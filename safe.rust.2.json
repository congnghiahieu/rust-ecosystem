[
  {
    "project": "",
    "target": 0,
    "commit_id": "93117b7add1d7e9b135c636836dbf827e15ed609",
    "func": "#![cfg_attr(docsrs, feature(doc_auto_cfg))]\n#![forbid(unsafe_code)]\n#![doc(\n    html_logo_url = \"https://bevyengine.org/assets/icon.png\",\n    html_favicon_url = \"https://bevyengine.org/assets/icon.png\"\n)]\n\n//! Plugin providing an [`AssetLoader`](bevy_asset::AssetLoader) and type definitions\n//! for loading glTF 2.0 (a standard 3D scene definition format) files in Bevy.\n//!\n//! The [glTF 2.0 specification](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html) defines the format of the glTF files.\n//!\n//! # Quick Start\n//!\n//! Here's how to spawn a simple glTF scene\n//!\n//! ```\n//! # use bevy_ecs::prelude::*;\n//! # use bevy_asset::prelude::*;\n//! # use bevy_scene::prelude::*;\n//! # use bevy_transform::prelude::*;\n//! # use bevy_gltf::prelude::*;\n//!\n//! fn spawn_gltf(mut commands: Commands, asset_server: Res<AssetServer>) {\n//!     commands.spawn((\n//!         // This is equivalent to \"models/FlightHelmet/FlightHelmet.gltf#Scene0\"\n//!         // The `#Scene0` label here is very important because it tells bevy to load the first scene in the glTF file.\n//!         // If this isn't specified bevy doesn't know which part of the glTF file to load.\n//!         SceneRoot(asset_server.load(GltfAssetLabel::Scene(0).from_asset(\"models/FlightHelmet/FlightHelmet.gltf\"))),\n//!         // You can use the transform to give it a position\n//!         Transform::from_xyz(2.0, 0.0, -5.0),\n//!     ));\n//! }\n//! ```\n//! # Loading parts of a glTF asset\n//!\n//! ## Using `Gltf`\n//!\n//! If you want to access part of the asset, you can load the entire `Gltf` using the `AssetServer`.\n//! Once the `Handle<Gltf>` is loaded you can then use it to access named parts of it.\n//!\n//! ```\n//! # use bevy_ecs::prelude::*;\n//! # use bevy_asset::prelude::*;\n//! # use bevy_scene::prelude::*;\n//! # use bevy_transform::prelude::*;\n//! # use bevy_gltf::Gltf;\n//!\n//! // Holds the scene handle\n//! #[derive(Resource)]\n//! struct HelmetScene(Handle<Gltf>);\n//!\n//! fn load_gltf(mut commands: Commands, asset_server: Res<AssetServer>) {\n//!     let gltf = asset_server.load(\"models/FlightHelmet/FlightHelmet.gltf\");\n//!     commands.insert_resource(HelmetScene(gltf));\n//! }\n//!\n//! fn spawn_gltf_objects(\n//!     mut commands: Commands,\n//!     helmet_scene: Res<HelmetScene>,\n//!     gltf_assets: Res<Assets<Gltf>>,\n//!     mut loaded: Local<bool>,\n//! ) {\n//!     // Only do this once\n//!     if *loaded {\n//!         return;\n//!     }\n//!     // Wait until the scene is loaded\n//!     let Some(gltf) = gltf_assets.get(&helmet_scene.0) else {\n//!         return;\n//!     };\n//!     *loaded = true;\n//!\n//!     // Spawns the first scene in the file\n//!     commands.spawn(SceneRoot(gltf.scenes[0].clone()));\n//!\n//!     // Spawns the scene named \"Lenses_low\"\n//!     commands.spawn((\n//!         SceneRoot(gltf.named_scenes[\"Lenses_low\"].clone()),\n//!         Transform::from_xyz(1.0, 2.0, 3.0),\n//!     ));\n//! }\n//! ```\n//!\n//! ## Asset Labels\n//!\n//! The glTF loader let's you specify labels that let you target specific parts of the glTF.\n//!\n//! Be careful when using this feature, if you misspell a label it will simply ignore it without warning.\n//!\n//! You can use [`GltfAssetLabel`] to ensure you are using the correct label.\n\nextern crate alloc;\n\n#[cfg(feature = \"bevy_animation\")]\nuse bevy_animation::AnimationClip;\nuse bevy_utils::HashMap;\n\nmod loader;\nmod vertex_attributes;\npub use loader::*;\n\nuse bevy_app::prelude::*;\nuse bevy_asset::{Asset, AssetApp, AssetPath, Handle};\nuse bevy_ecs::{prelude::Component, reflect::ReflectComponent};\nuse bevy_pbr::StandardMaterial;\nuse bevy_reflect::{std_traits::ReflectDefault, Reflect, TypePath};\nuse bevy_render::{\n    mesh::{skinning::SkinnedMeshInverseBindposes, Mesh, MeshVertexAttribute},\n    renderer::RenderDevice,\n    texture::CompressedImageFormats,\n};\nuse bevy_scene::Scene;\n\n/// The glTF prelude.\n///\n/// This includes the most common types in this crate, re-exported for your convenience.\npub mod prelude {\n    #[doc(hidden)]\n    pub use crate::{Gltf, GltfAssetLabel, GltfExtras};\n}\n\n/// Adds support for glTF file loading to the app.\n#[derive(Default)]\npub struct GltfPlugin {\n    custom_vertex_attributes: HashMap<Box<str>, MeshVertexAttribute>,\n}\n\nimpl GltfPlugin {\n    /// Register a custom vertex attribute so that it is recognized when loading a glTF file with the [`GltfLoader`].\n    ///\n    /// `name` must be the attribute name as found in the glTF data, which must start with an underscore.\n    /// See [this section of the glTF specification](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)\n    /// for additional details on custom attributes.\n    pub fn add_custom_vertex_attribute(\n        mut self,\n        name: &str,\n        attribute: MeshVertexAttribute,\n    ) -> Self {\n        self.custom_vertex_attributes.insert(name.into(), attribute);\n        self\n    }\n}\n\nimpl Plugin for GltfPlugin {\n    fn build(&self, app: &mut App) {\n        app.register_type::<GltfExtras>()\n            .register_type::<GltfSceneExtras>()\n            .register_type::<GltfMeshExtras>()\n            .register_type::<GltfMaterialExtras>()\n            .register_type::<GltfMaterialName>()\n            .init_asset::<Gltf>()\n            .init_asset::<GltfNode>()\n            .init_asset::<GltfPrimitive>()\n            .init_asset::<GltfMesh>()\n            .init_asset::<GltfSkin>()\n            .preregister_asset_loader::<GltfLoader>(&[\"gltf\", \"glb\"]);\n    }\n\n    fn finish(&self, app: &mut App) {\n        let supported_compressed_formats = match app.world().get_resource::<RenderDevice>() {\n            Some(render_device) => CompressedImageFormats::from_features(render_device.features()),\n            None => CompressedImageFormats::NONE,\n        };\n        app.register_asset_loader(GltfLoader {\n            supported_compressed_formats,\n            custom_vertex_attributes: self.custom_vertex_attributes.clone(),\n        });\n    }\n}\n\n/// Representation of a loaded glTF file.\n#[derive(Asset, Debug, TypePath)]\npub struct Gltf {\n    /// All scenes loaded from the glTF file.\n    pub scenes: Vec<Handle<Scene>>,\n    /// Named scenes loaded from the glTF file.\n    pub named_scenes: HashMap<Box<str>, Handle<Scene>>,\n    /// All meshes loaded from the glTF file.\n    pub meshes: Vec<Handle<GltfMesh>>,\n    /// Named meshes loaded from the glTF file.\n    pub named_meshes: HashMap<Box<str>, Handle<GltfMesh>>,\n    /// All materials loaded from the glTF file.\n    pub materials: Vec<Handle<StandardMaterial>>,\n    /// Named materials loaded from the glTF file.\n    pub named_materials: HashMap<Box<str>, Handle<StandardMaterial>>,\n    /// All nodes loaded from the glTF file.\n    pub nodes: Vec<Handle<GltfNode>>,\n    /// Named nodes loaded from the glTF file.\n    pub named_nodes: HashMap<Box<str>, Handle<GltfNode>>,\n    /// All skins loaded from the glTF file.\n    pub skins: Vec<Handle<GltfSkin>>,\n    /// Named skins loaded from the glTF file.\n    pub named_skins: HashMap<Box<str>, Handle<GltfSkin>>,\n    /// Default scene to be displayed.\n    pub default_scene: Option<Handle<Scene>>,\n    /// All animations loaded from the glTF file.\n    #[cfg(feature = \"bevy_animation\")]\n    pub animations: Vec<Handle<AnimationClip>>,\n    /// Named animations loaded from the glTF file.\n    #[cfg(feature = \"bevy_animation\")]\n    pub named_animations: HashMap<Box<str>, Handle<AnimationClip>>,\n    /// The gltf root of the gltf asset, see <https://docs.rs/gltf/latest/gltf/struct.Gltf.html>. Only has a value when `GltfLoaderSettings::include_source` is true.\n    pub source: Option<gltf::Gltf>,\n}\n\n/// A glTF node with all of its child nodes, its [`GltfMesh`],\n/// [`Transform`](bevy_transform::prelude::Transform), its optional [`GltfSkin`]\n/// and an optional [`GltfExtras`].\n///\n/// See [the relevant glTF specification section](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-node).\n#[derive(Asset, Debug, Clone, TypePath)]\npub struct GltfNode {\n    /// Index of the node inside the scene\n    pub index: usize,\n    /// Computed name for a node - either a user defined node name from gLTF or a generated name from index\n    pub name: String,\n    /// Direct children of the node.\n    pub children: Vec<Handle<GltfNode>>,\n    /// Mesh of the node.\n    pub mesh: Option<Handle<GltfMesh>>,\n    /// Skin of the node.\n    pub skin: Option<Handle<GltfSkin>>,\n    /// Local transform.\n    pub transform: bevy_transform::prelude::Transform,\n    /// Is this node used as an animation root\n    #[cfg(feature = \"bevy_animation\")]\n    pub is_animation_root: bool,\n    /// Additional data.\n    pub extras: Option<GltfExtras>,\n}\n\nimpl GltfNode {\n    /// Create a node extracting name and index from glTF def\n    pub fn new(\n        node: &gltf::Node,\n        children: Vec<Handle<GltfNode>>,\n        mesh: Option<Handle<GltfMesh>>,\n        transform: bevy_transform::prelude::Transform,\n        skin: Option<Handle<GltfSkin>>,\n        extras: Option<GltfExtras>,\n    ) -> Self {\n        Self {\n            index: node.index(),\n            name: if let Some(name) = node.name() {\n                name.to_string()\n            } else {\n                format!(\"GltfNode{}\", node.index())\n            },\n            children,\n            mesh,\n            transform,\n            skin,\n            #[cfg(feature = \"bevy_animation\")]\n            is_animation_root: false,\n            extras,\n        }\n    }\n\n    /// Create a node with animation root mark\n    #[cfg(feature = \"bevy_animation\")]\n    pub fn with_animation_root(self, is_animation_root: bool) -> Self {\n        Self {\n            is_animation_root,\n            ..self\n        }\n    }\n\n    /// Subasset label for this node within the gLTF parent asset.\n    pub fn asset_label(&self) -> GltfAssetLabel {\n        GltfAssetLabel::Node(self.index)\n    }\n}\n\n/// A glTF skin with all of its joint nodes, [`SkinnedMeshInversiveBindposes`](bevy_render::mesh::skinning::SkinnedMeshInverseBindposes)\n/// and an optional [`GltfExtras`].\n///\n/// See [the relevant glTF specification section](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-skin).\n#[derive(Asset, Debug, Clone, TypePath)]\npub struct GltfSkin {\n    /// Index of the skin inside the scene\n    pub index: usize,\n    /// Computed name for a skin - either a user defined skin name from gLTF or a generated name from index\n    pub name: String,\n    /// All the nodes that form this skin.\n    pub joints: Vec<Handle<GltfNode>>,\n    /// Inverse-bind matricy of this skin.\n    pub inverse_bind_matrices: Handle<SkinnedMeshInverseBindposes>,\n    /// Additional data.\n    pub extras: Option<GltfExtras>,\n}\n\nimpl GltfSkin {\n    /// Create a skin extracting name and index from glTF def\n    pub fn new(\n        skin: &gltf::Skin,\n        joints: Vec<Handle<GltfNode>>,\n        inverse_bind_matrices: Handle<SkinnedMeshInverseBindposes>,\n        extras: Option<GltfExtras>,\n    ) -> Self {\n        Self {\n            index: skin.index(),\n            name: if let Some(name) = skin.name() {\n                name.to_string()\n            } else {\n                format!(\"GltfSkin{}\", skin.index())\n            },\n            joints,\n            inverse_bind_matrices,\n            extras,\n        }\n    }\n\n    /// Subasset label for this skin within the gLTF parent asset.\n    pub fn asset_label(&self) -> GltfAssetLabel {\n        GltfAssetLabel::Skin(self.index)\n    }\n}\n\n/// A glTF mesh, which may consist of multiple [`GltfPrimitives`](GltfPrimitive)\n/// and an optional [`GltfExtras`].\n///\n/// See [the relevant glTF specification section](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-mesh).\n#[derive(Asset, Debug, Clone, TypePath)]\npub struct GltfMesh {\n    /// Index of the mesh inside the scene\n    pub index: usize,\n    /// Computed name for a mesh - either a user defined mesh name from gLTF or a generated name from index\n    pub name: String,\n    /// Primitives of the glTF mesh.\n    pub primitives: Vec<GltfPrimitive>,\n    /// Additional data.\n    pub extras: Option<GltfExtras>,\n}\n\nimpl GltfMesh {\n    /// Create a mesh extracting name and index from glTF def\n    pub fn new(\n        mesh: &gltf::Mesh,\n        primitives: Vec<GltfPrimitive>,\n        extras: Option<GltfExtras>,\n    ) -> Self {\n        Self {\n            index: mesh.index(),\n            name: if let Some(name) = mesh.name() {\n                name.to_string()\n            } else {\n                format!(\"GltfMesh{}\", mesh.index())\n            },\n            primitives,\n            extras,\n        }\n    }\n\n    /// Subasset label for this mesh within the gLTF parent asset.\n    pub fn asset_label(&self) -> GltfAssetLabel {\n        GltfAssetLabel::Mesh(self.index)\n    }\n}\n\n/// Part of a [`GltfMesh`] that consists of a [`Mesh`], an optional [`StandardMaterial`] and [`GltfExtras`].\n///\n/// See [the relevant glTF specification section](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-mesh-primitive).\n#[derive(Asset, Debug, Clone, TypePath)]\npub struct GltfPrimitive {\n    /// Index of the primitive inside the mesh\n    pub index: usize,\n    /// Index of the parent [`GltfMesh`] of this primitive\n    pub parent_mesh_index: usize,\n    /// Computed name for a primitive - either a user defined primitive name from gLTF or a generated name from index\n    pub name: String,\n    /// Topology to be rendered.\n    pub mesh: Handle<Mesh>,\n    /// Material to apply to the `mesh`.\n    pub material: Option<Handle<StandardMaterial>>,\n    /// Additional data.\n    pub extras: Option<GltfExtras>,\n    /// Additional data of the `material`.\n    pub material_extras: Option<GltfExtras>,\n}\n\nimpl GltfPrimitive {\n    /// Create a primitive extracting name and index from glTF def\n    pub fn new(\n        gltf_mesh: &gltf::Mesh,\n        gltf_primitive: &gltf::Primitive,\n        mesh: Handle<Mesh>,\n        material: Option<Handle<StandardMaterial>>,\n        extras: Option<GltfExtras>,\n        material_extras: Option<GltfExtras>,\n    ) -> Self {\n        GltfPrimitive {\n            index: gltf_primitive.index(),\n            parent_mesh_index: gltf_mesh.index(),\n            name: {\n                let mesh_name = gltf_mesh.name().unwrap_or(\"Mesh\");\n                if gltf_mesh.primitives().len() > 1 {\n                    format!(\"{}.{}\", mesh_name, gltf_primitive.index())\n                } else {\n                    mesh_name.to_string()\n                }\n            },\n            mesh,\n            material,\n            extras,\n            material_extras,\n        }\n    }\n\n    /// Subasset label for this primitive within its parent [`GltfMesh`] within the gLTF parent asset.\n    pub fn asset_label(&self) -> GltfAssetLabel {\n        GltfAssetLabel::Primitive {\n            mesh: self.parent_mesh_index,\n            primitive: self.index,\n        }\n    }\n}\n\n/// Additional untyped data that can be present on most glTF types at the primitive level.\n///\n/// See [the relevant glTF specification section](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-extras).\n#[derive(Clone, Debug, Reflect, Default, Component)]\n#[reflect(Component, Default, Debug)]\npub struct GltfExtras {\n    /// Content of the extra data.\n    pub value: String,\n}\n\n/// Additional untyped data that can be present on most glTF types at the scene level.\n///\n/// See [the relevant glTF specification section](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-extras).\n#[derive(Clone, Debug, Reflect, Default, Component)]\n#[reflect(Component, Default, Debug)]\npub struct GltfSceneExtras {\n    /// Content of the extra data.\n    pub value: String,\n}\n\n/// Additional untyped data that can be present on most glTF types at the mesh level.\n///\n/// See [the relevant glTF specification section](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-extras).\n#[derive(Clone, Debug, Reflect, Default, Component)]\n#[reflect(Component, Default, Debug)]\npub struct GltfMeshExtras {\n    /// Content of the extra data.\n    pub value: String,\n}\n\n/// Additional untyped data that can be present on most glTF types at the material level.\n///\n/// See [the relevant glTF specification section](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-extras).\n#[derive(Clone, Debug, Reflect, Default, Component)]\n#[reflect(Component, Default, Debug)]\npub struct GltfMaterialExtras {\n    /// Content of the extra data.\n    pub value: String,\n}\n\n/// The material name of a glTF primitive.\n///\n/// See [the relevant glTF specification section](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#reference-material).\n#[derive(Clone, Debug, Reflect, Default, Component)]\n#[reflect(Component)]\npub struct GltfMaterialName(pub String);\n\n/// Labels that can be used to load part of a glTF\n///\n/// You can use [`GltfAssetLabel::from_asset`] to add it to an asset path\n///\n/// ```\n/// # use bevy_ecs::prelude::*;\n/// # use bevy_asset::prelude::*;\n/// # use bevy_scene::prelude::*;\n/// # use bevy_gltf::prelude::*;\n///\n/// fn load_gltf_scene(asset_server: Res<AssetServer>) {\n///     let gltf_scene: Handle<Scene> = asset_server.load(GltfAssetLabel::Scene(0).from_asset(\"models/FlightHelmet/FlightHelmet.gltf\"));\n/// }\n/// ```\n///\n/// Or when formatting a string for the path\n///\n/// ```\n/// # use bevy_ecs::prelude::*;\n/// # use bevy_asset::prelude::*;\n/// # use bevy_scene::prelude::*;\n/// # use bevy_gltf::prelude::*;\n///\n/// fn load_gltf_scene(asset_server: Res<AssetServer>) {\n///     let gltf_scene: Handle<Scene> = asset_server.load(format!(\"models/FlightHelmet/FlightHelmet.gltf#{}\", GltfAssetLabel::Scene(0)));\n/// }\n/// ```\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum GltfAssetLabel {\n    /// `Scene{}`: glTF Scene as a Bevy `Scene`\n    Scene(usize),\n    /// `Node{}`: glTF Node as a `GltfNode`\n    Node(usize),\n    /// `Mesh{}`: glTF Mesh as a `GltfMesh`\n    Mesh(usize),\n    /// `Mesh{}/Primitive{}`: glTF Primitive as a Bevy `Mesh`\n    Primitive {\n        /// Index of the mesh for this primitive\n        mesh: usize,\n        /// Index of this primitive in its parent mesh\n        primitive: usize,\n    },\n    /// `Mesh{}/Primitive{}/MorphTargets`: Morph target animation data for a glTF Primitive\n    MorphTarget {\n        /// Index of the mesh for this primitive\n        mesh: usize,\n        /// Index of this primitive in its parent mesh\n        primitive: usize,\n    },\n    /// `Texture{}`: glTF Texture as a Bevy `Image`\n    Texture(usize),\n    /// `Material{}`: glTF Material as a Bevy `StandardMaterial`\n    Material {\n        /// Index of this material\n        index: usize,\n        /// Used to set the [`Face`](bevy_render::render_resource::Face) of the material, useful if it is used with negative scale\n        is_scale_inverted: bool,\n    },\n    /// `DefaultMaterial`: as above, if the glTF file contains a default material with no index\n    DefaultMaterial,\n    /// `Animation{}`: glTF Animation as Bevy `AnimationClip`\n    Animation(usize),\n    /// `Skin{}`: glTF mesh skin as `GltfSkin`\n    Skin(usize),\n    /// `Skin{}/InverseBindMatrices`: glTF mesh skin matrices as Bevy `SkinnedMeshInverseBindposes`\n    InverseBindMatrices(usize),\n}\n\nimpl core::fmt::Display for GltfAssetLabel {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        match self {\n            GltfAssetLabel::Scene(index) => f.write_str(&format!(\"Scene{index}\")),\n            GltfAssetLabel::Node(index) => f.write_str(&format!(\"Node{index}\")),\n            GltfAssetLabel::Mesh(index) => f.write_str(&format!(\"Mesh{index}\")),\n            GltfAssetLabel::Primitive { mesh, primitive } => {\n                f.write_str(&format!(\"Mesh{mesh}/Primitive{primitive}\"))\n            }\n            GltfAssetLabel::MorphTarget { mesh, primitive } => {\n                f.write_str(&format!(\"Mesh{mesh}/Primitive{primitive}/MorphTargets\"))\n            }\n            GltfAssetLabel::Texture(index) => f.write_str(&format!(\"Texture{index}\")),\n            GltfAssetLabel::Material {\n                index,\n                is_scale_inverted,\n            } => f.write_str(&format!(\n                \"Material{index}{}\",\n                if *is_scale_inverted {\n                    \" (inverted)\"\n                } else {\n                    \"\"\n                }\n            )),\n            GltfAssetLabel::DefaultMaterial => f.write_str(\"DefaultMaterial\"),\n            GltfAssetLabel::Animation(index) => f.write_str(&format!(\"Animation{index}\")),\n            GltfAssetLabel::Skin(index) => f.write_str(&format!(\"Skin{index}\")),\n            GltfAssetLabel::InverseBindMatrices(index) => {\n                f.write_str(&format!(\"Skin{index}/InverseBindMatrices\"))\n            }\n        }\n    }\n}\n\nimpl GltfAssetLabel {\n    /// Add this label to an asset path\n    ///\n    /// ```\n    /// # use bevy_ecs::prelude::*;\n    /// # use bevy_asset::prelude::*;\n    /// # use bevy_scene::prelude::*;\n    /// # use bevy_gltf::prelude::*;\n    ///\n    /// fn load_gltf_scene(asset_server: Res<AssetServer>) {\n    ///     let gltf_scene: Handle<Scene> = asset_server.load(GltfAssetLabel::Scene(0).from_asset(\"models/FlightHelmet/FlightHelmet.gltf\"));\n    /// }\n    /// ```\n    pub fn from_asset(&self, path: impl Into<AssetPath<'static>>) -> AssetPath<'static> {\n        path.into().with_label(self.to_string())\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "8712413af5471a3603ab4d5bf7647996a2fc6227",
    "func": "use sea_query_attr::enum_def;\n\n#[enum_def(prefix = \"\", suffix = \"Def\")]\npub struct Hello {\n    pub name: String\n}\n\nfn main() {\n    println!(\"{:?}\", HelloDef::Name);\n}"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "782a2169bd0822f8f1e730b724b5604c38a95ba7",
    "func": "use crate::{Children, HierarchyEvent, Parent};\nuse bevy_ecs::{\n    bundle::Bundle,\n    entity::Entity,\n    prelude::Events,\n    system::{Commands, EntityCommands},\n    world::{Command, EntityWorldMut, World},\n};\nuse smallvec::{smallvec, SmallVec};\n\n// Do not use `world.send_event_batch` as it prints error message when the Events are not available in the world,\n// even though it's a valid use case to execute commands on a world without events. Loading a GLTF file for example\nfn push_events(world: &mut World, events: impl IntoIterator<Item = HierarchyEvent>) {\n    if let Some(mut moved) = world.get_resource_mut::<Events<HierarchyEvent>>() {\n        moved.extend(events);\n    }\n}\n\n/// Adds `child` to `parent`'s [`Children`], without checking if it is already present there.\n///\n/// This might cause unexpected results when removing duplicate children.\nfn add_child_unchecked(world: &mut World, parent: Entity, child: Entity) {\n    let mut parent = world.entity_mut(parent);\n    if let Some(mut children) = parent.get_mut::<Children>() {\n        children.0.push(child);\n    } else {\n        parent.insert(Children(smallvec![child]));\n    }\n}\n\n/// Sets [`Parent`] of the `child` to `new_parent`. Inserts [`Parent`] if `child` doesn't have one.\nfn update_parent(world: &mut World, child: Entity, new_parent: Entity) -> Option<Entity> {\n    let mut child = world.entity_mut(child);\n    if let Some(mut parent) = child.get_mut::<Parent>() {\n        let previous = parent.0;\n        *parent = Parent(new_parent);\n        Some(previous)\n    } else {\n        child.insert(Parent(new_parent));\n        None\n    }\n}\n\n/// Remove child from the parent's [`Children`] component.\n///\n/// Removes the [`Children`] component from the parent if it's empty.\nfn remove_from_children(world: &mut World, parent: Entity, child: Entity) {\n    let Ok(mut parent) = world.get_entity_mut(parent) else {\n        return;\n    };\n    let Some(mut children) = parent.get_mut::<Children>() else {\n        return;\n    };\n    children.0.retain(|x| *x != child);\n    if children.is_empty() {\n        parent.remove::<Children>();\n    }\n}\n\n/// Update the [`Parent`] component of the `child`.\n/// Removes the `child` from the previous parent's [`Children`].\n///\n/// Does not update the new parents [`Children`] component.\n///\n/// Does nothing if `child` was already a child of `parent`.\n///\n/// Sends [`HierarchyEvent`]'s.\nfn update_old_parent(world: &mut World, child: Entity, parent: Entity) {\n    let previous = update_parent(world, child, parent);\n    if let Some(previous_parent) = previous {\n        // Do nothing if the child was already parented to this entity.\n        if previous_parent == parent {\n            return;\n        }\n        remove_from_children(world, previous_parent, child);\n\n        push_events(\n            world,\n            [HierarchyEvent::ChildMoved {\n                child,\n                previous_parent,\n                new_parent: parent,\n            }],\n        );\n    } else {\n        push_events(world, [HierarchyEvent::ChildAdded { child, parent }]);\n    }\n}\n\n/// Update the [`Parent`] components of the `children`.\n/// Removes the `children` from their previous parent's [`Children`].\n///\n/// Does not update the new parents [`Children`] component.\n///\n/// Does nothing for a child if it was already a child of `parent`.\n///\n/// Sends [`HierarchyEvent`]'s.\nfn update_old_parents(world: &mut World, parent: Entity, children: &[Entity]) {\n    let mut events: SmallVec<[HierarchyEvent; 8]> = SmallVec::with_capacity(children.len());\n    for &child in children {\n        if let Some(previous) = update_parent(world, child, parent) {\n            // Do nothing if the entity already has the correct parent.\n            if parent == previous {\n                continue;\n            }\n\n            remove_from_children(world, previous, child);\n            events.push(HierarchyEvent::ChildMoved {\n                child,\n                previous_parent: previous,\n                new_parent: parent,\n            });\n        } else {\n            events.push(HierarchyEvent::ChildAdded { child, parent });\n        }\n    }\n    push_events(world, events);\n}\n\n/// Removes entities in `children` from `parent`'s [`Children`], removing the component if it ends up empty.\n/// Also removes [`Parent`] component from `children`.\nfn remove_children(parent: Entity, children: &[Entity], world: &mut World) {\n    let mut events: SmallVec<[HierarchyEvent; 8]> = SmallVec::new();\n    if let Some(parent_children) = world.get::<Children>(parent) {\n        for &child in children {\n            if parent_children.contains(&child) {\n                events.push(HierarchyEvent::ChildRemoved { child, parent });\n            }\n        }\n    } else {\n        return;\n    }\n    for event in &events {\n        if let &HierarchyEvent::ChildRemoved { child, .. } = event {\n            world.entity_mut(child).remove::<Parent>();\n        }\n    }\n    push_events(world, events);\n\n    let mut parent = world.entity_mut(parent);\n    if let Some(mut parent_children) = parent.get_mut::<Children>() {\n        parent_children\n            .0\n            .retain(|parent_child| !children.contains(parent_child));\n\n        if parent_children.is_empty() {\n            parent.remove::<Children>();\n        }\n    }\n}\n\n/// Removes all children from `parent` by removing its [`Children`] component, as well as removing\n/// [`Parent`] component from its children.\nfn clear_children(parent: Entity, world: &mut World) {\n    if let Some(children) = world.entity_mut(parent).take::<Children>() {\n        for &child in &children.0 {\n            world.entity_mut(child).remove::<Parent>();\n        }\n    }\n}\n\n/// Command that adds a child to an entity.\n#[derive(Debug)]\npub struct AddChild {\n    /// Parent entity to add the child to.\n    pub parent: Entity,\n    /// Child entity to add.\n    pub child: Entity,\n}\n\nimpl Command for AddChild {\n    fn apply(self, world: &mut World) {\n        world.entity_mut(self.parent).add_child(self.child);\n    }\n}\n\n/// Command that inserts a child at a given index of a parent's children, shifting following children back.\n#[derive(Debug)]\npub struct InsertChildren {\n    parent: Entity,\n    children: SmallVec<[Entity; 8]>,\n    index: usize,\n}\n\nimpl Command for InsertChildren {\n    fn apply(self, world: &mut World) {\n        world\n            .entity_mut(self.parent)\n            .insert_children(self.index, &self.children);\n    }\n}\n\n/// Command that pushes children to the end of the entity's [`Children`].\n#[derive(Debug)]\npub struct AddChildren {\n    parent: Entity,\n    children: SmallVec<[Entity; 8]>,\n}\n\nimpl Command for AddChildren {\n    fn apply(self, world: &mut World) {\n        world.entity_mut(self.parent).add_children(&self.children);\n    }\n}\n\n/// Command that removes children from an entity, and removes these children's parent.\npub struct RemoveChildren {\n    parent: Entity,\n    children: SmallVec<[Entity; 8]>,\n}\n\nimpl Command for RemoveChildren {\n    fn apply(self, world: &mut World) {\n        remove_children(self.parent, &self.children, world);\n    }\n}\n\n/// Command that clears all children from an entity and removes [`Parent`] component from those\n/// children.\npub struct ClearChildren {\n    parent: Entity,\n}\n\nimpl Command for ClearChildren {\n    fn apply(self, world: &mut World) {\n        clear_children(self.parent, world);\n    }\n}\n\n/// Command that clear all children from an entity, replacing them with the given children.\npub struct ReplaceChildren {\n    parent: Entity,\n    children: SmallVec<[Entity; 8]>,\n}\n\nimpl Command for ReplaceChildren {\n    fn apply(self, world: &mut World) {\n        clear_children(self.parent, world);\n        world.entity_mut(self.parent).add_children(&self.children);\n    }\n}\n\n/// Command that removes the parent of an entity, and removes that entity from the parent's [`Children`].\npub struct RemoveParent {\n    /// `Entity` whose parent must be removed.\n    pub child: Entity,\n}\n\nimpl Command for RemoveParent {\n    fn apply(self, world: &mut World) {\n        world.entity_mut(self.child).remove_parent();\n    }\n}\n\n/// Struct for building children entities and adding them to a parent entity.\n///\n/// # Example\n///\n/// This example creates three entities, a parent and two children.\n///\n/// ```\n/// # use bevy_ecs::bundle::Bundle;\n/// # use bevy_ecs::system::Commands;\n/// # use bevy_hierarchy::{ChildBuild, BuildChildren};\n/// # #[derive(Bundle)]\n/// # struct MyBundle {}\n/// # #[derive(Bundle)]\n/// # struct MyChildBundle {}\n/// #\n/// # fn test(mut commands: Commands) {\n/// commands.spawn(MyBundle {}).with_children(|child_builder| {\n///     child_builder.spawn(MyChildBundle {});\n///     child_builder.spawn(MyChildBundle {});\n/// });\n/// # }\n/// ```\npub struct ChildBuilder<'a> {\n    commands: Commands<'a, 'a>,\n    add_children: AddChildren,\n}\n\n/// Trait for building children entities and adding them to a parent entity. This is used in\n/// implementations of [`BuildChildren`] as a bound on the [`Builder`](BuildChildren::Builder)\n/// associated type. The closure passed to [`BuildChildren::with_children`] accepts an\n/// implementation of `ChildBuild` so that children can be spawned via [`ChildBuild::spawn`].\npub trait ChildBuild {\n    /// Spawn output type. Both [`spawn`](Self::spawn) and [`spawn_empty`](Self::spawn_empty) return\n    /// an implementation of this type so that children can be operated on via method-chaining.\n    /// Implementations of `ChildBuild` reborrow `self` when spawning entities (see\n    /// [`Commands::spawn_empty`] and [`World::get_entity_mut`]). Lifetime `'a` corresponds to this\n    /// reborrowed self, and `Self` outlives it.\n    type SpawnOutput<'a>: BuildChildren\n    where\n        Self: 'a;\n\n    /// Spawns an entity with the given bundle and inserts it into the parent entity's [`Children`].\n    /// Also adds [`Parent`] component to the created entity.\n    fn spawn(&mut self, bundle: impl Bundle) -> Self::SpawnOutput<'_>;\n\n    /// Spawns an [`Entity`] with no components and inserts it into the parent entity's [`Children`].\n    /// Also adds [`Parent`] component to the created entity.\n    fn spawn_empty(&mut self) -> Self::SpawnOutput<'_>;\n\n    /// Returns the parent entity.\n    fn parent_entity(&self) -> Entity;\n\n    /// Adds a command to be executed, like [`Commands::queue`].\n    fn enqueue_command<C: Command>(&mut self, command: C) -> &mut Self;\n}\n\nimpl ChildBuild for ChildBuilder<'_> {\n    type SpawnOutput<'a>\n        = EntityCommands<'a>\n    where\n        Self: 'a;\n\n    fn spawn(&mut self, bundle: impl Bundle) -> EntityCommands {\n        let e = self.commands.spawn(bundle);\n        self.add_children.children.push(e.id());\n        e\n    }\n\n    fn spawn_empty(&mut self) -> EntityCommands {\n        let e = self.commands.spawn_empty();\n        self.add_children.children.push(e.id());\n        e\n    }\n\n    fn parent_entity(&self) -> Entity {\n        self.add_children.parent\n    }\n\n    fn enqueue_command<C: Command>(&mut self, command: C) -> &mut Self {\n        self.commands.queue(command);\n        self\n    }\n}\n\n/// Trait for removing, adding and replacing children and parents of an entity.\npub trait BuildChildren {\n    /// Child builder type.\n    type Builder<'a>: ChildBuild;\n\n    /// Takes a closure which builds children for this entity using [`ChildBuild`].\n    ///\n    /// For convenient spawning of a single child, you can use [`with_child`].\n    ///\n    /// [`with_child`]: BuildChildren::with_child\n    fn with_children(&mut self, f: impl FnOnce(&mut Self::Builder<'_>)) -> &mut Self;\n\n    /// Spawns the passed bundle and adds it to this entity as a child.\n    ///\n    /// For efficient spawning of multiple children, use [`with_children`].\n    ///\n    /// [`with_children`]: BuildChildren::with_children\n    fn with_child<B: Bundle>(&mut self, bundle: B) -> &mut Self;\n\n    /// Pushes children to the back of the builder's children. For any entities that are\n    /// already a child of this one, this method does nothing.\n    ///\n    /// If the children were previously children of another parent, that parent's [`Children`] component\n    /// will have those children removed from its list. Removing all children from a parent causes its\n    /// [`Children`] component to be removed from the entity.\n    ///\n    /// # Panics\n    ///\n    /// Panics if any of the children are the same as the parent.\n    fn add_children(&mut self, children: &[Entity]) -> &mut Self;\n\n    /// Inserts children at the given index.\n    ///\n    /// If the children were previously children of another parent, that parent's [`Children`] component\n    /// will have those children removed from its list. Removing all children from a parent causes its\n    /// [`Children`] component to be removed from the entity.\n    ///\n    /// # Panics\n    ///\n    /// Panics if any of the children are the same as the parent.\n    fn insert_children(&mut self, index: usize, children: &[Entity]) -> &mut Self;\n\n    /// Removes the given children\n    ///\n    /// Removing all children from a parent causes its [`Children`] component to be removed from the entity.\n    fn remove_children(&mut self, children: &[Entity]) -> &mut Self;\n\n    /// Adds a single child.\n    ///\n    /// If the children were previously children of another parent, that parent's [`Children`] component\n    /// will have those children removed from its list. Removing all children from a parent causes its\n    /// [`Children`] component to be removed from the entity.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the child is the same as the parent.\n    fn add_child(&mut self, child: Entity) -> &mut Self;\n\n    /// Removes all children from this entity. The [`Children`] component will be removed if it exists, otherwise this does nothing.\n    fn clear_children(&mut self) -> &mut Self;\n\n    /// Removes all current children from this entity, replacing them with the specified list of entities.\n    ///\n    /// The removed children will have their [`Parent`] component removed.\n    ///\n    /// # Panics\n    ///\n    /// Panics if any of the children are the same as the parent.\n    fn replace_children(&mut self, children: &[Entity]) -> &mut Self;\n\n    /// Sets the parent of this entity.\n    ///\n    /// If this entity already had a parent, the parent's [`Children`] component will have this\n    /// child removed from its list. Removing all children from a parent causes its [`Children`]\n    /// component to be removed from the entity.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the parent is the same as the child.\n    fn set_parent(&mut self, parent: Entity) -> &mut Self;\n\n    /// Removes the [`Parent`] of this entity.\n    ///\n    /// Also removes this entity from its parent's [`Children`] component. Removing all children from a parent causes\n    /// its [`Children`] component to be removed from the entity.\n    fn remove_parent(&mut self) -> &mut Self;\n}\n\nimpl BuildChildren for EntityCommands<'_> {\n    type Builder<'a> = ChildBuilder<'a>;\n\n    fn with_children(&mut self, spawn_children: impl FnOnce(&mut Self::Builder<'_>)) -> &mut Self {\n        let parent = self.id();\n        let mut builder = ChildBuilder {\n            commands: self.commands(),\n            add_children: AddChildren {\n                children: SmallVec::default(),\n                parent,\n            },\n        };\n\n        spawn_children(&mut builder);\n        let children = builder.add_children;\n        if children.children.contains(&parent) {\n            panic!(\"Entity cannot be a child of itself.\");\n        }\n        self.commands().queue(children);\n        self\n    }\n\n    fn with_child<B: Bundle>(&mut self, bundle: B) -> &mut Self {\n        let parent = self.id();\n        let child = self.commands().spawn(bundle).id();\n        self.commands().queue(AddChild { parent, child });\n        self\n    }\n\n    fn add_children(&mut self, children: &[Entity]) -> &mut Self {\n        let parent = self.id();\n        if children.contains(&parent) {\n            panic!(\"Cannot push entity as a child of itself.\");\n        }\n        self.commands().queue(AddChildren {\n            children: SmallVec::from(children),\n            parent,\n        });\n        self\n    }\n\n    fn insert_children(&mut self, index: usize, children: &[Entity]) -> &mut Self {\n        let parent = self.id();\n        if children.contains(&parent) {\n            panic!(\"Cannot insert entity as a child of itself.\");\n        }\n        self.commands().queue(InsertChildren {\n            children: SmallVec::from(children),\n            index,\n            parent,\n        });\n        self\n    }\n\n    fn remove_children(&mut self, children: &[Entity]) -> &mut Self {\n        let parent = self.id();\n        self.commands().queue(RemoveChildren {\n            children: SmallVec::from(children),\n            parent,\n        });\n        self\n    }\n\n    fn add_child(&mut self, child: Entity) -> &mut Self {\n        let parent = self.id();\n        if child == parent {\n            panic!(\"Cannot add entity as a child of itself.\");\n        }\n        self.commands().queue(AddChild { child, parent });\n        self\n    }\n\n    fn clear_children(&mut self) -> &mut Self {\n        let parent = self.id();\n        self.commands().queue(ClearChildren { parent });\n        self\n    }\n\n    fn replace_children(&mut self, children: &[Entity]) -> &mut Self {\n        let parent = self.id();\n        if children.contains(&parent) {\n            panic!(\"Cannot replace entity as a child of itself.\");\n        }\n        self.commands().queue(ReplaceChildren {\n            children: SmallVec::from(children),\n            parent,\n        });\n        self\n    }\n\n    fn set_parent(&mut self, parent: Entity) -> &mut Self {\n        let child = self.id();\n        if child == parent {\n            panic!(\"Cannot set parent to itself\");\n        }\n        self.commands().queue(AddChild { child, parent });\n        self\n    }\n\n    fn remove_parent(&mut self) -> &mut Self {\n        let child = self.id();\n        self.commands().queue(RemoveParent { child });\n        self\n    }\n}\n\n/// Struct for adding children to an entity directly through the [`World`] for use in exclusive systems.\n#[derive(Debug)]\npub struct WorldChildBuilder<'w> {\n    world: &'w mut World,\n    parent: Entity,\n}\n\nimpl ChildBuild for WorldChildBuilder<'_> {\n    type SpawnOutput<'a>\n        = EntityWorldMut<'a>\n    where\n        Self: 'a;\n\n    fn spawn(&mut self, bundle: impl Bundle) -> EntityWorldMut {\n        let entity = self.world.spawn((bundle, Parent(self.parent))).id();\n        add_child_unchecked(self.world, self.parent, entity);\n        push_events(\n            self.world,\n            [HierarchyEvent::ChildAdded {\n                child: entity,\n                parent: self.parent,\n            }],\n        );\n        self.world.entity_mut(entity)\n    }\n\n    fn spawn_empty(&mut self) -> EntityWorldMut {\n        let entity = self.world.spawn(Parent(self.parent)).id();\n        add_child_unchecked(self.world, self.parent, entity);\n        push_events(\n            self.world,\n            [HierarchyEvent::ChildAdded {\n                child: entity,\n                parent: self.parent,\n            }],\n        );\n        self.world.entity_mut(entity)\n    }\n\n    fn parent_entity(&self) -> Entity {\n        self.parent\n    }\n\n    fn enqueue_command<C: Command>(&mut self, command: C) -> &mut Self {\n        command.apply(self.world);\n        self\n    }\n}\n\nimpl BuildChildren for EntityWorldMut<'_> {\n    type Builder<'a> = WorldChildBuilder<'a>;\n\n    fn with_children(&mut self, spawn_children: impl FnOnce(&mut WorldChildBuilder)) -> &mut Self {\n        let parent = self.id();\n        self.world_scope(|world| {\n            spawn_children(&mut WorldChildBuilder { world, parent });\n        });\n        self\n    }\n\n    fn with_child<B: Bundle>(&mut self, bundle: B) -> &mut Self {\n        let parent = self.id();\n        let child = self.world_scope(|world| world.spawn((bundle, Parent(parent))).id());\n        if let Some(mut children_component) = self.get_mut::<Children>() {\n            children_component.0.retain(|value| child != *value);\n            children_component.0.push(child);\n        } else {\n            self.insert(Children::from_entities(&[child]));\n        }\n        self\n    }\n\n    fn add_child(&mut self, child: Entity) -> &mut Self {\n        let parent = self.id();\n        if child == parent {\n            panic!(\"Cannot add entity as a child of itself.\");\n        }\n        self.world_scope(|world| {\n            update_old_parent(world, child, parent);\n        });\n        if let Some(mut children_component) = self.get_mut::<Children>() {\n            children_component.0.retain(|value| child != *value);\n            children_component.0.push(child);\n        } else {\n            self.insert(Children::from_entities(&[child]));\n        }\n        self\n    }\n\n    fn add_children(&mut self, children: &[Entity]) -> &mut Self {\n        if children.is_empty() {\n            return self;\n        }\n\n        let parent = self.id();\n        if children.contains(&parent) {\n            panic!(\"Cannot push entity as a child of itself.\");\n        }\n        self.world_scope(|world| {\n            update_old_parents(world, parent, children);\n        });\n        if let Some(mut children_component) = self.get_mut::<Children>() {\n            children_component\n                .0\n                .retain(|value| !children.contains(value));\n            children_component.0.extend(children.iter().cloned());\n        } else {\n            self.insert(Children::from_entities(children));\n        }\n        self\n    }\n\n    fn insert_children(&mut self, index: usize, children: &[Entity]) -> &mut Self {\n        let parent = self.id();\n        if children.contains(&parent) {\n            panic!(\"Cannot insert entity as a child of itself.\");\n        }\n        self.world_scope(|world| {\n            update_old_parents(world, parent, children);\n        });\n        if let Some(mut children_component) = self.get_mut::<Children>() {\n            children_component\n                .0\n                .retain(|value| !children.contains(value));\n            children_component.0.insert_from_slice(index, children);\n        } else {\n            self.insert(Children::from_entities(children));\n        }\n        self\n    }\n\n    fn remove_children(&mut self, children: &[Entity]) -> &mut Self {\n        let parent = self.id();\n        self.world_scope(|world| {\n            remove_children(parent, children, world);\n        });\n        self\n    }\n\n    fn set_parent(&mut self, parent: Entity) -> &mut Self {\n        let child = self.id();\n        self.world_scope(|world| {\n            world.entity_mut(parent).add_child(child);\n        });\n        self\n    }\n\n    fn remove_parent(&mut self) -> &mut Self {\n        let child = self.id();\n        if let Some(parent) = self.take::<Parent>().map(|p| p.get()) {\n            self.world_scope(|world| {\n                remove_from_children(world, parent, child);\n                push_events(world, [HierarchyEvent::ChildRemoved { child, parent }]);\n            });\n        }\n        self\n    }\n\n    fn clear_children(&mut self) -> &mut Self {\n        let parent = self.id();\n        self.world_scope(|world| {\n            clear_children(parent, world);\n        });\n        self\n    }\n\n    fn replace_children(&mut self, children: &[Entity]) -> &mut Self {\n        self.clear_children().add_children(children)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{BuildChildren, ChildBuild};\n    use crate::{\n        components::{Children, Parent},\n        HierarchyEvent::{self, ChildAdded, ChildMoved, ChildRemoved},\n    };\n    use smallvec::{smallvec, SmallVec};\n\n    use bevy_ecs::{\n        component::Component,\n        entity::Entity,\n        event::Events,\n        system::Commands,\n        world::{CommandQueue, World},\n    };\n\n    /// Assert the (non)existence and state of the child's [`Parent`] component.\n    fn assert_parent(world: &World, child: Entity, parent: Option<Entity>) {\n        assert_eq!(world.get::<Parent>(child).map(Parent::get), parent);\n    }\n\n    /// Assert the (non)existence and state of the parent's [`Children`] component.\n    fn assert_children(world: &World, parent: Entity, children: Option<&[Entity]>) {\n        assert_eq!(world.get::<Children>(parent).map(|c| &**c), children);\n    }\n\n    /// Assert the number of children in the parent's [`Children`] component if it exists.\n    fn assert_num_children(world: &World, parent: Entity, num_children: usize) {\n        assert_eq!(\n            world.get::<Children>(parent).map(|c| c.len()).unwrap_or(0),\n            num_children\n        );\n    }\n\n    /// Used to omit a number of events that are not relevant to a particular test.\n    fn omit_events(world: &mut World, number: usize) {\n        let mut events_resource = world.resource_mut::<Events<HierarchyEvent>>();\n        let mut events: Vec<_> = events_resource.drain().collect();\n        events_resource.extend(events.drain(number..));\n    }\n\n    fn assert_events(world: &mut World, expected_events: &[HierarchyEvent]) {\n        let events: Vec<_> = world\n            .resource_mut::<Events<HierarchyEvent>>()\n            .drain()\n            .collect();\n        assert_eq!(events, expected_events);\n    }\n\n    #[test]\n    fn add_child() {\n        let world = &mut World::new();\n        world.insert_resource(Events::<HierarchyEvent>::default());\n\n        let [a, b, c, d] = core::array::from_fn(|_| world.spawn_empty().id());\n\n        world.entity_mut(a).add_child(b);\n\n        assert_parent(world, b, Some(a));\n        assert_children(world, a, Some(&[b]));\n        assert_events(\n            world,\n            &[ChildAdded {\n                child: b,\n                parent: a,\n            }],\n        );\n\n        world.entity_mut(a).add_child(c);\n\n        assert_children(world, a, Some(&[b, c]));\n        assert_parent(world, c, Some(a));\n        assert_events(\n            world,\n            &[ChildAdded {\n                child: c,\n                parent: a,\n            }],\n        );\n        // Children component should be removed when it's empty.\n        world.entity_mut(d).add_child(b).add_child(c);\n        assert_children(world, a, None);\n    }\n\n    #[test]\n    fn set_parent() {\n        let world = &mut World::new();\n        world.insert_resource(Events::<HierarchyEvent>::default());\n\n        let [a, b, c] = core::array::from_fn(|_| world.spawn_empty().id());\n\n        world.entity_mut(a).set_parent(b);\n\n        assert_parent(world, a, Some(b));\n        assert_children(world, b, Some(&[a]));\n        assert_events(\n            world,\n            &[ChildAdded {\n                child: a,\n                parent: b,\n            }],\n        );\n\n        world.entity_mut(a).set_parent(c);\n\n        assert_parent(world, a, Some(c));\n        assert_children(world, b, None);\n        assert_children(world, c, Some(&[a]));\n        assert_events(\n            world,\n            &[ChildMoved {\n                child: a,\n                previous_parent: b,\n                new_parent: c,\n            }],\n        );\n    }\n\n    // regression test for https://github.com/bevyengine/bevy/pull/8346\n    #[test]\n    fn set_parent_of_orphan() {\n        let world = &mut World::new();\n\n        let [a, b, c] = core::array::from_fn(|_| world.spawn_empty().id());\n        world.entity_mut(a).set_parent(b);\n        assert_parent(world, a, Some(b));\n        assert_children(world, b, Some(&[a]));\n\n        world.entity_mut(b).despawn();\n        world.entity_mut(a).set_parent(c);\n\n        assert_parent(world, a, Some(c));\n        assert_children(world, c, Some(&[a]));\n    }\n\n    #[test]\n    fn remove_parent() {\n        let world = &mut World::new();\n        world.insert_resource(Events::<HierarchyEvent>::default());\n\n        let [a, b, c] = core::array::from_fn(|_| world.spawn_empty().id());\n\n        world.entity_mut(a).add_children(&[b, c]);\n        world.entity_mut(b).remove_parent();\n\n        assert_parent(world, b, None);\n        assert_parent(world, c, Some(a));\n        assert_children(world, a, Some(&[c]));\n        omit_events(world, 2); // Omit ChildAdded events.\n        assert_events(\n            world,\n            &[ChildRemoved {\n                child: b,\n                parent: a,\n            }],\n        );\n\n        world.entity_mut(c).remove_parent();\n        assert_parent(world, c, None);\n        assert_children(world, a, None);\n        assert_events(\n            world,\n            &[ChildRemoved {\n                child: c,\n                parent: a,\n            }],\n        );\n    }\n\n    #[allow(dead_code)]\n    #[derive(Component)]\n    struct C(u32);\n\n    #[test]\n    fn build_children() {\n        let mut world = World::default();\n        let mut queue = CommandQueue::default();\n        let mut commands = Commands::new(&mut queue, &world);\n\n        let parent = commands.spawn(C(1)).id();\n        let mut children = Vec::new();\n        commands.entity(parent).with_children(|parent| {\n            children.extend([\n                parent.spawn(C(2)).id(),\n                parent.spawn(C(3)).id(),\n                parent.spawn(C(4)).id(),\n            ]);\n        });\n\n        queue.apply(&mut world);\n        assert_eq!(\n            world.get::<Children>(parent).unwrap().0.as_slice(),\n            children.as_slice(),\n        );\n        assert_eq!(*world.get::<Parent>(children[0]).unwrap(), Parent(parent));\n        assert_eq!(*world.get::<Parent>(children[1]).unwrap(), Parent(parent));\n\n        assert_eq!(*world.get::<Parent>(children[0]).unwrap(), Parent(parent));\n        assert_eq!(*world.get::<Parent>(children[1]).unwrap(), Parent(parent));\n    }\n\n    #[test]\n    fn build_child() {\n        let mut world = World::default();\n        let mut queue = CommandQueue::default();\n        let mut commands = Commands::new(&mut queue, &world);\n\n        let parent = commands.spawn(C(1)).id();\n        commands.entity(parent).with_child(C(2));\n\n        queue.apply(&mut world);\n        assert_eq!(world.get::<Children>(parent).unwrap().0.len(), 1);\n    }\n\n    #[test]\n    fn push_and_insert_and_remove_children_commands() {\n        let mut world = World::default();\n        let entities = world\n            .spawn_batch(vec![C(1), C(2), C(3), C(4), C(5)])\n            .collect::<Vec<Entity>>();\n\n        let mut queue = CommandQueue::default();\n        {\n            let mut commands = Commands::new(&mut queue, &world);\n            commands.entity(entities[0]).add_children(&entities[1..3]);\n        }\n        queue.apply(&mut world);\n\n        let parent = entities[0];\n        let child1 = entities[1];\n        let child2 = entities[2];\n        let child3 = entities[3];\n        let child4 = entities[4];\n\n        let expected_children: SmallVec<[Entity; 8]> = smallvec![child1, child2];\n        assert_eq!(\n            world.get::<Children>(parent).unwrap().0.clone(),\n            expected_children\n        );\n        assert_eq!(*world.get::<Parent>(child1).unwrap(), Parent(parent));\n        assert_eq!(*world.get::<Parent>(child2).unwrap(), Parent(parent));\n\n        assert_eq!(*world.get::<Parent>(child1).unwrap(), Parent(parent));\n        assert_eq!(*world.get::<Parent>(child2).unwrap(), Parent(parent));\n\n        {\n            let mut commands = Commands::new(&mut queue, &world);\n            commands.entity(parent).insert_children(1, &entities[3..]);\n        }\n        queue.apply(&mut world);\n\n        let expected_children: SmallVec<[Entity; 8]> = smallvec![child1, child3, child4, child2];\n        assert_eq!(\n            world.get::<Children>(parent).unwrap().0.clone(),\n            expected_children\n        );\n        assert_eq!(*world.get::<Parent>(child3).unwrap(), Parent(parent));\n        assert_eq!(*world.get::<Parent>(child4).unwrap(), Parent(parent));\n\n        let remove_children = [child1, child4];\n        {\n            let mut commands = Commands::new(&mut queue, &world);\n            commands.entity(parent).remove_children(&remove_children);\n        }\n        queue.apply(&mut world);\n\n        let expected_children: SmallVec<[Entity; 8]> = smallvec![child3, child2];\n        assert_eq!(\n            world.get::<Children>(parent).unwrap().0.clone(),\n            expected_children\n        );\n        assert!(world.get::<Parent>(child1).is_none());\n        assert!(world.get::<Parent>(child4).is_none());\n    }\n\n    #[test]\n    fn push_and_clear_children_commands() {\n        let mut world = World::default();\n        let entities = world\n            .spawn_batch(vec![C(1), C(2), C(3), C(4), C(5)])\n            .collect::<Vec<Entity>>();\n\n        let mut queue = CommandQueue::default();\n        {\n            let mut commands = Commands::new(&mut queue, &world);\n            commands.entity(entities[0]).add_children(&entities[1..3]);\n        }\n        queue.apply(&mut world);\n\n        let parent = entities[0];\n        let child1 = entities[1];\n        let child2 = entities[2];\n\n        let expected_children: SmallVec<[Entity; 8]> = smallvec![child1, child2];\n        assert_eq!(\n            world.get::<Children>(parent).unwrap().0.clone(),\n            expected_children\n        );\n        assert_eq!(*world.get::<Parent>(child1).unwrap(), Parent(parent));\n        assert_eq!(*world.get::<Parent>(child2).unwrap(), Parent(parent));\n\n        {\n            let mut commands = Commands::new(&mut queue, &world);\n            commands.entity(parent).clear_children();\n        }\n        queue.apply(&mut world);\n\n        assert!(world.get::<Children>(parent).is_none());\n\n        assert!(world.get::<Parent>(child1).is_none());\n        assert!(world.get::<Parent>(child2).is_none());\n    }\n\n    #[test]\n    fn push_and_replace_children_commands() {\n        let mut world = World::default();\n        let entities = world\n            .spawn_batch(vec![C(1), C(2), C(3), C(4), C(5)])\n            .collect::<Vec<Entity>>();\n\n        let mut queue = CommandQueue::default();\n        {\n            let mut commands = Commands::new(&mut queue, &world);\n            commands.entity(entities[0]).add_children(&entities[1..3]);\n        }\n        queue.apply(&mut world);\n\n        let parent = entities[0];\n        let child1 = entities[1];\n        let child2 = entities[2];\n        let child4 = entities[4];\n\n        let expected_children: SmallVec<[Entity; 8]> = smallvec![child1, child2];\n        assert_eq!(\n            world.get::<Children>(parent).unwrap().0.clone(),\n            expected_children\n        );\n        assert_eq!(*world.get::<Parent>(child1).unwrap(), Parent(parent));\n        assert_eq!(*world.get::<Parent>(child2).unwrap(), Parent(parent));\n\n        let replace_children = [child1, child4];\n        {\n            let mut commands = Commands::new(&mut queue, &world);\n            commands.entity(parent).replace_children(&replace_children);\n        }\n        queue.apply(&mut world);\n\n        let expected_children: SmallVec<[Entity; 8]> = smallvec![child1, child4];\n        assert_eq!(\n            world.get::<Children>(parent).unwrap().0.clone(),\n            expected_children\n        );\n        assert_eq!(*world.get::<Parent>(child1).unwrap(), Parent(parent));\n        assert_eq!(*world.get::<Parent>(child4).unwrap(), Parent(parent));\n        assert!(world.get::<Parent>(child2).is_none());\n    }\n\n    #[test]\n    fn push_and_insert_and_remove_children_world() {\n        let mut world = World::default();\n        let entities = world\n            .spawn_batch(vec![C(1), C(2), C(3), C(4), C(5)])\n            .collect::<Vec<Entity>>();\n\n        world.entity_mut(entities[0]).add_children(&entities[1..3]);\n\n        let parent = entities[0];\n        let child1 = entities[1];\n        let child2 = entities[2];\n        let child3 = entities[3];\n        let child4 = entities[4];\n\n        let expected_children: SmallVec<[Entity; 8]> = smallvec![child1, child2];\n        assert_eq!(\n            world.get::<Children>(parent).unwrap().0.clone(),\n            expected_children\n        );\n        assert_eq!(*world.get::<Parent>(child1).unwrap(), Parent(parent));\n        assert_eq!(*world.get::<Parent>(child2).unwrap(), Parent(parent));\n\n        world.entity_mut(parent).insert_children(1, &entities[3..]);\n        let expected_children: SmallVec<[Entity; 8]> = smallvec![child1, child3, child4, child2];\n        assert_eq!(\n            world.get::<Children>(parent).unwrap().0.clone(),\n            expected_children\n        );\n        assert_eq!(*world.get::<Parent>(child3).unwrap(), Parent(parent));\n        assert_eq!(*world.get::<Parent>(child4).unwrap(), Parent(parent));\n\n        let remove_children = [child1, child4];\n        world.entity_mut(parent).remove_children(&remove_children);\n        let expected_children: SmallVec<[Entity; 8]> = smallvec![child3, child2];\n        assert_eq!(\n            world.get::<Children>(parent).unwrap().0.clone(),\n            expected_children\n        );\n        assert!(world.get::<Parent>(child1).is_none());\n        assert!(world.get::<Parent>(child4).is_none());\n    }\n\n    #[test]\n    fn push_and_insert_and_clear_children_world() {\n        let mut world = World::default();\n        let entities = world\n            .spawn_batch(vec![C(1), C(2), C(3)])\n            .collect::<Vec<Entity>>();\n\n        world.entity_mut(entities[0]).add_children(&entities[1..3]);\n\n        let parent = entities[0];\n        let child1 = entities[1];\n        let child2 = entities[2];\n\n        let expected_children: SmallVec<[Entity; 8]> = smallvec![child1, child2];\n        assert_eq!(\n            world.get::<Children>(parent).unwrap().0.clone(),\n            expected_children\n        );\n        assert_eq!(*world.get::<Parent>(child1).unwrap(), Parent(parent));\n        assert_eq!(*world.get::<Parent>(child2).unwrap(), Parent(parent));\n\n        world.entity_mut(parent).clear_children();\n        assert!(world.get::<Children>(parent).is_none());\n        assert!(world.get::<Parent>(child1).is_none());\n        assert!(world.get::<Parent>(child2).is_none());\n    }\n\n    #[test]\n    fn push_and_replace_children_world() {\n        let mut world = World::default();\n        let entities = world\n            .spawn_batch(vec![C(1), C(2), C(3), C(4), C(5)])\n            .collect::<Vec<Entity>>();\n\n        world.entity_mut(entities[0]).add_children(&entities[1..3]);\n\n        let parent = entities[0];\n        let child1 = entities[1];\n        let child2 = entities[2];\n        let child3 = entities[3];\n        let child4 = entities[4];\n\n        let expected_children: SmallVec<[Entity; 8]> = smallvec![child1, child2];\n        assert_eq!(\n            world.get::<Children>(parent).unwrap().0.clone(),\n            expected_children\n        );\n        assert_eq!(*world.get::<Parent>(child1).unwrap(), Parent(parent));\n        assert_eq!(*world.get::<Parent>(child2).unwrap(), Parent(parent));\n\n        world.entity_mut(parent).replace_children(&entities[2..]);\n        let expected_children: SmallVec<[Entity; 8]> = smallvec![child2, child3, child4];\n        assert_eq!(\n            world.get::<Children>(parent).unwrap().0.clone(),\n            expected_children\n        );\n        assert!(world.get::<Parent>(child1).is_none());\n        assert_eq!(*world.get::<Parent>(child2).unwrap(), Parent(parent));\n        assert_eq!(*world.get::<Parent>(child3).unwrap(), Parent(parent));\n        assert_eq!(*world.get::<Parent>(child4).unwrap(), Parent(parent));\n    }\n\n    /// Tests what happens when all children are removed from a parent using world functions\n    #[test]\n    fn children_removed_when_empty_world() {\n        let mut world = World::default();\n        let entities = world\n            .spawn_batch(vec![C(1), C(2), C(3)])\n            .collect::<Vec<Entity>>();\n\n        let parent1 = entities[0];\n        let parent2 = entities[1];\n        let child = entities[2];\n\n        // add child into parent1\n        world.entity_mut(parent1).add_children(&[child]);\n        assert_eq!(\n            world.get::<Children>(parent1).unwrap().0.as_slice(),\n            &[child]\n        );\n\n        // move only child from parent1 with `add_children`\n        world.entity_mut(parent2).add_children(&[child]);\n        assert!(world.get::<Children>(parent1).is_none());\n\n        // move only child from parent2 with `insert_children`\n        world.entity_mut(parent1).insert_children(0, &[child]);\n        assert!(world.get::<Children>(parent2).is_none());\n\n        // remove only child from parent1 with `remove_children`\n        world.entity_mut(parent1).remove_children(&[child]);\n        assert!(world.get::<Children>(parent1).is_none());\n    }\n\n    /// Tests what happens when all children are removed form a parent using commands\n    #[test]\n    fn children_removed_when_empty_commands() {\n        let mut world = World::default();\n        let entities = world\n            .spawn_batch(vec![C(1), C(2), C(3)])\n            .collect::<Vec<Entity>>();\n\n        let parent1 = entities[0];\n        let parent2 = entities[1];\n        let child = entities[2];\n\n        let mut queue = CommandQueue::default();\n\n        // add child into parent1\n        {\n            let mut commands = Commands::new(&mut queue, &world);\n            commands.entity(parent1).add_children(&[child]);\n            queue.apply(&mut world);\n        }\n        assert_eq!(\n            world.get::<Children>(parent1).unwrap().0.as_slice(),\n            &[child]\n        );\n\n        // move only child from parent1 with `add_children`\n        {\n            let mut commands = Commands::new(&mut queue, &world);\n            commands.entity(parent2).add_children(&[child]);\n            queue.apply(&mut world);\n        }\n        assert!(world.get::<Children>(parent1).is_none());\n\n        // move only child from parent2 with `insert_children`\n        {\n            let mut commands = Commands::new(&mut queue, &world);\n            commands.entity(parent1).insert_children(0, &[child]);\n            queue.apply(&mut world);\n        }\n        assert!(world.get::<Children>(parent2).is_none());\n\n        // move only child from parent1 with `add_child`\n        {\n            let mut commands = Commands::new(&mut queue, &world);\n            commands.entity(parent2).add_child(child);\n            queue.apply(&mut world);\n        }\n        assert!(world.get::<Children>(parent1).is_none());\n\n        // remove only child from parent2 with `remove_children`\n        {\n            let mut commands = Commands::new(&mut queue, &world);\n            commands.entity(parent2).remove_children(&[child]);\n            queue.apply(&mut world);\n        }\n        assert!(world.get::<Children>(parent2).is_none());\n    }\n\n    #[test]\n    fn regression_add_children_same_archetype() {\n        let mut world = World::new();\n        let child = world.spawn_empty().id();\n        world.spawn_empty().add_children(&[child]);\n    }\n\n    #[test]\n    fn add_children_idempotent() {\n        let mut world = World::new();\n        let child = world.spawn_empty().id();\n        let parent = world\n            .spawn_empty()\n            .add_children(&[child])\n            .add_children(&[child])\n            .id();\n\n        let mut query = world.query::<&Children>();\n        let children = query.get(&world, parent).unwrap();\n        assert_eq!(**children, [child]);\n    }\n\n    #[test]\n    fn add_children_does_not_insert_empty_children() {\n        let mut world = World::new();\n        let parent = world.spawn_empty().add_children(&[]).id();\n\n        let mut query = world.query::<&Children>();\n        let children = query.get(&world, parent);\n        assert!(children.is_err());\n    }\n\n    #[test]\n    fn with_child() {\n        let world = &mut World::new();\n        world.insert_resource(Events::<HierarchyEvent>::default());\n\n        let a = world.spawn_empty().id();\n        let b = ();\n        let c = ();\n        let d = ();\n\n        world.entity_mut(a).with_child(b);\n\n        assert_num_children(world, a, 1);\n\n        world.entity_mut(a).with_child(c).with_child(d);\n\n        assert_num_children(world, a, 3);\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "041f9fd23f14f8b379c400362e42416787a9bd1d",
    "func": "#[macro_use] extern crate rocket;\n\nuse std::path::PathBuf;\n\nuse rocket::local::blocking::Client;\nuse rocket::fairing::AdHoc;\n\n#[get(\"/foo\")]\nfn foo() -> &'static str { \"foo\" }\n\n#[get(\"/bar\")]\nfn not_bar() -> &'static str { \"not_bar\" }\n\n#[get(\"/bar/\")]\nfn bar() -> &'static str { \"bar\" }\n\n#[get(\"/foo/<_>/<_baz..>\")]\nfn baz(_baz: PathBuf) -> &'static str { \"baz\" }\n\n#[get(\"/doggy/<_>/<_baz..>?doggy\")]\nfn doggy(_baz: PathBuf) -> &'static str { \"doggy\" }\n\n#[get(\"/<_..>\")]\nfn rest() -> &'static str { \"rest\" }\n\nmacro_rules! assert_response {\n    ($client:ident : $path:expr => $response:expr) => {\n        let response = $client.get($path).dispatch().into_string().unwrap();\n        assert_eq!(response, $response, \"\\nGET {}: got {} but expected {}\",\n            $path, response, $response);\n    };\n}\n\n#[test]\nfn test_adhoc_normalizer_works_as_expected () {\n    let rocket = rocket::build()\n        .mount(\"/\", routes![foo, bar, not_bar, baz, doggy])\n        .mount(\"/base\", routes![foo, bar, not_bar, baz, doggy, rest])\n        .attach(AdHoc::uri_normalizer());\n\n    let client = Client::debug(rocket).unwrap();\n\n    assert_response!(client: \"/foo\" => \"foo\");\n    assert_response!(client: \"/foo/\" => \"foo\");\n    assert_response!(client: \"/bar/\" => \"bar\");\n    assert_response!(client: \"/bar\" => \"not_bar\");\n    assert_response!(client: \"/foo/bar\" => \"baz\");\n    assert_response!(client: \"/doggy/bar?doggy\" => \"doggy\");\n    assert_response!(client: \"/foo/bar/\" => \"baz\");\n    assert_response!(client: \"/foo/bar/baz\" => \"baz\");\n    assert_response!(client: \"/base/foo/\" => \"foo\");\n    assert_response!(client: \"/base/foo\" => \"foo\");\n    assert_response!(client: \"/base/bar/\" => \"bar\");\n    assert_response!(client: \"/base/bar\" => \"not_bar\");\n    assert_response!(client: \"/base/foo/bar\" => \"baz\");\n    assert_response!(client: \"/doggy/foo/bar?doggy\" => \"doggy\");\n    assert_response!(client: \"/base/foo/bar/\" => \"baz\");\n    assert_response!(client: \"/base/foo/bar/baz\" => \"baz\");\n\n    assert_response!(client: \"/base/cat\" => \"rest\");\n    assert_response!(client: \"/base/cat/\" => \"rest\");\n    assert_response!(client: \"/base/cat/dog\" => \"rest\");\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "3bd44cfe9af00bb11f3e1b6b2bd1aeb31f488884",
    "func": "use crate::Stream;\n\nuse core::fmt;\nuse core::pin::Pin;\nuse core::task::{ready, Context, Poll};\nuse pin_project_lite::pin_project;\n\npin_project! {\n    /// Stream returned by the [`filter_map`](super::StreamExt::filter_map) method.\n    #[must_use = \"streams do nothing unless polled\"]\n    pub struct FilterMap<St, F> {\n        #[pin]\n        stream: St,\n        f: F,\n    }\n}\n\nimpl<St, F> fmt::Debug for FilterMap<St, F>\nwhere\n    St: fmt::Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"FilterMap\")\n            .field(\"stream\", &self.stream)\n            .finish()\n    }\n}\n\nimpl<St, F> FilterMap<St, F> {\n    pub(super) fn new(stream: St, f: F) -> Self {\n        Self { stream, f }\n    }\n}\n\nimpl<St, F, T> Stream for FilterMap<St, F>\nwhere\n    St: Stream,\n    F: FnMut(St::Item) -> Option<T>,\n{\n    type Item = T;\n\n    fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<T>> {\n        loop {\n            match ready!(self.as_mut().project().stream.poll_next(cx)) {\n                Some(e) => {\n                    if let Some(e) = (self.as_mut().project().f)(e) {\n                        return Poll::Ready(Some(e));\n                    }\n                }\n                None => return Poll::Ready(None),\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (0, self.stream.size_hint().1) // can't know a lower bound, due to the predicate\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "e05f54674df5899cbd4cef1c4a723aba89b33a56",
    "func": "use super::sea_orm_active_enums::*;\nuse sea_orm::entity::prelude::*;\n\n#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = \"categories\")]\npub struct Model {\n    #[sea_orm(primary_key, auto_increment = false)]\n    pub id: i32,\n    pub categories: Option<Vec<Category>>,\n}\n\n#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]\npub enum Relation {}\n\nimpl ActiveModelBehavior for ActiveModel {}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "301331befa9df5da848b9c783f6af2ac35767675",
    "func": "use web_sys::HtmlTextAreaElement;\nuse yew::prelude::*;\n\nuse crate::use_sleep;\n\n#[function_component]\npub fn WithSleep<Comp>() -> HtmlResult\nwhere\n    Comp: BaseComponent<Properties = AppContentProps>,\n{\n    let sleep = use_sleep()?;\n    let sleep = Callback::from(move |_| sleep());\n    Ok(yew::virtual_dom::VChild::<Comp>::new(AppContentProps { resleep: sleep }, None).into())\n}\n\n#[derive(Debug, PartialEq, Properties)]\npub struct AppContentProps {\n    pub resleep: Callback<()>,\n}\n\npub type AppContent = WithSleep<BaseAppContent>;\n\npub enum Msg {\n    ValueUpdate(String),\n    TakeABreak,\n}\n\npub struct BaseAppContent {\n    value: String,\n}\n\nimpl Component for BaseAppContent {\n    type Message = Msg;\n    type Properties = AppContentProps;\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self {\n            value: \"I am writing a long story...\".to_string(),\n        }\n    }\n\n    fn update(&mut self, ctx: &Context<Self>, msg: Self::Message) -> bool {\n        match msg {\n            Msg::ValueUpdate(v) => {\n                self.value = v;\n            }\n            Msg::TakeABreak => {\n                ctx.props().resleep.emit(());\n            }\n        };\n        true\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        let oninput = ctx.link().callback(|e: InputEvent| {\n            let input: HtmlTextAreaElement = e.target_unchecked_into::<HtmlTextAreaElement>();\n            Msg::ValueUpdate(input.value())\n        });\n        let on_take_a_break = ctx.link().callback(|_| Msg::TakeABreak);\n        html! {\n            <div class=\"content-area\">\n                <textarea value={self.value.clone()} {oninput}></textarea>\n                <div class=\"action-area\">\n                    <button onclick={on_take_a_break}>{\"Take a break!\"}</button>\n                    <div class=\"hint\">{\"You can take a break at anytime\"}<br />{\"and your work will be preserved.\"}</div>\n                </div>\n            </div>\n        }\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "67211ee7712a4c401f9035afba0f3dded6ce08d8",
    "func": "use super::cache::Segment;\nuse crate::cache::StringCache;\n\nuse dioxus_core::{prelude::*, AttributeValue, DynamicNode};\nuse rustc_hash::FxHashMap;\nuse std::fmt::Write;\nuse std::sync::Arc;\n\ntype ComponentRenderCallback = Arc<\n    dyn Fn(&mut Renderer, &mut dyn Write, &VirtualDom, ScopeId) -> std::fmt::Result + Send + Sync,\n>;\n\n/// A virtualdom renderer that caches the templates it has seen for faster rendering\n#[derive(Default)]\npub struct Renderer {\n    /// Choose to write ElementIDs into elements so the page can be re-hydrated later on\n    pub pre_render: bool,\n\n    /// A callback used to render components. You can set this callback to control what components are rendered and add wrappers around components that are not present in CSR\n    render_components: Option<ComponentRenderCallback>,\n\n    /// A cache of templates that have been rendered\n    template_cache: FxHashMap<Template, Arc<StringCache>>,\n\n    /// The current dynamic node id for hydration\n    dynamic_node_id: usize,\n}\n\nimpl Renderer {\n    pub fn new() -> Self {\n        Self::default()\n    }\n\n    /// Set the callback that the renderer uses to render components\n    pub fn set_render_components(\n        &mut self,\n        callback: impl Fn(&mut Renderer, &mut dyn Write, &VirtualDom, ScopeId) -> std::fmt::Result\n            + Send\n            + Sync\n            + 'static,\n    ) {\n        self.render_components = Some(Arc::new(callback));\n    }\n\n    /// Reset the callback that the renderer uses to render components\n    pub fn reset_render_components(&mut self) {\n        self.render_components = None;\n    }\n\n    pub fn render(&mut self, dom: &VirtualDom) -> String {\n        let mut buf = String::new();\n        self.render_to(&mut buf, dom).unwrap();\n        buf\n    }\n\n    pub fn render_to<W: Write + ?Sized>(\n        &mut self,\n        buf: &mut W,\n        dom: &VirtualDom,\n    ) -> std::fmt::Result {\n        self.reset_hydration();\n        self.render_scope(buf, dom, ScopeId::ROOT)\n    }\n\n    /// Render an element to a string\n    pub fn render_element(&mut self, element: Element) -> String {\n        let mut buf = String::new();\n        self.render_element_to(&mut buf, element).unwrap();\n        buf\n    }\n\n    /// Render an element to the buffer\n    pub fn render_element_to<W: Write + ?Sized>(\n        &mut self,\n        buf: &mut W,\n        element: Element,\n    ) -> std::fmt::Result {\n        fn lazy_app(props: Element) -> Element {\n            props\n        }\n        let mut dom = VirtualDom::new_with_props(lazy_app, element);\n        dom.rebuild_in_place();\n        self.render_to(buf, &dom)\n    }\n\n    /// Reset the renderer hydration state\n    pub fn reset_hydration(&mut self) {\n        self.dynamic_node_id = 0;\n    }\n\n    pub fn render_scope<W: Write + ?Sized>(\n        &mut self,\n        buf: &mut W,\n        dom: &VirtualDom,\n        scope: ScopeId,\n    ) -> std::fmt::Result {\n        let node = dom.get_scope(scope).unwrap().root_node();\n        self.render_template(buf, dom, node)?;\n\n        Ok(())\n    }\n\n    fn render_template<W: Write + ?Sized>(\n        &mut self,\n        mut buf: &mut W,\n        dom: &VirtualDom,\n        template: &VNode,\n    ) -> std::fmt::Result {\n        let entry = self\n            .template_cache\n            .entry(template.template)\n            .or_insert_with(move || Arc::new(StringCache::from_template(template).unwrap()))\n            .clone();\n\n        let mut inner_html = None;\n\n        // We need to keep track of the dynamic styles so we can insert them into the right place\n        let mut accumulated_dynamic_styles = Vec::new();\n\n        // We need to keep track of the listeners so we can insert them into the right place\n        let mut accumulated_listeners = Vec::new();\n\n        // We keep track of the index we are on manually so that we can jump forward to a new section quickly without iterating every item\n        let mut index = 0;\n\n        while let Some(segment) = entry.segments.get(index) {\n            match segment {\n                Segment::HydrationOnlySection(jump_to) => {\n                    // If we are not prerendering, we don't need to write the content of the hydration only section\n                    // Instead we can jump to the next section\n                    if !self.pre_render {\n                        index = *jump_to;\n                        continue;\n                    }\n                }\n                Segment::Attr(idx) => {\n                    let attrs = &*template.dynamic_attrs[*idx];\n                    for attr in attrs {\n                        if attr.name == \"dangerous_inner_html\" {\n                            inner_html = Some(attr);\n                        } else if attr.namespace == Some(\"style\") {\n                            accumulated_dynamic_styles.push(attr);\n                        } else if BOOL_ATTRS.contains(&attr.name) {\n                            if truthy(&attr.value) {\n                                write_attribute(buf, attr)?;\n                            }\n                        } else {\n                            write_attribute(buf, attr)?;\n                        }\n\n                        if self.pre_render {\n                            if let AttributeValue::Listener(_) = &attr.value {\n                                // The onmounted event doesn't need a DOM listener\n                                if attr.name != \"onmounted\" {\n                                    accumulated_listeners.push(attr.name);\n                                }\n                            }\n                        }\n                    }\n                }\n                Segment::Node(idx) => match &template.dynamic_nodes[*idx] {\n                    DynamicNode::Component(node) => {\n                        if let Some(render_components) = self.render_components.clone() {\n                            let scope_id = node.mounted_scope_id(*idx, template, dom).unwrap();\n\n                            render_components(self, &mut buf, dom, scope_id)?;\n                        } else {\n                            let scope = node.mounted_scope(*idx, template, dom).unwrap();\n                            let node = scope.root_node();\n                            self.render_template(buf, dom, node)?\n                        }\n                    }\n                    DynamicNode::Text(text) => {\n                        // in SSR, we are concerned that we can't hunt down the right text node since they might get merged\n                        if self.pre_render {\n                            write!(buf, \"<!--node-id{}-->\", self.dynamic_node_id)?;\n                            self.dynamic_node_id += 1;\n                        }\n\n                        write!(\n                            buf,\n                            \"{}\",\n                            askama_escape::escape(&text.value, askama_escape::Html)\n                        )?;\n\n                        if self.pre_render {\n                            write!(buf, \"<!--#-->\")?;\n                        }\n                    }\n                    DynamicNode::Fragment(nodes) => {\n                        for child in nodes {\n                            self.render_template(buf, dom, child)?;\n                        }\n                    }\n\n                    DynamicNode::Placeholder(_) => {\n                        if self.pre_render {\n                            write!(buf, \"<!--placeholder{}-->\", self.dynamic_node_id)?;\n                            self.dynamic_node_id += 1;\n                        }\n                    }\n                },\n\n                Segment::PreRendered(contents) => write!(buf, \"{contents}\")?,\n\n                Segment::StyleMarker { inside_style_tag } => {\n                    if !accumulated_dynamic_styles.is_empty() {\n                        // if we are inside a style tag, we don't need to write the style attribute\n                        if !*inside_style_tag {\n                            write!(buf, \" style=\\\"\")?;\n                        }\n                        for attr in &accumulated_dynamic_styles {\n                            write!(buf, \"{}:\", attr.name)?;\n                            write_value_unquoted(buf, &attr.value)?;\n                            write!(buf, \";\")?;\n                        }\n                        if !*inside_style_tag {\n                            write!(buf, \"\\\"\")?;\n                        }\n\n                        // clear the accumulated styles\n                        accumulated_dynamic_styles.clear();\n                    }\n                }\n\n                Segment::InnerHtmlMarker => {\n                    if let Some(inner_html) = inner_html.take() {\n                        let inner_html = &inner_html.value;\n                        match inner_html {\n                            AttributeValue::Text(value) => write!(buf, \"{}\", value)?,\n                            AttributeValue::Bool(value) => write!(buf, \"{}\", value)?,\n                            AttributeValue::Float(f) => write!(buf, \"{}\", f)?,\n                            AttributeValue::Int(i) => write!(buf, \"{}\", i)?,\n                            _ => {}\n                        }\n                    }\n                }\n\n                Segment::AttributeNodeMarker => {\n                    // first write the id\n                    write!(buf, \"{}\", self.dynamic_node_id)?;\n                    self.dynamic_node_id += 1;\n                    // then write any listeners\n                    for name in accumulated_listeners.drain(..) {\n                        write!(buf, \",{}:\", &name[2..])?;\n                        write!(\n                            buf,\n                            \"{}\",\n                            dioxus_core_types::event_bubbles(&name[2..]) as u8\n                        )?;\n                    }\n                }\n\n                Segment::RootNodeMarker => {\n                    write!(buf, \"{}\", self.dynamic_node_id)?;\n                    self.dynamic_node_id += 1\n                }\n            }\n\n            index += 1;\n        }\n\n        Ok(())\n    }\n}\n\n#[test]\nfn to_string_works() {\n    use dioxus::prelude::*;\n\n    fn app() -> Element {\n        let dynamic = 123;\n        let dyn2 = \"</diiiiiiiiv>\"; // this should be escaped\n\n        rsx! {\n            div { class: \"asdasdasd\", class: \"asdasdasd\", id: \"id-{dynamic}\",\n                \"Hello world 1 -->\"\n                \"{dynamic}\"\n                \"<-- Hello world 2\"\n                div { \"nest 1\" }\n                div {}\n                div { \"nest 2\" }\n                \"{dyn2}\"\n                for i in (0..5) {\n                    div { \"finalize {i}\" }\n                }\n            }\n        }\n    }\n\n    let mut dom = VirtualDom::new(app);\n    dom.rebuild(&mut dioxus_core::NoOpMutations);\n\n    let mut renderer = Renderer::new();\n    let out = renderer.render(&dom);\n\n    for item in renderer.template_cache.iter() {\n        if item.1.segments.len() > 10 {\n            assert_eq!(\n                item.1.segments,\n                vec![\n                    PreRendered(\"<div class=\\\"asdasdasd asdasdasd\\\"\".to_string()),\n                    Attr(0),\n                    StyleMarker {\n                        inside_style_tag: false\n                    },\n                    HydrationOnlySection(7), // jump to `>` if we don't need to hydrate\n                    PreRendered(\" data-node-hydration=\\\"\".to_string()),\n                    AttributeNodeMarker,\n                    PreRendered(\"\\\"\".to_string()),\n                    PreRendered(\">\".to_string()),\n                    InnerHtmlMarker,\n                    PreRendered(\"Hello world 1 --&gt;\".to_string()),\n                    Node(0),\n                    PreRendered(\n                        \"&lt;-- Hello world 2<div>nest 1</div><div></div><div>nest 2</div>\"\n                            .to_string()\n                    ),\n                    Node(1),\n                    Node(2),\n                    PreRendered(\"</div>\".to_string())\n                ]\n            );\n        }\n    }\n\n    use Segment::*;\n\n    assert_eq!(out, \"<div class=\\\"asdasdasd asdasdasd\\\" id=\\\"id-123\\\">Hello world 1 --&gt;123&lt;-- Hello world 2<div>nest 1</div><div></div><div>nest 2</div>&lt;/diiiiiiiiv&gt;<div>finalize 0</div><div>finalize 1</div><div>finalize 2</div><div>finalize 3</div><div>finalize 4</div></div>\");\n}\n\n#[test]\nfn empty_for_loop_works() {\n    use dioxus::prelude::*;\n\n    fn app() -> Element {\n        rsx! {\n            div { class: \"asdasdasd\",\n                for _ in (0..5) {\n\n                }\n            }\n        }\n    }\n\n    let mut dom = VirtualDom::new(app);\n    dom.rebuild(&mut dioxus_core::NoOpMutations);\n\n    let mut renderer = Renderer::new();\n    let out = renderer.render(&dom);\n\n    for item in renderer.template_cache.iter() {\n        if item.1.segments.len() > 5 {\n            assert_eq!(\n                item.1.segments,\n                vec![\n                    PreRendered(\"<div class=\\\"asdasdasd\\\"\".to_string()),\n                    HydrationOnlySection(5), // jump to `>` if we don't need to hydrate\n                    PreRendered(\" data-node-hydration=\\\"\".to_string()),\n                    RootNodeMarker,\n                    PreRendered(\"\\\"\".to_string()),\n                    PreRendered(\">\".to_string()),\n                    Node(0),\n                    PreRendered(\"</div>\".to_string())\n                ]\n            );\n        }\n    }\n\n    use Segment::*;\n\n    assert_eq!(out, \"<div class=\\\"asdasdasd\\\"></div>\");\n}\n\n#[test]\nfn empty_render_works() {\n    use dioxus::prelude::*;\n\n    fn app() -> Element {\n        rsx! {}\n    }\n\n    let mut dom = VirtualDom::new(app);\n    dom.rebuild(&mut dioxus_core::NoOpMutations);\n\n    let mut renderer = Renderer::new();\n    let out = renderer.render(&dom);\n\n    for item in renderer.template_cache.iter() {\n        if item.1.segments.len() > 5 {\n            assert_eq!(item.1.segments, vec![]);\n        }\n    }\n    assert_eq!(out, \"\");\n}\n\npub(crate) const BOOL_ATTRS: &[&str] = &[\n    \"allowfullscreen\",\n    \"allowpaymentrequest\",\n    \"async\",\n    \"autofocus\",\n    \"autoplay\",\n    \"checked\",\n    \"controls\",\n    \"default\",\n    \"defer\",\n    \"disabled\",\n    \"formnovalidate\",\n    \"hidden\",\n    \"ismap\",\n    \"itemscope\",\n    \"loop\",\n    \"multiple\",\n    \"muted\",\n    \"nomodule\",\n    \"novalidate\",\n    \"open\",\n    \"playsinline\",\n    \"readonly\",\n    \"required\",\n    \"reversed\",\n    \"selected\",\n    \"truespeed\",\n    \"webkitdirectory\",\n];\n\npub(crate) fn str_truthy(value: &str) -> bool {\n    !value.is_empty() && value != \"0\" && value.to_lowercase() != \"false\"\n}\n\npub(crate) fn truthy(value: &AttributeValue) -> bool {\n    match value {\n        AttributeValue::Text(value) => str_truthy(value),\n        AttributeValue::Bool(value) => *value,\n        AttributeValue::Int(value) => *value != 0,\n        AttributeValue::Float(value) => *value != 0.0,\n        _ => false,\n    }\n}\n\npub(crate) fn write_attribute<W: Write + ?Sized>(\n    buf: &mut W,\n    attr: &Attribute,\n) -> std::fmt::Result {\n    let name = &attr.name;\n    match &attr.value {\n        AttributeValue::Text(value) => write!(buf, \" {name}=\\\"{value}\\\"\"),\n        AttributeValue::Bool(value) => write!(buf, \" {name}={value}\"),\n        AttributeValue::Int(value) => write!(buf, \" {name}={value}\"),\n        AttributeValue::Float(value) => write!(buf, \" {name}={value}\"),\n        _ => Ok(()),\n    }\n}\n\npub(crate) fn write_value_unquoted<W: Write + ?Sized>(\n    buf: &mut W,\n    value: &AttributeValue,\n) -> std::fmt::Result {\n    match value {\n        AttributeValue::Text(value) => write!(buf, \"{}\", value),\n        AttributeValue::Bool(value) => write!(buf, \"{}\", value),\n        AttributeValue::Int(value) => write!(buf, \"{}\", value),\n        AttributeValue::Float(value) => write!(buf, \"{}\", value),\n        _ => Ok(()),\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "508a1d23644bca3e33cc71ecbb30afef63df04b5",
    "func": "#![allow(clippy::expect_fun_call)]\nuse diesel::connection::SimpleConnection;\nuse diesel::dsl::sql;\nuse diesel::sql_types::Bool;\nuse diesel::*;\n\npub struct Database {\n    url: String,\n}\n\nimpl Database {\n    pub fn new(url: &str) -> Self {\n        Database { url: url.into() }\n    }\n\n    pub fn create(self) -> Self {\n        let (database, mysql_url) = self.split_url();\n        let mut conn = MysqlConnection::establish(&mysql_url).unwrap();\n        diesel::sql_query(format!(\"CREATE DATABASE `{}`\", database))\n            .execute(&mut conn)\n            .unwrap();\n        self\n    }\n\n    pub fn exists(&self) -> bool {\n        MysqlConnection::establish(&self.url).is_ok()\n    }\n\n    pub fn table_exists(&self, table: &str) -> bool {\n        select(sql::<Bool>(&format!(\n            \"EXISTS \\\n                (SELECT 1 \\\n                 FROM information_schema.tables \\\n                 WHERE table_name = '{}'\n                 AND table_schema = DATABASE())\",\n            table\n        )))\n        .get_result(&mut self.conn())\n        .unwrap()\n    }\n\n    pub fn conn(&self) -> MysqlConnection {\n        MysqlConnection::establish(&self.url)\n            .expect(&format!(\"Failed to open connection to {}\", &self.url))\n    }\n\n    pub fn execute(&self, command: &str) {\n        self.conn()\n            .batch_execute(command)\n            .expect(&format!(\"Error executing command {}\", command));\n    }\n\n    fn split_url(&self) -> (String, String) {\n        let mut split: Vec<&str> = self.url.split('/').collect();\n        let database = split.pop().unwrap();\n        let mysql_url = format!(\"{}/{}\", split.join(\"/\"), \"information_schema\");\n        (database.into(), mysql_url)\n    }\n}\n\nimpl Drop for Database {\n    fn drop(&mut self) {\n        let (database, mysql_url) = self.split_url();\n        let mut conn = try_drop!(\n            MysqlConnection::establish(&mysql_url),\n            \"Couldn't connect to database\"\n        );\n        try_drop!(\n            diesel::sql_query(format!(\"DROP DATABASE IF EXISTS `{}`\", database)).execute(&mut conn),\n            \"Couldn't drop database\"\n        );\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "c7fd2ea5d87ef6ad382d62c5df064b8fa60034db",
    "func": "use alloc::sync::Arc;\nuse bevy_core_pipeline::{\n    core_3d::ViewTransmissionTexture,\n    oit::{OitBuffers, OrderIndependentTransparencySettings},\n    prepass::ViewPrepassTextures,\n    tonemapping::{\n        get_lut_bind_group_layout_entries, get_lut_bindings, Tonemapping, TonemappingLuts,\n    },\n};\nuse bevy_derive::{Deref, DerefMut};\nuse bevy_ecs::{\n    component::Component,\n    entity::Entity,\n    query::Has,\n    system::{Commands, Query, Res, Resource},\n    world::{FromWorld, World},\n};\nuse bevy_math::Vec4;\nuse bevy_render::{\n    globals::{GlobalsBuffer, GlobalsUniform},\n    render_asset::RenderAssets,\n    render_resource::{binding_types::*, *},\n    renderer::RenderDevice,\n    texture::{BevyDefault, FallbackImage, FallbackImageMsaa, FallbackImageZero, GpuImage},\n    view::{\n        Msaa, RenderVisibilityRanges, ViewUniform, ViewUniforms,\n        VISIBILITY_RANGES_STORAGE_BUFFER_COUNT,\n    },\n};\nuse core::{array, num::NonZero};\n\n#[cfg(all(feature = \"webgl\", target_arch = \"wasm32\", not(feature = \"webgpu\")))]\nuse bevy_render::render_resource::binding_types::texture_cube;\nuse bevy_render::renderer::RenderAdapter;\n#[cfg(debug_assertions)]\nuse bevy_utils::warn_once;\nuse environment_map::EnvironmentMapLight;\n\n#[cfg(debug_assertions)]\nuse crate::MESH_PIPELINE_VIEW_LAYOUT_SAFE_MAX_TEXTURES;\nuse crate::{\n    environment_map::{self, RenderViewEnvironmentMapBindGroupEntries},\n    irradiance_volume::{\n        self, IrradianceVolume, RenderViewIrradianceVolumeBindGroupEntries,\n        IRRADIANCE_VOLUMES_ARE_USABLE,\n    },\n    prepass, EnvironmentMapUniformBuffer, FogMeta, GlobalClusterableObjectMeta,\n    GpuClusterableObjects, GpuFog, GpuLights, LightMeta, LightProbesBuffer, LightProbesUniform,\n    MeshPipeline, MeshPipelineKey, RenderViewLightProbes, ScreenSpaceAmbientOcclusionResources,\n    ScreenSpaceReflectionsBuffer, ScreenSpaceReflectionsUniform, ShadowSamplers,\n    ViewClusterBindings, ViewShadowBindings, CLUSTERED_FORWARD_STORAGE_BUFFER_COUNT,\n};\n\n#[derive(Clone)]\npub struct MeshPipelineViewLayout {\n    pub bind_group_layout: BindGroupLayout,\n\n    #[cfg(debug_assertions)]\n    pub texture_count: usize,\n}\n\nbitflags::bitflags! {\n    /// A key that uniquely identifies a [`MeshPipelineViewLayout`].\n    ///\n    /// Used to generate all possible layouts for the mesh pipeline in [`generate_view_layouts`],\n    /// so special care must be taken to not add too many flags, as the number of possible layouts\n    /// will grow exponentially.\n    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n    #[repr(transparent)]\n    pub struct MeshPipelineViewLayoutKey: u32 {\n        const MULTISAMPLED                = 1 << 0;\n        const DEPTH_PREPASS               = 1 << 1;\n        const NORMAL_PREPASS              = 1 << 2;\n        const MOTION_VECTOR_PREPASS       = 1 << 3;\n        const DEFERRED_PREPASS            = 1 << 4;\n        const OIT_ENABLED                 = 1 << 5;\n    }\n}\n\nimpl MeshPipelineViewLayoutKey {\n    // The number of possible layouts\n    pub const COUNT: usize = Self::all().bits() as usize + 1;\n\n    /// Builds a unique label for each layout based on the flags\n    pub fn label(&self) -> String {\n        use MeshPipelineViewLayoutKey as Key;\n\n        format!(\n            \"mesh_view_layout{}{}{}{}{}{}\",\n            self.contains(Key::MULTISAMPLED)\n                .then_some(\"_multisampled\")\n                .unwrap_or_default(),\n            self.contains(Key::DEPTH_PREPASS)\n                .then_some(\"_depth\")\n                .unwrap_or_default(),\n            self.contains(Key::NORMAL_PREPASS)\n                .then_some(\"_normal\")\n                .unwrap_or_default(),\n            self.contains(Key::MOTION_VECTOR_PREPASS)\n                .then_some(\"_motion\")\n                .unwrap_or_default(),\n            self.contains(Key::DEFERRED_PREPASS)\n                .then_some(\"_deferred\")\n                .unwrap_or_default(),\n            self.contains(Key::OIT_ENABLED)\n                .then_some(\"_oit\")\n                .unwrap_or_default(),\n        )\n    }\n}\n\nimpl From<MeshPipelineKey> for MeshPipelineViewLayoutKey {\n    fn from(value: MeshPipelineKey) -> Self {\n        let mut result = MeshPipelineViewLayoutKey::empty();\n\n        if value.msaa_samples() > 1 {\n            result |= MeshPipelineViewLayoutKey::MULTISAMPLED;\n        }\n        if value.contains(MeshPipelineKey::DEPTH_PREPASS) {\n            result |= MeshPipelineViewLayoutKey::DEPTH_PREPASS;\n        }\n        if value.contains(MeshPipelineKey::NORMAL_PREPASS) {\n            result |= MeshPipelineViewLayoutKey::NORMAL_PREPASS;\n        }\n        if value.contains(MeshPipelineKey::MOTION_VECTOR_PREPASS) {\n            result |= MeshPipelineViewLayoutKey::MOTION_VECTOR_PREPASS;\n        }\n        if value.contains(MeshPipelineKey::DEFERRED_PREPASS) {\n            result |= MeshPipelineViewLayoutKey::DEFERRED_PREPASS;\n        }\n        if value.contains(MeshPipelineKey::OIT_ENABLED) {\n            result |= MeshPipelineViewLayoutKey::OIT_ENABLED;\n        }\n\n        result\n    }\n}\n\nimpl From<Msaa> for MeshPipelineViewLayoutKey {\n    fn from(value: Msaa) -> Self {\n        let mut result = MeshPipelineViewLayoutKey::empty();\n\n        if value.samples() > 1 {\n            result |= MeshPipelineViewLayoutKey::MULTISAMPLED;\n        }\n\n        result\n    }\n}\n\nimpl From<Option<&ViewPrepassTextures>> for MeshPipelineViewLayoutKey {\n    fn from(value: Option<&ViewPrepassTextures>) -> Self {\n        let mut result = MeshPipelineViewLayoutKey::empty();\n\n        if let Some(prepass_textures) = value {\n            if prepass_textures.depth.is_some() {\n                result |= MeshPipelineViewLayoutKey::DEPTH_PREPASS;\n            }\n            if prepass_textures.normal.is_some() {\n                result |= MeshPipelineViewLayoutKey::NORMAL_PREPASS;\n            }\n            if prepass_textures.motion_vectors.is_some() {\n                result |= MeshPipelineViewLayoutKey::MOTION_VECTOR_PREPASS;\n            }\n            if prepass_textures.deferred.is_some() {\n                result |= MeshPipelineViewLayoutKey::DEFERRED_PREPASS;\n            }\n        }\n\n        result\n    }\n}\n\nfn buffer_layout(\n    buffer_binding_type: BufferBindingType,\n    has_dynamic_offset: bool,\n    min_binding_size: Option<NonZero<u64>>,\n) -> BindGroupLayoutEntryBuilder {\n    match buffer_binding_type {\n        BufferBindingType::Uniform => uniform_buffer_sized(has_dynamic_offset, min_binding_size),\n        BufferBindingType::Storage { read_only } => {\n            if read_only {\n                storage_buffer_read_only_sized(has_dynamic_offset, min_binding_size)\n            } else {\n                storage_buffer_sized(has_dynamic_offset, min_binding_size)\n            }\n        }\n    }\n}\n\n/// Returns the appropriate bind group layout vec based on the parameters\nfn layout_entries(\n    clustered_forward_buffer_binding_type: BufferBindingType,\n    visibility_ranges_buffer_binding_type: BufferBindingType,\n    layout_key: MeshPipelineViewLayoutKey,\n    render_device: &RenderDevice,\n    render_adapter: &RenderAdapter,\n) -> Vec<BindGroupLayoutEntry> {\n    let mut entries = DynamicBindGroupLayoutEntries::new_with_indices(\n        ShaderStages::FRAGMENT,\n        (\n            // View\n            (\n                0,\n                uniform_buffer::<ViewUniform>(true).visibility(ShaderStages::VERTEX_FRAGMENT),\n            ),\n            // Lights\n            (1, uniform_buffer::<GpuLights>(true)),\n            // Point Shadow Texture Cube Array\n            (\n                2,\n                #[cfg(all(\n                    not(feature = \"ios_simulator\"),\n                    any(\n                        not(feature = \"webgl\"),\n                        not(target_arch = \"wasm32\"),\n                        feature = \"webgpu\"\n                    )\n                ))]\n                texture_cube_array(TextureSampleType::Depth),\n                #[cfg(any(\n                    feature = \"ios_simulator\",\n                    all(feature = \"webgl\", target_arch = \"wasm32\", not(feature = \"webgpu\"))\n                ))]\n                texture_cube(TextureSampleType::Depth),\n            ),\n            // Point Shadow Texture Array Comparison Sampler\n            (3, sampler(SamplerBindingType::Comparison)),\n            // Point Shadow Texture Array Linear Sampler\n            (4, sampler(SamplerBindingType::Filtering)),\n            // Directional Shadow Texture Array\n            (\n                5,\n                #[cfg(any(\n                    not(feature = \"webgl\"),\n                    not(target_arch = \"wasm32\"),\n                    feature = \"webgpu\"\n                ))]\n                texture_2d_array(TextureSampleType::Depth),\n                #[cfg(all(feature = \"webgl\", target_arch = \"wasm32\", not(feature = \"webgpu\")))]\n                texture_2d(TextureSampleType::Depth),\n            ),\n            // Directional Shadow Texture Array Comparison Sampler\n            (6, sampler(SamplerBindingType::Comparison)),\n            // Directional Shadow Texture Array Linear Sampler\n            (7, sampler(SamplerBindingType::Filtering)),\n            // PointLights\n            (\n                8,\n                buffer_layout(\n                    clustered_forward_buffer_binding_type,\n                    false,\n                    Some(GpuClusterableObjects::min_size(\n                        clustered_forward_buffer_binding_type,\n                    )),\n                ),\n            ),\n            // ClusteredLightIndexLists\n            (\n                9,\n                buffer_layout(\n                    clustered_forward_buffer_binding_type,\n                    false,\n                    Some(\n                        ViewClusterBindings::min_size_clusterable_object_index_lists(\n                            clustered_forward_buffer_binding_type,\n                        ),\n                    ),\n                ),\n            ),\n            // ClusterOffsetsAndCounts\n            (\n                10,\n                buffer_layout(\n                    clustered_forward_buffer_binding_type,\n                    false,\n                    Some(ViewClusterBindings::min_size_cluster_offsets_and_counts(\n                        clustered_forward_buffer_binding_type,\n                    )),\n                ),\n            ),\n            // Globals\n            (\n                11,\n                uniform_buffer::<GlobalsUniform>(false).visibility(ShaderStages::VERTEX_FRAGMENT),\n            ),\n            // Fog\n            (12, uniform_buffer::<GpuFog>(true)),\n            // Light probes\n            (13, uniform_buffer::<LightProbesUniform>(true)),\n            // Visibility ranges\n            (\n                14,\n                buffer_layout(\n                    visibility_ranges_buffer_binding_type,\n                    false,\n                    Some(Vec4::min_size()),\n                )\n                .visibility(ShaderStages::VERTEX),\n            ),\n            // Screen space reflection settings\n            (15, uniform_buffer::<ScreenSpaceReflectionsUniform>(true)),\n            // Screen space ambient occlusion texture\n            (\n                16,\n                texture_2d(TextureSampleType::Float { filterable: false }),\n            ),\n        ),\n    );\n\n    // EnvironmentMapLight\n    let environment_map_entries = environment_map::get_bind_group_layout_entries(render_device);\n    entries = entries.extend_with_indices((\n        (17, environment_map_entries[0]),\n        (18, environment_map_entries[1]),\n        (19, environment_map_entries[2]),\n        (20, environment_map_entries[3]),\n    ));\n\n    // Irradiance volumes\n    if IRRADIANCE_VOLUMES_ARE_USABLE {\n        let irradiance_volume_entries =\n            irradiance_volume::get_bind_group_layout_entries(render_device);\n        entries = entries.extend_with_indices((\n            (21, irradiance_volume_entries[0]),\n            (22, irradiance_volume_entries[1]),\n        ));\n    }\n\n    // Tonemapping\n    let tonemapping_lut_entries = get_lut_bind_group_layout_entries();\n    entries = entries.extend_with_indices((\n        (23, tonemapping_lut_entries[0]),\n        (24, tonemapping_lut_entries[1]),\n    ));\n\n    // Prepass\n    if cfg!(any(not(feature = \"webgl\"), not(target_arch = \"wasm32\")))\n        || (cfg!(all(feature = \"webgl\", target_arch = \"wasm32\"))\n            && !layout_key.contains(MeshPipelineViewLayoutKey::MULTISAMPLED))\n    {\n        for (entry, binding) in prepass::get_bind_group_layout_entries(layout_key)\n            .iter()\n            .zip([25, 26, 27, 28])\n        {\n            if let Some(entry) = entry {\n                entries = entries.extend_with_indices(((binding as u32, *entry),));\n            }\n        }\n    }\n\n    // View Transmission Texture\n    entries = entries.extend_with_indices((\n        (\n            29,\n            texture_2d(TextureSampleType::Float { filterable: true }),\n        ),\n        (30, sampler(SamplerBindingType::Filtering)),\n    ));\n\n    // OIT\n    if layout_key.contains(MeshPipelineViewLayoutKey::OIT_ENABLED) {\n        // Check if the GPU supports writable storage buffers in the fragment shader\n        // If not, we can't use OIT, so we skip the OIT bindings.\n        // This is a hack to avoid errors on webgl -- the OIT plugin will warn the user that OIT\n        // is not supported on their platform, so we don't need to do it here.\n        if render_adapter\n            .get_downlevel_capabilities()\n            .flags\n            .contains(DownlevelFlags::FRAGMENT_WRITABLE_STORAGE)\n        {\n            entries = entries.extend_with_indices((\n                // oit_layers\n                (31, storage_buffer_sized(false, None)),\n                // oit_layer_ids,\n                (32, storage_buffer_sized(false, None)),\n                // oit_layer_count\n                (33, uniform_buffer::<i32>(true)),\n            ));\n        }\n    }\n\n    entries.to_vec()\n}\n\n/// Stores the view layouts for every combination of pipeline keys.\n///\n/// This is wrapped in an [`Arc`] so that it can be efficiently cloned and\n/// placed inside specializable pipeline types.\n#[derive(Resource, Clone, Deref, DerefMut)]\npub struct MeshPipelineViewLayouts(\n    pub Arc<[MeshPipelineViewLayout; MeshPipelineViewLayoutKey::COUNT]>,\n);\n\nimpl FromWorld for MeshPipelineViewLayouts {\n    fn from_world(world: &mut World) -> Self {\n        // Generates all possible view layouts for the mesh pipeline, based on all combinations of\n        // [`MeshPipelineViewLayoutKey`] flags.\n\n        let render_device = world.resource::<RenderDevice>();\n        let render_adapter = world.resource::<RenderAdapter>();\n\n        let clustered_forward_buffer_binding_type = render_device\n            .get_supported_read_only_binding_type(CLUSTERED_FORWARD_STORAGE_BUFFER_COUNT);\n        let visibility_ranges_buffer_binding_type = render_device\n            .get_supported_read_only_binding_type(VISIBILITY_RANGES_STORAGE_BUFFER_COUNT);\n\n        Self(Arc::new(array::from_fn(|i| {\n            let key = MeshPipelineViewLayoutKey::from_bits_truncate(i as u32);\n            let entries = layout_entries(\n                clustered_forward_buffer_binding_type,\n                visibility_ranges_buffer_binding_type,\n                key,\n                render_device,\n                render_adapter,\n            );\n            #[cfg(debug_assertions)]\n            let texture_count: usize = entries\n                .iter()\n                .filter(|entry| matches!(entry.ty, BindingType::Texture { .. }))\n                .count();\n\n            MeshPipelineViewLayout {\n                bind_group_layout: render_device\n                    .create_bind_group_layout(key.label().as_str(), &entries),\n                #[cfg(debug_assertions)]\n                texture_count,\n            }\n        })))\n    }\n}\n\nimpl MeshPipelineViewLayouts {\n    pub fn get_view_layout(&self, layout_key: MeshPipelineViewLayoutKey) -> &BindGroupLayout {\n        let index = layout_key.bits() as usize;\n        let layout = &self[index];\n\n        #[cfg(debug_assertions)]\n        if layout.texture_count > MESH_PIPELINE_VIEW_LAYOUT_SAFE_MAX_TEXTURES {\n            // Issue our own warning here because Naga's error message is a bit cryptic in this situation\n            warn_once!(\"Too many textures in mesh pipeline view layout, this might cause us to hit `wgpu::Limits::max_sampled_textures_per_shader_stage` in some environments.\");\n        }\n\n        &layout.bind_group_layout\n    }\n}\n\n/// Generates all possible view layouts for the mesh pipeline, based on all combinations of\n/// [`MeshPipelineViewLayoutKey`] flags.\npub fn generate_view_layouts(\n    render_device: &RenderDevice,\n    render_adapter: &RenderAdapter,\n    clustered_forward_buffer_binding_type: BufferBindingType,\n    visibility_ranges_buffer_binding_type: BufferBindingType,\n) -> [MeshPipelineViewLayout; MeshPipelineViewLayoutKey::COUNT] {\n    array::from_fn(|i| {\n        let key = MeshPipelineViewLayoutKey::from_bits_truncate(i as u32);\n        let entries = layout_entries(\n            clustered_forward_buffer_binding_type,\n            visibility_ranges_buffer_binding_type,\n            key,\n            render_device,\n            render_adapter,\n        );\n\n        #[cfg(debug_assertions)]\n        let texture_count: usize = entries\n            .iter()\n            .filter(|entry| matches!(entry.ty, BindingType::Texture { .. }))\n            .count();\n\n        MeshPipelineViewLayout {\n            bind_group_layout: render_device\n                .create_bind_group_layout(key.label().as_str(), &entries),\n            #[cfg(debug_assertions)]\n            texture_count,\n        }\n    })\n}\n\n#[derive(Component)]\npub struct MeshViewBindGroup {\n    pub value: BindGroup,\n}\n\n#[allow(clippy::too_many_arguments)]\npub fn prepare_mesh_view_bind_groups(\n    mut commands: Commands,\n    render_device: Res<RenderDevice>,\n    mesh_pipeline: Res<MeshPipeline>,\n    shadow_samplers: Res<ShadowSamplers>,\n    (light_meta, global_light_meta): (Res<LightMeta>, Res<GlobalClusterableObjectMeta>),\n    fog_meta: Res<FogMeta>,\n    (view_uniforms, environment_map_uniform): (Res<ViewUniforms>, Res<EnvironmentMapUniformBuffer>),\n    views: Query<(\n        Entity,\n        &ViewShadowBindings,\n        &ViewClusterBindings,\n        &Msaa,\n        Option<&ScreenSpaceAmbientOcclusionResources>,\n        Option<&ViewPrepassTextures>,\n        Option<&ViewTransmissionTexture>,\n        &Tonemapping,\n        Option<&RenderViewLightProbes<EnvironmentMapLight>>,\n        Option<&RenderViewLightProbes<IrradianceVolume>>,\n        Has<OrderIndependentTransparencySettings>,\n    )>,\n    (images, mut fallback_images, fallback_image, fallback_image_zero): (\n        Res<RenderAssets<GpuImage>>,\n        FallbackImageMsaa,\n        Res<FallbackImage>,\n        Res<FallbackImageZero>,\n    ),\n    globals_buffer: Res<GlobalsBuffer>,\n    tonemapping_luts: Res<TonemappingLuts>,\n    light_probes_buffer: Res<LightProbesBuffer>,\n    visibility_ranges: Res<RenderVisibilityRanges>,\n    ssr_buffer: Res<ScreenSpaceReflectionsBuffer>,\n    oit_buffers: Res<OitBuffers>,\n) {\n    if let (\n        Some(view_binding),\n        Some(light_binding),\n        Some(clusterable_objects_binding),\n        Some(globals),\n        Some(fog_binding),\n        Some(light_probes_binding),\n        Some(visibility_ranges_buffer),\n        Some(ssr_binding),\n        Some(environment_map_binding),\n    ) = (\n        view_uniforms.uniforms.binding(),\n        light_meta.view_gpu_lights.binding(),\n        global_light_meta.gpu_clusterable_objects.binding(),\n        globals_buffer.buffer.binding(),\n        fog_meta.gpu_fogs.binding(),\n        light_probes_buffer.binding(),\n        visibility_ranges.buffer().buffer(),\n        ssr_buffer.binding(),\n        environment_map_uniform.binding(),\n    ) {\n        for (\n            entity,\n            shadow_bindings,\n            cluster_bindings,\n            msaa,\n            ssao_resources,\n            prepass_textures,\n            transmission_texture,\n            tonemapping,\n            render_view_environment_maps,\n            render_view_irradiance_volumes,\n            has_oit,\n        ) in &views\n        {\n            let fallback_ssao = fallback_images\n                .image_for_samplecount(1, TextureFormat::bevy_default())\n                .texture_view\n                .clone();\n            let ssao_view = ssao_resources\n                .map(|t| &t.screen_space_ambient_occlusion_texture.default_view)\n                .unwrap_or(&fallback_ssao);\n\n            let mut layout_key = MeshPipelineViewLayoutKey::from(*msaa)\n                | MeshPipelineViewLayoutKey::from(prepass_textures);\n            if has_oit {\n                layout_key |= MeshPipelineViewLayoutKey::OIT_ENABLED;\n            }\n\n            let layout = &mesh_pipeline.get_view_layout(layout_key);\n\n            let mut entries = DynamicBindGroupEntries::new_with_indices((\n                (0, view_binding.clone()),\n                (1, light_binding.clone()),\n                (2, &shadow_bindings.point_light_depth_texture_view),\n                (3, &shadow_samplers.point_light_comparison_sampler),\n                (4, &shadow_samplers.point_light_linear_sampler),\n                (5, &shadow_bindings.directional_light_depth_texture_view),\n                (6, &shadow_samplers.directional_light_comparison_sampler),\n                (7, &shadow_samplers.directional_light_linear_sampler),\n                (8, clusterable_objects_binding.clone()),\n                (\n                    9,\n                    cluster_bindings\n                        .clusterable_object_index_lists_binding()\n                        .unwrap(),\n                ),\n                (10, cluster_bindings.offsets_and_counts_binding().unwrap()),\n                (11, globals.clone()),\n                (12, fog_binding.clone()),\n                (13, light_probes_binding.clone()),\n                (14, visibility_ranges_buffer.as_entire_binding()),\n                (15, ssr_binding.clone()),\n                (16, ssao_view),\n            ));\n\n            let environment_map_bind_group_entries = RenderViewEnvironmentMapBindGroupEntries::get(\n                render_view_environment_maps,\n                &images,\n                &fallback_image,\n                &render_device,\n            );\n\n            match environment_map_bind_group_entries {\n                RenderViewEnvironmentMapBindGroupEntries::Single {\n                    diffuse_texture_view,\n                    specular_texture_view,\n                    sampler,\n                } => {\n                    entries = entries.extend_with_indices((\n                        (17, diffuse_texture_view),\n                        (18, specular_texture_view),\n                        (19, sampler),\n                        (20, environment_map_binding.clone()),\n                    ));\n                }\n                RenderViewEnvironmentMapBindGroupEntries::Multiple {\n                    ref diffuse_texture_views,\n                    ref specular_texture_views,\n                    sampler,\n                } => {\n                    entries = entries.extend_with_indices((\n                        (17, diffuse_texture_views.as_slice()),\n                        (18, specular_texture_views.as_slice()),\n                        (19, sampler),\n                        (20, environment_map_binding.clone()),\n                    ));\n                }\n            }\n\n            let irradiance_volume_bind_group_entries = if IRRADIANCE_VOLUMES_ARE_USABLE {\n                Some(RenderViewIrradianceVolumeBindGroupEntries::get(\n                    render_view_irradiance_volumes,\n                    &images,\n                    &fallback_image,\n                    &render_device,\n                ))\n            } else {\n                None\n            };\n\n            match irradiance_volume_bind_group_entries {\n                Some(RenderViewIrradianceVolumeBindGroupEntries::Single {\n                    texture_view,\n                    sampler,\n                }) => {\n                    entries = entries.extend_with_indices(((21, texture_view), (22, sampler)));\n                }\n                Some(RenderViewIrradianceVolumeBindGroupEntries::Multiple {\n                    ref texture_views,\n                    sampler,\n                }) => {\n                    entries = entries\n                        .extend_with_indices(((21, texture_views.as_slice()), (22, sampler)));\n                }\n                None => {}\n            }\n\n            let lut_bindings =\n                get_lut_bindings(&images, &tonemapping_luts, tonemapping, &fallback_image);\n            entries = entries.extend_with_indices(((23, lut_bindings.0), (24, lut_bindings.1)));\n\n            // When using WebGL, we can't have a depth texture with multisampling\n            let prepass_bindings;\n            if cfg!(any(not(feature = \"webgl\"), not(target_arch = \"wasm32\"))) || msaa.samples() == 1\n            {\n                prepass_bindings = prepass::get_bindings(prepass_textures);\n                for (binding, index) in prepass_bindings\n                    .iter()\n                    .map(Option::as_ref)\n                    .zip([25, 26, 27, 28])\n                    .flat_map(|(b, i)| b.map(|b| (b, i)))\n                {\n                    entries = entries.extend_with_indices(((index, binding),));\n                }\n            };\n\n            let transmission_view = transmission_texture\n                .map(|transmission| &transmission.view)\n                .unwrap_or(&fallback_image_zero.texture_view);\n\n            let transmission_sampler = transmission_texture\n                .map(|transmission| &transmission.sampler)\n                .unwrap_or(&fallback_image_zero.sampler);\n\n            entries =\n                entries.extend_with_indices(((29, transmission_view), (30, transmission_sampler)));\n\n            if has_oit {\n                if let (\n                    Some(oit_layers_binding),\n                    Some(oit_layer_ids_binding),\n                    Some(oit_layers_count_uniforms_binding),\n                ) = (\n                    oit_buffers.layers.binding(),\n                    oit_buffers.layer_ids.binding(),\n                    oit_buffers.layers_count_uniforms.binding(),\n                ) {\n                    entries = entries.extend_with_indices((\n                        (31, oit_layers_binding.clone()),\n                        (32, oit_layer_ids_binding.clone()),\n                        (33, oit_layers_count_uniforms_binding.clone()),\n                    ));\n                }\n            }\n\n            commands.entity(entity).insert(MeshViewBindGroup {\n                value: render_device.create_bind_group(\"mesh_view_bind_group\", layout, &entries),\n            });\n        }\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "030892b95d6dbc438d0b60fe0c2f38aa23c55f6d",
    "func": "use sea_orm_migration::prelude::*;\n\n#[async_std::main]\nasync fn main() {\n    cli::run_cli(migration::Migrator).await;\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "8f28ae788a5a826d6e70e6dbdc43c00f253640f1",
    "func": "use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(from = \"Option<T\")]\nenum TestOne {\n    Testing,\n    One,\n    Two,\n    Three,\n}\n\nfn main() {}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "3c7be724def486a27d4cc7115e4cf897e39fd41a",
    "func": "use proc_macro2::TokenStream;\nuse quote::{quote, ToTokens, TokenStreamExt};\nuse syn::parse::{Parse, ParseStream};\nuse syn::spanned::Spanned;\nuse syn::*;\n\npub struct ComponentBody {\n    pub item_fn: ItemFn,\n}\n\nimpl Parse for ComponentBody {\n    fn parse(input: ParseStream) -> Result<Self> {\n        let item_fn: ItemFn = input.parse()?;\n        validate_component_fn(&item_fn)?;\n        Ok(Self { item_fn })\n    }\n}\n\nimpl ToTokens for ComponentBody {\n    fn to_tokens(&self, tokens: &mut TokenStream) {\n        // https://github.com/DioxusLabs/dioxus/issues/1938\n        // If there's only one input and the input is `props: Props`, we don't need to generate a props struct\n        // Just attach the non_snake_case attribute to the function\n        // eventually we'll dump this metadata into devtooling that lets us find all these components\n        //\n        // Components can also use the struct pattern to \"inline\" their props.\n        // Freya uses this a bunch (because it's clean),\n        // e.g. `fn Navbar(NavbarProps { title }: NavbarProps)` was previously being incorrectly parsed\n        if self.is_explicit_props_ident() || self.has_struct_parameter_pattern() {\n            let comp_fn = &self.item_fn;\n            tokens.append_all(allow_camel_case_for_fn_ident(comp_fn).into_token_stream());\n            return;\n        }\n\n        let comp_fn = self.comp_fn();\n\n        // If there's no props declared, we simply omit the props argument\n        // This is basically so you can annotate the App component with #[component] and still be compatible with the\n        // launch signatures that take fn() -> Element\n        let props_struct = match self.item_fn.sig.inputs.is_empty() {\n            // No props declared, so we don't need to generate a props struct\n            true => quote! {},\n\n            // Props declared, so we generate a props struct and then also attach the doc attributes to it\n            false => {\n                let doc = format!(\"Properties for the [`{}`] component.\", &comp_fn.sig.ident);\n                let props_struct = self.props_struct();\n                quote! {\n                    #[doc = #doc]\n                    #props_struct\n                }\n            }\n        };\n\n        let completion_hints = self.completion_hints();\n\n        tokens.append_all(quote! {\n            #props_struct\n            #comp_fn\n\n            #completion_hints\n        });\n    }\n}\n\nimpl ComponentBody {\n    // build a new item fn, transforming the original item fn\n    fn comp_fn(&self) -> ItemFn {\n        let ComponentBody { item_fn, .. } = self;\n        let ItemFn {\n            attrs,\n            vis,\n            sig,\n            block,\n        } = item_fn;\n        let Signature {\n            inputs,\n            ident: fn_ident,\n            generics,\n            output: fn_output,\n            ..\n        } = sig;\n\n        let Generics { where_clause, .. } = generics;\n        let (_, impl_generics, _) = generics.split_for_impl();\n        let generics_turbofish = impl_generics.as_turbofish();\n\n        // We generate a struct with the same name as the component but called `Props`\n        let struct_ident = Ident::new(&format!(\"{fn_ident}Props\"), fn_ident.span());\n\n        // We pull in the field names from the original function signature, but need to strip off the mutability\n        let struct_field_names = inputs.iter().map(rebind_mutability);\n\n        let props_docs = self.props_docs(inputs.iter().collect());\n\n        let inlined_props_argument = if inputs.is_empty() {\n            quote! {}\n        } else {\n            quote! { #struct_ident { #(#struct_field_names),* }: #struct_ident #impl_generics }\n        };\n\n        // The extra nest is for the snake case warning to kick back in\n        parse_quote! {\n            #(#attrs)*\n            #(#props_docs)*\n            #[allow(non_snake_case)]\n            #vis fn #fn_ident #generics (#inlined_props_argument) #fn_output #where_clause {\n                {\n                    // In debug mode we can detect if the user is calling the component like a function\n                    dioxus_core::internal::verify_component_called_as_component(#fn_ident #generics_turbofish);\n                    #block\n                }\n            }\n        }\n    }\n\n    /// Build an associated struct for the props of the component\n    ///\n    /// This will expand to the typed-builder implementation that we have vendored in this crate.\n    /// TODO: don't vendor typed-builder and instead transform the tokens we give it before expansion.\n    /// TODO: cache these tokens since this codegen is rather expensive (lots of tokens)\n    ///\n    /// We try our best to transfer over any declared doc attributes from the original function signature onto the\n    /// props struct fields.\n    fn props_struct(&self) -> ItemStruct {\n        let ItemFn { vis, sig, .. } = &self.item_fn;\n        let Signature {\n            inputs,\n            ident,\n            generics,\n            ..\n        } = sig;\n\n        let struct_fields = inputs.iter().map(move |f| make_prop_struct_field(f, vis));\n        let struct_ident = Ident::new(&format!(\"{ident}Props\"), ident.span());\n\n        parse_quote! {\n            #[derive(Props, Clone, PartialEq)]\n            #[allow(non_camel_case_types)]\n            #vis struct #struct_ident #generics {\n                #(#struct_fields),*\n            }\n        }\n    }\n\n    /// Convert a list of function arguments into a list of doc attributes for the props struct\n    ///\n    /// This lets us generate set of attributes that we can apply to the props struct to give it a nice docstring.\n    fn props_docs(&self, inputs: Vec<&FnArg>) -> Vec<Attribute> {\n        let fn_ident = &self.item_fn.sig.ident;\n\n        if inputs.is_empty() {\n            return Vec::new();\n        }\n\n        let arg_docs = inputs\n            .iter()\n            .filter_map(|f| build_doc_fields(f))\n            .collect::<Vec<_>>();\n\n        let mut props_docs = Vec::with_capacity(5);\n        let props_def_link = fn_ident.to_string() + \"Props\";\n        let header =\n            format!(\"# Props\\n*For details, see the [props struct definition]({props_def_link}).*\");\n\n        props_docs.push(parse_quote! {\n            #[doc = #header]\n        });\n\n        for arg in arg_docs {\n            let DocField {\n                arg_name,\n                arg_type,\n                deprecation,\n                input_arg_doc,\n            } = arg;\n\n            let arg_name = strip_pat_mutability(arg_name).to_token_stream().to_string();\n            let arg_type = crate::utils::format_type_string(arg_type);\n\n            let input_arg_doc = keep_up_to_n_consecutive_chars(input_arg_doc.trim(), 2, '\\n')\n                .replace(\"\\n\\n\", \"</p><p>\");\n            let prop_def_link = format!(\"{props_def_link}::{arg_name}\");\n            let mut arg_doc = format!(\"- [`{arg_name}`]({prop_def_link}) : `{arg_type}`\");\n\n            if let Some(deprecation) = deprecation {\n                arg_doc.push_str(\"<p>\ud83d\udc4e Deprecated\");\n\n                if let Some(since) = deprecation.since {\n                    arg_doc.push_str(&format!(\" since {since}\"));\n                }\n\n                if let Some(note) = deprecation.note {\n                    let note = keep_up_to_n_consecutive_chars(&note, 1, '\\n').replace('\\n', \" \");\n                    let note = keep_up_to_n_consecutive_chars(&note, 1, '\\t').replace('\\t', \" \");\n\n                    arg_doc.push_str(&format!(\": {note}\"));\n                }\n\n                arg_doc.push_str(\"</p>\");\n\n                if !input_arg_doc.is_empty() {\n                    arg_doc.push_str(\"<hr/>\");\n                }\n            }\n\n            if !input_arg_doc.is_empty() {\n                arg_doc.push_str(&format!(\"<p>{input_arg_doc}</p>\"));\n            }\n\n            props_docs.push(parse_quote! { #[doc = #arg_doc] });\n        }\n\n        props_docs\n    }\n\n    fn is_explicit_props_ident(&self) -> bool {\n        if let Some(FnArg::Typed(PatType { pat, .. })) = self.item_fn.sig.inputs.first() {\n            if let Pat::Ident(ident) = pat.as_ref() {\n                return ident.ident == \"props\";\n            }\n        }\n\n        false\n    }\n\n    fn has_struct_parameter_pattern(&self) -> bool {\n        if let Some(FnArg::Typed(PatType { pat, .. })) = self.item_fn.sig.inputs.first() {\n            if matches!(pat.as_ref(), Pat::Struct(_)) {\n                return true;\n            }\n        }\n\n        false\n    }\n\n    // We generate an extra enum to help us autocomplete the braces after the component.\n    // This is a bit of a hack, but it's the only way to get the braces to autocomplete.\n    fn completion_hints(&self) -> TokenStream {\n        let comp_fn = &self.item_fn.sig.ident;\n        let completions_mod = Ident::new(&format!(\"{}_completions\", comp_fn), comp_fn.span());\n\n        let vis = &self.item_fn.vis;\n\n        quote! {\n            #[allow(non_snake_case)]\n            #[doc(hidden)]\n            mod #completions_mod {\n                #[doc(hidden)]\n                #[allow(non_camel_case_types)]\n                /// This enum is generated to help autocomplete the braces after the component. It does nothing\n                pub enum Component {\n                    #comp_fn {}\n                }\n            }\n\n            #[allow(unused)]\n            #vis use #completions_mod::Component::#comp_fn;\n        }\n    }\n}\n\nstruct DocField<'a> {\n    arg_name: &'a Pat,\n    arg_type: &'a Type,\n    deprecation: Option<crate::utils::DeprecatedAttribute>,\n    input_arg_doc: String,\n}\n\nfn build_doc_fields(f: &FnArg) -> Option<DocField> {\n    let FnArg::Typed(pt) = f else { unreachable!() };\n\n    let arg_doc = pt\n        .attrs\n        .iter()\n        .filter_map(|attr| {\n            // TODO: Error reporting\n            // Check if the path of the attribute is \"doc\"\n            if !is_attr_doc(attr) {\n                return None;\n            };\n\n            let Meta::NameValue(meta_name_value) = &attr.meta else {\n                return None;\n            };\n\n            let Expr::Lit(doc_lit) = &meta_name_value.value else {\n                return None;\n            };\n\n            let Lit::Str(doc_lit_str) = &doc_lit.lit else {\n                return None;\n            };\n\n            Some(doc_lit_str.value())\n        })\n        .fold(String::new(), |mut doc, next_doc_line| {\n            doc.push('\\n');\n            doc.push_str(&next_doc_line);\n            doc\n        });\n\n    Some(DocField {\n        arg_name: &pt.pat,\n        arg_type: &pt.ty,\n        deprecation: pt.attrs.iter().find_map(|attr| {\n            if !attr.path().is_ident(\"deprecated\") {\n                return None;\n            }\n\n            let res = crate::utils::DeprecatedAttribute::from_meta(&attr.meta);\n\n            match res {\n                Err(e) => panic!(\"{}\", e.to_string()),\n                Ok(v) => Some(v),\n            }\n        }),\n        input_arg_doc: arg_doc,\n    })\n}\n\nfn validate_component_fn(item_fn: &ItemFn) -> Result<()> {\n    // Do some validation....\n    // 1. Ensure the component returns *something*\n    if item_fn.sig.output == ReturnType::Default {\n        return Err(Error::new(\n            item_fn.sig.output.span(),\n            \"Must return a <dioxus_core::Element>\".to_string(),\n        ));\n    }\n\n    // 2. make sure there's no lifetimes on the component - we don't know how to handle those\n    if item_fn.sig.generics.lifetimes().count() > 0 {\n        return Err(Error::new(\n            item_fn.sig.generics.span(),\n            \"Lifetimes are not supported in components\".to_string(),\n        ));\n    }\n\n    // 3. we can't handle async components\n    if item_fn.sig.asyncness.is_some() {\n        return Err(Error::new(\n            item_fn.sig.asyncness.span(),\n            \"Async components are not supported\".to_string(),\n        ));\n    }\n\n    // 4. we can't handle const components\n    if item_fn.sig.constness.is_some() {\n        return Err(Error::new(\n            item_fn.sig.constness.span(),\n            \"Const components are not supported\".to_string(),\n        ));\n    }\n\n    // 5. no receiver parameters\n    if item_fn\n        .sig\n        .inputs\n        .iter()\n        .any(|f| matches!(f, FnArg::Receiver(_)))\n    {\n        return Err(Error::new(\n            item_fn.sig.inputs.span(),\n            \"Receiver parameters are not supported\".to_string(),\n        ));\n    }\n\n    Ok(())\n}\n\n/// Convert a function arg with a given visibility (provided by the function) and then generate a field for the\n/// associated props struct.\nfn make_prop_struct_field(f: &FnArg, vis: &Visibility) -> TokenStream {\n    // There's no receivers (&self) allowed in the component body\n    let FnArg::Typed(pt) = f else { unreachable!() };\n\n    let arg_pat = match pt.pat.as_ref() {\n        // rip off mutability\n        // todo: we actually don't want any of the extra bits of the field pattern\n        Pat::Ident(f) => {\n            let mut f = f.clone();\n            f.mutability = None;\n            quote! { #f }\n        }\n        a => quote! { #a },\n    };\n\n    let PatType {\n        attrs,\n        ty,\n        colon_token,\n        ..\n    } = pt;\n\n    quote! {\n        #(#attrs)*\n        #vis #arg_pat #colon_token #ty\n    }\n}\n\nfn rebind_mutability(f: &FnArg) -> TokenStream {\n    // There's no receivers (&self) allowed in the component body\n    let FnArg::Typed(pt) = f else { unreachable!() };\n\n    let immutable = strip_pat_mutability(&pt.pat);\n\n    quote!(mut #immutable)\n}\n\nfn strip_pat_mutability(pat: &Pat) -> Pat {\n    let mut pat = pat.clone();\n    // rip off mutability, but still write it out eventually\n    if let Pat::Ident(ref mut pat_ident) = &mut pat {\n        pat_ident.mutability = None;\n    }\n\n    pat\n}\n\n/// Checks if the attribute is a `#[doc]` attribute.\nfn is_attr_doc(attr: &Attribute) -> bool {\n    attr.path() == &parse_quote!(doc)\n}\n\nfn keep_up_to_n_consecutive_chars(\n    input: &str,\n    n_of_consecutive_chars_allowed: usize,\n    target_char: char,\n) -> String {\n    let mut output = String::new();\n    let mut prev_char: Option<char> = None;\n    let mut consecutive_count = 0;\n\n    for c in input.chars() {\n        match prev_char {\n            Some(prev) if c == target_char && prev == target_char => {\n                if consecutive_count < n_of_consecutive_chars_allowed {\n                    output.push(c);\n                    consecutive_count += 1;\n                }\n            }\n            _ => {\n                output.push(c);\n                prev_char = Some(c);\n                consecutive_count = 1;\n            }\n        }\n    }\n\n    output\n}\n\n/// Takes a function and returns a clone of it where an `UpperCamelCase` identifier is allowed by the compiler.\nfn allow_camel_case_for_fn_ident(item_fn: &ItemFn) -> ItemFn {\n    let mut clone = item_fn.clone();\n    let block = &item_fn.block;\n\n    clone.attrs.push(parse_quote! { #[allow(non_snake_case)] });\n\n    clone.block = parse_quote! {\n        {\n            #block\n        }\n    };\n\n    clone\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "3b8e5be246ba13c21f4987489f72be88894b878b",
    "func": "//! This example illustrates how to create buttons with their textures sliced\n//! and kept in proportion instead of being stretched by the button dimensions\n\nuse bevy::{\n    color::palettes::css::{GOLD, ORANGE},\n    prelude::*,\n    winit::WinitSettings,\n};\n\nfn main() {\n    App::new()\n        .add_plugins(DefaultPlugins)\n        // Only run the app when there is user input. This will significantly reduce CPU/GPU use.\n        .insert_resource(WinitSettings::desktop_app())\n        .add_systems(Startup, setup)\n        .add_systems(Update, button_system)\n        .run();\n}\n\nfn button_system(\n    mut interaction_query: Query<\n        (&Interaction, &Children, &mut UiImage),\n        (Changed<Interaction>, With<Button>),\n    >,\n    mut text_query: Query<&mut Text>,\n) {\n    for (interaction, children, mut image) in &mut interaction_query {\n        let mut text = text_query.get_mut(children[0]).unwrap();\n        match *interaction {\n            Interaction::Pressed => {\n                **text = \"Press\".to_string();\n                image.color = GOLD.into();\n            }\n            Interaction::Hovered => {\n                **text = \"Hover\".to_string();\n                image.color = ORANGE.into();\n            }\n            Interaction::None => {\n                **text = \"Button\".to_string();\n                image.color = Color::WHITE;\n            }\n        }\n    }\n}\n\nfn setup(mut commands: Commands, asset_server: Res<AssetServer>) {\n    let image = asset_server.load(\"textures/fantasy_ui_borders/panel-border-010.png\");\n\n    let slicer = TextureSlicer {\n        border: BorderRect::square(22.0),\n        center_scale_mode: SliceScaleMode::Stretch,\n        sides_scale_mode: SliceScaleMode::Stretch,\n        max_corner_scale: 1.0,\n    };\n    // ui camera\n    commands.spawn(Camera2d);\n    commands\n        .spawn(Node {\n            width: Val::Percent(100.0),\n            height: Val::Percent(100.0),\n            align_items: AlignItems::Center,\n            justify_content: JustifyContent::Center,\n            ..default()\n        })\n        .with_children(|parent| {\n            for [w, h] in [[150.0, 150.0], [300.0, 150.0], [150.0, 300.0]] {\n                parent\n                    .spawn((\n                        Button,\n                        Node {\n                            width: Val::Px(w),\n                            height: Val::Px(h),\n                            // horizontally center child text\n                            justify_content: JustifyContent::Center,\n                            // vertically center child text\n                            align_items: AlignItems::Center,\n                            margin: UiRect::all(Val::Px(20.0)),\n                            ..default()\n                        },\n                        UiImage::new(image.clone()),\n                        ImageScaleMode::Sliced(slicer.clone()),\n                    ))\n                    .with_children(|parent| {\n                        parent.spawn((\n                            Text::new(\"Button\"),\n                            TextFont {\n                                font: asset_server.load(\"fonts/FiraSans-Bold.ttf\"),\n                                font_size: 33.0,\n                                ..default()\n                            },\n                            TextColor(Color::srgb(0.9, 0.9, 0.9)),\n                        ));\n                    });\n            }\n        });\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "49390da2ab485cace2596b32971bae103da02a7f",
    "func": "// Copyright 2024 Cloudflare, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#[cfg(feature = \"dhat-heap\")]\n#[global_allocator]\nstatic ALLOC: dhat::Alloc = dhat::Alloc;\n\nuse ahash::RandomState;\nuse dashmap::DashMap;\nuse pingora_limits::estimator::Estimator;\nuse rand::distributions::Uniform;\nuse rand::{thread_rng, Rng};\nuse std::collections::HashMap;\nuse std::sync::atomic::{AtomicUsize, Ordering};\nuse std::sync::Arc;\nuse std::sync::Mutex;\nuse std::thread;\nuse std::time::Instant;\n\ntrait Counter {\n    fn incr(&self, key: u32, value: usize);\n    fn name() -> &'static str;\n}\n\n#[derive(Default)]\nstruct NaiveCounter(Mutex<HashMap<u32, usize>>);\nimpl Counter for NaiveCounter {\n    fn incr(&self, key: u32, value: usize) {\n        let mut map = self.0.lock().unwrap();\n        if let Some(v) = map.get_mut(&key) {\n            *v += value;\n        } else {\n            map.insert(key, value);\n        }\n    }\n\n    fn name() -> &'static str {\n        \"Naive Counter\"\n    }\n}\n\n#[derive(Default)]\nstruct OptimizedCounter(DashMap<u32, AtomicUsize, RandomState>);\nimpl Counter for OptimizedCounter {\n    fn incr(&self, key: u32, value: usize) {\n        if let Some(v) = self.0.get(&key) {\n            v.fetch_add(value, Ordering::Relaxed);\n            return;\n        }\n        self.0.insert(key, AtomicUsize::new(value));\n    }\n\n    fn name() -> &'static str {\n        \"Optimized Counter\"\n    }\n}\n\nimpl Counter for Estimator {\n    fn incr(&self, key: u32, value: usize) {\n        self.incr(key, value as isize);\n    }\n\n    fn name() -> &'static str {\n        \"Pingora Estimator\"\n    }\n}\n\nfn run_bench<T: Counter>(\n    counter: &T,\n    samples: usize,\n    distribution: &Uniform<u32>,\n    test_name: &str,\n) {\n    let mut rng = thread_rng();\n    let before = Instant::now();\n    for _ in 0..samples {\n        let event: u32 = rng.sample(distribution);\n        counter.incr(event, 1);\n    }\n    let elapsed = before.elapsed();\n    println!(\n        \"{} {test_name} {:?} total, {:?} avg per operation\",\n        T::name(),\n        elapsed,\n        elapsed / samples as u32\n    );\n}\n\nfn run_threaded_bench<T: Counter + Send + Sync + 'static>(\n    threads: usize,\n    counter: Arc<T>,\n    samples: usize,\n    distribution: &Uniform<u32>,\n) {\n    let mut handlers = vec![];\n    for i in 0..threads {\n        let est = counter.clone();\n        let dist = *distribution;\n        let handler = thread::spawn(move || {\n            run_bench(est.as_ref(), samples, &dist, &format!(\"thread#{i}\"));\n        });\n        handlers.push(handler);\n    }\n    for thread in handlers {\n        thread.join().unwrap();\n    }\n}\n\n/*\nPingora Estimator single thread 1.042849543s total, 10ns avg per operation\nNaive Counter single thread 5.12641496s total, 51ns avg per operation\nOptimized Counter single thread 4.302553352s total, 43ns avg per operation\nPingora Estimator thread#7 2.654667606s total, 212ns avg per operation\nPingora Estimator thread#2 2.65651993s total, 212ns avg per operation\nPingora Estimator thread#4 2.658225266s total, 212ns avg per operation\nPingora Estimator thread#0 2.660603361s total, 212ns avg per operation\nPingora Estimator thread#1 2.66139014s total, 212ns avg per operation\nPingora Estimator thread#6 2.663498849s total, 213ns avg per operation\nPingora Estimator thread#5 2.663344276s total, 213ns avg per operation\nPingora Estimator thread#3 2.664652951s total, 213ns avg per operation\nNaive Counter thread#7 18.795881242s total, 1.503\u00b5s avg per operation\nNaive Counter thread#1 18.805652672s total, 1.504\u00b5s avg per operation\nNaive Counter thread#6 18.818084416s total, 1.505\u00b5s avg per operation\nNaive Counter thread#4 18.832778982s total, 1.506\u00b5s avg per operation\nNaive Counter thread#3 18.833952715s total, 1.506\u00b5s avg per operation\nNaive Counter thread#2 18.837975133s total, 1.507\u00b5s avg per operation\nNaive Counter thread#0 18.8397464s total, 1.507\u00b5s avg per operation\nNaive Counter thread#5 18.842616299s total, 1.507\u00b5s avg per operation\nOptimized Counter thread#4 2.650860314s total, 212ns avg per operation\nOptimized Counter thread#0 2.651867013s total, 212ns avg per operation\nOptimized Counter thread#2 2.656473381s total, 212ns avg per operation\nOptimized Counter thread#5 2.657715876s total, 212ns avg per operation\nOptimized Counter thread#1 2.658275111s total, 212ns avg per operation\nOptimized Counter thread#7 2.658770751s total, 212ns avg per operation\nOptimized Counter thread#6 2.659831251s total, 212ns avg per operation\nOptimized Counter thread#3 2.664375398s total, 213ns avg per operation\n*/\n\n/* cargo bench --features dhat-heap for memory info\n\nPingora Estimator single thread 1.066846098s total, 10ns avg per operation\ndhat: Total:     26,184 bytes in 9 blocks\ndhat: At t-gmax: 26,184 bytes in 9 blocks\ndhat: At t-end:  1,464 bytes in 5 blocks\ndhat: The data has been saved to dhat-heap.json, and is viewable with dhat/dh_view.html\nNaive Counter single thread 5.429089242s total, 54ns avg per operation\ndhat: Total:     71,303,260 bytes in 20 blocks\ndhat: At t-gmax: 53,477,392 bytes in 2 blocks\ndhat: At t-end:  0 bytes in 0 blocks\ndhat: The data has been saved to dhat-heap.json, and is viewable with dhat/dh_view.html\nOptimized Counter single thread 4.361720355s total, 43ns avg per operation\ndhat: Total:     71,307,722 bytes in 491 blocks\ndhat: At t-gmax: 36,211,208 bytes in 34 blocks\ndhat: At t-end:  0 bytes in 0 blocks\ndhat: The data has been saved to dhat-heap.json, and is viewable with dhat/dh_view.html\n*/\n\nfn main() {\n    const SAMPLES: usize = 100_000_000;\n    const THREADS: usize = 8;\n    const ITEMS: u32 = 1_000_000;\n    const SAMPLES_PER_THREAD: usize = SAMPLES / THREADS;\n    let distribution = Uniform::new(0, ITEMS);\n\n    // single thread\n    {\n        #[cfg(feature = \"dhat-heap\")]\n        let _profiler = dhat::Profiler::new_heap();\n        let pingora_est = Estimator::new(3, 1024);\n        run_bench(&pingora_est, SAMPLES, &distribution, \"single thread\");\n    }\n\n    {\n        #[cfg(feature = \"dhat-heap\")]\n        let _profiler = dhat::Profiler::new_heap();\n        let naive: NaiveCounter = Default::default();\n        run_bench(&naive, SAMPLES, &distribution, \"single thread\");\n    }\n\n    {\n        #[cfg(feature = \"dhat-heap\")]\n        let _profiler = dhat::Profiler::new_heap();\n        let optimized: OptimizedCounter = Default::default();\n        run_bench(&optimized, SAMPLES, &distribution, \"single thread\");\n    }\n\n    // multithread\n    let pingora_est = Arc::new(Estimator::new(3, 1024));\n    run_threaded_bench(THREADS, pingora_est, SAMPLES_PER_THREAD, &distribution);\n\n    let naive: Arc<NaiveCounter> = Default::default();\n    run_threaded_bench(THREADS, naive, SAMPLES_PER_THREAD, &distribution);\n\n    let optimized: Arc<OptimizedCounter> = Default::default();\n    run_threaded_bench(THREADS, optimized, SAMPLES_PER_THREAD, &distribution);\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "779500ff24f8bea3ea415a0a0dc6eadf9bb027e0",
    "func": "#![allow(clippy::needless_lifetimes)]\n\nmod regression {\n    automod::dir!(\"tests/regression\");\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "3d91b35b856f49775ab7a06a1ef19a1d9d558cef",
    "func": "use super::downsampling_pipeline::BloomUniforms;\nuse bevy_ecs::{prelude::Component, query::QueryItem, reflect::ReflectComponent};\nuse bevy_math::{AspectRatio, URect, UVec4, Vec4};\nuse bevy_reflect::{std_traits::ReflectDefault, Reflect};\nuse bevy_render::{extract_component::ExtractComponent, prelude::Camera};\n\n/// Applies a bloom effect to an HDR-enabled 2d or 3d camera.\n///\n/// Bloom emulates an effect found in real cameras and the human eye,\n/// causing halos to appear around very bright parts of the scene.\n///\n/// See also <https://en.wikipedia.org/wiki/Bloom_(shader_effect)>.\n///\n/// # Usage Notes\n///\n/// **Bloom is currently not compatible with WebGL2.**\n///\n/// Often used in conjunction with `bevy_pbr::StandardMaterial::emissive` for 3d meshes.\n///\n/// Bloom is best used alongside a tonemapping function that desaturates bright colors,\n/// such as [`crate::tonemapping::Tonemapping::TonyMcMapface`].\n///\n/// Bevy's implementation uses a parametric curve to blend between a set of\n/// blurred (lower frequency) images generated from the camera's view.\n/// See <https://starlederer.github.io/bloom/> for a visualization of the parametric curve\n/// used in Bevy as well as a visualization of the curve's respective scattering profile.\n#[derive(Component, Reflect, Clone)]\n#[reflect(Component, Default)]\npub struct Bloom {\n    /// Controls the baseline of how much the image is scattered (default: 0.15).\n    ///\n    /// This parameter should be used only to control the strength of the bloom\n    /// for the scene as a whole. Increasing it too much will make the scene appear\n    /// blurry and over-exposed.\n    ///\n    /// To make a mesh glow brighter, rather than increase the bloom intensity,\n    /// you should increase the mesh's `emissive` value.\n    ///\n    /// # In energy-conserving mode\n    /// The value represents how likely the light is to scatter.\n    ///\n    /// The value should be between 0.0 and 1.0 where:\n    /// * 0.0 means no bloom\n    /// * 1.0 means the light is scattered as much as possible\n    ///\n    /// # In additive mode\n    /// The value represents how much scattered light is added to\n    /// the image to create the glow effect.\n    ///\n    /// In this configuration:\n    /// * 0.0 means no bloom\n    /// * Greater than 0.0 means a proportionate amount of scattered light is added\n    pub intensity: f32,\n\n    /// Low frequency contribution boost.\n    /// Controls how much more likely the light\n    /// is to scatter completely sideways (low frequency image).\n    ///\n    /// Comparable to a low shelf boost on an equalizer.\n    ///\n    /// # In energy-conserving mode\n    /// The value should be between 0.0 and 1.0 where:\n    /// * 0.0 means low frequency light uses base intensity for blend factor calculation\n    /// * 1.0 means low frequency light contributes at full power\n    ///\n    /// # In additive mode\n    /// The value represents how much scattered light is added to\n    /// the image to create the glow effect.\n    ///\n    /// In this configuration:\n    /// * 0.0 means no bloom\n    /// * Greater than 0.0 means a proportionate amount of scattered light is added\n    pub low_frequency_boost: f32,\n\n    /// Low frequency contribution boost curve.\n    /// Controls the curvature of the blend factor function\n    /// making frequencies next to the lowest ones contribute more.\n    ///\n    /// Somewhat comparable to the Q factor of an equalizer node.\n    ///\n    /// Valid range:\n    /// * 0.0 - base intensity and boosted intensity are linearly interpolated\n    /// * 1.0 - all frequencies below maximum are at boosted intensity level\n    pub low_frequency_boost_curvature: f32,\n\n    /// Tightens how much the light scatters (default: 1.0).\n    ///\n    /// Valid range:\n    /// * 0.0 - maximum scattering angle is 0 degrees (no scattering)\n    /// * 1.0 - maximum scattering angle is 90 degrees\n    pub high_pass_frequency: f32,\n\n    /// Controls the threshold filter used for extracting the brightest regions from the input image\n    /// before blurring them and compositing back onto the original image.\n    ///\n    /// Changing these settings creates a physically inaccurate image and makes it easy to make\n    /// the final result look worse. However, they can be useful when emulating the 1990s-2000s game look.\n    /// See [`BloomPrefilter`] for more information.\n    pub prefilter: BloomPrefilter,\n\n    /// Controls whether bloom textures\n    /// are blended between or added to each other. Useful\n    /// if image brightening is desired and a must-change\n    /// if `prefilter` is used.\n    ///\n    /// # Recommendation\n    /// Set to [`BloomCompositeMode::Additive`] if `prefilter` is\n    /// configured in a non-energy-conserving way,\n    /// otherwise set to [`BloomCompositeMode::EnergyConserving`].\n    pub composite_mode: BloomCompositeMode,\n\n    /// Maximum size of each dimension for the largest mipchain texture used in downscaling/upscaling.\n    /// Only tweak if you are seeing visual artifacts.\n    pub max_mip_dimension: u32,\n\n    /// UV offset for bloom shader. Ideally close to 2.0 / `max_mip_dimension`.\n    /// Only tweak if you are seeing visual artifacts.\n    pub uv_offset: f32,\n}\n\n#[deprecated(since = \"0.15.0\", note = \"Renamed to `Bloom`\")]\npub type BloomSettings = Bloom;\n\nimpl Bloom {\n    const DEFAULT_MAX_MIP_DIMENSION: u32 = 512;\n    const DEFAULT_UV_OFFSET: f32 = 0.004;\n\n    /// The default bloom preset.\n    ///\n    /// This uses the [`EnergyConserving`](BloomCompositeMode::EnergyConserving) composite mode.\n    pub const NATURAL: Self = Self {\n        intensity: 0.15,\n        low_frequency_boost: 0.7,\n        low_frequency_boost_curvature: 0.95,\n        high_pass_frequency: 1.0,\n        prefilter: BloomPrefilter {\n            threshold: 0.0,\n            threshold_softness: 0.0,\n        },\n        composite_mode: BloomCompositeMode::EnergyConserving,\n        max_mip_dimension: Self::DEFAULT_MAX_MIP_DIMENSION,\n        uv_offset: Self::DEFAULT_UV_OFFSET,\n    };\n\n    /// A preset that's similar to how older games did bloom.\n    pub const OLD_SCHOOL: Self = Self {\n        intensity: 0.05,\n        low_frequency_boost: 0.7,\n        low_frequency_boost_curvature: 0.95,\n        high_pass_frequency: 1.0,\n        prefilter: BloomPrefilter {\n            threshold: 0.6,\n            threshold_softness: 0.2,\n        },\n        composite_mode: BloomCompositeMode::Additive,\n        max_mip_dimension: Self::DEFAULT_MAX_MIP_DIMENSION,\n        uv_offset: Self::DEFAULT_UV_OFFSET,\n    };\n\n    /// A preset that applies a very strong bloom, and blurs the whole screen.\n    pub const SCREEN_BLUR: Self = Self {\n        intensity: 1.0,\n        low_frequency_boost: 0.0,\n        low_frequency_boost_curvature: 0.0,\n        high_pass_frequency: 1.0 / 3.0,\n        prefilter: BloomPrefilter {\n            threshold: 0.0,\n            threshold_softness: 0.0,\n        },\n        composite_mode: BloomCompositeMode::EnergyConserving,\n        max_mip_dimension: Self::DEFAULT_MAX_MIP_DIMENSION,\n        uv_offset: Self::DEFAULT_UV_OFFSET,\n    };\n}\n\nimpl Default for Bloom {\n    fn default() -> Self {\n        Self::NATURAL\n    }\n}\n\n/// Applies a threshold filter to the input image to extract the brightest\n/// regions before blurring them and compositing back onto the original image.\n/// These settings are useful when emulating the 1990s-2000s game look.\n///\n/// # Considerations\n/// * Changing these settings creates a physically inaccurate image\n/// * Changing these settings makes it easy to make the final result look worse\n/// * Non-default prefilter settings should be used in conjunction with [`BloomCompositeMode::Additive`]\n#[derive(Default, Clone, Reflect)]\npub struct BloomPrefilter {\n    /// Baseline of the quadratic threshold curve (default: 0.0).\n    ///\n    /// RGB values under the threshold curve will not contribute to the effect.\n    pub threshold: f32,\n\n    /// Controls how much to blend between the thresholded and non-thresholded colors (default: 0.0).\n    ///\n    /// 0.0 = Abrupt threshold, no blending\n    /// 1.0 = Fully soft threshold\n    ///\n    /// Values outside of the range [0.0, 1.0] will be clamped.\n    pub threshold_softness: f32,\n}\n\n#[deprecated(since = \"0.15.0\", note = \"Renamed to `BloomPrefilter`\")]\npub type BloomPrefilterSettings = BloomPrefilter;\n\n#[derive(Debug, Clone, Reflect, PartialEq, Eq, Hash, Copy)]\npub enum BloomCompositeMode {\n    EnergyConserving,\n    Additive,\n}\n\nimpl ExtractComponent for Bloom {\n    type QueryData = (&'static Self, &'static Camera);\n\n    type QueryFilter = ();\n    type Out = (Self, BloomUniforms);\n\n    fn extract_component((bloom, camera): QueryItem<'_, Self::QueryData>) -> Option<Self::Out> {\n        match (\n            camera.physical_viewport_rect(),\n            camera.physical_viewport_size(),\n            camera.physical_target_size(),\n            camera.is_active,\n            camera.hdr,\n        ) {\n            (Some(URect { min: origin, .. }), Some(size), Some(target_size), true, true)\n                if size.x != 0 && size.y != 0 =>\n            {\n                let threshold = bloom.prefilter.threshold;\n                let threshold_softness = bloom.prefilter.threshold_softness;\n                let knee = threshold * threshold_softness.clamp(0.0, 1.0);\n\n                let uniform = BloomUniforms {\n                    threshold_precomputations: Vec4::new(\n                        threshold,\n                        threshold - knee,\n                        2.0 * knee,\n                        0.25 / (knee + 0.00001),\n                    ),\n                    viewport: UVec4::new(origin.x, origin.y, size.x, size.y).as_vec4()\n                        / UVec4::new(target_size.x, target_size.y, target_size.x, target_size.y)\n                            .as_vec4(),\n                    aspect: AspectRatio::try_from_pixels(size.x, size.y)\n                        .expect(\"Valid screen size values for Bloom settings\")\n                        .ratio(),\n                    uv_offset: bloom.uv_offset,\n                };\n\n                Some((bloom.clone(), uniform))\n            }\n            _ => None,\n        }\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "348938362a5b7812e4b062f1e984f244008116e0",
    "func": "//! # [Ratatui] Logo example\n//!\n//! The latest version of this example is available in the [examples] folder in the repository.\n//!\n//! Please note that the examples are designed to be run against the `main` branch of the Github\n//! repository. This means that you may not be able to compile with the latest release version on\n//! crates.io, or the one that you have installed locally.\n//!\n//! See the [examples readme] for more information on finding examples that match the version of the\n//! library you are using.\n//!\n//! [Ratatui]: https://github.com/ratatui/ratatui\n//! [examples]: https://github.com/ratatui/ratatui/blob/main/examples\n//! [examples readme]: https://github.com/ratatui/ratatui/blob/main/examples/README.md\n\nuse std::env::args;\n\nuse color_eyre::Result;\nuse crossterm::event::{self, Event};\nuse ratatui::{\n    layout::{Constraint, Layout},\n    widgets::{RatatuiLogo, RatatuiLogoSize},\n    DefaultTerminal, TerminalOptions, Viewport,\n};\n\nfn main() -> Result<()> {\n    color_eyre::install()?;\n    let terminal = ratatui::init_with_options(TerminalOptions {\n        viewport: Viewport::Inline(3),\n    });\n    let size = match args().nth(1).as_deref() {\n        Some(\"small\") => RatatuiLogoSize::Small,\n        Some(\"tiny\") => RatatuiLogoSize::Tiny,\n        _ => RatatuiLogoSize::default(),\n    };\n    let result = run(terminal, size);\n    ratatui::restore();\n    println!();\n    result\n}\n\nfn run(mut terminal: DefaultTerminal, size: RatatuiLogoSize) -> Result<()> {\n    loop {\n        terminal.draw(|frame| {\n            use Constraint::{Fill, Length};\n            let [top, bottom] = Layout::vertical([Length(1), Fill(1)]).areas(frame.area());\n            frame.render_widget(\"Powered by\", top);\n            frame.render_widget(RatatuiLogo::new(size), bottom);\n        })?;\n        if matches!(event::read()?, Event::Key(_)) {\n            break Ok(());\n        }\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "37541fb21b071b893f80072cf6a26a301059a76b",
    "func": "//! The main html module which defines components, listeners, and class helpers.\n\nmod classes;\nmod component;\nmod conversion;\nmod error;\nmod listener;\n\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\npub use classes::*;\npub use component::*;\npub use conversion::*;\npub use error::*;\npub use listener::*;\nuse wasm_bindgen::JsValue;\nuse web_sys::{Element, Node};\n\nuse crate::sealed::Sealed;\nuse crate::virtual_dom::{VNode, VPortal};\n\n/// A type which expected as a result of `view` function implementation.\npub type Html = VNode;\n\n/// An enhanced type of `Html` returned in suspendible function components.\npub type HtmlResult = RenderResult<Html>;\n\nimpl Sealed for HtmlResult {}\nimpl Sealed for Html {}\n\n/// A trait to translate into a [`HtmlResult`].\npub trait IntoHtmlResult: Sealed {\n    /// Performs the conversion.\n    fn into_html_result(self) -> HtmlResult;\n}\n\nimpl IntoHtmlResult for HtmlResult {\n    #[inline(always)]\n    fn into_html_result(self) -> HtmlResult {\n        self\n    }\n}\nimpl IntoHtmlResult for Html {\n    #[inline(always)]\n    fn into_html_result(self) -> HtmlResult {\n        Ok(self)\n    }\n}\n\n/// Wrapped Node reference for later use in Component lifecycle methods.\n///\n/// # Example\n/// Focus an `<input>` element on mount.\n/// ```\n/// use web_sys::HtmlInputElement;\n/// # use yew::prelude::*;\n///\n/// pub struct Input {\n///     node_ref: NodeRef,\n/// }\n///\n/// impl Component for Input {\n///     type Message = ();\n///     type Properties = ();\n///\n///     fn create(_ctx: &Context<Self>) -> Self {\n///         Input {\n///             node_ref: NodeRef::default(),\n///         }\n///     }\n///\n///     fn rendered(&mut self, _ctx: &Context<Self>, first_render: bool) {\n///         if first_render {\n///             if let Some(input) = self.node_ref.cast::<HtmlInputElement>() {\n///                 input.focus();\n///             }\n///         }\n///     }\n///\n///     fn view(&self, _ctx: &Context<Self>) -> Html {\n///         html! {\n///             <input ref={self.node_ref.clone()} type=\"text\" />\n///         }\n///     }\n/// }\n/// ```\n/// ## Relevant examples\n/// - [Node Refs](https://github.com/yewstack/yew/tree/master/examples/node_refs)\n#[derive(Default, Clone)]\npub struct NodeRef(Rc<RefCell<NodeRefInner>>);\n\nimpl PartialEq for NodeRef {\n    fn eq(&self, other: &Self) -> bool {\n        self.0.as_ptr() == other.0.as_ptr()\n    }\n}\n\nimpl std::fmt::Debug for NodeRef {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        write!(\n            f,\n            \"NodeRef {{ references: {:?} }}\",\n            self.get().map(|n| crate::utils::print_node(&n))\n        )\n    }\n}\n\n#[derive(PartialEq, Debug, Default, Clone)]\nstruct NodeRefInner {\n    node: Option<Node>,\n}\n\nimpl NodeRef {\n    /// Get the wrapped Node reference if it exists\n    pub fn get(&self) -> Option<Node> {\n        let inner = self.0.borrow();\n        inner.node.clone()\n    }\n\n    /// Try converting the node reference into another form\n    pub fn cast<INTO: AsRef<Node> + From<JsValue>>(&self) -> Option<INTO> {\n        let node = self.get();\n        node.map(Into::into).map(INTO::from)\n    }\n}\n\n#[cfg(feature = \"csr\")]\nmod feat_csr {\n    use super::*;\n\n    impl NodeRef {\n        pub(crate) fn set(&self, new_ref: Option<Node>) {\n            let mut inner = self.0.borrow_mut();\n            inner.node = new_ref;\n        }\n    }\n}\n\n/// Render children into a DOM node that exists outside the hierarchy of the parent\n/// component.\n/// ## Relevant examples\n/// - [Portals](https://github.com/yewstack/yew/tree/master/examples/portals)\npub fn create_portal(child: Html, host: Element) -> Html {\n    VNode::VPortal(Rc::new(VPortal::new(child, host)))\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "7a37ce92c133114c80600361c98b2344e4547a4d",
    "func": "pub mod prelude {\n    pub use super::model::{\n        ActiveModel as ContainerActiveModel, Column as ContainerColumn, Entity as Container,\n        Model as ContainerModel, PrimaryKey as ContainerPrimaryKey, Relation as ContainerRelation,\n    };\n}\n\npub mod model {\n    use sea_orm::entity::prelude::*;\n\n    #[derive(Clone, Debug, PartialEq, DeriveEntityModel)]\n    #[sea_orm(table_name = \"container\")]\n    pub struct Model {\n        #[sea_orm(primary_key, column_name = \"db_id\")]\n        pub rust_id: i32,\n    }\n\n    #[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]\n    pub enum Relation {\n        #[sea_orm(has_many = \"crate::Content\")]\n        Content, // 1(Container) \u21c6 n(Content)\n    }\n\n    impl Related<crate::Content> for Entity {\n        fn to() -> RelationDef {\n            Relation::Content.def()\n        }\n    }\n\n    impl ActiveModelBehavior for ActiveModel {}\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "75d66a509eb1c1a95f398b5fd072ee134a45017e",
    "func": "use devise::*;\nuse devise::ext::SpanDiagnosticExt;\n\nuse quote::quote;\nuse proc_macro2::TokenStream;\nuse syn::ext::IdentExt;\n\nuse crate::exports::*;\n\npub fn derive_from_param(input: proc_macro::TokenStream) -> TokenStream {\n    DeriveGenerator::build_for(input, quote!(impl<'a> #_request::FromParam<'a>))\n        .support(Support::Enum)\n        .validator(ValidatorBuild::new().fields_validate(|_, fields| {\n            if !fields.is_empty() {\n                return Err(fields.span().error(\"variants with data fields are not supported\"));\n            }\n\n            Ok(())\n        }))\n        .inner_mapper(MapperBuild::new().enum_map(|_, data| {\n            let matches = data.variants().map(|field| {\n                let field_name = field.ident.unraw();\n                quote!(stringify!(#field_name) => Ok(Self::#field))\n            });\n\n            let names = data.variants().map(|field| {\n                let field_name = field.ident.unraw();\n                quote!(stringify!(#field_name))\n            });\n\n            quote! {\n                type Error = #_error::InvalidOption<'a>;\n\n                fn from_param(param: &'a str) -> Result<Self, Self::Error> {\n                    match param {\n                        #(#matches,)*\n                        _ => Err(#_error::InvalidOption::new(param, &[#(#names),*])),\n                    }\n                }\n            }\n        }))\n        .to_tokens()\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "4fa23c43e63d36e97a430bddbb16fe617cc995bd",
    "func": "use yew::prelude::*;\n\nfn main() {\n    let bad_a = html! {\n        <a>{ \"I don't have a href attribute\" }</a>\n    };\n    let bad_a_2 = html! {\n        <a href=\"#\">{ \"I have a malformed href attribute\" }</a>\n    };\n    let bad_a_3 = html! {\n        <a href=\"javascript:void(0)\">{ \"I have a malformed href attribute\" }</a>\n    };\n    let bad_img = html! {\n        <img src=\"img.jpeg\"/>\n    };\n    let misformed_tagname = html! {\n        <tExTAreA />\n    };\n    compile_error!(\"This macro call exists to deliberately fail the compilation of the test so we can verify output of lints\");\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "46236303f63944a4108e08f825c51cc01232279c",
    "func": "use cell::Cellule;\nuse gloo::timers::callback::Interval;\nuse rand::Rng;\nuse yew::html::Scope;\nuse yew::{classes, html, Component, Context, Html};\n\nmod cell;\n\npub enum Msg {\n    Random,\n    Start,\n    Step,\n    Reset,\n    Stop,\n    ToggleCellule(usize),\n    Tick,\n}\n\npub struct App {\n    active: bool,\n    cellules: Vec<Cellule>,\n    cellules_width: usize,\n    cellules_height: usize,\n    _interval: Interval,\n}\n\nimpl App {\n    pub fn random_mutate(&mut self) {\n        for cellule in self.cellules.iter_mut() {\n            if rand::thread_rng().gen() {\n                cellule.set_alive();\n            } else {\n                cellule.set_dead();\n            }\n        }\n    }\n\n    fn reset(&mut self) {\n        for cellule in self.cellules.iter_mut() {\n            cellule.set_dead();\n        }\n    }\n\n    fn step(&mut self) {\n        let mut to_dead = Vec::new();\n        let mut to_live = Vec::new();\n        for row in 0..self.cellules_height {\n            for col in 0..self.cellules_width {\n                let neighbors = self.neighbors(row as isize, col as isize);\n\n                let current_idx = self.row_col_as_idx(row as isize, col as isize);\n                if self.cellules[current_idx].is_alive() {\n                    if Cellule::alone(&neighbors) || Cellule::overpopulated(&neighbors) {\n                        to_dead.push(current_idx);\n                    }\n                } else if Cellule::can_be_revived(&neighbors) {\n                    to_live.push(current_idx);\n                }\n            }\n        }\n        to_dead\n            .iter()\n            .for_each(|idx| self.cellules[*idx].set_dead());\n        to_live\n            .iter()\n            .for_each(|idx| self.cellules[*idx].set_alive());\n    }\n\n    fn neighbors(&self, row: isize, col: isize) -> [Cellule; 8] {\n        [\n            self.cellules[self.row_col_as_idx(row + 1, col)],\n            self.cellules[self.row_col_as_idx(row + 1, col + 1)],\n            self.cellules[self.row_col_as_idx(row + 1, col - 1)],\n            self.cellules[self.row_col_as_idx(row - 1, col)],\n            self.cellules[self.row_col_as_idx(row - 1, col + 1)],\n            self.cellules[self.row_col_as_idx(row - 1, col - 1)],\n            self.cellules[self.row_col_as_idx(row, col - 1)],\n            self.cellules[self.row_col_as_idx(row, col + 1)],\n        ]\n    }\n\n    fn row_col_as_idx(&self, row: isize, col: isize) -> usize {\n        let row = wrap(row, self.cellules_height as isize);\n        let col = wrap(col, self.cellules_width as isize);\n\n        row * self.cellules_width + col\n    }\n\n    fn view_cellule(&self, idx: usize, cellule: &Cellule, link: &Scope<Self>) -> Html {\n        let cellule_status = {\n            if cellule.is_alive() {\n                \"cellule-live\"\n            } else {\n                \"cellule-dead\"\n            }\n        };\n        html! {\n            <div key={idx} class={classes!(\"game-cellule\", cellule_status)}\n                onclick={link.callback(move |_| Msg::ToggleCellule(idx))}>\n            </div>\n        }\n    }\n}\nimpl Component for App {\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(ctx: &Context<Self>) -> Self {\n        let callback = ctx.link().callback(|_| Msg::Tick);\n        let interval = Interval::new(200, move || callback.emit(()));\n\n        let (cellules_width, cellules_height) = (53, 40);\n\n        Self {\n            active: false,\n            cellules: vec![Cellule::new_dead(); cellules_width * cellules_height],\n            cellules_width,\n            cellules_height,\n            _interval: interval,\n        }\n    }\n\n    fn update(&mut self, _ctx: &Context<Self>, msg: Self::Message) -> bool {\n        match msg {\n            Msg::Random => {\n                self.random_mutate();\n                log::info!(\"Random\");\n                true\n            }\n            Msg::Start => {\n                self.active = true;\n                log::info!(\"Start\");\n                false\n            }\n            Msg::Step => {\n                self.step();\n                true\n            }\n            Msg::Reset => {\n                self.reset();\n                log::info!(\"Reset\");\n                true\n            }\n            Msg::Stop => {\n                self.active = false;\n                log::info!(\"Stop\");\n                false\n            }\n            Msg::ToggleCellule(idx) => {\n                let cellule = self.cellules.get_mut(idx).unwrap();\n                cellule.toggle();\n                true\n            }\n            Msg::Tick => {\n                if self.active {\n                    self.step();\n                    true\n                } else {\n                    false\n                }\n            }\n        }\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        let cell_rows =\n            self.cellules\n                .chunks(self.cellules_width)\n                .enumerate()\n                .map(|(y, cellules)| {\n                    let idx_offset = y * self.cellules_width;\n\n                    let cells = cellules\n                        .iter()\n                        .enumerate()\n                        .map(|(x, cell)| self.view_cellule(idx_offset + x, cell, ctx.link()));\n                    html! {\n                        <div key={y} class=\"game-row\">\n                            { for cells }\n                        </div>\n                    }\n                });\n\n        html! {\n            <div>\n                <section class=\"game-container\">\n                    <header class=\"app-header\">\n                        <img alt=\"The app logo\" src=\"favicon.ico\" class=\"app-logo\"/>\n                        <h1 class=\"app-title\">{ \"Game of Life\" }</h1>\n                    </header>\n                    <section class=\"game-area\">\n                        <div class=\"game-of-life\">\n                            { for cell_rows }\n                        </div>\n                        <div class=\"game-buttons\">\n                            <button class=\"game-button\" onclick={ctx.link().callback(|_| Msg::Random)}>{ \"Random\" }</button>\n                            <button class=\"game-button\" onclick={ctx.link().callback(|_| Msg::Step)}>{ \"Step\" }</button>\n                            <button class=\"game-button\" onclick={ctx.link().callback(|_| Msg::Start)}>{ \"Start\" }</button>\n                            <button class=\"game-button\" onclick={ctx.link().callback(|_| Msg::Stop)}>{ \"Stop\" }</button>\n                            <button class=\"game-button\" onclick={ctx.link().callback(|_| Msg::Reset)}>{ \"Reset\" }</button>\n                        </div>\n                    </section>\n                </section>\n                <footer class=\"app-footer\">\n                    <strong class=\"footer-text\">\n                      { \"Game of Life - a yew experiment \" }\n                    </strong>\n                    <a href=\"https://github.com/yewstack/yew\" target=\"_blank\">{ \"source\" }</a>\n                </footer>\n            </div>\n        }\n    }\n}\n\nfn wrap(coord: isize, range: isize) -> usize {\n    let result = if coord < 0 {\n        coord + range\n    } else if coord >= range {\n        coord - range\n    } else {\n        coord\n    };\n    result as usize\n}\n\nfn main() {\n    wasm_logger::init(wasm_logger::Config::default());\n    log::trace!(\"Initializing yew...\");\n    yew::Renderer::<App>::new().render();\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "5bbaae8dbccb1980a4f1b56a5d5867ed9ee26975",
    "func": "use crate::sync::broadcast;\nuse crate::sync::broadcast::error::RecvError::{Closed, Lagged};\n\nuse loom::future::block_on;\nuse loom::sync::Arc;\nuse loom::thread;\nuse tokio_test::{assert_err, assert_ok};\n\n#[test]\nfn broadcast_send() {\n    loom::model(|| {\n        let (tx1, mut rx) = broadcast::channel(2);\n        let tx1 = Arc::new(tx1);\n        let tx2 = tx1.clone();\n\n        let th1 = thread::spawn(move || {\n            block_on(async {\n                assert_ok!(tx1.send(\"one\"));\n                assert_ok!(tx1.send(\"two\"));\n                assert_ok!(tx1.send(\"three\"));\n            });\n        });\n\n        let th2 = thread::spawn(move || {\n            block_on(async {\n                assert_ok!(tx2.send(\"eins\"));\n                assert_ok!(tx2.send(\"zwei\"));\n                assert_ok!(tx2.send(\"drei\"));\n            });\n        });\n\n        block_on(async {\n            let mut num = 0;\n            loop {\n                match rx.recv().await {\n                    Ok(_) => num += 1,\n                    Err(Closed) => break,\n                    Err(Lagged(n)) => num += n as usize,\n                }\n            }\n            assert_eq!(num, 6);\n        });\n\n        assert_ok!(th1.join());\n        assert_ok!(th2.join());\n    });\n}\n\n// An `Arc` is used as the value in order to detect memory leaks.\n#[test]\nfn broadcast_two() {\n    loom::model(|| {\n        let (tx, mut rx1) = broadcast::channel::<Arc<&'static str>>(16);\n        let mut rx2 = tx.subscribe();\n\n        let th1 = thread::spawn(move || {\n            block_on(async {\n                let v = assert_ok!(rx1.recv().await);\n                assert_eq!(*v, \"hello\");\n\n                let v = assert_ok!(rx1.recv().await);\n                assert_eq!(*v, \"world\");\n\n                match assert_err!(rx1.recv().await) {\n                    Closed => {}\n                    _ => panic!(),\n                }\n            });\n        });\n\n        let th2 = thread::spawn(move || {\n            block_on(async {\n                let v = assert_ok!(rx2.recv().await);\n                assert_eq!(*v, \"hello\");\n\n                let v = assert_ok!(rx2.recv().await);\n                assert_eq!(*v, \"world\");\n\n                match assert_err!(rx2.recv().await) {\n                    Closed => {}\n                    _ => panic!(),\n                }\n            });\n        });\n\n        assert_ok!(tx.send(Arc::new(\"hello\")));\n        assert_ok!(tx.send(Arc::new(\"world\")));\n        drop(tx);\n\n        assert_ok!(th1.join());\n        assert_ok!(th2.join());\n    });\n}\n\n#[test]\nfn broadcast_wrap() {\n    loom::model(|| {\n        let (tx, mut rx1) = broadcast::channel(2);\n        let mut rx2 = tx.subscribe();\n\n        let th1 = thread::spawn(move || {\n            block_on(async {\n                let mut num = 0;\n\n                loop {\n                    match rx1.recv().await {\n                        Ok(_) => num += 1,\n                        Err(Closed) => break,\n                        Err(Lagged(n)) => num += n as usize,\n                    }\n                }\n\n                assert_eq!(num, 3);\n            });\n        });\n\n        let th2 = thread::spawn(move || {\n            block_on(async {\n                let mut num = 0;\n\n                loop {\n                    match rx2.recv().await {\n                        Ok(_) => num += 1,\n                        Err(Closed) => break,\n                        Err(Lagged(n)) => num += n as usize,\n                    }\n                }\n\n                assert_eq!(num, 3);\n            });\n        });\n\n        assert_ok!(tx.send(\"one\"));\n        assert_ok!(tx.send(\"two\"));\n        assert_ok!(tx.send(\"three\"));\n\n        drop(tx);\n\n        assert_ok!(th1.join());\n        assert_ok!(th2.join());\n    });\n}\n\n#[test]\nfn drop_rx() {\n    loom::model(|| {\n        let (tx, mut rx1) = broadcast::channel(16);\n        let rx2 = tx.subscribe();\n\n        let th1 = thread::spawn(move || {\n            block_on(async {\n                let v = assert_ok!(rx1.recv().await);\n                assert_eq!(v, \"one\");\n\n                let v = assert_ok!(rx1.recv().await);\n                assert_eq!(v, \"two\");\n\n                let v = assert_ok!(rx1.recv().await);\n                assert_eq!(v, \"three\");\n\n                match assert_err!(rx1.recv().await) {\n                    Closed => {}\n                    _ => panic!(),\n                }\n            });\n        });\n\n        let th2 = thread::spawn(move || {\n            drop(rx2);\n        });\n\n        assert_ok!(tx.send(\"one\"));\n        assert_ok!(tx.send(\"two\"));\n        assert_ok!(tx.send(\"three\"));\n        drop(tx);\n\n        assert_ok!(th1.join());\n        assert_ok!(th2.join());\n    });\n}\n\n#[test]\nfn drop_multiple_rx_with_overflow() {\n    loom::model(move || {\n        // It is essential to have multiple senders and receivers in this test case.\n        let (tx, mut rx) = broadcast::channel(1);\n        let _rx2 = tx.subscribe();\n\n        let _ = tx.send(());\n        let tx2 = tx.clone();\n        let th1 = thread::spawn(move || {\n            block_on(async {\n                for _ in 0..100 {\n                    let _ = tx2.send(());\n                }\n            });\n        });\n        let _ = tx.send(());\n\n        let th2 = thread::spawn(move || {\n            block_on(async { while let Ok(_) = rx.recv().await {} });\n        });\n\n        assert_ok!(th1.join());\n        assert_ok!(th2.join());\n    });\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "a066a2eea1819aebb9dd78ae4263165ebf428eae",
    "func": "//! SeaORM Entity. Generated by sea-orm-codegen 0.10.0\n\nuse sea_orm::entity::prelude::*;\n\n#[derive(Copy, Clone, Default, Debug, DeriveEntity)]\npub struct Entity;\n\nimpl EntityName for Entity {\n    fn schema_name(&self) -> Option< &str > {\n        Some(\"schema_name\")\n    }\n\n    fn table_name(&self) -> &str {\n        \"collection\"\n    }\n}\n\n#[derive(Clone, Debug, PartialEq, DeriveModel, DeriveActiveModel, Eq)]\npub struct Model {\n    pub id: i32,\n    pub integers: Vec<i32> ,\n    pub integers_opt: Option<Vec<i32> > ,\n}\n\n#[derive(Copy, Clone, Debug, EnumIter, DeriveColumn)]\npub enum Column {\n    Id,\n    Integers,\n    IntegersOpt,\n}\n\n#[derive(Copy, Clone, Debug, EnumIter, DerivePrimaryKey)]\npub enum PrimaryKey {\n    Id,\n}\n\nimpl PrimaryKeyTrait for PrimaryKey {\n    type ValueType = i32;\n    fn auto_increment() -> bool {\n        true\n    }\n}\n\n#[derive(Copy, Clone, Debug, EnumIter)]\npub enum Relation {}\n\nimpl ColumnTrait for Column {\n    type EntityName = Entity;\n    fn def(&self) -> ColumnDef {\n        match self {\n            Self::Id => ColumnType::Integer.def(),\n            Self::Integers => ColumnType::Array(RcOrArc::new(ColumnType::Integer)).def(),\n            Self::IntegersOpt => ColumnType::Array(RcOrArc::new(ColumnType::Integer)).def().null(),\n        }\n    }\n}\n\nimpl RelationTrait for Relation {\n    fn def(&self) -> RelationDef {\n        panic!(\"No RelationDef\")\n    }\n}\n\nimpl ActiveModelBehavior for ActiveModel {}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "1e81e76d4de061f5253abd9d4ce2c0c741922fed",
    "func": "//! # [Ratatui] Chart example\n//!\n//! The latest version of this example is available in the [examples] folder in the repository.\n//!\n//! Please note that the examples are designed to be run against the `main` branch of the Github\n//! repository. This means that you may not be able to compile with the latest release version on\n//! crates.io, or the one that you have installed locally.\n//!\n//! See the [examples readme] for more information on finding examples that match the version of the\n//! library you are using.\n//!\n//! [Ratatui]: https://github.com/ratatui/ratatui\n//! [examples]: https://github.com/ratatui/ratatui/blob/main/examples\n//! [examples readme]: https://github.com/ratatui/ratatui/blob/main/examples/README.md\n\nuse std::time::{Duration, Instant};\n\nuse color_eyre::Result;\nuse ratatui::{\n    crossterm::event::{self, Event, KeyCode},\n    layout::{Constraint, Layout, Rect},\n    style::{Color, Modifier, Style, Stylize},\n    symbols::{self, Marker},\n    text::{Line, Span},\n    widgets::{Axis, Block, Chart, Dataset, GraphType, LegendPosition},\n    DefaultTerminal, Frame,\n};\n\nfn main() -> Result<()> {\n    color_eyre::install()?;\n    let terminal = ratatui::init();\n    let app_result = App::new().run(terminal);\n    ratatui::restore();\n    app_result\n}\n\nstruct App {\n    signal1: SinSignal,\n    data1: Vec<(f64, f64)>,\n    signal2: SinSignal,\n    data2: Vec<(f64, f64)>,\n    window: [f64; 2],\n}\n\n#[derive(Clone)]\nstruct SinSignal {\n    x: f64,\n    interval: f64,\n    period: f64,\n    scale: f64,\n}\n\nimpl SinSignal {\n    const fn new(interval: f64, period: f64, scale: f64) -> Self {\n        Self {\n            x: 0.0,\n            interval,\n            period,\n            scale,\n        }\n    }\n}\n\nimpl Iterator for SinSignal {\n    type Item = (f64, f64);\n    fn next(&mut self) -> Option<Self::Item> {\n        let point = (self.x, (self.x * 1.0 / self.period).sin() * self.scale);\n        self.x += self.interval;\n        Some(point)\n    }\n}\n\nimpl App {\n    fn new() -> Self {\n        let mut signal1 = SinSignal::new(0.2, 3.0, 18.0);\n        let mut signal2 = SinSignal::new(0.1, 2.0, 10.0);\n        let data1 = signal1.by_ref().take(200).collect::<Vec<(f64, f64)>>();\n        let data2 = signal2.by_ref().take(200).collect::<Vec<(f64, f64)>>();\n        Self {\n            signal1,\n            data1,\n            signal2,\n            data2,\n            window: [0.0, 20.0],\n        }\n    }\n\n    fn run(mut self, mut terminal: DefaultTerminal) -> Result<()> {\n        let tick_rate = Duration::from_millis(250);\n        let mut last_tick = Instant::now();\n        loop {\n            terminal.draw(|frame| self.draw(frame))?;\n\n            let timeout = tick_rate.saturating_sub(last_tick.elapsed());\n            if event::poll(timeout)? {\n                if let Event::Key(key) = event::read()? {\n                    if key.code == KeyCode::Char('q') {\n                        return Ok(());\n                    }\n                }\n            }\n            if last_tick.elapsed() >= tick_rate {\n                self.on_tick();\n                last_tick = Instant::now();\n            }\n        }\n    }\n\n    fn on_tick(&mut self) {\n        self.data1.drain(0..5);\n        self.data1.extend(self.signal1.by_ref().take(5));\n\n        self.data2.drain(0..10);\n        self.data2.extend(self.signal2.by_ref().take(10));\n\n        self.window[0] += 1.0;\n        self.window[1] += 1.0;\n    }\n\n    fn draw(&self, frame: &mut Frame) {\n        let [top, bottom] = Layout::vertical([Constraint::Fill(1); 2]).areas(frame.area());\n        let [animated_chart, bar_chart] =\n            Layout::horizontal([Constraint::Fill(1), Constraint::Length(29)]).areas(top);\n        let [line_chart, scatter] = Layout::horizontal([Constraint::Fill(1); 2]).areas(bottom);\n\n        self.render_animated_chart(frame, animated_chart);\n        render_barchart(frame, bar_chart);\n        render_line_chart(frame, line_chart);\n        render_scatter(frame, scatter);\n    }\n\n    fn render_animated_chart(&self, frame: &mut Frame, area: Rect) {\n        let x_labels = vec![\n            Span::styled(\n                format!(\"{}\", self.window[0]),\n                Style::default().add_modifier(Modifier::BOLD),\n            ),\n            Span::raw(format!(\"{}\", (self.window[0] + self.window[1]) / 2.0)),\n            Span::styled(\n                format!(\"{}\", self.window[1]),\n                Style::default().add_modifier(Modifier::BOLD),\n            ),\n        ];\n        let datasets = vec![\n            Dataset::default()\n                .name(\"data2\")\n                .marker(symbols::Marker::Dot)\n                .style(Style::default().fg(Color::Cyan))\n                .data(&self.data1),\n            Dataset::default()\n                .name(\"data3\")\n                .marker(symbols::Marker::Braille)\n                .style(Style::default().fg(Color::Yellow))\n                .data(&self.data2),\n        ];\n\n        let chart = Chart::new(datasets)\n            .block(Block::bordered())\n            .x_axis(\n                Axis::default()\n                    .title(\"X Axis\")\n                    .style(Style::default().fg(Color::Gray))\n                    .labels(x_labels)\n                    .bounds(self.window),\n            )\n            .y_axis(\n                Axis::default()\n                    .title(\"Y Axis\")\n                    .style(Style::default().fg(Color::Gray))\n                    .labels([\"-20\".bold(), \"0\".into(), \"20\".bold()])\n                    .bounds([-20.0, 20.0]),\n            );\n\n        frame.render_widget(chart, area);\n    }\n}\n\nfn render_barchart(frame: &mut Frame, bar_chart: Rect) {\n    let dataset = Dataset::default()\n        .marker(symbols::Marker::HalfBlock)\n        .style(Style::new().fg(Color::Blue))\n        .graph_type(GraphType::Bar)\n        // a bell curve\n        .data(&[\n            (0., 0.4),\n            (10., 2.9),\n            (20., 13.5),\n            (30., 41.1),\n            (40., 80.1),\n            (50., 100.0),\n            (60., 80.1),\n            (70., 41.1),\n            (80., 13.5),\n            (90., 2.9),\n            (100., 0.4),\n        ]);\n\n    let chart = Chart::new(vec![dataset])\n        .block(Block::bordered().title_top(Line::from(\"Bar chart\").cyan().bold().centered()))\n        .x_axis(\n            Axis::default()\n                .style(Style::default().gray())\n                .bounds([0.0, 100.0])\n                .labels([\"0\".bold(), \"50\".into(), \"100.0\".bold()]),\n        )\n        .y_axis(\n            Axis::default()\n                .style(Style::default().gray())\n                .bounds([0.0, 100.0])\n                .labels([\"0\".bold(), \"50\".into(), \"100.0\".bold()]),\n        )\n        .hidden_legend_constraints((Constraint::Ratio(1, 2), Constraint::Ratio(1, 2)));\n\n    frame.render_widget(chart, bar_chart);\n}\n\nfn render_line_chart(frame: &mut Frame, area: Rect) {\n    let datasets = vec![Dataset::default()\n        .name(\"Line from only 2 points\".italic())\n        .marker(symbols::Marker::Braille)\n        .style(Style::default().fg(Color::Yellow))\n        .graph_type(GraphType::Line)\n        .data(&[(1., 1.), (4., 4.)])];\n\n    let chart = Chart::new(datasets)\n        .block(Block::bordered().title(Line::from(\"Line chart\").cyan().bold().centered()))\n        .x_axis(\n            Axis::default()\n                .title(\"X Axis\")\n                .style(Style::default().gray())\n                .bounds([0.0, 5.0])\n                .labels([\"0\".bold(), \"2.5\".into(), \"5.0\".bold()]),\n        )\n        .y_axis(\n            Axis::default()\n                .title(\"Y Axis\")\n                .style(Style::default().gray())\n                .bounds([0.0, 5.0])\n                .labels([\"0\".bold(), \"2.5\".into(), \"5.0\".bold()]),\n        )\n        .legend_position(Some(LegendPosition::TopLeft))\n        .hidden_legend_constraints((Constraint::Ratio(1, 2), Constraint::Ratio(1, 2)));\n\n    frame.render_widget(chart, area);\n}\n\nfn render_scatter(frame: &mut Frame, area: Rect) {\n    let datasets = vec![\n        Dataset::default()\n            .name(\"Heavy\")\n            .marker(Marker::Dot)\n            .graph_type(GraphType::Scatter)\n            .style(Style::new().yellow())\n            .data(&HEAVY_PAYLOAD_DATA),\n        Dataset::default()\n            .name(\"Medium\".underlined())\n            .marker(Marker::Braille)\n            .graph_type(GraphType::Scatter)\n            .style(Style::new().magenta())\n            .data(&MEDIUM_PAYLOAD_DATA),\n        Dataset::default()\n            .name(\"Small\")\n            .marker(Marker::Dot)\n            .graph_type(GraphType::Scatter)\n            .style(Style::new().cyan())\n            .data(&SMALL_PAYLOAD_DATA),\n    ];\n\n    let chart = Chart::new(datasets)\n        .block(Block::bordered().title(Line::from(\"Scatter chart\").cyan().bold().centered()))\n        .x_axis(\n            Axis::default()\n                .title(\"Year\")\n                .bounds([1960., 2020.])\n                .style(Style::default().fg(Color::Gray))\n                .labels([\"1960\", \"1990\", \"2020\"]),\n        )\n        .y_axis(\n            Axis::default()\n                .title(\"Cost\")\n                .bounds([0., 75000.])\n                .style(Style::default().fg(Color::Gray))\n                .labels([\"0\", \"37 500\", \"75 000\"]),\n        )\n        .hidden_legend_constraints((Constraint::Ratio(1, 2), Constraint::Ratio(1, 2)));\n\n    frame.render_widget(chart, area);\n}\n\n// Data from https://ourworldindata.org/space-exploration-satellites\nconst HEAVY_PAYLOAD_DATA: [(f64, f64); 9] = [\n    (1965., 8200.),\n    (1967., 5400.),\n    (1981., 65400.),\n    (1989., 30800.),\n    (1997., 10200.),\n    (2004., 11600.),\n    (2014., 4500.),\n    (2016., 7900.),\n    (2018., 1500.),\n];\n\nconst MEDIUM_PAYLOAD_DATA: [(f64, f64); 29] = [\n    (1963., 29500.),\n    (1964., 30600.),\n    (1965., 177_900.),\n    (1965., 21000.),\n    (1966., 17900.),\n    (1966., 8400.),\n    (1975., 17500.),\n    (1982., 8300.),\n    (1985., 5100.),\n    (1988., 18300.),\n    (1990., 38800.),\n    (1990., 9900.),\n    (1991., 18700.),\n    (1992., 9100.),\n    (1994., 10500.),\n    (1994., 8500.),\n    (1994., 8700.),\n    (1997., 6200.),\n    (1999., 18000.),\n    (1999., 7600.),\n    (1999., 8900.),\n    (1999., 9600.),\n    (2000., 16000.),\n    (2001., 10000.),\n    (2002., 10400.),\n    (2002., 8100.),\n    (2010., 2600.),\n    (2013., 13600.),\n    (2017., 8000.),\n];\n\nconst SMALL_PAYLOAD_DATA: [(f64, f64); 23] = [\n    (1961., 118_500.),\n    (1962., 14900.),\n    (1975., 21400.),\n    (1980., 32800.),\n    (1988., 31100.),\n    (1990., 41100.),\n    (1993., 23600.),\n    (1994., 20600.),\n    (1994., 34600.),\n    (1996., 50600.),\n    (1997., 19200.),\n    (1997., 45800.),\n    (1998., 19100.),\n    (2000., 73100.),\n    (2003., 11200.),\n    (2008., 12600.),\n    (2010., 30500.),\n    (2012., 20000.),\n    (2013., 10600.),\n    (2013., 34500.),\n    (2015., 10600.),\n    (2018., 23100.),\n    (2019., 17300.),\n];\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "2736ccd70d423bc9ce5908c68176040ed7eeaffa",
    "func": "use crate::{expr::*, query::*, types::*};\nuse inherent::inherent;\n\npub trait OverStatement {\n    #[doc(hidden)]\n    // Implementation for the trait.\n    fn add_partition_by(&mut self, partition: SimpleExpr) -> &mut Self;\n\n    /// Partition by column.\n    fn partition_by<T>(&mut self, col: T) -> &mut Self\n    where\n        T: IntoColumnRef,\n    {\n        self.add_partition_by(SimpleExpr::Column(col.into_column_ref()))\n    }\n\n    /// Partition by custom string.\n    fn partition_by_customs<I, T>(&mut self, cols: I) -> &mut Self\n    where\n        T: ToString,\n        I: IntoIterator<Item = T>,\n    {\n        cols.into_iter().for_each(|c| {\n            self.add_partition_by(SimpleExpr::Custom(c.to_string()));\n        });\n        self\n    }\n\n    /// Partition by vector of columns.\n    fn partition_by_columns<I, T>(&mut self, cols: I) -> &mut Self\n    where\n        T: IntoColumnRef,\n        I: IntoIterator<Item = T>,\n    {\n        cols.into_iter().for_each(|c| {\n            self.add_partition_by(SimpleExpr::Column(c.into_column_ref()));\n        });\n        self\n    }\n}\n\n/// frame_start or frame_end clause\n#[derive(Debug, Clone, PartialEq)]\npub enum Frame {\n    UnboundedPreceding,\n    Preceding(u32),\n    CurrentRow,\n    Following(u32),\n    UnboundedFollowing,\n}\n\n/// Frame type\n#[derive(Debug, Clone, PartialEq)]\npub enum FrameType {\n    Range,\n    Rows,\n}\n\n/// Frame clause\n#[derive(Debug, Clone, PartialEq)]\npub struct FrameClause {\n    pub(crate) r#type: FrameType,\n    pub(crate) start: Frame,\n    pub(crate) end: Option<Frame>,\n}\n\n/// Window expression\n///\n/// # References:\n///\n/// 1. <https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html>\n/// 2. <https://www.sqlite.org/windowfunctions.html>\n/// 3. <https://www.postgresql.org/docs/current/tutorial-window.html>\n#[derive(Default, Debug, Clone, PartialEq)]\npub struct WindowStatement {\n    pub(crate) partition_by: Vec<SimpleExpr>,\n    pub(crate) order_by: Vec<OrderExpr>,\n    pub(crate) frame: Option<FrameClause>,\n}\n\nimpl WindowStatement {\n    /// Construct a new [`WindowStatement`]\n    pub fn new() -> Self {\n        Self::default()\n    }\n\n    pub fn take(&mut self) -> Self {\n        Self {\n            partition_by: std::mem::take(&mut self.partition_by),\n            order_by: std::mem::take(&mut self.order_by),\n            frame: self.frame.take(),\n        }\n    }\n\n    /// Construct a new [`WindowStatement`] with PARTITION BY column\n    pub fn partition_by<T>(col: T) -> Self\n    where\n        T: IntoColumnRef,\n    {\n        let mut window = Self::new();\n        window.add_partition_by(SimpleExpr::Column(col.into_column_ref()));\n        window\n    }\n\n    /// Construct a new [`WindowStatement`] with PARTITION BY custom\n    pub fn partition_by_custom<T>(col: T) -> Self\n    where\n        T: ToString,\n    {\n        let mut window = Self::new();\n        window.add_partition_by(SimpleExpr::Custom(col.to_string()));\n        window\n    }\n\n    /// frame clause for frame_start\n    /// # Examples:\n    ///\n    /// ```\n    /// use sea_query::{tests_cfg::*, *};\n    ///\n    /// let query = Query::select()\n    ///     .from(Char::Table)\n    ///     .expr_window_as(\n    ///         Expr::col(Char::Character),\n    ///         WindowStatement::partition_by(Char::FontSize)\n    ///             .frame_start(FrameType::Rows, Frame::UnboundedPreceding)\n    ///             .take(),\n    ///         Alias::new(\"C\"))\n    ///     .to_owned();\n    ///\n    /// assert_eq!(\n    ///     query.to_string(MysqlQueryBuilder),\n    ///     r#\"SELECT `character` OVER ( PARTITION BY `font_size` ROWS UNBOUNDED PRECEDING ) AS `C` FROM `character`\"#\n    /// );\n    /// assert_eq!(\n    ///     query.to_string(PostgresQueryBuilder),\n    ///     r#\"SELECT \"character\" OVER ( PARTITION BY \"font_size\" ROWS UNBOUNDED PRECEDING ) AS \"C\" FROM \"character\"\"#\n    /// );\n    /// assert_eq!(\n    ///     query.to_string(SqliteQueryBuilder),\n    ///     r#\"SELECT \"character\" OVER ( PARTITION BY \"font_size\" ROWS UNBOUNDED PRECEDING ) AS \"C\" FROM \"character\"\"#\n    /// );\n    /// ```\n    pub fn frame_start(&mut self, r#type: FrameType, start: Frame) -> &mut Self {\n        self.frame(r#type, start, None)\n    }\n\n    /// frame clause for BETWEEN frame_start AND frame_end\n    ///\n    /// # Examples:\n    ///\n    /// ```\n    /// use sea_query::{tests_cfg::*, *};\n    ///\n    /// let query = Query::select()\n    ///     .from(Char::Table)\n    ///     .expr_window_as(\n    ///         Expr::col(Char::Character),\n    ///         WindowStatement::partition_by(Char::FontSize)\n    ///             .frame_between(FrameType::Rows, Frame::UnboundedPreceding, Frame::UnboundedFollowing)\n    ///             .take(),\n    ///         Alias::new(\"C\"))\n    ///     .to_owned();\n    ///\n    /// assert_eq!(\n    ///     query.to_string(MysqlQueryBuilder),\n    ///     r#\"SELECT `character` OVER ( PARTITION BY `font_size` ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING ) AS `C` FROM `character`\"#\n    /// );\n    /// assert_eq!(\n    ///     query.to_string(PostgresQueryBuilder),\n    ///     r#\"SELECT \"character\" OVER ( PARTITION BY \"font_size\" ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING ) AS \"C\" FROM \"character\"\"#\n    /// );\n    /// assert_eq!(\n    ///     query.to_string(SqliteQueryBuilder),\n    ///     r#\"SELECT \"character\" OVER ( PARTITION BY \"font_size\" ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING ) AS \"C\" FROM \"character\"\"#\n    /// );\n    /// ```\n    pub fn frame_between(&mut self, r#type: FrameType, start: Frame, end: Frame) -> &mut Self {\n        self.frame(r#type, start, Some(end))\n    }\n\n    /// frame clause\n    pub fn frame(&mut self, r#type: FrameType, start: Frame, end: Option<Frame>) -> &mut Self {\n        let frame_clause = FrameClause { r#type, start, end };\n        self.frame = Some(frame_clause);\n        self\n    }\n}\n\nimpl OverStatement for WindowStatement {\n    fn add_partition_by(&mut self, partition: SimpleExpr) -> &mut Self {\n        self.partition_by.push(partition);\n        self\n    }\n}\n\n#[inherent]\nimpl OrderedStatement for WindowStatement {\n    pub fn add_order_by(&mut self, order: OrderExpr) -> &mut Self {\n        self.order_by.push(order);\n        self\n    }\n\n    pub fn clear_order_by(&mut self) -> &mut Self {\n        self.order_by = Vec::new();\n        self\n    }\n\n    pub fn order_by<T>(&mut self, col: T, order: Order) -> &mut Self\n    where\n        T: IntoColumnRef;\n\n    pub fn order_by_expr(&mut self, expr: SimpleExpr, order: Order) -> &mut Self;\n    pub fn order_by_customs<I, T>(&mut self, cols: I) -> &mut Self\n    where\n        T: ToString,\n        I: IntoIterator<Item = (T, Order)>;\n    pub fn order_by_columns<I, T>(&mut self, cols: I) -> &mut Self\n    where\n        T: IntoColumnRef,\n        I: IntoIterator<Item = (T, Order)>;\n    pub fn order_by_with_nulls<T>(\n        &mut self,\n        col: T,\n        order: Order,\n        nulls: NullOrdering,\n    ) -> &mut Self\n    where\n        T: IntoColumnRef;\n    pub fn order_by_expr_with_nulls(\n        &mut self,\n        expr: SimpleExpr,\n        order: Order,\n        nulls: NullOrdering,\n    ) -> &mut Self;\n    pub fn order_by_customs_with_nulls<I, T>(&mut self, cols: I) -> &mut Self\n    where\n        T: ToString,\n        I: IntoIterator<Item = (T, Order, NullOrdering)>;\n    pub fn order_by_columns_with_nulls<I, T>(&mut self, cols: I) -> &mut Self\n    where\n        T: IntoColumnRef,\n        I: IntoIterator<Item = (T, Order, NullOrdering)>;\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "3bfa4771a01b8880b888dc159cc89426c8ecd873",
    "func": "#![warn(rust_2018_idioms)]\n#![cfg(all(feature = \"full\", not(target_os = \"wasi\")))] // WASI does not support all fs operations\n\nuse std::io::Write;\nuse tempfile::NamedTempFile;\nuse tokio::fs::OpenOptions;\nuse tokio::io::AsyncReadExt;\n\nconst HELLO: &[u8] = b\"hello world...\";\n\n#[tokio::test]\nasync fn open_with_open_options_and_read() {\n    let mut tempfile = NamedTempFile::new().unwrap();\n    tempfile.write_all(HELLO).unwrap();\n\n    let mut file = OpenOptions::new().read(true).open(tempfile).await.unwrap();\n\n    let mut buf = [0; 1024];\n    let n = file.read(&mut buf).await.unwrap();\n\n    assert_eq!(n, HELLO.len());\n    assert_eq!(&buf[..n], HELLO);\n}\n\n#[tokio::test]\nasync fn open_options_write() {\n    // TESTING HACK: use Debug output to check the stored data\n    assert!(format!(\"{:?}\", OpenOptions::new().write(true)).contains(\"write: true\"));\n}\n\n#[tokio::test]\nasync fn open_options_append() {\n    // TESTING HACK: use Debug output to check the stored data\n    assert!(format!(\"{:?}\", OpenOptions::new().append(true)).contains(\"append: true\"));\n}\n\n#[tokio::test]\nasync fn open_options_truncate() {\n    // TESTING HACK: use Debug output to check the stored data\n    assert!(format!(\"{:?}\", OpenOptions::new().truncate(true)).contains(\"truncate: true\"));\n}\n\n#[tokio::test]\nasync fn open_options_create() {\n    // TESTING HACK: use Debug output to check the stored data\n    assert!(format!(\"{:?}\", OpenOptions::new().create(true)).contains(\"create: true\"));\n}\n\n#[tokio::test]\nasync fn open_options_create_new() {\n    // TESTING HACK: use Debug output to check the stored data\n    assert!(format!(\"{:?}\", OpenOptions::new().create_new(true)).contains(\"create_new: true\"));\n}\n\n#[tokio::test]\n#[cfg(unix)]\nasync fn open_options_mode() {\n    let mode = format!(\"{:?}\", OpenOptions::new().mode(0o644));\n    // TESTING HACK: use Debug output to check the stored data\n    assert!(\n        mode.contains(\"mode: 420 \") || mode.contains(\"mode: 0o000644 \"),\n        \"mode is: {}\",\n        mode\n    );\n}\n\n#[tokio::test]\n#[cfg(target_os = \"linux\")]\nasync fn open_options_custom_flags_linux() {\n    // TESTING HACK: use Debug output to check the stored data\n    assert!(\n        format!(\"{:?}\", OpenOptions::new().custom_flags(libc::O_TRUNC))\n            .contains(\"custom_flags: 512,\")\n    );\n}\n\n#[tokio::test]\n#[cfg(any(target_os = \"freebsd\", target_os = \"macos\"))]\nasync fn open_options_custom_flags_bsd_family() {\n    // TESTING HACK: use Debug output to check the stored data\n    assert!(\n        format!(\"{:?}\", OpenOptions::new().custom_flags(libc::O_NOFOLLOW))\n            .contains(\"custom_flags: 256,\")\n    );\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "1398d750135f06cd690478d520e12dcf2a6d4d57",
    "func": "/// [Source data](http://www.gnuplotting.org/plotting-the-world-revisited)\npub const WORLD_HIGH_RESOLUTION: [(f64, f64); 5125] = [\n    (-163.7128, -78.5956),\n    (-163.1058, -78.2233),\n    (-161.2451, -78.3801),\n    (-160.2462, -78.6936),\n    (-159.4824, -79.0463),\n    (-159.2081, -79.4970),\n    (-161.1276, -79.6342),\n    (-162.4398, -79.2814),\n    (-163.0274, -78.9287),\n    (-163.0666, -78.8699),\n    (-163.7128, -78.5956),\n    (-6.1978, 53.8675),\n    (-6.0329, 53.1531),\n    (-6.7888, 52.2601),\n    (-8.5616, 51.6693),\n    (-9.9770, 51.8204),\n    (-9.1662, 52.8646),\n    (-9.6885, 53.8813),\n    (-8.3279, 54.6645),\n    (-7.5721, 55.1316),\n    (-6.7338, 55.1728),\n    (-5.6619, 54.5546),\n    (-6.1978, 53.8675),\n    (141.0002, -2.6001),\n    (142.7352, -3.2891),\n    (144.5839, -3.8614),\n    (145.2731, -4.3737),\n    (145.8297, -4.8764),\n    (145.9819, -5.4656),\n    (147.6480, -6.0836),\n    (147.8911, -6.6140),\n    (146.9709, -6.7216),\n    (147.1918, -7.3880),\n    (148.0846, -8.0441),\n    (148.7341, -9.1046),\n    (149.3068, -9.0714),\n    (149.2666, -9.5144),\n    (150.0387, -9.6843),\n    (149.7387, -9.8729),\n    (150.8016, -10.2936),\n    (150.6905, -10.5827),\n    (150.0283, -10.6524),\n    (149.7823, -10.3932),\n    (148.9231, -10.2809),\n    (147.9130, -10.1304),\n    (147.1354, -9.4924),\n    (146.5678, -8.9425),\n    (146.0484, -8.0674),\n    (144.7441, -7.6301),\n    (143.8970, -7.9153),\n    (143.2863, -8.2454),\n    (143.4139, -8.9830),\n    (142.6284, -9.3268),\n    (142.0682, -9.1595),\n    (141.0338, -9.1178),\n    (140.1434, -8.2971),\n    (139.1277, -8.0960),\n    (138.8814, -8.3809),\n    (137.6144, -8.4116),\n    (138.0390, -7.5978),\n    (138.6686, -7.3202),\n    (138.4079, -6.2328),\n    (137.9278, -5.3933),\n    (135.9892, -4.5465),\n    (135.1645, -4.4629),\n    (133.6628, -3.5388),\n    (133.3677, -4.0248),\n    (132.9839, -4.1129),\n    (132.7569, -3.7462),\n    (132.7537, -3.3117),\n    (131.9898, -2.8205),\n    (133.0668, -2.4604),\n    (133.7800, -2.4798),\n    (133.6962, -2.2145),\n    (132.2323, -2.2125),\n    (131.8362, -1.6171),\n    (130.9428, -1.4325),\n    (130.5195, -0.9377),\n    (131.8675, -0.6954),\n    (132.3801, -0.3695),\n    (133.9855, -0.7802),\n    (134.1433, -1.1518),\n    (134.4226, -2.7691),\n    (135.4576, -3.3677),\n    (136.2933, -2.3070),\n    (137.4407, -1.7035),\n    (138.3297, -1.7026),\n    (139.1849, -2.0512),\n    (139.9266, -2.4089),\n    (141.0002, -2.6001),\n    (114.2040, 4.5258),\n    (114.5999, 4.9000),\n    (115.4507, 5.4477),\n    (116.2207, 6.1431),\n    (116.7251, 6.9247),\n    (117.1296, 6.9280),\n    (117.6433, 6.4221),\n    (117.6890, 5.9874),\n    (118.3476, 5.7086),\n    (119.1819, 5.4078),\n    (119.1106, 5.0161),\n    (118.4397, 4.9665),\n    (118.6183, 4.4782),\n    (117.8820, 4.1375),\n    (117.3132, 3.2344),\n    (118.0483, 2.2876),\n    (117.8756, 1.8276),\n    (118.9967, 0.9022),\n    (117.8118, 0.7842),\n    (117.4783, 0.1024),\n    (117.5216, -0.8037),\n    (116.5600, -1.4876),\n    (116.5337, -2.4835),\n    (116.1480, -4.0127),\n    (116.0008, -3.6570),\n    (114.8648, -4.1069),\n    (114.4686, -3.4957),\n    (113.7556, -3.4391),\n    (113.2569, -3.1187),\n    (112.0681, -3.4783),\n    (111.7032, -2.9944),\n    (111.0482, -3.0494),\n    (110.2238, -2.9340),\n    (110.0709, -1.5928),\n    (109.5719, -1.3149),\n    (109.0918, -0.4595),\n    (108.9526, 0.4153),\n    (109.0691, 1.3419),\n    (109.6632, 2.0064),\n    (110.3961, 1.6637),\n    (111.1688, 1.8506),\n    (111.3700, 2.6973),\n    (111.7969, 2.8858),\n    (112.9956, 3.1023),\n    (113.7129, 3.8935),\n    (114.2040, 4.5258),\n    (-93.6127, 74.9799),\n    (-94.1569, 74.5923),\n    (-95.6086, 74.6668),\n    (-96.8209, 74.9276),\n    (-96.2885, 75.3778),\n    (-94.8508, 75.6472),\n    (-93.9777, 75.2964),\n    (-93.6127, 74.9799),\n    (-93.8400, 77.5199),\n    (-94.2956, 77.4913),\n    (-96.1696, 77.5551),\n    (-96.4363, 77.8346),\n    (-94.4225, 77.8200),\n    (-93.7206, 77.6343),\n    (-93.8400, 77.5199),\n    (-96.7543, 78.7658),\n    (-95.5592, 78.4183),\n    (-95.8302, 78.0569),\n    (-97.3098, 77.8505),\n    (-98.1242, 78.0828),\n    (-98.5528, 78.4581),\n    (-98.6319, 78.8719),\n    (-97.3372, 78.8319),\n    (-96.7543, 78.7658),\n    (-88.1503, 74.3923),\n    (-89.7647, 74.5155),\n    (-92.4224, 74.8377),\n    (-92.7682, 75.3868),\n    (-92.8899, 75.8826),\n    (-93.8938, 76.3192),\n    (-95.9624, 76.4413),\n    (-97.1213, 76.7510),\n    (-96.7451, 77.1613),\n    (-94.6840, 77.0978),\n    (-93.5739, 76.7762),\n    (-91.6050, 76.7785),\n    (-90.7418, 76.4495),\n    (-90.9696, 76.0740),\n    (-89.8222, 75.8477),\n    (-89.1870, 75.6101),\n    (-87.8382, 75.5661),\n    (-86.3791, 75.4824),\n    (-84.7896, 75.6992),\n    (-82.7534, 75.7843),\n    (-81.1285, 75.7139),\n    (-80.0575, 75.3368),\n    (-79.8339, 74.9231),\n    (-80.4577, 74.6573),\n    (-81.9488, 74.4424),\n    (-83.2288, 74.5640),\n    (-86.0974, 74.4100),\n    (-88.1503, 74.3923),\n    (-111.2644, 78.1529),\n    (-109.8544, 77.9963),\n    (-110.1869, 77.6970),\n    (-112.0511, 77.4092),\n    (-113.5342, 77.7322),\n    (-112.7245, 78.0510),\n    (-111.2644, 78.1529),\n    (-110.9636, 78.8044),\n    (-109.6631, 78.6019),\n    (-110.8813, 78.4069),\n    (-112.5420, 78.4079),\n    (-112.5258, 78.5505),\n    (-111.5000, 78.8499),\n    (-110.9636, 78.8044),\n    (-66.2824, 18.5147),\n    (-65.7713, 18.4266),\n    (-65.5910, 18.2280),\n    (-65.8471, 17.9759),\n    (-66.5999, 17.9818),\n    (-67.1841, 17.9465),\n    (-67.2424, 18.3744),\n    (-67.1006, 18.5206),\n    (-66.2824, 18.5147),\n    (-77.5696, 18.4905),\n    (-76.8966, 18.4008),\n    (-76.3653, 18.1607),\n    (-76.1996, 17.8868),\n    (-76.9025, 17.8682),\n    (-77.2063, 17.7011),\n    (-77.7660, 17.8615),\n    (-78.3377, 18.2259),\n    (-78.2177, 18.4545),\n    (-77.7973, 18.5242),\n    (-77.5696, 18.4905),\n    (-82.2681, 23.1886),\n    (-81.4044, 23.1172),\n    (-80.6187, 23.1060),\n    (-79.6795, 22.7653),\n    (-79.2814, 22.3992),\n    (-78.3474, 22.5121),\n    (-77.9932, 22.2771),\n    (-77.1464, 21.6578),\n    (-76.5238, 21.2068),\n    (-76.1946, 21.2205),\n    (-75.5982, 21.0166),\n    (-75.6710, 20.7350),\n    (-74.9338, 20.6939),\n    (-74.1780, 20.2846),\n    (-74.2966, 20.0503),\n    (-74.9615, 19.9234),\n    (-75.6346, 19.8737),\n    (-76.3236, 19.9528),\n    (-77.7554, 19.8554),\n    (-77.0851, 20.4133),\n    (-77.4926, 20.6731),\n    (-78.1372, 20.7399),\n    (-78.4828, 21.0286),\n    (-78.7198, 21.5981),\n    (-79.2849, 21.5591),\n    (-80.2174, 21.8273),\n    (-80.5175, 22.0370),\n    (-81.8209, 22.1920),\n    (-82.1699, 22.3871),\n    (-81.7950, 22.6369),\n    (-82.7758, 22.6881),\n    (-83.4944, 22.1685),\n    (-83.9088, 22.1545),\n    (-84.0521, 21.9105),\n    (-84.5470, 21.8012),\n    (-84.9749, 21.8960),\n    (-84.4470, 22.2049),\n    (-84.2303, 22.5657),\n    (-83.7782, 22.7881),\n    (-83.2675, 22.9830),\n    (-82.5104, 23.0787),\n    (-82.2681, 23.1886),\n    (-55.6002, 51.3170),\n    (-56.1340, 50.6870),\n    (-56.7958, 49.8123),\n    (-56.1431, 50.1501),\n    (-55.4714, 49.9358),\n    (-55.8224, 49.5871),\n    (-54.9351, 49.3130),\n    (-54.4737, 49.5566),\n    (-53.4765, 49.2491),\n    (-53.7860, 48.5167),\n    (-53.0861, 48.6878),\n    (-52.9586, 48.1571),\n    (-52.6480, 47.5355),\n    (-53.0691, 46.6554),\n    (-53.5214, 46.6182),\n    (-54.1789, 46.8070),\n    (-53.9618, 47.6252),\n    (-54.2404, 47.7522),\n    (-55.4007, 46.8849),\n    (-55.9974, 46.9197),\n    (-55.2912, 47.3895),\n    (-56.2507, 47.6325),\n    (-57.3252, 47.5728),\n    (-59.2660, 47.6033),\n    (-59.4194, 47.8994),\n    (-58.7965, 48.2515),\n    (-59.2316, 48.5231),\n    (-58.3918, 49.1255),\n    (-57.3586, 50.7182),\n    (-56.7386, 51.2874),\n    (-55.8709, 51.6320),\n    (-55.4069, 51.5882),\n    (-55.6002, 51.3170),\n    (-83.8826, 65.1096),\n    (-82.7875, 64.7666),\n    (-81.6420, 64.4551),\n    (-81.5534, 63.9796),\n    (-80.8173, 64.0574),\n    (-80.1034, 63.7259),\n    (-80.9910, 63.4112),\n    (-82.5471, 63.6517),\n    (-83.1087, 64.1018),\n    (-84.1004, 63.5697),\n    (-85.5234, 63.0523),\n    (-85.8667, 63.6372),\n    (-87.2219, 63.5412),\n    (-86.3527, 64.0358),\n    (-86.2248, 64.8229),\n    (-85.8838, 65.7387),\n    (-85.1613, 65.6572),\n    (-84.9757, 65.2175),\n    (-84.4640, 65.3717),\n    (-83.8826, 65.1096),\n    (-78.7706, 72.3521),\n    (-77.8246, 72.7496),\n    (-75.6058, 72.2436),\n    (-74.2286, 71.7671),\n    (-74.0991, 71.3308),\n    (-72.2422, 71.5569),\n    (-71.2000, 70.9200),\n    (-68.7860, 70.5250),\n    (-67.9149, 70.1219),\n    (-66.9690, 69.1860),\n    (-68.8051, 68.7201),\n    (-66.4498, 68.0671),\n    (-64.8623, 67.8475),\n    (-63.4249, 66.9284),\n    (-61.8519, 66.8621),\n    (-62.1631, 66.1602),\n    (-63.9184, 64.9986),\n    (-65.1488, 65.4260),\n    (-66.7212, 66.3880),\n    (-68.0150, 66.2627),\n    (-68.1412, 65.6897),\n    (-67.0896, 65.1084),\n    (-65.7320, 64.6484),\n    (-65.3201, 64.3827),\n    (-64.6694, 63.3929),\n    (-65.0138, 62.6741),\n    (-66.2750, 62.9450),\n    (-68.7831, 63.7456),\n    (-67.3696, 62.8839),\n    (-66.3282, 62.2800),\n    (-66.1655, 61.9308),\n    (-68.8773, 62.3301),\n    (-71.0234, 62.9107),\n    (-72.2353, 63.3978),\n    (-71.8862, 63.6799),\n    (-73.3783, 64.1939),\n    (-74.8344, 64.6791),\n    (-74.8185, 64.3890),\n    (-77.7099, 64.2295),\n    (-78.5559, 64.5729),\n    (-77.8972, 65.3091),\n    (-76.0182, 65.3269),\n    (-73.9597, 65.4547),\n    (-74.2938, 65.8117),\n    (-73.9449, 66.3105),\n    (-72.6511, 67.2845),\n    (-72.9260, 67.7269),\n    (-73.3116, 68.0694),\n    (-74.8433, 68.5546),\n    (-76.8691, 68.8947),\n    (-76.2286, 69.1477),\n    (-77.2873, 69.7695),\n    (-78.1686, 69.8264),\n    (-78.9572, 70.1668),\n    (-79.4924, 69.8718),\n    (-81.3054, 69.7431),\n    (-84.9447, 69.9666),\n    (-87.0600, 70.2600),\n    (-88.6817, 70.4107),\n    (-89.5134, 70.7620),\n    (-88.4677, 71.2181),\n    (-89.8881, 71.2225),\n    (-90.2051, 72.2350),\n    (-89.4365, 73.1294),\n    (-88.4082, 73.5378),\n    (-85.8261, 73.8038),\n    (-86.5621, 73.1574),\n    (-85.7743, 72.5341),\n    (-84.8501, 73.3402),\n    (-82.3155, 73.7509),\n    (-80.6000, 72.7165),\n    (-80.7489, 72.0619),\n    (-78.7706, 72.3521),\n    (-94.5036, 74.1349),\n    (-92.4200, 74.1000),\n    (-90.5097, 73.8567),\n    (-92.0039, 72.9662),\n    (-93.1962, 72.7719),\n    (-94.2690, 72.0245),\n    (-95.4098, 72.0618),\n    (-96.0337, 72.9402),\n    (-96.0182, 73.4374),\n    (-95.4957, 73.8624),\n    (-94.5036, 74.1349),\n    (-100.4383, 72.7058),\n    (-101.54, 73.36),\n    (-100.3564, 73.8438),\n    (-99.1638, 73.6333),\n    (-97.38, 73.76),\n    (-97.12, 73.47),\n    (-98.0535, 72.9905),\n    (-96.54, 72.56),\n    (-96.72, 71.66),\n    (-98.3596, 71.2728),\n    (-99.3228, 71.3563),\n    (-100.0148, 71.7382),\n    (-102.48, 72.4829),\n    (-102.48, 72.83),\n    (-100.4383, 72.7058),\n    (-107.8194, 75.8455),\n    (-106.9289, 76.0128),\n    (-105.8809, 75.9693),\n    (-105.7049, 75.4795),\n    (-106.3134, 75.0052),\n    (-109.6999, 74.8500),\n    (-112.2230, 74.4169),\n    (-113.7438, 74.3942),\n    (-113.8713, 74.7202),\n    (-111.7942, 75.1624),\n    (-116.3121, 75.0434),\n    (-117.7104, 75.2222),\n    (-116.3460, 76.1990),\n    (-115.4048, 76.4788),\n    (-112.5905, 76.1413),\n    (-110.8142, 75.5491),\n    (-109.0671, 75.4732),\n    (-110.4972, 76.4298),\n    (-109.5811, 76.7941),\n    (-108.5485, 76.6783),\n    (-108.2114, 76.2016),\n    (-107.8194, 75.8455),\n    (-122.8549, 76.1165),\n    (-121.1575, 76.8645),\n    (-119.1039, 77.5122),\n    (-117.5701, 77.4983),\n    (-116.1985, 77.6452),\n    (-116.3358, 76.8769),\n    (-117.1060, 76.5300),\n    (-118.0404, 76.4811),\n    (-119.8993, 76.0532),\n    (-121.4999, 75.9000),\n    (-122.8549, 76.1165),\n    (-121.5378, 74.4489),\n    (-120.1097, 74.2413),\n    (-117.5556, 74.1857),\n    (-116.5844, 73.8960),\n    (-115.5107, 73.4752),\n    (-116.7679, 73.2229),\n    (-119.22, 72.52),\n    (-120.46, 71.82),\n    (-120.46, 71.3836),\n    (-123.0921, 70.9016),\n    (-123.62, 71.34),\n    (-125.9289, 71.8686),\n    (-125.5, 72.2922),\n    (-124.8072, 73.0225),\n    (-123.94, 73.68),\n    (-124.9177, 74.2927),\n    (-121.5378, 74.4489),\n    (-166.4677, 60.3841),\n    (-165.6744, 60.2936),\n    (-165.5791, 59.9099),\n    (-166.1927, 59.7544),\n    (-166.8483, 59.9414),\n    (-167.4552, 60.2130),\n    (-166.4677, 60.3841),\n    (-153.2287, 57.9690),\n    (-152.5647, 57.9014),\n    (-152.1411, 57.5910),\n    (-153.0063, 57.1158),\n    (-154.0050, 56.7346),\n    (-154.5164, 56.9927),\n    (-154.6709, 57.4611),\n    (-153.7627, 57.8165),\n    (-153.2287, 57.9690),\n    (-132.7100, 54.0400),\n    (-131.7499, 54.1200),\n    (-132.0494, 52.9846),\n    (-131.1790, 52.1804),\n    (-131.5778, 52.1823),\n    (-132.1804, 52.6397),\n    (-132.5499, 53.1000),\n    (-133.0546, 53.4114),\n    (-133.2396, 53.8510),\n    (-133.1800, 54.1699),\n    (-132.7100, 54.0400),\n    (-125.4150, 49.9500),\n    (-124.9207, 49.4752),\n    (-123.9225, 49.0624),\n    (-123.5100, 48.5100),\n    (-124.0128, 48.3708),\n    (-125.6550, 48.8250),\n    (-125.9549, 49.1799),\n    (-126.8500, 49.5300),\n    (-127.0299, 49.8149),\n    (-128.0593, 49.9949),\n    (-128.4445, 50.5391),\n    (-128.3584, 50.7706),\n    (-127.3085, 50.5525),\n    (-126.6950, 50.4009),\n    (-125.7550, 50.2950),\n    (-125.4150, 49.9500),\n    (-171.7316, 63.7825),\n    (-171.1144, 63.5921),\n    (-170.4911, 63.6949),\n    (-169.6825, 63.4311),\n    (-168.6894, 63.2975),\n    (-168.7719, 63.1885),\n    (-169.5294, 62.9769),\n    (-170.2905, 63.1944),\n    (-170.6713, 63.3758),\n    (-171.5530, 63.3177),\n    (-171.7911, 63.4058),\n    (-171.7316, 63.7825),\n    (-105.4922, 79.3015),\n    (-103.5292, 79.1653),\n    (-100.8251, 78.8004),\n    (-100.0601, 78.3247),\n    (-99.6709, 77.9075),\n    (-101.3039, 78.0189),\n    (-102.9498, 78.3432),\n    (-105.1761, 78.3803),\n    (-104.2104, 78.6774),\n    (-105.4195, 78.9183),\n    (-105.4922, 79.3015),\n    (32.9469, 35.3867),\n    (33.6672, 35.3732),\n    (34.5764, 35.6715),\n    (33.9008, 35.2457),\n    (34.0048, 34.9780),\n    (32.9798, 34.5718),\n    (32.4902, 34.7016),\n    (32.2566, 35.1032),\n    (32.8024, 35.1455),\n    (32.9469, 35.3867),\n    (26.2900, 35.2999),\n    (26.1649, 35.0049),\n    (24.7249, 34.9199),\n    (24.7350, 35.0849),\n    (23.5149, 35.2799),\n    (23.6999, 35.7050),\n    (24.2466, 35.3680),\n    (25.0250, 35.4249),\n    (25.7692, 35.3540),\n    (25.7450, 35.1799),\n    (26.2900, 35.2999),\n    (49.5435, -12.4698),\n    (49.8089, -12.8952),\n    (50.0565, -13.5557),\n    (50.2174, -14.7587),\n    (50.4765, -15.2265),\n    (50.3771, -15.7060),\n    (50.2002, -16.0002),\n    (49.8606, -15.4142),\n    (49.6726, -15.7101),\n    (49.8633, -16.4510),\n    (49.7745, -16.8750),\n    (49.4986, -17.1060),\n    (49.4356, -17.9530),\n    (49.0417, -19.1187),\n    (48.5485, -20.4968),\n    (47.9307, -22.3915),\n    (47.5477, -23.7819),\n    (47.0957, -24.9416),\n    (46.2824, -25.1784),\n    (45.4095, -25.6014),\n    (44.8335, -25.3461),\n    (44.0397, -24.9883),\n    (43.7637, -24.4606),\n    (43.6977, -23.5741),\n    (43.3456, -22.7769),\n    (43.2541, -22.0574),\n    (43.4332, -21.3364),\n    (43.8936, -21.1633),\n    (43.8963, -20.8304),\n    (44.3743, -20.0723),\n    (44.4643, -19.4354),\n    (44.2324, -18.9619),\n    (44.0429, -18.3313),\n    (43.9630, -17.4099),\n    (44.3124, -16.8504),\n    (44.4465, -16.2162),\n    (44.9449, -16.1793),\n    (45.5027, -15.9743),\n    (45.8729, -15.7934),\n    (46.3122, -15.7800),\n    (46.8821, -15.2101),\n    (47.7051, -14.5943),\n    (48.0052, -14.0912),\n    (47.8689, -13.6638),\n    (48.2938, -13.7840),\n    (48.8450, -13.0891),\n    (48.8635, -12.4878),\n    (49.1946, -12.0405),\n    (49.5435, -12.4698),\n    (167.2168, -15.8918),\n    (167.8448, -16.4663),\n    (167.5151, -16.5978),\n    (167.1800, -16.1599),\n    (167.2168, -15.8918),\n    (166.7931, -15.6688),\n    (166.6498, -15.3927),\n    (166.6291, -14.6264),\n    (167.1077, -14.9339),\n    (167.2700, -15.7400),\n    (167.0012, -15.6146),\n    (166.7931, -15.6688),\n    (134.2101, -6.8952),\n    (134.1127, -6.1424),\n    (134.2903, -5.7830),\n    (134.4996, -5.4450),\n    (134.7270, -5.7375),\n    (134.7246, -6.2144),\n    (134.2101, -6.8952),\n    (-48.6606, -78.0470),\n    (-48.1513, -78.0470),\n    (-46.6628, -77.8314),\n    (-45.1547, -78.0470),\n    (-43.9208, -78.4781),\n    (-43.4899, -79.0855),\n    (-43.3724, -79.5166),\n    (-43.3332, -80.0261),\n    (-44.8805, -80.3396),\n    (-46.5061, -80.5943),\n    (-48.3864, -80.8294),\n    (-50.4821, -81.0254),\n    (-52.8519, -80.9666),\n    (-54.1642, -80.6335),\n    (-53.9879, -80.2220),\n    (-51.8531, -79.9477),\n    (-50.9913, -79.6146),\n    (-50.3645, -79.1834),\n    (-49.9141, -78.8112),\n    (-49.3069, -78.4585),\n    (-48.6606, -78.0470),\n    (-66.2900, -80.2557),\n    (-64.0376, -80.2948),\n    (-61.8832, -80.3928),\n    (-61.1389, -79.9813),\n    (-60.6101, -79.6286),\n    (-59.5720, -80.0401),\n    (-59.8658, -80.5496),\n    (-60.1596, -81.0003),\n    (-62.2553, -80.8631),\n    (-64.4881, -80.9219),\n    (-65.7416, -80.5888),\n    (-65.7416, -80.5496),\n    (-66.2900, -80.2557),\n    (-73.9158, -71.2693),\n    (-73.2303, -71.1517),\n    (-72.0747, -71.1909),\n    (-71.7809, -70.6814),\n    (-71.7221, -70.3091),\n    (-71.7417, -69.5057),\n    (-71.1738, -69.0354),\n    (-70.2532, -68.8787),\n    (-69.7244, -69.2510),\n    (-69.4894, -69.6233),\n    (-69.0585, -70.0740),\n    (-68.7255, -70.5051),\n    (-68.4513, -70.9558),\n    (-68.3338, -71.4064),\n    (-68.5101, -71.7984),\n    (-68.7842, -72.1706),\n    (-69.9594, -72.3078),\n    (-71.0758, -72.5038),\n    (-72.3881, -72.4842),\n    (-71.8984, -72.0923),\n    (-73.0736, -72.2294),\n    (-74.1900, -72.3666),\n    (-74.9538, -72.0727),\n    (-75.0126, -71.6612),\n    (-73.9158, -71.2693),\n    (-102.3307, -71.8941),\n    (-101.7039, -71.7177),\n    (-100.4309, -71.8549),\n    (-98.9815, -71.9333),\n    (-97.8847, -72.0705),\n    (-96.7879, -71.9529),\n    (-96.2003, -72.5212),\n    (-96.9837, -72.4428),\n    (-98.1980, -72.4820),\n    (-99.4320, -72.4428),\n    (-100.7834, -72.5016),\n    (-101.8018, -72.3056),\n    (-102.3307, -71.8941),\n    (-122.6217, -73.6577),\n    (-122.4062, -73.3246),\n    (-121.2115, -73.5009),\n    (-119.9188, -73.6577),\n    (-118.7241, -73.4813),\n    (-119.2921, -73.8340),\n    (-120.2322, -74.0888),\n    (-121.6228, -74.0104),\n    (-122.6217, -73.6577),\n    (-127.2831, -73.4617),\n    (-126.5584, -73.2462),\n    (-125.5595, -73.4813),\n    (-124.0318, -73.8732),\n    (-124.6194, -73.8340),\n    (-125.9121, -73.7361),\n    (-127.2831, -73.4617),\n    (165.7799, -21.0800),\n    (166.5999, -21.7000),\n    (167.1200, -22.1599),\n    (166.7400, -22.3999),\n    (166.1897, -22.1297),\n    (165.4743, -21.6796),\n    (164.8298, -21.1498),\n    (164.1679, -20.4447),\n    (164.0296, -20.1056),\n    (164.4599, -20.1200),\n    (165.0200, -20.4599),\n    (165.4600, -20.8000),\n    (165.7799, -21.0800),\n    (152.6400, -3.6599),\n    (153.0199, -3.9800),\n    (153.1400, -4.4999),\n    (152.8272, -4.7664),\n    (152.6386, -4.1761),\n    (152.4060, -3.7897),\n    (151.9532, -3.4620),\n    (151.3842, -3.0354),\n    (150.6620, -2.7414),\n    (150.9399, -2.5000),\n    (151.4799, -2.7799),\n    (151.8200, -2.9999),\n    (152.2399, -3.2400),\n    (152.6400, -3.6599),\n    (151.3013, -5.8407),\n    (150.7544, -6.0837),\n    (150.2411, -6.3177),\n    (149.7099, -6.3165),\n    (148.8900, -6.0260),\n    (148.3189, -5.7471),\n    (148.4018, -5.4377),\n    (149.2984, -5.5837),\n    (149.8455, -5.5055),\n    (149.9962, -5.0261),\n    (150.1397, -5.0013),\n    (150.2369, -5.5322),\n    (150.8074, -5.4558),\n    (151.0896, -5.1136),\n    (151.6478, -4.7570),\n    (151.5378, -4.1678),\n    (152.1367, -4.1487),\n    (152.3387, -4.3129),\n    (152.3186, -4.8676),\n    (151.9827, -5.4780),\n    (151.4591, -5.5602),\n    (151.3013, -5.8407),\n    (162.1190, -10.4827),\n    (162.3986, -10.8263),\n    (161.7000, -10.8200),\n    (161.3197, -10.2047),\n    (161.9173, -10.4466),\n    (162.1190, -10.4827),\n    (161.6799, -9.5999),\n    (161.5293, -9.7843),\n    (160.7882, -8.9175),\n    (160.5799, -8.3200),\n    (160.9200, -8.3200),\n    (161.2800, -9.1200),\n    (161.6799, -9.5999),\n    (160.8522, -9.8729),\n    (160.4625, -9.8952),\n    (159.8494, -9.7940),\n    (159.6400, -9.6399),\n    (159.7029, -9.2429),\n    (160.3629, -9.4003),\n    (160.6885, -9.6101),\n    (160.8522, -9.8729),\n    (159.6400, -8.0200),\n    (159.8750, -8.3373),\n    (159.9174, -8.5382),\n    (159.1336, -8.1141),\n    (158.5861, -7.7548),\n    (158.2111, -7.4218),\n    (158.3599, -7.3200),\n    (158.8200, -7.5600),\n    (159.6400, -8.0200),\n    (157.1400, -7.0216),\n    (157.5384, -7.3478),\n    (157.3394, -7.4047),\n    (156.9020, -7.1768),\n    (156.4913, -6.7659),\n    (156.5428, -6.5993),\n    (157.1400, -7.0216),\n    (154.7599, -5.3399),\n    (155.0629, -5.5667),\n    (155.5477, -6.2006),\n    (156.0199, -6.5400),\n    (155.8800, -6.8199),\n    (155.5999, -6.9199),\n    (155.1669, -6.5359),\n    (154.7291, -5.9007),\n    (154.5141, -5.1391),\n    (154.6525, -5.0423),\n    (154.7599, -5.3399),\n    (176.8858, -40.0659),\n    (176.5080, -40.6047),\n    (176.0124, -41.2896),\n    (175.2395, -41.6883),\n    (175.0678, -41.4258),\n    (174.6509, -41.2818),\n    (175.2276, -40.4592),\n    (174.9001, -39.9088),\n    (173.8240, -39.5088),\n    (173.8522, -39.1466),\n    (174.5748, -38.7976),\n    (174.7434, -38.0278),\n    (174.6969, -37.3811),\n    (174.2920, -36.7110),\n    (174.3190, -36.5348),\n    (173.8409, -36.1219),\n    (173.0541, -35.2371),\n    (172.6360, -34.5291),\n    (173.0070, -34.4506),\n    (173.5512, -35.0061),\n    (174.3293, -35.2654),\n    (174.6120, -36.1563),\n    (175.3366, -37.2090),\n    (175.3575, -36.5261),\n    (175.8088, -36.7989),\n    (175.9584, -37.5553),\n    (176.7631, -37.8812),\n    (177.4388, -37.9612),\n    (178.0103, -37.5798),\n    (178.5170, -37.6953),\n    (178.2747, -38.5828),\n    (177.9704, -39.1663),\n    (177.2069, -39.1457),\n    (176.9399, -39.4497),\n    (177.0329, -39.8799),\n    (176.8858, -40.0659),\n    (169.6678, -43.5553),\n    (170.5249, -43.0316),\n    (171.1250, -42.5127),\n    (171.5697, -41.7674),\n    (171.9487, -41.5144),\n    (172.0972, -40.9561),\n    (172.7985, -40.4939),\n    (173.0203, -40.9190),\n    (173.2472, -41.3319),\n    (173.9584, -40.9267),\n    (174.2475, -41.3491),\n    (174.2485, -41.7700),\n    (173.8764, -42.2331),\n    (173.2227, -42.9700),\n    (172.7112, -43.3722),\n    (173.0801, -43.8533),\n    (172.3085, -43.8656),\n    (171.4529, -44.2424),\n    (171.1851, -44.8971),\n    (170.6166, -45.9089),\n    (169.8314, -46.3557),\n    (169.3323, -46.6412),\n    (168.4113, -46.6199),\n    (167.7637, -46.2901),\n    (166.6768, -46.2199),\n    (166.5091, -45.8527),\n    (167.0463, -45.1109),\n    (168.3037, -44.1239),\n    (168.9494, -43.9358),\n    (169.6678, -43.5553),\n    (147.6892, -40.8082),\n    (148.2890, -40.8754),\n    (148.3598, -42.0623),\n    (148.0173, -42.4070),\n    (147.9140, -43.2115),\n    (147.5645, -42.9376),\n    (146.8703, -43.6345),\n    (146.6633, -43.5808),\n    (146.0483, -43.5497),\n    (145.4319, -42.6937),\n    (145.2950, -42.0336),\n    (144.7180, -41.1625),\n    (144.7437, -40.7039),\n    (145.3979, -40.7925),\n    (146.3641, -41.1376),\n    (146.9085, -41.0005),\n    (147.6892, -40.8082),\n    (126.1487, -32.2159),\n    (125.0886, -32.7287),\n    (124.2216, -32.9594),\n    (124.0289, -33.4838),\n    (123.6596, -33.8901),\n    (122.8110, -33.9144),\n    (122.1830, -34.0034),\n    (121.2991, -33.8210),\n    (120.5802, -33.9301),\n    (119.8936, -33.9760),\n    (119.2988, -34.5093),\n    (119.0073, -34.4641),\n    (118.5057, -34.7468),\n    (118.0249, -35.0647),\n    (117.2955, -35.0254),\n    (116.6251, -35.0250),\n    (115.5643, -34.3864),\n    (115.0268, -34.1965),\n    (115.0486, -33.6234),\n    (115.5451, -33.4872),\n    (115.7146, -33.2595),\n    (115.6793, -32.9003),\n    (115.8016, -32.2050),\n    (115.6896, -31.6124),\n    (115.1609, -30.6015),\n    (114.9970, -30.0307),\n    (115.0400, -29.4610),\n    (114.6419, -28.8102),\n    (114.6164, -28.5163),\n    (114.1735, -28.1180),\n    (114.0488, -27.3347),\n    (113.4774, -26.5431),\n    (113.3389, -26.1165),\n    (113.7783, -26.5490),\n    (113.4409, -25.6212),\n    (113.9369, -25.9112),\n    (114.2328, -26.2984),\n    (114.2161, -25.7862),\n    (113.7212, -24.9989),\n    (113.6253, -24.6839),\n    (113.3935, -24.3847),\n    (113.5020, -23.8063),\n    (113.7069, -23.5602),\n    (113.8434, -23.0599),\n    (113.7365, -22.4754),\n    (114.1497, -21.7558),\n    (114.2253, -22.5174),\n    (114.6477, -21.8295),\n    (115.4601, -21.4951),\n    (115.9473, -21.0686),\n    (116.7116, -20.7016),\n    (117.1663, -20.6235),\n    (117.4415, -20.7468),\n    (118.2295, -20.3742),\n    (118.8360, -20.2633),\n    (118.9878, -20.0442),\n    (119.2524, -19.9529),\n    (119.8052, -19.9765),\n    (120.8562, -19.6837),\n    (121.3998, -19.2397),\n    (121.6550, -18.7053),\n    (122.2416, -18.1976),\n    (122.2866, -17.7986),\n    (122.3127, -17.2549),\n    (123.0125, -16.4051),\n    (123.4337, -17.2685),\n    (123.8593, -17.0690),\n    (123.5032, -16.5965),\n    (123.8170, -16.1113),\n    (124.2582, -16.3279),\n    (124.3797, -15.5670),\n    (124.9261, -15.0751),\n    (125.1672, -14.6803),\n    (125.6700, -14.5100),\n    (125.6857, -14.2306),\n    (126.1251, -14.3473),\n    (126.1428, -14.0959),\n    (126.5825, -13.9527),\n    (127.0658, -13.8179),\n    (127.8046, -14.2769),\n    (128.3596, -14.8691),\n    (128.9855, -14.8759),\n    (129.6214, -14.9697),\n    (129.4096, -14.4206),\n    (129.8886, -13.6187),\n    (130.3394, -13.3573),\n    (130.1835, -13.1075),\n    (130.6177, -12.5363),\n    (131.2234, -12.1836),\n    (131.7350, -12.3024),\n    (132.5752, -12.1140),\n    (132.5572, -11.6030),\n    (131.8246, -11.2737),\n    (132.3572, -11.1285),\n    (133.0195, -11.3764),\n    (133.5508, -11.7865),\n    (134.3930, -12.0423),\n    (134.6786, -11.9411),\n    (135.2984, -12.2486),\n    (135.8826, -11.9622),\n    (136.2583, -12.0493),\n    (136.4924, -11.8572),\n    (136.9516, -12.3519),\n    (136.6851, -12.8872),\n    (136.3054, -13.2912),\n    (135.9617, -13.3245),\n    (136.0776, -13.7242),\n    (135.7838, -14.2239),\n    (135.4286, -14.7154),\n    (135.5001, -14.9977),\n    (136.2951, -15.5502),\n    (137.0653, -15.8707),\n    (137.5804, -16.2150),\n    (138.3032, -16.8076),\n    (138.5851, -16.8066),\n    (139.1085, -17.0626),\n    (139.2605, -17.3716),\n    (140.2151, -17.7108),\n    (140.8754, -17.3690),\n    (141.0711, -16.8320),\n    (141.2740, -16.3888),\n    (141.3982, -15.8405),\n    (141.7021, -15.0449),\n    (141.5633, -14.5613),\n    (141.6355, -14.2703),\n    (141.5198, -13.6980),\n    (141.6509, -12.9446),\n    (141.8426, -12.7415),\n    (141.6869, -12.4076),\n    (141.9286, -11.8774),\n    (142.1184, -11.3280),\n    (142.1437, -11.0427),\n    (142.5152, -10.6681),\n    (142.7973, -11.1573),\n    (142.8667, -11.7847),\n    (143.1159, -11.9056),\n    (143.1586, -12.3256),\n    (143.5221, -12.8343),\n    (143.5971, -13.4004),\n    (143.5618, -13.7636),\n    (143.9220, -14.5483),\n    (144.5637, -14.1711),\n    (144.8948, -14.5944),\n    (145.3747, -14.9849),\n    (145.2719, -15.4282),\n    (145.4852, -16.2856),\n    (145.6369, -16.7849),\n    (145.8888, -16.9069),\n    (146.1603, -17.7616),\n    (146.0636, -18.2800),\n    (146.3874, -18.9582),\n    (147.4710, -19.4807),\n    (148.1776, -19.9559),\n    (148.8484, -20.3912),\n    (148.7174, -20.6334),\n    (149.2894, -21.2605),\n    (149.6783, -22.3425),\n    (150.0773, -22.1227),\n    (150.4829, -22.5561),\n    (150.7272, -22.4023),\n    (150.8995, -23.4622),\n    (151.6091, -24.0762),\n    (152.0735, -24.4578),\n    (152.8551, -25.2675),\n    (153.1361, -26.0711),\n    (153.1619, -26.6413),\n    (153.0929, -27.2602),\n    (153.5694, -28.1100),\n    (153.5121, -28.9950),\n    (153.3390, -29.4582),\n    (153.0692, -30.3502),\n    (153.0895, -30.9236),\n    (152.8915, -31.6404),\n    (152.4500, -32.5500),\n    (151.7091, -33.0413),\n    (151.3439, -33.8160),\n    (151.0105, -34.3103),\n    (150.7141, -35.1734),\n    (150.3282, -35.6718),\n    (150.0752, -36.4202),\n    (149.9461, -37.1090),\n    (149.9972, -37.4252),\n    (149.4238, -37.7726),\n    (148.3046, -37.8090),\n    (147.3817, -38.2192),\n    (146.9221, -38.6065),\n    (146.3179, -39.0357),\n    (145.4896, -38.5937),\n    (144.8769, -38.4174),\n    (145.0322, -37.8961),\n    (144.4856, -38.0853),\n    (143.6099, -38.8094),\n    (142.7454, -38.5382),\n    (142.1783, -38.3800),\n    (141.6065, -38.3085),\n    (140.6385, -38.0193),\n    (139.9921, -37.4029),\n    (139.8065, -36.6436),\n    (139.5741, -36.1383),\n    (139.0828, -35.7327),\n    (138.1207, -35.6122),\n    (138.4494, -35.1272),\n    (138.2075, -34.3847),\n    (137.7191, -35.0768),\n    (136.8294, -35.2605),\n    (137.3523, -34.7073),\n    (137.5038, -34.1302),\n    (137.8901, -33.6404),\n    (137.8103, -32.9000),\n    (136.9968, -33.7527),\n    (136.3720, -34.0947),\n    (135.9890, -34.8901),\n    (135.2082, -34.4786),\n    (135.2392, -33.9479),\n    (134.6134, -33.2227),\n    (134.0859, -32.8480),\n    (134.2739, -32.6172),\n    (132.9907, -32.0112),\n    (132.2880, -31.9826),\n    (131.3263, -31.4958),\n    (129.5357, -31.5904),\n    (128.2409, -31.9484),\n    (127.1028, -32.2822),\n    (126.1487, -32.2159),\n    (81.7879, 7.5230),\n    (81.6373, 6.4817),\n    (81.2180, 6.1971),\n    (80.3483, 5.9683),\n    (79.8724, 6.7634),\n    (79.6951, 8.2008),\n    (80.1478, 9.8240),\n    (80.8388, 9.2684),\n    (81.3043, 8.5642),\n    (81.7879, 7.5230),\n    (129.3709, -2.8021),\n    (130.4713, -3.0937),\n    (130.8348, -3.8584),\n    (129.9905, -3.4463),\n    (129.1552, -3.3626),\n    (128.5906, -3.4286),\n    (127.8988, -3.3934),\n    (128.1358, -2.8436),\n    (129.3709, -2.8021),\n    (126.8749, -3.7909),\n    (126.1838, -3.6073),\n    (125.9890, -3.1772),\n    (127.0006, -3.1293),\n    (127.2492, -3.4590),\n    (126.8749, -3.7909),\n    (127.9323, 2.1745),\n    (128.0041, 1.6285),\n    (128.5945, 1.5408),\n    (128.6882, 1.1323),\n    (128.6359, 0.2584),\n    (128.1201, 0.3564),\n    (127.9680, -0.2520),\n    (128.3799, -0.7800),\n    (128.1000, -0.8999),\n    (127.6964, -0.2665),\n    (127.3994, 1.0117),\n    (127.6005, 1.8106),\n    (127.9323, 2.1745),\n    (122.9275, 0.8751),\n    (124.0775, 0.9171),\n    (125.0659, 1.6432),\n    (125.2405, 1.4198),\n    (124.4370, 0.4278),\n    (123.6855, 0.2355),\n    (122.7230, 0.4311),\n    (121.0567, 0.3812),\n    (120.1830, 0.2372),\n    (120.0408, -0.5196),\n    (120.9359, -1.4089),\n    (121.4758, -0.9559),\n    (123.3405, -0.6156),\n    (123.2583, -1.0762),\n    (122.8226, -0.9309),\n    (122.3885, -1.5168),\n    (121.5082, -1.9044),\n    (122.4545, -3.1860),\n    (122.2718, -3.5295),\n    (123.1709, -4.6836),\n    (123.1623, -5.3406),\n    (122.6285, -5.6345),\n    (122.2363, -5.2829),\n    (122.7195, -4.4641),\n    (121.7382, -4.8513),\n    (121.4894, -4.5745),\n    (121.6191, -4.1884),\n    (120.8981, -3.6021),\n    (120.9723, -2.6276),\n    (120.3054, -2.9316),\n    (120.3900, -4.0975),\n    (120.4307, -5.5282),\n    (119.7965, -5.6734),\n    (119.3669, -5.3798),\n    (119.6536, -4.4594),\n    (119.4988, -3.4944),\n    (119.0783, -3.4870),\n    (118.7677, -2.8019),\n    (119.1809, -2.1471),\n    (119.3233, -1.3531),\n    (119.8259, 0.1542),\n    (120.0357, 0.5664),\n    (120.8857, 1.3092),\n    (121.6668, 1.0139),\n    (122.9275, 0.8751),\n    (120.2950, -10.2586),\n    (118.9678, -9.5579),\n    (119.9003, -9.3613),\n    (120.4257, -9.6659),\n    (120.7755, -9.9696),\n    (120.7156, -10.2395),\n    (120.2950, -10.2586),\n    (121.3416, -8.5367),\n    (122.0073, -8.4606),\n    (122.9035, -8.0942),\n    (122.7569, -8.6498),\n    (121.2544, -8.9336),\n    (119.9243, -8.8104),\n    (119.9209, -8.4448),\n    (120.7150, -8.2369),\n    (121.3416, -8.5367),\n    (118.2606, -8.3623),\n    (118.8784, -8.2806),\n    (119.1265, -8.7058),\n    (117.9704, -8.9066),\n    (117.2777, -9.0408),\n    (116.7401, -9.0328),\n    (117.0837, -8.4571),\n    (117.6320, -8.4493),\n    (117.9000, -8.0956),\n    (118.2606, -8.3623),\n    (108.4868, -6.4219),\n    (108.6234, -6.7776),\n    (110.5392, -6.8773),\n    (110.7595, -6.4651),\n    (112.6148, -6.9460),\n    (112.9787, -7.5942),\n    (114.4789, -7.7765),\n    (115.7055, -8.3708),\n    (114.5645, -8.7518),\n    (113.4647, -8.3489),\n    (112.5596, -8.3761),\n    (111.5220, -8.3021),\n    (110.5861, -8.1226),\n    (109.4276, -7.7406),\n    (108.6936, -7.6416),\n    (108.2777, -7.7666),\n    (106.4541, -7.3548),\n    (106.2806, -6.9248),\n    (105.3654, -6.8514),\n    (106.0516, -5.8959),\n    (107.2650, -5.9549),\n    (108.0720, -6.3457),\n    (108.4868, -6.4219),\n    (104.3699, -1.0848),\n    (104.5394, -1.7823),\n    (104.8878, -2.3404),\n    (105.6221, -2.4288),\n    (106.1085, -3.0617),\n    (105.8574, -4.3055),\n    (105.8176, -5.8523),\n    (104.7103, -5.8732),\n    (103.8682, -5.0373),\n    (102.5842, -4.2202),\n    (102.1561, -3.6141),\n    (101.3991, -2.7997),\n    (100.9025, -2.0502),\n    (100.1419, -0.6503),\n    (99.2637, 0.1831),\n    (98.9700, 1.0428),\n    (98.6013, 1.8235),\n    (97.6995, 2.4531),\n    (97.1769, 3.3087),\n    (96.4240, 3.8688),\n    (95.3808, 4.9707),\n    (95.2930, 5.4798),\n    (95.9368, 5.4395),\n    (97.4848, 5.2463),\n    (98.3691, 4.2683),\n    (99.1425, 3.5903),\n    (99.6939, 3.1743),\n    (100.6414, 2.0993),\n    (101.6580, 2.0836),\n    (102.4982, 1.3987),\n    (103.0768, 0.5613),\n    (103.8383, 0.1045),\n    (103.4376, -0.7119),\n    (104.0107, -1.0592),\n    (104.3699, -1.0848),\n    (120.8338, 12.7044),\n    (120.3234, 13.4664),\n    (121.1801, 13.4296),\n    (121.5273, 13.0695),\n    (121.2621, 12.2055),\n    (120.8338, 12.7044),\n    (122.5860, 9.9810),\n    (122.8370, 10.2611),\n    (122.9474, 10.8818),\n    (123.4988, 10.9406),\n    (123.3377, 10.2673),\n    (124.0779, 11.2327),\n    (123.9824, 10.2787),\n    (123.6230, 9.9500),\n    (123.3099, 9.3182),\n    (122.9958, 9.0221),\n    (122.3800, 9.7133),\n    (122.5860, 9.9810),\n    (126.3768, 8.4147),\n    (126.4785, 7.7503),\n    (126.5374, 7.1894),\n    (126.1967, 6.2742),\n    (125.8314, 7.2937),\n    (125.3638, 6.7864),\n    (125.6831, 6.0496),\n    (125.3965, 5.5810),\n    (124.2197, 6.1613),\n    (123.9387, 6.8851),\n    (124.2436, 7.3606),\n    (123.6101, 7.8335),\n    (123.2960, 7.4188),\n    (122.8255, 7.4573),\n    (122.0854, 6.8994),\n    (121.9199, 7.1921),\n    (122.3123, 8.0349),\n    (122.9423, 8.3162),\n    (123.4876, 8.6930),\n    (123.8411, 8.2403),\n    (124.6014, 8.5141),\n    (124.7646, 8.9604),\n    (125.4713, 8.9869),\n    (125.4121, 9.7603),\n    (126.2227, 9.2860),\n    (126.3066, 8.7824),\n    (126.3768, 8.4147),\n    (109.4752, 18.1977),\n    (108.6552, 18.5076),\n    (108.6262, 19.3678),\n    (109.1190, 19.8210),\n    (110.2115, 20.1012),\n    (110.7865, 20.0775),\n    (111.0100, 19.6959),\n    (110.5706, 19.2558),\n    (110.3391, 18.6783),\n    (109.4752, 18.1977),\n    (121.7778, 24.3942),\n    (121.1756, 22.7908),\n    (120.7470, 21.9705),\n    (120.2200, 22.8148),\n    (120.1061, 23.5562),\n    (120.6946, 24.5384),\n    (121.4950, 25.2954),\n    (121.9512, 24.9975),\n    (121.7778, 24.3942),\n    (141.8846, 39.1808),\n    (140.9594, 38.1740),\n    (140.9763, 37.1420),\n    (140.5997, 36.3439),\n    (140.7740, 35.8428),\n    (140.2532, 35.1381),\n    (138.9755, 34.6676),\n    (137.2175, 34.6062),\n    (135.7929, 33.4648),\n    (135.1209, 33.8490),\n    (135.0794, 34.5965),\n    (133.3403, 34.3759),\n    (132.1567, 33.9049),\n    (130.9861, 33.8857),\n    (132.0000, 33.1499),\n    (131.3327, 31.4503),\n    (130.6863, 31.0295),\n    (130.2024, 31.4182),\n    (130.4476, 32.3194),\n    (129.8146, 32.6103),\n    (129.4084, 33.2960),\n    (130.3539, 33.6041),\n    (130.8784, 34.2327),\n    (131.8842, 34.7497),\n    (132.6176, 35.4333),\n    (134.6083, 35.7316),\n    (135.6775, 35.5271),\n    (136.7238, 37.3049),\n    (137.3906, 36.8273),\n    (138.8576, 37.8274),\n    (139.4264, 38.2159),\n    (140.0547, 39.4388),\n    (139.8833, 40.5633),\n    (140.3057, 41.1950),\n    (141.3689, 41.3785),\n    (141.9142, 39.9916),\n    (141.8846, 39.1808),\n    (144.6134, 43.9609),\n    (145.3208, 44.3847),\n    (145.5431, 43.2621),\n    (144.0596, 42.9883),\n    (143.1838, 41.9952),\n    (141.6114, 42.6787),\n    (141.0672, 41.5845),\n    (139.9551, 41.5695),\n    (139.8175, 42.5637),\n    (140.3120, 43.3332),\n    (141.3805, 43.3888),\n    (141.6719, 44.7721),\n    (141.9676, 45.5514),\n    (143.1428, 44.5103),\n    (143.9101, 44.1740),\n    (144.6134, 43.9609),\n    (8.7099, 40.8999),\n    (9.2100, 41.2099),\n    (9.8099, 40.5000),\n    (9.6695, 39.1773),\n    (9.2148, 39.2404),\n    (8.8069, 38.9066),\n    (8.4283, 39.1718),\n    (8.3882, 40.3783),\n    (8.1599, 40.9500),\n    (8.7099, 40.8999),\n    (8.7460, 42.6281),\n    (9.3900, 43.0099),\n    (9.5600, 42.1525),\n    (9.2297, 41.3800),\n    (8.7757, 41.5836),\n    (8.5442, 42.2565),\n    (8.7460, 42.6281),\n    (12.3709, 56.1114),\n    (12.6900, 55.6099),\n    (12.0899, 54.8000),\n    (11.0435, 55.3648),\n    (10.9039, 55.7799),\n    (12.3709, 56.1114),\n    (-4.2114, 58.5508),\n    (-3.0050, 58.6350),\n    (-4.0738, 57.5530),\n    (-3.0550, 57.6900),\n    (-1.9592, 57.6847),\n    (-2.2199, 56.8700),\n    (-3.1190, 55.9737),\n    (-2.0850, 55.9099),\n    (-1.1149, 54.6249),\n    (-0.4304, 54.4643),\n    (0.1849, 53.3250),\n    (0.4699, 52.9299),\n    (1.6815, 52.7395),\n    (1.5599, 52.0999),\n    (1.0505, 51.8067),\n    (1.4498, 51.2894),\n    (0.5503, 50.7657),\n    (-0.7875, 50.7749),\n    (-2.4899, 50.5000),\n    (-2.9562, 50.6968),\n    (-3.6174, 50.2283),\n    (-4.5425, 50.3418),\n    (-5.2450, 49.9599),\n    (-5.7765, 50.1596),\n    (-4.3099, 51.2100),\n    (-3.4148, 51.4260),\n    (-4.9843, 51.5934),\n    (-5.2672, 51.9914),\n    (-4.2223, 52.3013),\n    (-4.7700, 52.8400),\n    (-4.5799, 53.4950),\n    (-3.0920, 53.4044),\n    (-2.9450, 53.9849),\n    (-3.6300, 54.6150),\n    (-4.8441, 54.7909),\n    (-5.0825, 55.0616),\n    (-4.7191, 55.5084),\n    (-5.0479, 55.7839),\n    (-5.5863, 55.3111),\n    (-5.6449, 56.2750),\n    (-6.1499, 56.7850),\n    (-5.7868, 57.8188),\n    (-5.0099, 58.6300),\n    (-4.2114, 58.5508),\n    (-14.5086, 66.4558),\n    (-14.7396, 65.8087),\n    (-13.6097, 65.1266),\n    (-14.9098, 64.3640),\n    (-17.7944, 63.6787),\n    (-18.6562, 63.4963),\n    (-19.9727, 63.6436),\n    (-22.7629, 63.9601),\n    (-21.7784, 64.4021),\n    (-23.9550, 64.8911),\n    (-22.1844, 65.0849),\n    (-22.2274, 65.3785),\n    (-24.3261, 65.6111),\n    (-23.6505, 66.2625),\n    (-22.1349, 66.4104),\n    (-20.5762, 65.7321),\n    (-19.0568, 66.2766),\n    (-17.7986, 65.9938),\n    (-16.1678, 66.5268),\n    (-14.5086, 66.4558),\n    (142.9146, 53.7045),\n    (143.2608, 52.7407),\n    (143.2352, 51.7566),\n    (143.6480, 50.7476),\n    (144.6541, 48.9763),\n    (143.1739, 49.3065),\n    (142.5586, 47.8615),\n    (143.5334, 46.8367),\n    (143.5052, 46.1379),\n    (142.7477, 46.7407),\n    (142.0920, 45.9667),\n    (141.9069, 46.8059),\n    (142.0184, 47.7801),\n    (141.9044, 48.8591),\n    (142.1358, 49.6151),\n    (142.1799, 50.9523),\n    (141.5940, 51.9354),\n    (141.6825, 53.3019),\n    (142.6069, 53.7621),\n    (142.2097, 54.2254),\n    (142.6547, 54.3658),\n    (142.9146, 53.7045),\n    (118.5045, 9.3163),\n    (117.1742, 8.3674),\n    (117.6644, 9.0668),\n    (118.3869, 9.6844),\n    (118.9873, 10.3762),\n    (119.5114, 11.3696),\n    (119.6896, 10.5542),\n    (119.0294, 10.0036),\n    (118.5045, 9.3163),\n    (122.3369, 18.2248),\n    (122.1742, 17.8102),\n    (122.5156, 17.0935),\n    (122.2523, 16.2624),\n    (121.6627, 15.9310),\n    (121.5050, 15.1248),\n    (121.7288, 14.3283),\n    (122.2589, 14.2182),\n    (122.7012, 14.3365),\n    (123.9502, 13.7821),\n    (123.8551, 13.2377),\n    (124.1812, 12.9975),\n    (124.0774, 12.5366),\n    (123.2980, 13.0275),\n    (122.9286, 13.5529),\n    (122.6713, 13.1858),\n    (122.0346, 13.7844),\n    (121.1263, 13.6366),\n    (120.6286, 13.8576),\n    (120.6793, 14.2710),\n    (120.9918, 14.5253),\n    (120.6933, 14.7566),\n    (120.5641, 14.3962),\n    (120.0704, 14.9708),\n    (119.9209, 15.4063),\n    (119.8837, 16.3637),\n    (120.2864, 16.0346),\n    (120.3900, 17.5990),\n    (120.7158, 18.5052),\n    (121.3213, 18.5040),\n    (121.9376, 18.2185),\n    (122.2460, 18.4789),\n    (122.3369, 18.2248),\n    (122.0383, 11.4158),\n    (121.8835, 11.8917),\n    (122.4838, 11.5822),\n    (123.1202, 11.5836),\n    (123.1008, 11.1659),\n    (122.6377, 10.7413),\n    (122.0026, 10.4410),\n    (121.9673, 10.9056),\n    (122.0383, 11.4158),\n    (125.5025, 12.1626),\n    (125.7834, 11.0461),\n    (125.0118, 11.3114),\n    (125.0327, 10.9758),\n    (125.2774, 10.3587),\n    (124.8018, 10.1346),\n    (124.7601, 10.8379),\n    (124.4591, 10.8899),\n    (124.3025, 11.4953),\n    (124.8910, 11.4155),\n    (124.8779, 11.7941),\n    (124.2667, 12.5577),\n    (125.2271, 12.5357),\n    (125.5025, 12.1626),\n    (-77.3533, 8.6705),\n    (-76.8366, 8.6387),\n    (-76.0863, 9.3368),\n    (-75.6746, 9.4432),\n    (-75.6647, 9.7740),\n    (-75.4804, 10.6189),\n    (-74.9068, 11.0830),\n    (-74.2767, 11.1020),\n    (-74.1972, 11.3104),\n    (-73.4147, 11.2270),\n    (-72.6278, 11.7319),\n    (-72.2381, 11.9555),\n    (-71.7540, 12.4373),\n    (-71.3998, 12.3760),\n    (-71.1374, 12.1129),\n    (-71.3315, 11.7762),\n    (-71.3600, 11.5399),\n    (-71.9470, 11.4232),\n    (-71.6208, 10.9694),\n    (-71.6330, 10.4464),\n    (-72.0741, 9.8656),\n    (-71.6956, 9.0722),\n    (-71.2645, 9.1372),\n    (-71.0399, 9.8599),\n    (-71.3500, 10.2119),\n    (-71.4006, 10.9689),\n    (-70.1552, 11.3754),\n    (-70.2938, 11.8468),\n    (-69.9432, 12.1623),\n    (-69.5843, 11.4596),\n    (-68.8829, 11.4433),\n    (-68.2332, 10.8857),\n    (-68.1941, 10.5546),\n    (-67.2962, 10.5458),\n    (-66.2278, 10.6486),\n    (-65.6552, 10.2007),\n    (-64.8904, 10.0772),\n    (-64.3294, 10.3895),\n    (-64.3180, 10.6414),\n    (-63.0793, 10.7017),\n    (-61.8809, 10.7156),\n    (-62.7301, 10.4202),\n    (-62.3885, 9.9482),\n    (-61.5887, 9.8730),\n    (-60.8305, 9.3813),\n    (-60.6712, 8.5801),\n    (-60.1500, 8.6027),\n    (-59.7582, 8.3670),\n    (-59.1016, 7.9992),\n    (-58.4829, 7.3476),\n    (-58.4548, 6.8327),\n    (-58.0781, 6.8090),\n    (-57.5422, 6.3212),\n    (-57.1474, 5.9731),\n    (-55.9493, 5.7728),\n    (-55.8417, 5.9531),\n    (-55.0332, 6.0252),\n    (-53.9580, 5.7565),\n    (-53.6184, 5.6465),\n    (-52.8821, 5.4098),\n    (-51.8233, 4.5657),\n    (-51.6577, 4.1562),\n    (-51.2999, 4.1200),\n    (-51.0697, 3.6503),\n    (-50.5088, 1.9015),\n    (-49.9740, 1.7364),\n    (-49.9471, 1.0461),\n    (-50.6992, 0.2229),\n    (-50.3882, -0.0784),\n    (-48.6205, -0.2354),\n    (-48.5844, -1.2378),\n    (-47.8249, -0.5816),\n    (-46.5665, -0.9410),\n    (-44.9057, -1.5517),\n    (-44.4176, -2.1377),\n    (-44.5815, -2.6913),\n    (-43.4187, -2.3831),\n    (-41.4726, -2.9120),\n    (-39.9786, -2.8730),\n    (-38.5003, -3.7006),\n    (-37.2232, -4.8209),\n    (-36.4529, -5.1094),\n    (-35.5977, -5.1495),\n    (-35.2353, -5.4649),\n    (-34.8960, -6.7381),\n    (-34.7299, -7.3432),\n    (-35.1282, -8.9964),\n    (-35.6369, -9.6492),\n    (-37.0465, -11.0407),\n    (-37.6836, -12.1711),\n    (-38.4238, -13.0381),\n    (-38.6738, -13.0576),\n    (-38.9532, -13.7933),\n    (-38.8822, -15.6670),\n    (-39.1610, -17.2084),\n    (-39.2673, -17.8677),\n    (-39.5835, -18.2622),\n    (-39.7608, -19.5991),\n    (-40.7747, -20.9045),\n    (-40.9447, -21.9373),\n    (-41.7541, -22.3706),\n    (-41.9882, -22.9700),\n    (-43.0747, -22.9676),\n    (-44.6478, -23.3519),\n    (-45.3521, -23.7968),\n    (-46.4720, -24.0889),\n    (-47.6489, -24.8851),\n    (-48.4954, -25.8770),\n    (-48.6410, -26.6236),\n    (-48.4747, -27.1759),\n    (-48.6615, -28.1861),\n    (-48.8884, -28.6741),\n    (-49.5873, -29.2244),\n    (-50.6968, -30.9844),\n    (-51.5762, -31.7776),\n    (-52.2560, -32.2453),\n    (-52.7120, -33.1965),\n    (-53.3736, -33.7683),\n    (-53.8064, -34.3968),\n    (-54.9358, -34.9526),\n    (-55.6740, -34.7526),\n    (-56.2152, -34.8598),\n    (-57.1396, -34.4304),\n    (-57.8178, -34.4625),\n    (-58.4270, -33.9094),\n    (-58.4954, -34.4314),\n    (-57.2258, -35.2880),\n    (-57.3623, -35.9773),\n    (-56.7374, -36.4131),\n    (-56.7882, -36.9015),\n    (-57.7491, -38.1838),\n    (-59.2318, -38.7201),\n    (-61.2374, -38.9284),\n    (-62.3359, -38.8277),\n    (-62.1257, -39.4241),\n    (-62.3305, -40.1725),\n    (-62.1459, -40.6768),\n    (-62.7458, -41.0287),\n    (-63.7704, -41.1667),\n    (-64.7320, -40.8026),\n    (-65.1180, -41.0643),\n    (-64.9785, -42.0580),\n    (-64.3034, -42.3590),\n    (-63.7559, -42.0436),\n    (-63.4580, -42.5631),\n    (-64.3788, -42.8735),\n    (-65.1818, -43.4953),\n    (-65.3288, -44.5013),\n    (-65.5652, -45.0367),\n    (-66.5099, -45.0396),\n    (-67.2937, -45.5518),\n    (-67.5805, -46.3017),\n    (-66.5970, -47.0338),\n    (-65.6410, -47.2361),\n    (-65.9850, -48.1332),\n    (-67.1661, -48.6973),\n    (-67.8160, -49.8696),\n    (-68.7287, -50.2641),\n    (-69.1385, -50.7325),\n    (-68.8155, -51.7711),\n    (-68.1499, -52.3499),\n    (-68.5715, -52.2994),\n    (-69.4612, -52.2919),\n    (-69.9427, -52.5379),\n    (-70.8451, -52.8991),\n    (-71.0063, -53.8332),\n    (-71.4297, -53.8564),\n    (-72.5579, -53.5314),\n    (-73.7027, -52.8350),\n    (-74.9467, -52.2627),\n    (-75.2600, -51.6293),\n    (-74.9766, -51.0433),\n    (-75.4797, -50.3783),\n    (-75.6080, -48.6737),\n    (-75.1827, -47.7119),\n    (-74.1265, -46.9392),\n    (-75.6443, -46.6476),\n    (-74.6921, -45.7639),\n    (-74.3517, -44.1030),\n    (-73.2403, -44.4549),\n    (-72.7178, -42.3833),\n    (-73.3888, -42.1175),\n    (-73.7013, -43.3657),\n    (-74.3319, -43.2249),\n    (-74.0179, -41.7948),\n    (-73.6770, -39.9422),\n    (-73.2175, -39.2586),\n    (-73.5055, -38.2828),\n    (-73.5880, -37.1562),\n    (-73.1667, -37.1237),\n    (-72.5531, -35.5088),\n    (-71.8617, -33.9090),\n    (-71.4384, -32.4188),\n    (-71.6687, -30.9206),\n    (-71.3700, -30.0956),\n    (-71.4898, -28.8614),\n    (-70.9051, -27.6403),\n    (-70.7249, -25.7059),\n    (-70.4039, -23.6289),\n    (-70.0912, -21.3933),\n    (-70.1644, -19.7564),\n    (-70.3725, -18.3479),\n    (-71.3752, -17.7737),\n    (-71.4620, -17.3634),\n    (-73.4445, -16.3593),\n    (-75.2378, -15.2656),\n    (-76.0092, -14.6492),\n    (-76.4234, -13.8231),\n    (-76.2592, -13.5350),\n    (-77.1061, -12.2227),\n    (-78.0921, -10.3777),\n    (-79.0369, -8.3865),\n    (-79.4459, -7.9308),\n    (-79.7605, -7.1943),\n    (-80.5374, -6.5416),\n    (-81.2499, -6.1368),\n    (-80.9263, -5.6905),\n    (-81.4109, -4.7367),\n    (-81.0996, -4.0363),\n    (-80.3025, -3.4048),\n    (-79.7702, -2.6575),\n    (-79.9865, -2.2207),\n    (-80.3687, -2.6851),\n    (-80.9677, -2.2469),\n    (-80.7648, -1.9650),\n    (-80.9336, -1.0574),\n    (-80.5833, -0.9066),\n    (-80.3993, -0.2837),\n    (-80.0208, 0.3603),\n    (-80.0906, 0.7684),\n    (-79.5427, 0.9829),\n    (-78.8552, 1.3809),\n    (-78.9909, 1.6913),\n    (-78.6178, 1.7664),\n    (-78.6621, 2.2673),\n    (-78.4276, 2.6295),\n    (-77.9315, 2.6966),\n    (-77.5104, 3.3250),\n    (-77.1276, 3.8496),\n    (-77.4962, 4.0876),\n    (-77.3076, 4.6679),\n    (-77.5332, 5.5828),\n    (-77.3188, 5.8453),\n    (-77.4766, 6.6911),\n    (-77.8815, 7.2237),\n    (-74.6625, -52.8374),\n    (-73.8380, -53.0474),\n    (-72.4341, -53.7153),\n    (-71.1077, -54.0743),\n    (-70.5917, -53.6158),\n    (-70.2674, -52.9312),\n    (-69.3456, -52.5182),\n    (-68.6341, -52.6362),\n    (-68.2500, -53.1000),\n    (-67.7499, -53.8499),\n    (-66.4499, -54.4500),\n    (-65.0500, -54.7000),\n    (-65.5000, -55.1999),\n    (-66.4499, -55.2500),\n    (-66.9599, -54.8968),\n    (-67.2910, -55.3012),\n    (-68.1486, -55.6118),\n    (-68.6399, -55.5800),\n    (-69.2320, -55.4990),\n    (-69.9580, -55.1984),\n    (-71.0056, -55.0538),\n    (-72.2639, -54.4951),\n    (-73.2852, -53.9575),\n    (-74.6625, -52.8374),\n    (44.8469, 80.5898),\n    (46.7991, 80.7719),\n    (48.3184, 80.7840),\n    (48.5228, 80.5145),\n    (49.0971, 80.7539),\n    (50.0397, 80.9188),\n    (51.5229, 80.6997),\n    (51.1361, 80.5472),\n    (49.7936, 80.4154),\n    (48.8944, 80.3395),\n    (48.7549, 80.1754),\n    (47.5861, 80.0101),\n    (46.5028, 80.2472),\n    (47.0724, 80.5594),\n    (44.8469, 80.5898),\n    (53.5082, 73.7498),\n    (55.9024, 74.6274),\n    (55.6319, 75.0814),\n    (57.8686, 75.6093),\n    (61.1700, 76.2518),\n    (64.4983, 76.4390),\n    (66.2109, 76.8097),\n    (68.1570, 76.9396),\n    (68.8522, 76.5448),\n    (68.1805, 76.2336),\n    (64.6373, 75.7377),\n    (61.5835, 75.2608),\n    (58.4770, 74.3090),\n    (56.9867, 73.3330),\n    (55.4193, 72.3712),\n    (55.6228, 71.5405),\n    (57.5356, 70.7204),\n    (56.9449, 70.6327),\n    (53.6773, 70.7626),\n    (53.4120, 71.2066),\n    (51.6018, 71.4747),\n    (51.4557, 72.0148),\n    (52.4782, 72.2294),\n    (52.4441, 72.7747),\n    (54.4276, 73.6275),\n    (53.5082, 73.7498),\n    (27.4075, 80.0564),\n    (25.9246, 79.5178),\n    (23.0244, 79.4000),\n    (20.0751, 79.5668),\n    (19.8972, 79.8423),\n    (18.4622, 79.8598),\n    (17.3680, 80.3188),\n    (20.4559, 80.5981),\n    (21.9079, 80.3576),\n    (22.9192, 80.6571),\n    (25.4476, 80.4073),\n    (27.4075, 80.0564),\n    (24.7241, 77.8538),\n    (22.4903, 77.4449),\n    (20.7260, 77.6770),\n    (21.4160, 77.9350),\n    (20.8118, 78.2546),\n    (22.8842, 78.4549),\n    (23.2813, 78.0795),\n    (24.7241, 77.8538),\n    (15.1428, 79.6743),\n    (15.5225, 80.0160),\n    (16.9908, 80.0508),\n    (18.2518, 79.7017),\n    (21.5438, 78.9561),\n    (19.0273, 78.5625),\n    (18.4717, 77.8266),\n    (17.5944, 77.6379),\n    (17.1182, 76.8094),\n    (15.9131, 76.7704),\n    (13.7626, 77.3803),\n    (14.6695, 77.7356),\n    (13.1705, 78.0249),\n    (11.2222, 78.8692),\n    (10.4445, 79.6523),\n    (13.1707, 80.0104),\n    (13.7185, 79.6604),\n    (15.1428, 79.6743),\n    (-77.8815, 7.2237),\n    (-78.2149, 7.5122),\n    (-78.4291, 8.0520),\n    (-78.1820, 8.3191),\n    (-78.4354, 8.3877),\n    (-78.6221, 8.7181),\n    (-79.1203, 8.9960),\n    (-79.5578, 8.9323),\n    (-79.7605, 8.5845),\n    (-80.1644, 8.3333),\n    (-80.3826, 8.2984),\n    (-80.4806, 8.0903),\n    (-80.0036, 7.5475),\n    (-80.2766, 7.4197),\n    (-80.4211, 7.2715),\n    (-80.8864, 7.2205),\n    (-81.0595, 7.8179),\n    (-81.1897, 7.6479),\n    (-81.5195, 7.7066),\n    (-81.7213, 8.1089),\n    (-82.1314, 8.1753),\n    (-82.3909, 8.2923),\n    (-82.6054, 8.2916),\n    (-82.8200, 8.2908),\n    (-82.8509, 8.0738),\n    (-82.9657, 8.2250),\n    (-83.5084, 8.4469),\n    (-83.7114, 8.6568),\n    (-83.5963, 8.8304),\n    (-83.6326, 9.0513),\n    (-83.9098, 9.2908),\n    (-84.3034, 9.4873),\n    (-84.6476, 9.6155),\n    (-84.7133, 9.9080),\n    (-84.9756, 10.0867),\n    (-84.9113, 9.7959),\n    (-85.1109, 9.5570),\n    (-85.3394, 9.8345),\n    (-85.6607, 9.9333),\n    (-85.7974, 10.1348),\n    (-85.7917, 10.4393),\n    (-85.6593, 10.7543),\n    (-85.8005, 10.8247),\n    (-85.9417, 10.8952),\n    (-85.7125, 11.0884),\n    (-86.0584, 11.4034),\n    (-86.5258, 11.8068),\n    (-86.7459, 12.1439),\n    (-87.1675, 12.4582),\n    (-87.6684, 12.9099),\n    (-87.5574, 13.0645),\n    (-87.3923, 12.9140),\n    (-87.3166, 12.9846),\n    (-87.4894, 13.2975),\n    (-87.6412, 13.3410),\n    (-87.7931, 13.3844),\n    (-87.9041, 13.1490),\n    (-88.4833, 13.1639),\n    (-88.8432, 13.2597),\n    (-89.2567, 13.4585),\n    (-89.8123, 13.5206),\n    (-90.0955, 13.7353),\n    (-90.6086, 13.9097),\n    (-91.2324, 13.9278),\n    (-91.6897, 14.1262),\n    (-92.2277, 14.5388),\n    (-93.3594, 15.6154),\n    (-93.8751, 15.9401),\n    (-94.6916, 16.2009),\n    (-95.2502, 16.1283),\n    (-96.0533, 15.7520),\n    (-96.5574, 15.6535),\n    (-97.2635, 15.9170),\n    (-98.0130, 16.1073),\n    (-98.9476, 16.5660),\n    (-99.6973, 16.7061),\n    (-100.8294, 17.1710),\n    (-101.6660, 17.6490),\n    (-101.9185, 17.9160),\n    (-102.4781, 17.9757),\n    (-103.5009, 18.2922),\n    (-103.9175, 18.7485),\n    (-104.9920, 19.3161),\n    (-105.4930, 19.9467),\n    (-105.7313, 20.4341),\n    (-105.3977, 20.5317),\n    (-105.5006, 20.8168),\n    (-105.2707, 21.0762),\n    (-105.2658, 21.4221),\n    (-105.6031, 21.8711),\n    (-105.6934, 22.2690),\n    (-106.0287, 22.7737),\n    (-106.9099, 23.7678),\n    (-107.9154, 24.5489),\n    (-108.4019, 25.1723),\n    (-109.2601, 25.5806),\n    (-109.4440, 25.8248),\n    (-109.2916, 26.4429),\n    (-109.8014, 26.6761),\n    (-110.3917, 27.1621),\n    (-110.6410, 27.8598),\n    (-111.1789, 27.9412),\n    (-111.7596, 28.4679),\n    (-112.2282, 28.9544),\n    (-112.2718, 29.2668),\n    (-112.8095, 30.0211),\n    (-113.1638, 30.7868),\n    (-113.1486, 31.1709),\n    (-113.8718, 31.5676),\n    (-114.2057, 31.5240),\n    (-114.7764, 31.7995),\n    (-114.9366, 31.3934),\n    (-114.7712, 30.9136),\n    (-114.6738, 30.1626),\n    (-114.3309, 29.7504),\n    (-113.5888, 29.0616),\n    (-113.4240, 28.8261),\n    (-113.2719, 28.7547),\n    (-113.1400, 28.4112),\n    (-112.9622, 28.4251),\n    (-112.7615, 27.7802),\n    (-112.4579, 27.5258),\n    (-112.2449, 27.1717),\n    (-111.6164, 26.6628),\n    (-111.2846, 25.7325),\n    (-110.9878, 25.2946),\n    (-110.7100, 24.8260),\n    (-110.6550, 24.2985),\n    (-110.1728, 24.2655),\n    (-109.7718, 23.8111),\n    (-109.4091, 23.3646),\n    (-109.4333, 23.1855),\n    (-109.8542, 22.8182),\n    (-110.0313, 22.8230),\n    (-110.2950, 23.4309),\n    (-110.9495, 24.0009),\n    (-111.6705, 24.4844),\n    (-112.1820, 24.7384),\n    (-112.1489, 25.4701),\n    (-112.3007, 26.0120),\n    (-112.7772, 26.3219),\n    (-113.4646, 26.7681),\n    (-113.5967, 26.6394),\n    (-113.8489, 26.9000),\n    (-114.4657, 27.1420),\n    (-115.0551, 27.7227),\n    (-114.9822, 27.7982),\n    (-114.5703, 27.7414),\n    (-114.1993, 28.1150),\n    (-114.1620, 28.5661),\n    (-114.9318, 29.2794),\n    (-115.5186, 29.5563),\n    (-115.8873, 30.1807),\n    (-116.2583, 30.8364),\n    (-116.7215, 31.6357),\n    (-117.1277, 32.5353),\n    (-117.2959, 33.0462),\n    (-117.944, 33.6212),\n    (-118.4106, 33.7409),\n    (-118.5198, 34.0277),\n    (-119.081, 34.078),\n    (-119.4388, 34.3484),\n    (-120.3677, 34.4470),\n    (-120.6228, 34.6085),\n    (-120.7443, 35.1568),\n    (-121.7145, 36.1615),\n    (-122.5474, 37.5517),\n    (-122.5119, 37.7833),\n    (-122.9531, 38.1136),\n    (-123.7271, 38.9516),\n    (-123.8651, 39.7669),\n    (-124.3980, 40.3131),\n    (-124.1788, 41.1420),\n    (-124.2137, 41.9996),\n    (-124.5328, 42.7659),\n    (-124.1421, 43.7083),\n    (-124.0205, 44.6158),\n    (-123.8989, 45.5234),\n    (-124.0796, 46.8647),\n    (-124.3956, 47.7201),\n    (-124.6872, 48.1844),\n    (-124.5661, 48.3797),\n    (-123.12, 48.04),\n    (-122.5873, 47.0959),\n    (-122.3399, 47.3600),\n    (-122.5000, 48.1800),\n    (-122.84, 49.0),\n    (-122.9742, 49.0025),\n    (-124.9102, 49.9845),\n    (-125.6246, 50.4165),\n    (-127.4356, 50.8305),\n    (-127.9927, 51.7158),\n    (-127.8503, 52.3296),\n    (-129.1297, 52.7553),\n    (-129.3052, 53.5615),\n    (-130.5149, 54.2875),\n    (-130.5361, 54.8027),\n    (-131.0858, 55.1789),\n    (-131.9672, 55.4977),\n    (-132.2500, 56.3699),\n    (-133.5391, 57.1788),\n    (-134.0780, 58.1230),\n    (-135.0382, 58.1877),\n    (-136.6280, 58.2122),\n    (-137.8000, 58.4999),\n    (-139.8677, 59.5377),\n    (-140.8252, 59.7275),\n    (-142.5744, 60.0844),\n    (-143.9588, 59.9991),\n    (-145.9255, 60.4586),\n    (-147.1143, 60.8846),\n    (-148.2243, 60.6729),\n    (-148.0180, 59.9783),\n    (-148.5708, 59.9141),\n    (-149.7278, 59.7056),\n    (-150.6082, 59.3682),\n    (-151.7163, 59.1558),\n    (-151.8594, 59.7449),\n    (-151.4097, 60.7258),\n    (-150.3469, 61.0335),\n    (-150.6211, 61.2844),\n    (-151.8958, 60.7271),\n    (-152.5783, 60.0616),\n    (-154.0191, 59.3502),\n    (-153.2875, 58.8647),\n    (-154.2324, 58.1463),\n    (-155.3074, 57.7277),\n    (-156.3083, 57.4227),\n    (-156.5560, 56.9799),\n    (-158.1172, 56.4636),\n    (-158.4333, 55.9941),\n    (-159.6033, 55.5666),\n    (-160.2897, 55.6435),\n    (-161.2230, 55.3647),\n    (-162.2377, 55.0241),\n    (-163.0694, 54.6897),\n    (-164.7855, 54.4041),\n    (-164.9422, 54.5722),\n    (-163.8483, 55.0394),\n    (-162.8700, 55.3480),\n    (-161.8041, 55.8949),\n    (-160.5636, 56.0080),\n    (-160.0705, 56.4180),\n    (-158.6844, 57.0166),\n    (-158.4610, 57.2169),\n    (-157.7227, 57.5700),\n    (-157.5502, 58.3283),\n    (-157.0416, 58.9188),\n    (-158.1947, 58.6158),\n    (-158.5172, 58.7877),\n    (-159.0586, 58.4241),\n    (-159.7116, 58.9313),\n    (-159.9812, 58.5725),\n    (-160.3552, 59.0711),\n    (-161.3550, 58.6708),\n    (-161.9688, 58.6716),\n    (-162.0549, 59.2669),\n    (-161.8741, 59.6336),\n    (-162.5180, 59.9897),\n    (-163.8183, 59.7980),\n    (-164.6622, 60.2674),\n    (-165.3463, 60.5074),\n    (-165.3508, 61.0738),\n    (-166.1213, 61.5000),\n    (-165.7344, 62.0749),\n    (-164.9191, 62.6330),\n    (-164.5625, 63.1463),\n    (-163.7533, 63.2194),\n    (-163.0672, 63.0594),\n    (-162.2605, 63.5419),\n    (-161.5344, 63.4558),\n    (-160.7725, 63.7661),\n    (-160.9583, 64.2227),\n    (-161.5180, 64.4027),\n    (-160.7777, 64.7886),\n    (-161.3919, 64.7772),\n    (-162.4530, 64.5594),\n    (-162.7577, 64.3386),\n    (-163.5463, 64.5591),\n    (-164.9608, 64.4469),\n    (-166.4252, 64.6866),\n    (-166.8450, 65.0888),\n    (-168.1105, 65.6699),\n    (-166.7052, 66.0883),\n    (-164.4747, 66.5766),\n    (-163.6525, 66.5766),\n    (-163.7886, 66.0772),\n    (-161.6777, 66.1161),\n    (-162.4897, 66.7355),\n    (-163.7197, 67.1163),\n    (-164.4309, 67.6163),\n    (-165.3902, 68.0427),\n    (-166.7644, 68.3588),\n    (-166.2047, 68.8830),\n    (-164.4308, 68.9155),\n    (-163.1686, 69.3711),\n    (-162.9305, 69.8580),\n    (-161.9088, 70.3333),\n    (-160.9347, 70.4476),\n    (-159.0391, 70.8916),\n    (-158.1197, 70.8247),\n    (-156.5808, 71.3577),\n    (-155.0677, 71.1477),\n    (-154.3441, 70.6964),\n    (-153.9000, 70.8899),\n    (-152.2100, 70.8299),\n    (-152.2700, 70.6000),\n    (-150.7399, 70.4300),\n    (-149.7200, 70.5300),\n    (-147.6133, 70.2140),\n    (-145.6899, 70.1200),\n    (-144.9200, 69.9899),\n    (-143.5894, 70.1525),\n    (-142.0725, 69.8519),\n    (-140.9859, 69.7119),\n    (-139.1205, 69.4710),\n    (-137.5463, 68.9900),\n    (-136.5035, 68.8980),\n    (-135.6257, 69.3151),\n    (-134.4146, 69.6274),\n    (-132.9292, 69.5053),\n    (-131.4313, 69.9445),\n    (-129.7947, 70.1937),\n    (-129.1077, 69.7792),\n    (-128.3615, 70.0128),\n    (-128.1381, 70.4838),\n    (-127.4471, 70.3772),\n    (-125.7563, 69.4805),\n    (-124.4248, 70.1584),\n    (-124.2896, 69.3996),\n    (-123.0610, 69.5637),\n    (-122.6834, 69.8555),\n    (-121.4722, 69.7977),\n    (-119.9428, 69.3778),\n    (-117.6026, 69.0112),\n    (-116.2264, 68.8414),\n    (-115.2468, 68.9059),\n    (-113.8979, 68.3989),\n    (-115.3048, 67.9026),\n    (-113.4972, 67.6881),\n    (-110.7980, 67.8060),\n    (-109.9461, 67.9810),\n    (-108.8801, 67.3814),\n    (-107.7923, 67.8873),\n    (-108.8129, 68.3116),\n    (-108.1672, 68.6539),\n    (-106.9500, 68.6999),\n    (-106.1500, 68.7999),\n    (-105.3428, 68.5612),\n    (-104.3379, 68.0180),\n    (-103.2211, 68.0977),\n    (-101.4543, 67.6468),\n    (-99.9019, 67.8056),\n    (-98.4432, 67.7816),\n    (-98.5586, 68.4039),\n    (-97.6694, 68.5786),\n    (-96.1199, 68.2394),\n    (-96.1258, 67.2933),\n    (-95.4894, 68.0907),\n    (-94.6849, 68.0638),\n    (-94.2328, 69.0690),\n    (-95.3040, 69.6857),\n    (-96.4713, 70.0897),\n    (-96.3911, 71.1948),\n    (-95.2088, 71.9205),\n    (-93.8899, 71.7601),\n    (-92.8781, 71.3186),\n    (-91.5196, 70.1912),\n    (-92.4069, 69.6999),\n    (-90.5471, 69.4976),\n    (-90.5514, 68.4749),\n    (-89.2151, 69.2587),\n    (-88.0196, 68.6150),\n    (-88.3174, 67.8733),\n    (-87.3501, 67.1987),\n    (-86.3060, 67.9214),\n    (-85.5766, 68.7845),\n    (-85.5219, 69.8820),\n    (-84.1008, 69.8054),\n    (-82.6225, 69.6582),\n    (-81.2804, 69.1620),\n    (-81.2202, 68.6656),\n    (-81.9643, 68.1325),\n    (-81.2592, 67.5971),\n    (-81.3865, 67.1107),\n    (-83.3445, 66.4115),\n    (-84.7354, 66.2572),\n    (-85.7694, 66.5583),\n    (-86.0676, 66.0562),\n    (-87.0314, 65.2129),\n    (-87.3232, 64.7756),\n    (-88.4829, 64.0989),\n    (-89.9144, 64.0327),\n    (-90.7039, 63.6101),\n    (-90.7700, 62.9602),\n    (-91.9334, 62.8350),\n    (-93.1569, 62.0246),\n    (-94.2415, 60.8986),\n    (-94.6293, 60.1102),\n    (-94.6846, 58.9488),\n    (-93.2150, 58.7821),\n    (-92.7646, 57.8457),\n    (-92.2970, 57.0870),\n    (-90.8976, 57.2846),\n    (-89.0395, 56.8517),\n    (-88.0397, 56.4716),\n    (-87.3241, 55.9991),\n    (-86.0712, 55.7238),\n    (-85.0118, 55.3026),\n    (-83.3605, 55.2448),\n    (-82.2728, 55.1483),\n    (-82.4362, 54.2822),\n    (-82.1250, 53.2770),\n    (-81.4007, 52.1578),\n    (-79.9128, 51.2083),\n    (-79.1430, 51.5339),\n    (-78.6019, 52.5620),\n    (-79.1242, 54.1414),\n    (-79.8295, 54.6677),\n    (-78.2287, 55.1364),\n    (-77.0955, 55.8374),\n    (-76.5413, 56.5342),\n    (-76.6231, 57.2026),\n    (-77.3022, 58.0520),\n    (-78.5168, 58.8045),\n    (-77.3367, 59.8526),\n    (-77.7727, 60.7578),\n    (-78.1068, 62.3196),\n    (-77.4106, 62.5505),\n    (-75.6962, 62.2783),\n    (-74.6682, 62.1811),\n    (-73.8398, 62.4437),\n    (-72.9085, 62.1050),\n    (-71.6770, 61.5253),\n    (-71.3736, 61.1371),\n    (-69.5904, 61.0614),\n    (-69.6203, 60.2212),\n    (-69.2878, 58.9573),\n    (-68.3745, 58.8010),\n    (-67.6497, 58.2120),\n    (-66.2017, 58.7673),\n    (-65.2451, 59.8707),\n    (-64.5835, 60.3355),\n    (-63.8047, 59.4425),\n    (-62.5023, 58.1670),\n    (-61.3965, 56.9674),\n    (-61.7986, 56.3394),\n    (-60.4685, 55.7754),\n    (-59.5696, 55.2040),\n    (-57.9750, 54.9454),\n    (-57.3332, 54.6264),\n    (-56.9368, 53.7803),\n    (-56.1581, 53.6474),\n    (-55.7563, 53.2703),\n    (-55.6833, 52.1466),\n    (-56.4091, 51.7706),\n    (-57.1269, 51.4197),\n    (-58.7748, 51.0642),\n    (-60.0331, 50.2427),\n    (-61.7236, 50.0804),\n    (-63.8625, 50.2909),\n    (-65.3633, 50.2981),\n    (-66.3990, 50.2289),\n    (-67.2363, 49.5115),\n    (-68.5111, 49.0683),\n    (-69.9536, 47.7448),\n    (-71.1045, 46.8217),\n    (-70.2552, 46.9860),\n    (-68.6499, 48.2999),\n    (-66.5524, 49.1330),\n    (-65.0562, 49.2327),\n    (-64.1709, 48.7425),\n    (-65.1154, 48.0708),\n    (-64.7985, 46.9929),\n    (-64.4721, 46.2384),\n    (-63.1732, 45.7390),\n    (-61.5207, 45.8837),\n    (-60.5181, 47.0079),\n    (-60.4486, 46.2826),\n    (-59.8028, 45.9204),\n    (-61.0398, 45.2652),\n    (-63.2547, 44.6701),\n    (-64.2465, 44.2655),\n    (-65.3640, 43.5452),\n    (-66.1234, 43.6186),\n    (-66.1617, 44.4651),\n    (-64.4254, 45.2920),\n    (-66.0260, 45.2593),\n    (-67.1374, 45.1375),\n    (-66.9646, 44.8097),\n    (-68.0325, 44.3252),\n    (-69.06, 43.98),\n    (-70.1161, 43.6840),\n    (-70.6454, 43.0902),\n    (-70.8148, 42.8652),\n    (-70.8249, 42.3349),\n    (-70.4949, 41.8049),\n    (-70.0800, 41.7800),\n    (-70.1849, 42.1449),\n    (-69.8849, 41.9228),\n    (-69.9650, 41.6371),\n    (-70.6399, 41.4749),\n    (-71.1203, 41.4944),\n    (-71.8538, 41.3199),\n    (-72.2949, 41.2699),\n    (-72.8764, 41.2206),\n    (-73.71, 40.9311),\n    (-72.2412, 41.1194),\n    (-71.9450, 40.9300),\n    (-73.3450, 40.6300),\n    (-73.9819, 40.6280),\n    (-73.9523, 40.7507),\n    (-74.2567, 40.4734),\n    (-73.9624, 40.4276),\n    (-74.1783, 39.7092),\n    (-74.9060, 38.9395),\n    (-74.9804, 39.1963),\n    (-75.2000, 39.2484),\n    (-75.5280, 39.4984),\n    (-75.3199, 38.9599),\n    (-75.0718, 38.7820),\n    (-75.0567, 38.4041),\n    (-75.3774, 38.0155),\n    (-75.9402, 37.2169),\n    (-76.0312, 37.2565),\n    (-75.7220, 37.9370),\n    (-76.2328, 38.3192),\n    (-76.35, 39.15),\n    (-76.5427, 38.7176),\n    (-76.3293, 38.0832),\n    (-76.9899, 38.2399),\n    (-76.3016, 37.9179),\n    (-76.2587, 36.9664),\n    (-75.9718, 36.8972),\n    (-75.8680, 36.5512),\n    (-75.7274, 35.5507),\n    (-76.3631, 34.8085),\n    (-77.3976, 34.5120),\n    (-78.0549, 33.9254),\n    (-78.5543, 33.8613),\n    (-79.0606, 33.4939),\n    (-79.2035, 33.1583),\n    (-80.3013, 32.5093),\n    (-80.8649, 32.0333),\n    (-81.3362, 31.4404),\n    (-81.4904, 30.7299),\n    (-81.3137, 30.0355),\n    (-80.9799, 29.1800),\n    (-80.5355, 28.4721),\n    (-80.5299, 28.0399),\n    (-80.0565, 26.88),\n    (-80.0880, 26.2057),\n    (-80.1315, 25.8167),\n    (-80.3810, 25.2061),\n    (-80.6800, 25.0799),\n    (-81.1721, 25.2012),\n    (-81.3299, 25.6399),\n    (-81.7099, 25.8699),\n    (-82.2400, 26.7299),\n    (-82.7051, 27.4950),\n    (-82.8552, 27.8862),\n    (-82.6500, 28.5499),\n    (-82.93, 29.1),\n    (-83.7095, 29.9365),\n    (-84.1, 30.09),\n    (-85.1088, 29.6361),\n    (-85.2878, 29.6861),\n    (-85.7731, 30.1526),\n    (-86.3999, 30.4000),\n    (-87.5303, 30.2743),\n    (-88.4178, 30.3849),\n    (-89.1804, 30.3159),\n    (-89.5938, 30.1599),\n    (-89.4137, 29.8941),\n    (-89.43, 29.48864),\n    (-89.2176, 29.2910),\n    (-89.4082, 29.1596),\n    (-89.7792, 29.3071),\n    (-90.1546, 29.1174),\n    (-90.8802, 29.1485),\n    (-91.6267, 29.677),\n    (-92.4990, 29.5523),\n    (-93.2263, 29.7837),\n    (-93.8484, 29.7136),\n    (-94.6900, 29.4800),\n    (-95.6002, 28.7386),\n    (-96.5940, 28.3074),\n    (-97.1400, 27.8300),\n    (-97.3699, 27.3800),\n    (-97.3799, 26.6899),\n    (-97.3299, 26.2100),\n    (-97.1400, 25.8699),\n    (-97.5280, 24.9921),\n    (-97.7029, 24.2723),\n    (-97.7760, 22.9325),\n    (-97.8723, 22.4442),\n    (-97.6990, 21.8986),\n    (-97.3889, 21.4110),\n    (-97.1893, 20.6354),\n    (-96.5255, 19.8909),\n    (-96.2921, 19.3203),\n    (-95.9008, 18.8280),\n    (-94.8390, 18.5627),\n    (-94.4257, 18.1443),\n    (-93.5486, 18.4238),\n    (-92.7861, 18.5248),\n    (-92.0373, 18.7045),\n    (-91.4079, 18.8760),\n    (-90.7718, 19.2841),\n    (-90.5335, 19.8674),\n    (-90.4514, 20.7075),\n    (-90.2786, 20.9998),\n    (-89.6013, 21.2617),\n    (-88.5438, 21.4936),\n    (-87.6584, 21.4588),\n    (-87.0518, 21.5435),\n    (-86.8119, 21.3315),\n    (-86.8459, 20.8498),\n    (-87.3832, 20.2554),\n    (-87.6210, 19.6465),\n    (-87.4367, 19.4724),\n    (-87.5865, 19.0401),\n    (-87.8371, 18.2598),\n    (-88.0906, 18.5166),\n    (-88.3000, 18.4999),\n    (-88.2963, 18.3532),\n    (-88.1068, 18.3486),\n    (-88.1234, 18.0766),\n    (-88.2853, 17.6441),\n    (-88.1978, 17.4894),\n    (-88.3026, 17.1316),\n    (-88.2395, 17.0360),\n    (-88.3554, 16.5307),\n    (-88.5518, 16.2654),\n    (-88.7324, 16.2336),\n    (-88.9306, 15.8872),\n    (-88.6045, 15.7063),\n    (-88.5183, 15.8553),\n    (-88.1899, 15.7199),\n    (-88.1211, 15.6886),\n    (-87.9018, 15.8644),\n    (-87.6156, 15.8787),\n    (-87.5229, 15.7972),\n    (-87.3677, 15.8469),\n    (-86.9031, 15.7567),\n    (-86.4409, 15.7828),\n    (-86.1192, 15.8934),\n    (-86.0019, 16.0054),\n    (-85.6833, 15.9536),\n    (-85.4440, 15.8857),\n    (-85.1824, 15.9091),\n    (-84.9837, 15.9959),\n    (-84.5269, 15.8572),\n    (-84.3682, 15.8351),\n    (-84.0630, 15.6482),\n    (-83.7739, 15.4240),\n    (-83.4103, 15.2709),\n    (-83.1472, 14.9958),\n    (-83.2332, 14.8998),\n    (-83.2841, 14.6766),\n    (-83.1821, 14.3107),\n    (-83.4124, 13.9700),\n    (-83.5198, 13.5676),\n    (-83.5522, 13.1270),\n    (-83.4985, 12.8692),\n    (-83.4733, 12.4190),\n    (-83.6261, 12.3208),\n    (-83.7196, 11.8931),\n    (-83.6508, 11.6290),\n    (-83.8554, 11.3733),\n    (-83.8089, 11.1030),\n    (-83.6556, 10.9387),\n    (-83.5900, 10.7850),\n    (-83.4023, 10.3954),\n    (-83.0156, 9.9929),\n    (-82.5461, 9.5661),\n    (-82.1871, 9.2074),\n    (-82.2075, 8.9955),\n    (-81.8085, 8.9506),\n    (-81.7141, 9.0319),\n    (-81.4392, 8.7862),\n    (-80.9473, 8.8585),\n    (-80.5219, 9.1110),\n    (-79.9145, 9.3127),\n    (-79.5733, 9.6116),\n    (-79.0211, 9.5529),\n    (-79.0584, 9.4545),\n    (-78.5008, 9.4204),\n    (-78.0559, 9.2477),\n    (-77.7295, 8.9468),\n    (-77.3533, 8.6705),\n    (-71.7123, 19.7144),\n    (-71.5873, 19.8849),\n    (-71.3800, 19.9049),\n    (-70.8067, 19.8802),\n    (-70.2143, 19.6228),\n    (-69.9508, 19.6479),\n    (-69.7692, 19.2932),\n    (-69.2221, 19.3132),\n    (-69.2543, 19.0151),\n    (-68.8094, 18.9791),\n    (-68.3179, 18.6121),\n    (-68.6893, 18.2051),\n    (-69.1649, 18.4226),\n    (-69.6239, 18.3807),\n    (-69.9529, 18.4283),\n    (-70.1332, 18.2459),\n    (-70.5171, 18.1842),\n    (-70.6692, 18.4268),\n    (-70.9999, 18.2833),\n    (-71.4002, 17.5985),\n    (-71.6576, 17.7575),\n    (-71.7083, 18.0449),\n    (-72.3724, 18.2149),\n    (-72.8444, 18.1456),\n    (-73.4545, 18.2179),\n    (-73.9224, 18.0309),\n    (-74.4580, 18.3425),\n    (-74.3699, 18.6649),\n    (-73.4495, 18.5260),\n    (-72.6949, 18.4457),\n    (-72.3348, 18.6684),\n    (-72.7916, 19.1016),\n    (-72.7841, 19.4835),\n    (-73.4150, 19.6395),\n    (-73.1897, 19.9156),\n    (-72.5796, 19.8715),\n    (-71.7123, 19.7144),\n    (14.7612, 38.1438),\n    (15.5203, 38.2311),\n    (15.1602, 37.4440),\n    (15.3098, 37.1342),\n    (15.0999, 36.6199),\n    (14.3352, 36.9966),\n    (13.8267, 37.1045),\n    (12.4310, 37.6129),\n    (12.5709, 38.1263),\n    (13.7411, 38.0349),\n    (14.7612, 38.1438),\n    (37.5391, 44.6572),\n    (38.6799, 44.2799),\n    (39.9550, 43.4349),\n    (132.3711, 33.4636),\n    (132.9243, 34.0602),\n    (133.4929, 33.9446),\n    (133.9041, 34.3649),\n    (134.6384, 34.1492),\n    (134.7663, 33.8063),\n    (134.2034, 33.2011),\n    (133.7929, 33.5219),\n    (133.2802, 33.2895),\n    (133.0148, 32.7045),\n    (132.3631, 32.9893),\n    (132.3711, 33.4636),\n    (180.0000, 68.9636),\n    (178.5999, 69.4000),\n    (175.7240, 69.8772),\n    (173.6439, 69.8174),\n    (170.4534, 70.0970),\n    (170.0082, 69.6527),\n    (170.8168, 69.0136),\n    (169.5776, 68.6938),\n    (167.8629, 69.5687),\n    (165.9403, 69.4719),\n    (164.0524, 69.6682),\n    (162.2790, 69.6420),\n    (160.9405, 69.4372),\n    (159.7086, 69.7219),\n    (159.8303, 70.4532),\n    (158.9977, 70.8667),\n    (157.0068, 71.0314),\n    (152.9688, 70.8422),\n    (150.3511, 71.6064),\n    (149.5000, 72.1999),\n    (140.4681, 72.8494),\n    (139.1479, 72.4161),\n    (139.8698, 71.4878),\n    (138.2340, 71.6280),\n    (137.4975, 71.3476),\n    (135.5619, 71.6552),\n    (133.8576, 71.3864),\n    (132.2535, 71.8363),\n    (131.2885, 70.7869),\n    (129.7159, 71.1930),\n    (128.46, 71.98),\n    (129.0515, 72.3987),\n    (128.5912, 73.0387),\n    (126.9764, 73.5654),\n    (125.38, 73.56),\n    (123.2577, 73.7350),\n    (123.2006, 72.9712),\n    (119.02, 73.12),\n    (118.7763, 73.5877),\n    (115.5678, 73.7528),\n    (113.9688, 73.5948),\n    (113.5295, 73.3350),\n    (113.0195, 73.9769),\n    (112.1191, 73.7877),\n    (110.64, 74.04),\n    (109.4, 74.18),\n    (110.1512, 74.4767),\n    (112.7791, 75.0318),\n    (113.8853, 75.3277),\n    (114.1341, 75.8476),\n    (113.3315, 76.2222),\n    (111.07726, 76.71),\n    (108.1537, 76.7233),\n    (107.2399, 76.4799),\n    (106.9701, 76.9741),\n    (104.7050, 77.1273),\n    (106.0666, 77.3738),\n    (104.3515, 77.6979),\n    (101.9908, 77.2875),\n    (101.0353, 76.8618),\n    (100.7596, 76.4302),\n    (98.9225, 76.4468),\n    (96.6782, 75.9154),\n    (95.8600, 76.1400),\n    (93.2342, 76.0471),\n    (92.9006, 75.7733),\n    (90.2599, 75.6399),\n    (88.3156, 75.1439),\n    (87.1668, 75.1164),\n    (86.0095, 74.4596),\n    (86.8223, 73.9368),\n    (84.6552, 73.8059),\n    (82.2499, 73.8500),\n    (80.5110, 73.6482),\n    (80.6107, 72.5828),\n    (81.5000, 71.7499),\n    (79.6520, 72.3201),\n    (77.5766, 72.2671),\n    (75.9031, 71.8740),\n    (76.3591, 71.1528),\n    (75.2889, 71.3355),\n    (75.6835, 72.3005),\n    (75.1580, 72.8549),\n    (74.6592, 72.8322),\n    (74.8908, 72.1211),\n    (73.1011, 71.4471),\n    (74.3998, 70.6317),\n    (73.6018, 69.6276),\n    (73.8423, 69.0714),\n    (74.9358, 68.9891),\n    (74.4692, 68.3289),\n    (75.052, 67.76047),\n    (74.1865, 67.2842),\n    (73.9209, 66.7894),\n    (72.8207, 66.5326),\n    (72.4230, 66.1726),\n    (71.28, 66.32),\n    (73.2387, 67.7404),\n    (73.6678, 68.4079),\n    (72.5646, 69.0208),\n    (72.7918, 70.3911),\n    (72.4701, 71.0901),\n    (71.8481, 71.4089),\n    (72.7960, 72.2200),\n    (72.5875, 72.7762),\n    (69.94, 73.04),\n    (69.1963, 72.8433),\n    (68.5400, 71.9345),\n    (66.6946, 71.0289),\n    (66.7249, 70.7088),\n    (67.2597, 69.9287),\n    (66.9300, 69.4546),\n    (68.1352, 69.3564),\n    (68.1644, 69.1443),\n    (69.1806, 68.6156),\n    (68.5121, 68.0923),\n    (64.8881, 69.2348),\n    (63.5040, 69.5473),\n    (60.5500, 69.8500),\n    (60.03, 69.52),\n    (61.0778, 68.9406),\n    (59.9414, 68.2784),\n    (58.802, 68.88082),\n    (57.3170, 68.4662),\n    (55.4426, 68.4386),\n    (54.7530, 68.0868),\n    (53.4858, 68.2013),\n    (54.4717, 68.8081),\n    (53.7174, 68.8573),\n    (48.1387, 67.5223),\n    (47.8941, 66.8845),\n    (46.3491, 66.6676),\n    (45.5620, 67.0100),\n    (45.5551, 67.5665),\n    (46.8213, 67.6899),\n    (46.2500, 68.2499),\n    (43.4528, 68.5708),\n    (44.1747, 67.9616),\n    (43.6983, 67.3524),\n    (44.5322, 66.7563),\n    (43.9497, 66.0690),\n    (43.0160, 66.4185),\n    (42.0930, 66.4762),\n    (39.7626, 65.4968),\n    (40.4356, 64.7644),\n    (39.5934, 64.5207),\n    (37.1760, 65.1432),\n    (36.5395, 64.7644),\n    (37.1419, 64.3347),\n    (37.0127, 63.8498),\n    (36.2312, 64.1094),\n    (34.9439, 64.4143),\n    (34.8785, 65.4362),\n    (34.8147, 65.9001),\n    (33.1844, 66.6325),\n    (33.9186, 66.7595),\n    (38.3829, 65.9995),\n    (40.0158, 66.2661),\n    (41.1259, 66.7915),\n    (41.0598, 67.4571),\n    (40.2923, 67.9323),\n    (36.5139, 69.0634),\n    (33.7754, 69.3014),\n    (32.1327, 69.9059),\n    (31.1010, 69.5580),\n    (30.0054, 70.1862),\n    (31.2934, 70.4537),\n    (28.1655, 71.1854),\n    (26.3700, 70.9862),\n    (24.5465, 71.0304),\n    (23.0237, 70.2020),\n    (21.3784, 70.2551),\n    (19.1840, 69.8174),\n    (16.4359, 68.5632),\n    (14.7611, 67.8106),\n    (12.3583, 65.8797),\n    (10.5277, 64.4860),\n    (8.5534, 63.4540),\n    (5.9129, 62.6144),\n    (4.9920, 61.9709),\n    (5.3082, 59.6632),\n    (5.6658, 58.5881),\n    (7.0487, 58.0788),\n    (8.3820, 58.3132),\n    (10.3565, 59.4698),\n    (11.0273, 58.8561),\n    (11.7879, 57.4418),\n    (12.6251, 56.3070),\n    (12.9429, 55.3617),\n    (14.1007, 55.4077),\n    (14.6666, 56.2008),\n    (15.8797, 56.1043),\n    (16.4477, 57.0411),\n    (16.8291, 58.7198),\n    (17.8692, 58.9537),\n    (18.7877, 60.0819),\n    (17.8313, 60.6365),\n    (17.1195, 61.3411),\n    (17.8477, 62.7494),\n    (19.7788, 63.6095),\n    (21.3696, 64.4135),\n    (21.2135, 65.0260),\n    (22.1831, 65.7237),\n    (23.9033, 66.0069),\n    (25.2940, 65.5343),\n    (25.3980, 65.1114),\n    (24.7305, 64.9023),\n    (22.4427, 63.8178),\n    (21.5360, 63.1897),\n    (21.0592, 62.6073),\n    (21.5448, 61.7053),\n    (21.3222, 60.7201),\n    (22.2907, 60.3919),\n    (22.8696, 59.8463),\n    (24.4966, 60.0573),\n    (26.2551, 60.4239),\n    (28.0699, 60.5035),\n    (29.1176, 60.0280),\n    (27.9811, 59.4753),\n    (26.9491, 59.4458),\n    (25.8641, 59.6110),\n    (24.6042, 59.4658),\n    (23.3397, 59.1872),\n    (23.4265, 58.6127),\n    (24.0611, 58.2573),\n    (24.4289, 58.3834),\n    (24.3128, 57.7934),\n    (24.1207, 57.0256),\n    (23.3184, 57.0062),\n    (22.5243, 57.7533),\n    (21.5818, 57.4118),\n    (21.0904, 56.7838),\n    (21.0558, 56.0310),\n    (21.2684, 55.1904),\n    (19.8884, 54.8661),\n    (19.6606, 54.4260),\n    (18.6962, 54.4387),\n    (18.6208, 54.6826),\n    (17.6228, 54.8515),\n    (16.3634, 54.5131),\n    (14.8029, 54.0507),\n    (14.1196, 53.7570),\n    (13.6474, 54.0755),\n    (12.5184, 54.4703),\n    (11.9562, 54.1964),\n    (10.9394, 54.0086),\n    (10.9501, 54.3636),\n    (9.9395, 54.5966),\n    (9.9219, 54.9831),\n    (9.6499, 55.4699),\n    (10.3699, 56.1900),\n    (10.6678, 56.0813),\n    (10.9121, 56.4586),\n    (10.3699, 56.6099),\n    (10.2500, 56.8900),\n    (10.5461, 57.2157),\n    (10.5800, 57.7300),\n    (9.7755, 57.4479),\n    (9.4244, 57.1720),\n    (8.5434, 57.1100),\n    (8.2565, 56.8099),\n    (8.0899, 56.5400),\n    (8.1203, 55.5177),\n    (8.5262, 54.9627),\n    (8.5721, 54.3956),\n    (8.8007, 54.0207),\n    (8.1217, 53.5277),\n    (7.9362, 53.7482),\n    (7.1004, 53.6939),\n    (6.9051, 53.4821),\n    (6.0741, 53.5104),\n    (4.7059, 53.0917),\n    (3.8302, 51.6205),\n    (3.3149, 51.3457),\n    (2.5135, 51.1485),\n    (1.6390, 50.9466),\n    (1.3387, 50.1271),\n    (-0.9894, 49.3473),\n    (-1.9334, 49.7763),\n    (-1.6165, 48.6444),\n    (-3.2958, 48.9016),\n    (-4.5923, 48.6841),\n    (-4.4915, 47.9549),\n    (-2.9632, 47.5703),\n    (-2.2257, 47.0643),\n    (-1.1937, 46.0149),\n    (-1.3842, 44.0226),\n    (-1.9013, 43.4228),\n    (-3.5175, 43.4559),\n    (-4.3478, 43.4034),\n    (-5.4118, 43.5742),\n    (-6.7544, 43.5679),\n    (-7.9781, 43.7483),\n    (-9.3928, 43.0266),\n    (-8.9844, 42.5927),\n    (-9.0348, 41.8805),\n    (-8.9907, 41.5434),\n    (-8.7908, 41.1843),\n    (-8.7686, 40.7606),\n    (-8.9773, 40.1593),\n    (-9.0483, 39.7550),\n    (-9.4469, 39.3920),\n    (-9.5265, 38.7374),\n    (-9.2874, 38.3584),\n    (-8.8399, 38.2662),\n    (-8.7461, 37.6513),\n    (-8.8988, 36.8688),\n    (-8.3828, 36.9788),\n    (-7.8556, 36.8382),\n    (-7.4537, 37.0977),\n    (-6.5201, 36.9429),\n    (-6.2366, 36.3676),\n    (-5.8664, 36.0298),\n    (-5.3771, 35.9468),\n    (-4.9952, 36.3247),\n    (-4.3689, 36.6778),\n    (-3.4157, 36.6588),\n    (-2.1464, 36.6741),\n    (-1.4383, 37.4430),\n    (-0.6833, 37.6423),\n    (-0.4671, 38.2923),\n    (0.1112, 38.7385),\n    (-0.2787, 39.3099),\n    (0.1066, 40.1239),\n    (0.7213, 40.6783),\n    (0.8105, 41.0147),\n    (2.0918, 41.2260),\n    (3.0394, 41.8921),\n    (2.9859, 42.4730),\n    (3.1004, 43.0752),\n    (4.5569, 43.3996),\n    (6.5292, 43.1288),\n    (7.4351, 43.6938),\n    (7.8507, 43.7671),\n    (8.4285, 44.2312),\n    (8.8889, 44.3663),\n    (9.7024, 44.0362),\n    (10.2000, 43.9200),\n    (10.5119, 42.9314),\n    (11.1919, 42.3554),\n    (12.1066, 41.7045),\n    (12.8880, 41.2530),\n    (13.6279, 41.1882),\n    (14.0606, 40.7863),\n    (14.7032, 40.6045),\n    (14.9984, 40.1729),\n    (15.4136, 40.0483),\n    (15.7188, 39.5440),\n    (16.1093, 38.9645),\n    (15.8919, 38.7509),\n    (15.6879, 38.2145),\n    (15.6840, 37.9088),\n    (16.1009, 37.9858),\n    (16.6350, 38.8435),\n    (17.0528, 38.9028),\n    (17.1714, 39.4246),\n    (16.4487, 39.7954),\n    (16.8695, 40.4422),\n    (17.7383, 40.2776),\n    (18.2933, 39.8107),\n    (18.4802, 40.1688),\n    (18.3766, 40.3556),\n    (17.5191, 40.8771),\n    (16.7850, 41.1796),\n    (15.8893, 41.5410),\n    (16.1698, 41.7402),\n    (15.9261, 41.9613),\n    (15.1425, 41.9551),\n    (14.0298, 42.7610),\n    (13.5269, 43.5877),\n    (12.5892, 44.0913),\n    (12.2614, 44.6004),\n    (12.3838, 44.8853),\n    (12.3285, 45.3817),\n    (13.1416, 45.7366),\n    (13.9376, 45.5910),\n    (13.7150, 45.5003),\n    (13.6794, 45.4841),\n    (13.6569, 45.1369),\n    (13.9522, 44.8021),\n    (14.2587, 45.2337),\n    (14.9016, 45.0760),\n    (14.9203, 44.7384),\n    (15.3762, 44.3179),\n    (15.1744, 44.2431),\n    (16.0153, 43.5072),\n    (16.9300, 43.2099),\n    (17.5099, 42.8499),\n    (18.4500, 42.4799),\n    (18.8821, 42.2815),\n    (19.1624, 41.9550),\n    (19.3717, 41.8775),\n    (19.5400, 41.7199),\n    (19.4035, 41.4095),\n    (19.3190, 40.7272),\n    (19.4060, 40.2507),\n    (19.9600, 39.9150),\n    (19.9800, 39.6949),\n    (20.1500, 39.6249),\n    (20.2177, 39.3402),\n    (20.7300, 38.7699),\n    (21.1200, 38.3103),\n    (21.2950, 37.6449),\n    (21.6700, 36.8449),\n    (22.4900, 36.4100),\n    (23.1542, 36.4225),\n    (22.7749, 37.3050),\n    (23.4099, 37.4099),\n    (23.1150, 37.9200),\n    (24.0400, 37.6550),\n    (24.0250, 38.2199),\n    (23.5300, 38.5100),\n    (22.9730, 38.9709),\n    (23.3500, 39.1900),\n    (22.8497, 39.6593),\n    (22.6262, 40.2565),\n    (22.8139, 40.4760),\n    (23.3429, 39.9609),\n    (23.8999, 39.9620),\n    (24.4079, 40.1249),\n    (23.7148, 40.6871),\n    (24.9258, 40.9470),\n    (25.4476, 40.8525),\n    (26.0569, 40.8241),\n    (26.0433, 40.6177),\n    (26.3580, 40.1519),\n    (27.1923, 40.6905),\n    (27.6190, 40.9998),\n    (28.8064, 41.0549),\n    (28.9884, 41.2999),\n    (28.1155, 41.6228),\n    (27.9967, 42.0073),\n    (27.6738, 42.5778),\n    (28.0390, 43.2931),\n    (28.5580, 43.7074),\n    (28.8378, 44.9138),\n    (29.1416, 44.8202),\n    (29.6265, 45.0353),\n    (29.6032, 45.2933),\n    (30.3776, 46.0324),\n    (30.7487, 46.5831),\n    (31.6753, 46.7062),\n    (31.7441, 46.3333),\n    (33.2985, 46.0805),\n    (33.5881, 45.8515),\n    (32.6308, 45.5191),\n    (32.4541, 45.3274),\n    (33.5469, 45.0347),\n    (33.3264, 44.5648),\n    (33.8825, 44.3614),\n    (35.2399, 44.9399),\n    (36.3347, 45.1132),\n    (36.5299, 45.4699),\n    (35.5100, 45.4099),\n    (35.0207, 45.6512),\n    (34.9623, 46.2731),\n    (35.8236, 46.6459),\n    (36.7598, 46.6987),\n    (37.4251, 47.0222),\n    (38.2235, 47.1021),\n    (39.1212, 47.2633),\n    (39.1476, 47.0447),\n    (37.6737, 46.6365),\n    (38.2329, 46.2408),\n    (37.4031, 45.4045),\n    (36.6754, 45.2446),\n    (37.5391, 44.6572),\n    (38.6799, 44.2799),\n    (39.9550, 43.4349),\n    (40.3213, 43.1286),\n    (40.8754, 43.0136),\n    (41.4534, 42.6451),\n    (41.7031, 41.9629),\n    (41.5540, 41.5356),\n    (40.3734, 41.0136),\n    (39.5126, 41.1027),\n    (38.3476, 40.9485),\n    (36.9131, 41.3353),\n    (35.1677, 42.0402),\n    (33.5132, 42.0189),\n    (32.3479, 41.7362),\n    (31.1459, 41.0876),\n    (29.2400, 41.2199),\n    (28.8199, 40.4600),\n    (27.2800, 40.4200),\n    (26.1707, 39.4636),\n    (26.8047, 38.9857),\n    (26.3182, 38.2081),\n    (27.0487, 37.6533),\n    (27.6411, 36.6588),\n    (28.7329, 36.6768),\n    (29.6999, 36.1443),\n    (30.3910, 36.2629),\n    (30.6216, 36.6778),\n    (31.6995, 36.6442),\n    (32.5091, 36.1075),\n    (34.0268, 36.2199),\n    (34.7145, 36.7955),\n    (35.5509, 36.5654),\n    (36.1608, 36.6506),\n    (35.7820, 36.2749),\n    (36.1497, 35.8215),\n    (35.9050, 35.4100),\n    (35.9984, 34.6449),\n    (35.9795, 34.6100),\n    (35.4822, 33.9054),\n    (35.1260, 33.0909),\n    (35.0984, 33.0805),\n    (34.9554, 32.8273),\n    (34.7525, 32.0729),\n    (34.4881, 31.6055),\n    (34.5563, 31.5488),\n    (34.2654, 31.2193),\n    (33.7733, 30.9674),\n    (32.9939, 31.0240),\n    (32.1924, 31.2603),\n    (31.9604, 30.9336),\n    (31.6879, 31.4296),\n    (30.9769, 31.5558),\n    (30.0950, 31.4734),\n    (29.6834, 31.1868),\n    (28.9135, 30.8700),\n    (28.4504, 31.0257),\n    (27.4576, 31.3212),\n    (26.4953, 31.5856),\n    (25.1648, 31.5691),\n    (24.9211, 31.8993),\n    (23.9275, 32.0166),\n    (23.6091, 32.1872),\n    (23.2368, 32.1914),\n    (22.8957, 32.6385),\n    (21.5430, 32.8432),\n    (20.8545, 32.7067),\n    (20.1339, 32.2381),\n    (19.8203, 31.7517),\n    (20.0533, 30.9857),\n    (19.5740, 30.5258),\n    (19.0864, 30.2663),\n    (18.0211, 30.7635),\n    (16.6116, 31.1821),\n    (15.7139, 31.3762),\n    (15.2456, 32.2650),\n    (13.9186, 32.7119),\n    (13.0832, 32.8788),\n    (12.6633, 32.7927),\n    (11.4887, 33.1369),\n    (11.1085, 33.2933),\n    (10.8568, 33.7687),\n    (10.3396, 33.7857),\n    (10.1495, 34.3307),\n    (10.8078, 34.8335),\n    (10.9395, 35.6989),\n    (10.5932, 35.9474),\n    (10.6000, 36.4100),\n    (11.1000, 36.8999),\n    (11.0288, 37.0921),\n    (10.1806, 36.7240),\n    (10.2100, 37.2300),\n    (9.5099, 37.3499),\n    (8.4209, 36.9464),\n    (7.7370, 36.8857),\n    (7.3303, 37.1183),\n    (6.2618, 37.1106),\n    (5.3201, 36.7165),\n    (4.8157, 36.8650),\n    (3.1616, 36.7839),\n    (1.4669, 36.6056),\n    (0.5038, 36.3012),\n    (-0.1274, 35.8886),\n    (-1.2086, 35.7148),\n    (-2.1699, 35.1683),\n    (-2.6043, 35.1790),\n    (-3.6400, 35.3998),\n    (-4.5910, 35.3307),\n    (-5.1938, 35.7551),\n    (-5.9299, 35.7599),\n    (-6.2443, 35.1458),\n    (-6.9125, 34.1104),\n    (-7.6541, 33.6970),\n    (-8.6574, 33.2402),\n    (-9.3006, 32.5646),\n    (-9.4347, 32.0380),\n    (-9.8147, 31.1777),\n    (-9.5648, 29.9335),\n    (-10.3995, 29.0985),\n    (-10.9009, 28.8321),\n    (-11.6889, 28.1486),\n    (-12.6188, 28.0381),\n    (-13.1399, 27.6401),\n    (-13.7738, 26.6188),\n    (-14.4399, 26.2544),\n    (-14.8009, 25.6362),\n    (-14.8246, 25.1035),\n    (-15.0893, 24.5202),\n    (-15.4260, 24.3591),\n    (-15.9826, 23.7233),\n    (-16.3264, 23.0177),\n    (-16.2619, 22.6793),\n    (-16.5891, 22.1582),\n    (-16.9732, 21.8857),\n    (-17.0204, 21.4223),\n    (-17.0634, 20.9997),\n    (-16.5363, 20.5678),\n    (-16.2778, 20.0925),\n    (-16.3776, 19.5938),\n    (-16.2568, 19.0967),\n    (-16.1463, 18.1084),\n    (-16.2705, 17.1669),\n    (-16.5497, 16.6738),\n    (-16.4630, 16.1350),\n    (-16.7007, 15.6215),\n    (-17.1851, 14.9194),\n    (-17.6250, 14.7295),\n    (-17.1261, 14.3735),\n    (-16.7137, 13.5949),\n    (-16.8415, 13.1513),\n    (-16.6774, 12.3848),\n    (-16.6138, 12.1709),\n    (-16.3089, 11.9587),\n    (-16.3147, 11.8065),\n    (-16.0852, 11.5245),\n    (-15.6641, 11.4584),\n    (-15.1303, 11.0404),\n    (-14.8395, 10.8765),\n    (-14.6932, 10.6563),\n    (-14.5796, 10.2144),\n    (-14.3300, 10.0157),\n    (-14.0740, 9.8861),\n    (-13.6851, 9.4947),\n    (-13.2465, 8.9030),\n    (-13.1240, 8.1639),\n    (-12.9490, 7.7986),\n    (-12.4280, 7.2629),\n    (-11.7081, 6.8600),\n    (-11.4387, 6.7859),\n    (-10.7653, 6.1407),\n    (-9.9134, 5.5935),\n    (-9.0047, 4.8324),\n    (-7.9741, 4.3557),\n    (-7.7121, 4.3645),\n    (-7.5189, 4.3382),\n    (-6.5287, 4.7050),\n    (-5.8344, 4.9937),\n    (-4.6499, 5.1682),\n    (-4.0088, 5.1798),\n    (-3.3110, 4.9842),\n    (-2.8561, 4.9944),\n    (-1.9647, 4.7104),\n    (-1.0636, 5.0005),\n    (-0.5076, 5.3434),\n    (1.0601, 5.9288),\n    (1.8652, 6.1421),\n    (2.6917, 6.2588),\n    (3.5741, 6.2583),\n    (4.3256, 6.2706),\n    (5.0335, 5.6118),\n    (5.3628, 4.8879),\n    (5.8981, 4.2624),\n    (6.6980, 4.2405),\n    (7.0825, 4.4646),\n    (7.4621, 4.4121),\n    (8.5002, 4.7719),\n    (8.4888, 4.4956),\n    (8.7449, 4.3522),\n    (8.9481, 3.9041),\n    (9.4043, 3.7345),\n    (9.7951, 3.0734),\n    (9.6491, 2.2838),\n    (9.3056, 1.1609),\n    (9.4928, 1.0101),\n    (9.2913, 0.2686),\n    (9.0484, -0.4593),\n    (8.8300, -0.7790),\n    (8.7979, -1.1113),\n    (9.4052, -2.1443),\n    (10.0661, -2.9694),\n    (11.0937, -3.9788),\n    (11.9149, -5.0379),\n    (12.1823, -5.7899),\n    (12.3224, -6.1000),\n    (12.2273, -6.2944),\n    (12.7282, -6.9271),\n    (12.9330, -7.5965),\n    (13.2364, -8.5626),\n    (12.9290, -8.9590),\n    (12.8753, -9.1669),\n    (13.1209, -9.7668),\n    (13.3873, -10.3735),\n    (13.6863, -10.7310),\n    (13.7387, -11.2978),\n    (13.6337, -12.0386),\n    (13.3129, -12.4836),\n    (12.7384, -13.1379),\n    (12.5000, -13.5476),\n    (12.1756, -14.4491),\n    (12.1235, -14.8783),\n    (11.7785, -15.7938),\n    (11.6400, -16.6731),\n    (11.7341, -17.3018),\n    (11.7949, -18.0691),\n    (12.6085, -19.0453),\n    (12.8268, -19.6731),\n    (13.3524, -20.8728),\n    (13.8686, -21.6990),\n    (14.2577, -22.1112),\n    (14.3857, -22.6566),\n    (14.4081, -23.8530),\n    (14.7432, -25.3929),\n    (14.9897, -26.1173),\n    (15.2104, -27.0909),\n    (15.6018, -27.8212),\n    (16.3449, -28.5767),\n    (17.0629, -29.8759),\n    (17.0644, -29.8786),\n    (17.5669, -30.7257),\n    (18.2217, -31.6616),\n    (18.2479, -32.4291),\n    (17.9251, -32.6112),\n    (18.2500, -33.2814),\n    (18.2444, -33.8677),\n    (18.3774, -34.1365),\n    (18.4246, -33.9978),\n    (18.8553, -34.4443),\n    (19.1932, -34.4625),\n    (19.6164, -34.8191),\n    (20.0712, -34.7951),\n    (20.6890, -34.4171),\n    (21.5427, -34.2588),\n    (22.5741, -33.8640),\n    (22.9881, -33.9164),\n    (23.5940, -33.7944),\n    (24.6778, -33.9871),\n    (25.1728, -33.7968),\n    (25.7806, -33.9446),\n    (25.9096, -33.6670),\n    (26.4194, -33.6149),\n    (27.4646, -33.2269),\n    (28.2197, -32.7719),\n    (28.9255, -32.1720),\n    (30.0557, -31.1402),\n    (30.6228, -30.4237),\n    (30.9017, -29.9099),\n    (31.3255, -29.4019),\n    (31.5210, -29.2573),\n    (32.2033, -28.7524),\n    (32.4621, -28.3010),\n    (32.5802, -27.4701),\n    (32.8301, -26.7421),\n    (32.9159, -26.2158),\n    (32.6603, -26.1485),\n    (32.5746, -25.7273),\n    (33.0132, -25.3575),\n    (34.2158, -24.8163),\n    (35.0407, -24.4783),\n    (35.4587, -24.1226),\n    (35.6074, -23.7065),\n    (35.3717, -23.5353),\n    (35.5339, -23.0707),\n    (35.5625, -22.09),\n    (35.3858, -22.14),\n    (35.3734, -21.8408),\n    (35.1761, -21.2543),\n    (34.7018, -20.4970),\n    (34.7863, -19.7840),\n    (35.1983, -19.5528),\n    (35.8964, -18.8422),\n    (36.2812, -18.6596),\n    (37.4111, -17.5863),\n    (38.5383, -17.1010),\n    (39.4525, -16.7208),\n    (40.0892, -16.1007),\n    (40.4772, -15.4062),\n    (40.7754, -14.6917),\n    (40.5996, -14.2019),\n    (40.5608, -12.6391),\n    (40.4372, -11.7617),\n    (40.4783, -10.7654),\n    (40.3165, -10.3170),\n    (39.9495, -10.0984),\n    (39.5357, -9.1123),\n    (39.1865, -8.4855),\n    (39.2520, -8.0078),\n    (39.1946, -7.7039),\n    (39.4699, -7.0999),\n    (39.4400, -6.8399),\n    (38.7997, -6.4756),\n    (38.7405, -5.9089),\n    (39.2022, -4.6767),\n    (39.6049, -4.3465),\n    (39.8000, -3.6811),\n    (40.1211, -3.2776),\n    (40.2630, -2.5730),\n    (40.6378, -2.4997),\n    (40.8847, -2.0825),\n    (41.5851, -1.6832),\n    (41.8109, -1.4464),\n    (42.0415, -0.9191),\n    (43.1359, 0.2921),\n    (44.0681, 1.0528),\n    (45.5639, 2.0457),\n    (46.5647, 2.8552),\n    (47.7407, 4.2194),\n    (48.5945, 5.3391),\n    (49.4527, 6.8046),\n    (50.0709, 8.0817),\n    (50.5523, 9.1987),\n    (50.8341, 10.2797),\n    (51.0452, 10.6409),\n    (51.0415, 11.1665),\n    (51.1338, 11.7481),\n    (51.1112, 12.0246),\n    (50.7320, 12.0219),\n    (50.2587, 11.6795),\n    (49.7286, 11.5789),\n    (49.2677, 11.4303),\n    (48.9482, 11.4106),\n    (48.3787, 11.3754),\n    (48.0215, 11.1930),\n    (47.5256, 11.1272),\n    (46.6454, 10.8165),\n    (45.5569, 10.6980),\n    (44.6142, 10.4422),\n    (44.1178, 10.4455),\n    (43.6666, 10.8641),\n    (43.4706, 11.2777),\n    (43.1453, 11.4620),\n    (42.7158, 11.7356),\n    (43.2863, 11.9749),\n    (43.3178, 12.3901),\n    (43.0812, 12.6996),\n    (42.5895, 13.0004),\n    (42.2768, 13.3439),\n    (41.7349, 13.9210),\n    (41.1792, 14.4910),\n    (39.8142, 15.4356),\n    (39.2661, 15.9227),\n    (38.9906, 16.8406),\n    (38.4100, 17.9983),\n    (37.8627, 18.3678),\n    (37.4817, 18.6140),\n    (37.1147, 19.8079),\n    (36.9694, 20.8374),\n    (37.1887, 21.0188),\n    (36.86623, 22.0),\n    (36.6907, 22.2048),\n    (35.5259, 23.1024),\n    (35.4937, 23.7523),\n    (35.6924, 23.9267),\n    (34.7950, 25.0337),\n    (34.4738, 25.5985),\n    (34.1045, 26.1422),\n    (33.3487, 27.6998),\n    (32.7348, 28.7052),\n    (32.3204, 29.7604),\n    (32.4232, 29.8510),\n    (33.1367, 28.4176),\n    (33.5881, 27.9713),\n    (33.9213, 27.6487),\n    (34.1545, 27.8233),\n    (34.4265, 28.3439),\n    (34.6417, 29.0994),\n    (34.9226, 29.5013),\n    (34.9560, 29.3565),\n    (34.8322, 28.9574),\n    (34.7877, 28.6074),\n    (34.6323, 28.0585),\n    (35.1301, 28.0633),\n    (35.6401, 27.3765),\n    (36.2491, 26.5701),\n    (36.6396, 25.8262),\n    (36.9316, 25.6029),\n    (37.2094, 25.0845),\n    (37.1548, 24.8584),\n    (37.4836, 24.2854),\n    (38.0238, 24.0786),\n    (38.4927, 23.6884),\n    (39.0663, 22.5796),\n    (39.0236, 21.9868),\n    (39.1393, 21.2919),\n    (39.8016, 20.3388),\n    (40.2476, 20.1746),\n    (40.9393, 19.4864),\n    (41.2213, 18.6715),\n    (41.7543, 17.8330),\n    (42.2708, 17.4747),\n    (42.3479, 17.0758),\n    (42.6495, 16.7746),\n    (42.7793, 16.3478),\n    (42.8236, 15.9117),\n    (42.7024, 15.7188),\n    (42.8050, 15.2619),\n    (42.6048, 15.2133),\n    (42.8922, 14.8022),\n    (43.0879, 14.0626),\n    (43.2514, 13.7675),\n    (43.2228, 13.2209),\n    (43.4829, 12.6368),\n    (44.1751, 12.5859),\n    (44.4945, 12.7216),\n    (44.9895, 12.6995),\n    (45.1443, 12.9539),\n    (45.4064, 13.0269),\n    (45.6250, 13.2909),\n    (45.8775, 13.3477),\n    (46.7170, 13.3996),\n    (47.3544, 13.5922),\n    (47.9389, 14.0072),\n    (48.2389, 13.9480),\n    (48.6792, 14.0032),\n    (49.5745, 14.7087),\n    (51.1725, 15.1752),\n    (52.1681, 15.5974),\n    (52.1917, 15.9384),\n    (52.3852, 16.3824),\n    (53.1085, 16.6510),\n    (53.5705, 16.7076),\n    (54.2392, 17.0449),\n    (54.7910, 16.9506),\n    (55.2749, 17.2283),\n    (55.2699, 17.6323),\n    (55.6614, 17.8841),\n    (56.2835, 17.8760),\n    (56.5121, 18.0871),\n    (56.6096, 18.5742),\n    (57.2342, 18.9479),\n    (57.6943, 18.9447),\n    (57.7887, 19.0675),\n    (57.6657, 19.7360),\n    (57.8263, 20.2430),\n    (58.0343, 20.4814),\n    (58.4879, 20.4289),\n    (58.8611, 21.1140),\n    (59.2824, 21.4338),\n    (59.4421, 21.7145),\n    (59.8061, 22.3105),\n    (59.8080, 22.5336),\n    (59.4500, 22.6602),\n    (59.1805, 22.9923),\n    (58.7292, 23.5656),\n    (58.1369, 23.7479),\n    (57.4034, 23.8785),\n    (56.8451, 24.2416),\n    (56.3968, 24.9247),\n    (56.2610, 25.7146),\n    (56.3914, 25.8959),\n    (56.4856, 26.3091),\n    (56.3620, 26.3959),\n    (56.0708, 26.0554),\n    (55.4390, 25.4391),\n    (54.6930, 24.7978),\n    (54.0080, 24.1217),\n    (53.4040, 24.1513),\n    (52.5770, 24.1774),\n    (51.7943, 24.0198),\n    (51.7574, 24.2940),\n    (51.5795, 24.2454),\n    (51.3896, 24.6273),\n    (51.6067, 25.2156),\n    (51.5890, 25.8011),\n    (51.2864, 26.1145),\n    (51.0133, 26.0069),\n    (50.7439, 25.4824),\n    (50.8101, 24.7547),\n    (50.6605, 24.9998),\n    (50.5273, 25.3278),\n    (50.2398, 25.6080),\n    (50.1133, 25.9439),\n    (50.2129, 26.2770),\n    (50.1524, 26.6896),\n    (49.4709, 27.1099),\n    (49.2995, 27.4612),\n    (48.8075, 27.6896),\n    (48.4160, 28.5520),\n    (48.0939, 29.3062),\n    (48.1831, 29.5344),\n    (47.9745, 29.9758),\n    (48.5679, 29.9267),\n    (48.9413, 30.3170),\n    (49.5768, 29.9857),\n    (50.1150, 30.1477),\n    (50.8529, 28.8145),\n    (51.5207, 27.8656),\n    (52.4835, 27.5808),\n    (53.4930, 26.8123),\n    (54.7150, 26.4806),\n    (55.7237, 26.9646),\n    (56.4921, 27.1433),\n    (56.9707, 26.9661),\n    (57.3972, 25.7399),\n    (58.5257, 25.6099),\n    (59.6161, 25.3801),\n    (61.4973, 25.0782),\n    (62.9057, 25.2184),\n    (64.5304, 25.2370),\n    (66.3728, 25.4251),\n    (67.1454, 24.6636),\n    (67.4436, 23.9448),\n    (68.1766, 23.6919),\n    (69.3495, 22.8431),\n    (69.6449, 22.4507),\n    (69.1641, 22.0892),\n    (70.4704, 20.8773),\n    (71.1752, 20.7574),\n    (72.6305, 21.3560),\n    (72.8244, 20.4195),\n    (72.8209, 19.2082),\n    (73.1199, 17.9285),\n    (73.5341, 15.9906),\n    (74.4438, 14.6172),\n    (74.6167, 13.9925),\n    (74.8648, 12.7419),\n    (75.3961, 11.7812),\n    (75.7464, 11.3082),\n    (76.1300, 10.2996),\n    (76.5929, 8.8992),\n    (77.5398, 7.9655),\n    (77.9411, 8.2529),\n    (78.2779, 8.9330),\n    (79.1897, 9.2165),\n    (78.8853, 9.5461),\n    (79.3405, 10.3088),\n    (79.8579, 10.3572),\n    (79.8625, 12.0562),\n    (80.2862, 13.0062),\n    (80.2332, 13.8357),\n    (80.0250, 15.1364),\n    (80.3248, 15.8991),\n    (80.7919, 15.9519),\n    (81.6927, 16.3102),\n    (82.1912, 16.5566),\n    (82.1927, 17.0166),\n    (83.1892, 17.6712),\n    (83.9410, 18.3020),\n    (85.0602, 19.4785),\n    (86.4993, 20.1516),\n    (87.0331, 20.7433),\n    (86.9757, 21.4955),\n    (88.2084, 21.7031),\n    (88.8887, 21.6905),\n    (89.0319, 22.0557),\n    (89.4188, 21.9661),\n    (89.7020, 21.8571),\n    (89.8474, 22.0391),\n    (90.2729, 21.8363),\n    (90.5869, 22.3927),\n    (90.4960, 22.8050),\n    (91.4170, 22.7650),\n    (91.8348, 22.1829),\n    (92.0252, 21.7015),\n    (92.0828, 21.1921),\n    (92.3685, 20.6708),\n    (93.0782, 19.8551),\n    (93.6632, 19.7269),\n    (93.5409, 19.3664),\n    (94.3248, 18.2135),\n    (94.5334, 17.2772),\n    (94.1888, 16.0379),\n    (94.8084, 15.8034),\n    (95.3693, 15.7143),\n    (96.5057, 16.4272),\n    (97.1645, 16.9287),\n    (97.5970, 16.1005),\n    (97.7777, 14.8372),\n    (98.1036, 13.6404),\n    (98.5095, 13.1223),\n    (98.4283, 12.0329),\n    (98.7645, 11.4412),\n    (98.4571, 10.6752),\n    (98.5535, 9.9329),\n    (98.2591, 8.9739),\n    (98.1500, 8.3500),\n    (98.3396, 7.7945),\n    (98.5037, 8.3823),\n    (98.9882, 7.9079),\n    (99.5196, 7.3434),\n    (99.6906, 6.8482),\n    (100.0857, 6.4644),\n    (100.3062, 6.0405),\n    (100.1967, 5.3124),\n    (100.5574, 4.7672),\n    (100.6954, 3.9391),\n    (101.2735, 3.2702),\n    (101.3906, 2.7608),\n    (102.5736, 1.9671),\n    (103.5197, 1.2263),\n    (104.2288, 1.2930),\n    (104.2479, 1.6311),\n    (103.8546, 2.5154),\n    (103.5024, 2.7910),\n    (103.4294, 3.3828),\n    (103.3321, 3.7266),\n    (103.4385, 4.1816),\n    (103.3812, 4.8550),\n    (102.9617, 5.5244),\n    (102.3711, 6.1282),\n    (102.1411, 6.2216),\n    (101.6230, 6.7406),\n    (101.0173, 6.8568),\n    (100.4592, 7.4295),\n    (100.2796, 8.2951),\n    (99.8738, 9.2078),\n    (99.2223, 9.2392),\n    (99.1537, 9.9630),\n    (99.4789, 10.8463),\n    (100.0187, 12.3070),\n    (100.0977, 13.4068),\n    (100.9784, 13.4127),\n    (100.8318, 12.6270),\n    (101.6871, 12.6457),\n    (102.5849, 12.1865),\n    (103.0906, 11.1536),\n    (103.4972, 10.6325),\n    (104.3343, 10.4865),\n    (105.0762, 9.9184),\n    (104.7951, 9.2410),\n    (105.1582, 8.5997),\n    (106.4051, 9.5308),\n    (107.2209, 10.3644),\n    (108.3661, 11.0083),\n    (109.2001, 11.6668),\n    (109.3352, 13.4260),\n    (108.8771, 15.2766),\n    (108.2694, 16.0797),\n    (107.3619, 16.6974),\n    (106.4268, 18.0041),\n    (105.6620, 19.0581),\n    (105.8816, 19.7520),\n    (106.7150, 20.6968),\n    (108.0501, 21.5523),\n    (108.5228, 21.7152),\n    (109.8644, 21.3950),\n    (109.6276, 21.0082),\n    (109.8898, 20.2824),\n    (110.4440, 20.3410),\n    (110.5093, 20.5654),\n    (110.7854, 21.3971),\n    (111.8435, 21.5504),\n    (113.2410, 22.0513),\n    (113.8067, 22.5483),\n    (114.1525, 22.2237),\n    (114.7638, 22.6680),\n    (115.8907, 22.7828),\n    (117.2816, 23.6245),\n    (118.6568, 24.5473),\n    (119.5854, 25.7407),\n    (120.3954, 27.0532),\n    (121.1256, 28.1356),\n    (121.6844, 28.2255),\n    (121.9384, 29.0180),\n    (122.0921, 29.8325),\n    (121.5035, 30.1429),\n    (121.2642, 30.6762),\n    (121.8919, 30.9493),\n    (121.9081, 31.6921),\n    (121.2290, 32.4603),\n    (120.6203, 33.3767),\n    (120.2275, 34.3603),\n    (119.1512, 34.9098),\n    (119.6645, 35.6097),\n    (120.6370, 36.1114),\n    (121.1041, 36.6513),\n    (122.5199, 36.9306),\n    (122.3579, 37.4544),\n    (121.7112, 37.4811),\n    (120.8234, 37.8704),\n    (119.7028, 37.1563),\n    (118.9116, 37.4484),\n    (118.8781, 37.8973),\n    (118.0596, 38.0614),\n    (117.5327, 38.7376),\n    (118.0427, 39.2042),\n    (119.0234, 39.2523),\n    (119.6396, 39.8980),\n    (120.7686, 40.5933),\n    (121.6403, 40.9463),\n    (122.1685, 40.4224),\n    (121.3767, 39.7502),\n    (121.5859, 39.3608),\n    (121.0545, 38.8974),\n    (122.1313, 39.1704),\n    (122.8675, 39.6377),\n    (124.2656, 39.9284),\n    (124.7374, 39.6603),\n    (125.3211, 39.5513),\n    (125.3865, 39.3879),\n    (125.1328, 38.8485),\n    (125.2219, 38.6658),\n    (124.9859, 38.5484),\n    (124.7121, 38.1083),\n    (124.9810, 37.9488),\n    (125.2400, 37.8572),\n    (125.2753, 37.6690),\n    (125.5684, 37.7520),\n    (125.6891, 37.9400),\n    (126.1747, 37.7496),\n    (126.8601, 36.8939),\n    (126.1173, 36.7254),\n    (126.5592, 35.6845),\n    (126.3739, 34.9345),\n    (126.4857, 34.3900),\n    (127.3865, 34.4756),\n    (128.1858, 34.8903),\n    (129.0913, 35.0824),\n    (129.4683, 35.6321),\n    (129.4604, 36.7841),\n    (129.2129, 37.4323),\n    (128.3497, 38.6122),\n    (127.7833, 39.0508),\n    (127.3854, 39.2134),\n    (127.5021, 39.3239),\n    (127.5334, 39.7568),\n    (127.9674, 40.0254),\n    (128.6333, 40.1898),\n    (129.0103, 40.4854),\n    (129.1881, 40.6618),\n    (129.7051, 40.8828),\n    (129.6673, 41.6011),\n    (129.9659, 41.9413),\n    (130.4000, 42.2800),\n    (130.7800, 42.2200),\n    (130.9358, 42.5527),\n    (132.2780, 43.2845),\n    (132.9062, 42.7984),\n    (133.5368, 42.8114),\n    (134.8694, 43.3982),\n    (135.5153, 43.9889),\n    (136.8623, 45.1434),\n    (138.2197, 46.3079),\n    (138.5547, 46.9996),\n    (140.0619, 48.4467),\n    (140.5130, 50.0455),\n    (140.5974, 51.2396),\n    (141.3792, 52.2387),\n    (141.3453, 53.0895),\n    (139.9015, 54.1896),\n    (138.8046, 54.2545),\n    (138.1647, 53.7550),\n    (137.1934, 53.9773),\n    (136.7017, 54.6035),\n    (135.1261, 54.7295),\n    (138.9584, 57.0880),\n    (142.1978, 59.0399),\n    (145.4872, 59.3363),\n    (148.5448, 59.1644),\n    (149.7837, 59.6557),\n    (151.3381, 59.5039),\n    (151.2657, 58.7808),\n    (152.8118, 58.8838),\n    (155.0437, 59.1449),\n    (154.2180, 59.7581),\n    (156.7206, 61.4344),\n    (159.3023, 61.7739),\n    (160.1214, 60.5442),\n    (162.6579, 61.6424),\n    (163.2583, 62.4662),\n    (164.4735, 62.5506),\n    (163.6696, 61.1408),\n    (161.87204, 60.343),\n    (160.1506, 59.3147),\n    (158.3643, 58.0557),\n    (156.8103, 57.8320),\n    (156.7581, 57.3647),\n    (155.9144, 56.7679),\n    (155.4336, 55.3810),\n    (155.9918, 53.1589),\n    (156.42, 51.7),\n    (156.7897, 51.0110),\n    (158.2311, 51.9426),\n    (158.5309, 52.9586),\n    (160.0217, 53.2025),\n    (160.3687, 54.3443),\n    (162.1174, 54.8551),\n    (161.7014, 55.2856),\n    (162.1263, 56.1158),\n    (163.0579, 56.1592),\n    (163.1919, 57.6150),\n    (162.0529, 57.8391),\n    (162.0173, 58.2432),\n    (163.2171, 59.2110),\n    (163.5392, 59.8686),\n    (164.8767, 59.7316),\n    (165.84, 60.16),\n    (166.2949, 59.7885),\n    (168.9004, 60.5735),\n    (170.3308, 59.8817),\n    (170.6985, 60.3361),\n    (172.15, 60.95),\n    (173.6801, 61.6526),\n    (174.5692, 61.7691),\n    (177.3643, 62.5219),\n    (179.2282, 62.3041),\n    (179.4863, 62.5689),\n    (179.3703, 62.9826),\n    (178.9082, 63.2519),\n    (178.313, 64.07593),\n    (177.4112, 64.6082),\n    (178.7072, 64.5349),\n    (180.0, 64.9797),\n    (-177.5500, 68.1999),\n    (-179.9999, 68.9636),\n    (-179.9999, -16.0671),\n    (-179.7933, -16.0208),\n    (-179.9173, -16.5017),\n    (-179.9999, -16.5552),\n    (125.9470, -8.4320),\n    (126.6447, -8.3982),\n    (126.9572, -8.2733),\n    (127.3359, -8.3973),\n    (126.9679, -8.6682),\n    (125.9258, -9.1060),\n    (125.0885, -9.3931),\n    (124.4359, -10.1400),\n    (123.5799, -10.3599),\n    (123.4599, -10.2399),\n    (123.5500, -9.9000),\n    (123.9800, -9.2900),\n    (124.9686, -8.8927),\n    (125.0862, -8.6568),\n    (125.9470, -8.4320),\n    (-180.0, 68.9636),\n    (-177.5500, 68.1999),\n    (-174.9282, 67.2058),\n    (-175.0142, 66.5843),\n    (-174.3398, 66.3355),\n    (-174.5718, 67.0621),\n    (-171.8573, 66.9130),\n    (-169.8995, 65.9772),\n    (-170.8910, 65.5413),\n    (-172.5302, 65.4379),\n    (-172.555, 64.46079),\n    (-172.9553, 64.2526),\n    (-173.8918, 64.2826),\n    (-174.6539, 64.6312),\n    (-175.9835, 64.9228),\n    (-176.2071, 65.3566),\n    (-177.2226, 65.5202),\n    (-178.3599, 65.3905),\n    (-178.9033, 65.7404),\n    (-178.6861, 66.1121),\n    (-179.8837, 65.8745),\n    (-179.4326, 65.4041),\n    (-180.0, 64.9797),\n    (-180.0, 71.5157),\n    (-179.8718, 71.5576),\n    (-179.0243, 71.5555),\n    (-177.5779, 71.2694),\n    (-177.6635, 71.1327),\n    (-178.6937, 70.8930),\n    (-180.0, 70.8321),\n    (180.0, 70.8321),\n    (178.9034, 70.7811),\n    (178.7253, 71.0988),\n    (180.0, 71.5157),\n    (180.0, -16.5552),\n    (179.3641, -16.8013),\n    (178.7250, -17.0120),\n    (178.5968, -16.6391),\n    (179.0966, -16.4339),\n    (179.4135, -16.3790),\n    (180.0, -16.0671),\n    (-61.2, -51.85),\n    (-60.0, -51.25),\n    (-59.15, -51.5),\n    (-58.55, -51.1),\n    (-57.75, -51.55),\n    (-58.05, -51.9),\n    (-59.4, -52.2),\n    (-59.85, -51.85),\n    (-60.7, -52.3),\n    (-61.2, -51.85),\n    (68.935, -48.625),\n    (69.58, -48.94),\n    (70.525, -49.065),\n    (70.56, -49.255),\n    (70.28, -49.71),\n    (68.745, -49.775),\n    (68.72, -49.2425),\n    (68.8675, -48.83),\n    (68.935, -48.625),\n    (178.1255, -17.5048),\n    (178.3736, -17.3399),\n    (178.7180, -17.6284),\n    (178.5527, -18.1505),\n    (177.9326, -18.2879),\n    (177.3814, -18.1643),\n    (177.2850, -17.7246),\n    (177.6708, -17.3811),\n    (178.1255, -17.5048),\n    (-61.68, 10.76),\n    (-61.105, 10.89),\n    (-60.895, 10.855),\n    (-60.935, 10.11),\n    (-61.77, 10.0),\n    (-61.95, 10.09),\n    (-61.66, 10.365),\n    (-61.68, 10.76),\n    (-155.4021, 20.0797),\n    (-155.2245, 19.9930),\n    (-155.0622, 19.8591),\n    (-154.8074, 19.5087),\n    (-154.8314, 19.4532),\n    (-155.2221, 19.2397),\n    (-155.5421, 19.0834),\n    (-155.6881, 18.9161),\n    (-155.9366, 19.0593),\n    (-155.9080, 19.3388),\n    (-156.0734, 19.7029),\n    (-156.0236, 19.8142),\n    (-155.8500, 19.9772),\n    (-155.9190, 20.1739),\n    (-155.8610, 20.2672),\n    (-155.7850, 20.2487),\n    (-155.4021, 20.0797),\n    (-155.9956, 20.7640),\n    (-156.0792, 20.6439),\n    (-156.4144, 20.5724),\n    (-156.58673, 20.783),\n    (-156.7016, 20.8643),\n    (-156.7105, 20.9267),\n    (-156.6125, 21.0124),\n    (-156.2571, 20.9174),\n    (-155.9956, 20.7640),\n    (-156.7582, 21.1768),\n    (-156.7893, 21.0687),\n    (-157.3252, 21.0977),\n    (-157.2502, 21.2195),\n    (-156.7582, 21.1768),\n    (-158.0252, 21.7169),\n    (-157.9416, 21.6527),\n    (-157.6528, 21.3221),\n    (-157.7070, 21.2644),\n    (-157.7786, 21.2772),\n    (-158.1266, 21.3124),\n    (-158.2538, 21.5391),\n    (-158.2926, 21.5791),\n    (-158.0252, 21.7169),\n    (-159.3656, 22.2149),\n    (-159.34512, 21.982),\n    (-159.4637, 21.8829),\n    (-159.8005, 22.0653),\n    (-159.7487, 22.1382),\n    (-159.5962, 22.2361),\n    (-159.3656, 22.2149),\n    (-78.1908, 25.2103),\n    (-77.89, 25.17),\n    (-77.54, 24.34),\n    (-77.5346, 23.7597),\n    (-77.78, 23.71),\n    (-78.0340, 24.2861),\n    (-78.4084, 24.5756),\n    (-78.1908, 25.2103),\n    (-78.98, 26.79),\n    (-78.51, 26.87),\n    (-77.85, 26.84),\n    (-77.82, 26.58),\n    (-78.91, 26.42),\n    (-78.98, 26.79),\n    (-77.79, 27.04),\n    (-77.0, 26.59),\n    (-77.1725, 25.8791),\n    (-77.3564, 26.0073),\n    (-77.34, 26.53),\n    (-77.7880, 26.9251),\n    (-77.79, 27.04),\n    (-64.0148, 47.0360),\n    (-63.6645, 46.5500),\n    (-62.9393, 46.4158),\n    (-62.0120, 46.4431),\n    (-62.5039, 46.0333),\n    (-62.8743, 45.9681),\n    (-64.1428, 46.3926),\n    (-64.3926, 46.7274),\n    (-64.0148, 47.0360),\n    (46.6820, 44.6092),\n    (47.6759, 45.6414),\n    (48.6454, 45.8062),\n    (49.1011, 46.3993),\n    (50.0340, 46.6089),\n    (51.1919, 47.0487),\n    (52.0420, 46.8046),\n    (53.0427, 46.8530),\n    (53.2208, 46.2346),\n    (53.0408, 45.2590),\n    (52.1673, 45.4083),\n    (51.3168, 45.2459),\n    (51.2785, 44.5148),\n    (50.3056, 44.6098),\n    (50.3391, 44.2840),\n    (50.8912, 44.0310),\n    (51.3424, 43.1329),\n    (52.5014, 42.7922),\n    (52.6921, 42.4438),\n    (52.4463, 42.0271),\n    (52.5024, 41.7833),\n    (52.8146, 41.1353),\n    (52.9167, 41.8681),\n    (53.7217, 42.1231),\n    (54.0083, 41.5512),\n    (54.7368, 40.9510),\n    (53.8581, 40.6310),\n    (52.9152, 40.8765),\n    (52.6939, 40.0336),\n    (53.3578, 39.9752),\n    (53.1010, 39.2905),\n    (53.8809, 38.9520),\n    (53.7355, 37.9061),\n    (53.9215, 37.1989),\n    (53.8257, 36.9650),\n    (52.2640, 36.7004),\n    (50.8423, 36.8728),\n    (50.1477, 37.3745),\n    (49.1996, 37.5828),\n    (48.8832, 38.3202),\n    (48.8565, 38.8154),\n    (49.2232, 39.0492),\n    (49.3952, 39.3994),\n    (49.5692, 40.1761),\n    (50.3928, 40.2565),\n    (50.0848, 40.5261),\n    (49.6189, 40.5729),\n    (49.1102, 41.2822),\n    (48.5843, 41.8088),\n    (47.4925, 42.9865),\n    (47.5909, 43.6601),\n    (46.6820, 44.6092),\n    (-64.5191, 49.8730),\n    (-64.1732, 49.9571),\n    (-62.8582, 49.7064),\n    (-61.8355, 49.2885),\n    (-61.8063, 49.1050),\n    (-62.2931, 49.0871),\n    (-63.5892, 49.4006),\n    (-64.5191, 49.8730),\n    (-80.3153, 62.0855),\n    (-79.9293, 62.3856),\n    (-79.5200, 62.3637),\n    (-79.2658, 62.1586),\n    (-79.6575, 61.6330),\n    (-80.0995, 61.7181),\n    (-80.3621, 62.0164),\n    (-80.3153, 62.0855),\n    (-83.9936, 62.4528),\n    (-83.2504, 62.9140),\n    (-81.8769, 62.9045),\n    (-81.8982, 62.7108),\n    (-83.0685, 62.1592),\n    (-83.7746, 62.1823),\n    (-83.9936, 62.4528),\n    (-75.2159, 67.4442),\n    (-75.8658, 67.1488),\n    (-76.9868, 67.0987),\n    (-77.2364, 67.5880),\n    (-76.8116, 68.1485),\n    (-75.8952, 68.2872),\n    (-75.1145, 68.0103),\n    (-75.1033, 67.5820),\n    (-75.2159, 67.4442),\n    (-96.5574, 69.6800),\n    (-95.6476, 69.1076),\n    (-96.2695, 68.7570),\n    (-97.6174, 69.0600),\n    (-98.4318, 68.9507),\n    (-99.7974, 69.4000),\n    (-98.9174, 69.7100),\n    (-98.2182, 70.1435),\n    (-97.1574, 69.8600),\n    (-96.5574, 69.6800),\n    (-106.5225, 73.0760),\n    (-105.4024, 72.6725),\n    (-104.7748, 71.6984),\n    (-104.4647, 70.9929),\n    (-102.7853, 70.4977),\n    (-100.9807, 70.0243),\n    (-101.0893, 69.5844),\n    (-102.7311, 69.5040),\n    (-102.0932, 69.1196),\n    (-102.4302, 68.7528),\n    (-104.24, 68.91),\n    (-105.96, 69.18),\n    (-107.1225, 69.1192),\n    (-109.0, 68.78),\n    (-111.5341, 68.6300),\n    (-113.3132, 68.5355),\n    (-113.8549, 69.0074),\n    (-115.22, 69.28),\n    (-116.1079, 69.1682),\n    (-117.34, 69.96),\n    (-116.6747, 70.0665),\n    (-115.1311, 70.2373),\n    (-113.7213, 70.1923),\n    (-112.4161, 70.3663),\n    (-114.3499, 70.6000),\n    (-116.4868, 70.5204),\n    (-117.9048, 70.5405),\n    (-118.4323, 70.9092),\n    (-116.1131, 71.3091),\n    (-117.6556, 71.2951),\n    (-119.4019, 71.5585),\n    (-118.5626, 72.3078),\n    (-117.8664, 72.7059),\n    (-115.1890, 73.3145),\n    (-114.1671, 73.1214),\n    (-114.6663, 72.6527),\n    (-112.4410, 72.9553),\n    (-111.0503, 72.4504),\n    (-109.9203, 72.9611),\n    (-109.0065, 72.6333),\n    (-108.1883, 71.6508),\n    (-107.6859, 72.0654),\n    (-108.3964, 73.0895),\n    (-107.5164, 73.2359),\n    (-106.5225, 73.0760),\n    (-79.7758, 72.8029),\n    (-80.8760, 73.3331),\n    (-80.8338, 73.6931),\n    (-80.3530, 73.7597),\n    (-78.0644, 73.6519),\n    (-76.34, 73.1026),\n    (-76.2514, 72.8263),\n    (-77.3144, 72.8555),\n    (-78.3916, 72.8766),\n    (-79.4862, 72.7422),\n    (-79.7758, 72.8029),\n    (139.8631, 73.3698),\n    (140.8117, 73.7650),\n    (142.0620, 73.8575),\n    (143.4828, 73.4752),\n    (143.6038, 73.2124),\n    (142.0876, 73.2054),\n    (140.0381, 73.3169),\n    (139.8631, 73.3698),\n    (148.2222, 75.3458),\n    (150.7316, 75.0840),\n    (149.5759, 74.6889),\n    (147.9774, 74.7783),\n    (146.1191, 75.1729),\n    (146.3584, 75.4968),\n    (148.2222, 75.3458),\n    (138.8310, 76.1367),\n    (141.4716, 76.0928),\n    (145.0862, 75.5626),\n    (144.3, 74.82),\n    (140.6138, 74.8476),\n    (138.9554, 74.6114),\n    (136.9743, 75.2616),\n    (137.5117, 75.9491),\n    (138.8310, 76.1367),\n    (-98.5770, 76.5886),\n    (-98.5, 76.72),\n    (-97.7355, 76.2565),\n    (-97.7044, 75.7434),\n    (-98.16, 75.0),\n    (-99.8087, 74.8974),\n    (-100.8836, 75.0573),\n    (-100.8629, 75.6407),\n    (-102.5020, 75.5638),\n    (-102.5655, 76.3365),\n    (-101.4897, 76.3053),\n    (-99.9834, 76.6463),\n    (-98.5770, 76.5886),\n    (102.8378, 79.2812),\n    (105.3724, 78.7133),\n    (105.0754, 78.3068),\n    (99.43814, 77.921),\n    (101.2649, 79.2339),\n    (102.0863, 79.3464),\n    (102.8378, 79.2812),\n    (93.7776, 81.0246),\n    (95.9408, 81.2504),\n    (97.8838, 80.7469),\n    (100.1866, 79.7801),\n    (99.9397, 78.8809),\n    (97.7579, 78.7562),\n    (94.9725, 79.0447),\n    (93.3128, 79.4265),\n    (92.5454, 80.1437),\n    (91.1810, 80.3414),\n    (93.7776, 81.0246),\n    (-96.0164, 80.6023),\n    (-95.3234, 80.9072),\n    (-94.2984, 80.9772),\n    (-94.7354, 81.2064),\n    (-92.4098, 81.2573),\n    (-91.1328, 80.7234),\n    (-87.81, 80.32),\n    (-87.02, 79.66),\n    (-85.8143, 79.3369),\n    (-87.1875, 79.0393),\n    (-89.0353, 78.2872),\n    (-90.8043, 78.2153),\n    (-92.8766, 78.3433),\n    (-93.9511, 78.7510),\n    (-93.9357, 79.1137),\n    (-93.1452, 79.3801),\n    (-94.9739, 79.3724),\n    (-96.0761, 79.7050),\n    (-96.7097, 80.1577),\n    (-96.0164, 80.6023),\n    (-91.5870, 81.8942),\n    (-90.1, 82.085),\n    (-88.9322, 82.1175),\n    (-86.9702, 82.2796),\n    (-85.5, 82.6522),\n    (-84.2600, 82.6),\n    (-83.18, 82.32),\n    (-82.42, 82.86),\n    (-81.1, 83.02),\n    (-79.3066, 83.1305),\n    (-76.25, 83.1720),\n    (-75.7187, 83.0640),\n    (-72.8315, 83.2332),\n    (-70.6657, 83.1697),\n    (-68.5, 83.1063),\n    (-65.8273, 83.0280),\n    (-63.68, 82.9),\n    (-61.85, 82.6286),\n    (-61.8938, 82.3616),\n    (-64.334, 81.92775),\n    (-66.7534, 81.7252),\n    (-67.6575, 81.5014),\n    (-65.4803, 81.5065),\n    (-67.84, 80.9),\n    (-69.4697, 80.6168),\n    (-71.18, 79.8),\n    (-73.2428, 79.6341),\n    (-73.88, 79.4301),\n    (-76.9077, 79.3230),\n    (-75.5292, 79.1976),\n    (-76.2204, 79.0190),\n    (-75.3934, 78.5258),\n    (-76.3435, 78.1829),\n    (-77.8885, 77.8999),\n    (-78.3626, 77.5085),\n    (-79.7595, 77.2096),\n    (-79.6196, 76.9833),\n    (-77.9108, 77.0220),\n    (-77.8891, 76.7779),\n    (-80.5612, 76.1781),\n    (-83.1743, 76.4540),\n    (-86.1118, 76.2990),\n    (-87.6, 76.42),\n    (-89.4906, 76.4723),\n    (-89.6161, 76.9521),\n    (-87.7673, 77.1783),\n    (-88.26, 77.9),\n    (-87.65, 77.9702),\n    (-84.9763, 77.5387),\n    (-86.34, 78.18),\n    (-87.9619, 78.3718),\n    (-87.1519, 78.7586),\n    (-85.3786, 78.9969),\n    (-85.0949, 79.3454),\n    (-86.5073, 79.7362),\n    (-86.9317, 80.2514),\n    (-84.1984, 80.2083),\n    (-83.4086, 80.1),\n    (-81.8482, 80.4644),\n    (-84.1, 80.58),\n    (-87.5989, 80.5162),\n    (-89.3666, 80.8556),\n    (-90.2, 81.26),\n    (-91.3678, 81.5531),\n    (-91.5870, 81.8942),\n    (-46.7637, 82.6279),\n    (-43.4064, 83.2251),\n    (-39.8975, 83.1801),\n    (-38.6221, 83.5490),\n    (-35.0878, 83.6451),\n    (-27.1004, 83.5196),\n    (-20.8453, 82.7266),\n    (-22.6918, 82.3416),\n    (-26.5175, 82.2976),\n    (-31.9, 82.2),\n    (-31.3964, 82.0215),\n    (-27.8566, 82.1317),\n    (-24.8444, 81.7869),\n    (-22.9032, 82.0931),\n    (-22.0717, 81.7344),\n    (-23.1696, 81.1527),\n    (-20.6236, 81.5246),\n    (-15.7681, 81.9124),\n    (-12.7701, 81.7188),\n    (-12.2085, 81.2915),\n    (-16.2853, 80.5800),\n    (-16.85, 80.35),\n    (-20.0462, 80.1770),\n    (-17.7303, 80.1291),\n    (-18.9, 79.4),\n    (-19.7049, 78.7512),\n    (-19.6735, 77.6385),\n    (-18.4728, 76.9856),\n    (-20.0350, 76.9443),\n    (-21.6794, 76.6279),\n    (-19.8340, 76.0980),\n    (-19.5989, 75.2483),\n    (-20.6681, 75.1558),\n    (-19.3728, 74.2956),\n    (-21.5942, 74.2238),\n    (-20.4345, 73.8171),\n    (-20.7623, 73.4643),\n    (-22.1722, 73.3095),\n    (-23.5659, 73.3066),\n    (-22.3131, 72.6292),\n    (-22.2995, 72.1840),\n    (-24.2783, 72.5978),\n    (-24.7929, 72.3302),\n    (-23.4429, 72.0801),\n    (-22.1328, 71.4689),\n    (-21.7535, 70.6636),\n    (-23.53603, 70.471),\n    (-24.3070, 70.8564),\n    (-25.5434, 71.4309),\n    (-25.2013, 70.7522),\n    (-26.3627, 70.2264),\n    (-23.7274, 70.1840),\n    (-22.3490, 70.1294),\n    (-25.0292, 69.2588),\n    (-27.7473, 68.4704),\n    (-30.6737, 68.1250),\n    (-31.7766, 68.1207),\n    (-32.8110, 67.7354),\n    (-34.2019, 66.6797),\n    (-36.3528, 65.9789),\n    (-37.0437, 65.9376),\n    (-38.3750, 65.6921),\n    (-39.8122, 65.4584),\n    (-40.6689, 64.8399),\n    (-40.6828, 64.1390),\n    (-41.1887, 63.4824),\n    (-42.8193, 62.6823),\n    (-42.4166, 61.9009),\n    (-42.8661, 61.0740),\n    (-43.3784, 60.0977),\n    (-44.7875, 60.0367),\n    (-46.2636, 60.8532),\n    (-48.2629, 60.8584),\n    (-49.2330, 61.4068),\n    (-49.9003, 62.3833),\n    (-51.6332, 63.6269),\n    (-52.1401, 64.2784),\n    (-52.2765, 65.1767),\n    (-53.6616, 66.0995),\n    (-53.3016, 66.8365),\n    (-53.9691, 67.1889),\n    (-52.9804, 68.3575),\n    (-51.4753, 68.7295),\n    (-51.0804, 69.1478),\n    (-50.8712, 69.9291),\n    (-52.0135, 69.5749),\n    (-52.5579, 69.4261),\n    (-53.4562, 69.2836),\n    (-54.6833, 69.6100),\n    (-54.7500, 70.2893),\n    (-54.3588, 70.8213),\n    (-53.4313, 70.8357),\n    (-51.3901, 70.5697),\n    (-53.1093, 71.2048),\n    (-54.0042, 71.5471),\n    (-55.0, 71.4065),\n    (-55.8346, 71.6544),\n    (-54.7181, 72.5862),\n    (-55.3263, 72.9586),\n    (-56.1200, 73.6497),\n    (-57.3236, 74.7102),\n    (-58.5967, 75.0986),\n    (-58.5851, 75.5172),\n    (-61.2686, 76.1023),\n    (-63.3916, 76.1752),\n    (-66.0642, 76.1348),\n    (-68.5043, 76.0614),\n    (-69.6648, 76.3797),\n    (-71.4025, 77.0085),\n    (-68.7767, 77.3231),\n    (-66.7639, 77.3759),\n    (-71.0429, 77.6359),\n    (-73.297, 78.04419),\n    (-73.1593, 78.4327),\n    (-69.3734, 78.9138),\n    (-65.7107, 79.3943),\n    (-65.3239, 79.7581),\n    (-68.0229, 80.1172),\n    (-67.1512, 80.5158),\n    (-63.6892, 81.2139),\n    (-62.2344, 81.3211),\n    (-62.6511, 81.7704),\n    (-60.2824, 82.0336),\n    (-57.2074, 82.1907),\n    (-54.1344, 82.1996),\n    (-53.0432, 81.8883),\n    (-50.3906, 82.4388),\n    (-48.0038, 82.0648),\n    (-46.5998, 81.9859),\n    (-44.523, 81.6607),\n    (-46.9007, 82.1997),\n    (-46.7637, 82.6279),\n    (-106.6, 73.6),\n    (-105.26, 73.64),\n    (-104.5, 73.42),\n    (-105.38, 72.76),\n    (-106.94, 73.46),\n    (-106.6, 73.6),\n    (-180.0, -84.71338),\n    (-179.9424, -84.7214),\n    (-179.0586, -84.1394),\n    (-177.2567, -84.4529),\n    (-176.0846, -84.0992),\n    (-175.8298, -84.1179),\n    (-174.3825, -84.5343),\n    (-173.1165, -84.1179),\n    (-172.8891, -84.0610),\n    (-169.9512, -83.8846),\n    (-168.9999, -84.1179),\n    (-168.5301, -84.2373),\n    (-167.0220, -84.5704),\n    (-164.1821, -84.8252),\n    (-161.9297, -85.1387),\n    (-158.0713, -85.3739),\n    (-155.1922, -85.0995),\n    (-150.9420, -85.2955),\n    (-148.5330, -85.6090),\n    (-145.8889, -85.3151),\n    (-143.1077, -85.0407),\n    (-142.8922, -84.5704),\n    (-146.8290, -84.5312),\n    (-150.0607, -84.2961),\n    (-150.9029, -83.9042),\n    (-153.5862, -83.6886),\n    (-153.4099, -83.2380),\n    (-153.0377, -82.8265),\n    (-152.6656, -82.4541),\n    (-152.8615, -82.0426),\n    (-154.5262, -81.7683),\n    (-155.2901, -81.4156),\n    (-156.8374, -81.1021),\n    (-154.4087, -81.1609),\n    (-152.0976, -81.0041),\n    (-150.6482, -81.3373),\n    (-148.8659, -81.0433),\n    (-147.2207, -80.6710),\n    (-146.4177, -80.3379),\n    (-146.7702, -79.9264),\n    (-148.0629, -79.6520),\n    (-149.5319, -79.3582),\n    (-151.5884, -79.2993),\n    (-153.3903, -79.1622),\n    (-155.3293, -79.0642),\n    (-155.9756, -78.6919),\n    (-157.2683, -78.3784),\n    (-158.0517, -78.0256),\n    (-158.3651, -76.8892),\n    (-157.8754, -76.9872),\n    (-156.9745, -77.3007),\n    (-155.3293, -77.2027),\n    (-153.7428, -77.0655),\n    (-152.9202, -77.4966),\n    (-151.3337, -77.3987),\n    (-150.0019, -77.1831),\n    (-148.7484, -76.9088),\n    (-147.6124, -76.5757),\n    (-146.1044, -76.4777),\n    (-146.1435, -76.1054),\n    (-146.4960, -75.7331),\n    (-146.2023, -75.3804),\n    (-144.9096, -75.2040),\n    (-144.3220, -75.5371),\n    (-142.7943, -75.3412),\n    (-141.6387, -75.0864),\n    (-140.2090, -75.0668),\n    (-138.8575, -74.9689),\n    (-137.5062, -74.7337),\n    (-136.4289, -74.5182),\n    (-135.2145, -74.3026),\n    (-134.4311, -74.3614),\n    (-133.7456, -74.4398),\n    (-132.2571, -74.3026),\n    (-130.9253, -74.4790),\n    (-129.5542, -74.4594),\n    (-128.2420, -74.3222),\n    (-126.8906, -74.4202),\n    (-125.4020, -74.5182),\n    (-124.0114, -74.4790),\n    (-122.5621, -74.4986),\n    (-121.0736, -74.5182),\n    (-119.7025, -74.4790),\n    (-118.6841, -74.1850),\n    (-117.4698, -74.0283),\n    (-116.2163, -74.2438),\n    (-115.0215, -74.0675),\n    (-113.9443, -73.7148),\n    (-113.2979, -74.0283),\n    (-112.9454, -74.3810),\n    (-112.2990, -74.7141),\n    (-111.2610, -74.4202),\n    (-110.0663, -74.7925),\n    (-108.7149, -74.9101),\n    (-107.5593, -75.1844),\n    (-106.1491, -75.1256),\n    (-104.8760, -74.9493),\n    (-103.3679, -74.9884),\n    (-102.0165, -75.1256),\n    (-100.6455, -75.3020),\n    (-100.1166, -74.8709),\n    (-100.7630, -74.5378),\n    (-101.2527, -74.1850),\n    (-102.5453, -74.1067),\n    (-103.1133, -73.7344),\n    (-103.3287, -73.3620),\n    (-103.6812, -72.6175),\n    (-102.9174, -72.7546),\n    (-101.6052, -72.8134),\n    (-100.3125, -72.7546),\n    (-99.1373, -72.9114),\n    (-98.1188, -73.2053),\n    (-97.6880, -73.5580),\n    (-96.3365, -73.6168),\n    (-95.0439, -73.4797),\n    (-93.6729, -73.2837),\n    (-92.4390, -73.1661),\n    (-91.4205, -73.4013),\n    (-90.0887, -73.3229),\n    (-89.2269, -72.5587),\n    (-88.4239, -73.0093),\n    (-87.2683, -73.1857),\n    (-86.0148, -73.0877),\n    (-85.1922, -73.4797),\n    (-83.8799, -73.5188),\n    (-82.6656, -73.6364),\n    (-81.4709, -73.8519),\n    (-80.6874, -73.4797),\n    (-80.2957, -73.1269),\n    (-79.2968, -73.5188),\n    (-77.9258, -73.4208),\n    (-76.9073, -73.6364),\n    (-76.2218, -73.9695),\n    (-74.8900, -73.8716),\n    (-73.8520, -73.6560),\n    (-72.8335, -73.4013),\n    (-71.6192, -73.2641),\n    (-70.2090, -73.1465),\n    (-68.9359, -73.0093),\n    (-67.9566, -72.7938),\n    (-67.3690, -72.4803),\n    (-67.1340, -72.0492),\n    (-67.2515, -71.6377),\n    (-67.5649, -71.2458),\n    (-67.9174, -70.8539),\n    (-68.2308, -70.4620),\n    (-68.4854, -70.1093),\n    (-68.5442, -69.7173),\n    (-68.4462, -69.3255),\n    (-67.9762, -68.9532),\n    (-67.5844, -68.5417),\n    (-67.4278, -68.1498),\n    (-67.6236, -67.7187),\n    (-67.7411, -67.3268),\n    (-67.2515, -66.8761),\n    (-66.7031, -66.5822),\n    (-66.0568, -66.2099),\n    (-65.3713, -65.8963),\n    (-64.5682, -65.6025),\n    (-64.1765, -65.1714),\n    (-63.6281, -64.8970),\n    (-63.0013, -64.6423),\n    (-62.0416, -64.5835),\n    (-61.4149, -64.2700),\n    (-60.7098, -64.0740),\n    (-59.8872, -63.9565),\n    (-59.1625, -63.7017),\n    (-58.5945, -63.3882),\n    (-57.8111, -63.2706),\n    (-57.2235, -63.5254),\n    (-57.5957, -63.8585),\n    (-58.6141, -64.1524),\n    (-59.0450, -64.3680),\n    (-59.7893, -64.2112),\n    (-60.6119, -64.3092),\n    (-61.2974, -64.5443),\n    (-62.0221, -64.7990),\n    (-62.5117, -65.0930),\n    (-62.6488, -65.4849),\n    (-62.5901, -65.8572),\n    (-62.1200, -66.1903),\n    (-62.8055, -66.4255),\n    (-63.7456, -66.5038),\n    (-64.2941, -66.8370),\n    (-64.8816, -67.1504),\n    (-65.5084, -67.5816),\n    (-65.6650, -67.9538),\n    (-65.3125, -68.3653),\n    (-64.7837, -68.6789),\n    (-63.9611, -68.9139),\n    (-63.1972, -69.2275),\n    (-62.7859, -69.6194),\n    (-62.5705, -69.9917),\n    (-62.2767, -70.3836),\n    (-61.8066, -70.7167),\n    (-61.5129, -71.0890),\n    (-61.3758, -72.0100),\n    (-61.0819, -72.3823),\n    (-61.0036, -72.7742),\n    (-60.6902, -73.1661),\n    (-60.8273, -73.6952),\n    (-61.3758, -74.1067),\n    (-61.9633, -74.4398),\n    (-63.2952, -74.5769),\n    (-63.7456, -74.9297),\n    (-64.3528, -75.2628),\n    (-65.8609, -75.6351),\n    (-67.1928, -75.7919),\n    (-68.4462, -76.0074),\n    (-69.7977, -76.2229),\n    (-70.6007, -76.6344),\n    (-72.2067, -76.6736),\n    (-73.9695, -76.6344),\n    (-75.5559, -76.7128),\n    (-77.2403, -76.7128),\n    (-76.9269, -77.1048),\n    (-75.3992, -77.2810),\n    (-74.2828, -77.5554),\n    (-73.6561, -77.9081),\n    (-74.7725, -78.2216),\n    (-76.4961, -78.1236),\n    (-77.9258, -78.3784),\n    (-77.9846, -78.7899),\n    (-78.0237, -79.1818),\n    (-76.8486, -79.5149),\n    (-76.6332, -79.8872),\n    (-75.3600, -80.2595),\n    (-73.2448, -80.4163),\n    (-71.4429, -80.6906),\n    (-70.0131, -81.0041),\n    (-68.1916, -81.3176),\n    (-65.7042, -81.4744),\n    (-63.2560, -81.7487),\n    (-61.5520, -82.0426),\n    (-59.6914, -82.3758),\n    (-58.7121, -82.8461),\n    (-58.2224, -83.2184),\n    (-57.0081, -82.8656),\n    (-55.3628, -82.5717),\n    (-53.6197, -82.2582),\n    (-51.5436, -82.0035),\n    (-49.7613, -81.7291),\n    (-47.2739, -81.7095),\n    (-44.8257, -81.8467),\n    (-42.8083, -82.0819),\n    (-42.1620, -81.6508),\n    (-40.7714, -81.3568),\n    (-38.2448, -81.3373),\n    (-36.2666, -81.1217),\n    (-34.3863, -80.9061),\n    (-32.3102, -80.7690),\n    (-30.0970, -80.5926),\n    (-28.5498, -80.3379),\n    (-29.2549, -79.9851),\n    (-29.6858, -79.6325),\n    (-29.6858, -79.2602),\n    (-31.6248, -79.2993),\n    (-33.6813, -79.4561),\n    (-35.6399, -79.4561),\n    (-35.9141, -79.0838),\n    (-35.7770, -78.3392),\n    (-35.3265, -78.1236),\n    (-33.8967, -77.8885),\n    (-32.2123, -77.6534),\n    (-30.9980, -77.3595),\n    (-29.7837, -77.0655),\n    (-28.8827, -76.6736),\n    (-27.5117, -76.4973),\n    (-26.1603, -76.3601),\n    (-25.4748, -76.2818),\n    (-23.9275, -76.2425),\n    (-22.4585, -76.1054),\n    (-21.2246, -75.9094),\n    (-20.0103, -75.6743),\n    (-18.9135, -75.4392),\n    (-17.5229, -75.1256),\n    (-16.6415, -74.7925),\n    (-15.7014, -74.4986),\n    (-15.4077, -74.1067),\n    (-16.4653, -73.8716),\n    (-16.1127, -73.4601),\n    (-15.4468, -73.1465),\n    (-14.4088, -72.9505),\n    (-13.3119, -72.7154),\n    (-12.2935, -72.4019),\n    (-11.5100, -72.0100),\n    (-11.0204, -71.5397),\n    (-10.2957, -71.2654),\n    (-9.1010, -71.3242),\n    (-8.6113, -71.6573),\n    (-7.4166, -71.6965),\n    (-7.3774, -71.3242),\n    (-6.8682, -70.9323),\n    (-5.7909, -71.0302),\n    (-5.5363, -71.4026),\n    (-4.3416, -71.4613),\n    (-3.0489, -71.2850),\n    (-1.7954, -71.1674),\n    (-0.6594, -71.2262),\n    (-0.2286, -71.6377),\n    (0.8681, -71.3046),\n    (1.8866, -71.1282),\n    (3.0226, -70.9911),\n    (4.1390, -70.8539),\n    (5.1575, -70.6187),\n    (6.2739, -70.4620),\n    (7.1357, -70.2465),\n    (7.7428, -69.8937),\n    (8.4871, -70.1485),\n    (9.5251, -70.0113),\n    (10.2498, -70.4816),\n    (10.8178, -70.8343),\n    (11.9538, -70.6383),\n    (12.4042, -70.2465),\n    (13.4227, -69.9721),\n    (14.7349, -70.0309),\n    (15.1267, -70.4032),\n    (15.9493, -70.0309),\n    (17.0265, -69.9133),\n    (18.2017, -69.8741),\n    (19.2593, -69.8937),\n    (20.3757, -70.0113),\n    (21.4529, -70.0701),\n    (21.9230, -70.4032),\n    (22.5694, -70.6971),\n    (23.6661, -70.5208),\n    (24.8413, -70.4816),\n    (25.9773, -70.4816),\n    (27.0937, -70.4620),\n    (28.0925, -70.3248),\n    (29.1502, -70.2072),\n    (30.0315, -69.9329),\n    (30.9717, -69.7566),\n    (31.9901, -69.6586),\n    (32.7540, -69.3842),\n    (33.3024, -68.8356),\n    (33.8704, -68.5025),\n    (34.9084, -68.6592),\n    (35.3002, -69.0120),\n    (36.1620, -69.2471),\n    (37.2000, -69.1687),\n    (37.9051, -69.5214),\n    (38.6494, -69.7762),\n    (39.6678, -69.5410),\n    (40.0204, -69.1099),\n    (40.9213, -68.9336),\n    (41.9594, -68.6005),\n    (42.9387, -68.4633),\n    (44.1138, -68.2674),\n    (44.8972, -68.0518),\n    (45.7199, -67.8167),\n    (46.5033, -67.6011),\n    (47.4434, -67.7187),\n    (48.3444, -67.3660),\n    (48.9907, -67.0917),\n    (49.9308, -67.1113),\n    (50.7534, -66.8761),\n    (50.9493, -66.5234),\n    (51.7915, -66.2491),\n    (52.6141, -66.0531),\n    (53.6130, -65.8963),\n    (54.5335, -65.8180),\n    (55.4149, -65.8768),\n    (56.3550, -65.9747),\n    (57.1580, -66.2491),\n    (57.2559, -66.6802),\n    (58.1373, -67.0133),\n    (58.7445, -67.2876),\n    (59.9393, -67.4052),\n    (60.6052, -67.6795),\n    (61.4278, -67.9538),\n    (62.3874, -68.0126),\n    (63.1904, -67.8167),\n    (64.0523, -67.4052),\n    (64.9924, -67.6207),\n    (65.9717, -67.7383),\n    (66.9118, -67.8559),\n    (67.8911, -67.9343),\n    (68.8900, -67.9343),\n    (69.7126, -68.9727),\n    (69.6734, -69.2275),\n    (69.5559, -69.6782),\n    (68.5962, -69.9329),\n    (67.8127, -70.3052),\n    (67.9498, -70.6971),\n    (69.0663, -70.6775),\n    (68.9291, -71.0694),\n    (68.4199, -71.4417),\n    (67.9498, -71.8532),\n    (68.7137, -72.1668),\n    (69.8693, -72.2647),\n    (71.0248, -72.0884),\n    (71.5732, -71.6965),\n    (71.9062, -71.3242),\n    (72.4546, -71.0107),\n    (73.0814, -70.7167),\n    (73.3360, -70.3640),\n    (73.8648, -69.8741),\n    (74.4915, -69.7762),\n    (75.6275, -69.7370),\n    (76.6264, -69.6194),\n    (77.6449, -69.4626),\n    (78.1345, -69.0707),\n    (78.4283, -68.6984),\n    (79.1138, -68.3262),\n    (80.0931, -68.0715),\n    (80.9353, -67.8755),\n    (81.4837, -67.5423),\n    (82.0517, -67.3660),\n    (82.7764, -67.2092),\n    (83.7753, -67.3072),\n    (84.6762, -67.2092),\n    (85.6555, -67.0917),\n    (86.7523, -67.1504),\n    (87.4770, -66.8761),\n    (87.9862, -66.2099),\n    (88.3584, -66.4842),\n    (88.8284, -66.9545),\n    (89.6706, -67.1504),\n    (90.6303, -67.2288),\n    (91.5900, -67.1113),\n    (92.6085, -67.1896),\n    (93.5486, -67.2092),\n    (94.1754, -67.1113),\n    (95.0175, -67.1701),\n    (95.7814, -67.3856),\n    (96.6823, -67.2485),\n    (97.7596, -67.2485),\n    (98.6802, -67.1113),\n    (99.7181, -67.2485),\n    (100.3841, -66.9153),\n    (100.8933, -66.5822),\n    (101.5788, -66.3078),\n    (102.8324, -65.5632),\n    (103.4786, -65.7004),\n    (104.2425, -65.9747),\n    (104.9084, -66.3275),\n    (106.1815, -66.9349),\n    (107.1608, -66.9545),\n    (108.0813, -66.9545),\n    (109.1586, -66.8370),\n    (110.2358, -66.6998),\n    (111.0584, -66.4255),\n    (111.7439, -66.1315),\n    (112.8603, -66.0923),\n    (113.6046, -65.8768),\n    (114.3880, -66.0727),\n    (114.8973, -66.3862),\n    (115.6023, -66.6998),\n    (116.6991, -66.6606),\n    (117.3847, -66.9153),\n    (118.5794, -67.1701),\n    (119.8329, -67.2680),\n    (120.8709, -67.1896),\n    (121.6544, -66.8761),\n    (122.3203, -66.5626),\n    (123.2212, -66.4842),\n    (124.1222, -66.6214),\n    (125.1602, -66.7193),\n    (126.1003, -66.5626),\n    (127.0014, -66.5626),\n    (127.8827, -66.6606),\n    (128.8032, -66.7586),\n    (129.7042, -66.5822),\n    (130.7814, -66.4255),\n    (131.7999, -66.3862),\n    (132.9358, -66.3862),\n    (133.8564, -66.2883),\n    (134.7573, -66.2099),\n    (135.0315, -65.7200),\n    (135.0707, -65.3085),\n    (135.6974, -65.5828),\n    (135.8738, -66.0335),\n    (136.2067, -66.4450),\n    (136.6180, -66.7781),\n    (137.4602, -66.9545),\n    (138.5962, -66.8957),\n    (139.9084, -66.8761),\n    (140.8094, -66.8173),\n    (142.1216, -66.8173),\n    (143.0618, -66.7977),\n    (144.3740, -66.8370),\n    (145.4904, -66.9153),\n    (146.1955, -67.2288),\n    (145.9996, -67.6011),\n    (146.6460, -67.8951),\n    (147.7232, -68.1302),\n    (148.8396, -68.3850),\n    (150.1323, -68.5612),\n    (151.4837, -68.7181),\n    (152.5022, -68.8748),\n    (153.6381, -68.8945),\n    (154.2845, -68.5612),\n    (155.1658, -68.8356),\n    (155.9297, -69.1492),\n    (156.8111, -69.3842),\n    (158.0255, -69.4822),\n    (159.1810, -69.5998),\n    (159.6706, -69.9917),\n    (160.8066, -70.2268),\n    (161.5704, -70.5796),\n    (162.6868, -70.7363),\n    (163.8424, -70.7167),\n    (164.9196, -70.7755),\n    (166.1144, -70.7559),\n    (167.3090, -70.8343),\n    (168.4256, -70.9714),\n    (169.4635, -71.2066),\n    (170.5016, -71.4026),\n    (171.2067, -71.6965),\n    (171.0892, -72.0884),\n    (170.5604, -72.4411),\n    (170.1099, -72.8918),\n    (169.7573, -73.2445),\n    (169.2873, -73.6560),\n    (167.9751, -73.8128),\n    (167.3874, -74.1654),\n    (166.0948, -74.3810),\n    (165.6443, -74.7729),\n    (164.9588, -75.1452),\n    (164.2341, -75.4588),\n    (163.8227, -75.8703),\n    (163.5682, -76.2425),\n    (163.4702, -76.6933),\n    (163.4898, -77.0655),\n    (164.0578, -77.4574),\n    (164.2733, -77.8297),\n    (164.7434, -78.1825),\n    (166.6041, -78.3196),\n    (166.9957, -78.7507),\n    (165.1938, -78.9074),\n    (163.6662, -79.1230),\n    (161.7663, -79.1622),\n    (160.9241, -79.7304),\n    (160.7478, -80.2007),\n    (160.3169, -80.5730),\n    (159.7882, -80.9453),\n    (161.1200, -81.2785),\n    (161.6292, -81.6900),\n    (162.4909, -82.0622),\n    (163.7053, -82.3954),\n    (165.0959, -82.7089),\n    (166.6041, -83.0224),\n    (168.8956, -83.3359),\n    (169.4047, -83.8258),\n    (172.2839, -84.0414),\n    (172.4770, -84.1179),\n    (173.2240, -84.4137),\n    (175.9856, -84.1589),\n    (178.2772, -84.4725),\n    (180.0, -84.71338),\n];\n\npub const WORLD_LOW_RESOLUTION: [(f64, f64); 1166] = [\n    (-92.32, 48.24),\n    (-88.13, 48.92),\n    (-83.11, 46.27),\n    (-81.66, 44.76),\n    (-82.09, 42.29),\n    (-77.10, 44.00),\n    (-69.95, 46.92),\n    (-65.92, 45.32),\n    (-66.37, 44.25),\n    (-61.22, 45.43),\n    (-64.94, 47.34),\n    (-64.12, 48.52),\n    (-70.68, 47.02),\n    (-67.24, 49.33),\n    (-59.82, 50.48),\n    (-56.14, 52.46),\n    (-59.07, 53.58),\n    (-58.26, 54.21),\n    (-60.69, 55.33),\n    (-61.97, 57.41),\n    (-64.35, 59.49),\n    (-67.29, 58.15),\n    (-69.89, 59.91),\n    (-71.31, 61.45),\n    (-78.22, 61.97),\n    (-77.28, 59.53),\n    (-77.09, 55.88),\n    (-79.06, 51.68),\n    (-82.23, 52.70),\n    (-86.75, 55.72),\n    (-92.17, 56.86),\n    (-95.61, 58.82),\n    (-92.66, 62.02),\n    (-90.65, 63.24),\n    (-95.96, 64.12),\n    (-89.88, 63.98),\n    (-89.30, 65.22),\n    (-86.86, 66.12),\n    (-84.54, 66.88),\n    (-82.30, 67.76),\n    (-83.10, 69.68),\n    (-86.05, 67.98),\n    (-88.18, 68.20),\n    (-91.00, 68.82),\n    (-91.72, 69.69),\n    (-93.15, 71.09),\n    (-96.58, 71.05),\n    (-93.35, 69.52),\n    (-94.23, 68.25),\n    (-95.96, 66.73),\n    (-98.83, 68.27),\n    (-102.45, 67.69),\n    (-108.34, 68.43),\n    (-105.83, 68.05),\n    (-108.15, 66.60),\n    (-111.15, 67.63),\n    (-114.10, 68.23),\n    (-120.92, 69.44),\n    (-124.32, 69.26),\n    (-128.76, 70.50),\n    (-131.86, 69.19),\n    (-131.15, 69.79),\n    (-135.81, 69.13),\n    (-140.19, 69.37),\n    (-141.20, 69.58),\n    (-141.21, 69.56),\n    (-142.49, 69.83),\n    (-148.09, 70.26),\n    (-154.37, 70.96),\n    (-159.53, 70.38),\n    (-166.64, 68.25),\n    (-161.56, 66.55),\n    (-162.99, 65.97),\n    (-168.23, 65.49),\n    (-161.12, 64.49),\n    (-165.29, 62.57),\n    (-164.58, 60.06),\n    (-162.06, 58.36),\n    (-157.85, 58.12),\n    (-162.34, 55.06),\n    (-156.52, 57.11),\n    (-153.53, 59.32),\n    (-149.18, 60.81),\n    (-149.90, 59.50),\n    (-146.54, 60.36),\n    (-139.98, 59.73),\n    (-137.12, 58.28),\n    (-136.01, 59.12),\n    (-133.84, 57.12),\n    (-131.46, 55.98),\n    (-132.08, 57.20),\n    (-140.37, 60.25),\n    (-141.21, 60.16),\n    (-133.38, 58.93),\n    (-130.88, 54.83),\n    (-128.86, 53.90),\n    (-126.58, 52.12),\n    (-127.08, 50.80),\n    (-124.42, 49.66),\n    (-122.56, 48.91),\n    (-122.44, 48.92),\n    (-124.42, 47.18),\n    (-124.52, 42.48),\n    (-123.09, 38.45),\n    (-121.73, 36.62),\n    (-117.60, 33.34),\n    (-117.28, 32.64),\n    (-117.29, 32.48),\n    (-114.75, 27.80),\n    (-112.53, 24.80),\n    (-110.55, 24.07),\n    (-114.23, 29.59),\n    (-112.58, 29.99),\n    (-109.57, 25.94),\n    (-105.61, 21.94),\n    (-102.09, 17.87),\n    (-95.75, 15.94),\n    (-92.21, 14.97),\n    (-92.22, 14.71),\n    (-86.74, 12.06),\n    (-83.03, 8.65),\n    (-79.93, 8.74),\n    (-77.00, 7.82),\n    (-81.99, 8.97),\n    (-83.92, 12.70),\n    (-86.33, 15.80),\n    (-88.40, 15.92),\n    (-88.45, 17.42),\n    (-87.01, 21.33),\n    (-91.65, 18.72),\n    (-96.96, 20.37),\n    (-97.65, 25.67),\n    (-97.62, 25.82),\n    (-95.62, 28.84),\n    (-90.77, 29.03),\n    (-87.33, 30.22),\n    (-82.69, 28.15),\n    (-80.16, 26.66),\n    (-80.74, 32.31),\n    (-76.89, 35.43),\n    (-76.47, 38.21),\n    (-75.66, 37.67),\n    (-71.31, 41.76),\n    (-69.44, 44.17),\n    (-67.69, 47.03),\n    (-73.18, 45.14),\n    (-79.26, 43.28),\n    (-82.84, 42.59),\n    (-83.49, 45.32),\n    (-86.36, 43.65),\n    (-87.75, 43.42),\n    (-86.01, 45.96),\n    (-87.00, 46.59),\n    (-91.39, 46.79),\n    (-90.05, 47.96),\n    (-152.62, 58.41),\n    (-152.60, 58.40),\n    (-153.30, 57.80),\n    (-152.40, 57.48),\n    (-153.32, 57.79),\n    (-166.96, 53.96),\n    (-167.01, 53.95),\n    (-168.36, 53.50),\n    (-168.19, 53.36),\n    (-170.73, 52.68),\n    (-170.60, 52.55),\n    (-174.47, 51.94),\n    (-174.47, 51.92),\n    (-176.58, 51.71),\n    (-176.64, 51.73),\n    (-177.55, 51.76),\n    (-177.41, 51.63),\n    (-178.27, 51.75),\n    (177.35, 51.80),\n    (177.33, 51.76),\n    (172.44, 53.00),\n    (172.55, 53.03),\n    (-123.40, 48.33),\n    (-128.00, 50.84),\n    (-123.50, 48.34),\n    (-132.49, 52.88),\n    (-132.44, 52.91),\n    (-132.64, 53.02),\n    (-131.97, 53.71),\n    (-132.63, 53.02),\n    (-55.36, 51.56),\n    (-54.66, 49.52),\n    (-53.65, 47.48),\n    (-52.98, 46.31),\n    (-56.12, 46.84),\n    (-58.47, 47.57),\n    (-57.61, 50.38),\n    (-55.39, 51.53),\n    (-61.37, 49.01),\n    (-61.80, 49.29),\n    (-61.38, 49.03),\n    (-63.01, 46.71),\n    (-64.42, 46.61),\n    (-63.04, 46.68),\n    (-60.14, 46.48),\n    (-60.14, 46.50),\n    (-71.97, 41.11),\n    (-71.97, 41.15),\n    (-80.79, 27.03),\n    (-81.01, 26.99),\n    (-113.01, 42.09),\n    (-113.10, 42.01),\n    (-155.74, 20.02),\n    (-155.73, 19.98),\n    (-156.51, 20.78),\n    (-156.51, 20.78),\n    (-157.12, 21.21),\n    (-157.08, 20.95),\n    (-157.87, 21.42),\n    (-159.53, 22.07),\n    (-117.44, 66.46),\n    (-119.59, 65.24),\n    (-123.95, 65.03),\n    (-123.69, 66.44),\n    (-119.21, 66.22),\n    (-117.44, 66.44),\n    (-120.71, 64.03),\n    (-114.91, 62.30),\n    (-109.07, 62.72),\n    (-112.62, 61.19),\n    (-118.68, 61.19),\n    (-117.01, 61.17),\n    (-115.97, 62.56),\n    (-119.46, 64.00),\n    (-120.59, 63.94),\n    (-112.31, 58.46),\n    (-108.90, 59.44),\n    (-104.14, 58.90),\n    (-102.56, 56.72),\n    (-101.82, 58.73),\n    (-104.65, 58.91),\n    (-111.00, 58.51),\n    (-112.35, 58.62),\n    (-98.74, 50.09),\n    (-99.75, 52.24),\n    (-99.62, 51.47),\n    (-98.82, 50.39),\n    (-97.02, 50.21),\n    (-97.50, 54.02),\n    (-98.69, 52.93),\n    (-97.19, 51.09),\n    (-96.98, 50.20),\n    (-95.34, 49.04),\n    (-92.32, 50.34),\n    (-94.14, 49.47),\n    (-95.36, 48.82),\n    (-80.39, 56.16),\n    (-79.22, 55.94),\n    (-80.34, 56.08),\n    (-103.56, 58.60),\n    (-103.60, 58.58),\n    (-101.82, 58.03),\n    (-102.33, 58.10),\n    (-101.77, 58.06),\n    (-101.88, 55.79),\n    (-97.92, 57.15),\n    (-101.22, 55.85),\n    (-101.88, 55.74),\n    (-77.61, 6.80),\n    (-78.70, 0.97),\n    (-80.75, -4.47),\n    (-76.19, -14.57),\n    (-70.44, -18.75),\n    (-70.68, -26.15),\n    (-71.44, -32.03),\n    (-73.38, -37.27),\n    (-73.06, -42.11),\n    (-73.17, -46.09),\n    (-73.52, -48.05),\n    (-73.67, -51.56),\n    (-71.06, -53.88),\n    (-69.14, -50.77),\n    (-67.51, -46.59),\n    (-63.49, -42.80),\n    (-62.14, -40.16),\n    (-57.12, -36.71),\n    (-53.17, -34.15),\n    (-51.26, -32.02),\n    (-48.16, -25.48),\n    (-40.73, -22.32),\n    (-38.88, -15.24),\n    (-34.60, -7.81),\n    (-41.95, -3.42),\n    (-48.02, -1.84),\n    (-48.44, -1.57),\n    (-50.81, 0.00),\n    (-54.47, 5.39),\n    (-60.59, 8.32),\n    (-64.19, 9.88),\n    (-70.78, 10.64),\n    (-70.97, 11.89),\n    (-76.26, 8.76),\n    (-77.61, 6.80),\n    (-69.14, -52.79),\n    (-66.16, -55.08),\n    (-70.01, -54.88),\n    (-70.55, -53.85),\n    (-59.29, -51.58),\n    (-59.35, -51.54),\n    (-58.65, -51.55),\n    (-58.55, -51.56),\n    (-84.39, 21.44),\n    (-73.90, 19.73),\n    (-79.27, 21.18),\n    (-83.74, 21.80),\n    (-84.32, 21.42),\n    (-66.96, 17.95),\n    (-67.05, 17.89),\n    (-77.88, 17.22),\n    (-78.06, 16.98),\n    (-74.47, 18.08),\n    (-69.88, 18.99),\n    (-71.10, 17.76),\n    (-74.45, 17.86),\n    (-85.28, 73.74),\n    (-85.79, 70.96),\n    (-85.13, 71.94),\n    (-84.74, 72.96),\n    (-80.61, 73.10),\n    (-78.45, 72.20),\n    (-75.44, 72.55),\n    (-73.89, 71.98),\n    (-72.56, 71.04),\n    (-71.49, 70.57),\n    (-69.78, 70.29),\n    (-68.12, 69.71),\n    (-65.91, 69.19),\n    (-66.92, 68.39),\n    (-64.08, 67.68),\n    (-62.50, 66.68),\n    (-63.07, 65.33),\n    (-66.11, 66.08),\n    (-67.48, 65.41),\n    (-64.05, 63.15),\n    (-66.58, 63.26),\n    (-69.04, 62.33),\n    (-72.22, 63.77),\n    (-76.88, 64.17),\n    (-73.25, 65.54),\n    (-70.09, 66.64),\n    (-72.05, 67.44),\n    (-76.32, 68.36),\n    (-78.34, 70.17),\n    (-82.12, 69.71),\n    (-87.64, 70.12),\n    (-89.68, 71.43),\n    (-85.28, 73.74),\n    (-80.90, 76.10),\n    (-84.21, 76.28),\n    (-88.94, 76.38),\n    (-85.47, 77.40),\n    (-85.43, 77.93),\n    (-87.01, 78.54),\n    (-83.17, 78.94),\n    (-84.87, 79.93),\n    (-81.33, 79.82),\n    (-76.27, 80.92),\n    (-82.88, 80.62),\n    (-82.58, 81.16),\n    (-86.51, 81.05),\n    (-89.36, 81.21),\n    (-90.45, 81.38),\n    (-89.28, 81.86),\n    (-87.21, 82.30),\n    (-80.51, 82.05),\n    (-80.16, 82.55),\n    (-77.83, 82.86),\n    (-75.51, 83.05),\n    (-71.18, 82.90),\n    (-65.10, 82.78),\n    (-63.34, 81.80),\n    (-68.26, 81.26),\n    (-69.46, 80.34),\n    (-71.05, 79.82),\n    (-74.40, 79.46),\n    (-75.42, 79.03),\n    (-75.48, 78.92),\n    (-76.01, 78.20),\n    (-80.66, 77.28),\n    (-78.07, 76.98),\n    (-80.90, 76.13),\n    (-92.86, 74.13),\n    (-92.50, 72.70),\n    (-94.89, 73.16),\n    (-92.96, 74.14),\n    (-94.80, 76.95),\n    (-89.68, 76.04),\n    (-88.52, 75.40),\n    (-82.36, 75.67),\n    (-79.39, 74.65),\n    (-86.15, 74.22),\n    (-91.70, 74.94),\n    (-95.60, 76.91),\n    (-94.87, 76.96),\n    (-99.96, 73.74),\n    (-97.89, 72.90),\n    (-98.28, 71.13),\n    (-102.04, 72.92),\n    (-101.34, 73.14),\n    (-99.69, 73.59),\n    (-107.58, 73.25),\n    (-104.59, 71.02),\n    (-101.71, 69.56),\n    (-104.07, 68.62),\n    (-106.61, 69.12),\n    (-114.09, 69.05),\n    (-113.89, 70.12),\n    (-115.88, 70.32),\n    (-116.10, 71.32),\n    (-117.45, 72.48),\n    (-113.53, 72.44),\n    (-109.84, 72.24),\n    (-106.62, 71.71),\n    (-107.43, 73.04),\n    (-120.96, 74.29),\n    (-118.37, 72.53),\n    (-123.06, 71.18),\n    (-123.40, 73.77),\n    (-120.93, 74.27),\n    (-108.83, 76.74),\n    (-106.25, 75.54),\n    (-107.08, 74.78),\n    (-112.99, 74.16),\n    (-112.28, 74.99),\n    (-116.04, 75.33),\n    (-115.27, 76.20),\n    (-110.95, 75.56),\n    (-109.77, 76.31),\n    (-108.82, 76.70),\n    (-115.70, 77.46),\n    (-118.10, 76.30),\n    (-121.13, 76.37),\n    (-116.04, 77.28),\n    (-110.01, 77.86),\n    (-112.36, 77.68),\n    (-109.96, 77.86),\n    (-109.60, 78.48),\n    (-112.20, 78.01),\n    (-109.60, 78.48),\n    (-97.87, 76.61),\n    (-99.21, 75.31),\n    (-100.86, 75.60),\n    (-99.40, 76.26),\n    (-97.79, 76.60),\n    (-94.72, 75.53),\n    (-94.66, 75.52),\n    (-104.10, 79.01),\n    (-99.19, 77.54),\n    (-103.22, 78.08),\n    (-104.30, 78.95),\n    (-93.74, 77.52),\n    (-93.74, 77.52),\n    (-96.88, 78.50),\n    (-96.91, 77.77),\n    (-96.94, 78.48),\n    (-84.69, 65.84),\n    (-81.58, 63.87),\n    (-85.00, 62.96),\n    (-84.63, 65.71),\n    (-81.84, 62.75),\n    (-82.01, 62.63),\n    (-79.88, 62.12),\n    (-79.88, 62.12),\n    (-43.53, 59.89),\n    (-45.29, 60.67),\n    (-47.91, 60.83),\n    (-49.90, 62.41),\n    (-50.71, 64.42),\n    (-51.39, 64.94),\n    (-52.96, 66.09),\n    (-53.62, 67.19),\n    (-53.51, 67.51),\n    (-51.84, 68.65),\n    (-52.19, 70.00),\n    (-51.85, 71.03),\n    (-55.41, 71.41),\n    (-54.63, 72.97),\n    (-56.98, 74.70),\n    (-61.95, 76.09),\n    (-66.38, 75.83),\n    (-71.13, 77.00),\n    (-66.81, 77.60),\n    (-70.78, 77.78),\n    (-64.96, 79.70),\n    (-63.38, 81.16),\n    (-56.89, 82.17),\n    (-48.18, 82.15),\n    (-42.08, 82.74),\n    (-38.02, 83.54),\n    (-23.96, 82.94),\n    (-25.97, 81.97),\n    (-25.99, 80.64),\n    (-13.57, 80.97),\n    (-16.60, 80.16),\n    (-19.82, 78.82),\n    (-18.80, 77.54),\n    (-21.98, 76.46),\n    (-20.69, 75.12),\n    (-21.78, 74.40),\n    (-24.10, 73.69),\n    (-26.54, 73.08),\n    (-24.63, 72.69),\n    (-21.84, 71.69),\n    (-24.62, 71.24),\n    (-27.16, 70.89),\n    (-27.21, 70.00),\n    (-24.10, 69.35),\n    (-28.35, 68.43),\n    (-32.48, 68.56),\n    (-35.26, 66.26),\n    (-37.90, 65.90),\n    (-40.04, 65.00),\n    (-40.49, 64.04),\n    (-42.01, 63.14),\n    (-42.88, 61.15),\n    (-43.09, 60.07),\n    (-43.56, 59.90),\n    (-16.26, 66.41),\n    (-15.32, 64.29),\n    (-20.14, 63.47),\n    (-21.76, 64.21),\n    (-21.33, 64.97),\n    (-23.04, 65.62),\n    (-21.76, 66.26),\n    (-18.77, 66.12),\n    (-16.23, 66.35),\n    (0.56, 51.47),\n    (-1.71, 54.94),\n    (-3.41, 57.52),\n    (-5.42, 58.14),\n    (-5.77, 55.59),\n    (-3.48, 54.82),\n    (-4.68, 52.88),\n    (-2.68, 51.58),\n    (-3.80, 50.08),\n    (1.26, 51.14),\n    (0.65, 51.41),\n    (-7.17, 54.91),\n    (-9.97, 53.47),\n    (-8.52, 51.76),\n    (-5.69, 54.79),\n    (-7.34, 55.25),\n    (-1.33, 60.66),\n    (-1.17, 60.38),\n    (-6.18, 58.44),\n    (-6.09, 58.36),\n    (-6.47, 57.58),\n    (-6.33, 57.54),\n    (-7.30, 57.54),\n    (-7.46, 57.05),\n    (-6.54, 56.94),\n    (-6.00, 55.94),\n    (-5.09, 55.55),\n    (-4.44, 54.38),\n    (-4.30, 54.19),\n    (-8.08, 71.02),\n    (-8.21, 70.86),\n    (16.92, 79.52),\n    (22.26, 78.46),\n    (16.86, 76.41),\n    (16.00, 77.39),\n    (16.03, 77.92),\n    (16.81, 79.50),\n    (14.71, 79.40),\n    (16.05, 79.12),\n    (14.02, 77.80),\n    (13.56, 78.46),\n    (12.63, 79.26),\n    (14.68, 79.40),\n    (22.01, 78.24),\n    (21.86, 78.23),\n    (21.54, 77.75),\n    (23.88, 77.26),\n    (21.53, 77.67),\n    (22.79, 77.79),\n    (23.50, 79.97),\n    (28.24, 79.54),\n    (20.85, 78.94),\n    (19.00, 79.34),\n    (21.05, 79.88),\n    (23.41, 79.96),\n    (46.98, 80.23),\n    (43.13, 79.97),\n    (47.18, 80.22),\n    (50.43, 80.19),\n    (50.55, 79.88),\n    (47.77, 79.86),\n    (50.45, 80.14),\n    (61.79, 80.18),\n    (61.79, 80.18),\n    (65.08, 80.69),\n    (64.27, 80.59),\n    (65.13, 80.68),\n    (-5.13, 35.66),\n    (4.06, 36.63),\n    (10.40, 37.12),\n    (11.36, 33.61),\n    (20.10, 30.10),\n    (23.49, 32.17),\n    (31.65, 30.80),\n    (35.76, 23.74),\n    (39.75, 14.82),\n    (42.93, 11.34),\n    (51.52, 11.45),\n    (49.82, 6.99),\n    (43.13, -0.62),\n    (39.15, -7.58),\n    (40.37, -13.20),\n    (37.74, -18.17),\n    (35.33, -22.71),\n    (32.84, -28.15),\n    (26.50, -34.39),\n    (19.55, -35.51),\n    (17.50, -30.88),\n    (12.24, -18.75),\n    (13.89, -12.81),\n    (12.05, -5.55),\n    (9.67, 0.14),\n    (7.19, 3.79),\n    (1.74, 5.39),\n    (-4.77, 4.59),\n    (-12.00, 6.75),\n    (-15.54, 10.98),\n    (-16.33, 15.50),\n    (-16.10, 22.29),\n    (-12.90, 27.12),\n    (-9.52, 31.09),\n    (-5.41, 35.58),\n    (33.71, 0.00),\n    (33.48, -3.42),\n    (33.34, -0.20),\n    (33.71, 0.00),\n    (49.30, -12.50),\n    (49.28, -18.79),\n    (43.95, -25.50),\n    (44.37, -20.08),\n    (46.34, -16.31),\n    (47.91, -14.08),\n    (49.30, -12.50),\n    (178.88, 69.10),\n    (181.20, 68.42),\n    (183.52, 67.78),\n    (188.87, 66.38),\n    (186.54, 64.74),\n    (182.87, 65.63),\n    (180.13, 65.14),\n    (179.48, 64.88),\n    (178.20, 64.29),\n    (177.46, 62.62),\n    (170.42, 60.17),\n    (164.48, 59.89),\n    (162.92, 57.34),\n    (161.82, 54.88),\n    (156.42, 51.09),\n    (156.40, 57.76),\n    (163.79, 61.73),\n    (159.90, 60.73),\n    (156.81, 61.68),\n    (153.83, 59.10),\n    (148.57, 59.46),\n    (140.77, 58.39),\n    (137.10, 54.07),\n    (140.72, 52.43),\n    (138.77, 47.30),\n    (129.92, 42.04),\n    (128.33, 38.46),\n    (126.15, 35.18),\n    (125.12, 39.08),\n    (121.62, 40.15),\n    (117.58, 38.21),\n    (121.77, 36.90),\n    (120.73, 32.65),\n    (121.28, 30.25),\n    (118.83, 24.93),\n    (112.69, 21.81),\n    (108.53, 21.73),\n    (107.55, 16.34),\n    (107.32, 10.45),\n    (104.39, 10.37),\n    (100.01, 13.52),\n    (100.26, 8.30),\n    (103.22, 1.56),\n    (98.21, 9.17),\n    (97.66, 15.36),\n    (94.21, 17.79),\n    (90.05, 21.74),\n    (90.06, 21.03),\n    (82.06, 15.95),\n    (80.05, 11.72),\n    (76.41, 8.60),\n    (72.79, 17.43),\n    (72.02, 20.00),\n    (68.98, 21.99),\n    (64.62, 24.41),\n    (57.83, 24.77),\n    (53.11, 26.20),\n    (49.67, 29.41),\n    (50.96, 25.15),\n    (54.33, 23.44),\n    (59.03, 22.57),\n    (57.87, 18.86),\n    (52.95, 15.74),\n    (47.26, 12.96),\n    (42.75, 14.68),\n    (39.93, 19.61),\n    (36.92, 25.78),\n    (33.30, 28.46),\n    (32.60, 30.63),\n    (32.18, 30.58),\n    (36.08, 35.03),\n    (32.53, 36.17),\n    (27.77, 36.94),\n    (26.51, 39.18),\n    (31.54, 40.82),\n    (38.53, 40.48),\n    (40.35, 43.17),\n    (39.88, 46.45),\n    (35.18, 44.99),\n    (33.50, 44.96),\n    (30.24, 45.14),\n    (28.70, 41.48),\n    (26.55, 39.84),\n    (23.62, 39.67),\n    (23.80, 37.34),\n    (21.90, 36.92),\n    (18.79, 42.02),\n    (14.52, 44.31),\n    (14.58, 42.25),\n    (18.32, 39.57),\n    (16.05, 39.35),\n    (11.52, 42.36),\n    (6.87, 43.08),\n    (2.80, 41.09),\n    (-1.11, 37.14),\n    (-6.24, 36.70),\n    (-8.67, 39.57),\n    (-6.51, 43.13),\n    (-0.84, 45.55),\n    (-3.93, 48.40),\n    (0.48, 49.09),\n    (4.20, 51.29),\n    (6.44, 52.92),\n    (8.42, 55.94),\n    (11.72, 55.49),\n    (11.73, 53.66),\n    (16.78, 54.14),\n    (21.40, 56.32),\n    (24.67, 57.20),\n    (28.94, 59.18),\n    (24.16, 59.52),\n    (22.07, 62.66),\n    (23.76, 65.35),\n    (18.70, 62.54),\n    (19.11, 59.67),\n    (18.40, 58.54),\n    (15.34, 55.73),\n    (11.74, 58.08),\n    (8.37, 57.68),\n    (5.80, 59.20),\n    (7.38, 60.86),\n    (7.51, 61.86),\n    (9.62, 62.99),\n    (13.37, 65.46),\n    (15.46, 67.12),\n    (18.54, 68.62),\n    (22.32, 69.64),\n    (24.77, 70.17),\n    (25.93, 69.79),\n    (28.56, 70.46),\n    (29.75, 69.76),\n    (33.83, 69.11),\n    (41.90, 66.85),\n    (35.14, 66.25),\n    (33.30, 66.07),\n    (35.46, 64.15),\n    (37.68, 64.03),\n    (41.71, 64.09),\n    (44.80, 65.58),\n    (44.87, 68.16),\n    (45.92, 66.83),\n    (51.79, 67.85),\n    (53.70, 67.89),\n    (59.68, 68.09),\n    (65.07, 69.08),\n    (68.56, 69.19),\n    (68.38, 70.97),\n    (73.03, 71.62),\n    (73.80, 68.29),\n    (69.42, 66.45),\n    (73.43, 66.36),\n    (77.51, 68.36),\n    (80.74, 66.74),\n    (75.27, 68.67),\n    (75.11, 71.80),\n    (78.62, 70.56),\n    (78.43, 71.90),\n    (82.72, 71.23),\n    (84.25, 70.03),\n    (81.40, 72.76),\n    (86.50, 74.01),\n    (87.68, 74.78),\n    (90.25, 75.23),\n    (89.68, 75.57),\n    (95.12, 75.95),\n    (99.69, 76.09),\n    (104.10, 77.52),\n    (106.34, 76.40),\n    (112.99, 75.60),\n    (107.88, 73.72),\n    (110.43, 73.71),\n    (113.34, 73.37),\n    (123.10, 73.28),\n    (128.94, 73.02),\n    (126.10, 72.24),\n    (130.53, 70.86),\n    (135.49, 71.51),\n    (139.60, 72.23),\n    (146.04, 72.39),\n    (146.92, 72.21),\n    (150.77, 71.28),\n    (159.92, 70.14),\n    (167.68, 69.63),\n    (170.20, 69.99),\n    (178.88, 69.10),\n    (68.33, 76.71),\n    (66.03, 75.62),\n    (59.10, 74.11),\n    (54.92, 73.03),\n    (56.67, 74.10),\n    (58.56, 75.09),\n    (63.86, 75.87),\n    (68.19, 76.70),\n    (53.04, 72.57),\n    (58.29, 70.39),\n    (55.03, 70.78),\n    (53.44, 72.26),\n    (53.63, 72.61),\n    (52.22, 46.50),\n    (51.73, 44.73),\n    (52.56, 41.80),\n    (53.43, 40.40),\n    (54.22, 37.86),\n    (49.04, 38.45),\n    (48.17, 42.76),\n    (49.33, 45.64),\n    (52.22, 46.50),\n    (62.32, 46.32),\n    (60.32, 43.06),\n    (59.57, 45.58),\n    (61.94, 46.33),\n    (79.55, 46.12),\n    (74.30, 44.44),\n    (78.62, 45.79),\n    (79.66, 46.07),\n    (76.81, 41.96),\n    (76.73, 41.86),\n    (35.15, 35.15),\n    (34.61, 34.84),\n    (35.18, 35.17),\n    (23.84, 35.33),\n    (24.30, 34.91),\n    (24.09, 35.39),\n    (15.54, 37.89),\n    (13.47, 37.89),\n    (15.54, 37.89),\n    (9.56, 40.95),\n    (8.46, 39.99),\n    (9.12, 40.69),\n    (9.72, 42.60),\n    (9.54, 42.35),\n    (80.60, 8.95),\n    (79.73, 5.96),\n    (80.10, 8.30),\n    (11.04, 57.44),\n    (10.67, 57.25),\n    (-77.92, 24.67),\n    (-77.98, 24.22),\n    (-77.61, 23.62),\n    (-77.18, 23.64),\n    (-75.55, 24.13),\n    (-75.41, 24.31),\n    (-91.40, -0.17),\n    (-91.52, -0.26),\n    (-60.25, 46.68),\n    (-60.71, 46.33),\n    (-63.89, 49.47),\n    (-63.45, 49.43),\n    (142.53, -10.60),\n    (145.62, -16.34),\n    (149.79, -22.09),\n    (153.21, -26.82),\n    (150.52, -35.19),\n    (145.60, -38.53),\n    (140.13, -37.69),\n    (137.34, -34.77),\n    (135.76, -34.56),\n    (131.50, -31.34),\n    (121.72, -33.65),\n    (115.62, -33.25),\n    (114.09, -26.01),\n    (114.88, -21.27),\n    (122.34, -18.13),\n    (125.32, -14.53),\n    (128.39, -14.90),\n    (132.35, -11.42),\n    (136.16, -12.43),\n    (138.07, -16.45),\n    (142.25, -10.78),\n    (144.72, -40.68),\n    (148.32, -42.14),\n    (145.57, -42.77),\n    (146.47, -41.19),\n    (172.86, -34.23),\n    (176.10, -37.52),\n    (177.06, -39.49),\n    (174.77, -38.03),\n    (172.83, -34.27),\n    (172.36, -40.53),\n    (172.92, -43.81),\n    (168.41, -46.13),\n    (170.26, -43.21),\n    (173.69, -40.94),\n    (150.74, -10.18),\n    (143.04, -8.26),\n    (138.48, -6.97),\n    (131.95, -2.94),\n    (130.91, -1.35),\n    (134.38, -2.64),\n    (141.24, -2.62),\n    (148.19, -8.15),\n    (150.75, -10.27),\n    (117.24, 7.01),\n    (117.90, 0.76),\n    (113.89, -3.50),\n    (109.44, -0.82),\n    (113.13, 3.38),\n    (117.24, 7.01),\n    (95.31, 5.75),\n    (102.32, 1.40),\n    (106.03, -2.98),\n    (101.46, -2.81),\n    (95.20, 5.73),\n    (140.91, 41.53),\n    (140.79, 35.75),\n    (136.82, 34.56),\n    (133.56, 34.72),\n    (132.49, 35.41),\n    (136.73, 37.20),\n    (139.82, 40.00),\n    (140.68, 41.43),\n    (133.71, 34.30),\n    (131.41, 31.58),\n    (129.38, 33.10),\n    (133.90, 34.37),\n    (141.89, 45.50),\n    (144.12, 42.92),\n    (140.30, 41.64),\n    (141.53, 45.30),\n    (141.89, 45.53),\n    (142.57, 54.36),\n    (143.64, 49.19),\n    (141.99, 45.88),\n    (141.92, 50.85),\n    (142.60, 54.34),\n    (121.92, 25.48),\n    (120.53, 24.70),\n    (121.70, 25.51),\n    (110.81, 20.07),\n    (109.20, 19.66),\n    (110.81, 20.07),\n    (106.51, -6.16),\n    (114.15, -7.72),\n    (108.71, -7.89),\n    (106.51, -6.16),\n    (164.27, -20.01),\n    (164.16, -20.27),\n    (178.61, -17.04),\n    (178.61, -17.04),\n    (179.45, -16.43),\n    (179.35, -16.43),\n    (-172.55, -13.39),\n    (-172.61, -13.78),\n    (122.26, 18.67),\n    (123.05, 13.86),\n    (120.73, 13.80),\n    (120.43, 16.43),\n    (121.72, 18.40),\n    (125.34, 9.79),\n    #[allow(clippy::approx_constant)]\n    (125.56, 6.28),\n    (122.38, 7.00),\n    (125.10, 9.38),\n    (119.64, 11.35),\n    (118.81, 10.16),\n    (119.59, 10.86),\n    (119.64, 11.35),\n    (-179.87, 65.14),\n    (-177.13, 65.63),\n    (-173.46, 64.74),\n    (-171.13, 66.38),\n    (-176.48, 67.78),\n    (-178.80, 68.42),\n    (101.96, 79.08),\n    (101.31, 77.86),\n    (101.22, 79.04),\n    (94.29, 79.29),\n    (95.31, 78.68),\n    (100.02, 79.43),\n    (97.26, 79.62),\n    (95.44, 79.65),\n    (95.46, 80.62),\n    (92.39, 79.66),\n    (95.07, 80.54),\n    (138.54, 76.05),\n    (144.93, 75.45),\n    (140.30, 74.99),\n    (137.27, 75.44),\n    (138.29, 75.98),\n    (146.08, 75.29),\n    (147.75, 74.73),\n    (145.85, 75.06),\n    (141.44, 73.88),\n    (141.48, 73.84),\n    (0.01, -71.68),\n    (6.57, -70.57),\n    (15.04, -70.44),\n    (25.10, -70.75),\n    (33.37, -69.10),\n    (38.46, -69.77),\n    (42.85, -68.16),\n    (46.59, -67.23),\n    (49.35, -66.96),\n    (52.90, -65.97),\n    (58.46, -67.20),\n    (63.60, -67.58),\n    (70.63, -68.41),\n    (69.24, -70.36),\n    (76.20, -69.44),\n    (88.08, -66.64),\n    (94.98, -66.52),\n    (101.53, -66.09),\n    (111.31, -65.91),\n    (118.64, -66.87),\n    (126.24, -66.24),\n    (133.09, -66.18),\n    (139.85, -66.72),\n    (146.86, -67.96),\n    (153.65, -68.82),\n    (159.94, -69.57),\n    (164.10, -70.67),\n    (170.19, -71.94),\n    (165.68, -74.64),\n    (163.82, -77.60),\n    (162.10, -78.95),\n    (166.72, -82.84),\n    (175.58, -83.86),\n    (-178.56, -84.37),\n    (-147.96, -85.40),\n    (-152.96, -81.12),\n    (-153.95, -79.50),\n    (-151.24, -77.48),\n    (-146.74, -76.44),\n    (-137.68, -75.16),\n    (-131.63, -74.63),\n    (-123.05, -74.41),\n    (-114.76, -73.97),\n    (-111.91, -75.41),\n    (-105.05, -74.77),\n    (-100.90, -74.21),\n    (-101.04, -73.18),\n    (-100.28, -73.06),\n    (-93.06, -73.33),\n    (-85.40, -73.18),\n    (-79.82, -73.04),\n    (-78.21, -72.52),\n    (-71.90, -73.41),\n    (-67.51, -71.10),\n    (-67.57, -68.92),\n    (-66.65, -66.83),\n    (-64.30, -65.28),\n    (-59.14, -63.74),\n    (-59.58, -64.37),\n    (-62.50, -65.94),\n    (-62.48, -66.66),\n    (-65.64, -68.02),\n    (-63.85, -69.07),\n    (-61.69, -70.87),\n    (-60.89, -72.71),\n    (-61.07, -74.30),\n    (-63.33, -75.88),\n    (-76.05, -77.06),\n    (-83.04, -77.12),\n    (-74.30, -80.83),\n    (-56.40, -82.14),\n    (-42.46, -81.65),\n    (-31.60, -80.17),\n    (-34.01, -79.20),\n    (-32.48, -77.28),\n    (-26.28, -76.18),\n    (-17.18, -73.45),\n    (-11.20, -72.01),\n    (-8.67, -71.98),\n    (-5.45, -71.45),\n    (-0.82, -71.74),\n    (0.07, -71.68),\n    (164.65, -77.89),\n    (170.95, -77.37),\n    (179.67, -78.25),\n    (-178.74, -78.24),\n    (-165.76, -78.47),\n    (-158.42, -77.73),\n    (-58.98, -64.63),\n    (-60.99, -68.62),\n    (-61.02, -71.70),\n    (-62.01, -74.94),\n    (-52.00, -77.07),\n    (-42.23, -77.80),\n    (-36.22, -78.03),\n    (-35.03, -77.81),\n    (-26.13, -75.54),\n    (-19.35, -73.04),\n    (-12.16, -71.86),\n    (-6.15, -70.65),\n    (-0.57, -69.14),\n    (4.93, -70.25),\n    (10.91, -69.99),\n    (16.52, -69.87),\n    (25.41, -70.22),\n    (32.13, -69.29),\n    (33.62, -69.58),\n    (70.56, -68.53),\n    (73.91, -69.51),\n    (81.42, -67.87),\n    (84.67, -66.41),\n    (89.07, -66.73),\n    (-135.79, -74.67),\n    (-124.34, -73.22),\n    (-116.65, -74.08),\n    (-109.93, -74.64),\n    (-105.36, -74.56),\n    (-105.83, -74.77),\n    (-69.30, -70.06),\n    (-71.33, -72.68),\n    (-71.42, -71.85),\n    (-75.10, -71.46),\n    (-71.79, -70.55),\n    (-70.34, -69.26),\n    (-69.34, -70.13),\n    (-49.20, -77.83),\n    (-44.59, -78.79),\n    (-44.14, -80.13),\n    (-59.04, -79.95),\n    (-49.28, -77.84),\n    (-48.24, -77.81),\n    (-58.13, -80.12),\n    (-63.25, -80.20),\n    (-58.32, -80.12),\n    (-163.64, -78.74),\n    (-161.20, -79.93),\n    (-163.62, -78.74),\n    (66.82, 66.82),\n    (66.82, 66.82),\n];\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "65cd676674274104fab7606798d33181480ffc64",
    "func": "extern crate diesel;\n\nuse diesel::prelude::*;\n\ntable! {\n    users {\n        id -> Integer,\n        name -> Text,\n        hair_color -> Nullable<Text>,\n    }\n}\n\ntable! {\n    posts {\n        id -> Integer,\n        title -> Text,\n        user_id -> Integer,\n    }\n}\n\ntable! {\n    comments {\n        id -> Integer,\n        text -> Text,\n        post_id -> Integer,\n    }\n}\n\njoinable!(comments -> posts (post_id));\njoinable!(posts -> users (user_id));\n\nallow_tables_to_appear_in_same_query!(users, posts, comments);\nallow_columns_to_appear_in_same_group_by_clause!(\n    posts::title,\n    users::id,\n    posts::user_id,\n    users::name,\n    posts::id,\n    users::hair_color\n);\n\nfn main() {\n    use diesel::dsl;\n    // cases thas should compile\n\n    // A column appearing in the group by clause should be considered valid for the select clause\n    let source = users::table.group_by(users::name).select(users::name);\n    // If the column appearing in the group by clause is the primary key, any column of that table is a\n    // valid group by clause\n    let source = users::table.group_by(users::id).select(users::name);\n    let source = users::table\n        .group_by(users::id)\n        .select((users::name, users::hair_color));\n    // It's valid to use a aggregate function on a column that does not appear in the group by clause)\n    let source = users::table\n        .group_by(users::name)\n        .select(dsl::max(users::id));\n    // If the group by clause consists of multiple columns it's fine for the select clause to contain\n    // any of those\n    let source = users::table\n        .group_by((users::name, users::hair_color))\n        .select(users::name);\n    let source = users::table\n        .group_by((users::name, users::hair_color))\n        .select(users::hair_color);\n    let source = users::table\n        .group_by((users::name, users::hair_color))\n        .select((users::name, users::hair_color));\n    // It's fine to select all columns of a table as long as the primary key appears in the group by clause\n    let source = users::table\n        .inner_join(posts::table)\n        .group_by(users::id)\n        .select(users::all_columns);\n    // This also work for group by clauses with multiple columns\n    let source = users::table\n        .inner_join(posts::table)\n        .group_by((users::id, posts::title))\n        .select((users::all_columns, posts::title));\n    let source = users::table\n        .inner_join(posts::table.inner_join(comments::table))\n        .group_by((users::id, posts::id))\n        .select((users::all_columns, posts::all_columns));\n\n    // cases that should fail to compile\n    let source = users::table.group_by(users::name).select(users::id);\n    let source = users::table\n        .group_by((users::name, users::hair_color))\n        .select(users::id);\n    let source = users::table\n        .group_by(users::name)\n        .select((users::name, users::id));\n    let source = users::table\n        .group_by((users::name, users::hair_color))\n        .select(users::id);\n    let source = users::table\n        .inner_join(posts::table)\n        .group_by((users::id, posts::title))\n        .select((users::all_columns, posts::id));\n    let source = users::table\n        .inner_join(posts::table.inner_join(comments::table))\n        .group_by((users::id, posts::id))\n        .select((users::all_columns, posts::all_columns, comments::id));\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "218f452dd8f289d6fffe5b447c7d51c90fd18f50",
    "func": "#![warn(rust_2018_idioms)]\n#![cfg(all(feature = \"full\", not(target_os = \"wasi\")))] // WASI does not support all fs operations\n#![cfg(windows)]\n\nuse tempfile::tempdir;\nuse tokio::fs;\n\n#[tokio::test]\nasync fn symlink_file_windows() {\n    const FILE_NAME: &str = \"abc.txt\";\n\n    let temp_dir = tempdir().unwrap();\n\n    let dir1 = temp_dir.path().join(\"a\");\n    fs::create_dir(&dir1).await.unwrap();\n\n    let file1 = dir1.as_path().join(FILE_NAME);\n    fs::write(&file1, b\"Hello File!\").await.unwrap();\n\n    let dir2 = temp_dir.path().join(\"b\");\n    fs::symlink_dir(&dir1, &dir2).await.unwrap();\n\n    fs::write(&file1, b\"new data!\").await.unwrap();\n\n    let file2 = dir2.as_path().join(FILE_NAME);\n\n    let from = fs::read(&file1).await.unwrap();\n    let to = fs::read(&file2).await.unwrap();\n\n    assert_eq!(from, to);\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "92b8a1b5170a30a80127d1d0d7056eecb2f624fa",
    "func": "//! SeaORM Entity. Generated by sea-orm-codegen 0.10.0\n\nuse sea_orm::entity::prelude::*;\n\n#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq)]\n#[sea_orm(table_name = \"collection\")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    pub integers: Vec<i32> ,\n    pub integers_opt: Option<Vec<i32> > ,\n}\n\n#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]\npub enum Relation {}\n\nimpl ActiveModelBehavior for ActiveModel {}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "80ae73314acb8566b83caa91b4188baff3e970c8",
    "func": "use sea_query::{Iden, IdenStatic};\n\n#[derive(Copy, Clone, IdenStatic)]\npub struct SomeType;\n\n#[derive(Copy, Clone, IdenStatic)]\n#[iden(rename = \"Hel`lo\")]\npub struct SomeTypeWithRename;\n\nfn main() {\n    assert_eq!(SomeType.to_string(), \"some_type\");\n    assert_eq!(SomeTypeWithRename.to_string(), \"Hel`lo\");\n\n    let mut string = String::new();\n    SomeType.prepare(&mut string, '\"'.into());\n    assert_eq!(string, \"\\\"some_type\\\"\");\n\n    let mut string = String::new();\n    SomeTypeWithRename.prepare(&mut string, '\"'.into());\n    assert_eq!(string, \"\\\"Hel`lo\\\"\");\n\n    let mut string = String::new();\n    SomeTypeWithRename.prepare(&mut string, b'`'.into());\n    assert_eq!(string, \"`Hel``lo`\");\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "d9759de14b076506d9bbe319c9bd74df2de3f183",
    "func": "// Copyright 2019-2024 Tauri Programme within The Commons Conservancy\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n\nuse crate::{\n  image::Image,\n  ipc::{\n    channel::ChannelDataIpcQueue, CallbackFn, CommandArg, CommandItem, Invoke, InvokeError,\n    InvokeHandler, InvokeResponseBody,\n  },\n  manager::{webview::UriSchemeProtocol, AppManager, Asset},\n  plugin::{Plugin, PluginStore},\n  resources::ResourceTable,\n  runtime::{\n    window::{WebviewEvent as RuntimeWebviewEvent, WindowEvent as RuntimeWindowEvent},\n    ExitRequestedEventAction, RunEvent as RuntimeRunEvent,\n  },\n  sealed::{ManagerBase, RuntimeOrDispatch},\n  utils::{config::Config, Env},\n  webview::PageLoadPayload,\n  Context, DeviceEventFilter, Emitter, EventLoopMessage, Listener, Manager, Monitor, Result,\n  Runtime, Scopes, StateManager, Theme, Webview, WebviewWindowBuilder, Window,\n};\n\n#[cfg(desktop)]\nuse crate::menu::{Menu, MenuEvent};\n#[cfg(all(desktop, feature = \"tray-icon\"))]\nuse crate::tray::{TrayIcon, TrayIconBuilder, TrayIconEvent, TrayIconId};\nuse raw_window_handle::HasDisplayHandle;\nuse serialize_to_javascript::{default_template, DefaultTemplate, Template};\nuse tauri_macros::default_runtime;\n#[cfg(desktop)]\nuse tauri_runtime::EventLoopProxy;\nuse tauri_runtime::{\n  dpi::{PhysicalPosition, PhysicalSize},\n  window::DragDropEvent,\n  RuntimeInitArgs,\n};\nuse tauri_utils::{assets::AssetsIter, PackageInfo};\n\nuse serde::Serialize;\nuse std::{\n  borrow::Cow,\n  collections::HashMap,\n  fmt,\n  sync::{mpsc::Sender, Arc, MutexGuard},\n};\n\nuse crate::{event::EventId, runtime::RuntimeHandle, Event, EventTarget};\n\n#[cfg(target_os = \"macos\")]\nuse crate::ActivationPolicy;\n\npub(crate) mod plugin;\n\n#[cfg(desktop)]\npub(crate) type GlobalMenuEventListener<T> = Box<dyn Fn(&T, crate::menu::MenuEvent) + Send + Sync>;\n#[cfg(all(desktop, feature = \"tray-icon\"))]\npub(crate) type GlobalTrayIconEventListener<T> =\n  Box<dyn Fn(&T, crate::tray::TrayIconEvent) + Send + Sync>;\npub(crate) type GlobalWindowEventListener<R> = Box<dyn Fn(&Window<R>, &WindowEvent) + Send + Sync>;\npub(crate) type GlobalWebviewEventListener<R> =\n  Box<dyn Fn(&Webview<R>, &WebviewEvent) + Send + Sync>;\n/// A closure that is run when the Tauri application is setting up.\npub type SetupHook<R> =\n  Box<dyn FnOnce(&mut App<R>) -> std::result::Result<(), Box<dyn std::error::Error>> + Send>;\n/// A closure that is run every time a page starts or finishes loading.\npub type OnPageLoad<R> = dyn Fn(&Webview<R>, &PageLoadPayload<'_>) + Send + Sync + 'static;\npub type ChannelInterceptor<R> =\n  Box<dyn Fn(&Webview<R>, CallbackFn, usize, &InvokeResponseBody) -> bool + Send + Sync + 'static>;\n\n/// The exit code on [`RunEvent::ExitRequested`] when [`AppHandle#method.restart`] is called.\npub const RESTART_EXIT_CODE: i32 = i32::MAX;\n\n/// Api exposed on the `ExitRequested` event.\n#[derive(Debug)]\npub struct ExitRequestApi(Sender<ExitRequestedEventAction>);\n\nimpl ExitRequestApi {\n  /// Prevents the app from exiting.\n  ///\n  /// **Note:** This is ignored when using [`AppHandle#method.restart`].\n  pub fn prevent_exit(&self) {\n    self.0.send(ExitRequestedEventAction::Prevent).unwrap();\n  }\n}\n\n/// Api exposed on the `CloseRequested` event.\n#[derive(Debug, Clone)]\npub struct CloseRequestApi(Sender<bool>);\n\nimpl CloseRequestApi {\n  /// Prevents the window from being closed.\n  pub fn prevent_close(&self) {\n    self.0.send(true).unwrap();\n  }\n}\n\n/// An event from a window.\n#[derive(Debug, Clone)]\n#[non_exhaustive]\npub enum WindowEvent {\n  /// The size of the window has changed. Contains the client area's new dimensions.\n  Resized(PhysicalSize<u32>),\n  /// The position of the window has changed. Contains the window's new position.\n  Moved(PhysicalPosition<i32>),\n  /// The window has been requested to close.\n  #[non_exhaustive]\n  CloseRequested {\n    /// An API modify the behavior of the close requested event.\n    api: CloseRequestApi,\n  },\n  /// The window has been destroyed.\n  Destroyed,\n  /// The window gained or lost focus.\n  ///\n  /// The parameter is true if the window has gained focus, and false if it has lost focus.\n  Focused(bool),\n  /// The window's scale factor has changed.\n  ///\n  /// The following user actions can cause DPI changes:\n  ///\n  /// - Changing the display's resolution.\n  /// - Changing the display's scale factor (e.g. in Control Panel on Windows).\n  /// - Moving the window to a display with a different scale factor.\n  #[non_exhaustive]\n  ScaleFactorChanged {\n    /// The new scale factor.\n    scale_factor: f64,\n    /// The window inner size.\n    new_inner_size: PhysicalSize<u32>,\n  },\n  /// An event associated with the drag and drop action.\n  DragDrop(DragDropEvent),\n  /// The system window theme has changed. Only delivered if the window [`theme`](`crate::window::WindowBuilder#method.theme`) is `None`.\n  ///\n  /// Applications might wish to react to this to change the theme of the content of the window when the system changes the window theme.\n  ///\n  /// ## Platform-specific\n  ///\n  /// - **Linux**: Not supported.\n  ThemeChanged(Theme),\n}\n\nimpl From<RuntimeWindowEvent> for WindowEvent {\n  fn from(event: RuntimeWindowEvent) -> Self {\n    match event {\n      RuntimeWindowEvent::Resized(size) => Self::Resized(size),\n      RuntimeWindowEvent::Moved(position) => Self::Moved(position),\n      RuntimeWindowEvent::CloseRequested { signal_tx } => Self::CloseRequested {\n        api: CloseRequestApi(signal_tx),\n      },\n      RuntimeWindowEvent::Destroyed => Self::Destroyed,\n      RuntimeWindowEvent::Focused(flag) => Self::Focused(flag),\n      RuntimeWindowEvent::ScaleFactorChanged {\n        scale_factor,\n        new_inner_size,\n      } => Self::ScaleFactorChanged {\n        scale_factor,\n        new_inner_size,\n      },\n      RuntimeWindowEvent::DragDrop(event) => Self::DragDrop(event),\n      RuntimeWindowEvent::ThemeChanged(theme) => Self::ThemeChanged(theme),\n    }\n  }\n}\n\n/// An event from a window.\n#[derive(Debug, Clone)]\n#[non_exhaustive]\npub enum WebviewEvent {\n  /// An event associated with the drag and drop action.\n  DragDrop(DragDropEvent),\n}\n\nimpl From<RuntimeWebviewEvent> for WebviewEvent {\n  fn from(event: RuntimeWebviewEvent) -> Self {\n    match event {\n      RuntimeWebviewEvent::DragDrop(e) => Self::DragDrop(e),\n    }\n  }\n}\n\n/// An application event, triggered from the event loop.\n///\n/// See [`App::run`](crate::App#method.run) for usage examples.\n#[derive(Debug)]\n#[non_exhaustive]\npub enum RunEvent {\n  /// Event loop is exiting.\n  Exit,\n  /// The app is about to exit\n  #[non_exhaustive]\n  ExitRequested {\n    /// Exit code.\n    /// [`Option::None`] when the exit is requested by user interaction,\n    /// [`Option::Some`] when requested programmatically via [`AppHandle#method.exit`] and [`AppHandle#method.restart`].\n    code: Option<i32>,\n    /// Event API\n    api: ExitRequestApi,\n  },\n  /// An event associated with a window.\n  #[non_exhaustive]\n  WindowEvent {\n    /// The window label.\n    label: String,\n    /// The detailed event.\n    event: WindowEvent,\n  },\n  /// An event associated with a webview.\n  #[non_exhaustive]\n  WebviewEvent {\n    /// The window label.\n    label: String,\n    /// The detailed event.\n    event: WebviewEvent,\n  },\n  /// Application ready.\n  Ready,\n  /// Sent if the event loop is being resumed.\n  Resumed,\n  /// Emitted when all of the event loop's input events have been processed and redraw processing is about to begin.\n  ///\n  /// This event is useful as a place to put your code that should be run after all state-changing events have been handled and you want to do stuff (updating state, performing calculations, etc) that happens as the \u201cmain body\u201d of your event loop.\n  MainEventsCleared,\n  /// Emitted when the user wants to open the specified resource with the app.\n  #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n  #[cfg_attr(docsrs, doc(cfg(any(target_os = \"macos\", feature = \"ios\"))))]\n  Opened {\n    /// The URL of the resources that is being open.\n    urls: Vec<url::Url>,\n  },\n  /// An event from a menu item, could be on the window menu bar, application menu bar (on macOS) or tray icon menu.\n  #[cfg(desktop)]\n  #[cfg_attr(docsrs, doc(cfg(desktop)))]\n  MenuEvent(crate::menu::MenuEvent),\n  /// An event from a tray icon.\n  #[cfg(all(desktop, feature = \"tray-icon\"))]\n  #[cfg_attr(docsrs, doc(cfg(all(desktop, feature = \"tray-icon\"))))]\n  TrayIconEvent(crate::tray::TrayIconEvent),\n  /// Emitted when the NSApplicationDelegate's applicationShouldHandleReopen gets called\n  #[non_exhaustive]\n  #[cfg(target_os = \"macos\")]\n  #[cfg_attr(docsrs, doc(cfg(target_os = \"macos\")))]\n  Reopen {\n    /// Indicates whether the NSApplication object found any visible windows in your application.\n    has_visible_windows: bool,\n  },\n}\n\nimpl From<EventLoopMessage> for RunEvent {\n  fn from(event: EventLoopMessage) -> Self {\n    match event {\n      #[cfg(desktop)]\n      EventLoopMessage::MenuEvent(e) => Self::MenuEvent(e),\n      #[cfg(all(desktop, feature = \"tray-icon\"))]\n      EventLoopMessage::TrayIconEvent(e) => Self::TrayIconEvent(e),\n    }\n  }\n}\n\n/// The asset resolver is a helper to access the [`tauri_utils::assets::Assets`] interface.\n#[derive(Debug, Clone)]\npub struct AssetResolver<R: Runtime> {\n  manager: Arc<AppManager<R>>,\n}\n\nimpl<R: Runtime> AssetResolver<R> {\n  /// Gets the app asset associated with the given path.\n  ///\n  /// Resolves to the embedded asset that is part of the app\n  /// in dev when [`devUrl`](https://v2.tauri.app/reference/config/#devurl) points to a folder in your filesystem\n  /// or in production when [`frontendDist`](https://v2.tauri.app/reference/config/#frontenddist)\n  /// points to your frontend assets.\n  ///\n  /// Fallbacks to reading the asset from the [distDir] folder so the behavior is consistent in development.\n  /// Note that the dist directory must exist so you might need to build your frontend assets first.\n  pub fn get(&self, path: String) -> Option<Asset> {\n    #[cfg(dev)]\n    {\n      // on dev if the devPath is a path to a directory we have the embedded assets\n      // so we can use get_asset() directly\n      // we only fallback to reading from distDir directly if we're using an external URL (which is likely)\n      if let (Some(_), Some(crate::utils::config::FrontendDist::Directory(dist_path))) = (\n        &self.manager.config().build.dev_url,\n        &self.manager.config().build.frontend_dist,\n      ) {\n        let asset_path = std::path::PathBuf::from(&path)\n          .components()\n          .filter(|c| !matches!(c, std::path::Component::RootDir))\n          .collect::<std::path::PathBuf>();\n\n        let asset_path = self\n          .manager\n          .config_parent()\n          .map(|p| p.join(dist_path).join(&asset_path))\n          .unwrap_or_else(|| dist_path.join(&asset_path));\n        return std::fs::read(asset_path).ok().map(|bytes| {\n          let mime_type = crate::utils::mime_type::MimeType::parse(&bytes, &path);\n          Asset {\n            bytes,\n            mime_type,\n            csp_header: None,\n          }\n        });\n      }\n    }\n\n    self.manager.get_asset(path).ok()\n  }\n\n  /// Iterate on all assets.\n  pub fn iter(&self) -> Box<AssetsIter<'_>> {\n    self.manager.assets.iter()\n  }\n}\n\n/// A handle to the currently running application.\n///\n/// This type implements [`Manager`] which allows for manipulation of global application items.\n#[default_runtime(crate::Wry, wry)]\n#[derive(Debug)]\npub struct AppHandle<R: Runtime> {\n  pub(crate) runtime_handle: R::Handle,\n  pub(crate) manager: Arc<AppManager<R>>,\n}\n\n/// APIs specific to the wry runtime.\n#[cfg(feature = \"wry\")]\nimpl AppHandle<crate::Wry> {\n  /// Create a new tao window using a callback. The event loop must be running at this point.\n  pub fn create_tao_window<\n    F: FnOnce() -> (String, tauri_runtime_wry::TaoWindowBuilder) + Send + 'static,\n  >(\n    &self,\n    f: F,\n  ) -> crate::Result<std::sync::Weak<tauri_runtime_wry::Window>> {\n    self.runtime_handle.create_tao_window(f).map_err(Into::into)\n  }\n\n  /// Sends a window message to the event loop.\n  pub fn send_tao_window_event(\n    &self,\n    window_id: tauri_runtime_wry::TaoWindowId,\n    message: tauri_runtime_wry::WindowMessage,\n  ) -> crate::Result<()> {\n    self\n      .runtime_handle\n      .send_event(tauri_runtime_wry::Message::Window(\n        self.runtime_handle.window_id(window_id),\n        message,\n      ))\n      .map_err(Into::into)\n  }\n}\n\nimpl<R: Runtime> Clone for AppHandle<R> {\n  fn clone(&self) -> Self {\n    Self {\n      runtime_handle: self.runtime_handle.clone(),\n      manager: self.manager.clone(),\n    }\n  }\n}\n\nimpl<'de, R: Runtime> CommandArg<'de, R> for AppHandle<R> {\n  /// Grabs the [`Window`] from the [`CommandItem`] and returns the associated [`AppHandle`]. This will never fail.\n  fn from_command(command: CommandItem<'de, R>) -> std::result::Result<Self, InvokeError> {\n    Ok(command.message.webview().app_handle)\n  }\n}\n\nimpl<R: Runtime> AppHandle<R> {\n  /// Runs the given closure on the main thread.\n  pub fn run_on_main_thread<F: FnOnce() + Send + 'static>(&self, f: F) -> crate::Result<()> {\n    self\n      .runtime_handle\n      .run_on_main_thread(f)\n      .map_err(Into::into)\n  }\n\n  /// Adds a Tauri application plugin.\n  /// This function can be used to register a plugin that is loaded dynamically e.g. after login.\n  /// For plugins that are created when the app is started, prefer [`Builder::plugin`].\n  ///\n  /// See [`Builder::plugin`] for more information.\n  ///\n  /// # Examples\n  ///\n  /// ```\n  /// use tauri::{plugin::{Builder as PluginBuilder, TauriPlugin}, Runtime};\n  ///\n  /// fn init_plugin<R: Runtime>() -> TauriPlugin<R> {\n  ///   PluginBuilder::new(\"dummy\").build()\n  /// }\n  ///\n  /// tauri::Builder::default()\n  ///   .setup(move |app| {\n  ///     let handle = app.handle().clone();\n  ///     std::thread::spawn(move || {\n  ///       handle.plugin(init_plugin());\n  ///     });\n  ///\n  ///     Ok(())\n  ///   });\n  /// ```\n  #[cfg_attr(feature = \"tracing\", tracing::instrument(name = \"app::plugin::register\", skip(plugin), fields(name = plugin.name())))]\n  pub fn plugin<P: Plugin<R> + 'static>(&self, plugin: P) -> crate::Result<()> {\n    let mut plugin = Box::new(plugin) as Box<dyn Plugin<R>>;\n\n    let mut store = self.manager().plugins.lock().unwrap();\n    store.initialize(&mut plugin, self, &self.config().plugins)?;\n    store.register(plugin);\n\n    Ok(())\n  }\n\n  /// Removes the plugin with the given name.\n  ///\n  /// # Examples\n  ///\n  /// ```\n  /// use tauri::{plugin::{Builder as PluginBuilder, TauriPlugin, Plugin}, Runtime};\n  ///\n  /// fn init_plugin<R: Runtime>() -> TauriPlugin<R> {\n  ///   PluginBuilder::new(\"dummy\").build()\n  /// }\n  ///\n  /// let plugin = init_plugin();\n  /// // `.name()` requires the `PLugin` trait import\n  /// let plugin_name = plugin.name();\n  /// tauri::Builder::default()\n  ///   .plugin(plugin)\n  ///   .setup(move |app| {\n  ///     let handle = app.handle().clone();\n  ///     std::thread::spawn(move || {\n  ///       handle.remove_plugin(plugin_name);\n  ///     });\n  ///\n  ///     Ok(())\n  ///   });\n  /// ```\n  pub fn remove_plugin(&self, plugin: &'static str) -> bool {\n    self.manager().plugins.lock().unwrap().unregister(plugin)\n  }\n\n  /// Exits the app by triggering [`RunEvent::ExitRequested`] and [`RunEvent::Exit`].\n  pub fn exit(&self, exit_code: i32) {\n    if let Err(e) = self.runtime_handle.request_exit(exit_code) {\n      log::error!(\"failed to exit: {}\", e);\n      self.cleanup_before_exit();\n      std::process::exit(exit_code);\n    }\n  }\n\n  /// Restarts the app by triggering [`RunEvent::ExitRequested`] with code [`RESTART_EXIT_CODE`] and [`RunEvent::Exit`]..\n  pub fn restart(&self) -> ! {\n    if self.runtime_handle.request_exit(RESTART_EXIT_CODE).is_err() {\n      self.cleanup_before_exit();\n    }\n    crate::process::restart(&self.env());\n  }\n\n  /// Sets the activation policy for the application. It is set to `NSApplicationActivationPolicyRegular` by default.\n  ///\n  /// # Examples\n  /// ```,no_run\n  /// tauri::Builder::default()\n  ///   .setup(move |app| {\n  ///     #[cfg(target_os = \"macos\")]\n  ///     app.handle().set_activation_policy(tauri::ActivationPolicy::Accessory);\n  ///     Ok(())\n  ///   });\n  /// ```\n  #[cfg(target_os = \"macos\")]\n  #[cfg_attr(docsrs, doc(cfg(target_os = \"macos\")))]\n  pub fn set_activation_policy(&self, activation_policy: ActivationPolicy) -> crate::Result<()> {\n    self\n      .runtime_handle\n      .set_activation_policy(activation_policy)\n      .map_err(Into::into)\n  }\n}\n\nimpl<R: Runtime> Manager<R> for AppHandle<R> {\n  fn resources_table(&self) -> MutexGuard<'_, ResourceTable> {\n    self.manager.resources_table()\n  }\n}\n\nimpl<R: Runtime> ManagerBase<R> for AppHandle<R> {\n  fn manager(&self) -> &AppManager<R> {\n    &self.manager\n  }\n\n  fn manager_owned(&self) -> Arc<AppManager<R>> {\n    self.manager.clone()\n  }\n\n  fn runtime(&self) -> RuntimeOrDispatch<'_, R> {\n    RuntimeOrDispatch::RuntimeHandle(self.runtime_handle.clone())\n  }\n\n  fn managed_app_handle(&self) -> &AppHandle<R> {\n    self\n  }\n}\n\n/// The instance of the currently running application.\n///\n/// This type implements [`Manager`] which allows for manipulation of global application items.\n#[default_runtime(crate::Wry, wry)]\npub struct App<R: Runtime> {\n  runtime: Option<R>,\n  setup: Option<SetupHook<R>>,\n  manager: Arc<AppManager<R>>,\n  handle: AppHandle<R>,\n  ran_setup: bool,\n}\n\nimpl<R: Runtime> fmt::Debug for App<R> {\n  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n    f.debug_struct(\"App\")\n      .field(\"runtime\", &self.runtime)\n      .field(\"manager\", &self.manager)\n      .field(\"handle\", &self.handle)\n      .finish()\n  }\n}\n\nimpl<R: Runtime> Manager<R> for App<R> {\n  fn resources_table(&self) -> MutexGuard<'_, ResourceTable> {\n    self.manager.resources_table()\n  }\n}\n\nimpl<R: Runtime> ManagerBase<R> for App<R> {\n  fn manager(&self) -> &AppManager<R> {\n    &self.manager\n  }\n\n  fn manager_owned(&self) -> Arc<AppManager<R>> {\n    self.manager.clone()\n  }\n\n  fn runtime(&self) -> RuntimeOrDispatch<'_, R> {\n    if let Some(runtime) = self.runtime.as_ref() {\n      RuntimeOrDispatch::Runtime(runtime)\n    } else {\n      self.handle.runtime()\n    }\n  }\n\n  fn managed_app_handle(&self) -> &AppHandle<R> {\n    self.handle()\n  }\n}\n\n/// APIs specific to the wry runtime.\n#[cfg(feature = \"wry\")]\nimpl App<crate::Wry> {\n  /// Adds a [`tauri_runtime_wry::Plugin`] using its [`tauri_runtime_wry::PluginBuilder`].\n  ///\n  /// # Stability\n  ///\n  /// This API is unstable.\n  pub fn wry_plugin<P: tauri_runtime_wry::PluginBuilder<EventLoopMessage> + Send + 'static>(\n    &mut self,\n    plugin: P,\n  ) where\n    <P as tauri_runtime_wry::PluginBuilder<EventLoopMessage>>::Plugin: Send,\n  {\n    self.handle.runtime_handle.plugin(plugin);\n  }\n}\n\nmacro_rules! shared_app_impl {\n  ($app: ty) => {\n    impl<R: Runtime> $app {\n      /// Registers a global menu event listener.\n      #[cfg(desktop)]\n      pub fn on_menu_event<F: Fn(&AppHandle<R>, MenuEvent) + Send + Sync + 'static>(\n        &self,\n        handler: F,\n      ) {\n        self.manager.menu.on_menu_event(handler)\n      }\n\n      /// Registers a global tray icon menu event listener.\n      #[cfg(all(desktop, feature = \"tray-icon\"))]\n      #[cfg_attr(docsrs, doc(cfg(all(desktop, feature = \"tray-icon\"))))]\n      pub fn on_tray_icon_event<F: Fn(&AppHandle<R>, TrayIconEvent) + Send + Sync + 'static>(\n        &self,\n        handler: F,\n      ) {\n        self.manager.tray.on_tray_icon_event(handler)\n      }\n\n      /// Gets a tray icon using the provided id.\n      #[cfg(all(desktop, feature = \"tray-icon\"))]\n      #[cfg_attr(docsrs, doc(cfg(all(desktop, feature = \"tray-icon\"))))]\n      pub fn tray_by_id<'a, I>(&self, id: &'a I) -> Option<TrayIcon<R>>\n      where\n        I: ?Sized,\n        TrayIconId: PartialEq<&'a I>,\n      {\n        self.manager.tray.tray_by_id(id)\n      }\n\n      /// Removes a tray icon using the provided id from tauri's internal state and returns it.\n      ///\n      /// Note that dropping the returned icon, may cause the tray icon to disappear\n      /// if it wasn't cloned somewhere else or referenced by JS.\n      #[cfg(all(desktop, feature = \"tray-icon\"))]\n      #[cfg_attr(docsrs, doc(cfg(all(desktop, feature = \"tray-icon\"))))]\n      pub fn remove_tray_by_id<'a, I>(&self, id: &'a I) -> Option<TrayIcon<R>>\n      where\n        I: ?Sized,\n        TrayIconId: PartialEq<&'a I>,\n      {\n        self.manager.tray.remove_tray_by_id(id)\n      }\n\n      /// Gets the app's configuration, defined on the `tauri.conf.json` file.\n      pub fn config(&self) -> &Config {\n        self.manager.config()\n      }\n\n      /// Gets the app's package information.\n      pub fn package_info(&self) -> &PackageInfo {\n        self.manager.package_info()\n      }\n\n      /// The application's asset resolver.\n      pub fn asset_resolver(&self) -> AssetResolver<R> {\n        AssetResolver {\n          manager: self.manager.clone(),\n        }\n      }\n\n      /// Returns the primary monitor of the system.\n      ///\n      /// Returns None if it can't identify any monitor as a primary one.\n      pub fn primary_monitor(&self) -> crate::Result<Option<Monitor>> {\n        Ok(match self.runtime() {\n          RuntimeOrDispatch::Runtime(h) => h.primary_monitor().map(Into::into),\n          RuntimeOrDispatch::RuntimeHandle(h) => h.primary_monitor().map(Into::into),\n          _ => unreachable!(),\n        })\n      }\n\n      /// Returns the monitor that contains the given point.\n      pub fn monitor_from_point(&self, x: f64, y: f64) -> crate::Result<Option<Monitor>> {\n        Ok(match self.runtime() {\n          RuntimeOrDispatch::Runtime(h) => h.monitor_from_point(x, y).map(Into::into),\n          RuntimeOrDispatch::RuntimeHandle(h) => h.monitor_from_point(x, y).map(Into::into),\n          _ => unreachable!(),\n        })\n      }\n\n      /// Returns the list of all the monitors available on the system.\n      pub fn available_monitors(&self) -> crate::Result<Vec<Monitor>> {\n        Ok(match self.runtime() {\n          RuntimeOrDispatch::Runtime(h) => {\n            h.available_monitors().into_iter().map(Into::into).collect()\n          }\n          RuntimeOrDispatch::RuntimeHandle(h) => {\n            h.available_monitors().into_iter().map(Into::into).collect()\n          }\n          _ => unreachable!(),\n        })\n      }\n\n      /// Get the cursor position relative to the top-left hand corner of the desktop.\n      ///\n      /// Note that the top-left hand corner of the desktop is not necessarily the same as the screen.\n      /// If the user uses a desktop with multiple monitors,\n      /// the top-left hand corner of the desktop is the top-left hand corner of the main monitor on Windows and macOS\n      /// or the top-left of the leftmost monitor on X11.\n      ///\n      /// The coordinates can be negative if the top-left hand corner of the window is outside of the visible screen region.\n      pub fn cursor_position(&self) -> crate::Result<PhysicalPosition<f64>> {\n        Ok(match self.runtime() {\n          RuntimeOrDispatch::Runtime(h) => h.cursor_position()?,\n          RuntimeOrDispatch::RuntimeHandle(h) => h.cursor_position()?,\n          _ => unreachable!(),\n        })\n      }\n\n      /// Set the app theme.\n      pub fn set_theme(&self, theme: Option<Theme>) {\n        #[cfg(windows)]\n        for window in self.manager.windows().values() {\n          if let (Some(menu), Ok(hwnd)) = (window.menu(), window.hwnd()) {\n            let raw_hwnd = hwnd.0 as isize;\n            let _ = self.run_on_main_thread(move || {\n              let _ = unsafe {\n                menu.inner().set_theme_for_hwnd(\n                  raw_hwnd,\n                  theme\n                    .map(crate::menu::map_to_menu_theme)\n                    .unwrap_or(muda::MenuTheme::Auto),\n                )\n              };\n            });\n          };\n        }\n        match self.runtime() {\n          RuntimeOrDispatch::Runtime(h) => h.set_theme(theme),\n          RuntimeOrDispatch::RuntimeHandle(h) => h.set_theme(theme),\n          _ => unreachable!(),\n        }\n      }\n\n      /// Returns the default window icon.\n      pub fn default_window_icon(&self) -> Option<&Image<'_>> {\n        self.manager.window.default_icon.as_ref()\n      }\n\n      /// Returns the app-wide menu.\n      #[cfg(desktop)]\n      pub fn menu(&self) -> Option<Menu<R>> {\n        self.manager.menu.menu_lock().clone()\n      }\n\n      /// Sets the app-wide menu and returns the previous one.\n      ///\n      /// If a window was not created with an explicit menu or had one set explicitly,\n      /// this menu will be assigned to it.\n      #[cfg(desktop)]\n      pub fn set_menu(&self, menu: Menu<R>) -> crate::Result<Option<Menu<R>>> {\n        let prev_menu = self.remove_menu()?;\n\n        self.manager.menu.insert_menu_into_stash(&menu);\n\n        self.manager.menu.menu_lock().replace(menu.clone());\n\n        // set it on all windows that don't have one or previously had the app-wide menu\n        #[cfg(not(target_os = \"macos\"))]\n        {\n          for window in self.manager.windows().values() {\n            let has_app_wide_menu = window.has_app_wide_menu() || window.menu().is_none();\n            if has_app_wide_menu {\n              window.set_menu(menu.clone())?;\n              window.menu_lock().replace(crate::window::WindowMenu {\n                is_app_wide: true,\n                menu: menu.clone(),\n              });\n            }\n          }\n        }\n\n        // set it app-wide for macos\n        #[cfg(target_os = \"macos\")]\n        {\n          let menu_ = menu.clone();\n          self.run_on_main_thread(move || {\n            let _ = init_app_menu(&menu_);\n          })?;\n        }\n\n        Ok(prev_menu)\n      }\n\n      /// Remove the app-wide menu and returns it.\n      ///\n      /// If a window was not created with an explicit menu or had one set explicitly,\n      /// this will remove the menu from it.\n      #[cfg(desktop)]\n      pub fn remove_menu(&self) -> crate::Result<Option<Menu<R>>> {\n        let menu = self.manager.menu.menu_lock().as_ref().cloned();\n        #[allow(unused_variables)]\n        if let Some(menu) = menu {\n          // remove from windows that have the app-wide menu\n          #[cfg(not(target_os = \"macos\"))]\n          {\n            for window in self.manager.windows().values() {\n              let has_app_wide_menu = window.has_app_wide_menu();\n              if has_app_wide_menu {\n                window.remove_menu()?;\n                *window.menu_lock() = None;\n              }\n            }\n          }\n\n          // remove app-wide for macos\n          #[cfg(target_os = \"macos\")]\n          {\n            self.run_on_main_thread(move || {\n              menu.inner().remove_for_nsapp();\n            })?;\n          }\n        }\n\n        let prev_menu = self.manager.menu.menu_lock().take();\n\n        self\n          .manager\n          .remove_menu_from_stash_by_id(prev_menu.as_ref().map(|m| m.id()));\n\n        Ok(prev_menu)\n      }\n\n      /// Hides the app-wide menu from windows that have it.\n      ///\n      /// If a window was not created with an explicit menu or had one set explicitly,\n      /// this will hide the menu from it.\n      #[cfg(desktop)]\n      pub fn hide_menu(&self) -> crate::Result<()> {\n        #[cfg(not(target_os = \"macos\"))]\n        {\n          let is_app_menu_set = self.manager.menu.menu_lock().is_some();\n          if is_app_menu_set {\n            for window in self.manager.windows().values() {\n              if window.has_app_wide_menu() {\n                window.hide_menu()?;\n              }\n            }\n          }\n        }\n\n        Ok(())\n      }\n\n      /// Shows the app-wide menu for windows that have it.\n      ///\n      /// If a window was not created with an explicit menu or had one set explicitly,\n      /// this will show the menu for it.\n      #[cfg(desktop)]\n      pub fn show_menu(&self) -> crate::Result<()> {\n        #[cfg(not(target_os = \"macos\"))]\n        {\n          let is_app_menu_set = self.manager.menu.menu_lock().is_some();\n          if is_app_menu_set {\n            for window in self.manager.windows().values() {\n              if window.has_app_wide_menu() {\n                window.show_menu()?;\n              }\n            }\n          }\n        }\n\n        Ok(())\n      }\n\n      /// Shows the application, but does not automatically focus it.\n      #[cfg(target_os = \"macos\")]\n      pub fn show(&self) -> crate::Result<()> {\n        match self.runtime() {\n          RuntimeOrDispatch::Runtime(r) => r.show(),\n          RuntimeOrDispatch::RuntimeHandle(h) => h.show()?,\n          _ => unreachable!(),\n        }\n        Ok(())\n      }\n\n      /// Hides the application.\n      #[cfg(target_os = \"macos\")]\n      pub fn hide(&self) -> crate::Result<()> {\n        match self.runtime() {\n          RuntimeOrDispatch::Runtime(r) => r.hide(),\n          RuntimeOrDispatch::RuntimeHandle(h) => h.hide()?,\n          _ => unreachable!(),\n        }\n        Ok(())\n      }\n\n      /// Runs necessary cleanup tasks before exiting the process.\n      /// **You should always exit the tauri app immediately after this function returns and not use any tauri-related APIs.**\n      pub fn cleanup_before_exit(&self) {\n        #[cfg(all(desktop, feature = \"tray-icon\"))]\n        self.manager.tray.icons.lock().unwrap().clear();\n        self.manager.resources_table().clear();\n        for (_, window) in self.manager.windows() {\n          window.resources_table().clear();\n          #[cfg(windows)]\n          let _ = window.hide();\n        }\n        for (_, webview) in self.manager.webviews() {\n          webview.resources_table().clear();\n        }\n      }\n\n      /// Gets the invoke key that must be referenced when using [`crate::webview::InvokeRequest`].\n      ///\n      /// # Security\n      ///\n      /// DO NOT expose this key to third party scripts as might grant access to the backend from external URLs and iframes.\n      pub fn invoke_key(&self) -> &str {\n        self.manager.invoke_key()\n      }\n    }\n\n    impl<R: Runtime> Listener<R> for $app {\n      /// Listen to an event on this app.\n      ///\n      /// # Examples\n      ///\n      /// ```\n      /// use tauri::Listener;\n      ///\n      /// tauri::Builder::default()\n      ///   .setup(|app| {\n      ///     app.listen(\"component-loaded\", move |event| {\n      ///       println!(\"window just loaded a component\");\n      ///     });\n      ///\n      ///     Ok(())\n      ///   });\n      /// ```\n      fn listen<F>(&self, event: impl Into<String>, handler: F) -> EventId\n      where\n        F: Fn(Event) + Send + 'static,\n      {\n        self.manager.listen(event.into(), EventTarget::App, handler)\n      }\n\n      /// Listen to an event on this app only once.\n      ///\n      /// See [`Self::listen`] for more information.\n      fn once<F>(&self, event: impl Into<String>, handler: F) -> EventId\n      where\n        F: FnOnce(Event) + Send + 'static,\n      {\n        self.manager.once(event.into(), EventTarget::App, handler)\n      }\n\n      /// Unlisten to an event on this app.\n      ///\n      /// # Examples\n      ///\n      /// ```\n      /// use tauri::Listener;\n      ///\n      /// tauri::Builder::default()\n      ///   .setup(|app| {\n      ///     let handler = app.listen(\"component-loaded\", move |event| {\n      ///       println!(\"app just loaded a component\");\n      ///     });\n      ///\n      ///     // stop listening to the event when you do not need it anymore\n      ///     app.unlisten(handler);\n      ///\n      ///     Ok(())\n      ///   });\n      /// ```\n      fn unlisten(&self, id: EventId) {\n        self.manager.unlisten(id)\n      }\n    }\n\n    impl<R: Runtime> Emitter<R> for $app {\n      /// Emits an event to all [targets](EventTarget).\n      ///\n      /// # Examples\n      /// ```\n      /// use tauri::Emitter;\n      ///\n      /// #[tauri::command]\n      /// fn synchronize(app: tauri::AppHandle) {\n      ///   // emits the synchronized event to all webviews\n      ///   app.emit(\"synchronized\", ());\n      /// }\n      /// ```\n      fn emit<S: Serialize + Clone>(&self, event: &str, payload: S) -> Result<()> {\n        self.manager.emit(event, payload)\n      }\n\n      /// Emits an event to all [targets](EventTarget) matching the given target.\n      ///\n      /// # Examples\n      /// ```\n      /// use tauri::{Emitter, EventTarget};\n      ///\n      /// #[tauri::command]\n      /// fn download(app: tauri::AppHandle) {\n      ///   for i in 1..100 {\n      ///     std::thread::sleep(std::time::Duration::from_millis(150));\n      ///     // emit a download progress event to all listeners\n      ///     app.emit_to(EventTarget::any(), \"download-progress\", i);\n      ///     // emit an event to listeners that used App::listen or AppHandle::listen\n      ///     app.emit_to(EventTarget::app(), \"download-progress\", i);\n      ///     // emit an event to any webview/window/webviewWindow matching the given label\n      ///     app.emit_to(\"updater\", \"download-progress\", i); // similar to using EventTarget::labeled\n      ///     app.emit_to(EventTarget::labeled(\"updater\"), \"download-progress\", i);\n      ///     // emit an event to listeners that used WebviewWindow::listen\n      ///     app.emit_to(EventTarget::webview_window(\"updater\"), \"download-progress\", i);\n      ///   }\n      /// }\n      /// ```\n      fn emit_to<I, S>(&self, target: I, event: &str, payload: S) -> Result<()>\n      where\n        I: Into<EventTarget>,\n        S: Serialize + Clone,\n      {\n        self.manager.emit_to(target, event, payload)\n      }\n\n      /// Emits an event to all [targets](EventTarget) based on the given filter.\n      ///\n      /// # Examples\n      /// ```\n      /// use tauri::{Emitter, EventTarget};\n      ///\n      /// #[tauri::command]\n      /// fn download(app: tauri::AppHandle) {\n      ///   for i in 1..100 {\n      ///     std::thread::sleep(std::time::Duration::from_millis(150));\n      ///     // emit a download progress event to the updater window\n      ///     app.emit_filter(\"download-progress\", i, |t| match t {\n      ///       EventTarget::WebviewWindow { label } => label == \"main\",\n      ///       _ => false,\n      ///     });\n      ///   }\n      /// }\n      /// ```\n      fn emit_filter<S, F>(&self, event: &str, payload: S, filter: F) -> Result<()>\n      where\n        S: Serialize + Clone,\n        F: Fn(&EventTarget) -> bool,\n      {\n        self.manager.emit_filter(event, payload, filter)\n      }\n    }\n  };\n}\n\nshared_app_impl!(App<R>);\nshared_app_impl!(AppHandle<R>);\n\nimpl<R: Runtime> App<R> {\n  #[cfg_attr(\n    feature = \"tracing\",\n    tracing::instrument(name = \"app::core_plugins::register\")\n  )]\n  fn register_core_plugins(&self) -> crate::Result<()> {\n    self.handle.plugin(crate::path::plugin::init())?;\n    self.handle.plugin(crate::event::plugin::init())?;\n    self.handle.plugin(crate::window::plugin::init())?;\n    self.handle.plugin(crate::webview::plugin::init())?;\n    self.handle.plugin(crate::app::plugin::init())?;\n    self.handle.plugin(crate::resources::plugin::init())?;\n    self.handle.plugin(crate::image::plugin::init())?;\n    #[cfg(desktop)]\n    self.handle.plugin(crate::menu::plugin::init())?;\n    #[cfg(all(desktop, feature = \"tray-icon\"))]\n    self.handle.plugin(crate::tray::plugin::init())?;\n    Ok(())\n  }\n\n  /// Runs the given closure on the main thread.\n  pub fn run_on_main_thread<F: FnOnce() + Send + 'static>(&self, f: F) -> crate::Result<()> {\n    self.app_handle().run_on_main_thread(f)\n  }\n\n  /// Gets a handle to the application instance.\n  pub fn handle(&self) -> &AppHandle<R> {\n    &self.handle\n  }\n\n  /// Sets the activation policy for the application. It is set to `NSApplicationActivationPolicyRegular` by default.\n  ///\n  /// # Examples\n  /// ```,no_run\n  /// tauri::Builder::default()\n  ///   .setup(move |app| {\n  ///     #[cfg(target_os = \"macos\")]\n  ///     app.set_activation_policy(tauri::ActivationPolicy::Accessory);\n  ///     Ok(())\n  ///   });\n  /// ```\n  #[cfg(target_os = \"macos\")]\n  #[cfg_attr(docsrs, doc(cfg(target_os = \"macos\")))]\n  pub fn set_activation_policy(&mut self, activation_policy: ActivationPolicy) {\n    if let Some(runtime) = self.runtime.as_mut() {\n      runtime.set_activation_policy(activation_policy);\n    } else {\n      let _ = self.app_handle().set_activation_policy(activation_policy);\n    }\n  }\n\n  /// Change the device event filter mode.\n  ///\n  /// Since the DeviceEvent capture can lead to high CPU usage for unfocused windows, [`tao`]\n  /// will ignore them by default for unfocused windows on Windows. This method allows changing\n  /// the filter to explicitly capture them again.\n  ///\n  /// ## Platform-specific\n  ///\n  /// - ** Linux / macOS / iOS / Android**: Unsupported.\n  ///\n  /// # Examples\n  /// ```,no_run\n  /// let mut app = tauri::Builder::default()\n  ///   // on an actual app, remove the string argument\n  ///   .build(tauri::generate_context!(\"test/fixture/src-tauri/tauri.conf.json\"))\n  ///   .expect(\"error while building tauri application\");\n  /// app.set_device_event_filter(tauri::DeviceEventFilter::Always);\n  /// app.run(|_app_handle, _event| {});\n  /// ```\n  ///\n  /// [`tao`]: https://crates.io/crates/tao\n  pub fn set_device_event_filter(&mut self, filter: DeviceEventFilter) {\n    self\n      .runtime\n      .as_mut()\n      .unwrap()\n      .set_device_event_filter(filter);\n  }\n\n  /// Runs the application.\n  ///\n  /// # Examples\n  /// ```,no_run\n  /// let app = tauri::Builder::default()\n  ///   // on an actual app, remove the string argument\n  ///   .build(tauri::generate_context!(\"test/fixture/src-tauri/tauri.conf.json\"))\n  ///   .expect(\"error while building tauri application\");\n  /// app.run(|_app_handle, event| match event {\n  ///   tauri::RunEvent::ExitRequested { api, .. } => {\n  ///     api.prevent_exit();\n  ///   }\n  ///   _ => {}\n  /// });\n  /// ```\n  pub fn run<F: FnMut(&AppHandle<R>, RunEvent) + 'static>(mut self, mut callback: F) {\n    let app_handle = self.handle().clone();\n    let manager = self.manager.clone();\n    self.runtime.take().unwrap().run(move |event| match event {\n      RuntimeRunEvent::Ready => {\n        if let Err(e) = setup(&mut self) {\n          panic!(\"Failed to setup app: {e}\");\n        }\n        let event = on_event_loop_event(&app_handle, RuntimeRunEvent::Ready, &manager);\n        callback(&app_handle, event);\n      }\n      RuntimeRunEvent::Exit => {\n        let event = on_event_loop_event(&app_handle, RuntimeRunEvent::Exit, &manager);\n        callback(&app_handle, event);\n        app_handle.cleanup_before_exit();\n      }\n      _ => {\n        let event = on_event_loop_event(&app_handle, event, &manager);\n        callback(&app_handle, event);\n      }\n    });\n  }\n\n  /// Runs an iteration of the runtime event loop and immediately return.\n  ///\n  /// Note that when using this API, app cleanup is not automatically done.\n  /// The cleanup calls [`App::cleanup_before_exit`] so you may want to call that function before exiting the application.\n  ///\n  /// # Examples\n  /// ```no_run\n  /// use tauri::Manager;\n  ///\n  /// let mut app = tauri::Builder::default()\n  ///   // on an actual app, remove the string argument\n  ///   .build(tauri::generate_context!(\"test/fixture/src-tauri/tauri.conf.json\"))\n  ///   .expect(\"error while building tauri application\");\n  ///\n  /// loop {\n  ///   app.run_iteration(|_app, _event| {});\n  ///   if app.webview_windows().is_empty() {\n  ///     app.cleanup_before_exit();\n  ///     break;\n  ///   }\n  /// }\n  /// ```\n  #[cfg(desktop)]\n  pub fn run_iteration<F: FnMut(&AppHandle<R>, RunEvent) + 'static>(&mut self, mut callback: F) {\n    let manager = self.manager.clone();\n    let app_handle = self.handle().clone();\n\n    if !self.ran_setup {\n      if let Err(e) = setup(self) {\n        panic!(\"Failed to setup app: {e}\");\n      }\n    }\n\n    self.runtime.as_mut().unwrap().run_iteration(move |event| {\n      let event = on_event_loop_event(&app_handle, event, &manager);\n      callback(&app_handle, event);\n    })\n  }\n}\n\n/// Builds a Tauri application.\n///\n/// # Examples\n/// ```,no_run\n/// tauri::Builder::default()\n///   // on an actual app, remove the string argument\n///   .run(tauri::generate_context!(\"test/fixture/src-tauri/tauri.conf.json\"))\n///  .expect(\"error while running tauri application\");\n/// ```\n#[allow(clippy::type_complexity)]\npub struct Builder<R: Runtime> {\n  /// A flag indicating that the runtime must be started on an environment that supports the event loop not on the main thread.\n  #[cfg(any(windows, target_os = \"linux\"))]\n  runtime_any_thread: bool,\n\n  /// The JS message handler.\n  invoke_handler: Box<InvokeHandler<R>>,\n\n  /// The script that initializes the `window.__TAURI_INTERNALS__.postMessage` function.\n  pub(crate) invoke_initialization_script: String,\n\n  channel_interceptor: Option<ChannelInterceptor<R>>,\n\n  /// The setup hook.\n  setup: SetupHook<R>,\n\n  /// Page load hook.\n  on_page_load: Option<Arc<OnPageLoad<R>>>,\n\n  /// All passed plugins\n  plugins: PluginStore<R>,\n\n  /// The webview protocols available to all windows.\n  uri_scheme_protocols: HashMap<String, Arc<UriSchemeProtocol<R>>>,\n\n  /// App state.\n  state: StateManager,\n\n  /// A closure that returns the menu set to all windows.\n  #[cfg(desktop)]\n  menu: Option<Box<dyn FnOnce(&AppHandle<R>) -> crate::Result<Menu<R>> + Send>>,\n\n  /// Menu event listeners for any menu event.\n  #[cfg(desktop)]\n  menu_event_listeners: Vec<GlobalMenuEventListener<AppHandle<R>>>,\n\n  /// Enable macOS default menu creation.\n  #[allow(unused)]\n  enable_macos_default_menu: bool,\n\n  /// Window event handlers that listens to all windows.\n  window_event_listeners: Vec<GlobalWindowEventListener<R>>,\n\n  /// Webview event handlers that listens to all webviews.\n  webview_event_listeners: Vec<GlobalWebviewEventListener<R>>,\n\n  /// The device event filter.\n  device_event_filter: DeviceEventFilter,\n\n  pub(crate) invoke_key: String,\n}\n\n#[derive(Template)]\n#[default_template(\"../scripts/ipc-protocol.js\")]\npub(crate) struct InvokeInitializationScript<'a> {\n  /// The function that processes the IPC message.\n  #[raw]\n  pub(crate) process_ipc_message_fn: &'a str,\n  pub(crate) os_name: &'a str,\n  pub(crate) fetch_channel_data_command: &'a str,\n  pub(crate) invoke_key: &'a str,\n}\n\n/// Make `Wry` the default `Runtime` for `Builder`\n#[cfg(feature = \"wry\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"wry\")))]\nimpl Default for Builder<crate::Wry> {\n  fn default() -> Self {\n    Self::new()\n  }\n}\n\n#[cfg(not(feature = \"wry\"))]\n#[cfg_attr(docsrs, doc(cfg(not(feature = \"wry\"))))]\nimpl<R: Runtime> Default for Builder<R> {\n  fn default() -> Self {\n    Self::new()\n  }\n}\n\nimpl<R: Runtime> Builder<R> {\n  /// Creates a new App builder.\n  pub fn new() -> Self {\n    let invoke_key = crate::generate_invoke_key().unwrap();\n\n    Self {\n      #[cfg(any(windows, target_os = \"linux\"))]\n      runtime_any_thread: false,\n      setup: Box::new(|_| Ok(())),\n      invoke_handler: Box::new(|_| false),\n      invoke_initialization_script: InvokeInitializationScript {\n        process_ipc_message_fn: crate::manager::webview::PROCESS_IPC_MESSAGE_FN,\n        os_name: std::env::consts::OS,\n        fetch_channel_data_command: crate::ipc::channel::FETCH_CHANNEL_DATA_COMMAND,\n        invoke_key: &invoke_key.clone(),\n      }\n      .render_default(&Default::default())\n      .unwrap()\n      .into_string(),\n      channel_interceptor: None,\n      on_page_load: None,\n      plugins: PluginStore::default(),\n      uri_scheme_protocols: Default::default(),\n      state: StateManager::new(),\n      #[cfg(desktop)]\n      menu: None,\n      #[cfg(desktop)]\n      menu_event_listeners: Vec::new(),\n      enable_macos_default_menu: true,\n      window_event_listeners: Vec::new(),\n      webview_event_listeners: Vec::new(),\n      device_event_filter: Default::default(),\n      invoke_key,\n    }\n  }\n}\n\nimpl<R: Runtime> Builder<R> {\n  /// Builds a new Tauri application running on any thread, bypassing the main thread requirement.\n  ///\n  /// ## Platform-specific\n  ///\n  /// - **macOS:** on macOS the application *must* be executed on the main thread, so this function is not exposed.\n  #[cfg(any(windows, target_os = \"linux\"))]\n  #[cfg_attr(docsrs, doc(cfg(any(windows, target_os = \"linux\"))))]\n  #[must_use]\n  pub fn any_thread(mut self) -> Self {\n    self.runtime_any_thread = true;\n    self\n  }\n\n  /// Defines the JS message handler callback.\n  ///\n  /// # Examples\n  /// ```\n  /// #[tauri::command]\n  /// fn command_1() -> String {\n  ///   return \"hello world\".to_string();\n  /// }\n  /// tauri::Builder::default()\n  ///   .invoke_handler(tauri::generate_handler![\n  ///     command_1,\n  ///     // etc...\n  ///   ]);\n  /// ```\n  #[must_use]\n  pub fn invoke_handler<F>(mut self, invoke_handler: F) -> Self\n  where\n    F: Fn(Invoke<R>) -> bool + Send + Sync + 'static,\n  {\n    self.invoke_handler = Box::new(invoke_handler);\n    self\n  }\n\n  /// Defines a custom JS message system.\n  ///\n  /// The `initialization_script` is a script that initializes `window.__TAURI_INTERNALS__.postMessage`.\n  /// That function must take the `(message: object, options: object)` arguments and send it to the backend.\n  ///\n  /// Additionally, the script must include a `__INVOKE_KEY__` token that is replaced with a value that must be sent with the IPC payload\n  /// to check the integrity of the message by the [`crate::WebviewWindow::on_message`] API, e.g.\n  ///\n  /// ```js\n  /// const invokeKey = __INVOKE_KEY__;\n  /// fetch('my-impl://command', {\n  ///   headers: {\n  ///     'Tauri-Invoke-Key': invokeKey,\n  ///   }\n  /// })\n  /// ```\n  ///\n  /// Note that the implementation details is up to your implementation.\n  #[must_use]\n  pub fn invoke_system(mut self, initialization_script: String) -> Self {\n    self.invoke_initialization_script =\n      initialization_script.replace(\"__INVOKE_KEY__\", &format!(\"\\\"{}\\\"\", self.invoke_key));\n    self\n  }\n\n  /// Registers a channel interceptor that can overwrite the default channel implementation.\n  ///\n  /// If the event has been consumed, it must return `true`.\n  ///\n  /// The channel automatically orders the messages, so the third closure argument represents the message number.\n  /// The payload expected by the channel receiver is in the form of `{ id: usize, message: T }`.\n  pub fn channel_interceptor<\n    F: Fn(&Webview<R>, CallbackFn, usize, &InvokeResponseBody) -> bool + Send + Sync + 'static,\n  >(\n    mut self,\n    interceptor: F,\n  ) -> Self {\n    self.channel_interceptor.replace(Box::new(interceptor));\n    self\n  }\n\n  /// Append a custom initialization script.\n  ///\n  /// Allow to append custom initialization script instend of replacing entire invoke system.\n  ///\n  /// # Examples\n  ///\n  /// ```\n  /// let custom_script = r#\"\n  /// // A custom call system bridge build on top of tauri invoke system.\n  /// async function invoke(cmd, args = {}) {\n  ///   if (!args) args = {};\n  ///\n  ///   let prefix = \"\";\n  ///\n  ///   if (args?.__module) {\n  ///     prefix = `plugin:hybridcall.${args.__module}|`;\n  ///   }\n  ///\n  ///   const command = `${prefix}tauri_${cmd}`;\n  ///\n  ///   const invoke = window.__TAURI_INTERNALS__.invoke;\n  ///\n  ///   return invoke(command, args).then(result => {\n  ///     if (window.build.debug) {\n  ///       console.log(`call: ${command}`);\n  ///       console.log(`args: ${JSON.stringify(args)}`);\n  ///       console.log(`return: ${JSON.stringify(result)}`);\n  ///     }\n  ///\n  ///     return result;\n  ///   });\n  /// }\n  /// \"#;\n  ///\n  /// tauri::Builder::default()\n  ///   .append_invoke_initialization_script(custom_script);\n  /// ```\n  pub fn append_invoke_initialization_script(\n    mut self,\n    initialization_script: impl AsRef<str>,\n  ) -> Self {\n    self\n      .invoke_initialization_script\n      .push_str(initialization_script.as_ref());\n    self\n  }\n\n  /// Defines the setup hook.\n  ///\n  /// # Examples\n  #[cfg_attr(\n    feature = \"unstable\",\n    doc = r####\"\n```\nuse tauri::Manager;\ntauri::Builder::default()\n  .setup(|app| {\n    let main_window = app.get_window(\"main\").unwrap();\n    main_window.set_title(\"Tauri!\")?;\n    Ok(())\n  });\n```\n  \"####\n  )]\n  #[must_use]\n  pub fn setup<F>(mut self, setup: F) -> Self\n  where\n    F: FnOnce(&mut App<R>) -> std::result::Result<(), Box<dyn std::error::Error>> + Send + 'static,\n  {\n    self.setup = Box::new(setup);\n    self\n  }\n\n  /// Defines the page load hook.\n  #[must_use]\n  pub fn on_page_load<F>(mut self, on_page_load: F) -> Self\n  where\n    F: Fn(&Webview<R>, &PageLoadPayload<'_>) + Send + Sync + 'static,\n  {\n    self.on_page_load.replace(Arc::new(on_page_load));\n    self\n  }\n\n  /// Adds a Tauri application plugin.\n  ///\n  /// A plugin is created using the [`crate::plugin::Builder`] struct.Check its documentation for more information.\n  ///\n  /// # Examples\n  ///\n  /// ```\n  /// mod plugin {\n  ///   use tauri::{plugin::{Builder as PluginBuilder, TauriPlugin}, RunEvent, Runtime};\n  ///\n  ///   // this command can be called in the frontend using `invoke('plugin:window|do_something')`.\n  ///   #[tauri::command]\n  ///   async fn do_something<R: Runtime>(app: tauri::AppHandle<R>, window: tauri::Window<R>) -> Result<(), String> {\n  ///     println!(\"command called\");\n  ///     Ok(())\n  ///   }\n  ///   pub fn init<R: Runtime>() -> TauriPlugin<R> {\n  ///     PluginBuilder::new(\"window\")\n  ///       .setup(|app, api| {\n  ///         // initialize the plugin here\n  ///         Ok(())\n  ///       })\n  ///       .on_event(|app, event| {\n  ///         match event {\n  ///           RunEvent::Ready => {\n  ///             println!(\"app is ready\");\n  ///           }\n  ///           RunEvent::WindowEvent { label, event, .. } => {\n  ///             println!(\"window {} received an event: {:?}\", label, event);\n  ///           }\n  ///           _ => (),\n  ///         }\n  ///       })\n  ///       .invoke_handler(tauri::generate_handler![do_something])\n  ///       .build()\n  ///   }\n  /// }\n  ///\n  /// tauri::Builder::default()\n  ///   .plugin(plugin::init());\n  /// ```\n  #[must_use]\n  pub fn plugin<P: Plugin<R> + 'static>(mut self, plugin: P) -> Self {\n    self.plugins.register(Box::new(plugin));\n    self\n  }\n\n  /// Add `state` to the state managed by the application.\n  ///\n  /// This method can be called any number of times as long as each call\n  /// refers to a different `T`.\n  ///\n  /// Managed state can be retrieved by any command handler via the\n  /// [`crate::State`] guard. In particular, if a value of type `T`\n  /// is managed by Tauri, adding `State<T>` to the list of arguments in a\n  /// command handler instructs Tauri to retrieve the managed value.\n  /// Additionally, [`state`](crate::Manager#method.state) can be used to retrieve the value manually.\n  ///\n  /// # Panics\n  ///\n  /// Panics if state of type `T` is already being managed.\n  ///\n  /// # Mutability\n  ///\n  /// Since the managed state is global and must be [`Send`] + [`Sync`], mutations can only happen through interior mutability:\n  ///\n  /// ```,no_run\n  /// use std::{collections::HashMap, sync::Mutex};\n  /// use tauri::State;\n  /// // here we use Mutex to achieve interior mutability\n  /// struct Storage {\n  ///   store: Mutex<HashMap<u64, String>>,\n  /// }\n  /// struct Connection;\n  /// struct DbConnection {\n  ///   db: Mutex<Option<Connection>>,\n  /// }\n  ///\n  /// #[tauri::command]\n  /// fn connect(connection: State<DbConnection>) {\n  ///   // initialize the connection, mutating the state with interior mutability\n  ///   *connection.db.lock().unwrap() = Some(Connection {});\n  /// }\n  ///\n  /// #[tauri::command]\n  /// fn storage_insert(key: u64, value: String, storage: State<Storage>) {\n  ///   // mutate the storage behind the Mutex\n  ///   storage.store.lock().unwrap().insert(key, value);\n  /// }\n  ///\n  /// tauri::Builder::default()\n  ///   .manage(Storage { store: Default::default() })\n  ///   .manage(DbConnection { db: Default::default() })\n  ///   .invoke_handler(tauri::generate_handler![connect, storage_insert])\n  ///   // on an actual app, remove the string argument\n  ///   .run(tauri::generate_context!(\"test/fixture/src-tauri/tauri.conf.json\"))\n  ///   .expect(\"error while running tauri application\");\n  /// ```\n  ///\n  /// # Examples\n  ///\n  /// ```,no_run\n  /// use tauri::State;\n  ///\n  /// struct MyInt(isize);\n  /// struct MyString(String);\n  ///\n  /// #[tauri::command]\n  /// fn int_command(state: State<MyInt>) -> String {\n  ///     format!(\"The stateful int is: {}\", state.0)\n  /// }\n  ///\n  /// #[tauri::command]\n  /// fn string_command<'r>(state: State<'r, MyString>) {\n  ///     println!(\"state: {}\", state.inner().0);\n  /// }\n  ///\n  /// tauri::Builder::default()\n  ///   .manage(MyInt(10))\n  ///   .manage(MyString(\"Hello, managed state!\".to_string()))\n  ///   .invoke_handler(tauri::generate_handler![int_command, string_command])\n  ///   // on an actual app, remove the string argument\n  ///   .run(tauri::generate_context!(\"test/fixture/src-tauri/tauri.conf.json\"))\n  ///   .expect(\"error while running tauri application\");\n  /// ```\n  #[must_use]\n  pub fn manage<T>(self, state: T) -> Self\n  where\n    T: Send + Sync + 'static,\n  {\n    let type_name = std::any::type_name::<T>();\n    assert!(\n      self.state.set(state),\n      \"state for type '{type_name}' is already being managed\",\n    );\n    self\n  }\n\n  /// Sets the menu to use on all windows.\n  ///\n  /// # Examples\n  /// ```\n  /// use tauri::menu::{Menu, MenuItem, PredefinedMenuItem, Submenu};\n  ///\n  /// tauri::Builder::default()\n  ///   .menu(|handle| Menu::with_items(handle, &[\n  ///     &Submenu::with_items(\n  ///       handle,\n  ///       \"File\",\n  ///       true,\n  ///       &[\n  ///         &PredefinedMenuItem::close_window(handle, None)?,\n  ///         #[cfg(target_os = \"macos\")]\n  ///         &MenuItem::new(handle, \"Hello\", true, None::<&str>)?,\n  ///       ],\n  ///     )?\n  ///   ]));\n  /// ```\n  #[must_use]\n  #[cfg(desktop)]\n  pub fn menu<F: FnOnce(&AppHandle<R>) -> crate::Result<Menu<R>> + Send + 'static>(\n    mut self,\n    f: F,\n  ) -> Self {\n    self.menu.replace(Box::new(f));\n    self\n  }\n\n  /// Registers an event handler for any menu event.\n  ///\n  /// # Examples\n  /// ```\n  /// use tauri::menu::*;\n  ///\n  /// tauri::Builder::default()\n  ///   .on_menu_event(|app, event| {\n  ///      if event.id() == \"quit\" {\n  ///        app.exit(0);\n  ///      }\n  ///   });\n  /// ```\n  #[must_use]\n  #[cfg(desktop)]\n  pub fn on_menu_event<F: Fn(&AppHandle<R>, MenuEvent) + Send + Sync + 'static>(\n    mut self,\n    f: F,\n  ) -> Self {\n    self.menu_event_listeners.push(Box::new(f));\n    self\n  }\n\n  /// Enable or disable the default menu on macOS. Enabled by default.\n  ///\n  /// # Examples\n  /// ```\n  /// tauri::Builder::default()\n  ///   .enable_macos_default_menu(false);\n  /// ```\n  #[must_use]\n  pub fn enable_macos_default_menu(mut self, enable: bool) -> Self {\n    self.enable_macos_default_menu = enable;\n    self\n  }\n\n  /// Registers a window event handler for all windows.\n  ///\n  /// # Examples\n  /// ```\n  /// tauri::Builder::default()\n  ///   .on_window_event(|window, event| match event {\n  ///     tauri::WindowEvent::Focused(focused) => {\n  ///       // hide window whenever it loses focus\n  ///       if !focused {\n  ///         window.hide().unwrap();\n  ///       }\n  ///     }\n  ///     _ => {}\n  ///   });\n  /// ```\n  #[must_use]\n  pub fn on_window_event<F: Fn(&Window<R>, &WindowEvent) + Send + Sync + 'static>(\n    mut self,\n    handler: F,\n  ) -> Self {\n    self.window_event_listeners.push(Box::new(handler));\n    self\n  }\n\n  /// Registers a webview event handler for all webviews.\n  ///\n  /// # Examples\n  /// ```\n  /// tauri::Builder::default()\n  ///   .on_webview_event(|window, event| match event {\n  ///     tauri::WebviewEvent::DragDrop(event) => {\n  ///       println!(\"{:?}\", event);\n  ///     }\n  ///     _ => {}\n  ///   });\n  /// ```\n  #[must_use]\n  pub fn on_webview_event<F: Fn(&Webview<R>, &WebviewEvent) + Send + Sync + 'static>(\n    mut self,\n    handler: F,\n  ) -> Self {\n    self.webview_event_listeners.push(Box::new(handler));\n    self\n  }\n\n  /// Registers a URI scheme protocol available to all webviews.\n  ///\n  /// Leverages [setURLSchemeHandler](https://developer.apple.com/documentation/webkit/wkwebviewconfiguration/2875766-seturlschemehandler) on macOS,\n  /// [AddWebResourceRequestedFilter](https://docs.microsoft.com/en-us/dotnet/api/microsoft.web.webview2.core.corewebview2.addwebresourcerequestedfilter?view=webview2-dotnet-1.0.774.44) on Windows\n  /// and [webkit-web-context-register-uri-scheme](https://webkitgtk.org/reference/webkit2gtk/stable/WebKitWebContext.html#webkit-web-context-register-uri-scheme) on Linux.\n  ///\n  /// # Arguments\n  ///\n  /// * `uri_scheme` The URI scheme to register, such as `example`.\n  /// * `protocol` the protocol associated with the given URI scheme. It's a function that takes a request and returns a response.\n  ///\n  /// # Examples\n  /// ```\n  /// tauri::Builder::default()\n  ///   .register_uri_scheme_protocol(\"app-files\", |_ctx, request| {\n  ///     // skip leading `/`\n  ///     if let Ok(data) = std::fs::read(&request.uri().path()[1..]) {\n  ///       http::Response::builder()\n  ///         .body(data)\n  ///         .unwrap()\n  ///     } else {\n  ///       http::Response::builder()\n  ///         .status(http::StatusCode::BAD_REQUEST)\n  ///         .header(http::header::CONTENT_TYPE, mime::TEXT_PLAIN.essence_str())\n  ///         .body(\"failed to read file\".as_bytes().to_vec())\n  ///         .unwrap()\n  ///     }\n  ///   });\n  /// ```\n  #[must_use]\n  pub fn register_uri_scheme_protocol<\n    N: Into<String>,\n    T: Into<Cow<'static, [u8]>>,\n    H: Fn(UriSchemeContext<'_, R>, http::Request<Vec<u8>>) -> http::Response<T>\n      + Send\n      + Sync\n      + 'static,\n  >(\n    mut self,\n    uri_scheme: N,\n    protocol: H,\n  ) -> Self {\n    self.uri_scheme_protocols.insert(\n      uri_scheme.into(),\n      Arc::new(UriSchemeProtocol {\n        protocol: Box::new(move |ctx, request, responder| {\n          responder.respond(protocol(ctx, request))\n        }),\n      }),\n    );\n    self\n  }\n\n  /// Similar to [`Self::register_uri_scheme_protocol`] but with an asynchronous responder that allows you\n  /// to process the request in a separate thread and respond asynchronously.\n  ///\n  /// # Arguments\n  ///\n  /// * `uri_scheme` The URI scheme to register, such as `example`.\n  /// * `protocol` the protocol associated with the given URI scheme. It's a function that takes an URL such as `example://localhost/asset.css`.\n  ///\n  /// # Examples\n  /// ```\n  /// tauri::Builder::default()\n  ///   .register_asynchronous_uri_scheme_protocol(\"app-files\", |_ctx, request, responder| {\n  ///     // skip leading `/`\n  ///     let path = request.uri().path()[1..].to_string();\n  ///     std::thread::spawn(move || {\n  ///       if let Ok(data) = std::fs::read(path) {\n  ///         responder.respond(\n  ///           http::Response::builder()\n  ///             .body(data)\n  ///             .unwrap()\n  ///         );\n  ///       } else {\n  ///         responder.respond(\n  ///           http::Response::builder()\n  ///             .status(http::StatusCode::BAD_REQUEST)\n  ///             .header(http::header::CONTENT_TYPE, mime::TEXT_PLAIN.essence_str())\n  ///             .body(\"failed to read file\".as_bytes().to_vec())\n  ///             .unwrap()\n  ///         );\n  ///     }\n  ///   });\n  ///   });\n  /// ```\n  #[must_use]\n  pub fn register_asynchronous_uri_scheme_protocol<\n    N: Into<String>,\n    H: Fn(UriSchemeContext<'_, R>, http::Request<Vec<u8>>, UriSchemeResponder) + Send + Sync + 'static,\n  >(\n    mut self,\n    uri_scheme: N,\n    protocol: H,\n  ) -> Self {\n    self.uri_scheme_protocols.insert(\n      uri_scheme.into(),\n      Arc::new(UriSchemeProtocol {\n        protocol: Box::new(protocol),\n      }),\n    );\n    self\n  }\n\n  /// Change the device event filter mode.\n  ///\n  /// Since the DeviceEvent capture can lead to high CPU usage for unfocused windows, [`tao`]\n  /// will ignore them by default for unfocused windows on Windows. This method allows changing\n  /// the filter to explicitly capture them again.\n  ///\n  /// ## Platform-specific\n  ///\n  /// - ** Linux / macOS / iOS / Android**: Unsupported.\n  ///\n  /// # Examples\n  /// ```,no_run\n  /// tauri::Builder::default()\n  ///   .device_event_filter(tauri::DeviceEventFilter::Always);\n  /// ```\n  ///\n  /// [`tao`]: https://crates.io/crates/tao\n  pub fn device_event_filter(mut self, filter: DeviceEventFilter) -> Self {\n    self.device_event_filter = filter;\n    self\n  }\n\n  /// Builds the application.\n  #[allow(clippy::type_complexity, unused_mut)]\n  #[cfg_attr(\n    feature = \"tracing\",\n    tracing::instrument(name = \"app::build\", skip_all)\n  )]\n  pub fn build(mut self, context: Context<R>) -> crate::Result<App<R>> {\n    #[cfg(target_os = \"macos\")]\n    if self.menu.is_none() && self.enable_macos_default_menu {\n      self.menu = Some(Box::new(|app_handle| {\n        crate::menu::Menu::default(app_handle)\n      }));\n    }\n\n    let manager = Arc::new(AppManager::with_handlers(\n      context,\n      self.plugins,\n      self.invoke_handler,\n      self.on_page_load,\n      self.uri_scheme_protocols,\n      self.state,\n      #[cfg(desktop)]\n      self.menu_event_listeners,\n      self.window_event_listeners,\n      self.webview_event_listeners,\n      #[cfg(desktop)]\n      HashMap::new(),\n      self.invoke_initialization_script,\n      self.channel_interceptor,\n      self.invoke_key,\n    ));\n\n    #[cfg(any(\n      target_os = \"linux\",\n      target_os = \"dragonfly\",\n      target_os = \"freebsd\",\n      target_os = \"netbsd\",\n      target_os = \"openbsd\"\n    ))]\n    let app_id = if manager.config.app.enable_gtk_app_id {\n      Some(manager.config.identifier.clone())\n    } else {\n      None\n    };\n\n    let runtime_args = RuntimeInitArgs {\n      #[cfg(any(\n        target_os = \"linux\",\n        target_os = \"dragonfly\",\n        target_os = \"freebsd\",\n        target_os = \"netbsd\",\n        target_os = \"openbsd\"\n      ))]\n      app_id,\n\n      #[cfg(windows)]\n      msg_hook: {\n        let menus = manager.menu.menus.clone();\n        Some(Box::new(move |msg| {\n          use windows::Win32::UI::WindowsAndMessaging::{TranslateAcceleratorW, HACCEL, MSG};\n          unsafe {\n            let msg = msg as *const MSG;\n            for menu in menus.lock().unwrap().values() {\n              let translated =\n                TranslateAcceleratorW((*msg).hwnd, HACCEL(menu.inner().haccel() as _), msg);\n              if translated == 1 {\n                return true;\n              }\n            }\n\n            false\n          }\n        }))\n      },\n    };\n\n    #[cfg(any(windows, target_os = \"linux\"))]\n    let mut runtime = if self.runtime_any_thread {\n      R::new_any_thread(runtime_args)?\n    } else {\n      R::new(runtime_args)?\n    };\n    #[cfg(not(any(windows, target_os = \"linux\")))]\n    let mut runtime = R::new(runtime_args)?;\n\n    #[cfg(desktop)]\n    {\n      // setup menu event handler\n      let proxy = runtime.create_proxy();\n      muda::MenuEvent::set_event_handler(Some(move |e: muda::MenuEvent| {\n        let _ = proxy.send_event(EventLoopMessage::MenuEvent(e.into()));\n      }));\n\n      // setup tray event handler\n      #[cfg(feature = \"tray-icon\")]\n      {\n        let proxy = runtime.create_proxy();\n        tray_icon::TrayIconEvent::set_event_handler(Some(move |e: tray_icon::TrayIconEvent| {\n          let _ = proxy.send_event(EventLoopMessage::TrayIconEvent(e.into()));\n        }));\n      }\n    }\n\n    runtime.set_device_event_filter(self.device_event_filter);\n\n    let runtime_handle = runtime.handle();\n\n    #[allow(unused_mut)]\n    let mut app = App {\n      runtime: Some(runtime),\n      setup: Some(self.setup),\n      manager: manager.clone(),\n      handle: AppHandle {\n        runtime_handle,\n        manager,\n      },\n      ran_setup: false,\n    };\n\n    #[cfg(desktop)]\n    if let Some(menu) = self.menu {\n      let menu = menu(&app.handle)?;\n      app\n        .manager\n        .menu\n        .menus_stash_lock()\n        .insert(menu.id().clone(), menu.clone());\n\n      #[cfg(target_os = \"macos\")]\n      init_app_menu(&menu)?;\n\n      app.manager.menu.menu_lock().replace(menu);\n    }\n\n    app.register_core_plugins()?;\n\n    let env = Env::default();\n    app.manage(env);\n\n    app.manage(Scopes {\n      #[cfg(feature = \"protocol-asset\")]\n      asset_protocol: crate::scope::fs::Scope::new(\n        &app,\n        &app.config().app.security.asset_protocol.scope,\n      )?,\n    });\n\n    app.manage(ChannelDataIpcQueue::default());\n    app.handle.plugin(crate::ipc::channel::plugin())?;\n\n    #[cfg(windows)]\n    {\n      if let crate::utils::config::WebviewInstallMode::FixedRuntime { path } =\n        &app.manager.config().bundle.windows.webview_install_mode\n      {\n        if let Ok(resource_dir) = app.path().resource_dir() {\n          std::env::set_var(\n            \"WEBVIEW2_BROWSER_EXECUTABLE_FOLDER\",\n            resource_dir.join(path),\n          );\n        } else {\n          #[cfg(debug_assertions)]\n          eprintln!(\n            \"failed to resolve resource directory; fallback to the installed Webview2 runtime.\"\n          );\n        }\n      }\n    }\n\n    let handle = app.handle();\n\n    // initialize default tray icon if defined\n    #[cfg(all(desktop, feature = \"tray-icon\"))]\n    {\n      let config = app.config();\n      if let Some(tray_config) = &config.app.tray_icon {\n        let mut tray =\n          TrayIconBuilder::with_id(tray_config.id.clone().unwrap_or_else(|| \"main\".into()))\n            .icon_as_template(tray_config.icon_as_template)\n            .menu_on_left_click(tray_config.menu_on_left_click);\n        if let Some(icon) = &app.manager.tray.icon {\n          tray = tray.icon(icon.clone());\n        }\n        if let Some(title) = &tray_config.title {\n          tray = tray.title(title);\n        }\n        if let Some(tooltip) = &tray_config.tooltip {\n          tray = tray.tooltip(tooltip);\n        }\n        tray.build(handle)?;\n      }\n    }\n\n    app.manager.initialize_plugins(handle)?;\n\n    Ok(app)\n  }\n\n  /// Runs the configured Tauri application.\n  pub fn run(self, context: Context<R>) -> crate::Result<()> {\n    self.build(context)?.run(|_, _| {});\n    Ok(())\n  }\n}\n\npub(crate) type UriSchemeResponderFn = Box<dyn FnOnce(http::Response<Cow<'static, [u8]>>) + Send>;\n\n/// Async uri scheme protocol responder.\npub struct UriSchemeResponder(pub(crate) UriSchemeResponderFn);\n\nimpl UriSchemeResponder {\n  /// Resolves the request with the given response.\n  pub fn respond<T: Into<Cow<'static, [u8]>>>(self, response: http::Response<T>) {\n    let (parts, body) = response.into_parts();\n    (self.0)(http::Response::from_parts(parts, body.into()))\n  }\n}\n\n/// Uri scheme protocol context\npub struct UriSchemeContext<'a, R: Runtime> {\n  pub(crate) app_handle: &'a AppHandle<R>,\n  pub(crate) webview_label: &'a str,\n}\n\nimpl<'a, R: Runtime> UriSchemeContext<'a, R> {\n  /// Get a reference to an [`AppHandle`].\n  pub fn app_handle(&self) -> &'a AppHandle<R> {\n    self.app_handle\n  }\n\n  /// Get the webview label that made the uri scheme request.\n  pub fn webview_label(&self) -> &'a str {\n    self.webview_label\n  }\n}\n\n#[cfg(target_os = \"macos\")]\nfn init_app_menu<R: Runtime>(menu: &Menu<R>) -> crate::Result<()> {\n  menu.inner().init_for_nsapp();\n\n  if let Some(window_menu) = menu.get(crate::menu::WINDOW_SUBMENU_ID) {\n    if let Some(m) = window_menu.as_submenu() {\n      m.set_as_windows_menu_for_nsapp()?;\n    }\n  }\n  if let Some(help_menu) = menu.get(crate::menu::HELP_SUBMENU_ID) {\n    if let Some(m) = help_menu.as_submenu() {\n      m.set_as_help_menu_for_nsapp()?;\n    }\n  }\n\n  Ok(())\n}\n\nimpl<R: Runtime> HasDisplayHandle for AppHandle<R> {\n  fn display_handle(\n    &self,\n  ) -> std::result::Result<raw_window_handle::DisplayHandle<'_>, raw_window_handle::HandleError> {\n    self.runtime_handle.display_handle()\n  }\n}\n\nimpl<R: Runtime> HasDisplayHandle for App<R> {\n  fn display_handle(\n    &self,\n  ) -> std::result::Result<raw_window_handle::DisplayHandle<'_>, raw_window_handle::HandleError> {\n    self.handle.display_handle()\n  }\n}\n\n#[cfg_attr(feature = \"tracing\", tracing::instrument(name = \"app::setup\"))]\nfn setup<R: Runtime>(app: &mut App<R>) -> crate::Result<()> {\n  app.ran_setup = true;\n\n  for window_config in app.config().app.windows.iter().filter(|w| w.create) {\n    WebviewWindowBuilder::from_config(app.handle(), window_config)?.build()?;\n  }\n\n  app.manager.assets.setup(app);\n\n  if let Some(setup) = app.setup.take() {\n    (setup)(app).map_err(|e| crate::Error::Setup(e.into()))?;\n  }\n\n  Ok(())\n}\n\nfn on_event_loop_event<R: Runtime>(\n  app_handle: &AppHandle<R>,\n  event: RuntimeRunEvent<EventLoopMessage>,\n  manager: &AppManager<R>,\n) -> RunEvent {\n  if let RuntimeRunEvent::WindowEvent {\n    label,\n    event: RuntimeWindowEvent::Destroyed,\n  } = &event\n  {\n    manager.on_window_close(label);\n  }\n\n  let event = match event {\n    RuntimeRunEvent::Exit => RunEvent::Exit,\n    RuntimeRunEvent::ExitRequested { code, tx } => RunEvent::ExitRequested {\n      code,\n      api: ExitRequestApi(tx),\n    },\n    RuntimeRunEvent::WindowEvent { label, event } => RunEvent::WindowEvent {\n      label,\n      event: event.into(),\n    },\n    RuntimeRunEvent::WebviewEvent { label, event } => RunEvent::WebviewEvent {\n      label,\n      event: event.into(),\n    },\n    RuntimeRunEvent::Ready => {\n      // set the app icon in development\n      #[cfg(all(dev, target_os = \"macos\"))]\n      {\n        use objc2::ClassType;\n        use objc2_app_kit::{NSApplication, NSImage};\n        use objc2_foundation::{MainThreadMarker, NSData};\n\n        if let Some(icon) = app_handle.manager.app_icon.clone() {\n          // TODO: Enable this check.\n          let mtm = unsafe { MainThreadMarker::new_unchecked() };\n          let app = NSApplication::sharedApplication(mtm);\n          let data = NSData::with_bytes(&icon);\n          let app_icon = NSImage::initWithData(NSImage::alloc(), &data).expect(\"creating icon\");\n          unsafe { app.setApplicationIconImage(Some(&app_icon)) };\n        }\n      }\n      RunEvent::Ready\n    }\n    RuntimeRunEvent::Resumed => RunEvent::Resumed,\n    RuntimeRunEvent::MainEventsCleared => RunEvent::MainEventsCleared,\n    RuntimeRunEvent::UserEvent(t) => {\n      match t {\n        #[cfg(desktop)]\n        EventLoopMessage::MenuEvent(ref e) => {\n          for listener in &*app_handle\n            .manager\n            .menu\n            .global_event_listeners\n            .lock()\n            .unwrap()\n          {\n            listener(app_handle, e.clone());\n          }\n          for (label, listener) in &*app_handle.manager.menu.event_listeners.lock().unwrap() {\n            if let Some(w) = app_handle.manager().get_window(label) {\n              listener(&w, e.clone());\n            }\n          }\n        }\n        #[cfg(all(desktop, feature = \"tray-icon\"))]\n        EventLoopMessage::TrayIconEvent(ref e) => {\n          for listener in &*app_handle\n            .manager\n            .tray\n            .global_event_listeners\n            .lock()\n            .unwrap()\n          {\n            listener(app_handle, e.clone());\n          }\n\n          for (id, listener) in &*app_handle.manager.tray.event_listeners.lock().unwrap() {\n            if e.id() == id {\n              if let Some(tray) = app_handle.tray_by_id(id) {\n                listener(&tray, e.clone());\n              }\n            }\n          }\n        }\n      }\n\n      #[allow(unreachable_code)]\n      t.into()\n    }\n    #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n    RuntimeRunEvent::Opened { urls } => RunEvent::Opened { urls },\n    #[cfg(target_os = \"macos\")]\n    RuntimeRunEvent::Reopen {\n      has_visible_windows,\n    } => RunEvent::Reopen {\n      has_visible_windows,\n    },\n    _ => unimplemented!(),\n  };\n\n  manager\n    .plugins\n    .lock()\n    .expect(\"poisoned plugin store\")\n    .on_event(app_handle, &event);\n\n  event\n}\n\n#[cfg(test)]\nmod tests {\n  #[test]\n  fn is_send_sync() {\n    crate::test_utils::assert_send::<super::AppHandle>();\n    crate::test_utils::assert_sync::<super::AppHandle>();\n\n    #[cfg(feature = \"wry\")]\n    {\n      crate::test_utils::assert_send::<super::AssetResolver<crate::Wry>>();\n      crate::test_utils::assert_sync::<super::AssetResolver<crate::Wry>>();\n    }\n  }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "095c7d60ad109c98bc2703762774d0132adc8359",
    "func": "extern crate diesel;\n\nuse diesel::prelude::*;\n\ntable! {\n    users {\n        id -> Integer,\n        name -> Binary,\n    }\n}\n\nfn main() {\n    use self::users::dsl::*;\n\n    let mut connection = SqliteConnection::establish(\"\").unwrap();\n\n    users\n        .select(name.concat(b\"foo\".to_vec()))\n        .filter(name.like(b\"bar\".to_vec()))\n        .filter(name.not_like(b\"baz\".to_vec()))\n        .get_result::<Vec<u8>>(&mut connection).unwrap();\n\n    let mut connection = MysqlConnection::establish(\"\").unwrap();\n\n    users\n        .select(name.concat(b\"foo\".to_vec()))\n        .filter(name.like(b\"bar\".to_vec()))\n        .filter(name.not_like(b\"baz\".to_vec()))\n        .get_result::<Vec<u8>>(&mut connection).unwrap();\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "b12beab5e5598b069cc8739891d45d4ba9d752fa",
    "func": "// this is copied from itertools under the following license\n//\n// Copyright (c) 2015\n//\n// Permission is hereby granted, free of charge, to any\n// person obtaining a copy of this software and associated\n// documentation files (the \"Software\"), to deal in the\n// Software without restriction, including without\n// limitation the rights to use, copy, modify, merge,\n// publish, distribute, sublicense, and/or sell copies of\n// the Software, and to permit persons to whom the Software\n// is furnished to do so, subject to the following\n// conditions:\n//\n// The above copyright notice and this permission notice\n// shall be included in all copies or substantial portions\n// of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF\n// ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n// TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT\n// SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR\n// IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n// DEALINGS IN THE SOFTWARE.\n\nuse std::iter::{Fuse, FusedIterator, Peekable};\n\npub(crate) struct WithPosition<I>\nwhere\n    I: Iterator,\n{\n    handled_first: bool,\n    peekable: Peekable<Fuse<I>>,\n}\n\nimpl<I> WithPosition<I>\nwhere\n    I: Iterator,\n{\n    pub(crate) fn new(iter: impl IntoIterator<IntoIter = I>) -> WithPosition<I> {\n        WithPosition {\n            handled_first: false,\n            peekable: iter.into_iter().fuse().peekable(),\n        }\n    }\n}\n\nimpl<I> Clone for WithPosition<I>\nwhere\n    I: Clone + Iterator,\n    I::Item: Clone,\n{\n    fn clone(&self) -> Self {\n        Self {\n            handled_first: self.handled_first,\n            peekable: self.peekable.clone(),\n        }\n    }\n}\n\n#[derive(Copy, Clone, Debug, PartialEq)]\npub(crate) enum Position<T> {\n    First(T),\n    Middle(T),\n    Last(T),\n    Only(T),\n}\n\nimpl<T> Position<T> {\n    pub(crate) fn into_inner(self) -> T {\n        match self {\n            Position::First(x) | Position::Middle(x) | Position::Last(x) | Position::Only(x) => x,\n        }\n    }\n}\n\nimpl<I: Iterator> Iterator for WithPosition<I> {\n    type Item = Position<I::Item>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        match self.peekable.next() {\n            Some(item) => {\n                if !self.handled_first {\n                    // Haven't seen the first item yet, and there is one to give.\n                    self.handled_first = true;\n                    // Peek to see if this is also the last item,\n                    // in which case tag it as `Only`.\n                    match self.peekable.peek() {\n                        Some(_) => Some(Position::First(item)),\n                        None => Some(Position::Only(item)),\n                    }\n                } else {\n                    // Have seen the first item, and there's something left.\n                    // Peek to see if this is the last item.\n                    match self.peekable.peek() {\n                        Some(_) => Some(Position::Middle(item)),\n                        None => Some(Position::Last(item)),\n                    }\n                }\n            }\n            // Iterator is finished.\n            None => None,\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.peekable.size_hint()\n    }\n}\n\nimpl<I> ExactSizeIterator for WithPosition<I> where I: ExactSizeIterator {}\n\nimpl<I: Iterator> FusedIterator for WithPosition<I> {}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "ae62a34ab090efd371c25fa57f0ae7adadbbf039",
    "func": "//! This example only enables a minimal set of plugins required for bevy to run.\n//! You can also completely remove rendering / windowing Plugin code from bevy\n//! by making your import look like this in your Cargo.toml.\n//!\n//! ```toml\n//! [dependencies]\n//! bevy = { version = \"*\", default-features = false }\n//! # replace \"*\" with the most recent version of bevy\n//! ```\n\nuse bevy::{app::ScheduleRunnerPlugin, log::LogPlugin, prelude::*, utils::Duration};\n\nfn main() {\n    // This app runs once\n    App::new()\n        .add_plugins(HeadlessPlugins.set(ScheduleRunnerPlugin::run_once()))\n        .add_systems(Update, hello_world_system)\n        .run();\n\n    // This app loops forever at 60 fps\n    App::new()\n        .add_plugins(\n            HeadlessPlugins\n                .set(ScheduleRunnerPlugin::run_loop(Duration::from_secs_f64(\n                    1.0 / 60.0,\n                )))\n                // The log and ctrl+c plugin can only be registered once globally,\n                // which means we need to disable it here, because it was already registered with the\n                // app that runs once.\n                .disable::<LogPlugin>(),\n        )\n        .add_systems(Update, counter)\n        .run();\n}\n\nfn hello_world_system() {\n    println!(\"hello world\");\n}\n\nfn counter(mut state: Local<CounterState>) {\n    if state.count % 60 == 0 {\n        println!(\"{}\", state.count);\n    }\n    state.count += 1;\n}\n\n#[derive(Default)]\nstruct CounterState {\n    count: u32,\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "7eec055d5b91d8256b06e07b15ff6c937bdf7705",
    "func": "use gloo::console::error;\nuse wasm_bindgen::JsValue;\nuse web_sys::History;\n\npub(crate) fn replace_state_with_url(\n    history: &History,\n    value: &[f64; 2],\n    url: Option<&str>,\n) -> Result<(), JsValue> {\n    let position = js_sys::Array::new();\n    position.push(&JsValue::from(value[0]));\n    position.push(&JsValue::from(value[1]));\n\n    history.replace_state_with_url(&position, \"\", url)\n}\n\npub(crate) fn push_state_and_url(\n    history: &History,\n    value: &[f64; 2],\n    url: String,\n) -> Result<(), JsValue> {\n    let position = js_sys::Array::new();\n    position.push(&JsValue::from(value[0]));\n    position.push(&JsValue::from(value[1]));\n\n    history.push_state_with_url(&position, \"\", Some(&url))\n}\n\npub(crate) fn get_current(history: &History) -> Option<[f64; 2]> {\n    use wasm_bindgen::JsCast;\n\n    let state = history.state();\n    if let Err(err) = &state {\n        error!(err);\n    }\n    state.ok().and_then(|state| {\n        let state = state.dyn_into::<js_sys::Array>().ok()?;\n        let x = state.get(0).as_f64()?;\n        let y = state.get(1).as_f64()?;\n        Some([x, y])\n    })\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "99e8e834e6d3c3d6888687ba70061608a22691a6",
    "func": "use crate::{\n    error::*, Condition, ConnectionTrait, DbErr, EntityTrait, Identity, ModelTrait, QueryFilter,\n    Related, RelationType, Select,\n};\nuse async_trait::async_trait;\nuse sea_query::{ColumnRef, DynIden, Expr, IntoColumnRef, SimpleExpr, TableRef, ValueTuple};\nuse std::{collections::HashMap, str::FromStr};\n\n/// Entity, or a Select<Entity>; to be used as parameters in [`LoaderTrait`]\npub trait EntityOrSelect<E: EntityTrait>: Send {\n    /// If self is Entity, use Entity::find()\n    fn select(self) -> Select<E>;\n}\n\n/// This trait implements the Data Loader API\n#[async_trait]\npub trait LoaderTrait {\n    /// Source model\n    type Model: ModelTrait;\n\n    /// Used to eager load has_one relations\n    async fn load_one<R, S, C>(&self, stmt: S, db: &C) -> Result<Vec<Option<R::Model>>, DbErr>\n    where\n        C: ConnectionTrait,\n        R: EntityTrait,\n        R::Model: Send + Sync,\n        S: EntityOrSelect<R>,\n        <<Self as LoaderTrait>::Model as ModelTrait>::Entity: Related<R>;\n\n    /// Used to eager load has_many relations\n    async fn load_many<R, S, C>(&self, stmt: S, db: &C) -> Result<Vec<Vec<R::Model>>, DbErr>\n    where\n        C: ConnectionTrait,\n        R: EntityTrait,\n        R::Model: Send + Sync,\n        S: EntityOrSelect<R>,\n        <<Self as LoaderTrait>::Model as ModelTrait>::Entity: Related<R>;\n\n    /// Used to eager load many_to_many relations\n    async fn load_many_to_many<R, S, V, C>(\n        &self,\n        stmt: S,\n        via: V,\n        db: &C,\n    ) -> Result<Vec<Vec<R::Model>>, DbErr>\n    where\n        C: ConnectionTrait,\n        R: EntityTrait,\n        R::Model: Send + Sync,\n        S: EntityOrSelect<R>,\n        V: EntityTrait,\n        V::Model: Send + Sync,\n        <<Self as LoaderTrait>::Model as ModelTrait>::Entity: Related<R>;\n}\n\nimpl<E> EntityOrSelect<E> for E\nwhere\n    E: EntityTrait,\n{\n    fn select(self) -> Select<E> {\n        E::find()\n    }\n}\n\nimpl<E> EntityOrSelect<E> for Select<E>\nwhere\n    E: EntityTrait,\n{\n    fn select(self) -> Select<E> {\n        self\n    }\n}\n\n#[async_trait]\nimpl<M> LoaderTrait for Vec<M>\nwhere\n    M: ModelTrait + Sync,\n{\n    type Model = M;\n\n    async fn load_one<R, S, C>(&self, stmt: S, db: &C) -> Result<Vec<Option<R::Model>>, DbErr>\n    where\n        C: ConnectionTrait,\n        R: EntityTrait,\n        R::Model: Send + Sync,\n        S: EntityOrSelect<R>,\n        <<Self as LoaderTrait>::Model as ModelTrait>::Entity: Related<R>,\n    {\n        self.as_slice().load_one(stmt, db).await\n    }\n\n    async fn load_many<R, S, C>(&self, stmt: S, db: &C) -> Result<Vec<Vec<R::Model>>, DbErr>\n    where\n        C: ConnectionTrait,\n        R: EntityTrait,\n        R::Model: Send + Sync,\n        S: EntityOrSelect<R>,\n        <<Self as LoaderTrait>::Model as ModelTrait>::Entity: Related<R>,\n    {\n        self.as_slice().load_many(stmt, db).await\n    }\n\n    async fn load_many_to_many<R, S, V, C>(\n        &self,\n        stmt: S,\n        via: V,\n        db: &C,\n    ) -> Result<Vec<Vec<R::Model>>, DbErr>\n    where\n        C: ConnectionTrait,\n        R: EntityTrait,\n        R::Model: Send + Sync,\n        S: EntityOrSelect<R>,\n        V: EntityTrait,\n        V::Model: Send + Sync,\n        <<Self as LoaderTrait>::Model as ModelTrait>::Entity: Related<R>,\n    {\n        self.as_slice().load_many_to_many(stmt, via, db).await\n    }\n}\n\n#[async_trait]\nimpl<M> LoaderTrait for &[M]\nwhere\n    M: ModelTrait + Sync,\n{\n    type Model = M;\n\n    async fn load_one<R, S, C>(&self, stmt: S, db: &C) -> Result<Vec<Option<R::Model>>, DbErr>\n    where\n        C: ConnectionTrait,\n        R: EntityTrait,\n        R::Model: Send + Sync,\n        S: EntityOrSelect<R>,\n        <<Self as LoaderTrait>::Model as ModelTrait>::Entity: Related<R>,\n    {\n        // we verify that is HasOne relation\n        if <<<Self as LoaderTrait>::Model as ModelTrait>::Entity as Related<R>>::via().is_some() {\n            return Err(query_err(\"Relation is ManytoMany instead of HasOne\"));\n        }\n        let rel_def = <<<Self as LoaderTrait>::Model as ModelTrait>::Entity as Related<R>>::to();\n        if rel_def.rel_type == RelationType::HasMany {\n            return Err(query_err(\"Relation is HasMany instead of HasOne\"));\n        }\n\n        if self.is_empty() {\n            return Ok(Vec::new());\n        }\n\n        let keys: Vec<ValueTuple> = self\n            .iter()\n            .map(|model: &M| extract_key(&rel_def.from_col, model))\n            .collect();\n\n        let condition = prepare_condition(&rel_def.to_tbl, &rel_def.to_col, &keys);\n\n        let stmt = <Select<R> as QueryFilter>::filter(stmt.select(), condition);\n\n        let data = stmt.all(db).await?;\n\n        let hashmap: HashMap<ValueTuple, <R as EntityTrait>::Model> = data.into_iter().fold(\n            HashMap::new(),\n            |mut acc, value: <R as EntityTrait>::Model| {\n                {\n                    let key = extract_key(&rel_def.to_col, &value);\n                    acc.insert(key, value);\n                }\n\n                acc\n            },\n        );\n\n        let result: Vec<Option<<R as EntityTrait>::Model>> =\n            keys.iter().map(|key| hashmap.get(key).cloned()).collect();\n\n        Ok(result)\n    }\n\n    async fn load_many<R, S, C>(&self, stmt: S, db: &C) -> Result<Vec<Vec<R::Model>>, DbErr>\n    where\n        C: ConnectionTrait,\n        R: EntityTrait,\n        R::Model: Send + Sync,\n        S: EntityOrSelect<R>,\n        <<Self as LoaderTrait>::Model as ModelTrait>::Entity: Related<R>,\n    {\n        // we verify that is HasMany relation\n\n        if <<<Self as LoaderTrait>::Model as ModelTrait>::Entity as Related<R>>::via().is_some() {\n            return Err(query_err(\"Relation is ManyToMany instead of HasMany\"));\n        }\n        let rel_def = <<<Self as LoaderTrait>::Model as ModelTrait>::Entity as Related<R>>::to();\n        if rel_def.rel_type == RelationType::HasOne {\n            return Err(query_err(\"Relation is HasOne instead of HasMany\"));\n        }\n\n        if self.is_empty() {\n            return Ok(Vec::new());\n        }\n\n        let keys: Vec<ValueTuple> = self\n            .iter()\n            .map(|model: &M| extract_key(&rel_def.from_col, model))\n            .collect();\n\n        let condition = prepare_condition(&rel_def.to_tbl, &rel_def.to_col, &keys);\n\n        let stmt = <Select<R> as QueryFilter>::filter(stmt.select(), condition);\n\n        let data = stmt.all(db).await?;\n\n        let mut hashmap: HashMap<ValueTuple, Vec<<R as EntityTrait>::Model>> =\n            keys.iter()\n                .fold(HashMap::new(), |mut acc, key: &ValueTuple| {\n                    acc.insert(key.clone(), Vec::new());\n                    acc\n                });\n\n        data.into_iter()\n            .for_each(|value: <R as EntityTrait>::Model| {\n                let key = extract_key(&rel_def.to_col, &value);\n\n                let vec = hashmap\n                    .get_mut(&key)\n                    .expect(\"Failed at finding key on hashmap\");\n\n                vec.push(value);\n            });\n\n        let result: Vec<Vec<R::Model>> = keys\n            .iter()\n            .map(|key: &ValueTuple| hashmap.get(key).cloned().unwrap_or_default())\n            .collect();\n\n        Ok(result)\n    }\n\n    async fn load_many_to_many<R, S, V, C>(\n        &self,\n        stmt: S,\n        via: V,\n        db: &C,\n    ) -> Result<Vec<Vec<R::Model>>, DbErr>\n    where\n        C: ConnectionTrait,\n        R: EntityTrait,\n        R::Model: Send + Sync,\n        S: EntityOrSelect<R>,\n        V: EntityTrait,\n        V::Model: Send + Sync,\n        <<Self as LoaderTrait>::Model as ModelTrait>::Entity: Related<R>,\n    {\n        if let Some(via_rel) =\n            <<<Self as LoaderTrait>::Model as ModelTrait>::Entity as Related<R>>::via()\n        {\n            let rel_def =\n                <<<Self as LoaderTrait>::Model as ModelTrait>::Entity as Related<R>>::to();\n            if rel_def.rel_type != RelationType::HasOne {\n                return Err(query_err(\"Relation to is not HasOne\"));\n            }\n\n            if !cmp_table_ref(&via_rel.to_tbl, &via.table_ref()) {\n                return Err(query_err(format!(\n                    \"The given via Entity is incorrect: expected: {:?}, given: {:?}\",\n                    via_rel.to_tbl,\n                    via.table_ref()\n                )));\n            }\n\n            if self.is_empty() {\n                return Ok(Vec::new());\n            }\n\n            let pkeys: Vec<ValueTuple> = self\n                .iter()\n                .map(|model: &M| extract_key(&via_rel.from_col, model))\n                .collect();\n\n            // Map of M::PK -> Vec<R::PK>\n            let mut keymap: HashMap<ValueTuple, Vec<ValueTuple>> = Default::default();\n\n            let keys: Vec<ValueTuple> = {\n                let condition = prepare_condition(&via_rel.to_tbl, &via_rel.to_col, &pkeys);\n                let stmt = V::find().filter(condition);\n                let data = stmt.all(db).await?;\n                data.into_iter().for_each(|model| {\n                    let pk = extract_key(&via_rel.to_col, &model);\n                    let entry = keymap.entry(pk).or_default();\n\n                    let fk = extract_key(&rel_def.from_col, &model);\n                    entry.push(fk);\n                });\n\n                keymap.values().flatten().cloned().collect()\n            };\n\n            let condition = prepare_condition(&rel_def.to_tbl, &rel_def.to_col, &keys);\n\n            let stmt = <Select<R> as QueryFilter>::filter(stmt.select(), condition);\n\n            let data = stmt.all(db).await?;\n\n            // Map of R::PK -> R::Model\n            let data: HashMap<ValueTuple, <R as EntityTrait>::Model> = data\n                .into_iter()\n                .map(|model| {\n                    let key = extract_key(&rel_def.to_col, &model);\n                    (key, model)\n                })\n                .collect();\n\n            let result: Vec<Vec<R::Model>> = pkeys\n                .into_iter()\n                .map(|pkey| {\n                    let fkeys = keymap.get(&pkey).cloned().unwrap_or_default();\n\n                    let models: Vec<_> = fkeys\n                        .into_iter()\n                        .filter_map(|fkey| data.get(&fkey).cloned())\n                        .collect();\n\n                    models\n                })\n                .collect();\n\n            Ok(result)\n        } else {\n            return Err(query_err(\"Relation is not ManyToMany\"));\n        }\n    }\n}\n\nfn cmp_table_ref(left: &TableRef, right: &TableRef) -> bool {\n    // not ideal; but\n    format!(\"{left:?}\") == format!(\"{right:?}\")\n}\n\nfn extract_key<Model>(target_col: &Identity, model: &Model) -> ValueTuple\nwhere\n    Model: ModelTrait,\n{\n    match target_col {\n        Identity::Unary(a) => {\n            let column_a =\n                <<<Model as ModelTrait>::Entity as EntityTrait>::Column as FromStr>::from_str(\n                    &a.to_string(),\n                )\n                .unwrap_or_else(|_| panic!(\"Failed at mapping string to column A:1\"));\n            ValueTuple::One(model.get(column_a))\n        }\n        Identity::Binary(a, b) => {\n            let column_a =\n                <<<Model as ModelTrait>::Entity as EntityTrait>::Column as FromStr>::from_str(\n                    &a.to_string(),\n                )\n                .unwrap_or_else(|_| panic!(\"Failed at mapping string to column A:2\"));\n            let column_b =\n                <<<Model as ModelTrait>::Entity as EntityTrait>::Column as FromStr>::from_str(\n                    &b.to_string(),\n                )\n                .unwrap_or_else(|_| panic!(\"Failed at mapping string to column B:2\"));\n            ValueTuple::Two(model.get(column_a), model.get(column_b))\n        }\n        Identity::Ternary(a, b, c) => {\n            let column_a =\n                <<<Model as ModelTrait>::Entity as EntityTrait>::Column as FromStr>::from_str(\n                    &a.to_string(),\n                )\n                .unwrap_or_else(|_| panic!(\"Failed at mapping string to column A:3\"));\n            let column_b =\n                <<<Model as ModelTrait>::Entity as EntityTrait>::Column as FromStr>::from_str(\n                    &b.to_string(),\n                )\n                .unwrap_or_else(|_| panic!(\"Failed at mapping string to column B:3\"));\n            let column_c =\n                <<<Model as ModelTrait>::Entity as EntityTrait>::Column as FromStr>::from_str(\n                    &c.to_string(),\n                )\n                .unwrap_or_else(|_| panic!(\"Failed at mapping string to column C:3\"));\n            ValueTuple::Three(\n                model.get(column_a),\n                model.get(column_b),\n                model.get(column_c),\n            )\n        }\n        Identity::Many(cols) => {\n            let values = cols.iter().map(|col| {\n                let col_name = col.to_string();\n                let column = <<<Model as ModelTrait>::Entity as EntityTrait>::Column as FromStr>::from_str(\n                    &col_name,\n                )\n                .unwrap_or_else(|_| panic!(\"Failed at mapping '{}' to column\", col_name));\n                model.get(column)\n            })\n            .collect();\n            ValueTuple::Many(values)\n        }\n    }\n}\n\nfn prepare_condition(table: &TableRef, col: &Identity, keys: &[ValueTuple]) -> Condition {\n    // TODO when value is hashable, retain only unique values\n    let keys = keys.to_owned();\n    match col {\n        Identity::Unary(column_a) => {\n            let column_a = table_column(table, column_a);\n            Condition::all().add(Expr::col(column_a).is_in(keys.into_iter().flatten()))\n        }\n        Identity::Binary(column_a, column_b) => Condition::all().add(\n            Expr::tuple([\n                SimpleExpr::Column(table_column(table, column_a)),\n                SimpleExpr::Column(table_column(table, column_b)),\n            ])\n            .in_tuples(keys),\n        ),\n        Identity::Ternary(column_a, column_b, column_c) => Condition::all().add(\n            Expr::tuple([\n                SimpleExpr::Column(table_column(table, column_a)),\n                SimpleExpr::Column(table_column(table, column_b)),\n                SimpleExpr::Column(table_column(table, column_c)),\n            ])\n            .in_tuples(keys),\n        ),\n        Identity::Many(cols) => {\n            let columns = cols\n                .iter()\n                .map(|col| SimpleExpr::Column(table_column(table, col)));\n            Condition::all().add(Expr::tuple(columns).in_tuples(keys))\n        }\n    }\n}\n\nfn table_column(tbl: &TableRef, col: &DynIden) -> ColumnRef {\n    match tbl.to_owned() {\n        TableRef::Table(tbl) => (tbl, col.clone()).into_column_ref(),\n        TableRef::SchemaTable(sch, tbl) => (sch, tbl, col.clone()).into_column_ref(),\n        val => unimplemented!(\"Unsupported TableRef {val:?}\"),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    fn cake_model(id: i32) -> sea_orm::tests_cfg::cake::Model {\n        let name = match id {\n            1 => \"apple cake\",\n            2 => \"orange cake\",\n            3 => \"fruit cake\",\n            4 => \"chocolate cake\",\n            _ => \"\",\n        }\n        .to_string();\n        sea_orm::tests_cfg::cake::Model { id, name }\n    }\n\n    fn fruit_model(id: i32, cake_id: Option<i32>) -> sea_orm::tests_cfg::fruit::Model {\n        let name = match id {\n            1 => \"apple\",\n            2 => \"orange\",\n            3 => \"grape\",\n            4 => \"strawberry\",\n            _ => \"\",\n        }\n        .to_string();\n        sea_orm::tests_cfg::fruit::Model { id, name, cake_id }\n    }\n\n    fn filling_model(id: i32) -> sea_orm::tests_cfg::filling::Model {\n        let name = match id {\n            1 => \"apple juice\",\n            2 => \"orange jam\",\n            3 => \"chocolate crust\",\n            4 => \"strawberry jam\",\n            _ => \"\",\n        }\n        .to_string();\n        sea_orm::tests_cfg::filling::Model {\n            id,\n            name,\n            vendor_id: Some(1),\n            ignored_attr: 0,\n        }\n    }\n\n    fn cake_filling_model(\n        cake_id: i32,\n        filling_id: i32,\n    ) -> sea_orm::tests_cfg::cake_filling::Model {\n        sea_orm::tests_cfg::cake_filling::Model {\n            cake_id,\n            filling_id,\n        }\n    }\n\n    #[tokio::test]\n    async fn test_load_one() {\n        use sea_orm::{entity::prelude::*, tests_cfg::*, DbBackend, LoaderTrait, MockDatabase};\n\n        let db = MockDatabase::new(DbBackend::Postgres)\n            .append_query_results([[cake_model(1), cake_model(2)]])\n            .into_connection();\n\n        let fruits = vec![fruit_model(1, Some(1))];\n\n        let cakes = fruits\n            .load_one(cake::Entity::find(), &db)\n            .await\n            .expect(\"Should return something\");\n\n        assert_eq!(cakes, [Some(cake_model(1))]);\n    }\n\n    #[tokio::test]\n    async fn test_load_one_same_cake() {\n        use sea_orm::{entity::prelude::*, tests_cfg::*, DbBackend, LoaderTrait, MockDatabase};\n\n        let db = MockDatabase::new(DbBackend::Postgres)\n            .append_query_results([[cake_model(1), cake_model(2)]])\n            .into_connection();\n\n        let fruits = vec![fruit_model(1, Some(1)), fruit_model(2, Some(1))];\n\n        let cakes = fruits\n            .load_one(cake::Entity::find(), &db)\n            .await\n            .expect(\"Should return something\");\n\n        assert_eq!(cakes, [Some(cake_model(1)), Some(cake_model(1))]);\n    }\n\n    #[tokio::test]\n    async fn test_load_one_empty() {\n        use sea_orm::{entity::prelude::*, tests_cfg::*, DbBackend, LoaderTrait, MockDatabase};\n\n        let db = MockDatabase::new(DbBackend::Postgres)\n            .append_query_results([[cake_model(1), cake_model(2)]])\n            .into_connection();\n\n        let fruits: Vec<fruit::Model> = vec![];\n\n        let cakes = fruits\n            .load_one(cake::Entity::find(), &db)\n            .await\n            .expect(\"Should return something\");\n\n        assert_eq!(cakes, []);\n    }\n\n    #[tokio::test]\n    async fn test_load_many() {\n        use sea_orm::{entity::prelude::*, tests_cfg::*, DbBackend, LoaderTrait, MockDatabase};\n\n        let db = MockDatabase::new(DbBackend::Postgres)\n            .append_query_results([[fruit_model(1, Some(1))]])\n            .into_connection();\n\n        let cakes = vec![cake_model(1), cake_model(2)];\n\n        let fruits = cakes\n            .load_many(fruit::Entity::find(), &db)\n            .await\n            .expect(\"Should return something\");\n\n        assert_eq!(fruits, [vec![fruit_model(1, Some(1))], vec![]]);\n    }\n\n    #[tokio::test]\n    async fn test_load_many_same_fruit() {\n        use sea_orm::{entity::prelude::*, tests_cfg::*, DbBackend, LoaderTrait, MockDatabase};\n\n        let db = MockDatabase::new(DbBackend::Postgres)\n            .append_query_results([[fruit_model(1, Some(1)), fruit_model(2, Some(1))]])\n            .into_connection();\n\n        let cakes = vec![cake_model(1), cake_model(2)];\n\n        let fruits = cakes\n            .load_many(fruit::Entity::find(), &db)\n            .await\n            .expect(\"Should return something\");\n\n        assert_eq!(\n            fruits,\n            [\n                vec![fruit_model(1, Some(1)), fruit_model(2, Some(1))],\n                vec![]\n            ]\n        );\n    }\n\n    #[tokio::test]\n    async fn test_load_many_empty() {\n        use sea_orm::{entity::prelude::*, tests_cfg::*, DbBackend, MockDatabase};\n\n        let db = MockDatabase::new(DbBackend::Postgres).into_connection();\n\n        let cakes: Vec<cake::Model> = vec![];\n\n        let fruits = cakes\n            .load_many(fruit::Entity::find(), &db)\n            .await\n            .expect(\"Should return something\");\n\n        let empty_vec: Vec<Vec<fruit::Model>> = vec![];\n\n        assert_eq!(fruits, empty_vec);\n    }\n\n    #[tokio::test]\n    async fn test_load_many_to_many_base() {\n        use sea_orm::{tests_cfg::*, DbBackend, IntoMockRow, LoaderTrait, MockDatabase};\n\n        let db = MockDatabase::new(DbBackend::Postgres)\n            .append_query_results([\n                [cake_filling_model(1, 1).into_mock_row()],\n                [filling_model(1).into_mock_row()],\n            ])\n            .into_connection();\n\n        let cakes = vec![cake_model(1)];\n\n        let fillings = cakes\n            .load_many_to_many(Filling, CakeFilling, &db)\n            .await\n            .expect(\"Should return something\");\n\n        assert_eq!(fillings, vec![vec![filling_model(1)]]);\n    }\n\n    #[tokio::test]\n    async fn test_load_many_to_many_complex() {\n        use sea_orm::{tests_cfg::*, DbBackend, IntoMockRow, LoaderTrait, MockDatabase};\n\n        let db = MockDatabase::new(DbBackend::Postgres)\n            .append_query_results([\n                [\n                    cake_filling_model(1, 1).into_mock_row(),\n                    cake_filling_model(1, 2).into_mock_row(),\n                    cake_filling_model(1, 3).into_mock_row(),\n                    cake_filling_model(2, 1).into_mock_row(),\n                    cake_filling_model(2, 2).into_mock_row(),\n                ],\n                [\n                    filling_model(1).into_mock_row(),\n                    filling_model(2).into_mock_row(),\n                    filling_model(3).into_mock_row(),\n                    filling_model(4).into_mock_row(),\n                    filling_model(5).into_mock_row(),\n                ],\n            ])\n            .into_connection();\n\n        let cakes = vec![cake_model(1), cake_model(2), cake_model(3)];\n\n        let fillings = cakes\n            .load_many_to_many(Filling, CakeFilling, &db)\n            .await\n            .expect(\"Should return something\");\n\n        assert_eq!(\n            fillings,\n            vec![\n                vec![filling_model(1), filling_model(2), filling_model(3)],\n                vec![filling_model(1), filling_model(2)],\n                vec![],\n            ]\n        );\n    }\n\n    #[tokio::test]\n    async fn test_load_many_to_many_empty() {\n        use sea_orm::{tests_cfg::*, DbBackend, IntoMockRow, LoaderTrait, MockDatabase};\n\n        let db = MockDatabase::new(DbBackend::Postgres)\n            .append_query_results([\n                [cake_filling_model(1, 1).into_mock_row()],\n                [filling_model(1).into_mock_row()],\n            ])\n            .into_connection();\n\n        let cakes: Vec<cake::Model> = vec![];\n\n        let fillings = cakes\n            .load_many_to_many(Filling, CakeFilling, &db)\n            .await\n            .expect(\"Should return something\");\n\n        let empty_vec: Vec<Vec<filling::Model>> = vec![];\n\n        assert_eq!(fillings, empty_vec);\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "7a57f7d2792f62c1aea58c348d0721ab20e4634e",
    "func": "/// Body size hint.\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum BodySize {\n    /// Implicitly empty body.\n    ///\n    /// Will omit the Content-Length header. Used for responses to certain methods (e.g., `HEAD`) or\n    /// with particular status codes (e.g., 204 No Content). Consumers that read this as a body size\n    /// hint are allowed to make optimizations that skip reading or writing the payload.\n    None,\n\n    /// Known size body.\n    ///\n    /// Will write `Content-Length: N` header.\n    Sized(u64),\n\n    /// Unknown size body.\n    ///\n    /// Will not write Content-Length header. Can be used with chunked Transfer-Encoding.\n    Stream,\n}\n\nimpl BodySize {\n    /// Equivalent to `BodySize::Sized(0)`;\n    pub const ZERO: Self = Self::Sized(0);\n\n    /// Returns true if size hint indicates omitted or empty body.\n    ///\n    /// Streams will return false because it cannot be known without reading the stream.\n    ///\n    /// ```\n    /// # use actix_http::body::BodySize;\n    /// assert!(BodySize::None.is_eof());\n    /// assert!(BodySize::Sized(0).is_eof());\n    ///\n    /// assert!(!BodySize::Sized(64).is_eof());\n    /// assert!(!BodySize::Stream.is_eof());\n    /// ```\n    pub fn is_eof(&self) -> bool {\n        matches!(self, BodySize::None | BodySize::Sized(0))\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "28173616f55891703e95a80f4324d1937954f440",
    "func": "use actix_multipart::form::{json::Json as MpJson, tempfile::TempFile, MultipartForm};\nuse actix_web::{middleware::Logger, post, App, HttpServer, Responder};\nuse serde::Deserialize;\n\n#[derive(Debug, Deserialize)]\nstruct Metadata {\n    name: String,\n}\n\n#[derive(Debug, MultipartForm)]\nstruct UploadForm {\n    #[multipart(limit = \"100MB\")]\n    file: TempFile,\n    json: MpJson<Metadata>,\n}\n\n#[post(\"/videos\")]\nasync fn post_video(MultipartForm(form): MultipartForm<UploadForm>) -> impl Responder {\n    format!(\n        \"Uploaded file {}, with size: {}\\ntemporary file ({}) was deleted\\n\",\n        form.json.name,\n        form.file.size,\n        form.file.file.path().display(),\n    )\n}\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    env_logger::init_from_env(env_logger::Env::new().default_filter_or(\"info\"));\n\n    HttpServer::new(move || App::new().service(post_video).wrap(Logger::default()))\n        .workers(2)\n        .bind((\"127.0.0.1\", 8080))?\n        .run()\n        .await\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "2844555b83b8ab39763be51fa789f71e7614056b",
    "func": "use crate::html::{Html, Properties};\n\n/// Properties for [Suspense].\n#[derive(Properties, PartialEq, Debug, Clone)]\npub struct SuspenseProps {\n    /// The Children of the current Suspense Component.\n    #[prop_or_default]\n    pub children: Html,\n\n    /// The Fallback UI of the current Suspense Component.\n    #[prop_or_default]\n    pub fallback: Html,\n}\n\n#[cfg(any(feature = \"csr\", feature = \"ssr\"))]\nmod feat_csr_ssr {\n    use super::*;\n    use crate::html::{Component, Context, Html, Scope};\n    use crate::suspense::Suspension;\n    #[cfg(feature = \"hydration\")]\n    use crate::suspense::SuspensionHandle;\n    use crate::virtual_dom::{VNode, VSuspense};\n    use crate::{function_component, html};\n\n    #[derive(Properties, PartialEq, Debug, Clone)]\n    pub(crate) struct BaseSuspenseProps {\n        pub children: Html,\n        #[prop_or(None)]\n        pub fallback: Option<Html>,\n    }\n\n    #[derive(Debug)]\n    pub(crate) enum BaseSuspenseMsg {\n        Suspend(Suspension),\n        Resume(Suspension),\n    }\n\n    #[derive(Debug)]\n    pub(crate) struct BaseSuspense {\n        suspensions: Vec<Suspension>,\n        #[cfg(feature = \"hydration\")]\n        hydration_handle: Option<SuspensionHandle>,\n    }\n\n    impl Component for BaseSuspense {\n        type Message = BaseSuspenseMsg;\n        type Properties = BaseSuspenseProps;\n\n        fn create(_ctx: &Context<Self>) -> Self {\n            #[cfg(not(feature = \"hydration\"))]\n            let suspensions = Vec::new();\n\n            // We create a suspension to block suspense until its rendered method is notified.\n            #[cfg(feature = \"hydration\")]\n            let (suspensions, hydration_handle) = {\n                use crate::callback::Callback;\n                use crate::html::RenderMode;\n\n                match _ctx.creation_mode() {\n                    RenderMode::Hydration => {\n                        let link = _ctx.link().clone();\n                        let (s, handle) = Suspension::new();\n                        s.listen(Callback::from(move |s| {\n                            link.send_message(BaseSuspenseMsg::Resume(s));\n                        }));\n                        (vec![s], Some(handle))\n                    }\n                    _ => (Vec::new(), None),\n                }\n            };\n\n            Self {\n                suspensions,\n                #[cfg(feature = \"hydration\")]\n                hydration_handle,\n            }\n        }\n\n        fn update(&mut self, ctx: &Context<Self>, msg: Self::Message) -> bool {\n            match msg {\n                Self::Message::Suspend(m) => {\n                    assert!(\n                        ctx.props().fallback.is_some(),\n                        \"You cannot suspend from a component rendered as a fallback.\"\n                    );\n\n                    if m.resumed() {\n                        return false;\n                    }\n\n                    // If a suspension already exists, ignore it.\n                    if self.suspensions.iter().any(|n| n == &m) {\n                        return false;\n                    }\n\n                    self.suspensions.push(m);\n\n                    true\n                }\n                Self::Message::Resume(ref m) => {\n                    let suspensions_len = self.suspensions.len();\n                    self.suspensions.retain(|n| m != n);\n\n                    suspensions_len != self.suspensions.len()\n                }\n            }\n        }\n\n        fn view(&self, ctx: &Context<Self>) -> Html {\n            let BaseSuspenseProps { children, fallback } = (*ctx.props()).clone();\n            let children = html! {<>{children}</>};\n\n            match fallback {\n                Some(fallback) => {\n                    let vsuspense = VSuspense::new(\n                        children,\n                        fallback,\n                        !self.suspensions.is_empty(),\n                        // We don't need to key this as the key will be applied to the component.\n                        None,\n                    );\n\n                    VNode::from(vsuspense)\n                }\n                None => children,\n            }\n        }\n\n        #[cfg(feature = \"hydration\")]\n        fn rendered(&mut self, _ctx: &Context<Self>, first_render: bool) {\n            if first_render {\n                if let Some(m) = self.hydration_handle.take() {\n                    m.resume();\n                }\n            }\n        }\n    }\n\n    impl BaseSuspense {\n        pub(crate) fn suspend(scope: &Scope<Self>, s: Suspension) {\n            scope.send_message(BaseSuspenseMsg::Suspend(s));\n        }\n\n        pub(crate) fn resume(scope: &Scope<Self>, s: Suspension) {\n            scope.send_message(BaseSuspenseMsg::Resume(s));\n        }\n    }\n\n    /// Suspend rendering and show a fallback UI until the underlying task completes.\n    #[function_component]\n    pub fn Suspense(props: &SuspenseProps) -> Html {\n        let SuspenseProps { children, fallback } = props.clone();\n\n        let fallback = html! {\n            <BaseSuspense>\n                {fallback}\n            </BaseSuspense>\n        };\n\n        html! {\n            <BaseSuspense {fallback}>\n                {children}\n            </BaseSuspense>\n        }\n    }\n}\n\n#[cfg(any(feature = \"csr\", feature = \"ssr\"))]\npub use feat_csr_ssr::*;\n\n#[cfg(not(any(feature = \"ssr\", feature = \"csr\")))]\nmod feat_no_csr_ssr {\n    use super::*;\n    use crate::function_component;\n\n    /// Suspend rendering and show a fallback UI until the underlying task completes.\n    #[function_component]\n    pub fn Suspense(_props: &SuspenseProps) -> Html {\n        Html::default()\n    }\n}\n\n#[cfg(not(any(feature = \"ssr\", feature = \"csr\")))]\npub use feat_no_csr_ssr::*;\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "325517d6fb587a7c3670ea6cf98309a2d14652b3",
    "func": "use std::fmt;\nuse std::path::{Path, PathBuf};\nuse std::sync::Arc;\nuse std::borrow::Cow;\n\nuse crate::{response, Data, Request, Response};\nuse crate::outcome::IntoOutcome;\nuse crate::http::{uri::Segments, HeaderMap, Method, ContentType, Status};\nuse crate::route::{Route, Handler, Outcome};\nuse crate::response::Responder;\nuse crate::util::Formatter;\nuse crate::fs::rewrite::*;\n\n/// Custom handler for serving static files.\n///\n/// This handler makes is simple to serve static files from a directory on the\n/// local file system. To use it, construct a `FileServer` using\n/// [`FileServer::new()`], then `mount` the handler.\n///\n/// ```rust,no_run\n/// # #[macro_use] extern crate rocket;\n/// use rocket::fs::FileServer;\n///\n/// #[launch]\n/// fn rocket() -> _ {\n///     rocket::build()\n///         .mount(\"/\", FileServer::new(\"/www/static\"))\n/// }\n/// ```\n///\n/// When mounted, the handler serves files from the specified path. If a\n/// requested file does not exist, the handler _forwards_ the request with a\n/// `404` status.\n///\n/// By default, the route has a rank of `10` which can be changed with\n/// [`FileServer::rank()`].\n///\n/// # Customization\n///\n/// `FileServer` works through a pipeline of _rewrites_ in which a requested\n/// path is transformed into a `PathBuf` via [`Segments::to_path_buf()`] and\n/// piped through a series of [`Rewriter`]s to obtain a final [`Rewrite`] which\n/// is then used to generate a final response. See [`Rewriter`] for complete\n/// details on implementing your own `Rewriter`s.\n///\n/// # Example\n///\n/// Serve files from the `/static` directory on the local file system at the\n/// `/public` path:\n///\n/// ```rust,no_run\n/// # #[macro_use] extern crate rocket;\n/// use rocket::fs::FileServer;\n///\n/// #[launch]\n/// fn rocket() -> _ {\n///     rocket::build().mount(\"/public\", FileServer::new(\"/static\"))\n/// }\n/// ```\n///\n/// Requests for files at `/public/<path..>` will be handled by returning the\n/// contents of `/static/<path..>`. Requests for directories will return the\n/// contents of `index.html`.\n///\n/// ## Relative Paths\n///\n/// In the example above, `/static` is an absolute path. If your static files\n/// are stored relative to your crate and your project is managed by Cargo, use\n/// the [`relative!`] macro to obtain a path that is relative to your crate's\n/// root. For example, to serve files in the `static` subdirectory of your crate\n/// at `/`, you might write:\n///\n/// ```rust,no_run\n/// # #[macro_use] extern crate rocket;\n/// use rocket::fs::{FileServer, relative};\n///\n/// #[launch]\n/// fn rocket() -> _ {\n///     rocket::build().mount(\"/\", FileServer::new(relative!(\"static\")))\n/// }\n/// ```\n///\n/// [`relative!`]: crate::fs::relative!\n#[derive(Clone)]\npub struct FileServer {\n    rewrites: Vec<Arc<dyn Rewriter>>,\n    rank: isize,\n}\n\nimpl FileServer {\n    /// The default rank use by `FileServer` routes.\n    const DEFAULT_RANK: isize = 10;\n\n    /// Constructs a new `FileServer` that serves files from the file system\n    /// `path` with the following rewrites:\n    ///\n    /// - `|f, _| f.is_visible()`: Serve only visible files (hide dotfiles).\n    /// - [`Prefix::checked(path)`]: Prefix requests with `path`.\n    /// - [`TrailingDirs`]: Ensure directory have a trailing slash.\n    /// - [`DirIndex::unconditional(\"index.html\")`]: Serve `$dir/index.html` for\n    ///   requests to directory `$dir`.\n    ///\n    /// If you don't want to serve index files or want a different index file,\n    /// use [`Self::without_index`]. To customize the entire request to file\n    /// path rewrite pipeline, use [`Self::identity`].\n    ///\n    /// [`Prefix::checked(path)`]: crate::fs::rewrite::Prefix::checked\n    /// [`TrailingDirs`]: crate::fs::rewrite::TrailingDirs\n    /// [`DirIndex::unconditional(\"index.html\")`]: DirIndex::unconditional()\n    ///\n    /// # Example\n    ///\n    /// ```rust,no_run\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::fs::FileServer;\n    ///\n    /// #[launch]\n    /// fn rocket() -> _ {\n    ///     rocket::build()\n    ///         .mount(\"/\", FileServer::new(\"/www/static\"))\n    /// }\n    /// ```\n    pub fn new<P: AsRef<Path>>(path: P) -> Self {\n        Self::identity()\n            .filter(|f, _| f.is_visible())\n            .rewrite(Prefix::checked(path))\n            .rewrite(TrailingDirs)\n            .rewrite(DirIndex::unconditional(\"index.html\"))\n    }\n\n    /// Exactly like [`FileServer::new()`] except it _does not_ serve directory\n    /// index files via [`DirIndex`]. It rewrites with the following:\n    ///\n    /// - `|f, _| f.is_visible()`: Serve only visible files (hide dotfiles).\n    /// - [`Prefix::checked(path)`]: Prefix requests with `path`.\n    /// - [`TrailingDirs`]: Ensure directory have a trailing slash.\n    ///\n    /// # Example\n    ///\n    /// Constructs a default file server to serve files from `./static` using\n    /// `index.txt` as the index file if `index.html` doesn't exist.\n    ///\n    /// ```rust,no_run\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::fs::{FileServer, rewrite::DirIndex};\n    ///\n    /// #[launch]\n    /// fn rocket() -> _ {\n    ///     let server = FileServer::new(\"static\")\n    ///         .rewrite(DirIndex::if_exists(\"index.html\"))\n    ///         .rewrite(DirIndex::unconditional(\"index.txt\"));\n    ///\n    ///     rocket::build()\n    ///         .mount(\"/\", server)\n    /// }\n    /// ```\n    ///\n    /// [`Prefix::checked(path)`]: crate::fs::rewrite::Prefix::checked\n    /// [`TrailingDirs`]: crate::fs::rewrite::TrailingDirs\n    pub fn without_index<P: AsRef<Path>>(path: P) -> Self {\n        Self::identity()\n            .filter(|f, _| f.is_visible())\n            .rewrite(Prefix::checked(path))\n            .rewrite(TrailingDirs)\n    }\n\n    /// Constructs a new `FileServer` with no rewrites.\n    ///\n    /// Without any rewrites, a `FileServer` will try to serve the requested\n    /// file from the current working directory. In other words, it represents\n    /// the identity rewrite. For example, a request `GET /foo/bar` will be\n    /// passed through unmodified and thus `./foo/bar` will be served. This is\n    /// very unlikely to be what you want.\n    ///\n    /// Prefer to use [`FileServer::new()`] or [`FileServer::without_index()`]\n    /// whenever possible and otherwise use one or more of the rewrites in\n    /// [`rocket::fs::rewrite`] or your own custom rewrites.\n    ///\n    /// # Example\n    ///\n    /// ```rust,no_run\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::fs::{FileServer, rewrite};\n    ///\n    /// #[launch]\n    /// fn rocket() -> _ {\n    ///     // A file server that serves exactly one file: /www/foo.html. The\n    ///     // file is served irrespective of what's requested.\n    ///     let server = FileServer::identity()\n    ///         .rewrite(rewrite::File::checked(\"/www/foo.html\"));\n    ///\n    ///     rocket::build()\n    ///         .mount(\"/\", server)\n    /// }\n    /// ```\n    pub fn identity() -> Self {\n        Self {\n            rewrites: vec![],\n            rank: Self::DEFAULT_RANK\n        }\n    }\n\n    /// Sets the rank of the route emitted by the `FileServer` to `rank`.\n    ///\n    /// # Example\n    ///\n    /// ```rust,no_run\n    /// # use rocket::fs::FileServer;\n    /// # fn make_server() -> FileServer {\n    /// FileServer::identity()\n    ///    .rank(5)\n    /// # }\n    pub fn rank(mut self, rank: isize) -> Self {\n        self.rank = rank;\n        self\n    }\n\n    /// Add `rewriter` to the rewrite pipeline.\n    ///\n    /// # Example\n    ///\n    /// Redirect filtered requests (`None`) to `/`.\n    ///\n    /// ```rust,no_run\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::fs::{FileServer, rewrite::Rewrite};\n    /// use rocket::{request::Request, response::Redirect};\n    ///\n    /// fn redir_missing<'r>(p: Option<Rewrite<'r>>, _req: &Request<'_>) -> Option<Rewrite<'r>> {\n    ///     Some(p.unwrap_or_else(|| Redirect::temporary(uri!(\"/\")).into()))\n    /// }\n    ///\n    /// #[launch]\n    /// fn rocket() -> _ {\n    ///     rocket::build()\n    ///         .mount(\"/\", FileServer::new(\"static\").rewrite(redir_missing))\n    /// }\n    /// ```\n    ///\n    /// Note that `redir_missing` is not a closure in this example. Making it a closure\n    /// causes compilation to fail with a lifetime error. It really shouldn't but it does.\n    pub fn rewrite<R: Rewriter>(mut self, rewriter: R) -> Self {\n        self.rewrites.push(Arc::new(rewriter));\n        self\n    }\n\n    /// Adds a rewriter to the pipeline that returns `Some` only when the\n    /// function `f` returns `true`, filtering out all other files.\n    ///\n    /// # Example\n    ///\n    /// Allow all files that don't have a file name or have a file name other\n    /// than \"hidden\".\n    ///\n    /// ```rust,no_run\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::fs::FileServer;\n    ///\n    /// #[launch]\n    /// fn rocket() -> _ {\n    ///     let server = FileServer::new(\"static\")\n    ///         .filter(|f, _| f.path.file_name() != Some(\"hidden\".as_ref()));\n    ///\n    ///     rocket::build()\n    ///         .mount(\"/\", server)\n    /// }\n    /// ```\n    pub fn filter<F: Send + Sync + 'static>(self, f: F) -> Self\n        where F: Fn(&File<'_>, &Request<'_>) -> bool\n    {\n        struct Filter<F>(F);\n\n        impl<F> Rewriter for Filter<F>\n            where F: Fn(&File<'_>, &Request<'_>) -> bool + Send + Sync + 'static\n        {\n            fn rewrite<'r>(&self, f: Option<Rewrite<'r>>, r: &Request<'_>) -> Option<Rewrite<'r>> {\n                f.and_then(|f| match f {\n                    Rewrite::File(f) if self.0(&f, r) => Some(Rewrite::File(f)),\n                    _ => None,\n                })\n            }\n        }\n\n        self.rewrite(Filter(f))\n    }\n\n    /// Adds a rewriter to the pipeline that maps the current `File` to another\n    /// `Rewrite` using `f`. If the current `Rewrite` is a `Redirect`, it is\n    /// passed through without calling `f`.\n    ///\n    /// # Example\n    ///\n    /// Append `index.txt` to every path.\n    ///\n    /// ```rust,no_run\n    /// # #[macro_use] extern crate rocket;\n    /// use rocket::fs::FileServer;\n    ///\n    /// #[launch]\n    /// fn rocket() -> _ {\n    ///     let server = FileServer::new(\"static\")\n    ///         .map(|f, _| f.map_path(|p| p.join(\"index.txt\")).into());\n    ///\n    ///     rocket::build()\n    ///         .mount(\"/\", server)\n    /// }\n    /// ```\n    pub fn map<F: Send + Sync + 'static>(self, f: F) -> Self\n        where F: for<'r> Fn(File<'r>, &Request<'_>) -> Rewrite<'r>\n    {\n        struct Map<F>(F);\n\n        impl<F> Rewriter for Map<F>\n            where F: for<'r> Fn(File<'r>, &Request<'_>) -> Rewrite<'r> + Send + Sync + 'static\n        {\n            fn rewrite<'r>(&self, f: Option<Rewrite<'r>>, r: &Request<'_>) -> Option<Rewrite<'r>> {\n                f.map(|f| match f {\n                    Rewrite::File(f) => self.0(f, r),\n                    Rewrite::Redirect(r) => Rewrite::Redirect(r),\n                })\n            }\n        }\n\n        self.rewrite(Map(f))\n    }\n}\n\nimpl From<FileServer> for Vec<Route> {\n    fn from(server: FileServer) -> Self {\n        let mut route = Route::ranked(server.rank, Method::Get, \"/<path..>\", server);\n        route.name = Some(\"FileServer\".into());\n        vec![route]\n    }\n}\n\n#[crate::async_trait]\nimpl Handler for FileServer {\n    async fn handle<'r>(&self, req: &'r Request<'_>, data: Data<'r>) -> Outcome<'r> {\n        use crate::http::uri::fmt::Path as UriPath;\n        let path: Option<PathBuf> = req.segments::<Segments<'_, UriPath>>(0..).ok()\n            .and_then(|segments| segments.to_path_buf(true).ok());\n\n        let mut response = path.map(|p| Rewrite::File(File::new(p)));\n        for rewrite in &self.rewrites {\n            response = rewrite.rewrite(response, req);\n        }\n\n        let (outcome, status) = match response {\n            Some(Rewrite::File(f)) => (f.open().await.respond_to(req), Status::NotFound),\n            Some(Rewrite::Redirect(r)) => (r.respond_to(req), Status::InternalServerError),\n            None => return Outcome::forward(data, Status::NotFound),\n        };\n\n        outcome.or_forward((data, status))\n    }\n}\n\nimpl fmt::Debug for FileServer {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"FileServer\")\n            .field(\"rewrites\", &Formatter(|f| write!(f, \"<{} rewrites>\", self.rewrites.len())))\n            .field(\"rank\", &self.rank)\n            .finish()\n    }\n}\n\nimpl<'r> File<'r> {\n    async fn open(self) -> std::io::Result<NamedFile<'r>> {\n        let file = tokio::fs::File::open(&self.path).await?;\n        let metadata = file.metadata().await?;\n        if metadata.is_dir() {\n            return Err(std::io::Error::other(\"is a directory\"));\n        }\n\n        Ok(NamedFile {\n            file,\n            len: metadata.len(),\n            path: self.path,\n            headers: self.headers,\n        })\n    }\n}\n\nstruct NamedFile<'r> {\n    file: tokio::fs::File,\n    len: u64,\n    path: Cow<'r, Path>,\n    headers: HeaderMap<'r>,\n}\n\n// Do we want to allow the user to rewrite the Content-Type?\nimpl<'r> Responder<'r, 'r> for NamedFile<'r> {\n    fn respond_to(self, _: &'r Request<'_>) -> response::Result<'r> {\n        let mut response = Response::new();\n        response.set_header_map(self.headers);\n        if !response.headers().contains(\"Content-Type\") {\n            self.path.extension()\n                .and_then(|ext| ext.to_str())\n                .and_then(ContentType::from_extension)\n                .map(|content_type| response.set_header(content_type));\n        }\n\n        response.set_sized_body(self.len as usize, self.file);\n        Ok(response)\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "deb7f7b1092b0ecc5a516c59545bb54d8b8dfa7c",
    "func": "use crate::{\n    serde::{de::registration_utils::try_get_registration, TypedReflectDeserializer},\n    DynamicMap, Map, MapInfo, TypeRegistry,\n};\nuse core::{fmt, fmt::Formatter};\nuse serde::de::{MapAccess, Visitor};\n\n/// A [`Visitor`] for deserializing [`Map`] values.\n///\n/// [`Map`]: crate::Map\npub(super) struct MapVisitor<'a> {\n    map_info: &'static MapInfo,\n    registry: &'a TypeRegistry,\n}\n\nimpl<'a> MapVisitor<'a> {\n    pub fn new(map_info: &'static MapInfo, registry: &'a TypeRegistry) -> Self {\n        Self { map_info, registry }\n    }\n}\n\nimpl<'a, 'de> Visitor<'de> for MapVisitor<'a> {\n    type Value = DynamicMap;\n\n    fn expecting(&self, formatter: &mut Formatter) -> fmt::Result {\n        formatter.write_str(\"reflected map value\")\n    }\n\n    fn visit_map<V>(self, mut map: V) -> Result<Self::Value, V::Error>\n    where\n        V: MapAccess<'de>,\n    {\n        let mut dynamic_map = DynamicMap::default();\n        let key_registration = try_get_registration(self.map_info.key_ty(), self.registry)?;\n        let value_registration = try_get_registration(self.map_info.value_ty(), self.registry)?;\n        while let Some(key) = map.next_key_seed(TypedReflectDeserializer::new_internal(\n            key_registration,\n            self.registry,\n        ))? {\n            let value = map.next_value_seed(TypedReflectDeserializer::new_internal(\n                value_registration,\n                self.registry,\n            ))?;\n            dynamic_map.insert_boxed(key, value);\n        }\n\n        Ok(dynamic_map)\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "6eed03d0ca06e87e004aa4695d72e011c4bcd1fe",
    "func": "use sea_orm::entity::prelude::*;\n\n#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = \"cake\")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    #[sea_orm(column_name = \"name\", enum_name = \"Name\")]\n    pub name: String,\n}\n\n#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]\npub enum Relation {\n    #[sea_orm(has_many = \"super::fruit::Entity\")]\n    Fruit,\n    #[sea_orm(\n        has_many = \"super::fruit::Entity\",\n        on_condition = r#\"super::fruit::Column::Name.like(\"%tropical%\")\"#\n    )]\n    TropicalFruit,\n    #[sea_orm(\n        has_many = \"super::fruit::Entity\",\n        condition_type = \"any\",\n        on_condition = r#\"super::fruit::Column::Name.like(\"%tropical%\")\"#\n    )]\n    OrTropicalFruit,\n}\n\nimpl Related<super::fruit::Entity> for Entity {\n    fn to() -> RelationDef {\n        Relation::Fruit.def()\n    }\n}\n\nimpl Related<super::filling::Entity> for Entity {\n    fn to() -> RelationDef {\n        super::cake_filling::Relation::Filling.def()\n    }\n\n    fn via() -> Option<RelationDef> {\n        Some(super::cake_filling::Relation::Cake.def().rev())\n    }\n}\n\n#[derive(Copy, Clone, Debug, EnumIter, DeriveRelatedEntity)]\npub enum RelatedEntity {\n    #[sea_orm(entity = \"super::fruit::Entity\")]\n    Fruit,\n    #[sea_orm(entity = \"super::filling::Entity\")]\n    Filling,\n    #[sea_orm(entity = \"super::fruit::Entity\", def = \"Relation::TropicalFruit.def()\")]\n    TropicalFruit,\n    #[sea_orm(\n        entity = \"super::fruit::Entity\",\n        def = \"Relation::OrTropicalFruit.def()\"\n    )]\n    OrTropicalFruit,\n}\n\nimpl ActiveModelBehavior for ActiveModel {}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "83b381eaf8db1c5705472040dd07f1a20a921e19",
    "func": "use crate::schema::TestBackend;\nuse diesel::*;\n\n#[test]\nfn test_debug_count_output() {\n    use crate::schema::users::dsl::*;\n    let sql = debug_query::<TestBackend, _>(&users.count()).to_string();\n    if cfg!(feature = \"postgres\") {\n        assert_eq!(sql, r#\"SELECT COUNT(*) FROM \"users\" -- binds: []\"#);\n    } else {\n        assert_eq!(sql, \"SELECT COUNT(*) FROM `users` -- binds: []\");\n    }\n}\n\n#[test]\nfn test_debug_output() {\n    use crate::schema::users::dsl::*;\n    let command = update(users.filter(id.eq(1))).set(name.eq(\"new_name\"));\n    let sql = debug_query::<TestBackend, _>(&command).to_string();\n    if cfg!(feature = \"postgres\") {\n        assert_eq!(\n            sql,\n            r#\"UPDATE \"users\" SET \"name\" = $1 WHERE (\"users\".\"id\" = $2) -- binds: [\"new_name\", 1]\"#\n        )\n    } else {\n        assert_eq!(\n            sql,\n            r#\"UPDATE `users` SET `name` = ? WHERE (`users`.`id` = ?) -- binds: [\"new_name\", 1]\"#\n        )\n    }\n}\n\n#[test]\nfn test_debug_batch_insert() {\n    use crate::schema::users::dsl::*;\n\n    let values = vec![\n        (name.eq(\"Sean\"), hair_color.eq(Some(\"black\"))),\n        (name.eq(\"Tess\"), hair_color.eq(None::<&str>)),\n    ];\n    let borrowed_command = insert_into(users).values(&values);\n    let borrowed_sql_display = debug_query::<TestBackend, _>(&borrowed_command).to_string();\n    let borrowed_sql_debug = format!(\"{:?}\", debug_query::<TestBackend, _>(&borrowed_command));\n\n    let owned_command = insert_into(users).values(values);\n    let owned_sql_display = debug_query::<TestBackend, _>(&owned_command).to_string();\n    let owned_sql_debug = format!(\"{:?}\", debug_query::<TestBackend, _>(&owned_command));\n\n    if cfg!(feature = \"postgres\") {\n        assert_eq!(\n            borrowed_sql_display,\n            r#\"INSERT INTO \"users\" (\"name\", \"hair_color\") VALUES ($1, $2), ($3, $4) -- binds: [\"Sean\", Some(\"black\"), \"Tess\", None]\"#\n        );\n        assert_eq!(\n            borrowed_sql_debug,\n            r#\"Query { sql: \"INSERT INTO \\\"users\\\" (\\\"name\\\", \\\"hair_color\\\") VALUES ($1, $2), ($3, $4)\", binds: [\"Sean\", Some(\"black\"), \"Tess\", None] }\"#\n        );\n\n        assert_eq!(\n            owned_sql_display,\n            r#\"INSERT INTO \"users\" (\"name\", \"hair_color\") VALUES ($1, $2), ($3, $4) -- binds: [\"Sean\", Some(\"black\"), \"Tess\", None]\"#\n        );\n        assert_eq!(\n            owned_sql_debug,\n            r#\"Query { sql: \"INSERT INTO \\\"users\\\" (\\\"name\\\", \\\"hair_color\\\") VALUES ($1, $2), ($3, $4)\", binds: [\"Sean\", Some(\"black\"), \"Tess\", None] }\"#\n        );\n    } else {\n        assert_eq!(\n            borrowed_sql_display,\n            r#\"INSERT INTO `users` (`name`, `hair_color`) VALUES (?, ?), (?, ?) -- binds: [\"Sean\", Some(\"black\"), \"Tess\", None]\"#\n        );\n        assert_eq!(\n            borrowed_sql_debug,\n            r#\"Query { sql: \"INSERT INTO `users` (`name`, `hair_color`) VALUES (?, ?), (?, ?)\", binds: [\"Sean\", Some(\"black\"), \"Tess\", None] }\"#\n        );\n\n        assert_eq!(\n            owned_sql_display,\n            r#\"INSERT INTO `users` (`name`, `hair_color`) VALUES (?, ?), (?, ?) -- binds: [\"Sean\", Some(\"black\"), \"Tess\", None]\"#\n        );\n        assert_eq!(\n            owned_sql_debug,\n            r#\"Query { sql: \"INSERT INTO `users` (`name`, `hair_color`) VALUES (?, ?), (?, ?)\", binds: [\"Sean\", Some(\"black\"), \"Tess\", None] }\"#\n        );\n    }\n}\n\n#[test]\n#[cfg(feature = \"sqlite\")]\nfn test_insert_with_default() {\n    // This test ensures that we've implemented `debug_query` for batch insert\n    // containing a default value on sqlite\n    // This requires a separate impl because it's more than one sql statement that\n    // is executed\n\n    use crate::schema::users::dsl::*;\n\n    let values = vec![\n        (Some(name.eq(\"Sean\")), hair_color.eq(Some(\"black\"))),\n        (Some(name.eq(\"Tess\")), hair_color.eq(None::<&str>)),\n    ];\n    let borrowed_command = insert_into(users).values(&values);\n    let borrowed_sql_display = debug_query::<TestBackend, _>(&borrowed_command).to_string();\n    let borrowed_sql_debug = format!(\"{:?}\", debug_query::<TestBackend, _>(&borrowed_command));\n\n    let owned_command = insert_into(users).values(values);\n    let owned_sql_display = debug_query::<TestBackend, _>(&owned_command).to_string();\n    let owned_sql_debug = format!(\"{:?}\", debug_query::<TestBackend, _>(&owned_command));\n\n    assert_eq!(\n        borrowed_sql_display,\n        r#\"BEGIN;\nINSERT INTO `users` (`name`, `hair_color`) VALUES (?, ?) -- binds: [\"Sean\", Some(\"black\")]\nINSERT INTO `users` (`name`, `hair_color`) VALUES (?, ?) -- binds: [\"Tess\", None]\nCOMMIT;\n\"#\n    );\n    assert_eq!(\n        borrowed_sql_debug,\n        r#\"Query { sql: [\"BEGIN\", \"INSERT INTO `users` (`name`, `hair_color`) VALUES (?, ?) -- binds: [\\\"Sean\\\", Some(\\\"black\\\")]\", \"INSERT INTO `users` (`name`, `hair_color`) VALUES (?, ?) -- binds: [\\\"Tess\\\", None]\", \"COMMIT\"], binds: [] }\"#\n    );\n\n    assert_eq!(\n        owned_sql_display,\n        r#\"BEGIN;\nINSERT INTO `users` (`name`, `hair_color`) VALUES (?, ?) -- binds: [\"Sean\", Some(\"black\")]\nINSERT INTO `users` (`name`, `hair_color`) VALUES (?, ?) -- binds: [\"Tess\", None]\nCOMMIT;\n\"#\n    );\n    assert_eq!(\n        owned_sql_debug,\n        r#\"Query { sql: [\"BEGIN\", \"INSERT INTO `users` (`name`, `hair_color`) VALUES (?, ?) -- binds: [\\\"Sean\\\", Some(\\\"black\\\")]\", \"INSERT INTO `users` (`name`, `hair_color`) VALUES (?, ?) -- binds: [\\\"Tess\\\", None]\", \"COMMIT\"], binds: [] }\"#\n    );\n}\n\n#[test]\n#[cfg(feature = \"postgres\")]\nfn test_upsert() {\n    // this test ensures we get the right debug string for upserts\n    use crate::schema::users::dsl::*;\n\n    let values = vec![\n        (name.eq(\"Sean\"), hair_color.eq(Some(\"black\"))),\n        (name.eq(\"Tess\"), hair_color.eq(None::<&str>)),\n    ];\n\n    let upsert_command_single_where = insert_into(users)\n        .values(&values)\n        .on_conflict(hair_color)\n        .filter_target(hair_color.eq(\"black\"))\n        .do_nothing();\n    let upsert_single_where_sql_display =\n        debug_query::<TestBackend, _>(&upsert_command_single_where).to_string();\n\n    assert_eq!(\n        upsert_single_where_sql_display,\n        r#\"INSERT INTO \"users\" (\"name\", \"hair_color\") VALUES ($1, $2), ($3, $4) ON CONFLICT (\"hair_color\") WHERE (\"users\".\"hair_color\" = $5) DO NOTHING -- binds: [\"Sean\", Some(\"black\"), \"Tess\", None, \"black\"]\"#\n    );\n\n    let upsert_command_second_where = insert_into(users)\n        .values(&values)\n        .on_conflict(hair_color)\n        .filter_target(hair_color.eq(\"black\"))\n        .filter_target(name.eq(\"Sean\"))\n        .do_nothing();\n\n    let upsert_second_where_sql_display =\n        debug_query::<TestBackend, _>(&upsert_command_second_where).to_string();\n\n    assert_eq!(\n        upsert_second_where_sql_display,\n        r#\"INSERT INTO \"users\" (\"name\", \"hair_color\") VALUES ($1, $2), ($3, $4) ON CONFLICT (\"hair_color\") WHERE ((\"users\".\"hair_color\" = $5) AND (\"users\".\"name\" = $6)) DO NOTHING -- binds: [\"Sean\", Some(\"black\"), \"Tess\", None, \"black\", \"Sean\"]\"#\n    );\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "09f3ddcc3e51802a1bedb5fd1fcefc3237b8d392",
    "func": "#![allow(unused_imports, dead_code)]\n\npub mod common;\n\npub use common::{features::*, setup::*, TestContext};\nuse pretty_assertions::assert_eq;\nuse sea_orm::{entity::prelude::*, query::*, DbBackend, IntoActiveModel, QueryOrder};\n\n#[sea_orm_macros::test]\nasync fn main() -> Result<(), DbErr> {\n    let ctx = TestContext::new(\"self_join_tests\").await;\n    create_tables(&ctx.db).await?;\n    create_metadata(&ctx.db).await?;\n    ctx.delete().await;\n    find_linked_001();\n    find_also_linked_001();\n\n    Ok(())\n}\n\npub async fn create_metadata(db: &DatabaseConnection) -> Result<(), DbErr> {\n    let model = self_join::Model {\n        uuid: Uuid::new_v4(),\n        uuid_ref: None,\n        time: Some(Time::from_hms_opt(1, 00, 00).unwrap()),\n    };\n\n    model.clone().into_active_model().insert(db).await?;\n\n    let linked_model = self_join::Model {\n        uuid: Uuid::new_v4(),\n        uuid_ref: Some(model.clone().uuid),\n        time: Some(Time::from_hms_opt(2, 00, 00).unwrap()),\n    };\n\n    linked_model.clone().into_active_model().insert(db).await?;\n\n    let not_linked_model = self_join::Model {\n        uuid: Uuid::new_v4(),\n        uuid_ref: None,\n        time: Some(Time::from_hms_opt(3, 00, 00).unwrap()),\n    };\n\n    not_linked_model\n        .clone()\n        .into_active_model()\n        .insert(db)\n        .await?;\n\n    assert_eq!(\n        model\n            .find_linked(self_join::SelfReferencingLink)\n            .all(db)\n            .await?,\n        []\n    );\n\n    assert_eq!(\n        linked_model\n            .find_linked(self_join::SelfReferencingLink)\n            .all(db)\n            .await?,\n        [model.clone()]\n    );\n\n    assert_eq!(\n        not_linked_model\n            .find_linked(self_join::SelfReferencingLink)\n            .all(db)\n            .await?,\n        []\n    );\n\n    assert_eq!(\n        self_join::Entity::find()\n            .find_also_linked(self_join::SelfReferencingLink)\n            .order_by_asc(self_join::Column::Time)\n            .all(db)\n            .await?,\n        [\n            (model.clone(), None),\n            (linked_model, Some(model)),\n            (not_linked_model, None),\n        ]\n    );\n\n    Ok(())\n}\n\nfn find_linked_001() {\n    use self_join::*;\n\n    let self_join_model = Model {\n        uuid: Uuid::default(),\n        uuid_ref: None,\n        time: None,\n    };\n\n    assert_eq!(\n        self_join_model\n            .find_linked(SelfReferencingLink)\n            .build(DbBackend::MySql)\n            .to_string(),\n        [\n            r#\"SELECT `self_join`.`uuid`, `self_join`.`uuid_ref`, `self_join`.`time`\"#,\n            r#\"FROM `self_join`\"#,\n            r#\"INNER JOIN `self_join` AS `r0` ON `r0`.`uuid_ref` = `self_join`.`uuid`\"#,\n            r#\"WHERE `r0`.`uuid` = '00000000-0000-0000-0000-000000000000'\"#,\n        ]\n        .join(\" \")\n    );\n}\n\nfn find_also_linked_001() {\n    use self_join::*;\n\n    assert_eq!(\n        Entity::find()\n            .find_also_linked(SelfReferencingLink)\n            .build(DbBackend::MySql)\n            .to_string(),\n        [\n            r#\"SELECT `self_join`.`uuid` AS `A_uuid`, `self_join`.`uuid_ref` AS `A_uuid_ref`, `self_join`.`time` AS `A_time`,\"#,\n            r#\"`r0`.`uuid` AS `B_uuid`, `r0`.`uuid_ref` AS `B_uuid_ref`, `r0`.`time` AS `B_time`\"#,\n            r#\"FROM `self_join`\"#,\n            r#\"LEFT JOIN `self_join` AS `r0` ON `self_join`.`uuid_ref` = `r0`.`uuid`\"#,\n        ]\n        .join(\" \")\n    );\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "8a46b7620ddb91115f4d8e98de27978780be0941",
    "func": "//! Run with\n//!\n//! ```not_rust\n//! cargo run -p example-templates\n//! ```\n\nuse askama::Template;\nuse axum::{\n    extract,\n    http::StatusCode,\n    response::{Html, IntoResponse, Response},\n    routing::get,\n    Router,\n};\nuse tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};\n\n#[tokio::main]\nasync fn main() {\n    tracing_subscriber::registry()\n        .with(\n            tracing_subscriber::EnvFilter::try_from_default_env()\n                .unwrap_or_else(|_| format!(\"{}=debug\", env!(\"CARGO_CRATE_NAME\")).into()),\n        )\n        .with(tracing_subscriber::fmt::layer())\n        .init();\n\n    // build our application with some routes\n    let app = Router::new().route(\"/greet/{name}\", get(greet));\n\n    // run it\n    let listener = tokio::net::TcpListener::bind(\"127.0.0.1:3000\")\n        .await\n        .unwrap();\n    tracing::debug!(\"listening on {}\", listener.local_addr().unwrap());\n    axum::serve(listener, app).await.unwrap();\n}\n\nasync fn greet(extract::Path(name): extract::Path<String>) -> impl IntoResponse {\n    let template = HelloTemplate { name };\n    HtmlTemplate(template)\n}\n\n#[derive(Template)]\n#[template(path = \"hello.html\")]\nstruct HelloTemplate {\n    name: String,\n}\n\nstruct HtmlTemplate<T>(T);\n\nimpl<T> IntoResponse for HtmlTemplate<T>\nwhere\n    T: Template,\n{\n    fn into_response(self) -> Response {\n        match self.0.render() {\n            Ok(html) => Html(html).into_response(),\n            Err(err) => (\n                StatusCode::INTERNAL_SERVER_ERROR,\n                format!(\"Failed to render template. Error: {err}\"),\n            )\n                .into_response(),\n        }\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "b4b4c7660d03f82b4fb474acf8d447be707bd437",
    "func": "//! This example illustrates the various features of Bevy UI.\n\nuse bevy::{\n    a11y::{\n        accesskit::{NodeBuilder, Role},\n        AccessibilityNode,\n    },\n    color::palettes::basic::LIME,\n    input::mouse::{MouseScrollUnit, MouseWheel},\n    picking::focus::HoverMap,\n    prelude::*,\n    winit::WinitSettings,\n};\n\nfn main() {\n    let mut app = App::new();\n    app.add_plugins(DefaultPlugins)\n        // Only run the app when there is user input. This will significantly reduce CPU/GPU use.\n        .insert_resource(WinitSettings::desktop_app())\n        .add_systems(Startup, setup)\n        .add_systems(Update, update_scroll_position);\n\n    #[cfg(feature = \"bevy_dev_tools\")]\n    {\n        app.add_plugins(bevy::dev_tools::ui_debug_overlay::DebugUiPlugin)\n            .add_systems(Update, toggle_overlay);\n    }\n\n    app.run();\n}\n\nfn setup(mut commands: Commands, asset_server: Res<AssetServer>) {\n    // Camera\n    commands.spawn((Camera2d, IsDefaultUiCamera, UiBoxShadowSamples(6)));\n\n    // root node\n    commands\n        .spawn(Node {\n            width: Val::Percent(100.0),\n            height: Val::Percent(100.0),\n            justify_content: JustifyContent::SpaceBetween,\n            ..default()\n        })\n        .insert(PickingBehavior::IGNORE)\n        .with_children(|parent| {\n            // left vertical fill (border)\n            parent\n                .spawn((\n                    Node {\n                        width: Val::Px(200.),\n                        border: UiRect::all(Val::Px(2.)),\n                        ..default()\n                    },\n                    BackgroundColor(Color::srgb(0.65, 0.65, 0.65)),\n                ))\n                .with_children(|parent| {\n                    // left vertical fill (content)\n                    parent\n                        .spawn((\n                            Node {\n                                width: Val::Percent(100.),\n                                flex_direction: FlexDirection::Column,\n                                padding: UiRect::all(Val::Px(5.)),\n                                row_gap: Val::Px(5.),\n                                ..default()\n                            },\n                            BackgroundColor(Color::srgb(0.15, 0.15, 0.15)),\n                        ))\n                        .with_children(|parent| {\n                            // text\n                            parent.spawn((\n                                Text::new(\"Text Example\"),\n                                TextFont {\n                                    font: asset_server.load(\"fonts/FiraSans-Bold.ttf\"),\n                                    font_size: 25.0,\n                                    ..default()\n                                },\n                                // Because this is a distinct label widget and\n                                // not button/list item text, this is necessary\n                                // for accessibility to treat the text accordingly.\n                                Label,\n                            ));\n\n                            #[cfg(feature = \"bevy_dev_tools\")]\n                            // Debug overlay text\n                            parent.spawn((\n                                Text::new(\"Press Space to enable debug outlines.\"),\n                                TextFont {\n                                    font: asset_server.load(\"fonts/FiraSans-Bold.ttf\"),\n                                    ..default()\n                                },\n                                Label,\n                            ));\n\n                            #[cfg(not(feature = \"bevy_dev_tools\"))]\n                            parent.spawn((\n                                Text::new(\"Try enabling feature \\\"bevy_dev_tools\\\".\"),\n                                TextFont {\n                                    font: asset_server.load(\"fonts/FiraSans-Bold.ttf\"),\n                                    ..default()\n                                },\n                                Label,\n                            ));\n                        });\n                });\n            // right vertical fill\n            parent\n                .spawn(Node {\n                    flex_direction: FlexDirection::Column,\n                    justify_content: JustifyContent::Center,\n                    align_items: AlignItems::Center,\n                    width: Val::Px(200.),\n                    ..default()\n                })\n                .with_children(|parent| {\n                    // Title\n                    parent.spawn((\n                        Text::new(\"Scrolling list\"),\n                        TextFont {\n                            font: asset_server.load(\"fonts/FiraSans-Bold.ttf\"),\n                            font_size: 21.,\n                            ..default()\n                        },\n                        Label,\n                    ));\n                    // Scrolling list\n                    parent\n                        .spawn((\n                            Node {\n                                flex_direction: FlexDirection::Column,\n                                align_self: AlignSelf::Stretch,\n                                height: Val::Percent(50.),\n                                overflow: Overflow::scroll_y(),\n                                ..default()\n                            },\n                            BackgroundColor(Color::srgb(0.10, 0.10, 0.10)),\n                        ))\n                        .with_children(|parent| {\n                            // List items\n                            for i in 0..25 {\n                                parent\n                                    .spawn((\n                                        Text(format!(\"Item {i}\")),\n                                        TextFont {\n                                            font: asset_server.load(\"fonts/FiraSans-Bold.ttf\"),\n                                            ..default()\n                                        },\n                                        Label,\n                                        AccessibilityNode(NodeBuilder::new(Role::ListItem)),\n                                    ))\n                                    .insert(PickingBehavior {\n                                        should_block_lower: false,\n                                        ..default()\n                                    });\n                            }\n                        });\n                });\n\n            parent\n                .spawn((\n                    Node {\n                        width: Val::Px(200.0),\n                        height: Val::Px(200.0),\n                        position_type: PositionType::Absolute,\n                        left: Val::Px(210.),\n                        bottom: Val::Px(10.),\n                        border: UiRect::all(Val::Px(20.)),\n                        ..default()\n                    },\n                    BorderColor(LIME.into()),\n                    BackgroundColor(Color::srgb(0.4, 0.4, 1.)),\n                ))\n                .with_children(|parent| {\n                    parent.spawn((\n                        Node {\n                            width: Val::Percent(100.0),\n                            height: Val::Percent(100.0),\n                            ..default()\n                        },\n                        BackgroundColor(Color::srgb(0.8, 0.8, 1.)),\n                    ));\n                });\n\n            let shadow = BoxShadow {\n                color: Color::BLACK.with_alpha(0.5),\n                blur_radius: Val::Px(2.),\n                x_offset: Val::Px(10.),\n                y_offset: Val::Px(10.),\n                ..Default::default()\n            };\n\n            // render order test: reddest in the back, whitest in the front (flex center)\n            parent\n                .spawn(Node {\n                    width: Val::Percent(100.0),\n                    height: Val::Percent(100.0),\n                    position_type: PositionType::Absolute,\n                    align_items: AlignItems::Center,\n                    justify_content: JustifyContent::Center,\n                    ..default()\n                })\n                .insert(PickingBehavior::IGNORE)\n                .with_children(|parent| {\n                    parent\n                        .spawn((\n                            Node {\n                                width: Val::Px(100.0),\n                                height: Val::Px(100.0),\n                                ..default()\n                            },\n                            BackgroundColor(Color::srgb(1.0, 0.0, 0.)),\n                            shadow,\n                        ))\n                        .with_children(|parent| {\n                            parent.spawn((\n                                Node {\n                                    // Take the size of the parent node.\n                                    width: Val::Percent(100.0),\n                                    height: Val::Percent(100.0),\n                                    position_type: PositionType::Absolute,\n                                    left: Val::Px(20.),\n                                    bottom: Val::Px(20.),\n                                    ..default()\n                                },\n                                BackgroundColor(Color::srgb(1.0, 0.3, 0.3)),\n                                shadow,\n                            ));\n                            parent.spawn((\n                                Node {\n                                    width: Val::Percent(100.0),\n                                    height: Val::Percent(100.0),\n                                    position_type: PositionType::Absolute,\n                                    left: Val::Px(40.),\n                                    bottom: Val::Px(40.),\n                                    ..default()\n                                },\n                                BackgroundColor(Color::srgb(1.0, 0.5, 0.5)),\n                                shadow,\n                            ));\n                            parent.spawn((\n                                Node {\n                                    width: Val::Percent(100.0),\n                                    height: Val::Percent(100.0),\n                                    position_type: PositionType::Absolute,\n                                    left: Val::Px(60.),\n                                    bottom: Val::Px(60.),\n                                    ..default()\n                                },\n                                BackgroundColor(Color::srgb(0.0, 0.7, 0.7)),\n                                shadow,\n                            ));\n                            // alpha test\n                            parent.spawn((\n                                Node {\n                                    width: Val::Percent(100.0),\n                                    height: Val::Percent(100.0),\n                                    position_type: PositionType::Absolute,\n                                    left: Val::Px(80.),\n                                    bottom: Val::Px(80.),\n                                    ..default()\n                                },\n                                BackgroundColor(Color::srgba(1.0, 0.9, 0.9, 0.4)),\n                                BoxShadow {\n                                    color: Color::BLACK.with_alpha(0.3),\n                                    ..shadow\n                                },\n                            ));\n                        });\n                });\n            // bevy logo (flex center)\n            parent\n                .spawn(Node {\n                    width: Val::Percent(100.0),\n                    position_type: PositionType::Absolute,\n                    justify_content: JustifyContent::Center,\n                    align_items: AlignItems::FlexStart,\n                    ..default()\n                })\n                .with_children(|parent| {\n                    // bevy logo (image)\n                    parent\n                        .spawn((\n                            UiImage::new(asset_server.load(\"branding/bevy_logo_dark_big.png\")),\n                            Node {\n                                width: Val::Px(500.0),\n                                height: Val::Px(125.0),\n                                margin: UiRect::top(Val::VMin(5.)),\n                                ..default()\n                            },\n                        ))\n                        .with_children(|parent| {\n                            // alt text\n                            // This UI node takes up no space in the layout and the `Text` component is used by the accessibility module\n                            // and is not rendered.\n                            parent.spawn((\n                                Node {\n                                    display: Display::None,\n                                    ..default()\n                                },\n                                Text::new(\"Bevy logo\"),\n                            ));\n                        });\n                });\n        });\n}\n\n#[cfg(feature = \"bevy_dev_tools\")]\n// The system that will enable/disable the debug outlines around the nodes\nfn toggle_overlay(\n    input: Res<ButtonInput<KeyCode>>,\n    mut options: ResMut<bevy::dev_tools::ui_debug_overlay::UiDebugOptions>,\n) {\n    info_once!(\"The debug outlines are enabled, press Space to turn them on/off\");\n    if input.just_pressed(KeyCode::Space) {\n        // The toggle method will enable the debug_overlay if disabled and disable if enabled\n        options.toggle();\n    }\n}\n\n/// Updates the scroll position of scrollable nodes in response to mouse input\npub fn update_scroll_position(\n    mut mouse_wheel_events: EventReader<MouseWheel>,\n    hover_map: Res<HoverMap>,\n    mut scrolled_node_query: Query<&mut ScrollPosition>,\n    keyboard_input: Res<ButtonInput<KeyCode>>,\n) {\n    for mouse_wheel_event in mouse_wheel_events.read() {\n        let (mut dx, mut dy) = match mouse_wheel_event.unit {\n            MouseScrollUnit::Line => (mouse_wheel_event.x * 20., mouse_wheel_event.y * 20.),\n            MouseScrollUnit::Pixel => (mouse_wheel_event.x, mouse_wheel_event.y),\n        };\n\n        if keyboard_input.pressed(KeyCode::ShiftLeft) || keyboard_input.pressed(KeyCode::ShiftRight)\n        {\n            std::mem::swap(&mut dx, &mut dy);\n        }\n\n        for (_pointer, pointer_map) in hover_map.iter() {\n            for (entity, _hit) in pointer_map.iter() {\n                if let Ok(mut scroll_position) = scrolled_node_query.get_mut(*entity) {\n                    scroll_position.offset_x -= dx;\n                    scroll_position.offset_y -= dy;\n                }\n            }\n        }\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "aa0dba8e7dd3daa5528f4fb881cd0a6063c3c969",
    "func": "#![allow(unused)] // Because indirectly included by e.g.integration_tests.rs, but not everything inside is used\n\nuse assert_cmd::cargo::CommandCargoExt;\nuse std::process::Command;\n\npub fn bat_raw_command_with_config() -> Command {\n    let mut cmd = Command::cargo_bin(\"bat\").unwrap();\n    cmd.current_dir(\"tests/examples\");\n    cmd.env_remove(\"BAT_CACHE_PATH\");\n    cmd.env_remove(\"BAT_CONFIG_DIR\");\n    cmd.env_remove(\"BAT_CONFIG_PATH\");\n    cmd.env_remove(\"BAT_OPTS\");\n    cmd.env_remove(\"BAT_PAGER\");\n    cmd.env_remove(\"BAT_STYLE\");\n    cmd.env_remove(\"BAT_TABS\");\n    cmd.env_remove(\"BAT_THEME\");\n    cmd.env_remove(\"COLORTERM\");\n    cmd.env_remove(\"NO_COLOR\");\n    cmd.env_remove(\"PAGER\");\n    cmd.env_remove(\"LESSOPEN\");\n    cmd.env_remove(\"LESSCLOSE\");\n    cmd.env_remove(\"SHELL\");\n    cmd\n}\n\n#[cfg(test)]\npub fn bat_raw_command() -> Command {\n    let mut cmd = bat_raw_command_with_config();\n    cmd.arg(\"--no-config\");\n    cmd\n}\n\n#[cfg(test)]\npub fn bat_with_config() -> assert_cmd::Command {\n    assert_cmd::Command::from_std(bat_raw_command_with_config())\n}\n\n#[cfg(test)]\npub fn bat() -> assert_cmd::Command {\n    assert_cmd::Command::from_std(bat_raw_command())\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "72c446a0d016f2c9b362840a7b6443506a4ad5f1",
    "func": "use super::{Context, Module, ModuleConfig};\n\nuse crate::configs::erlang::ErlangConfig;\nuse crate::formatter::StringFormatter;\nuse crate::formatter::VersionFormatter;\n\n/// Create a module with the current Erlang version\npub fn module<'a>(context: &'a Context) -> Option<Module<'a>> {\n    let mut module = context.new_module(\"erlang\");\n    let config = ErlangConfig::try_load(module.config);\n\n    let is_erlang_project = context\n        .try_begin_scan()?\n        .set_files(&config.detect_files)\n        .set_extensions(&config.detect_extensions)\n        .set_folders(&config.detect_folders)\n        .is_match();\n\n    if !is_erlang_project {\n        return None;\n    }\n\n    let parsed = StringFormatter::new(config.format).and_then(|formatter| {\n        formatter\n            .map_meta(|variable, _| match variable {\n                \"symbol\" => Some(config.symbol),\n                _ => None,\n            })\n            .map_style(|variable| match variable {\n                \"style\" => Some(Ok(config.style)),\n                _ => None,\n            })\n            .map(|variable| match variable {\n                \"version\" => {\n                    let erlang_version = get_erlang_version(context)?;\n                    VersionFormatter::format_module_version(\n                        module.get_name(),\n                        &erlang_version,\n                        config.version_format,\n                    )\n                    .map(Ok)\n                }\n                _ => None,\n            })\n            .parse(None, Some(context))\n    });\n\n    module.set_segments(match parsed {\n        Ok(segments) => segments,\n        Err(error) => {\n            log::warn!(\"Error in module `erlang`:\\n{}\", error);\n            return None;\n        }\n    });\n\n    Some(module)\n}\n\nfn get_erlang_version(context: &Context) -> Option<String> {\n    Some(context.exec_cmd(\n        \"erl\",\n        &[\n            \"-noshell\",\n            \"-eval\",\n            \"Fn=filename:join([code:root_dir(),\\\"releases\\\",erlang:system_info(otp_release),\\\"OTP_VERSION\\\"]),\\\n             {ok,Content}=file:read_file(Fn),\\\n             io:format(\\\"~s\\\",[Content]),\\\n             halt(0).\"\n        ]\n    )?.stdout.trim().to_string())\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::test::ModuleRenderer;\n    use nu_ansi_term::Color;\n    use std::fs::File;\n    use std::io;\n\n    #[test]\n    fn test_without_config() -> io::Result<()> {\n        let dir = tempfile::tempdir()?;\n\n        let expected = None;\n        let output = ModuleRenderer::new(\"erlang\").path(dir.path()).collect();\n\n        assert_eq!(output, expected);\n\n        dir.close()\n    }\n\n    #[test]\n    fn test_with_config() -> io::Result<()> {\n        let dir = tempfile::tempdir()?;\n        File::create(dir.path().join(\"rebar.config\"))?.sync_all()?;\n\n        let expected = Some(format!(\"via {}\", Color::Red.bold().paint(\"\ue7b1 v22.1.3 \")));\n        let output = ModuleRenderer::new(\"erlang\").path(dir.path()).collect();\n\n        assert_eq!(output, expected);\n\n        dir.close()\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "ce0aa9d752946e84fda10b4a2e466c04fbaf5975",
    "func": "//! Contains APIs for ordering systems and executing them on a [`World`](crate::world::World)\n\nmod condition;\nmod config;\nmod executor;\nmod graph_utils;\n#[allow(clippy::module_inception)]\nmod schedule;\nmod set;\nmod stepping;\n\nuse self::graph_utils::*;\npub use self::{condition::*, config::*, executor::*, schedule::*, set::*};\n\npub use self::graph_utils::NodeId;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use core::sync::atomic::{AtomicU32, Ordering};\n\n    pub use crate as bevy_ecs;\n    pub use crate::{\n        prelude::World,\n        schedule::{Schedule, SystemSet},\n        system::{Res, ResMut, Resource},\n    };\n\n    #[derive(SystemSet, Clone, Debug, PartialEq, Eq, Hash)]\n    enum TestSet {\n        A,\n        B,\n        C,\n        D,\n        X,\n    }\n\n    #[derive(Resource, Default)]\n    struct SystemOrder(Vec<u32>);\n\n    #[derive(Resource, Default)]\n    struct RunConditionBool(pub bool);\n\n    #[derive(Resource, Default)]\n    struct Counter(pub AtomicU32);\n\n    fn make_exclusive_system(tag: u32) -> impl FnMut(&mut World) {\n        move |world| world.resource_mut::<SystemOrder>().0.push(tag)\n    }\n\n    fn make_function_system(tag: u32) -> impl FnMut(ResMut<SystemOrder>) {\n        move |mut resource: ResMut<SystemOrder>| resource.0.push(tag)\n    }\n\n    fn named_system(mut resource: ResMut<SystemOrder>) {\n        resource.0.push(u32::MAX);\n    }\n\n    fn named_exclusive_system(world: &mut World) {\n        world.resource_mut::<SystemOrder>().0.push(u32::MAX);\n    }\n\n    fn counting_system(counter: Res<Counter>) {\n        counter.0.fetch_add(1, Ordering::Relaxed);\n    }\n\n    mod system_execution {\n        use super::*;\n\n        #[test]\n        fn run_system() {\n            let mut world = World::default();\n            let mut schedule = Schedule::default();\n\n            world.init_resource::<SystemOrder>();\n\n            schedule.add_systems(make_function_system(0));\n            schedule.run(&mut world);\n\n            assert_eq!(world.resource::<SystemOrder>().0, vec![0]);\n        }\n\n        #[test]\n        fn run_exclusive_system() {\n            let mut world = World::default();\n            let mut schedule = Schedule::default();\n\n            world.init_resource::<SystemOrder>();\n\n            schedule.add_systems(make_exclusive_system(0));\n            schedule.run(&mut world);\n\n            assert_eq!(world.resource::<SystemOrder>().0, vec![0]);\n        }\n\n        #[test]\n        #[cfg(not(miri))]\n        fn parallel_execution() {\n            use alloc::sync::Arc;\n            use bevy_tasks::{ComputeTaskPool, TaskPool};\n            use std::sync::Barrier;\n\n            let mut world = World::default();\n            let mut schedule = Schedule::default();\n            let thread_count = ComputeTaskPool::get_or_init(TaskPool::default).thread_num();\n\n            let barrier = Arc::new(Barrier::new(thread_count));\n\n            for _ in 0..thread_count {\n                let inner = barrier.clone();\n                schedule.add_systems(move || {\n                    inner.wait();\n                });\n            }\n\n            schedule.run(&mut world);\n        }\n    }\n\n    mod system_ordering {\n        use super::*;\n\n        #[test]\n        fn order_systems() {\n            let mut world = World::default();\n            let mut schedule = Schedule::default();\n\n            world.init_resource::<SystemOrder>();\n\n            schedule.add_systems((\n                named_system,\n                make_function_system(1).before(named_system),\n                make_function_system(0)\n                    .after(named_system)\n                    .in_set(TestSet::A),\n            ));\n            schedule.run(&mut world);\n\n            assert_eq!(world.resource::<SystemOrder>().0, vec![1, u32::MAX, 0]);\n\n            world.insert_resource(SystemOrder::default());\n\n            assert_eq!(world.resource::<SystemOrder>().0, vec![]);\n\n            // modify the schedule after it's been initialized and test ordering with sets\n            schedule.configure_sets(TestSet::A.after(named_system));\n            schedule.add_systems((\n                make_function_system(3)\n                    .before(TestSet::A)\n                    .after(named_system),\n                make_function_system(4).after(TestSet::A),\n            ));\n            schedule.run(&mut world);\n\n            assert_eq!(\n                world.resource::<SystemOrder>().0,\n                vec![1, u32::MAX, 3, 0, 4]\n            );\n        }\n\n        #[test]\n        fn order_exclusive_systems() {\n            let mut world = World::default();\n            let mut schedule = Schedule::default();\n\n            world.init_resource::<SystemOrder>();\n\n            schedule.add_systems((\n                named_exclusive_system,\n                make_exclusive_system(1).before(named_exclusive_system),\n                make_exclusive_system(0).after(named_exclusive_system),\n            ));\n            schedule.run(&mut world);\n\n            assert_eq!(world.resource::<SystemOrder>().0, vec![1, u32::MAX, 0]);\n        }\n\n        #[test]\n        fn add_systems_correct_order() {\n            let mut world = World::new();\n            let mut schedule = Schedule::default();\n\n            world.init_resource::<SystemOrder>();\n\n            schedule.add_systems(\n                (\n                    make_function_system(0),\n                    make_function_system(1),\n                    make_exclusive_system(2),\n                    make_function_system(3),\n                )\n                    .chain(),\n            );\n\n            schedule.run(&mut world);\n            assert_eq!(world.resource::<SystemOrder>().0, vec![0, 1, 2, 3]);\n        }\n\n        #[test]\n        fn add_systems_correct_order_nested() {\n            let mut world = World::new();\n            let mut schedule = Schedule::default();\n\n            world.init_resource::<SystemOrder>();\n\n            schedule.add_systems(\n                (\n                    (make_function_system(0), make_function_system(1)).chain(),\n                    make_function_system(2),\n                    (make_function_system(3), make_function_system(4)).chain(),\n                    (\n                        make_function_system(5),\n                        (make_function_system(6), make_function_system(7)),\n                    ),\n                    (\n                        (make_function_system(8), make_function_system(9)).chain(),\n                        make_function_system(10),\n                    ),\n                )\n                    .chain(),\n            );\n\n            schedule.run(&mut world);\n            let order = &world.resource::<SystemOrder>().0;\n            assert_eq!(\n                &order[0..5],\n                &[0, 1, 2, 3, 4],\n                \"first five items should be exactly ordered\"\n            );\n            let unordered = &order[5..8];\n            assert!(\n                unordered.contains(&5) && unordered.contains(&6) && unordered.contains(&7),\n                \"unordered must be 5, 6, and 7 in any order\"\n            );\n            let partially_ordered = &order[8..11];\n            assert!(\n                partially_ordered == [8, 9, 10] || partially_ordered == [10, 8, 9],\n                \"partially_ordered must be [8, 9, 10] or [10, 8, 9]\"\n            );\n            assert_eq!(order.len(), 11, \"must have exactly 11 order entries\");\n        }\n    }\n\n    mod conditions {\n        use crate::change_detection::DetectChanges;\n\n        use super::*;\n\n        #[test]\n        fn system_with_condition() {\n            let mut world = World::default();\n            let mut schedule = Schedule::default();\n\n            world.init_resource::<RunConditionBool>();\n            world.init_resource::<SystemOrder>();\n\n            schedule.add_systems(\n                make_function_system(0).run_if(|condition: Res<RunConditionBool>| condition.0),\n            );\n\n            schedule.run(&mut world);\n            assert_eq!(world.resource::<SystemOrder>().0, vec![]);\n\n            world.resource_mut::<RunConditionBool>().0 = true;\n            schedule.run(&mut world);\n            assert_eq!(world.resource::<SystemOrder>().0, vec![0]);\n        }\n\n        #[test]\n        fn systems_with_distributive_condition() {\n            let mut world = World::default();\n            let mut schedule = Schedule::default();\n\n            world.insert_resource(RunConditionBool(true));\n            world.init_resource::<SystemOrder>();\n\n            fn change_condition(mut condition: ResMut<RunConditionBool>) {\n                condition.0 = false;\n            }\n\n            schedule.add_systems(\n                (\n                    make_function_system(0),\n                    change_condition,\n                    make_function_system(1),\n                )\n                    .chain()\n                    .distributive_run_if(|condition: Res<RunConditionBool>| condition.0),\n            );\n\n            schedule.run(&mut world);\n            assert_eq!(world.resource::<SystemOrder>().0, vec![0]);\n        }\n\n        #[test]\n        fn run_exclusive_system_with_condition() {\n            let mut world = World::default();\n            let mut schedule = Schedule::default();\n\n            world.init_resource::<RunConditionBool>();\n            world.init_resource::<SystemOrder>();\n\n            schedule.add_systems(\n                make_exclusive_system(0).run_if(|condition: Res<RunConditionBool>| condition.0),\n            );\n\n            schedule.run(&mut world);\n            assert_eq!(world.resource::<SystemOrder>().0, vec![]);\n\n            world.resource_mut::<RunConditionBool>().0 = true;\n            schedule.run(&mut world);\n            assert_eq!(world.resource::<SystemOrder>().0, vec![0]);\n        }\n\n        #[test]\n        fn multiple_conditions_on_system() {\n            let mut world = World::default();\n            let mut schedule = Schedule::default();\n\n            world.init_resource::<Counter>();\n\n            schedule.add_systems((\n                counting_system.run_if(|| false).run_if(|| false),\n                counting_system.run_if(|| true).run_if(|| false),\n                counting_system.run_if(|| false).run_if(|| true),\n                counting_system.run_if(|| true).run_if(|| true),\n            ));\n\n            schedule.run(&mut world);\n            assert_eq!(world.resource::<Counter>().0.load(Ordering::Relaxed), 1);\n        }\n\n        #[test]\n        fn multiple_conditions_on_system_sets() {\n            let mut world = World::default();\n            let mut schedule = Schedule::default();\n\n            world.init_resource::<Counter>();\n\n            schedule.configure_sets(TestSet::A.run_if(|| false).run_if(|| false));\n            schedule.add_systems(counting_system.in_set(TestSet::A));\n            schedule.configure_sets(TestSet::B.run_if(|| true).run_if(|| false));\n            schedule.add_systems(counting_system.in_set(TestSet::B));\n            schedule.configure_sets(TestSet::C.run_if(|| false).run_if(|| true));\n            schedule.add_systems(counting_system.in_set(TestSet::C));\n            schedule.configure_sets(TestSet::D.run_if(|| true).run_if(|| true));\n            schedule.add_systems(counting_system.in_set(TestSet::D));\n\n            schedule.run(&mut world);\n            assert_eq!(world.resource::<Counter>().0.load(Ordering::Relaxed), 1);\n        }\n\n        #[test]\n        fn systems_nested_in_system_sets() {\n            let mut world = World::default();\n            let mut schedule = Schedule::default();\n\n            world.init_resource::<Counter>();\n\n            schedule.configure_sets(TestSet::A.run_if(|| false));\n            schedule.add_systems(counting_system.in_set(TestSet::A).run_if(|| false));\n            schedule.configure_sets(TestSet::B.run_if(|| true));\n            schedule.add_systems(counting_system.in_set(TestSet::B).run_if(|| false));\n            schedule.configure_sets(TestSet::C.run_if(|| false));\n            schedule.add_systems(counting_system.in_set(TestSet::C).run_if(|| true));\n            schedule.configure_sets(TestSet::D.run_if(|| true));\n            schedule.add_systems(counting_system.in_set(TestSet::D).run_if(|| true));\n\n            schedule.run(&mut world);\n            assert_eq!(world.resource::<Counter>().0.load(Ordering::Relaxed), 1);\n        }\n\n        #[test]\n        fn system_conditions_and_change_detection() {\n            #[derive(Resource, Default)]\n            struct Bool2(pub bool);\n\n            let mut world = World::default();\n            world.init_resource::<Counter>();\n            world.init_resource::<RunConditionBool>();\n            world.init_resource::<Bool2>();\n            let mut schedule = Schedule::default();\n\n            schedule.add_systems(\n                counting_system\n                    .run_if(|res1: Res<RunConditionBool>| res1.is_changed())\n                    .run_if(|res2: Res<Bool2>| res2.is_changed()),\n            );\n\n            // both resource were just added.\n            schedule.run(&mut world);\n            assert_eq!(world.resource::<Counter>().0.load(Ordering::Relaxed), 1);\n\n            // nothing has changed\n            schedule.run(&mut world);\n            assert_eq!(world.resource::<Counter>().0.load(Ordering::Relaxed), 1);\n\n            // RunConditionBool has changed, but counting_system did not run\n            world.get_resource_mut::<RunConditionBool>().unwrap().0 = false;\n            schedule.run(&mut world);\n            assert_eq!(world.resource::<Counter>().0.load(Ordering::Relaxed), 1);\n\n            // internal state for the bool2 run criteria was updated in the\n            // previous run, so system still does not run\n            world.get_resource_mut::<Bool2>().unwrap().0 = false;\n            schedule.run(&mut world);\n            assert_eq!(world.resource::<Counter>().0.load(Ordering::Relaxed), 1);\n\n            // internal state for bool2 was updated, so system still does not run\n            world.get_resource_mut::<RunConditionBool>().unwrap().0 = false;\n            schedule.run(&mut world);\n            assert_eq!(world.resource::<Counter>().0.load(Ordering::Relaxed), 1);\n\n            // now check that it works correctly changing Bool2 first and then RunConditionBool\n            world.get_resource_mut::<Bool2>().unwrap().0 = false;\n            world.get_resource_mut::<RunConditionBool>().unwrap().0 = false;\n            schedule.run(&mut world);\n            assert_eq!(world.resource::<Counter>().0.load(Ordering::Relaxed), 2);\n        }\n\n        #[test]\n        fn system_set_conditions_and_change_detection() {\n            #[derive(Resource, Default)]\n            struct Bool2(pub bool);\n\n            let mut world = World::default();\n            world.init_resource::<Counter>();\n            world.init_resource::<RunConditionBool>();\n            world.init_resource::<Bool2>();\n            let mut schedule = Schedule::default();\n\n            schedule.configure_sets(\n                TestSet::A\n                    .run_if(|res1: Res<RunConditionBool>| res1.is_changed())\n                    .run_if(|res2: Res<Bool2>| res2.is_changed()),\n            );\n\n            schedule.add_systems(counting_system.in_set(TestSet::A));\n\n            // both resource were just added.\n            schedule.run(&mut world);\n            assert_eq!(world.resource::<Counter>().0.load(Ordering::Relaxed), 1);\n\n            // nothing has changed\n            schedule.run(&mut world);\n            assert_eq!(world.resource::<Counter>().0.load(Ordering::Relaxed), 1);\n\n            // RunConditionBool has changed, but counting_system did not run\n            world.get_resource_mut::<RunConditionBool>().unwrap().0 = false;\n            schedule.run(&mut world);\n            assert_eq!(world.resource::<Counter>().0.load(Ordering::Relaxed), 1);\n\n            // internal state for the bool2 run criteria was updated in the\n            // previous run, so system still does not run\n            world.get_resource_mut::<Bool2>().unwrap().0 = false;\n            schedule.run(&mut world);\n            assert_eq!(world.resource::<Counter>().0.load(Ordering::Relaxed), 1);\n\n            // internal state for bool2 was updated, so system still does not run\n            world.get_resource_mut::<RunConditionBool>().unwrap().0 = false;\n            schedule.run(&mut world);\n            assert_eq!(world.resource::<Counter>().0.load(Ordering::Relaxed), 1);\n\n            // the system only runs when both are changed on the same run\n            world.get_resource_mut::<Bool2>().unwrap().0 = false;\n            world.get_resource_mut::<RunConditionBool>().unwrap().0 = false;\n            schedule.run(&mut world);\n            assert_eq!(world.resource::<Counter>().0.load(Ordering::Relaxed), 2);\n        }\n\n        #[test]\n        fn mixed_conditions_and_change_detection() {\n            #[derive(Resource, Default)]\n            struct Bool2(pub bool);\n\n            let mut world = World::default();\n            world.init_resource::<Counter>();\n            world.init_resource::<RunConditionBool>();\n            world.init_resource::<Bool2>();\n            let mut schedule = Schedule::default();\n\n            schedule\n                .configure_sets(TestSet::A.run_if(|res1: Res<RunConditionBool>| res1.is_changed()));\n\n            schedule.add_systems(\n                counting_system\n                    .run_if(|res2: Res<Bool2>| res2.is_changed())\n                    .in_set(TestSet::A),\n            );\n\n            // both resource were just added.\n            schedule.run(&mut world);\n            assert_eq!(world.resource::<Counter>().0.load(Ordering::Relaxed), 1);\n\n            // nothing has changed\n            schedule.run(&mut world);\n            assert_eq!(world.resource::<Counter>().0.load(Ordering::Relaxed), 1);\n\n            // RunConditionBool has changed, but counting_system did not run\n            world.get_resource_mut::<RunConditionBool>().unwrap().0 = false;\n            schedule.run(&mut world);\n            assert_eq!(world.resource::<Counter>().0.load(Ordering::Relaxed), 1);\n\n            // we now only change bool2 and the system also should not run\n            world.get_resource_mut::<Bool2>().unwrap().0 = false;\n            schedule.run(&mut world);\n            assert_eq!(world.resource::<Counter>().0.load(Ordering::Relaxed), 1);\n\n            // internal state for the bool2 run criteria was updated in the\n            // previous run, so system still does not run\n            world.get_resource_mut::<RunConditionBool>().unwrap().0 = false;\n            schedule.run(&mut world);\n            assert_eq!(world.resource::<Counter>().0.load(Ordering::Relaxed), 1);\n\n            // the system only runs when both are changed on the same run\n            world.get_resource_mut::<Bool2>().unwrap().0 = false;\n            world.get_resource_mut::<RunConditionBool>().unwrap().0 = false;\n            schedule.run(&mut world);\n            assert_eq!(world.resource::<Counter>().0.load(Ordering::Relaxed), 2);\n        }\n    }\n\n    mod schedule_build_errors {\n        use super::*;\n\n        #[test]\n        #[should_panic]\n        fn dependency_loop() {\n            let mut schedule = Schedule::default();\n            schedule.configure_sets(TestSet::X.after(TestSet::X));\n        }\n\n        #[test]\n        fn dependency_cycle() {\n            let mut world = World::new();\n            let mut schedule = Schedule::default();\n\n            schedule.configure_sets(TestSet::A.after(TestSet::B));\n            schedule.configure_sets(TestSet::B.after(TestSet::A));\n\n            let result = schedule.initialize(&mut world);\n            assert!(matches!(\n                result,\n                Err(ScheduleBuildError::DependencyCycle(_))\n            ));\n\n            fn foo() {}\n            fn bar() {}\n\n            let mut world = World::new();\n            let mut schedule = Schedule::default();\n\n            schedule.add_systems((foo.after(bar), bar.after(foo)));\n            let result = schedule.initialize(&mut world);\n            assert!(matches!(\n                result,\n                Err(ScheduleBuildError::DependencyCycle(_))\n            ));\n        }\n\n        #[test]\n        #[should_panic]\n        fn hierarchy_loop() {\n            let mut schedule = Schedule::default();\n            schedule.configure_sets(TestSet::X.in_set(TestSet::X));\n        }\n\n        #[test]\n        fn hierarchy_cycle() {\n            let mut world = World::new();\n            let mut schedule = Schedule::default();\n\n            schedule.configure_sets(TestSet::A.in_set(TestSet::B));\n            schedule.configure_sets(TestSet::B.in_set(TestSet::A));\n\n            let result = schedule.initialize(&mut world);\n            assert!(matches!(result, Err(ScheduleBuildError::HierarchyCycle(_))));\n        }\n\n        #[test]\n        fn system_type_set_ambiguity() {\n            // Define some systems.\n            fn foo() {}\n            fn bar() {}\n\n            let mut world = World::new();\n            let mut schedule = Schedule::default();\n\n            // Schedule `bar` to run after `foo`.\n            schedule.add_systems((foo, bar.after(foo)));\n\n            // There's only one `foo`, so it's fine.\n            let result = schedule.initialize(&mut world);\n            assert!(result.is_ok());\n\n            // Schedule another `foo`.\n            schedule.add_systems(foo);\n\n            // When there are multiple instances of `foo`, dependencies on\n            // `foo` are no longer allowed. Too much ambiguity.\n            let result = schedule.initialize(&mut world);\n            assert!(matches!(\n                result,\n                Err(ScheduleBuildError::SystemTypeSetAmbiguity(_))\n            ));\n\n            // same goes for `ambiguous_with`\n            let mut schedule = Schedule::default();\n            schedule.add_systems(foo);\n            schedule.add_systems(bar.ambiguous_with(foo));\n            let result = schedule.initialize(&mut world);\n            assert!(result.is_ok());\n            schedule.add_systems(foo);\n            let result = schedule.initialize(&mut world);\n            assert!(matches!(\n                result,\n                Err(ScheduleBuildError::SystemTypeSetAmbiguity(_))\n            ));\n        }\n\n        #[test]\n        #[should_panic]\n        fn configure_system_type_set() {\n            fn foo() {}\n            let mut schedule = Schedule::default();\n            schedule.configure_sets(foo.into_system_set());\n        }\n\n        #[test]\n        fn hierarchy_redundancy() {\n            let mut world = World::new();\n            let mut schedule = Schedule::default();\n\n            schedule.set_build_settings(ScheduleBuildSettings {\n                hierarchy_detection: LogLevel::Error,\n                ..Default::default()\n            });\n\n            // Add `A`.\n            schedule.configure_sets(TestSet::A);\n\n            // Add `B` as child of `A`.\n            schedule.configure_sets(TestSet::B.in_set(TestSet::A));\n\n            // Add `X` as child of both `A` and `B`.\n            schedule.configure_sets(TestSet::X.in_set(TestSet::A).in_set(TestSet::B));\n\n            // `X` cannot be the `A`'s child and grandchild at the same time.\n            let result = schedule.initialize(&mut world);\n            assert!(matches!(\n                result,\n                Err(ScheduleBuildError::HierarchyRedundancy(_))\n            ));\n        }\n\n        #[test]\n        fn cross_dependency() {\n            let mut world = World::new();\n            let mut schedule = Schedule::default();\n\n            // Add `B` and give it both kinds of relationships with `A`.\n            schedule.configure_sets(TestSet::B.in_set(TestSet::A));\n            schedule.configure_sets(TestSet::B.after(TestSet::A));\n            let result = schedule.initialize(&mut world);\n            assert!(matches!(\n                result,\n                Err(ScheduleBuildError::CrossDependency(_, _))\n            ));\n        }\n\n        #[test]\n        fn sets_have_order_but_intersect() {\n            let mut world = World::new();\n            let mut schedule = Schedule::default();\n\n            fn foo() {}\n\n            // Add `foo` to both `A` and `C`.\n            schedule.add_systems(foo.in_set(TestSet::A).in_set(TestSet::C));\n\n            // Order `A -> B -> C`.\n            schedule.configure_sets((\n                TestSet::A,\n                TestSet::B.after(TestSet::A),\n                TestSet::C.after(TestSet::B),\n            ));\n\n            let result = schedule.initialize(&mut world);\n            // `foo` can't be in both `A` and `C` because they can't run at the same time.\n            assert!(matches!(\n                result,\n                Err(ScheduleBuildError::SetsHaveOrderButIntersect(_, _))\n            ));\n        }\n\n        #[test]\n        fn ambiguity() {\n            #[derive(Resource)]\n            struct X;\n\n            fn res_ref(_x: Res<X>) {}\n            fn res_mut(_x: ResMut<X>) {}\n\n            let mut world = World::new();\n            let mut schedule = Schedule::default();\n\n            schedule.set_build_settings(ScheduleBuildSettings {\n                ambiguity_detection: LogLevel::Error,\n                ..Default::default()\n            });\n\n            schedule.add_systems((res_ref, res_mut));\n            let result = schedule.initialize(&mut world);\n            assert!(matches!(result, Err(ScheduleBuildError::Ambiguity(_))));\n        }\n    }\n\n    mod system_ambiguity {\n        use alloc::collections::BTreeSet;\n\n        use super::*;\n        // Required to make the derive macro behave\n        use crate as bevy_ecs;\n        use crate::prelude::*;\n\n        #[derive(Resource)]\n        struct R;\n\n        #[derive(Component)]\n        struct A;\n\n        #[derive(Component)]\n        struct B;\n\n        // An event type\n        #[derive(Event)]\n        struct E;\n\n        #[derive(Resource, Component)]\n        struct RC;\n\n        fn empty_system() {}\n        fn res_system(_res: Res<R>) {}\n        fn resmut_system(_res: ResMut<R>) {}\n        fn nonsend_system(_ns: NonSend<R>) {}\n        fn nonsendmut_system(_ns: NonSendMut<R>) {}\n        fn read_component_system(_query: Query<&A>) {}\n        fn write_component_system(_query: Query<&mut A>) {}\n        fn with_filtered_component_system(_query: Query<&mut A, With<B>>) {}\n        fn without_filtered_component_system(_query: Query<&mut A, Without<B>>) {}\n        fn entity_ref_system(_query: Query<EntityRef>) {}\n        fn entity_mut_system(_query: Query<EntityMut>) {}\n        fn event_reader_system(_reader: EventReader<E>) {}\n        fn event_writer_system(_writer: EventWriter<E>) {}\n        fn event_resource_system(_events: ResMut<Events<E>>) {}\n        fn read_world_system(_world: &World) {}\n        fn write_world_system(_world: &mut World) {}\n\n        // Tests for conflict detection\n\n        #[test]\n        fn one_of_everything() {\n            let mut world = World::new();\n            world.insert_resource(R);\n            world.spawn(A);\n            world.init_resource::<Events<E>>();\n\n            let mut schedule = Schedule::default();\n            schedule\n                // nonsendmut system deliberately conflicts with resmut system\n                .add_systems((resmut_system, write_component_system, event_writer_system));\n\n            let _ = schedule.initialize(&mut world);\n\n            assert_eq!(schedule.graph().conflicting_systems().len(), 0);\n        }\n\n        #[test]\n        fn read_only() {\n            let mut world = World::new();\n            world.insert_resource(R);\n            world.spawn(A);\n            world.init_resource::<Events<E>>();\n\n            let mut schedule = Schedule::default();\n            schedule.add_systems((\n                empty_system,\n                empty_system,\n                res_system,\n                res_system,\n                nonsend_system,\n                nonsend_system,\n                read_component_system,\n                read_component_system,\n                entity_ref_system,\n                entity_ref_system,\n                event_reader_system,\n                event_reader_system,\n                read_world_system,\n                read_world_system,\n            ));\n\n            let _ = schedule.initialize(&mut world);\n\n            assert_eq!(schedule.graph().conflicting_systems().len(), 0);\n        }\n\n        #[test]\n        fn read_world() {\n            let mut world = World::new();\n            world.insert_resource(R);\n            world.spawn(A);\n            world.init_resource::<Events<E>>();\n\n            let mut schedule = Schedule::default();\n            schedule.add_systems((\n                resmut_system,\n                write_component_system,\n                event_writer_system,\n                read_world_system,\n            ));\n\n            let _ = schedule.initialize(&mut world);\n\n            assert_eq!(schedule.graph().conflicting_systems().len(), 3);\n        }\n\n        #[test]\n        fn resources() {\n            let mut world = World::new();\n            world.insert_resource(R);\n\n            let mut schedule = Schedule::default();\n            schedule.add_systems((resmut_system, res_system));\n\n            let _ = schedule.initialize(&mut world);\n\n            assert_eq!(schedule.graph().conflicting_systems().len(), 1);\n        }\n\n        #[test]\n        fn nonsend() {\n            let mut world = World::new();\n            world.insert_resource(R);\n\n            let mut schedule = Schedule::default();\n            schedule.add_systems((nonsendmut_system, nonsend_system));\n\n            let _ = schedule.initialize(&mut world);\n\n            assert_eq!(schedule.graph().conflicting_systems().len(), 1);\n        }\n\n        #[test]\n        fn components() {\n            let mut world = World::new();\n            world.spawn(A);\n\n            let mut schedule = Schedule::default();\n            schedule.add_systems((read_component_system, write_component_system));\n\n            let _ = schedule.initialize(&mut world);\n\n            assert_eq!(schedule.graph().conflicting_systems().len(), 1);\n        }\n\n        #[test]\n        #[ignore = \"Known failing but fix is non-trivial: https://github.com/bevyengine/bevy/issues/4381\"]\n        fn filtered_components() {\n            let mut world = World::new();\n            world.spawn(A);\n\n            let mut schedule = Schedule::default();\n            schedule.add_systems((\n                with_filtered_component_system,\n                without_filtered_component_system,\n            ));\n\n            let _ = schedule.initialize(&mut world);\n\n            assert_eq!(schedule.graph().conflicting_systems().len(), 0);\n        }\n\n        #[test]\n        fn events() {\n            let mut world = World::new();\n            world.init_resource::<Events<E>>();\n\n            let mut schedule = Schedule::default();\n            schedule.add_systems((\n                // All of these systems clash\n                event_reader_system,\n                event_writer_system,\n                event_resource_system,\n            ));\n\n            let _ = schedule.initialize(&mut world);\n\n            assert_eq!(schedule.graph().conflicting_systems().len(), 3);\n        }\n\n        /// Test that when a struct is both a Resource and a Component, they do not\n        /// conflict with each other.\n        #[test]\n        fn shared_resource_mut_component() {\n            let mut world = World::new();\n            world.insert_resource(RC);\n\n            let mut schedule = Schedule::default();\n            schedule.add_systems((|_: ResMut<RC>| {}, |_: Query<&mut RC>| {}));\n\n            let _ = schedule.initialize(&mut world);\n\n            assert_eq!(schedule.graph().conflicting_systems().len(), 0);\n        }\n\n        #[test]\n        fn resource_mut_and_entity_ref() {\n            let mut world = World::new();\n            world.insert_resource(R);\n\n            let mut schedule = Schedule::default();\n            schedule.add_systems((resmut_system, entity_ref_system));\n\n            let _ = schedule.initialize(&mut world);\n\n            assert_eq!(schedule.graph().conflicting_systems().len(), 0);\n        }\n\n        #[test]\n        fn resource_and_entity_mut() {\n            let mut world = World::new();\n            world.insert_resource(R);\n\n            let mut schedule = Schedule::default();\n            schedule.add_systems((res_system, nonsend_system, entity_mut_system));\n\n            let _ = schedule.initialize(&mut world);\n\n            assert_eq!(schedule.graph().conflicting_systems().len(), 0);\n        }\n\n        #[test]\n        fn write_component_and_entity_ref() {\n            let mut world = World::new();\n            world.insert_resource(R);\n\n            let mut schedule = Schedule::default();\n            schedule.add_systems((write_component_system, entity_ref_system));\n\n            let _ = schedule.initialize(&mut world);\n\n            assert_eq!(schedule.graph().conflicting_systems().len(), 1);\n        }\n\n        #[test]\n        fn read_component_and_entity_mut() {\n            let mut world = World::new();\n            world.insert_resource(R);\n\n            let mut schedule = Schedule::default();\n            schedule.add_systems((read_component_system, entity_mut_system));\n\n            let _ = schedule.initialize(&mut world);\n\n            assert_eq!(schedule.graph().conflicting_systems().len(), 1);\n        }\n\n        #[test]\n        fn exclusive() {\n            let mut world = World::new();\n            world.insert_resource(R);\n            world.spawn(A);\n            world.init_resource::<Events<E>>();\n\n            let mut schedule = Schedule::default();\n            schedule.add_systems((\n                // All 3 of these conflict with each other\n                write_world_system,\n                write_world_system,\n                res_system,\n            ));\n\n            let _ = schedule.initialize(&mut world);\n\n            assert_eq!(schedule.graph().conflicting_systems().len(), 3);\n        }\n\n        // Tests for silencing and resolving ambiguities\n        #[test]\n        fn before_and_after() {\n            let mut world = World::new();\n            world.init_resource::<Events<E>>();\n\n            let mut schedule = Schedule::default();\n            schedule.add_systems((\n                event_reader_system.before(event_writer_system),\n                event_writer_system,\n                event_resource_system.after(event_writer_system),\n            ));\n\n            let _ = schedule.initialize(&mut world);\n\n            assert_eq!(schedule.graph().conflicting_systems().len(), 0);\n        }\n\n        #[test]\n        fn ignore_all_ambiguities() {\n            let mut world = World::new();\n            world.insert_resource(R);\n\n            let mut schedule = Schedule::default();\n            schedule.add_systems((\n                resmut_system.ambiguous_with_all(),\n                res_system,\n                nonsend_system,\n            ));\n\n            let _ = schedule.initialize(&mut world);\n\n            assert_eq!(schedule.graph().conflicting_systems().len(), 0);\n        }\n\n        #[test]\n        fn ambiguous_with_label() {\n            let mut world = World::new();\n            world.insert_resource(R);\n\n            #[derive(SystemSet, Hash, PartialEq, Eq, Debug, Clone)]\n            struct IgnoreMe;\n\n            let mut schedule = Schedule::default();\n            schedule.add_systems((\n                resmut_system.ambiguous_with(IgnoreMe),\n                res_system.in_set(IgnoreMe),\n                nonsend_system.in_set(IgnoreMe),\n            ));\n\n            let _ = schedule.initialize(&mut world);\n\n            assert_eq!(schedule.graph().conflicting_systems().len(), 0);\n        }\n\n        #[test]\n        fn ambiguous_with_system() {\n            let mut world = World::new();\n\n            let mut schedule = Schedule::default();\n            schedule.add_systems((\n                write_component_system.ambiguous_with(read_component_system),\n                read_component_system,\n            ));\n            let _ = schedule.initialize(&mut world);\n\n            assert_eq!(schedule.graph().conflicting_systems().len(), 0);\n        }\n\n        #[derive(ScheduleLabel, Hash, PartialEq, Eq, Debug, Clone)]\n        struct TestSchedule;\n\n        // Tests that the correct ambiguities were reported in the correct order.\n        #[test]\n        fn correct_ambiguities() {\n            fn system_a(_res: ResMut<R>) {}\n            fn system_b(_res: ResMut<R>) {}\n            fn system_c(_res: ResMut<R>) {}\n            fn system_d(_res: ResMut<R>) {}\n            fn system_e(_res: ResMut<R>) {}\n\n            let mut world = World::new();\n            world.insert_resource(R);\n\n            let mut schedule = Schedule::new(TestSchedule);\n            schedule.add_systems((\n                system_a,\n                system_b,\n                system_c.ambiguous_with_all(),\n                system_d.ambiguous_with(system_b),\n                system_e.after(system_a),\n            ));\n\n            schedule.graph_mut().initialize(&mut world);\n            let _ = schedule.graph_mut().build_schedule(\n                world.components(),\n                TestSchedule.intern(),\n                &BTreeSet::new(),\n            );\n\n            let ambiguities: Vec<_> = schedule\n                .graph()\n                .conflicts_to_string(schedule.graph().conflicting_systems(), world.components())\n                .collect();\n\n            let expected = &[\n                (\n                    \"system_d\".to_string(),\n                    \"system_a\".to_string(),\n                    vec![\"bevy_ecs::schedule::tests::system_ambiguity::R\"],\n                ),\n                (\n                    \"system_d\".to_string(),\n                    \"system_e\".to_string(),\n                    vec![\"bevy_ecs::schedule::tests::system_ambiguity::R\"],\n                ),\n                (\n                    \"system_b\".to_string(),\n                    \"system_a\".to_string(),\n                    vec![\"bevy_ecs::schedule::tests::system_ambiguity::R\"],\n                ),\n                (\n                    \"system_b\".to_string(),\n                    \"system_e\".to_string(),\n                    vec![\"bevy_ecs::schedule::tests::system_ambiguity::R\"],\n                ),\n            ];\n\n            // ordering isn't stable so do this\n            for entry in expected {\n                assert!(ambiguities.contains(entry));\n            }\n        }\n\n        // Test that anonymous set names work properly\n        // Related issue https://github.com/bevyengine/bevy/issues/9641\n        #[test]\n        fn anonymous_set_name() {\n            let mut schedule = Schedule::new(TestSchedule);\n            schedule.add_systems((resmut_system, resmut_system).run_if(|| true));\n\n            let mut world = World::new();\n            schedule.graph_mut().initialize(&mut world);\n            let _ = schedule.graph_mut().build_schedule(\n                world.components(),\n                TestSchedule.intern(),\n                &BTreeSet::new(),\n            );\n\n            let ambiguities: Vec<_> = schedule\n                .graph()\n                .conflicts_to_string(schedule.graph().conflicting_systems(), world.components())\n                .collect();\n\n            assert_eq!(\n                ambiguities[0],\n                (\n                    \"resmut_system (in set (resmut_system, resmut_system))\".to_string(),\n                    \"resmut_system (in set (resmut_system, resmut_system))\".to_string(),\n                    vec![\"bevy_ecs::schedule::tests::system_ambiguity::R\"],\n                )\n            );\n        }\n\n        #[test]\n        fn ignore_component_resource_ambiguities() {\n            let mut world = World::new();\n            world.insert_resource(R);\n            world.allow_ambiguous_resource::<R>();\n            let mut schedule = Schedule::new(TestSchedule);\n\n            // check resource\n            schedule.add_systems((resmut_system, res_system));\n            schedule.initialize(&mut world).unwrap();\n            assert!(schedule.graph().conflicting_systems().is_empty());\n\n            // check components\n            world.allow_ambiguous_component::<A>();\n            schedule.add_systems((write_component_system, read_component_system));\n            schedule.initialize(&mut world).unwrap();\n            assert!(schedule.graph().conflicting_systems().is_empty());\n        }\n    }\n\n    #[cfg(feature = \"bevy_debug_stepping\")]\n    mod stepping {\n        use super::*;\n        use bevy_ecs::system::SystemState;\n\n        #[derive(ScheduleLabel, Clone, Debug, PartialEq, Eq, Hash)]\n        pub struct TestSchedule;\n\n        macro_rules! assert_executor_supports_stepping {\n            ($executor:expr) => {\n                // create a test schedule\n                let mut schedule = Schedule::new(TestSchedule);\n                schedule\n                    .set_executor_kind($executor)\n                    .add_systems(|| panic!(\"Executor ignored Stepping\"));\n\n                // Add our schedule to stepping & and enable stepping; this should\n                // prevent any systems in the schedule from running\n                let mut stepping = Stepping::default();\n                stepping.add_schedule(TestSchedule).enable();\n\n                // create a world, and add the stepping resource\n                let mut world = World::default();\n                world.insert_resource(stepping);\n\n                // start a new frame by running ihe begin_frame() system\n                let mut system_state: SystemState<Option<ResMut<Stepping>>> =\n                    SystemState::new(&mut world);\n                let res = system_state.get_mut(&mut world);\n                Stepping::begin_frame(res);\n\n                // now run the schedule; this will panic if the executor doesn't\n                // handle stepping\n                schedule.run(&mut world);\n            };\n        }\n\n        /// verify the [`SimpleExecutor`] supports stepping\n        #[test]\n        fn simple_executor() {\n            assert_executor_supports_stepping!(ExecutorKind::Simple);\n        }\n\n        /// verify the [`SingleThreadedExecutor`] supports stepping\n        #[test]\n        fn single_threaded_executor() {\n            assert_executor_supports_stepping!(ExecutorKind::SingleThreaded);\n        }\n\n        /// verify the [`MultiThreadedExecutor`] supports stepping\n        #[test]\n        fn multi_threaded_executor() {\n            assert_executor_supports_stepping!(ExecutorKind::MultiThreaded);\n        }\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "d148707cc26155bcc15b6a8933cf2f2607d3127c",
    "func": "#[macro_use]\nextern crate diesel;\n\n#[derive(QueryableByName)]\nstruct Foo {\n    foo: i32,\n    bar: String,\n}\n\n#[derive(QueryableByName)]\nstruct Bar(i32, String);\n\nfn main() {}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "43101ec7f5f28c3c702c502f8bb3dac491115827",
    "func": "mod parallel_scope;\n\nuse core::{marker::PhantomData, panic::Location};\n\nuse super::{\n    Deferred, IntoObserverSystem, IntoSystem, RegisterSystem, Resource, RunSystemCachedWith,\n};\nuse crate::{\n    self as bevy_ecs,\n    bundle::{Bundle, InsertMode},\n    change_detection::Mut,\n    component::{Component, ComponentId, ComponentInfo},\n    entity::{Entities, Entity},\n    event::{Event, SendEvent},\n    observer::{Observer, TriggerEvent, TriggerTargets},\n    system::{input::SystemInput, RunSystemWithInput, SystemId},\n    world::{\n        command_queue::RawCommandQueue, unsafe_world_cell::UnsafeWorldCell, Command, CommandQueue,\n        EntityWorldMut, FromWorld, SpawnBatchIter, World,\n    },\n};\nuse bevy_ptr::OwningPtr;\nuse bevy_utils::tracing::{error, info};\npub use parallel_scope::*;\n\n/// A [`Command`] queue to perform structural changes to the [`World`].\n///\n/// Since each command requires exclusive access to the `World`,\n/// all queued commands are automatically applied in sequence\n/// when the `apply_deferred` system runs (see [`apply_deferred`] documentation for more details).\n///\n/// Each command can be used to modify the [`World`] in arbitrary ways:\n/// * spawning or despawning entities\n/// * inserting components on new or existing entities\n/// * inserting resources\n/// * etc.\n///\n/// For a version of [`Commands`] that works in parallel contexts (such as\n/// within [`Query::par_iter`](crate::system::Query::par_iter)) see\n/// [`ParallelCommands`]\n///\n/// # Usage\n///\n/// Add `mut commands: Commands` as a function argument to your system to get a copy of this struct that will be applied the next time a copy of [`apply_deferred`] runs.\n/// Commands are almost always used as a [`SystemParam`](crate::system::SystemParam).\n///\n/// ```\n/// # use bevy_ecs::prelude::*;\n/// #\n/// fn my_system(mut commands: Commands) {\n///    // ...\n/// }\n/// # bevy_ecs::system::assert_is_system(my_system);\n/// ```\n///\n/// # Implementing\n///\n/// Each built-in command is implemented as a separate method, e.g. [`Commands::spawn`].\n/// In addition to the pre-defined command methods, you can add commands with any arbitrary\n/// behavior using [`Commands::queue`], which accepts any type implementing [`Command`].\n///\n/// Since closures and other functions implement this trait automatically, this allows one-shot,\n/// anonymous custom commands.\n///\n/// ```\n/// # use bevy_ecs::prelude::*;\n/// # fn foo(mut commands: Commands) {\n/// // NOTE: type inference fails here, so annotations are required on the closure.\n/// commands.queue(|w: &mut World| {\n///     // Mutate the world however you want...\n///     # todo!();\n/// });\n/// # }\n/// ```\n///\n/// [`apply_deferred`]: crate::schedule::apply_deferred\npub struct Commands<'w, 's> {\n    queue: InternalQueue<'s>,\n    entities: &'w Entities,\n}\n\n// SAFETY: All commands [`Command`] implement [`Send`]\nunsafe impl Send for Commands<'_, '_> {}\n\n// SAFETY: `Commands` never gives access to the inner commands.\nunsafe impl Sync for Commands<'_, '_> {}\n\nconst _: () = {\n    type __StructFieldsAlias<'w, 's> = (Deferred<'s, CommandQueue>, &'w Entities);\n    #[doc(hidden)]\n    pub struct FetchState {\n        state: <__StructFieldsAlias<'static, 'static> as bevy_ecs::system::SystemParam>::State,\n    }\n    // SAFETY: Only reads Entities\n    unsafe impl bevy_ecs::system::SystemParam for Commands<'_, '_> {\n        type State = FetchState;\n\n        type Item<'w, 's> = Commands<'w, 's>;\n\n        fn init_state(\n            world: &mut World,\n            system_meta: &mut bevy_ecs::system::SystemMeta,\n        ) -> Self::State {\n            FetchState {\n                state: <__StructFieldsAlias<'_, '_> as bevy_ecs::system::SystemParam>::init_state(\n                    world,\n                    system_meta,\n                ),\n            }\n        }\n\n        unsafe fn new_archetype(\n            state: &mut Self::State,\n            archetype: &bevy_ecs::archetype::Archetype,\n            system_meta: &mut bevy_ecs::system::SystemMeta,\n        ) {\n            // SAFETY: Caller guarantees the archetype is from the world used in `init_state`\n            unsafe {\n                <__StructFieldsAlias<'_, '_> as bevy_ecs::system::SystemParam>::new_archetype(\n                    &mut state.state,\n                    archetype,\n                    system_meta,\n                );\n            };\n        }\n\n        fn apply(\n            state: &mut Self::State,\n            system_meta: &bevy_ecs::system::SystemMeta,\n            world: &mut World,\n        ) {\n            <__StructFieldsAlias<'_, '_> as bevy_ecs::system::SystemParam>::apply(\n                &mut state.state,\n                system_meta,\n                world,\n            );\n        }\n\n        fn queue(\n            state: &mut Self::State,\n            system_meta: &bevy_ecs::system::SystemMeta,\n            world: bevy_ecs::world::DeferredWorld,\n        ) {\n            <__StructFieldsAlias<'_, '_> as bevy_ecs::system::SystemParam>::queue(\n                &mut state.state,\n                system_meta,\n                world,\n            );\n        }\n\n        #[inline]\n        unsafe fn validate_param(\n            state: &Self::State,\n            system_meta: &bevy_ecs::system::SystemMeta,\n            world: UnsafeWorldCell,\n        ) -> bool {\n            <(Deferred<CommandQueue>, &Entities) as bevy_ecs::system::SystemParam>::validate_param(\n                &state.state,\n                system_meta,\n                world,\n            )\n        }\n\n        #[inline]\n        unsafe fn get_param<'w, 's>(\n            state: &'s mut Self::State,\n            system_meta: &bevy_ecs::system::SystemMeta,\n            world: UnsafeWorldCell<'w>,\n            change_tick: bevy_ecs::component::Tick,\n        ) -> Self::Item<'w, 's> {\n            let(f0, f1) =  <(Deferred<'s, CommandQueue>, &'w Entities) as bevy_ecs::system::SystemParam>::get_param(&mut state.state, system_meta, world, change_tick);\n            Commands {\n                queue: InternalQueue::CommandQueue(f0),\n                entities: f1,\n            }\n        }\n    }\n    // SAFETY: Only reads Entities\n    unsafe impl<'w, 's> bevy_ecs::system::ReadOnlySystemParam for Commands<'w, 's>\n    where\n        Deferred<'s, CommandQueue>: bevy_ecs::system::ReadOnlySystemParam,\n        &'w Entities: bevy_ecs::system::ReadOnlySystemParam,\n    {\n    }\n};\n\nenum InternalQueue<'s> {\n    CommandQueue(Deferred<'s, CommandQueue>),\n    RawCommandQueue(RawCommandQueue),\n}\n\nimpl<'w, 's> Commands<'w, 's> {\n    /// Returns a new `Commands` instance from a [`CommandQueue`] and a [`World`].\n    ///\n    /// It is not required to call this constructor when using `Commands` as a [system parameter].\n    ///\n    /// [system parameter]: crate::system::SystemParam\n    pub fn new(queue: &'s mut CommandQueue, world: &'w World) -> Self {\n        Self::new_from_entities(queue, &world.entities)\n    }\n\n    /// Returns a new `Commands` instance from a [`CommandQueue`] and an [`Entities`] reference.\n    ///\n    /// It is not required to call this constructor when using `Commands` as a [system parameter].\n    ///\n    /// [system parameter]: crate::system::SystemParam\n    pub fn new_from_entities(queue: &'s mut CommandQueue, entities: &'w Entities) -> Self {\n        Self {\n            queue: InternalQueue::CommandQueue(Deferred(queue)),\n            entities,\n        }\n    }\n\n    /// Returns a new `Commands` instance from a [`RawCommandQueue`] and an [`Entities`] reference.\n    ///\n    /// This is used when constructing [`Commands`] from a [`DeferredWorld`](crate::world::DeferredWorld).\n    ///\n    /// # Safety\n    ///\n    /// * Caller ensures that `queue` must outlive 'w\n    pub(crate) unsafe fn new_raw_from_entities(\n        queue: RawCommandQueue,\n        entities: &'w Entities,\n    ) -> Self {\n        Self {\n            queue: InternalQueue::RawCommandQueue(queue),\n            entities,\n        }\n    }\n\n    /// Returns a [`Commands`] with a smaller lifetime.\n    /// This is useful if you have `&mut Commands` but need `Commands`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use bevy_ecs::prelude::*;\n    /// fn my_system(mut commands: Commands) {\n    ///     // We do our initialization in a separate function,\n    ///     // which expects an owned `Commands`.\n    ///     do_initialization(commands.reborrow());\n    ///\n    ///     // Since we only reborrowed the commands instead of moving them, we can still use them.\n    ///     commands.spawn_empty();\n    /// }\n    /// #\n    /// # fn do_initialization(_: Commands) {}\n    /// ```\n    pub fn reborrow(&mut self) -> Commands<'w, '_> {\n        Commands {\n            queue: match &mut self.queue {\n                InternalQueue::CommandQueue(queue) => InternalQueue::CommandQueue(queue.reborrow()),\n                InternalQueue::RawCommandQueue(queue) => {\n                    InternalQueue::RawCommandQueue(queue.clone())\n                }\n            },\n            entities: self.entities,\n        }\n    }\n\n    /// Take all commands from `other` and append them to `self`, leaving `other` empty\n    pub fn append(&mut self, other: &mut CommandQueue) {\n        match &mut self.queue {\n            InternalQueue::CommandQueue(queue) => queue.bytes.append(&mut other.bytes),\n            InternalQueue::RawCommandQueue(queue) => {\n                // SAFETY: Pointers in `RawCommandQueue` are never null\n                unsafe { queue.bytes.as_mut() }.append(&mut other.bytes);\n            }\n        }\n    }\n\n    /// Reserves a new empty [`Entity`] to be spawned, and returns its corresponding [`EntityCommands`].\n    ///\n    /// See [`World::spawn_empty`] for more details.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use bevy_ecs::prelude::*;\n    ///\n    /// #[derive(Component)]\n    /// struct Label(&'static str);\n    /// #[derive(Component)]\n    /// struct Strength(u32);\n    /// #[derive(Component)]\n    /// struct Agility(u32);\n    ///\n    /// fn example_system(mut commands: Commands) {\n    ///     // Create a new empty entity and retrieve its id.\n    ///     let empty_entity = commands.spawn_empty().id();\n    ///\n    ///     // Create another empty entity, then add some component to it\n    ///     commands.spawn_empty()\n    ///         // adds a new component bundle to the entity\n    ///         .insert((Strength(1), Agility(2)))\n    ///         // adds a single component to the entity\n    ///         .insert(Label(\"hello world\"));\n    /// }\n    /// # bevy_ecs::system::assert_is_system(example_system);\n    /// ```\n    ///\n    /// # See also\n    ///\n    /// - [`spawn`](Self::spawn) to spawn an entity with a bundle.\n    /// - [`spawn_batch`](Self::spawn_batch) to spawn entities with a bundle each.\n    pub fn spawn_empty(&mut self) -> EntityCommands {\n        let entity = self.entities.reserve_entity();\n        EntityCommands {\n            entity,\n            commands: self.reborrow(),\n        }\n    }\n\n    /// Pushes a [`Command`] to the queue for creating a new [`Entity`] if the given one does not exists,\n    /// and returns its corresponding [`EntityCommands`].\n    ///\n    /// This method silently fails by returning [`EntityCommands`]\n    /// even if the given `Entity` cannot be spawned.\n    ///\n    /// See [`World::get_or_spawn`] for more details.\n    ///\n    /// # Note\n    ///\n    /// Spawning a specific `entity` value is rarely the right choice. Most apps should favor\n    /// [`Commands::spawn`]. This method should generally only be used for sharing entities across\n    /// apps, and only when they have a scheme worked out to share an ID space (which doesn't happen\n    /// by default).\n    #[deprecated(since = \"0.15.0\", note = \"use Commands::spawn instead\")]\n    pub fn get_or_spawn(&mut self, entity: Entity) -> EntityCommands {\n        self.queue(move |world: &mut World| {\n            #[allow(deprecated)]\n            world.get_or_spawn(entity);\n        });\n        EntityCommands {\n            entity,\n            commands: self.reborrow(),\n        }\n    }\n\n    /// Pushes a [`Command`] to the queue for creating a new entity with the given [`Bundle`]'s components,\n    /// and returns its corresponding [`EntityCommands`].\n    ///\n    /// In case multiple bundles of the same [`Bundle`] type need to be spawned,\n    /// [`spawn_batch`](Self::spawn_batch) should be used for better performance.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bevy_ecs::prelude::*;\n    ///\n    /// #[derive(Component)]\n    /// struct Component1;\n    /// #[derive(Component)]\n    /// struct Component2;\n    /// #[derive(Component)]\n    /// struct Label(&'static str);\n    /// #[derive(Component)]\n    /// struct Strength(u32);\n    /// #[derive(Component)]\n    /// struct Agility(u32);\n    ///\n    /// #[derive(Bundle)]\n    /// struct ExampleBundle {\n    ///     a: Component1,\n    ///     b: Component2,\n    /// }\n    ///\n    /// fn example_system(mut commands: Commands) {\n    ///     // Create a new entity with a single component.\n    ///     commands.spawn(Component1);\n    ///\n    ///     // Create a new entity with a component bundle.\n    ///     commands.spawn(ExampleBundle {\n    ///         a: Component1,\n    ///         b: Component2,\n    ///     });\n    ///\n    ///     commands\n    ///         // Create a new entity with two components using a \"tuple bundle\".\n    ///         .spawn((Component1, Component2))\n    ///         // `spawn returns a builder, so you can insert more bundles like this:\n    ///         .insert((Strength(1), Agility(2)))\n    ///         // or insert single components like this:\n    ///         .insert(Label(\"hello world\"));\n    /// }\n    /// # bevy_ecs::system::assert_is_system(example_system);\n    /// ```\n    ///\n    /// # See also\n    ///\n    /// - [`spawn_empty`](Self::spawn_empty) to spawn an entity without any components.\n    /// - [`spawn_batch`](Self::spawn_batch) to spawn entities with a bundle each.\n    #[track_caller]\n    pub fn spawn<T: Bundle>(&mut self, bundle: T) -> EntityCommands {\n        let mut entity = self.spawn_empty();\n        entity.insert(bundle);\n        entity\n    }\n\n    /// Returns the [`EntityCommands`] for the requested [`Entity`].\n    ///\n    /// # Panics\n    ///\n    /// This method panics if the requested entity does not exist.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bevy_ecs::prelude::*;\n    ///\n    /// #[derive(Component)]\n    /// struct Label(&'static str);\n    /// #[derive(Component)]\n    /// struct Strength(u32);\n    /// #[derive(Component)]\n    /// struct Agility(u32);\n    ///\n    /// fn example_system(mut commands: Commands) {\n    ///     // Create a new, empty entity\n    ///     let entity = commands.spawn_empty().id();\n    ///\n    ///     commands.entity(entity)\n    ///         // adds a new component bundle to the entity\n    ///         .insert((Strength(1), Agility(2)))\n    ///         // adds a single component to the entity\n    ///         .insert(Label(\"hello world\"));\n    /// }\n    /// # bevy_ecs::system::assert_is_system(example_system);\n    /// ```\n    ///\n    /// # See also\n    ///\n    /// - [`get_entity`](Self::get_entity) for the fallible version.\n    #[inline]\n    #[track_caller]\n    pub fn entity(&mut self, entity: Entity) -> EntityCommands {\n        #[inline(never)]\n        #[cold]\n        #[track_caller]\n        fn panic_no_entity(entity: Entity) -> ! {\n            panic!(\n                \"Attempting to create an EntityCommands for entity {entity:?}, which doesn't exist.\",\n            );\n        }\n\n        match self.get_entity(entity) {\n            Some(entity) => entity,\n            None => panic_no_entity(entity),\n        }\n    }\n\n    /// Returns the [`EntityCommands`] for the requested [`Entity`], if it exists.\n    ///\n    /// Returns `None` if the entity does not exist.\n    ///\n    /// This method does not guarantee that `EntityCommands` will be successfully applied,\n    /// since another command in the queue may delete the entity before them.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bevy_ecs::prelude::*;\n    ///\n    /// #[derive(Component)]\n    /// struct Label(&'static str);\n    /// fn example_system(mut commands: Commands) {\n    ///     // Create a new, empty entity\n    ///     let entity = commands.spawn_empty().id();\n    ///\n    ///     // Get the entity if it still exists, which it will in this case\n    ///     if let Some(mut entity_commands) = commands.get_entity(entity) {\n    ///         // adds a single component to the entity\n    ///         entity_commands.insert(Label(\"hello world\"));\n    ///     }\n    /// }\n    /// # bevy_ecs::system::assert_is_system(example_system);\n    /// ```\n    ///\n    /// # See also\n    ///\n    /// - [`entity`](Self::entity) for the panicking version.\n    #[inline]\n    #[track_caller]\n    pub fn get_entity(&mut self, entity: Entity) -> Option<EntityCommands> {\n        self.entities.contains(entity).then_some(EntityCommands {\n            entity,\n            commands: self.reborrow(),\n        })\n    }\n\n    /// Pushes a [`Command`] to the queue for creating entities with a particular [`Bundle`] type.\n    ///\n    /// `bundles_iter` is a type that can be converted into a [`Bundle`] iterator\n    /// (it can also be a collection).\n    ///\n    /// This method is equivalent to iterating `bundles_iter`\n    /// and calling [`spawn`](Self::spawn) on each bundle,\n    /// but it is faster due to memory pre-allocation.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use bevy_ecs::prelude::*;\n    /// #\n    /// # #[derive(Component)]\n    /// # struct Name(String);\n    /// # #[derive(Component)]\n    /// # struct Score(u32);\n    /// #\n    /// # fn system(mut commands: Commands) {\n    /// commands.spawn_batch(vec![\n    ///     (\n    ///         Name(\"Alice\".to_string()),\n    ///         Score(0),\n    ///     ),\n    ///     (\n    ///         Name(\"Bob\".to_string()),\n    ///         Score(0),\n    ///     ),\n    /// ]);\n    /// # }\n    /// # bevy_ecs::system::assert_is_system(system);\n    /// ```\n    ///\n    /// # See also\n    ///\n    /// - [`spawn`](Self::spawn) to spawn an entity with a bundle.\n    /// - [`spawn_empty`](Self::spawn_empty) to spawn an entity without any components.\n    #[track_caller]\n    pub fn spawn_batch<I>(&mut self, bundles_iter: I)\n    where\n        I: IntoIterator + Send + Sync + 'static,\n        I::Item: Bundle,\n    {\n        self.queue(spawn_batch(bundles_iter));\n    }\n\n    /// Pushes a generic [`Command`] to the command queue.\n    ///\n    /// `command` can be a built-in command, custom struct that implements [`Command`] or a closure\n    /// that takes [`&mut World`](World) as an argument.\n    /// # Example\n    ///\n    /// ```\n    /// # use bevy_ecs::{world::Command, prelude::*};\n    /// #[derive(Resource, Default)]\n    /// struct Counter(u64);\n    ///\n    /// struct AddToCounter(u64);\n    ///\n    /// impl Command for AddToCounter {\n    ///     fn apply(self, world: &mut World) {\n    ///         let mut counter = world.get_resource_or_insert_with(Counter::default);\n    ///         counter.0 += self.0;\n    ///     }\n    /// }\n    ///\n    /// fn add_three_to_counter_system(mut commands: Commands) {\n    ///     commands.queue(AddToCounter(3));\n    /// }\n    /// fn add_twenty_five_to_counter_system(mut commands: Commands) {\n    ///     commands.queue(|world: &mut World| {\n    ///         let mut counter = world.get_resource_or_insert_with(Counter::default);\n    ///         counter.0 += 25;\n    ///     });\n    /// }\n    /// # bevy_ecs::system::assert_is_system(add_three_to_counter_system);\n    /// # bevy_ecs::system::assert_is_system(add_twenty_five_to_counter_system);\n    /// ```\n    pub fn queue<C: Command>(&mut self, command: C) {\n        match &mut self.queue {\n            InternalQueue::CommandQueue(queue) => {\n                queue.push(command);\n            }\n            InternalQueue::RawCommandQueue(queue) => {\n                // SAFETY: `RawCommandQueue` is only every constructed in `Commands::new_raw_from_entities`\n                // where the caller of that has ensured that `queue` outlives `self`\n                unsafe {\n                    queue.push(command);\n                }\n            }\n        }\n    }\n\n    /// Pushes a [`Command`] to the queue for creating entities, if needed,\n    /// and for adding a bundle to each entity.\n    ///\n    /// `bundles_iter` is a type that can be converted into an ([`Entity`], [`Bundle`]) iterator\n    /// (it can also be a collection).\n    ///\n    /// When the command is applied,\n    /// for each (`Entity`, `Bundle`) pair in the given `bundles_iter`,\n    /// the `Entity` is spawned, if it does not exist already.\n    /// Then, the `Bundle` is added to the entity.\n    ///\n    /// This method is equivalent to iterating `bundles_iter`,\n    /// calling [`get_or_spawn`](Self::get_or_spawn) for each bundle,\n    /// and passing it to [`insert`](EntityCommands::insert),\n    /// but it is faster due to memory pre-allocation.\n    ///\n    /// # Note\n    ///\n    /// Spawning a specific `entity` value is rarely the right choice. Most apps should use [`Commands::spawn_batch`].\n    /// This method should generally only be used for sharing entities across apps, and only when they have a scheme\n    /// worked out to share an ID space (which doesn't happen by default).\n    #[track_caller]\n    pub fn insert_or_spawn_batch<I, B>(&mut self, bundles_iter: I)\n    where\n        I: IntoIterator<Item = (Entity, B)> + Send + Sync + 'static,\n        B: Bundle,\n    {\n        self.queue(insert_or_spawn_batch(bundles_iter));\n    }\n\n    /// Pushes a [`Command`] to the queue for adding a [`Bundle`] type to a batch of [`Entities`](Entity).\n    ///\n    /// A batch can be any type that implements [`IntoIterator`] containing `(Entity, Bundle)` tuples,\n    /// such as a [`Vec<(Entity, Bundle)>`] or an array `[(Entity, Bundle); N]`.\n    ///\n    /// When the command is applied, for each `(Entity, Bundle)` pair in the given batch,\n    /// the `Bundle` is added to the `Entity`, overwriting any existing components shared by the `Bundle`.\n    ///\n    /// This method is equivalent to iterating the batch,\n    /// calling [`entity`](Self::entity) for each pair,\n    /// and passing the bundle to [`insert`](EntityCommands::insert),\n    /// but it is faster due to memory pre-allocation.\n    ///\n    /// # Panics\n    ///\n    /// This command panics if any of the given entities do not exist.\n    ///\n    /// For the non-panicking version, see [`try_insert_batch`](Self::try_insert_batch).\n    #[track_caller]\n    pub fn insert_batch<I, B>(&mut self, batch: I)\n    where\n        I: IntoIterator<Item = (Entity, B)> + Send + Sync + 'static,\n        B: Bundle,\n    {\n        self.queue(insert_batch(batch));\n    }\n\n    /// Pushes a [`Command`] to the queue for adding a [`Bundle`] type to a batch of [`Entities`](Entity).\n    ///\n    /// A batch can be any type that implements [`IntoIterator`] containing `(Entity, Bundle)` tuples,\n    /// such as a [`Vec<(Entity, Bundle)>`] or an array `[(Entity, Bundle); N]`.\n    ///\n    /// When the command is applied, for each `(Entity, Bundle)` pair in the given batch,\n    /// the `Bundle` is added to the `Entity`, except for any components already present on the `Entity`.\n    ///\n    /// This method is equivalent to iterating the batch,\n    /// calling [`entity`](Self::entity) for each pair,\n    /// and passing the bundle to [`insert_if_new`](EntityCommands::insert_if_new),\n    /// but it is faster due to memory pre-allocation.\n    ///\n    /// # Panics\n    ///\n    /// This command panics if any of the given entities do not exist.\n    ///\n    /// For the non-panicking version, see [`try_insert_batch_if_new`](Self::try_insert_batch_if_new).\n    #[track_caller]\n    pub fn insert_batch_if_new<I, B>(&mut self, batch: I)\n    where\n        I: IntoIterator<Item = (Entity, B)> + Send + Sync + 'static,\n        B: Bundle,\n    {\n        self.queue(insert_batch_if_new(batch));\n    }\n\n    /// Pushes a [`Command`] to the queue for adding a [`Bundle`] type to a batch of [`Entities`](Entity).\n    ///\n    /// A batch can be any type that implements [`IntoIterator`] containing `(Entity, Bundle)` tuples,\n    /// such as a [`Vec<(Entity, Bundle)>`] or an array `[(Entity, Bundle); N]`.\n    ///\n    /// When the command is applied, for each `(Entity, Bundle)` pair in the given batch,\n    /// the `Bundle` is added to the `Entity`, overwriting any existing components shared by the `Bundle`.\n    ///\n    /// This method is equivalent to iterating the batch,\n    /// calling [`get_entity`](Self::get_entity) for each pair,\n    /// and passing the bundle to [`insert`](EntityCommands::insert),\n    /// but it is faster due to memory pre-allocation.\n    ///\n    /// This command silently fails by ignoring any entities that do not exist.\n    ///\n    /// For the panicking version, see [`insert_batch`](Self::insert_batch).\n    #[track_caller]\n    pub fn try_insert_batch<I, B>(&mut self, batch: I)\n    where\n        I: IntoIterator<Item = (Entity, B)> + Send + Sync + 'static,\n        B: Bundle,\n    {\n        self.queue(try_insert_batch(batch));\n    }\n\n    /// Pushes a [`Command`] to the queue for adding a [`Bundle`] type to a batch of [`Entities`](Entity).\n    ///\n    /// A batch can be any type that implements [`IntoIterator`] containing `(Entity, Bundle)` tuples,\n    /// such as a [`Vec<(Entity, Bundle)>`] or an array `[(Entity, Bundle); N]`.\n    ///\n    /// When the command is applied, for each `(Entity, Bundle)` pair in the given batch,\n    /// the `Bundle` is added to the `Entity`, except for any components already present on the `Entity`.\n    ///\n    /// This method is equivalent to iterating the batch,\n    /// calling [`get_entity`](Self::get_entity) for each pair,\n    /// and passing the bundle to [`insert_if_new`](EntityCommands::insert_if_new),\n    /// but it is faster due to memory pre-allocation.\n    ///\n    /// This command silently fails by ignoring any entities that do not exist.\n    ///\n    /// For the panicking version, see [`insert_batch_if_new`](Self::insert_batch_if_new).\n    #[track_caller]\n    pub fn try_insert_batch_if_new<I, B>(&mut self, batch: I)\n    where\n        I: IntoIterator<Item = (Entity, B)> + Send + Sync + 'static,\n        B: Bundle,\n    {\n        self.queue(try_insert_batch_if_new(batch));\n    }\n\n    /// Pushes a [`Command`] to the queue for inserting a [`Resource`] in the [`World`] with an inferred value.\n    ///\n    /// The inferred value is determined by the [`FromWorld`] trait of the resource.\n    /// When the command is applied,\n    /// if the resource already exists, nothing happens.\n    ///\n    /// See [`World::init_resource`] for more details.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use bevy_ecs::prelude::*;\n    /// #\n    /// # #[derive(Resource, Default)]\n    /// # struct Scoreboard {\n    /// #     current_score: u32,\n    /// #     high_score: u32,\n    /// # }\n    /// #\n    /// # fn initialize_scoreboard(mut commands: Commands) {\n    /// commands.init_resource::<Scoreboard>();\n    /// # }\n    /// # bevy_ecs::system::assert_is_system(initialize_scoreboard);\n    /// ```\n    #[track_caller]\n    pub fn init_resource<R: Resource + FromWorld>(&mut self) {\n        self.queue(init_resource::<R>);\n    }\n\n    /// Pushes a [`Command`] to the queue for inserting a [`Resource`] in the [`World`] with a specific value.\n    ///\n    /// This will overwrite any previous value of the same resource type.\n    ///\n    /// See [`World::insert_resource`] for more details.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use bevy_ecs::prelude::*;\n    /// #\n    /// # #[derive(Resource)]\n    /// # struct Scoreboard {\n    /// #     current_score: u32,\n    /// #     high_score: u32,\n    /// # }\n    /// #\n    /// # fn system(mut commands: Commands) {\n    /// commands.insert_resource(Scoreboard {\n    ///     current_score: 0,\n    ///     high_score: 0,\n    /// });\n    /// # }\n    /// # bevy_ecs::system::assert_is_system(system);\n    /// ```\n    #[track_caller]\n    pub fn insert_resource<R: Resource>(&mut self, resource: R) {\n        self.queue(insert_resource(resource));\n    }\n\n    /// Pushes a [`Command`] to the queue for removing a [`Resource`] from the [`World`].\n    ///\n    /// See [`World::remove_resource`] for more details.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use bevy_ecs::prelude::*;\n    /// #\n    /// # #[derive(Resource)]\n    /// # struct Scoreboard {\n    /// #     current_score: u32,\n    /// #     high_score: u32,\n    /// # }\n    /// #\n    /// # fn system(mut commands: Commands) {\n    /// commands.remove_resource::<Scoreboard>();\n    /// # }\n    /// # bevy_ecs::system::assert_is_system(system);\n    /// ```\n    pub fn remove_resource<R: Resource>(&mut self) {\n        self.queue(remove_resource::<R>);\n    }\n\n    /// Runs the system corresponding to the given [`SystemId`].\n    /// Systems are ran in an exclusive and single threaded way.\n    /// Running slow systems can become a bottleneck.\n    ///\n    /// Calls [`World::run_system`](World::run_system).\n    ///\n    /// There is no way to get the output of a system when run as a command, because the\n    /// execution of the system happens later. To get the output of a system, use\n    /// [`World::run_system`] or [`World::run_system_with_input`] instead of running the system as a command.\n    pub fn run_system(&mut self, id: SystemId) {\n        self.run_system_with_input(id, ());\n    }\n\n    /// Runs the system corresponding to the given [`SystemId`].\n    /// Systems are ran in an exclusive and single threaded way.\n    /// Running slow systems can become a bottleneck.\n    ///\n    /// Calls [`World::run_system_with_input`](World::run_system_with_input).\n    ///\n    /// There is no way to get the output of a system when run as a command, because the\n    /// execution of the system happens later. To get the output of a system, use\n    /// [`World::run_system`] or [`World::run_system_with_input`] instead of running the system as a command.\n    pub fn run_system_with_input<I>(&mut self, id: SystemId<I>, input: I::Inner<'static>)\n    where\n        I: SystemInput<Inner<'static>: Send> + 'static,\n    {\n        self.queue(RunSystemWithInput::new_with_input(id, input));\n    }\n\n    /// Registers a system and returns a [`SystemId`] so it can later be called by [`World::run_system`].\n    ///\n    /// It's possible to register the same systems more than once, they'll be stored separately.\n    ///\n    /// This is different from adding systems to a [`Schedule`](crate::schedule::Schedule),\n    /// because the [`SystemId`] that is returned can be used anywhere in the [`World`] to run the associated system.\n    /// This allows for running systems in a push-based fashion.\n    /// Using a [`Schedule`](crate::schedule::Schedule) is still preferred for most cases\n    /// due to its better performance and ability to run non-conflicting systems simultaneously.\n    ///\n    /// If you want to prevent Commands from registering the same system multiple times, consider using [`Local`](crate::system::Local)\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use bevy_ecs::{prelude::*, world::CommandQueue, system::SystemId};\n    ///\n    /// #[derive(Resource)]\n    /// struct Counter(i32);\n    ///\n    /// fn register_system(mut local_system: Local<Option<SystemId>>, mut commands: Commands) {\n    ///     if let Some(system) = *local_system {\n    ///         commands.run_system(system);\n    ///     } else {\n    ///         *local_system = Some(commands.register_system(increment_counter));\n    ///     }\n    /// }\n    ///\n    /// fn increment_counter(mut value: ResMut<Counter>) {\n    ///     value.0 += 1;\n    /// }\n    ///\n    /// # let mut world = World::default();\n    /// # world.insert_resource(Counter(0));\n    /// # let mut queue_1 = CommandQueue::default();\n    /// # let systemid = {\n    /// #   let mut commands = Commands::new(&mut queue_1, &world);\n    /// #   commands.register_system(increment_counter)\n    /// # };\n    /// # let mut queue_2 = CommandQueue::default();\n    /// # {\n    /// #   let mut commands = Commands::new(&mut queue_2, &world);\n    /// #   commands.run_system(systemid);\n    /// # }\n    /// # queue_1.append(&mut queue_2);\n    /// # queue_1.apply(&mut world);\n    /// # assert_eq!(1, world.resource::<Counter>().0);\n    /// # bevy_ecs::system::assert_is_system(register_system);\n    /// ```\n    pub fn register_system<I, O, M>(\n        &mut self,\n        system: impl IntoSystem<I, O, M> + 'static,\n    ) -> SystemId<I, O>\n    where\n        I: SystemInput + Send + 'static,\n        O: Send + 'static,\n    {\n        let entity = self.spawn_empty().id();\n        self.queue(RegisterSystem::new(system, entity));\n        SystemId::from_entity(entity)\n    }\n\n    /// Similar to [`Self::run_system`], but caching the [`SystemId`] in a\n    /// [`CachedSystemId`](crate::system::CachedSystemId) resource.\n    ///\n    /// See [`World::register_system_cached`] for more information.\n    pub fn run_system_cached<M: 'static, S: IntoSystem<(), (), M> + Send + 'static>(\n        &mut self,\n        system: S,\n    ) {\n        self.run_system_cached_with(system, ());\n    }\n\n    /// Similar to [`Self::run_system_with_input`], but caching the [`SystemId`] in a\n    /// [`CachedSystemId`](crate::system::CachedSystemId) resource.\n    ///\n    /// See [`World::register_system_cached`] for more information.\n    pub fn run_system_cached_with<I, M, S>(&mut self, system: S, input: I::Inner<'static>)\n    where\n        I: SystemInput<Inner<'static>: Send> + Send + 'static,\n        M: 'static,\n        S: IntoSystem<I, (), M> + Send + 'static,\n    {\n        self.queue(RunSystemCachedWith::new(system, input));\n    }\n\n    /// Sends a \"global\" [`Trigger`] without any targets. This will run any [`Observer`] of the `event` that\n    /// isn't scoped to specific targets.\n    ///\n    /// [`Trigger`]: crate::observer::Trigger\n    pub fn trigger(&mut self, event: impl Event) {\n        self.queue(TriggerEvent { event, targets: () });\n    }\n\n    /// Sends a [`Trigger`] for the given targets. This will run any [`Observer`] of the `event` that\n    /// watches those targets.\n    ///\n    /// [`Trigger`]: crate::observer::Trigger\n    pub fn trigger_targets(\n        &mut self,\n        event: impl Event,\n        targets: impl TriggerTargets + Send + Sync + 'static,\n    ) {\n        self.queue(TriggerEvent { event, targets });\n    }\n\n    /// Spawns an [`Observer`] and returns the [`EntityCommands`] associated\n    /// with the entity that stores the observer.\n    ///\n    /// **Calling [`observe`](EntityCommands::observe) on the returned\n    /// [`EntityCommands`] will observe the observer itself, which you very\n    /// likely do not want.**\n    pub fn add_observer<E: Event, B: Bundle, M>(\n        &mut self,\n        observer: impl IntoObserverSystem<E, B, M>,\n    ) -> EntityCommands {\n        self.spawn(Observer::new(observer))\n    }\n\n    /// Sends an arbitrary [`Event`].\n    ///\n    /// This is a convenience method for sending events without requiring an [`EventWriter`].\n    /// ## Performance\n    /// Since this is a command, exclusive world access is used, which means that it will not profit from\n    /// system-level parallelism on supported platforms.\n    /// If these events are performance-critical or very frequently\n    /// sent, consider using a typed [`EventWriter`] instead.\n    ///\n    /// [`EventWriter`]: crate::event::EventWriter\n    pub fn send_event<E: Event>(&mut self, event: E) -> &mut Self {\n        self.queue(SendEvent { event });\n        self\n    }\n}\n\n/// A [`Command`] which gets executed for a given [`Entity`].\n///\n/// # Examples\n///\n/// ```\n/// # use std::collections::HashSet;\n/// # use bevy_ecs::prelude::*;\n/// use bevy_ecs::system::EntityCommand;\n/// #\n/// # #[derive(Component, PartialEq)]\n/// # struct Name(String);\n/// # impl Name {\n/// #   fn new(s: String) -> Self { Name(s) }\n/// #   fn as_str(&self) -> &str { &self.0 }\n/// # }\n///\n/// #[derive(Resource, Default)]\n/// struct Counter(i64);\n///\n/// /// A `Command` which names an entity based on a global counter.\n/// fn count_name(entity: Entity, world: &mut World) {\n///     // Get the current value of the counter, and increment it for next time.\n///     let mut counter = world.resource_mut::<Counter>();\n///     let i = counter.0;\n///     counter.0 += 1;\n///\n///     // Name the entity after the value of the counter.\n///     world.entity_mut(entity).insert(Name::new(format!(\"Entity #{i}\")));\n/// }\n///\n/// // App creation boilerplate omitted...\n/// # let mut world = World::new();\n/// # world.init_resource::<Counter>();\n/// #\n/// # let mut setup_schedule = Schedule::default();\n/// # setup_schedule.add_systems(setup);\n/// # let mut assert_schedule = Schedule::default();\n/// # assert_schedule.add_systems(assert_names);\n/// #\n/// # setup_schedule.run(&mut world);\n/// # assert_schedule.run(&mut world);\n///\n/// fn setup(mut commands: Commands) {\n///     commands.spawn_empty().queue(count_name);\n///     commands.spawn_empty().queue(count_name);\n/// }\n///\n/// fn assert_names(named: Query<&Name>) {\n///     // We use a HashSet because we do not care about the order.\n///     let names: HashSet<_> = named.iter().map(Name::as_str).collect();\n///     assert_eq!(names, HashSet::from_iter([\"Entity #0\", \"Entity #1\"]));\n/// }\n/// ```\npub trait EntityCommand<Marker = ()>: Send + 'static {\n    /// Executes this command for the given [`Entity`].\n    fn apply(self, entity: Entity, world: &mut World);\n\n    /// Returns a [`Command`] which executes this [`EntityCommand`] for the given [`Entity`].\n    ///\n    /// This method is called when adding an [`EntityCommand`] to a command queue via [`Commands`].\n    /// You can override the provided implementation if you can return a `Command` with a smaller memory\n    /// footprint than `(Entity, Self)`.\n    /// In most cases the provided implementation is sufficient.\n    #[must_use = \"commands do nothing unless applied to a `World`\"]\n    fn with_entity(self, entity: Entity) -> impl Command\n    where\n        Self: Sized,\n    {\n        move |world: &mut World| self.apply(entity, world)\n    }\n}\n\n/// A list of commands that will be run to modify an [entity](crate::entity).\npub struct EntityCommands<'a> {\n    pub(crate) entity: Entity,\n    pub(crate) commands: Commands<'a, 'a>,\n}\n\nimpl<'a> EntityCommands<'a> {\n    /// Returns the [`Entity`] id of the entity.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use bevy_ecs::prelude::*;\n    /// #\n    /// fn my_system(mut commands: Commands) {\n    ///     let entity_id = commands.spawn_empty().id();\n    /// }\n    /// # bevy_ecs::system::assert_is_system(my_system);\n    /// ```\n    #[inline]\n    #[must_use = \"Omit the .id() call if you do not need to store the `Entity` identifier.\"]\n    pub fn id(&self) -> Entity {\n        self.entity\n    }\n\n    /// Returns an [`EntityCommands`] with a smaller lifetime.\n    /// This is useful if you have `&mut EntityCommands` but you need `EntityCommands`.\n    pub fn reborrow(&mut self) -> EntityCommands {\n        EntityCommands {\n            entity: self.entity,\n            commands: self.commands.reborrow(),\n        }\n    }\n\n    /// Get an [`EntityEntryCommands`] for the [`Component`] `T`,\n    /// allowing you to modify it or insert it if it isn't already present.\n    ///\n    /// See also [`insert_if_new`](Self::insert_if_new), which lets you insert a [`Bundle`] without overwriting it.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use bevy_ecs::prelude::*;\n    /// # #[derive(Resource)]\n    /// # struct PlayerEntity { entity: Entity }\n    /// #[derive(Component)]\n    /// struct Level(u32);\n    ///\n    /// fn level_up_system(mut commands: Commands, player: Res<PlayerEntity>) {\n    ///     commands\n    ///         .entity(player.entity)\n    ///         .entry::<Level>()\n    ///         // Modify the component if it exists\n    ///         .and_modify(|mut lvl| lvl.0 += 1)\n    ///         // Otherwise insert a default value\n    ///         .or_insert(Level(0));\n    /// }\n    /// # bevy_ecs::system::assert_is_system(level_up_system);\n    /// ```\n    pub fn entry<T: Component>(&mut self) -> EntityEntryCommands<T> {\n        EntityEntryCommands {\n            entity_commands: self.reborrow(),\n            marker: PhantomData,\n        }\n    }\n\n    /// Adds a [`Bundle`] of components to the entity.\n    ///\n    /// This will overwrite any previous value(s) of the same component type.\n    /// See [`EntityCommands::insert_if_new`] to keep the old value instead.\n    ///\n    /// # Panics\n    ///\n    /// The command will panic when applied if the associated entity does not exist.\n    ///\n    /// To avoid a panic in this case, use the command [`Self::try_insert`] instead.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use bevy_ecs::prelude::*;\n    /// # #[derive(Resource)]\n    /// # struct PlayerEntity { entity: Entity }\n    /// #[derive(Component)]\n    /// struct Health(u32);\n    /// #[derive(Component)]\n    /// struct Strength(u32);\n    /// #[derive(Component)]\n    /// struct Defense(u32);\n    ///\n    /// #[derive(Bundle)]\n    /// struct CombatBundle {\n    ///     health: Health,\n    ///     strength: Strength,\n    /// }\n    ///\n    /// fn add_combat_stats_system(mut commands: Commands, player: Res<PlayerEntity>) {\n    ///     commands\n    ///         .entity(player.entity)\n    ///         // You can insert individual components:\n    ///         .insert(Defense(10))\n    ///         // You can also insert pre-defined bundles of components:\n    ///         .insert(CombatBundle {\n    ///             health: Health(100),\n    ///             strength: Strength(40),\n    ///         })\n    ///         // You can also insert tuples of components and bundles.\n    ///         // This is equivalent to the calls above:\n    ///         .insert((\n    ///             Defense(10),\n    ///             CombatBundle {\n    ///                 health: Health(100),\n    ///                 strength: Strength(40),\n    ///             },\n    ///         ));\n    /// }\n    /// # bevy_ecs::system::assert_is_system(add_combat_stats_system);\n    /// ```\n    #[track_caller]\n    pub fn insert(&mut self, bundle: impl Bundle) -> &mut Self {\n        self.queue(insert(bundle, InsertMode::Replace))\n    }\n\n    /// Similar to [`Self::insert`] but will only insert if the predicate returns true.\n    /// This is useful for chaining method calls.\n    ///\n    /// # Panics\n    ///\n    /// The command will panic when applied if the associated entity does not exist.\n    ///\n    /// To avoid a panic in this case, use the command [`Self::try_insert_if`] instead.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use bevy_ecs::prelude::*;\n    /// # #[derive(Resource)]\n    /// # struct PlayerEntity { entity: Entity }\n    /// # impl PlayerEntity { fn is_spectator(&self) -> bool { true } }\n    /// #[derive(Component)]\n    /// struct StillLoadingStats;\n    /// #[derive(Component)]\n    /// struct Health(u32);\n    ///\n    /// fn add_health_system(mut commands: Commands, player: Res<PlayerEntity>) {\n    ///     commands\n    ///         .entity(player.entity)\n    ///         .insert_if(Health(10), || !player.is_spectator())\n    ///         .remove::<StillLoadingStats>();\n    /// }\n    /// # bevy_ecs::system::assert_is_system(add_health_system);\n    /// ```\n    #[track_caller]\n    pub fn insert_if<F>(&mut self, bundle: impl Bundle, condition: F) -> &mut Self\n    where\n        F: FnOnce() -> bool,\n    {\n        if condition() {\n            self.queue(insert(bundle, InsertMode::Replace))\n        } else {\n            self\n        }\n    }\n\n    /// Adds a [`Bundle`] of components to the entity without overwriting.\n    ///\n    /// This is the same as [`EntityCommands::insert`], but in case of duplicate\n    /// components will leave the old values instead of replacing them with new\n    /// ones.\n    ///\n    /// See also [`entry`](Self::entry), which lets you modify a [`Component`] if it's present,\n    /// as well as initialize it with a default value.\n    ///\n    /// # Panics\n    ///\n    /// The command will panic when applied if the associated entity does not exist.\n    ///\n    /// To avoid a panic in this case, use the command [`Self::try_insert_if_new`] instead.\n    pub fn insert_if_new(&mut self, bundle: impl Bundle) -> &mut Self {\n        self.queue(insert(bundle, InsertMode::Keep))\n    }\n\n    /// Adds a [`Bundle`] of components to the entity without overwriting if the\n    /// predicate returns true.\n    ///\n    /// This is the same as [`EntityCommands::insert_if`], but in case of duplicate\n    /// components will leave the old values instead of replacing them with new\n    /// ones.\n    ///\n    /// # Panics\n    ///\n    /// The command will panic when applied if the associated entity does not\n    /// exist.\n    ///\n    /// To avoid a panic in this case, use the command [`Self::try_insert_if_new`]\n    /// instead.\n    pub fn insert_if_new_and<F>(&mut self, bundle: impl Bundle, condition: F) -> &mut Self\n    where\n        F: FnOnce() -> bool,\n    {\n        if condition() {\n            self.insert_if_new(bundle)\n        } else {\n            self\n        }\n    }\n\n    /// Adds a dynamic component to an entity.\n    ///\n    /// See [`EntityWorldMut::insert_by_id`] for more information.\n    ///\n    /// # Panics\n    ///\n    /// The command will panic when applied if the associated entity does not exist.\n    ///\n    /// To avoid a panic in this case, use the command [`Self::try_insert_by_id`] instead.\n    ///\n    /// # Safety\n    ///\n    /// - [`ComponentId`] must be from the same world as `self`.\n    /// - `T` must have the same layout as the one passed during `component_id` creation.\n    #[track_caller]\n    pub unsafe fn insert_by_id<T: Send + 'static>(\n        &mut self,\n        component_id: ComponentId,\n        value: T,\n    ) -> &mut Self {\n        let caller = Location::caller();\n        // SAFETY: same invariants as parent call\n        self.queue(unsafe {insert_by_id(component_id, value, move |entity| {\n            panic!(\"error[B0003]: {caller}: Could not insert a component {component_id:?} (with type {}) for entity {entity:?} because it doesn't exist in this World. See: https://bevyengine.org/learn/errors/b0003\", core::any::type_name::<T>());\n        })})\n    }\n\n    /// Attempts to add a dynamic component to an entity.\n    ///\n    /// See [`EntityWorldMut::insert_by_id`] for more information.\n    ///\n    /// # Safety\n    ///\n    /// - [`ComponentId`] must be from the same world as `self`.\n    /// - `T` must have the same layout as the one passed during `component_id` creation.\n    pub unsafe fn try_insert_by_id<T: Send + 'static>(\n        &mut self,\n        component_id: ComponentId,\n        value: T,\n    ) -> &mut Self {\n        // SAFETY: same invariants as parent call\n        self.queue(unsafe { insert_by_id(component_id, value, |_| {}) })\n    }\n\n    /// Tries to add a [`Bundle`] of components to the entity.\n    ///\n    /// This will overwrite any previous value(s) of the same component type.\n    ///\n    /// # Note\n    ///\n    /// Unlike [`Self::insert`], this will not panic if the associated entity does not exist.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use bevy_ecs::prelude::*;\n    /// # #[derive(Resource)]\n    /// # struct PlayerEntity { entity: Entity }\n    /// #[derive(Component)]\n    /// struct Health(u32);\n    /// #[derive(Component)]\n    /// struct Strength(u32);\n    /// #[derive(Component)]\n    /// struct Defense(u32);\n    ///\n    /// #[derive(Bundle)]\n    /// struct CombatBundle {\n    ///     health: Health,\n    ///     strength: Strength,\n    /// }\n    ///\n    /// fn add_combat_stats_system(mut commands: Commands, player: Res<PlayerEntity>) {\n    ///   commands.entity(player.entity)\n    ///    // You can try_insert individual components:\n    ///     .try_insert(Defense(10))\n    ///\n    ///    // You can also insert tuples of components:\n    ///     .try_insert(CombatBundle {\n    ///         health: Health(100),\n    ///         strength: Strength(40),\n    ///     });\n    ///\n    ///    // Suppose this occurs in a parallel adjacent system or process\n    ///    commands.entity(player.entity)\n    ///      .despawn();\n    ///\n    ///    commands.entity(player.entity)\n    ///    // This will not panic nor will it add the component\n    ///      .try_insert(Defense(5));\n    /// }\n    /// # bevy_ecs::system::assert_is_system(add_combat_stats_system);\n    /// ```\n    #[track_caller]\n    pub fn try_insert(&mut self, bundle: impl Bundle) -> &mut Self {\n        self.queue(try_insert(bundle, InsertMode::Replace))\n    }\n\n    /// Similar to [`Self::try_insert`] but will only try to insert if the predicate returns true.\n    /// This is useful for chaining method calls.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use bevy_ecs::prelude::*;\n    /// # #[derive(Resource)]\n    /// # struct PlayerEntity { entity: Entity }\n    /// # impl PlayerEntity { fn is_spectator(&self) -> bool { true } }\n    /// #[derive(Component)]\n    /// struct StillLoadingStats;\n    /// #[derive(Component)]\n    /// struct Health(u32);\n    ///\n    /// fn add_health_system(mut commands: Commands, player: Res<PlayerEntity>) {\n    ///   commands.entity(player.entity)\n    ///     .try_insert_if(Health(10), || !player.is_spectator())\n    ///     .remove::<StillLoadingStats>();\n    ///\n    ///    commands.entity(player.entity)\n    ///    // This will not panic nor will it add the component\n    ///      .try_insert_if(Health(5), || !player.is_spectator());\n    /// }\n    /// # bevy_ecs::system::assert_is_system(add_health_system);\n    /// ```\n    #[track_caller]\n    pub fn try_insert_if<F>(&mut self, bundle: impl Bundle, condition: F) -> &mut Self\n    where\n        F: FnOnce() -> bool,\n    {\n        if condition() {\n            self.queue(try_insert(bundle, InsertMode::Replace))\n        } else {\n            self\n        }\n    }\n\n    /// Tries to add a [`Bundle`] of components to the entity without overwriting if the\n    /// predicate returns true.\n    ///\n    /// This is the same as [`EntityCommands::try_insert_if`], but in case of duplicate\n    /// components will leave the old values instead of replacing them with new\n    /// ones.\n    ///\n    /// # Note\n    ///\n    /// Unlike [`Self::insert_if_new_and`], this will not panic if the associated entity does\n    /// not exist.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use bevy_ecs::prelude::*;\n    /// # #[derive(Resource)]\n    /// # struct PlayerEntity { entity: Entity }\n    /// # impl PlayerEntity { fn is_spectator(&self) -> bool { true } }\n    /// #[derive(Component)]\n    /// struct StillLoadingStats;\n    /// #[derive(Component)]\n    /// struct Health(u32);\n    ///\n    /// fn add_health_system(mut commands: Commands, player: Res<PlayerEntity>) {\n    ///   commands.entity(player.entity)\n    ///     .try_insert_if(Health(10), || player.is_spectator())\n    ///     .remove::<StillLoadingStats>();\n    ///\n    ///    commands.entity(player.entity)\n    ///    // This will not panic nor will it overwrite the component\n    ///      .try_insert_if_new_and(Health(5), || player.is_spectator());\n    /// }\n    /// # bevy_ecs::system::assert_is_system(add_health_system);\n    /// ```\n    pub fn try_insert_if_new_and<F>(&mut self, bundle: impl Bundle, condition: F) -> &mut Self\n    where\n        F: FnOnce() -> bool,\n    {\n        if condition() {\n            self.try_insert_if_new(bundle)\n        } else {\n            self\n        }\n    }\n\n    /// Tries to add a [`Bundle`] of components to the entity without overwriting.\n    ///\n    /// This is the same as [`EntityCommands::try_insert`], but in case of duplicate\n    /// components will leave the old values instead of replacing them with new\n    /// ones.\n    ///\n    /// # Note\n    ///\n    /// Unlike [`Self::insert_if_new`], this will not panic if the associated entity does not exist.\n    pub fn try_insert_if_new(&mut self, bundle: impl Bundle) -> &mut Self {\n        self.queue(try_insert(bundle, InsertMode::Keep))\n    }\n\n    /// Removes a [`Bundle`] of components from the entity.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use bevy_ecs::prelude::*;\n    /// #\n    /// # #[derive(Resource)]\n    /// # struct PlayerEntity { entity: Entity }\n    /// #[derive(Component)]\n    /// struct Health(u32);\n    /// #[derive(Component)]\n    /// struct Strength(u32);\n    /// #[derive(Component)]\n    /// struct Defense(u32);\n    ///\n    /// #[derive(Bundle)]\n    /// struct CombatBundle {\n    ///     health: Health,\n    ///     strength: Strength,\n    /// }\n    ///\n    /// fn remove_combat_stats_system(mut commands: Commands, player: Res<PlayerEntity>) {\n    ///     commands\n    ///         .entity(player.entity)\n    ///         // You can remove individual components:\n    ///         .remove::<Defense>()\n    ///         // You can also remove pre-defined Bundles of components:\n    ///         .remove::<CombatBundle>()\n    ///         // You can also remove tuples of components and bundles.\n    ///         // This is equivalent to the calls above:\n    ///         .remove::<(Defense, CombatBundle)>();\n    /// }\n    /// # bevy_ecs::system::assert_is_system(remove_combat_stats_system);\n    /// ```\n    pub fn remove<T>(&mut self) -> &mut Self\n    where\n        T: Bundle,\n    {\n        self.queue(remove::<T>)\n    }\n\n    /// Removes all components in the [`Bundle`] components and remove all required components for each component in the [`Bundle`] from entity.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bevy_ecs::prelude::*;\n    ///\n    /// #[derive(Component)]\n    /// #[require(B)]\n    /// struct A;\n    /// #[derive(Component, Default)]\n    /// struct B;\n    ///\n    /// #[derive(Resource)]\n    /// struct PlayerEntity { entity: Entity }\n    ///\n    /// fn remove_with_requires_system(mut commands: Commands, player: Res<PlayerEntity>) {\n    ///     commands\n    ///         .entity(player.entity)\n    ///         // Remove both A and B components from the entity, because B is required by A\n    ///         .remove_with_requires::<A>();\n    /// }\n    /// # bevy_ecs::system::assert_is_system(remove_with_requires_system);\n    /// ```\n    pub fn remove_with_requires<T: Bundle>(&mut self) -> &mut Self {\n        self.queue(remove_with_requires::<T>)\n    }\n\n    /// Removes a component from the entity.\n    pub fn remove_by_id(&mut self, component_id: ComponentId) -> &mut Self {\n        self.queue(remove_by_id(component_id))\n    }\n\n    /// Removes all components associated with the entity.\n    pub fn clear(&mut self) -> &mut Self {\n        self.queue(clear())\n    }\n\n    /// Despawns the entity.\n    /// This will emit a warning if the entity does not exist.\n    ///\n    /// See [`World::despawn`] for more details.\n    ///\n    /// # Note\n    ///\n    /// This won't clean up external references to the entity (such as parent-child relationships\n    /// if you're using `bevy_hierarchy`), which may leave the world in an invalid state.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use bevy_ecs::prelude::*;\n    /// #\n    /// # #[derive(Resource)]\n    /// # struct CharacterToRemove { entity: Entity }\n    /// #\n    /// fn remove_character_system(\n    ///     mut commands: Commands,\n    ///     character_to_remove: Res<CharacterToRemove>\n    /// )\n    /// {\n    ///     commands.entity(character_to_remove.entity).despawn();\n    /// }\n    /// # bevy_ecs::system::assert_is_system(remove_character_system);\n    /// ```\n    #[track_caller]\n    pub fn despawn(&mut self) {\n        self.queue(despawn());\n    }\n\n    /// Despawns the entity.\n    /// This will not emit a warning if the entity does not exist, essentially performing\n    /// the same function as [`Self::despawn`] without emitting warnings.\n    #[track_caller]\n    pub fn try_despawn(&mut self) {\n        self.queue(try_despawn());\n    }\n\n    /// Pushes an [`EntityCommand`] to the queue, which will get executed for the current [`Entity`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use bevy_ecs::prelude::*;\n    /// # fn my_system(mut commands: Commands) {\n    /// commands\n    ///     .spawn_empty()\n    ///     // Closures with this signature implement `EntityCommand`.\n    ///     .queue(|entity: EntityWorldMut| {\n    ///         println!(\"Executed an EntityCommand for {:?}\", entity.id());\n    ///     });\n    /// # }\n    /// # bevy_ecs::system::assert_is_system(my_system);\n    /// ```\n    pub fn queue<M: 'static>(&mut self, command: impl EntityCommand<M>) -> &mut Self {\n        self.commands.queue(command.with_entity(self.entity));\n        self\n    }\n\n    /// Removes all components except the given [`Bundle`] from the entity.\n    ///\n    /// This can also be used to remove all the components from the entity by passing it an empty Bundle.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use bevy_ecs::prelude::*;\n    /// #\n    /// # #[derive(Resource)]\n    /// # struct PlayerEntity { entity: Entity }\n    /// #[derive(Component)]\n    /// struct Health(u32);\n    /// #[derive(Component)]\n    /// struct Strength(u32);\n    /// #[derive(Component)]\n    /// struct Defense(u32);\n    ///\n    /// #[derive(Bundle)]\n    /// struct CombatBundle {\n    ///     health: Health,\n    ///     strength: Strength,\n    /// }\n    ///\n    /// fn remove_combat_stats_system(mut commands: Commands, player: Res<PlayerEntity>) {\n    ///     commands\n    ///         .entity(player.entity)\n    ///         // You can retain a pre-defined Bundle of components,\n    ///         // with this removing only the Defense component\n    ///         .retain::<CombatBundle>()\n    ///         // You can also retain only a single component\n    ///         .retain::<Health>()\n    ///         // And you can remove all the components by passing in an empty Bundle\n    ///         .retain::<()>();\n    /// }\n    /// # bevy_ecs::system::assert_is_system(remove_combat_stats_system);\n    /// ```\n    pub fn retain<T>(&mut self) -> &mut Self\n    where\n        T: Bundle,\n    {\n        self.queue(retain::<T>)\n    }\n\n    /// Logs the components of the entity at the info level.\n    ///\n    /// # Panics\n    ///\n    /// The command will panic when applied if the associated entity does not exist.\n    pub fn log_components(&mut self) -> &mut Self {\n        self.queue(log_components)\n    }\n\n    /// Returns the underlying [`Commands`].\n    pub fn commands(&mut self) -> Commands {\n        self.commands.reborrow()\n    }\n\n    /// Returns a mutable reference to the underlying [`Commands`].\n    pub fn commands_mut(&mut self) -> &mut Commands<'a, 'a> {\n        &mut self.commands\n    }\n\n    /// Sends a [`Trigger`] targeting this entity. This will run any [`Observer`] of the `event` that\n    /// watches this entity.\n    ///\n    /// [`Trigger`]: crate::observer::Trigger\n    pub fn trigger(&mut self, event: impl Event) -> &mut Self {\n        self.commands.trigger_targets(event, self.entity);\n        self\n    }\n\n    /// Creates an [`Observer`] listening for a trigger of type `T` that targets this entity.\n    pub fn observe<E: Event, B: Bundle, M>(\n        &mut self,\n        system: impl IntoObserverSystem<E, B, M>,\n    ) -> &mut Self {\n        self.queue(observe(system))\n    }\n}\n\n/// A wrapper around [`EntityCommands`] with convenience methods for working with a specified component type.\npub struct EntityEntryCommands<'a, T> {\n    entity_commands: EntityCommands<'a>,\n    marker: PhantomData<T>,\n}\n\nimpl<'a, T: Component> EntityEntryCommands<'a, T> {\n    /// Modify the component `T` if it exists, using the function `modify`.\n    pub fn and_modify(&mut self, modify: impl FnOnce(Mut<T>) + Send + Sync + 'static) -> &mut Self {\n        self.entity_commands\n            .queue(move |mut entity: EntityWorldMut| {\n                if let Some(value) = entity.get_mut() {\n                    modify(value);\n                }\n            });\n        self\n    }\n\n    /// [Insert](EntityCommands::insert) `default` into this entity, if `T` is not already present.\n    ///\n    /// See also [`or_insert_with`](Self::or_insert_with).\n    ///\n    /// # Panics\n    ///\n    /// Panics if the entity does not exist.\n    /// See [`or_try_insert`](Self::or_try_insert) for a non-panicking version.\n    #[track_caller]\n    pub fn or_insert(&mut self, default: T) -> &mut Self {\n        self.entity_commands\n            .queue(insert(default, InsertMode::Keep));\n        self\n    }\n\n    /// [Insert](EntityCommands::insert) `default` into this entity, if `T` is not already present.\n    ///\n    /// Unlike [`or_insert`](Self::or_insert), this will not panic if the entity does not exist.\n    ///\n    /// See also [`or_insert_with`](Self::or_insert_with).\n    #[track_caller]\n    pub fn or_try_insert(&mut self, default: T) -> &mut Self {\n        self.entity_commands\n            .queue(try_insert(default, InsertMode::Keep));\n        self\n    }\n\n    /// [Insert](EntityCommands::insert) the value returned from `default` into this entity, if `T` is not already present.\n    ///\n    /// See also [`or_insert`](Self::or_insert) and [`or_try_insert`](Self::or_try_insert).\n    ///\n    /// # Panics\n    ///\n    /// Panics if the entity does not exist.\n    /// See [`or_try_insert_with`](Self::or_try_insert_with) for a non-panicking version.\n    #[track_caller]\n    pub fn or_insert_with(&mut self, default: impl Fn() -> T) -> &mut Self {\n        self.or_insert(default())\n    }\n\n    /// [Insert](EntityCommands::insert) the value returned from `default` into this entity, if `T` is not already present.\n    ///\n    /// Unlike [`or_insert_with`](Self::or_insert_with), this will not panic if the entity does not exist.\n    ///\n    /// See also [`or_insert`](Self::or_insert) and [`or_try_insert`](Self::or_try_insert).\n    #[track_caller]\n    pub fn or_try_insert_with(&mut self, default: impl Fn() -> T) -> &mut Self {\n        self.or_try_insert(default())\n    }\n\n    /// [Insert](EntityCommands::insert) `T::default` into this entity, if `T` is not already present.\n    ///\n    /// See also [`or_insert`](Self::or_insert) and [`or_from_world`](Self::or_from_world).\n    ///\n    /// # Panics\n    ///\n    /// Panics if the entity does not exist.\n    #[track_caller]\n    pub fn or_default(&mut self) -> &mut Self\n    where\n        T: Default,\n    {\n        #[allow(clippy::unwrap_or_default)]\n        // FIXME: use `expect` once stable\n        self.or_insert(T::default())\n    }\n\n    /// [Insert](EntityCommands::insert) `T::from_world` into this entity, if `T` is not already present.\n    ///\n    /// See also [`or_insert`](Self::or_insert) and [`or_default`](Self::or_default).\n    ///\n    /// # Panics\n    ///\n    /// Panics if the entity does not exist.\n    #[track_caller]\n    pub fn or_from_world(&mut self) -> &mut Self\n    where\n        T: FromWorld,\n    {\n        self.entity_commands\n            .queue(insert_from_world::<T>(InsertMode::Keep));\n        self\n    }\n}\n\nimpl<F> Command for F\nwhere\n    F: FnOnce(&mut World) + Send + 'static,\n{\n    fn apply(self, world: &mut World) {\n        self(world);\n    }\n}\n\nimpl<F> EntityCommand<World> for F\nwhere\n    F: FnOnce(EntityWorldMut) + Send + 'static,\n{\n    fn apply(self, id: Entity, world: &mut World) {\n        self(world.entity_mut(id));\n    }\n}\n\nimpl<F> EntityCommand for F\nwhere\n    F: FnOnce(Entity, &mut World) + Send + 'static,\n{\n    fn apply(self, id: Entity, world: &mut World) {\n        self(id, world);\n    }\n}\n\n/// A [`Command`] that consumes an iterator of [`Bundle`]s to spawn a series of entities.\n///\n/// This is more efficient than spawning the entities individually.\n#[track_caller]\nfn spawn_batch<I, B>(bundles_iter: I) -> impl Command\nwhere\n    I: IntoIterator<Item = B> + Send + Sync + 'static,\n    B: Bundle,\n{\n    #[cfg(feature = \"track_change_detection\")]\n    let caller = Location::caller();\n    move |world: &mut World| {\n        SpawnBatchIter::new(\n            world,\n            bundles_iter.into_iter(),\n            #[cfg(feature = \"track_change_detection\")]\n            caller,\n        );\n    }\n}\n\n/// A [`Command`] that consumes an iterator to add a series of [`Bundle`]s to a set of entities.\n/// If any entities do not already exist in the world, they will be spawned.\n///\n/// This is more efficient than inserting the bundles individually.\n#[track_caller]\nfn insert_or_spawn_batch<I, B>(bundles_iter: I) -> impl Command\nwhere\n    I: IntoIterator<Item = (Entity, B)> + Send + Sync + 'static,\n    B: Bundle,\n{\n    #[cfg(feature = \"track_change_detection\")]\n    let caller = Location::caller();\n    move |world: &mut World| {\n        if let Err(invalid_entities) = world.insert_or_spawn_batch_with_caller(\n            bundles_iter,\n            #[cfg(feature = \"track_change_detection\")]\n            caller,\n        ) {\n            error!(\n                \"Failed to 'insert or spawn' bundle of type {} into the following invalid entities: {:?}\",\n                core::any::type_name::<B>(),\n                invalid_entities\n            );\n        }\n    }\n}\n\n/// A [`Command`] that consumes an iterator to add a series of [`Bundles`](Bundle) to a set of entities.\n/// If any entities do not exist in the world, this command will panic.\n///\n/// This is more efficient than inserting the bundles individually.\n#[track_caller]\nfn insert_batch<I, B>(batch: I) -> impl Command\nwhere\n    I: IntoIterator<Item = (Entity, B)> + Send + Sync + 'static,\n    B: Bundle,\n{\n    #[cfg(feature = \"track_change_detection\")]\n    let caller = Location::caller();\n    move |world: &mut World| {\n        world.insert_batch_with_caller(\n            batch,\n            InsertMode::Replace,\n            #[cfg(feature = \"track_change_detection\")]\n            caller,\n        );\n    }\n}\n\n/// A [`Command`] that consumes an iterator to add a series of [`Bundles`](Bundle) to a set of entities.\n/// If any entities do not exist in the world, this command will panic.\n///\n/// This is more efficient than inserting the bundles individually.\n#[track_caller]\nfn insert_batch_if_new<I, B>(batch: I) -> impl Command\nwhere\n    I: IntoIterator<Item = (Entity, B)> + Send + Sync + 'static,\n    B: Bundle,\n{\n    #[cfg(feature = \"track_change_detection\")]\n    let caller = Location::caller();\n    move |world: &mut World| {\n        world.insert_batch_with_caller(\n            batch,\n            InsertMode::Keep,\n            #[cfg(feature = \"track_change_detection\")]\n            caller,\n        );\n    }\n}\n\n/// A [`Command`] that consumes an iterator to add a series of [`Bundles`](Bundle) to a set of entities.\n/// If any entities do not exist in the world, this command will ignore them.\n///\n/// This is more efficient than inserting the bundles individually.\n#[track_caller]\nfn try_insert_batch<I, B>(batch: I) -> impl Command\nwhere\n    I: IntoIterator<Item = (Entity, B)> + Send + Sync + 'static,\n    B: Bundle,\n{\n    #[cfg(feature = \"track_change_detection\")]\n    let caller = Location::caller();\n    move |world: &mut World| {\n        world.try_insert_batch_with_caller(\n            batch,\n            InsertMode::Replace,\n            #[cfg(feature = \"track_change_detection\")]\n            caller,\n        );\n    }\n}\n\n/// A [`Command`] that consumes an iterator to add a series of [`Bundles`](Bundle) to a set of entities.\n/// If any entities do not exist in the world, this command will ignore them.\n///\n/// This is more efficient than inserting the bundles individually.\n#[track_caller]\nfn try_insert_batch_if_new<I, B>(batch: I) -> impl Command\nwhere\n    I: IntoIterator<Item = (Entity, B)> + Send + Sync + 'static,\n    B: Bundle,\n{\n    #[cfg(feature = \"track_change_detection\")]\n    let caller = Location::caller();\n    move |world: &mut World| {\n        world.try_insert_batch_with_caller(\n            batch,\n            InsertMode::Keep,\n            #[cfg(feature = \"track_change_detection\")]\n            caller,\n        );\n    }\n}\n\n/// A [`Command`] that despawns a specific entity.\n/// This will emit a warning if the entity does not exist.\n///\n/// # Note\n///\n/// This won't clean up external references to the entity (such as parent-child relationships\n/// if you're using `bevy_hierarchy`), which may leave the world in an invalid state.\n#[track_caller]\nfn despawn() -> impl EntityCommand {\n    let caller = Location::caller();\n    move |entity: Entity, world: &mut World| {\n        world.despawn_with_caller(entity, caller, true);\n    }\n}\n\n/// A [`Command`] that despawns a specific entity.\n/// This will not emit a warning if the entity does not exist.\n///\n/// # Note\n///\n/// This won't clean up external references to the entity (such as parent-child relationships\n/// if you're using `bevy_hierarchy`), which may leave the world in an invalid state.\n#[track_caller]\nfn try_despawn() -> impl EntityCommand {\n    let caller = Location::caller();\n    move |entity: Entity, world: &mut World| {\n        world.despawn_with_caller(entity, caller, false);\n    }\n}\n\n/// An [`EntityCommand`] that adds the components in a [`Bundle`] to an entity.\n#[track_caller]\nfn insert<T: Bundle>(bundle: T, mode: InsertMode) -> impl EntityCommand {\n    let caller = Location::caller();\n    move |entity: Entity, world: &mut World| {\n        if let Ok(mut entity) = world.get_entity_mut(entity) {\n            entity.insert_with_caller(\n                bundle,\n                mode,\n                #[cfg(feature = \"track_change_detection\")]\n                caller,\n            );\n        } else {\n            panic!(\"error[B0003]: {caller}: Could not insert a bundle (of type `{}`) for entity {:?} because it doesn't exist in this World. See: https://bevyengine.org/learn/errors/b0003\", core::any::type_name::<T>(), entity);\n        }\n    }\n}\n\n/// An [`EntityCommand`] that adds the component using its `FromWorld` implementation.\n#[track_caller]\nfn insert_from_world<T: Component + FromWorld>(mode: InsertMode) -> impl EntityCommand {\n    let caller = Location::caller();\n    move |entity: Entity, world: &mut World| {\n        let value = T::from_world(world);\n        if let Ok(mut entity) = world.get_entity_mut(entity) {\n            entity.insert_with_caller(\n                value,\n                mode,\n                #[cfg(feature = \"track_change_detection\")]\n                caller,\n            );\n        } else {\n            panic!(\"error[B0003]: {caller}: Could not insert a bundle (of type `{}`) for entity {:?} because it doesn't exist in this World. See: https://bevyengine.org/learn/errors/b0003\", core::any::type_name::<T>(), entity);\n        }\n    }\n}\n\n/// An [`EntityCommand`] that attempts to add the components in a [`Bundle`] to an entity.\n/// Does nothing if the entity does not exist.\n#[track_caller]\nfn try_insert(bundle: impl Bundle, mode: InsertMode) -> impl EntityCommand {\n    #[cfg(feature = \"track_change_detection\")]\n    let caller = Location::caller();\n    move |entity: Entity, world: &mut World| {\n        if let Ok(mut entity) = world.get_entity_mut(entity) {\n            entity.insert_with_caller(\n                bundle,\n                mode,\n                #[cfg(feature = \"track_change_detection\")]\n                caller,\n            );\n        }\n    }\n}\n\n/// An [`EntityCommand`] that attempts to add the dynamic component to an entity.\n///\n/// # Safety\n///\n/// - The returned `EntityCommand` must be queued for the world where `component_id` was created.\n/// - `T` must be the type represented by `component_id`.\nunsafe fn insert_by_id<T: Send + 'static>(\n    component_id: ComponentId,\n    value: T,\n    on_none_entity: impl FnOnce(Entity) + Send + 'static,\n) -> impl EntityCommand {\n    move |entity: Entity, world: &mut World| {\n        if let Ok(mut entity) = world.get_entity_mut(entity) {\n            // SAFETY:\n            // - `component_id` safety is ensured by the caller\n            // - `ptr` is valid within the `make` block;\n            OwningPtr::make(value, |ptr| unsafe {\n                entity.insert_by_id(component_id, ptr);\n            });\n        } else {\n            on_none_entity(entity);\n        }\n    }\n}\n\n/// An [`EntityCommand`] that removes components from an entity.\n///\n/// For a [`Bundle`] type `T`, this will remove any components in the bundle.\n/// Any components in the bundle that aren't found on the entity will be ignored.\nfn remove<T: Bundle>(entity: Entity, world: &mut World) {\n    if let Ok(mut entity) = world.get_entity_mut(entity) {\n        entity.remove::<T>();\n    }\n}\n\n/// An [`EntityCommand`] that removes components with a provided [`ComponentId`] from an entity.\n/// # Panics\n///\n/// Panics if the provided [`ComponentId`] does not exist in the [`World`].\nfn remove_by_id(component_id: ComponentId) -> impl EntityCommand {\n    move |entity: Entity, world: &mut World| {\n        if let Ok(mut entity) = world.get_entity_mut(entity) {\n            entity.remove_by_id(component_id);\n        }\n    }\n}\n\n/// An [`EntityCommand`] that remove all components in the bundle and remove all required components for each component in the bundle.\nfn remove_with_requires<T: Bundle>(entity: Entity, world: &mut World) {\n    if let Ok(mut entity) = world.get_entity_mut(entity) {\n        entity.remove_with_requires::<T>();\n    }\n}\n\n/// An [`EntityCommand`] that removes all components associated with a provided entity.\nfn clear() -> impl EntityCommand {\n    move |entity: Entity, world: &mut World| {\n        if let Ok(mut entity) = world.get_entity_mut(entity) {\n            entity.clear();\n        }\n    }\n}\n\n/// An [`EntityCommand`] that removes components from an entity.\n///\n/// For a [`Bundle`] type `T`, this will remove all components except those in the bundle.\n/// Any components in the bundle that aren't found on the entity will be ignored.\nfn retain<T: Bundle>(entity: Entity, world: &mut World) {\n    if let Ok(mut entity_mut) = world.get_entity_mut(entity) {\n        entity_mut.retain::<T>();\n    }\n}\n\n/// A [`Command`] that inserts a [`Resource`] into the world using a value\n/// created with the [`FromWorld`] trait.\n#[track_caller]\nfn init_resource<R: Resource + FromWorld>(world: &mut World) {\n    world.init_resource::<R>();\n}\n\n/// A [`Command`] that removes the [resource](Resource) `R` from the world.\n#[track_caller]\nfn remove_resource<R: Resource>(world: &mut World) {\n    world.remove_resource::<R>();\n}\n\n/// A [`Command`] that inserts a [`Resource`] into the world.\n#[track_caller]\nfn insert_resource<R: Resource>(resource: R) -> impl Command {\n    #[cfg(feature = \"track_change_detection\")]\n    let caller = Location::caller();\n    move |world: &mut World| {\n        world.insert_resource_with_caller(\n            resource,\n            #[cfg(feature = \"track_change_detection\")]\n            caller,\n        );\n    }\n}\n\n/// [`EntityCommand`] to log the components of a given entity. See [`EntityCommands::log_components`].\nfn log_components(entity: Entity, world: &mut World) {\n    let debug_infos: Vec<_> = world\n        .inspect_entity(entity)\n        .map(ComponentInfo::name)\n        .collect();\n    info!(\"Entity {entity}: {debug_infos:?}\");\n}\n\nfn observe<E: Event, B: Bundle, M>(\n    observer: impl IntoObserverSystem<E, B, M>,\n) -> impl EntityCommand {\n    move |entity: Entity, world: &mut World| {\n        if let Ok(mut entity) = world.get_entity_mut(entity) {\n            entity.observe(observer);\n        }\n    }\n}\n\n#[cfg(test)]\n#[allow(clippy::float_cmp, clippy::approx_constant)]\nmod tests {\n    use crate::{\n        self as bevy_ecs,\n        component::Component,\n        system::{Commands, Resource},\n        world::{CommandQueue, FromWorld, World},\n    };\n    use alloc::sync::Arc;\n    use core::{\n        any::TypeId,\n        sync::atomic::{AtomicUsize, Ordering},\n    };\n\n    #[allow(dead_code)]\n    #[derive(Component)]\n    #[component(storage = \"SparseSet\")]\n    struct SparseDropCk(DropCk);\n\n    #[derive(Component)]\n    struct DropCk(Arc<AtomicUsize>);\n    impl DropCk {\n        fn new_pair() -> (Self, Arc<AtomicUsize>) {\n            let atomic = Arc::new(AtomicUsize::new(0));\n            (DropCk(atomic.clone()), atomic)\n        }\n    }\n\n    impl Drop for DropCk {\n        fn drop(&mut self) {\n            self.0.as_ref().fetch_add(1, Ordering::Relaxed);\n        }\n    }\n\n    #[derive(Component, Resource)]\n    struct W<T>(T);\n\n    fn simple_command(world: &mut World) {\n        world.spawn((W(0u32), W(42u64)));\n    }\n\n    impl FromWorld for W<String> {\n        fn from_world(world: &mut World) -> Self {\n            let v = world.resource::<W<usize>>();\n            Self(\"*\".repeat(v.0))\n        }\n    }\n\n    #[test]\n    fn entity_commands_entry() {\n        let mut world = World::default();\n        let mut queue = CommandQueue::default();\n        let mut commands = Commands::new(&mut queue, &world);\n        let entity = commands.spawn_empty().id();\n        commands\n            .entity(entity)\n            .entry::<W<u32>>()\n            .and_modify(|_| unreachable!());\n        queue.apply(&mut world);\n        assert!(!world.entity(entity).contains::<W<u32>>());\n        let mut commands = Commands::new(&mut queue, &world);\n        commands\n            .entity(entity)\n            .entry::<W<u32>>()\n            .or_insert(W(0))\n            .and_modify(|mut val| {\n                val.0 = 21;\n            });\n        queue.apply(&mut world);\n        assert_eq!(21, world.get::<W<u32>>(entity).unwrap().0);\n        let mut commands = Commands::new(&mut queue, &world);\n        commands\n            .entity(entity)\n            .entry::<W<u64>>()\n            .and_modify(|_| unreachable!())\n            .or_insert(W(42));\n        queue.apply(&mut world);\n        assert_eq!(42, world.get::<W<u64>>(entity).unwrap().0);\n        world.insert_resource(W(5_usize));\n        let mut commands = Commands::new(&mut queue, &world);\n        commands.entity(entity).entry::<W<String>>().or_from_world();\n        queue.apply(&mut world);\n        assert_eq!(\"*****\", &world.get::<W<String>>(entity).unwrap().0);\n    }\n\n    #[test]\n    fn commands() {\n        let mut world = World::default();\n        let mut command_queue = CommandQueue::default();\n        let entity = Commands::new(&mut command_queue, &world)\n            .spawn((W(1u32), W(2u64)))\n            .id();\n        command_queue.apply(&mut world);\n        assert_eq!(world.entities().len(), 1);\n        let results = world\n            .query::<(&W<u32>, &W<u64>)>()\n            .iter(&world)\n            .map(|(a, b)| (a.0, b.0))\n            .collect::<Vec<_>>();\n        assert_eq!(results, vec![(1u32, 2u64)]);\n        // test entity despawn\n        {\n            let mut commands = Commands::new(&mut command_queue, &world);\n            commands.entity(entity).despawn();\n            commands.entity(entity).despawn(); // double despawn shouldn't panic\n        }\n        command_queue.apply(&mut world);\n        let results2 = world\n            .query::<(&W<u32>, &W<u64>)>()\n            .iter(&world)\n            .map(|(a, b)| (a.0, b.0))\n            .collect::<Vec<_>>();\n        assert_eq!(results2, vec![]);\n\n        // test adding simple (FnOnce) commands\n        {\n            let mut commands = Commands::new(&mut command_queue, &world);\n\n            // set up a simple command using a closure that adds one additional entity\n            commands.queue(|world: &mut World| {\n                world.spawn((W(42u32), W(0u64)));\n            });\n\n            // set up a simple command using a function that adds one additional entity\n            commands.queue(simple_command);\n        }\n        command_queue.apply(&mut world);\n        let results3 = world\n            .query::<(&W<u32>, &W<u64>)>()\n            .iter(&world)\n            .map(|(a, b)| (a.0, b.0))\n            .collect::<Vec<_>>();\n\n        assert_eq!(results3, vec![(42u32, 0u64), (0u32, 42u64)]);\n    }\n\n    #[test]\n    fn insert_components() {\n        let mut world = World::default();\n        let mut command_queue1 = CommandQueue::default();\n\n        // insert components\n        let entity = Commands::new(&mut command_queue1, &world)\n            .spawn(())\n            .insert_if(W(1u8), || true)\n            .insert_if(W(2u8), || false)\n            .insert_if_new(W(1u16))\n            .insert_if_new(W(2u16))\n            .insert_if_new_and(W(1u32), || false)\n            .insert_if_new_and(W(2u32), || true)\n            .insert_if_new_and(W(3u32), || true)\n            .id();\n        command_queue1.apply(&mut world);\n\n        let results = world\n            .query::<(&W<u8>, &W<u16>, &W<u32>)>()\n            .iter(&world)\n            .map(|(a, b, c)| (a.0, b.0, c.0))\n            .collect::<Vec<_>>();\n        assert_eq!(results, vec![(1u8, 1u16, 2u32)]);\n\n        // try to insert components after despawning entity\n        // in another command queue\n        Commands::new(&mut command_queue1, &world)\n            .entity(entity)\n            .try_insert_if_new_and(W(1u64), || true);\n\n        let mut command_queue2 = CommandQueue::default();\n        Commands::new(&mut command_queue2, &world)\n            .entity(entity)\n            .despawn();\n        command_queue2.apply(&mut world);\n        command_queue1.apply(&mut world);\n    }\n\n    #[test]\n    fn remove_components() {\n        let mut world = World::default();\n\n        let mut command_queue = CommandQueue::default();\n        let (dense_dropck, dense_is_dropped) = DropCk::new_pair();\n        let (sparse_dropck, sparse_is_dropped) = DropCk::new_pair();\n        let sparse_dropck = SparseDropCk(sparse_dropck);\n\n        let entity = Commands::new(&mut command_queue, &world)\n            .spawn((W(1u32), W(2u64), dense_dropck, sparse_dropck))\n            .id();\n        command_queue.apply(&mut world);\n        let results_before = world\n            .query::<(&W<u32>, &W<u64>)>()\n            .iter(&world)\n            .map(|(a, b)| (a.0, b.0))\n            .collect::<Vec<_>>();\n        assert_eq!(results_before, vec![(1u32, 2u64)]);\n\n        // test component removal\n        Commands::new(&mut command_queue, &world)\n            .entity(entity)\n            .remove::<W<u32>>()\n            .remove::<(W<u32>, W<u64>, SparseDropCk, DropCk)>();\n\n        assert_eq!(dense_is_dropped.load(Ordering::Relaxed), 0);\n        assert_eq!(sparse_is_dropped.load(Ordering::Relaxed), 0);\n        command_queue.apply(&mut world);\n        assert_eq!(dense_is_dropped.load(Ordering::Relaxed), 1);\n        assert_eq!(sparse_is_dropped.load(Ordering::Relaxed), 1);\n\n        let results_after = world\n            .query::<(&W<u32>, &W<u64>)>()\n            .iter(&world)\n            .map(|(a, b)| (a.0, b.0))\n            .collect::<Vec<_>>();\n        assert_eq!(results_after, vec![]);\n        let results_after_u64 = world\n            .query::<&W<u64>>()\n            .iter(&world)\n            .map(|v| v.0)\n            .collect::<Vec<_>>();\n        assert_eq!(results_after_u64, vec![]);\n    }\n\n    #[test]\n    fn remove_components_by_id() {\n        let mut world = World::default();\n\n        let mut command_queue = CommandQueue::default();\n        let (dense_dropck, dense_is_dropped) = DropCk::new_pair();\n        let (sparse_dropck, sparse_is_dropped) = DropCk::new_pair();\n        let sparse_dropck = SparseDropCk(sparse_dropck);\n\n        let entity = Commands::new(&mut command_queue, &world)\n            .spawn((W(1u32), W(2u64), dense_dropck, sparse_dropck))\n            .id();\n        command_queue.apply(&mut world);\n        let results_before = world\n            .query::<(&W<u32>, &W<u64>)>()\n            .iter(&world)\n            .map(|(a, b)| (a.0, b.0))\n            .collect::<Vec<_>>();\n        assert_eq!(results_before, vec![(1u32, 2u64)]);\n\n        // test component removal\n        Commands::new(&mut command_queue, &world)\n            .entity(entity)\n            .remove_by_id(world.components().get_id(TypeId::of::<W<u32>>()).unwrap())\n            .remove_by_id(world.components().get_id(TypeId::of::<W<u64>>()).unwrap())\n            .remove_by_id(world.components().get_id(TypeId::of::<DropCk>()).unwrap())\n            .remove_by_id(\n                world\n                    .components()\n                    .get_id(TypeId::of::<SparseDropCk>())\n                    .unwrap(),\n            );\n\n        assert_eq!(dense_is_dropped.load(Ordering::Relaxed), 0);\n        assert_eq!(sparse_is_dropped.load(Ordering::Relaxed), 0);\n        command_queue.apply(&mut world);\n        assert_eq!(dense_is_dropped.load(Ordering::Relaxed), 1);\n        assert_eq!(sparse_is_dropped.load(Ordering::Relaxed), 1);\n\n        let results_after = world\n            .query::<(&W<u32>, &W<u64>)>()\n            .iter(&world)\n            .map(|(a, b)| (a.0, b.0))\n            .collect::<Vec<_>>();\n        assert_eq!(results_after, vec![]);\n        let results_after_u64 = world\n            .query::<&W<u64>>()\n            .iter(&world)\n            .map(|v| v.0)\n            .collect::<Vec<_>>();\n        assert_eq!(results_after_u64, vec![]);\n    }\n\n    #[test]\n    fn remove_resources() {\n        let mut world = World::default();\n        let mut queue = CommandQueue::default();\n        {\n            let mut commands = Commands::new(&mut queue, &world);\n            commands.insert_resource(W(123i32));\n            commands.insert_resource(W(456.0f64));\n        }\n\n        queue.apply(&mut world);\n        assert!(world.contains_resource::<W<i32>>());\n        assert!(world.contains_resource::<W<f64>>());\n\n        {\n            let mut commands = Commands::new(&mut queue, &world);\n            // test resource removal\n            commands.remove_resource::<W<i32>>();\n        }\n        queue.apply(&mut world);\n        assert!(!world.contains_resource::<W<i32>>());\n        assert!(world.contains_resource::<W<f64>>());\n    }\n\n    #[test]\n    fn remove_component_with_required_components() {\n        #[derive(Component)]\n        #[require(Y)]\n        struct X;\n\n        #[derive(Component, Default)]\n        struct Y;\n\n        #[derive(Component)]\n        struct Z;\n\n        let mut world = World::default();\n        let mut queue = CommandQueue::default();\n        let e = {\n            let mut commands = Commands::new(&mut queue, &world);\n            commands.spawn((X, Z)).id()\n        };\n        queue.apply(&mut world);\n\n        assert!(world.get::<Y>(e).is_some());\n        assert!(world.get::<X>(e).is_some());\n        assert!(world.get::<Z>(e).is_some());\n\n        {\n            let mut commands = Commands::new(&mut queue, &world);\n            commands.entity(e).remove_with_requires::<X>();\n        }\n        queue.apply(&mut world);\n\n        assert!(world.get::<Y>(e).is_none());\n        assert!(world.get::<X>(e).is_none());\n\n        assert!(world.get::<Z>(e).is_some());\n    }\n\n    fn is_send<T: Send>() {}\n    fn is_sync<T: Sync>() {}\n\n    #[test]\n    fn test_commands_are_send_and_sync() {\n        is_send::<Commands>();\n        is_sync::<Commands>();\n    }\n\n    #[test]\n    fn append() {\n        let mut world = World::default();\n        let mut queue_1 = CommandQueue::default();\n        {\n            let mut commands = Commands::new(&mut queue_1, &world);\n            commands.insert_resource(W(123i32));\n        }\n        let mut queue_2 = CommandQueue::default();\n        {\n            let mut commands = Commands::new(&mut queue_2, &world);\n            commands.insert_resource(W(456.0f64));\n        }\n        queue_1.append(&mut queue_2);\n        queue_1.apply(&mut world);\n        assert!(world.contains_resource::<W<i32>>());\n        assert!(world.contains_resource::<W<f64>>());\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "c98f877b099669a6f7c4a4566bc6710e30c87ae4",
    "func": "mod cell;\nmod highlight_spacing;\nmod row;\nmod table;\nmod table_state;\n\npub use cell::*;\npub use highlight_spacing::*;\npub use row::*;\npub use table::*;\npub use table_state::*;\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "edf09dee6a08551de5f65c6082d24782f6d56970",
    "func": "use diesel::pg::sql_types::*;\nuse diesel::pg::Pg;\nuse diesel::query_builder::QueryFragment;\nuse diesel::result::QueryResult;\nuse diesel::sql_types::*;\n#[allow(unused_imports)]\nuse sea_query::{ArrayType, PostgresQueryBuilder, Value};\n\n#[allow(unused_imports)]\nuse super::macros::{bail, build, err, refine};\nuse super::{ExtractBuilder, TransformValue};\n\nimpl ExtractBuilder for Pg {\n    type Builder = PostgresQueryBuilder;\n\n    fn builder() -> Self::Builder {\n        PostgresQueryBuilder\n    }\n}\n\nimpl TransformValue for Pg {\n    fn transform_value(value: Value) -> QueryResult<Box<dyn QueryFragment<Self> + Send>> {\n        let transformed = match value {\n            Value::Bool(v) => build!(Bool, v),\n            Value::TinyInt(v) => build!(SmallInt, v.map(i16::from)),\n            Value::SmallInt(v) => build!(SmallInt, v),\n            Value::Int(v) => build!(Integer, v),\n            Value::BigInt(v) => build!(BigInt, v),\n            Value::TinyUnsigned(v) => build!(SmallInt, v.map(i16::from)),\n            Value::SmallUnsigned(v) => build!(Integer, v.map(i32::from)),\n            Value::Unsigned(v) => build!(BigInt, v.map(i64::from)),\n            // There is no i128 support, so hope the unsigned can be converted\n            Value::BigUnsigned(v) => {\n                let v = v\n                    .map(|v| {\n                        i64::try_from(v)\n                            .map_err(|_| err!(\"BigUnsigned cannot be represented as i64\"))\n                    })\n                    .transpose()?;\n                build!(BigInt, v)\n            }\n            Value::Float(v) => build!(Float, v),\n            Value::Double(v) => build!(Double, v),\n            Value::String(v) => build!(Text, v.map(|v| *v)),\n            Value::Char(v) => build!(Text, v.map(|v| v.to_string())),\n            Value::Bytes(v) => build!(Blob, v.map(|v| *v)),\n            #[cfg(feature = \"with-chrono\")]\n            Value::ChronoDate(v) => build!(Date, v.map(|v| *v)),\n            #[cfg(feature = \"with-chrono\")]\n            Value::ChronoTime(v) => build!(Time, v.map(|v| *v)),\n            #[cfg(feature = \"with-chrono\")]\n            Value::ChronoDateTime(v) => build!(Timestamp, v.map(|v| *v)),\n            #[cfg(feature = \"with-chrono\")]\n            Value::ChronoDateTimeUtc(v) => build!(Timestamptz, v.map(|v| *v)),\n            #[cfg(feature = \"with-chrono\")]\n            Value::ChronoDateTimeLocal(v) => build!(Timestamptz, v.map(|v| *v)),\n            #[cfg(feature = \"with-chrono\")]\n            Value::ChronoDateTimeWithTimeZone(v) => build!(Timestamptz, v.map(|v| *v)),\n            #[cfg(feature = \"with-time\")]\n            Value::TimeDate(v) => build!(Date, v.map(|v| *v)),\n            #[cfg(feature = \"with-time\")]\n            Value::TimeTime(v) => build!(Time, v.map(|v| *v)),\n            #[cfg(feature = \"with-time\")]\n            Value::TimeDateTime(v) => build!(Timestamp, v.map(|v| *v)),\n            #[cfg(feature = \"with-time\")]\n            Value::TimeDateTimeWithTimeZone(v) => build!(Timestamptz, v.map(|v| *v)),\n            #[cfg(feature = \"with-uuid\")]\n            Value::Uuid(v) => build!(Uuid, v.map(|v| *v)),\n            #[cfg(feature = \"with-rust_decimal-postgres\")]\n            Value::Decimal(v) => build!(Numeric, v.map(|v| *v)),\n            #[cfg(all(\n                feature = \"with-rust_decimal\",\n                not(feature = \"with-rust_decimal-postgres\")\n            ))]\n            Value::Decimal(_) => bail!(\"Enable feature with-rust_decimal-postgres\"),\n            #[cfg(feature = \"with-bigdecimal\")]\n            Value::BigDecimal(v) => build!(Numeric, v.map(|v| *v)),\n            #[cfg(feature = \"with-json\")]\n            Value::Json(v) => build!(Json, v.map(|v| *v)),\n            #[cfg(feature = \"with-ipnetwork\")]\n            Value::IpNetwork(v) => build!(Inet, v.map(|v| *v)),\n            #[cfg(feature = \"with-mac_address\")]\n            Value::MacAddress(v) => build!(MacAddr, v.map(|v| v.bytes())),\n            #[cfg(feature = \"postgres-array\")]\n            Value::Array(ty, v) => match ty {\n                ArrayType::Bool => build!(Array<Bool>, refine!(bool, ty, v)),\n                ArrayType::TinyInt => {\n                    build!(\n                        Array<SmallInt>,\n                        refine!(i8, ty, v)\n                            .map(|v| v.into_iter().map(i16::from).collect::<Vec<i16>>())\n                    )\n                }\n                ArrayType::SmallInt => build!(Array<SmallInt>, refine!(i16, ty, v)),\n                ArrayType::Int => build!(Array<Integer>, refine!(i32, ty, v)),\n                ArrayType::BigInt => build!(Array<BigInt>, refine!(i64, ty, v)),\n                ArrayType::TinyUnsigned => {\n                    build!(\n                        Array<SmallInt>,\n                        refine!(u8, ty, v)\n                            .map(|v| v.into_iter().map(i16::from).collect::<Vec<_>>())\n                    )\n                }\n                ArrayType::SmallUnsigned => {\n                    build!(\n                        Array<Integer>,\n                        refine!(u16, ty, v)\n                            .map(|v| v.into_iter().map(i32::from).collect::<Vec<_>>())\n                    )\n                }\n                ArrayType::Unsigned => {\n                    build!(\n                        Array<BigInt>,\n                        refine!(u32, ty, v)\n                            .map(|v| v.into_iter().map(i64::from).collect::<Vec<_>>())\n                    )\n                }\n                ArrayType::BigUnsigned => {\n                    build!(\n                        Array<BigInt>,\n                        refine!(u64, ty, v)\n                            .map(|v| v\n                                .into_iter()\n                                .map(|v| i64::try_from(v)\n                                    .map_err(|_| err!(\"BigUnsigned cannot be represented as i64\")))\n                                .collect::<Result<Vec<_>, _>>())\n                            .transpose()?\n                    )\n                }\n                ArrayType::Float => build!(Array<Float>, refine!(f32, ty, v)),\n                ArrayType::Double => build!(Array<Double>, refine!(f64, ty, v)),\n                ArrayType::String => build!(Array<Text>, refine!(String, ty, v)),\n                ArrayType::Char => {\n                    build!(\n                        Array<Text>,\n                        refine!(char, ty, v)\n                            .map(|v| v.into_iter().map(|v| v.to_string()).collect::<Vec<_>>())\n                    )\n                }\n                ArrayType::Bytes => build!(Array<Blob>, refine!(Vec<u8>, ty, v)),\n                #[cfg(feature = \"with-chrono\")]\n                ArrayType::ChronoDate => build!(Array<Date>, refine!(chrono::NaiveDate, ty, v)),\n                #[cfg(feature = \"with-chrono\")]\n                ArrayType::ChronoTime => build!(Array<Time>, refine!(chrono::NaiveTime, ty, v)),\n                #[cfg(feature = \"with-chrono\")]\n                ArrayType::ChronoDateTime => {\n                    build!(Array<Timestamp>, refine!(chrono::NaiveDateTime, ty, v))\n                }\n                #[cfg(feature = \"with-chrono\")]\n                ArrayType::ChronoDateTimeUtc => {\n                    build!(\n                        Array<Timestamptz>,\n                        refine!(chrono::DateTime<chrono::Utc>, ty, v)\n                    )\n                }\n                #[cfg(feature = \"with-chrono\")]\n                ArrayType::ChronoDateTimeLocal => {\n                    build!(\n                        Array<Timestamptz>,\n                        refine!(chrono::DateTime<chrono::Local>, ty, v)\n                    )\n                }\n                #[cfg(feature = \"with-chrono\")]\n                ArrayType::ChronoDateTimeWithTimeZone => {\n                    build!(\n                        Array<Timestamptz>,\n                        refine!(chrono::DateTime<chrono::FixedOffset>, ty, v)\n                    )\n                }\n                #[cfg(feature = \"with-time\")]\n                ArrayType::TimeDate => build!(Array<Date>, refine!(time::Date, ty, v)),\n                #[cfg(feature = \"with-time\")]\n                ArrayType::TimeTime => build!(Array<Time>, refine!(time::Time, ty, v)),\n                #[cfg(feature = \"with-time\")]\n                ArrayType::TimeDateTime => {\n                    build!(Array<Timestamp>, refine!(time::PrimitiveDateTime, ty, v))\n                }\n                #[cfg(feature = \"with-time\")]\n                ArrayType::TimeDateTimeWithTimeZone => {\n                    build!(Array<Timestamptz>, refine!(time::OffsetDateTime, ty, v))\n                }\n                #[cfg(feature = \"with-uuid\")]\n                ArrayType::Uuid => build!(Array<Uuid>, refine!(uuid::Uuid, ty, v)),\n                #[cfg(feature = \"with-rust_decimal-postgres\")]\n                ArrayType::Decimal => build!(Array<Numeric>, refine!(rust_decimal::Decimal, ty, v)),\n                #[cfg(all(\n                    feature = \"with-rust_decimal\",\n                    not(feature = \"with-rust_decimal-postgres\")\n                ))]\n                ArrayType::Decimal => bail!(\"Enable feature with-rust_decimal-postgres\"),\n                #[cfg(feature = \"with-bigdecimal\")]\n                ArrayType::BigDecimal => {\n                    build!(Array<Numeric>, refine!(bigdecimal::BigDecimal, ty, v))\n                }\n                #[cfg(feature = \"with-json\")]\n                ArrayType::Json => build!(Array<Json>, refine!(serde_json::Value, ty, v)),\n                #[cfg(feature = \"with-ipnetwork\")]\n                ArrayType::IpNetwork => build!(Array<Inet>, refine!(ipnetwork::IpNetwork, ty, v)),\n                #[cfg(feature = \"with-mac_address\")]\n                ArrayType::MacAddress => {\n                    build!(\n                        Array<MacAddr>,\n                        refine!(mac_address::MacAddress, ty, v)\n                            .map(|v| v.into_iter().map(|v| v.bytes()).collect::<Vec<_>>())\n                    )\n                }\n            },\n            #[cfg(feature = \"postgres-vector\")]\n            Value::Vector(v) => build!(pgvector::sql_types::Vector, v.map(|v| *v)),\n        };\n        Ok(transformed)\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "93096536d7ce47b60a7cbd96ad6849fcd555e659",
    "func": "//! SeaORM Entity. Generated by sea-orm-codegen 0.1.0\n\nuse sea_orm::entity::prelude::*;\n\n#[derive(Copy, Clone, Default, Debug, DeriveEntity)]\npub struct Entity;\n\nimpl EntityName for Entity {\n    fn table_name(&self) -> &str {\n        \"cake\"\n    }\n}\n\n#[derive(Clone, Debug, PartialEq, DeriveModel, DeriveActiveModel, Eq)]\npub struct Model {\n    pub id: i32,\n    pub name: Option<String> ,\n}\n\n#[derive(Copy, Clone, Debug, EnumIter, DeriveColumn)]\npub enum Column {\n    Id,\n    Name,\n}\n\n#[derive(Copy, Clone, Debug, EnumIter, DerivePrimaryKey)]\npub enum PrimaryKey {\n    Id,\n}\n\nimpl PrimaryKeyTrait for PrimaryKey {\n    type ValueType = i32;\n\n    fn auto_increment() -> bool {\n        true\n    }\n}\n\n#[derive(Copy, Clone, Debug, EnumIter)]\npub enum Relation {\n    Fruit,\n}\n\nimpl ColumnTrait for Column {\n    type EntityName = Entity;\n    fn def(&self) -> ColumnDef {\n        match self {\n            Self::Id => ColumnType::Integer.def(),\n            Self::Name => ColumnType::Text.def().null(),\n        }\n    }\n}\n\nimpl RelationTrait for Relation {\n    fn def(&self) -> RelationDef {\n        match self {\n            Self::Fruit => Entity::has_many(super::fruit::Entity).into(),\n        }\n    }\n}\n\nimpl Related<super::fruit::Entity> for Entity {\n    fn to() -> RelationDef {\n        Relation::Fruit.def()\n    }\n}\n\nimpl Related<super::filling::Entity> for Entity {\n    fn to() -> RelationDef {\n        super::cake_filling::Relation::Filling.def()\n    }\n    fn via() -> Option<RelationDef> {\n        Some(super::cake_filling::Relation::Cake.def().rev())\n    }\n}\n\nimpl ActiveModelBehavior for ActiveModel {}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "165e794cb55ffea429789e3648cb15692319caec",
    "func": "use sea_orm_migration::prelude::*;\n\n#[async_std::main]\nasync fn main() {\n    cli::run_cli(migration::Migrator).await;\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "bc2a213d7eb6657dc674ab76231b314032d7ae5a",
    "func": "use std::collections::HashMap;\n\nuse ahash::RandomState;\nuse crossfont::{\n    Error as RasterizerError, FontDesc, FontKey, GlyphKey, Metrics, Rasterize, RasterizedGlyph,\n    Rasterizer, Size, Slant, Style, Weight,\n};\nuse log::{error, info};\nuse unicode_width::UnicodeWidthChar;\n\nuse crate::config::font::{Font, FontDescription};\nuse crate::config::ui_config::Delta;\nuse crate::gl::types::*;\n\nuse super::builtin_font;\n\n/// `LoadGlyph` allows for copying a rasterized glyph into graphics memory.\npub trait LoadGlyph {\n    /// Load the rasterized glyph into GPU memory.\n    fn load_glyph(&mut self, rasterized: &RasterizedGlyph) -> Glyph;\n\n    /// Clear any state accumulated from previous loaded glyphs.\n    ///\n    /// This can, for instance, be used to reset the texture Atlas.\n    fn clear(&mut self);\n}\n\n#[derive(Copy, Clone, Debug)]\npub struct Glyph {\n    pub tex_id: GLuint,\n    pub multicolor: bool,\n    pub top: i16,\n    pub left: i16,\n    pub width: i16,\n    pub height: i16,\n    pub uv_bot: f32,\n    pub uv_left: f32,\n    pub uv_width: f32,\n    pub uv_height: f32,\n}\n\n/// Na\u00efve glyph cache.\n///\n/// Currently only keyed by `char`, and thus not possible to hold different\n/// representations of the same code point.\npub struct GlyphCache {\n    /// Cache of buffered glyphs.\n    cache: HashMap<GlyphKey, Glyph, RandomState>,\n\n    /// Rasterizer for loading new glyphs.\n    rasterizer: Rasterizer,\n\n    /// Regular font.\n    pub font_key: FontKey,\n\n    /// Bold font.\n    pub bold_key: FontKey,\n\n    /// Italic font.\n    pub italic_key: FontKey,\n\n    /// Bold italic font.\n    pub bold_italic_key: FontKey,\n\n    /// Font size.\n    pub font_size: crossfont::Size,\n\n    /// Font offset.\n    font_offset: Delta<i8>,\n\n    /// Glyph offset.\n    glyph_offset: Delta<i8>,\n\n    /// Font metrics.\n    metrics: Metrics,\n\n    /// Whether to use the built-in font for box drawing characters.\n    builtin_box_drawing: bool,\n}\n\nimpl GlyphCache {\n    pub fn new(mut rasterizer: Rasterizer, font: &Font) -> Result<GlyphCache, crossfont::Error> {\n        let (regular, bold, italic, bold_italic) = Self::compute_font_keys(font, &mut rasterizer)?;\n\n        // Need to load at least one glyph for the face before calling metrics.\n        // The glyph requested here ('m' at the time of writing) has no special\n        // meaning.\n        rasterizer.get_glyph(GlyphKey { font_key: regular, character: 'm', size: font.size() })?;\n\n        let metrics = rasterizer.metrics(regular, font.size())?;\n\n        Ok(Self {\n            cache: Default::default(),\n            rasterizer,\n            font_size: font.size(),\n            font_key: regular,\n            bold_key: bold,\n            italic_key: italic,\n            bold_italic_key: bold_italic,\n            font_offset: font.offset,\n            glyph_offset: font.glyph_offset,\n            metrics,\n            builtin_box_drawing: font.builtin_box_drawing,\n        })\n    }\n\n    fn load_glyphs_for_font<L: LoadGlyph>(&mut self, font: FontKey, loader: &mut L) {\n        let size = self.font_size;\n\n        // Cache all ascii characters.\n        for i in 32u8..=126u8 {\n            self.get(GlyphKey { font_key: font, character: i as char, size }, loader, true);\n        }\n    }\n\n    /// Computes font keys for (Regular, Bold, Italic, Bold Italic).\n    fn compute_font_keys(\n        font: &Font,\n        rasterizer: &mut Rasterizer,\n    ) -> Result<(FontKey, FontKey, FontKey, FontKey), crossfont::Error> {\n        let size = font.size();\n\n        // Load regular font.\n        let regular_desc = Self::make_desc(font.normal(), Slant::Normal, Weight::Normal);\n\n        let regular = Self::load_regular_font(rasterizer, &regular_desc, size)?;\n\n        // Helper to load a description if it is not the `regular_desc`.\n        let mut load_or_regular = |desc: FontDesc| {\n            if desc == regular_desc {\n                regular\n            } else {\n                rasterizer.load_font(&desc, size).unwrap_or(regular)\n            }\n        };\n\n        // Load bold font.\n        let bold_desc = Self::make_desc(&font.bold(), Slant::Normal, Weight::Bold);\n\n        let bold = load_or_regular(bold_desc);\n\n        // Load italic font.\n        let italic_desc = Self::make_desc(&font.italic(), Slant::Italic, Weight::Normal);\n\n        let italic = load_or_regular(italic_desc);\n\n        // Load bold italic font.\n        let bold_italic_desc = Self::make_desc(&font.bold_italic(), Slant::Italic, Weight::Bold);\n\n        let bold_italic = load_or_regular(bold_italic_desc);\n\n        Ok((regular, bold, italic, bold_italic))\n    }\n\n    fn load_regular_font(\n        rasterizer: &mut Rasterizer,\n        description: &FontDesc,\n        size: Size,\n    ) -> Result<FontKey, crossfont::Error> {\n        match rasterizer.load_font(description, size) {\n            Ok(font) => Ok(font),\n            Err(err) => {\n                error!(\"{}\", err);\n\n                let fallback_desc =\n                    Self::make_desc(Font::default().normal(), Slant::Normal, Weight::Normal);\n                rasterizer.load_font(&fallback_desc, size)\n            },\n        }\n    }\n\n    fn make_desc(desc: &FontDescription, slant: Slant, weight: Weight) -> FontDesc {\n        let style = if let Some(ref spec) = desc.style {\n            Style::Specific(spec.to_owned())\n        } else {\n            Style::Description { slant, weight }\n        };\n        FontDesc::new(desc.family.clone(), style)\n    }\n\n    /// Get a glyph from the font.\n    ///\n    /// If the glyph has never been loaded before, it will be rasterized and inserted into the\n    /// cache.\n    ///\n    /// # Errors\n    ///\n    /// This will fail when the glyph could not be rasterized. Usually this is due to the glyph\n    /// not being present in any font.\n    pub fn get<L>(&mut self, glyph_key: GlyphKey, loader: &mut L, show_missing: bool) -> Glyph\n    where\n        L: LoadGlyph + ?Sized,\n    {\n        // Try to load glyph from cache.\n        if let Some(glyph) = self.cache.get(&glyph_key) {\n            return *glyph;\n        };\n\n        // Rasterize the glyph using the built-in font for special characters or the user's font\n        // for everything else.\n        let rasterized = self\n            .builtin_box_drawing\n            .then(|| {\n                builtin_font::builtin_glyph(\n                    glyph_key.character,\n                    &self.metrics,\n                    &self.font_offset,\n                    &self.glyph_offset,\n                )\n            })\n            .flatten()\n            .map_or_else(|| self.rasterizer.get_glyph(glyph_key), Ok);\n\n        let glyph = match rasterized {\n            Ok(rasterized) => self.load_glyph(loader, rasterized),\n            // Load fallback glyph.\n            Err(RasterizerError::MissingGlyph(rasterized)) if show_missing => {\n                // Use `\\0` as \"missing\" glyph to cache it only once.\n                let missing_key = GlyphKey { character: '\\0', ..glyph_key };\n                if let Some(glyph) = self.cache.get(&missing_key) {\n                    *glyph\n                } else {\n                    // If no missing glyph was loaded yet, insert it as `\\0`.\n                    let glyph = self.load_glyph(loader, rasterized);\n                    self.cache.insert(missing_key, glyph);\n\n                    glyph\n                }\n            },\n            Err(_) => self.load_glyph(loader, Default::default()),\n        };\n\n        // Cache rasterized glyph.\n        *self.cache.entry(glyph_key).or_insert(glyph)\n    }\n\n    /// Load glyph into the atlas.\n    ///\n    /// This will apply all transforms defined for the glyph cache to the rasterized glyph before\n    pub fn load_glyph<L>(&self, loader: &mut L, mut glyph: RasterizedGlyph) -> Glyph\n    where\n        L: LoadGlyph + ?Sized,\n    {\n        glyph.left += i32::from(self.glyph_offset.x);\n        glyph.top += i32::from(self.glyph_offset.y);\n        glyph.top -= self.metrics.descent as i32;\n\n        // The metrics of zero-width characters are based on rendering\n        // the character after the current cell, with the anchor at the\n        // right side of the preceding character. Since we render the\n        // zero-width characters inside the preceding character, the\n        // anchor has been moved to the right by one cell.\n        if glyph.character.width() == Some(0) {\n            glyph.left += self.metrics.average_advance as i32;\n        }\n\n        // Add glyph to cache.\n        loader.load_glyph(&glyph)\n    }\n\n    /// Reset currently cached data in both GL and the registry to default state.\n    pub fn reset_glyph_cache<L: LoadGlyph>(&mut self, loader: &mut L) {\n        loader.clear();\n        self.cache = Default::default();\n\n        self.load_common_glyphs(loader);\n    }\n\n    /// Update the inner font size.\n    ///\n    /// NOTE: To reload the renderers's fonts [`Self::reset_glyph_cache`] should be called\n    /// afterwards.\n    pub fn update_font_size(&mut self, font: &Font) -> Result<(), crossfont::Error> {\n        // Update dpi scaling.\n        self.font_offset = font.offset;\n        self.glyph_offset = font.glyph_offset;\n\n        // Recompute font keys.\n        let (regular, bold, italic, bold_italic) =\n            Self::compute_font_keys(font, &mut self.rasterizer)?;\n\n        self.rasterizer.get_glyph(GlyphKey {\n            font_key: regular,\n            character: 'm',\n            size: font.size(),\n        })?;\n        let metrics = self.rasterizer.metrics(regular, font.size())?;\n\n        info!(\"Font size changed to {:?} px\", font.size().as_px());\n\n        self.font_size = font.size();\n        self.font_key = regular;\n        self.bold_key = bold;\n        self.italic_key = italic;\n        self.bold_italic_key = bold_italic;\n        self.metrics = metrics;\n        self.builtin_box_drawing = font.builtin_box_drawing;\n\n        Ok(())\n    }\n\n    pub fn font_metrics(&self) -> crossfont::Metrics {\n        self.metrics\n    }\n\n    /// Prefetch glyphs that are almost guaranteed to be loaded anyways.\n    pub fn load_common_glyphs<L: LoadGlyph>(&mut self, loader: &mut L) {\n        self.load_glyphs_for_font(self.font_key, loader);\n        self.load_glyphs_for_font(self.bold_key, loader);\n        self.load_glyphs_for_font(self.italic_key, loader);\n        self.load_glyphs_for_font(self.bold_italic_key, loader);\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "2a4770983a8682c03fd2a6e5d8b78c67e23caf5c",
    "func": "use std::{\n    io,\n    sync::{\n        atomic::{AtomicUsize, Ordering},\n        Arc,\n    },\n    thread,\n};\n\nuse actix_web::{middleware, web, App, HttpServer};\n\nasync fn hello() -> &'static str {\n    \"Hello world!\"\n}\n\n#[actix_web::main]\nasync fn main() -> io::Result<()> {\n    env_logger::init_from_env(env_logger::Env::new().default_filter_or(\"info\"));\n\n    let core_ids = core_affinity::get_core_ids().unwrap();\n    let n_core_ids = core_ids.len();\n    let next_core_id = Arc::new(AtomicUsize::new(0));\n\n    HttpServer::new(move || {\n        let pin = Arc::clone(&next_core_id).fetch_add(1, Ordering::AcqRel);\n        log::info!(\n            \"setting CPU affinity for worker {}: pinning to core {}\",\n            thread::current().name().unwrap(),\n            pin,\n        );\n        core_affinity::set_for_current(core_ids[pin]);\n\n        App::new()\n            .wrap(middleware::Logger::default())\n            .service(web::resource(\"/\").get(hello))\n    })\n    .bind((\"127.0.0.1\", 8080))?\n    .workers(n_core_ids)\n    .run()\n    .await\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "4ded5a906486ede8802826693faddf95724a1db4",
    "func": "//! Controls morph targets in a loaded scene.\n//!\n//! Illustrates:\n//!\n//! - How to access and modify individual morph target weights.\n//!   See the `update_weights` system for details.\n//! - How to read morph target names in `name_morphs`.\n//! - How to play morph target animations in `setup_animations`.\n\nuse bevy::prelude::*;\nuse std::f32::consts::PI;\n\nfn main() {\n    App::new()\n        .add_plugins(DefaultPlugins.set(WindowPlugin {\n            primary_window: Some(Window {\n                title: \"morph targets\".to_string(),\n                ..default()\n            }),\n            ..default()\n        }))\n        .insert_resource(AmbientLight {\n            brightness: 150.0,\n            ..default()\n        })\n        .add_systems(Startup, setup)\n        .add_systems(Update, (name_morphs, setup_animations))\n        .run();\n}\n\n#[derive(Resource)]\nstruct MorphData {\n    the_wave: Handle<AnimationClip>,\n    mesh: Handle<Mesh>,\n}\n\nfn setup(asset_server: Res<AssetServer>, mut commands: Commands) {\n    commands.insert_resource(MorphData {\n        the_wave: asset_server\n            .load(GltfAssetLabel::Animation(2).from_asset(\"models/animated/MorphStressTest.gltf\")),\n        mesh: asset_server.load(\n            GltfAssetLabel::Primitive {\n                mesh: 0,\n                primitive: 0,\n            }\n            .from_asset(\"models/animated/MorphStressTest.gltf\"),\n        ),\n    });\n    commands.spawn(SceneRoot(asset_server.load(\n        GltfAssetLabel::Scene(0).from_asset(\"models/animated/MorphStressTest.gltf\"),\n    )));\n    commands.spawn((\n        DirectionalLight::default(),\n        Transform::from_rotation(Quat::from_rotation_z(PI / 2.0)),\n    ));\n    commands.spawn((\n        Camera3d::default(),\n        Transform::from_xyz(3.0, 2.1, 10.2).looking_at(Vec3::ZERO, Vec3::Y),\n    ));\n}\n\n/// Plays an [`AnimationClip`] from the loaded [`Gltf`] on the [`AnimationPlayer`] created by the spawned scene.\nfn setup_animations(\n    mut has_setup: Local<bool>,\n    mut commands: Commands,\n    mut players: Query<(Entity, &Name, &mut AnimationPlayer)>,\n    morph_data: Res<MorphData>,\n    mut graphs: ResMut<Assets<AnimationGraph>>,\n) {\n    if *has_setup {\n        return;\n    }\n    for (entity, name, mut player) in &mut players {\n        // The name of the entity in the GLTF scene containing the AnimationPlayer for our morph targets is \"Main\"\n        if name.as_str() != \"Main\" {\n            continue;\n        }\n\n        let (graph, animation) = AnimationGraph::from_clip(morph_data.the_wave.clone());\n        commands\n            .entity(entity)\n            .insert(AnimationGraphHandle(graphs.add(graph)));\n\n        player.play(animation).repeat();\n        *has_setup = true;\n    }\n}\n\n/// You can get the target names in their corresponding [`Mesh`].\n/// They are in the order of the weights.\nfn name_morphs(\n    mut has_printed: Local<bool>,\n    morph_data: Res<MorphData>,\n    meshes: Res<Assets<Mesh>>,\n) {\n    if *has_printed {\n        return;\n    }\n\n    let Some(mesh) = meshes.get(&morph_data.mesh) else {\n        return;\n    };\n    let Some(names) = mesh.morph_target_names() else {\n        return;\n    };\n\n    info!(\"Target names:\");\n    for name in names {\n        info!(\"  {name}\");\n    }\n    *has_printed = true;\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "99d45984cbfd2704293c1b3f2a9242448dc60d89",
    "func": "use crate::lib::*;\n\nuse crate::de::{\n    Deserialize, Deserializer, EnumAccess, Error, MapAccess, SeqAccess, Unexpected, VariantAccess,\n    Visitor,\n};\n\nuse crate::seed::InPlaceSeed;\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nuse crate::de::size_hint;\n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct UnitVisitor;\n\nimpl<'de> Visitor<'de> for UnitVisitor {\n    type Value = ();\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(\"unit\")\n    }\n\n    fn visit_unit<E>(self) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Ok(())\n    }\n}\n\nimpl<'de> Deserialize<'de> for () {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        deserializer.deserialize_unit(UnitVisitor)\n    }\n}\n\n#[cfg(feature = \"unstable\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"unstable\")))]\nimpl<'de> Deserialize<'de> for ! {\n    fn deserialize<D>(_deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        Err(Error::custom(\"cannot deserialize `!`\"))\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct BoolVisitor;\n\nimpl<'de> Visitor<'de> for BoolVisitor {\n    type Value = bool;\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(\"a boolean\")\n    }\n\n    fn visit_bool<E>(self, v: bool) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Ok(v)\n    }\n}\n\nimpl<'de> Deserialize<'de> for bool {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        deserializer.deserialize_bool(BoolVisitor)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nmacro_rules! impl_deserialize_num {\n    ($primitive:ident, $nonzero:ident $(cfg($($cfg:tt)*))*, $deserialize:ident $($method:ident!($($val:ident : $visit:ident)*);)*) => {\n        impl_deserialize_num!($primitive, $deserialize $($method!($($val : $visit)*);)*);\n\n        $(#[cfg($($cfg)*)])*\n        impl<'de> Deserialize<'de> for num::$nonzero {\n            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n            where\n                D: Deserializer<'de>,\n            {\n                struct NonZeroVisitor;\n\n                impl<'de> Visitor<'de> for NonZeroVisitor {\n                    type Value = num::$nonzero;\n\n                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                        formatter.write_str(concat!(\"a nonzero \", stringify!($primitive)))\n                    }\n\n                    $($($method!(nonzero $primitive $val : $visit);)*)*\n                }\n\n                deserializer.$deserialize(NonZeroVisitor)\n            }\n        }\n\n        #[cfg(not(no_core_num_saturating))]\n        impl<'de> Deserialize<'de> for Saturating<$primitive> {\n            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n            where\n                D: Deserializer<'de>,\n            {\n                struct SaturatingVisitor;\n\n                impl<'de> Visitor<'de> for SaturatingVisitor {\n                    type Value = Saturating<$primitive>;\n\n                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                        formatter.write_str(\"integer with support for saturating semantics\")\n                    }\n\n                    $($($method!(saturating $primitive $val : $visit);)*)*\n                }\n\n                deserializer.$deserialize(SaturatingVisitor)\n            }\n        }\n    };\n\n    ($primitive:ident, $deserialize:ident $($method:ident!($($val:ident : $visit:ident)*);)*) => {\n        impl<'de> Deserialize<'de> for $primitive {\n            #[inline]\n            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n            where\n                D: Deserializer<'de>,\n            {\n                struct PrimitiveVisitor;\n\n                impl<'de> Visitor<'de> for PrimitiveVisitor {\n                    type Value = $primitive;\n\n                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                        formatter.write_str(stringify!($primitive))\n                    }\n\n                    $($($method!($val : $visit);)*)*\n                }\n\n                deserializer.$deserialize(PrimitiveVisitor)\n            }\n        }\n    };\n}\n\nmacro_rules! num_self {\n    ($ty:ident : $visit:ident) => {\n        #[inline]\n        fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>\n        where\n            E: Error,\n        {\n            Ok(v)\n        }\n    };\n\n    (nonzero $primitive:ident $ty:ident : $visit:ident) => {\n        fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>\n        where\n            E: Error,\n        {\n            if let Some(nonzero) = Self::Value::new(v) {\n                Ok(nonzero)\n            } else {\n                Err(Error::invalid_value(Unexpected::Unsigned(0), &self))\n            }\n        }\n    };\n\n    (saturating $primitive:ident $ty:ident : $visit:ident) => {\n        fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>\n        where\n            E: Error,\n        {\n            Ok(Saturating(v))\n        }\n    };\n}\n\nmacro_rules! num_as_self {\n    ($ty:ident : $visit:ident) => {\n        #[inline]\n        fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>\n        where\n            E: Error,\n        {\n            Ok(v as Self::Value)\n        }\n    };\n\n    (nonzero $primitive:ident $ty:ident : $visit:ident) => {\n        fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>\n        where\n            E: Error,\n        {\n            if let Some(nonzero) = Self::Value::new(v as $primitive) {\n                Ok(nonzero)\n            } else {\n                Err(Error::invalid_value(Unexpected::Unsigned(0), &self))\n            }\n        }\n    };\n\n    (saturating $primitive:ident $ty:ident : $visit:ident) => {\n        fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>\n        where\n            E: Error,\n        {\n            Ok(Saturating(v as $primitive))\n        }\n    };\n}\n\nmacro_rules! num_as_copysign_self {\n    ($ty:ident : $visit:ident) => {\n        #[inline]\n        fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>\n        where\n            E: Error,\n        {\n            #[cfg(any(no_float_copysign, not(feature = \"std\")))]\n            {\n                Ok(v as Self::Value)\n            }\n\n            #[cfg(all(not(no_float_copysign), feature = \"std\"))]\n            {\n                // Preserve sign of NaN. The `as` produces a nondeterministic sign.\n                let sign = if v.is_sign_positive() { 1.0 } else { -1.0 };\n                Ok((v as Self::Value).copysign(sign))\n            }\n        }\n    };\n}\n\nmacro_rules! int_to_int {\n    ($ty:ident : $visit:ident) => {\n        #[inline]\n        fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>\n        where\n            E: Error,\n        {\n            if Self::Value::min_value() as i64 <= v as i64\n                && v as i64 <= Self::Value::max_value() as i64\n            {\n                Ok(v as Self::Value)\n            } else {\n                Err(Error::invalid_value(Unexpected::Signed(v as i64), &self))\n            }\n        }\n    };\n\n    (nonzero $primitive:ident $ty:ident : $visit:ident) => {\n        fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>\n        where\n            E: Error,\n        {\n            if $primitive::min_value() as i64 <= v as i64\n                && v as i64 <= $primitive::max_value() as i64\n            {\n                if let Some(nonzero) = Self::Value::new(v as $primitive) {\n                    return Ok(nonzero);\n                }\n            }\n            Err(Error::invalid_value(Unexpected::Signed(v as i64), &self))\n        }\n    };\n\n    (saturating $primitive:ident $ty:ident : $visit:ident) => {\n        fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>\n        where\n            E: Error,\n        {\n            if (v as i64) < $primitive::MIN as i64 {\n                Ok(Saturating($primitive::MIN))\n            } else if ($primitive::MAX as i64) < v as i64 {\n                Ok(Saturating($primitive::MAX))\n            } else {\n                Ok(Saturating(v as $primitive))\n            }\n        }\n    };\n}\n\nmacro_rules! int_to_uint {\n    ($ty:ident : $visit:ident) => {\n        #[inline]\n        fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>\n        where\n            E: Error,\n        {\n            if 0 <= v && v as u64 <= Self::Value::max_value() as u64 {\n                Ok(v as Self::Value)\n            } else {\n                Err(Error::invalid_value(Unexpected::Signed(v as i64), &self))\n            }\n        }\n    };\n\n    (nonzero $primitive:ident $ty:ident : $visit:ident) => {\n        fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>\n        where\n            E: Error,\n        {\n            if 0 < v && v as u64 <= $primitive::max_value() as u64 {\n                if let Some(nonzero) = Self::Value::new(v as $primitive) {\n                    return Ok(nonzero);\n                }\n            }\n            Err(Error::invalid_value(Unexpected::Signed(v as i64), &self))\n        }\n    };\n\n    (saturating $primitive:ident $ty:ident : $visit:ident) => {\n        fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>\n        where\n            E: Error,\n        {\n            if v < 0 {\n                Ok(Saturating(0))\n            } else if ($primitive::MAX as u64) < v as u64 {\n                Ok(Saturating($primitive::MAX))\n            } else {\n                Ok(Saturating(v as $primitive))\n            }\n        }\n    };\n}\n\nmacro_rules! uint_to_self {\n    ($ty:ident : $visit:ident) => {\n        #[inline]\n        fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>\n        where\n            E: Error,\n        {\n            if v as u64 <= Self::Value::max_value() as u64 {\n                Ok(v as Self::Value)\n            } else {\n                Err(Error::invalid_value(Unexpected::Unsigned(v as u64), &self))\n            }\n        }\n    };\n\n    (nonzero $primitive:ident $ty:ident : $visit:ident) => {\n        fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>\n        where\n            E: Error,\n        {\n            if v as u64 <= $primitive::max_value() as u64 {\n                if let Some(nonzero) = Self::Value::new(v as $primitive) {\n                    return Ok(nonzero);\n                }\n            }\n            Err(Error::invalid_value(Unexpected::Unsigned(v as u64), &self))\n        }\n    };\n\n    (saturating $primitive:ident $ty:ident : $visit:ident) => {\n        fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>\n        where\n            E: Error,\n        {\n            if v as u64 <= $primitive::MAX as u64 {\n                Ok(Saturating(v as $primitive))\n            } else {\n                Ok(Saturating($primitive::MAX))\n            }\n        }\n    };\n}\n\nimpl_deserialize_num! {\n    i8, NonZeroI8 cfg(not(no_num_nonzero_signed)), deserialize_i8\n    num_self!(i8:visit_i8);\n    int_to_int!(i16:visit_i16 i32:visit_i32 i64:visit_i64);\n    uint_to_self!(u8:visit_u8 u16:visit_u16 u32:visit_u32 u64:visit_u64);\n}\n\nimpl_deserialize_num! {\n    i16, NonZeroI16 cfg(not(no_num_nonzero_signed)), deserialize_i16\n    num_self!(i16:visit_i16);\n    num_as_self!(i8:visit_i8);\n    int_to_int!(i32:visit_i32 i64:visit_i64);\n    uint_to_self!(u8:visit_u8 u16:visit_u16 u32:visit_u32 u64:visit_u64);\n}\n\nimpl_deserialize_num! {\n    i32, NonZeroI32 cfg(not(no_num_nonzero_signed)), deserialize_i32\n    num_self!(i32:visit_i32);\n    num_as_self!(i8:visit_i8 i16:visit_i16);\n    int_to_int!(i64:visit_i64);\n    uint_to_self!(u8:visit_u8 u16:visit_u16 u32:visit_u32 u64:visit_u64);\n}\n\nimpl_deserialize_num! {\n    i64, NonZeroI64 cfg(not(no_num_nonzero_signed)), deserialize_i64\n    num_self!(i64:visit_i64);\n    num_as_self!(i8:visit_i8 i16:visit_i16 i32:visit_i32);\n    uint_to_self!(u8:visit_u8 u16:visit_u16 u32:visit_u32 u64:visit_u64);\n}\n\nimpl_deserialize_num! {\n    isize, NonZeroIsize cfg(not(no_num_nonzero_signed)), deserialize_i64\n    num_as_self!(i8:visit_i8 i16:visit_i16);\n    int_to_int!(i32:visit_i32 i64:visit_i64);\n    uint_to_self!(u8:visit_u8 u16:visit_u16 u32:visit_u32 u64:visit_u64);\n}\n\nimpl_deserialize_num! {\n    u8, NonZeroU8, deserialize_u8\n    num_self!(u8:visit_u8);\n    int_to_uint!(i8:visit_i8 i16:visit_i16 i32:visit_i32 i64:visit_i64);\n    uint_to_self!(u16:visit_u16 u32:visit_u32 u64:visit_u64);\n}\n\nimpl_deserialize_num! {\n    u16, NonZeroU16, deserialize_u16\n    num_self!(u16:visit_u16);\n    num_as_self!(u8:visit_u8);\n    int_to_uint!(i8:visit_i8 i16:visit_i16 i32:visit_i32 i64:visit_i64);\n    uint_to_self!(u32:visit_u32 u64:visit_u64);\n}\n\nimpl_deserialize_num! {\n    u32, NonZeroU32, deserialize_u32\n    num_self!(u32:visit_u32);\n    num_as_self!(u8:visit_u8 u16:visit_u16);\n    int_to_uint!(i8:visit_i8 i16:visit_i16 i32:visit_i32 i64:visit_i64);\n    uint_to_self!(u64:visit_u64);\n}\n\nimpl_deserialize_num! {\n    u64, NonZeroU64, deserialize_u64\n    num_self!(u64:visit_u64);\n    num_as_self!(u8:visit_u8 u16:visit_u16 u32:visit_u32);\n    int_to_uint!(i8:visit_i8 i16:visit_i16 i32:visit_i32 i64:visit_i64);\n}\n\nimpl_deserialize_num! {\n    usize, NonZeroUsize, deserialize_u64\n    num_as_self!(u8:visit_u8 u16:visit_u16);\n    int_to_uint!(i8:visit_i8 i16:visit_i16 i32:visit_i32 i64:visit_i64);\n    uint_to_self!(u32:visit_u32 u64:visit_u64);\n}\n\nimpl_deserialize_num! {\n    f32, deserialize_f32\n    num_self!(f32:visit_f32);\n    num_as_copysign_self!(f64:visit_f64);\n    num_as_self!(i8:visit_i8 i16:visit_i16 i32:visit_i32 i64:visit_i64);\n    num_as_self!(u8:visit_u8 u16:visit_u16 u32:visit_u32 u64:visit_u64);\n}\n\nimpl_deserialize_num! {\n    f64, deserialize_f64\n    num_self!(f64:visit_f64);\n    num_as_copysign_self!(f32:visit_f32);\n    num_as_self!(i8:visit_i8 i16:visit_i16 i32:visit_i32 i64:visit_i64);\n    num_as_self!(u8:visit_u8 u16:visit_u16 u32:visit_u32 u64:visit_u64);\n}\n\nmacro_rules! num_128 {\n    ($ty:ident : $visit:ident) => {\n        fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>\n        where\n            E: Error,\n        {\n            if v as i128 >= Self::Value::min_value() as i128\n                && v as u128 <= Self::Value::max_value() as u128\n            {\n                Ok(v as Self::Value)\n            } else {\n                Err(Error::invalid_value(\n                    Unexpected::Other(stringify!($ty)),\n                    &self,\n                ))\n            }\n        }\n    };\n\n    (nonzero $primitive:ident $ty:ident : $visit:ident) => {\n        fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>\n        where\n            E: Error,\n        {\n            if v as i128 >= $primitive::min_value() as i128\n                && v as u128 <= $primitive::max_value() as u128\n            {\n                if let Some(nonzero) = Self::Value::new(v as $primitive) {\n                    Ok(nonzero)\n                } else {\n                    Err(Error::invalid_value(Unexpected::Unsigned(0), &self))\n                }\n            } else {\n                Err(Error::invalid_value(\n                    Unexpected::Other(stringify!($ty)),\n                    &self,\n                ))\n            }\n        }\n    };\n\n    (saturating $primitive:ident $ty:ident : $visit:ident) => {\n        fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>\n        where\n            E: Error,\n        {\n            if (v as i128) < $primitive::MIN as i128 {\n                Ok(Saturating($primitive::MIN))\n            } else if ($primitive::MAX as u128) < v as u128 {\n                Ok(Saturating($primitive::MAX))\n            } else {\n                Ok(Saturating(v as $primitive))\n            }\n        }\n    };\n}\n\nimpl_deserialize_num! {\n    i128, NonZeroI128 cfg(not(no_num_nonzero_signed)), deserialize_i128\n    num_self!(i128:visit_i128);\n    num_as_self!(i8:visit_i8 i16:visit_i16 i32:visit_i32 i64:visit_i64);\n    num_as_self!(u8:visit_u8 u16:visit_u16 u32:visit_u32 u64:visit_u64);\n    num_128!(u128:visit_u128);\n}\n\nimpl_deserialize_num! {\n    u128, NonZeroU128, deserialize_u128\n    num_self!(u128:visit_u128);\n    num_as_self!(u8:visit_u8 u16:visit_u16 u32:visit_u32 u64:visit_u64);\n    int_to_uint!(i8:visit_i8 i16:visit_i16 i32:visit_i32 i64:visit_i64);\n    num_128!(i128:visit_i128);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct CharVisitor;\n\nimpl<'de> Visitor<'de> for CharVisitor {\n    type Value = char;\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(\"a character\")\n    }\n\n    #[inline]\n    fn visit_char<E>(self, v: char) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Ok(v)\n    }\n\n    #[inline]\n    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        let mut iter = v.chars();\n        match (iter.next(), iter.next()) {\n            (Some(c), None) => Ok(c),\n            _ => Err(Error::invalid_value(Unexpected::Str(v), &self)),\n        }\n    }\n}\n\nimpl<'de> Deserialize<'de> for char {\n    #[inline]\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        deserializer.deserialize_char(CharVisitor)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nstruct StringVisitor;\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nstruct StringInPlaceVisitor<'a>(&'a mut String);\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl<'de> Visitor<'de> for StringVisitor {\n    type Value = String;\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(\"a string\")\n    }\n\n    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Ok(v.to_owned())\n    }\n\n    fn visit_string<E>(self, v: String) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Ok(v)\n    }\n\n    fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        match str::from_utf8(v) {\n            Ok(s) => Ok(s.to_owned()),\n            Err(_) => Err(Error::invalid_value(Unexpected::Bytes(v), &self)),\n        }\n    }\n\n    fn visit_byte_buf<E>(self, v: Vec<u8>) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        match String::from_utf8(v) {\n            Ok(s) => Ok(s),\n            Err(e) => Err(Error::invalid_value(\n                Unexpected::Bytes(&e.into_bytes()),\n                &self,\n            )),\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nimpl<'a, 'de> Visitor<'de> for StringInPlaceVisitor<'a> {\n    type Value = ();\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(\"a string\")\n    }\n\n    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        self.0.clear();\n        self.0.push_str(v);\n        Ok(())\n    }\n\n    fn visit_string<E>(self, v: String) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        *self.0 = v;\n        Ok(())\n    }\n\n    fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        match str::from_utf8(v) {\n            Ok(s) => {\n                self.0.clear();\n                self.0.push_str(s);\n                Ok(())\n            }\n            Err(_) => Err(Error::invalid_value(Unexpected::Bytes(v), &self)),\n        }\n    }\n\n    fn visit_byte_buf<E>(self, v: Vec<u8>) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        match String::from_utf8(v) {\n            Ok(s) => {\n                *self.0 = s;\n                Ok(())\n            }\n            Err(e) => Err(Error::invalid_value(\n                Unexpected::Bytes(&e.into_bytes()),\n                &self,\n            )),\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\n#[cfg_attr(docsrs, doc(cfg(any(feature = \"std\", feature = \"alloc\"))))]\nimpl<'de> Deserialize<'de> for String {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        deserializer.deserialize_string(StringVisitor)\n    }\n\n    fn deserialize_in_place<D>(deserializer: D, place: &mut Self) -> Result<(), D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        deserializer.deserialize_string(StringInPlaceVisitor(place))\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct StrVisitor;\n\nimpl<'a> Visitor<'a> for StrVisitor {\n    type Value = &'a str;\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(\"a borrowed string\")\n    }\n\n    fn visit_borrowed_str<E>(self, v: &'a str) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Ok(v) // so easy\n    }\n\n    fn visit_borrowed_bytes<E>(self, v: &'a [u8]) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        str::from_utf8(v).map_err(|_| Error::invalid_value(Unexpected::Bytes(v), &self))\n    }\n}\n\nimpl<'de: 'a, 'a> Deserialize<'de> for &'a str {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        deserializer.deserialize_str(StrVisitor)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct BytesVisitor;\n\nimpl<'a> Visitor<'a> for BytesVisitor {\n    type Value = &'a [u8];\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(\"a borrowed byte array\")\n    }\n\n    fn visit_borrowed_bytes<E>(self, v: &'a [u8]) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Ok(v)\n    }\n\n    fn visit_borrowed_str<E>(self, v: &'a str) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Ok(v.as_bytes())\n    }\n}\n\nimpl<'de: 'a, 'a> Deserialize<'de> for &'a [u8] {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        deserializer.deserialize_bytes(BytesVisitor)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(any(feature = \"std\", all(not(no_core_cstr), feature = \"alloc\")))]\nstruct CStringVisitor;\n\n#[cfg(any(feature = \"std\", all(not(no_core_cstr), feature = \"alloc\")))]\nimpl<'de> Visitor<'de> for CStringVisitor {\n    type Value = CString;\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(\"byte array\")\n    }\n\n    fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>\n    where\n        A: SeqAccess<'de>,\n    {\n        let capacity = size_hint::cautious::<u8>(seq.size_hint());\n        let mut values = Vec::<u8>::with_capacity(capacity);\n\n        while let Some(value) = tri!(seq.next_element()) {\n            values.push(value);\n        }\n\n        CString::new(values).map_err(Error::custom)\n    }\n\n    fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        CString::new(v).map_err(Error::custom)\n    }\n\n    fn visit_byte_buf<E>(self, v: Vec<u8>) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        CString::new(v).map_err(Error::custom)\n    }\n\n    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        CString::new(v).map_err(Error::custom)\n    }\n\n    fn visit_string<E>(self, v: String) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        CString::new(v).map_err(Error::custom)\n    }\n}\n\n#[cfg(any(feature = \"std\", all(not(no_core_cstr), feature = \"alloc\")))]\n#[cfg_attr(docsrs, doc(cfg(any(feature = \"std\", feature = \"alloc\"))))]\nimpl<'de> Deserialize<'de> for CString {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        deserializer.deserialize_byte_buf(CStringVisitor)\n    }\n}\n\nmacro_rules! forwarded_impl {\n    (\n        $(#[$attr:meta])*\n        ($($id:ident),*), $ty:ty, $func:expr\n    ) => {\n        $(#[$attr])*\n        impl<'de $(, $id : Deserialize<'de>,)*> Deserialize<'de> for $ty {\n            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n            where\n                D: Deserializer<'de>,\n            {\n                Deserialize::deserialize(deserializer).map($func)\n            }\n        }\n    }\n}\n\nforwarded_impl! {\n    #[cfg(any(feature = \"std\", all(not(no_core_cstr), feature = \"alloc\")))]\n    #[cfg_attr(docsrs, doc(cfg(any(feature = \"std\", feature = \"alloc\"))))]\n    (), Box<CStr>, CString::into_boxed_c_str\n}\n\nforwarded_impl! {\n    (T), Reverse<T>, Reverse\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct OptionVisitor<T> {\n    marker: PhantomData<T>,\n}\n\nimpl<'de, T> Visitor<'de> for OptionVisitor<T>\nwhere\n    T: Deserialize<'de>,\n{\n    type Value = Option<T>;\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(\"option\")\n    }\n\n    #[inline]\n    fn visit_unit<E>(self) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Ok(None)\n    }\n\n    #[inline]\n    fn visit_none<E>(self) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Ok(None)\n    }\n\n    #[inline]\n    fn visit_some<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        T::deserialize(deserializer).map(Some)\n    }\n\n    fn __private_visit_untagged_option<D>(self, deserializer: D) -> Result<Self::Value, ()>\n    where\n        D: Deserializer<'de>,\n    {\n        Ok(T::deserialize(deserializer).ok())\n    }\n}\n\nimpl<'de, T> Deserialize<'de> for Option<T>\nwhere\n    T: Deserialize<'de>,\n{\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        deserializer.deserialize_option(OptionVisitor {\n            marker: PhantomData,\n        })\n    }\n\n    // The Some variant's repr is opaque, so we can't play cute tricks with its\n    // tag to have deserialize_in_place build the content in place unconditionally.\n    //\n    // FIXME: investigate whether branching on the old value being Some to\n    // deserialize_in_place the value is profitable (probably data-dependent?)\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct PhantomDataVisitor<T: ?Sized> {\n    marker: PhantomData<T>,\n}\n\nimpl<'de, T> Visitor<'de> for PhantomDataVisitor<T>\nwhere\n    T: ?Sized,\n{\n    type Value = PhantomData<T>;\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(\"unit\")\n    }\n\n    #[inline]\n    fn visit_unit<E>(self) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Ok(PhantomData)\n    }\n}\n\nimpl<'de, T> Deserialize<'de> for PhantomData<T>\nwhere\n    T: ?Sized,\n{\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        let visitor = PhantomDataVisitor {\n            marker: PhantomData,\n        };\n        deserializer.deserialize_unit_struct(\"PhantomData\", visitor)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nmacro_rules! seq_impl {\n    (\n        $(#[$attr:meta])*\n        $ty:ident <T $(: $tbound1:ident $(+ $tbound2:ident)*)* $(, $typaram:ident : $bound1:ident $(+ $bound2:ident)*)*>,\n        $access:ident,\n        $clear:expr,\n        $with_capacity:expr,\n        $reserve:expr,\n        $insert:expr\n    ) => {\n        $(#[$attr])*\n        impl<'de, T $(, $typaram)*> Deserialize<'de> for $ty<T $(, $typaram)*>\n        where\n            T: Deserialize<'de> $(+ $tbound1 $(+ $tbound2)*)*,\n            $($typaram: $bound1 $(+ $bound2)*,)*\n        {\n            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n            where\n                D: Deserializer<'de>,\n            {\n                struct SeqVisitor<T $(, $typaram)*> {\n                    marker: PhantomData<$ty<T $(, $typaram)*>>,\n                }\n\n                impl<'de, T $(, $typaram)*> Visitor<'de> for SeqVisitor<T $(, $typaram)*>\n                where\n                    T: Deserialize<'de> $(+ $tbound1 $(+ $tbound2)*)*,\n                    $($typaram: $bound1 $(+ $bound2)*,)*\n                {\n                    type Value = $ty<T $(, $typaram)*>;\n\n                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                        formatter.write_str(\"a sequence\")\n                    }\n\n                    #[inline]\n                    fn visit_seq<A>(self, mut $access: A) -> Result<Self::Value, A::Error>\n                    where\n                        A: SeqAccess<'de>,\n                    {\n                        let mut values = $with_capacity;\n\n                        while let Some(value) = tri!($access.next_element()) {\n                            $insert(&mut values, value);\n                        }\n\n                        Ok(values)\n                    }\n                }\n\n                let visitor = SeqVisitor { marker: PhantomData };\n                deserializer.deserialize_seq(visitor)\n            }\n\n            fn deserialize_in_place<D>(deserializer: D, place: &mut Self) -> Result<(), D::Error>\n            where\n                D: Deserializer<'de>,\n            {\n                struct SeqInPlaceVisitor<'a, T: 'a $(, $typaram: 'a)*>(&'a mut $ty<T $(, $typaram)*>);\n\n                impl<'a, 'de, T $(, $typaram)*> Visitor<'de> for SeqInPlaceVisitor<'a, T $(, $typaram)*>\n                where\n                    T: Deserialize<'de> $(+ $tbound1 $(+ $tbound2)*)*,\n                    $($typaram: $bound1 $(+ $bound2)*,)*\n                {\n                    type Value = ();\n\n                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                        formatter.write_str(\"a sequence\")\n                    }\n\n                    #[inline]\n                    fn visit_seq<A>(mut self, mut $access: A) -> Result<Self::Value, A::Error>\n                    where\n                        A: SeqAccess<'de>,\n                    {\n                        $clear(&mut self.0);\n                        $reserve(&mut self.0, size_hint::cautious::<T>($access.size_hint()));\n\n                        // FIXME: try to overwrite old values here? (Vec, VecDeque, LinkedList)\n                        while let Some(value) = tri!($access.next_element()) {\n                            $insert(&mut self.0, value);\n                        }\n\n                        Ok(())\n                    }\n                }\n\n                deserializer.deserialize_seq(SeqInPlaceVisitor(place))\n            }\n        }\n    }\n}\n\n// Dummy impl of reserve\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\nfn nop_reserve<T>(_seq: T, _n: usize) {}\n\nseq_impl!(\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    #[cfg_attr(docsrs, doc(cfg(any(feature = \"std\", feature = \"alloc\"))))]\n    BinaryHeap<T: Ord>,\n    seq,\n    BinaryHeap::clear,\n    BinaryHeap::with_capacity(size_hint::cautious::<T>(seq.size_hint())),\n    BinaryHeap::reserve,\n    BinaryHeap::push\n);\n\nseq_impl!(\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    #[cfg_attr(docsrs, doc(cfg(any(feature = \"std\", feature = \"alloc\"))))]\n    BTreeSet<T: Eq + Ord>,\n    seq,\n    BTreeSet::clear,\n    BTreeSet::new(),\n    nop_reserve,\n    BTreeSet::insert\n);\n\nseq_impl!(\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    #[cfg_attr(docsrs, doc(cfg(any(feature = \"std\", feature = \"alloc\"))))]\n    LinkedList<T>,\n    seq,\n    LinkedList::clear,\n    LinkedList::new(),\n    nop_reserve,\n    LinkedList::push_back\n);\n\nseq_impl!(\n    #[cfg(feature = \"std\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"std\")))]\n    HashSet<T: Eq + Hash, S: BuildHasher + Default>,\n    seq,\n    HashSet::clear,\n    HashSet::with_capacity_and_hasher(size_hint::cautious::<T>(seq.size_hint()), S::default()),\n    HashSet::reserve,\n    HashSet::insert\n);\n\nseq_impl!(\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    #[cfg_attr(docsrs, doc(cfg(any(feature = \"std\", feature = \"alloc\"))))]\n    VecDeque<T>,\n    seq,\n    VecDeque::clear,\n    VecDeque::with_capacity(size_hint::cautious::<T>(seq.size_hint())),\n    VecDeque::reserve,\n    VecDeque::push_back\n);\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\n#[cfg_attr(docsrs, doc(cfg(any(feature = \"std\", feature = \"alloc\"))))]\nimpl<'de, T> Deserialize<'de> for Vec<T>\nwhere\n    T: Deserialize<'de>,\n{\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        struct VecVisitor<T> {\n            marker: PhantomData<T>,\n        }\n\n        impl<'de, T> Visitor<'de> for VecVisitor<T>\n        where\n            T: Deserialize<'de>,\n        {\n            type Value = Vec<T>;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(\"a sequence\")\n            }\n\n            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>\n            where\n                A: SeqAccess<'de>,\n            {\n                let capacity = size_hint::cautious::<T>(seq.size_hint());\n                let mut values = Vec::<T>::with_capacity(capacity);\n\n                while let Some(value) = tri!(seq.next_element()) {\n                    values.push(value);\n                }\n\n                Ok(values)\n            }\n        }\n\n        let visitor = VecVisitor {\n            marker: PhantomData,\n        };\n        deserializer.deserialize_seq(visitor)\n    }\n\n    fn deserialize_in_place<D>(deserializer: D, place: &mut Self) -> Result<(), D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        struct VecInPlaceVisitor<'a, T: 'a>(&'a mut Vec<T>);\n\n        impl<'a, 'de, T> Visitor<'de> for VecInPlaceVisitor<'a, T>\n        where\n            T: Deserialize<'de>,\n        {\n            type Value = ();\n\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(\"a sequence\")\n            }\n\n            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>\n            where\n                A: SeqAccess<'de>,\n            {\n                let hint = size_hint::cautious::<T>(seq.size_hint());\n                if let Some(additional) = hint.checked_sub(self.0.len()) {\n                    self.0.reserve(additional);\n                }\n\n                for i in 0..self.0.len() {\n                    let next = {\n                        let next_place = InPlaceSeed(&mut self.0[i]);\n                        tri!(seq.next_element_seed(next_place))\n                    };\n                    if next.is_none() {\n                        self.0.truncate(i);\n                        return Ok(());\n                    }\n                }\n\n                while let Some(value) = tri!(seq.next_element()) {\n                    self.0.push(value);\n                }\n\n                Ok(())\n            }\n        }\n\n        deserializer.deserialize_seq(VecInPlaceVisitor(place))\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct ArrayVisitor<A> {\n    marker: PhantomData<A>,\n}\nstruct ArrayInPlaceVisitor<'a, A: 'a>(&'a mut A);\n\nimpl<A> ArrayVisitor<A> {\n    fn new() -> Self {\n        ArrayVisitor {\n            marker: PhantomData,\n        }\n    }\n}\n\nimpl<'de, T> Visitor<'de> for ArrayVisitor<[T; 0]> {\n    type Value = [T; 0];\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(\"an empty array\")\n    }\n\n    #[inline]\n    fn visit_seq<A>(self, _: A) -> Result<Self::Value, A::Error>\n    where\n        A: SeqAccess<'de>,\n    {\n        Ok([])\n    }\n}\n\n// Does not require T: Deserialize<'de>.\nimpl<'de, T> Deserialize<'de> for [T; 0] {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        deserializer.deserialize_tuple(0, ArrayVisitor::<[T; 0]>::new())\n    }\n}\n\nmacro_rules! array_impls {\n    ($($len:expr => ($($n:tt)+))+) => {\n        $(\n            impl<'de, T> Visitor<'de> for ArrayVisitor<[T; $len]>\n            where\n                T: Deserialize<'de>,\n            {\n                type Value = [T; $len];\n\n                fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                    formatter.write_str(concat!(\"an array of length \", $len))\n                }\n\n                #[inline]\n                fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>\n                where\n                    A: SeqAccess<'de>,\n                {\n                    Ok([$(\n                        match tri!(seq.next_element()) {\n                            Some(val) => val,\n                            None => return Err(Error::invalid_length($n, &self)),\n                        }\n                    ),+])\n                }\n            }\n\n            impl<'a, 'de, T> Visitor<'de> for ArrayInPlaceVisitor<'a, [T; $len]>\n            where\n                T: Deserialize<'de>,\n            {\n                type Value = ();\n\n                fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                    formatter.write_str(concat!(\"an array of length \", $len))\n                }\n\n                #[inline]\n                fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>\n                where\n                    A: SeqAccess<'de>,\n                {\n                    let mut fail_idx = None;\n                    for (idx, dest) in self.0[..].iter_mut().enumerate() {\n                        if tri!(seq.next_element_seed(InPlaceSeed(dest))).is_none() {\n                            fail_idx = Some(idx);\n                            break;\n                        }\n                    }\n                    if let Some(idx) = fail_idx {\n                        return Err(Error::invalid_length(idx, &self));\n                    }\n                    Ok(())\n                }\n            }\n\n            impl<'de, T> Deserialize<'de> for [T; $len]\n            where\n                T: Deserialize<'de>,\n            {\n                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n                where\n                    D: Deserializer<'de>,\n                {\n                    deserializer.deserialize_tuple($len, ArrayVisitor::<[T; $len]>::new())\n                }\n\n                fn deserialize_in_place<D>(deserializer: D, place: &mut Self) -> Result<(), D::Error>\n                where\n                    D: Deserializer<'de>,\n                {\n                    deserializer.deserialize_tuple($len, ArrayInPlaceVisitor(place))\n                }\n            }\n        )+\n    }\n}\n\narray_impls! {\n    1 => (0)\n    2 => (0 1)\n    3 => (0 1 2)\n    4 => (0 1 2 3)\n    5 => (0 1 2 3 4)\n    6 => (0 1 2 3 4 5)\n    7 => (0 1 2 3 4 5 6)\n    8 => (0 1 2 3 4 5 6 7)\n    9 => (0 1 2 3 4 5 6 7 8)\n    10 => (0 1 2 3 4 5 6 7 8 9)\n    11 => (0 1 2 3 4 5 6 7 8 9 10)\n    12 => (0 1 2 3 4 5 6 7 8 9 10 11)\n    13 => (0 1 2 3 4 5 6 7 8 9 10 11 12)\n    14 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13)\n    15 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14)\n    16 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15)\n    17 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16)\n    18 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17)\n    19 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18)\n    20 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19)\n    21 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20)\n    22 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21)\n    23 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22)\n    24 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23)\n    25 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24)\n    26 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25)\n    27 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26)\n    28 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27)\n    29 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28)\n    30 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29)\n    31 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30)\n    32 => (0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31)\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nmacro_rules! tuple_impls {\n    ($($len:tt => ($($n:tt $name:ident)+))+) => {\n        $(\n            #[cfg_attr(docsrs, doc(hidden))]\n            impl<'de, $($name),+> Deserialize<'de> for ($($name,)+)\n            where\n                $($name: Deserialize<'de>,)+\n            {\n                tuple_impl_body!($len => ($($n $name)+));\n            }\n        )+\n    };\n}\n\nmacro_rules! tuple_impl_body {\n    ($len:tt => ($($n:tt $name:ident)+)) => {\n        #[inline]\n        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n        where\n            D: Deserializer<'de>,\n        {\n            struct TupleVisitor<$($name,)+> {\n                marker: PhantomData<($($name,)+)>,\n            }\n\n            impl<'de, $($name: Deserialize<'de>),+> Visitor<'de> for TupleVisitor<$($name,)+> {\n                type Value = ($($name,)+);\n\n                fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                    formatter.write_str(concat!(\"a tuple of size \", $len))\n                }\n\n                #[inline]\n                #[allow(non_snake_case)]\n                fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>\n                where\n                    A: SeqAccess<'de>,\n                {\n                    $(\n                        let $name = match tri!(seq.next_element()) {\n                            Some(value) => value,\n                            None => return Err(Error::invalid_length($n, &self)),\n                        };\n                    )+\n\n                    Ok(($($name,)+))\n                }\n            }\n\n            deserializer.deserialize_tuple($len, TupleVisitor { marker: PhantomData })\n        }\n\n        #[inline]\n        fn deserialize_in_place<D>(deserializer: D, place: &mut Self) -> Result<(), D::Error>\n        where\n            D: Deserializer<'de>,\n        {\n            struct TupleInPlaceVisitor<'a, $($name: 'a,)+>(&'a mut ($($name,)+));\n\n            impl<'a, 'de, $($name: Deserialize<'de>),+> Visitor<'de> for TupleInPlaceVisitor<'a, $($name,)+> {\n                type Value = ();\n\n                fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                    formatter.write_str(concat!(\"a tuple of size \", $len))\n                }\n\n                #[inline]\n                #[allow(non_snake_case)]\n                fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>\n                where\n                    A: SeqAccess<'de>,\n                {\n                    $(\n                        if tri!(seq.next_element_seed(InPlaceSeed(&mut (self.0).$n))).is_none() {\n                            return Err(Error::invalid_length($n, &self));\n                        }\n                    )+\n\n                    Ok(())\n                }\n            }\n\n            deserializer.deserialize_tuple($len, TupleInPlaceVisitor(place))\n        }\n    };\n}\n\n#[cfg_attr(docsrs, doc(fake_variadic))]\n#[cfg_attr(\n    docsrs,\n    doc = \"This trait is implemented for tuples up to 16 items long.\"\n)]\nimpl<'de, T> Deserialize<'de> for (T,)\nwhere\n    T: Deserialize<'de>,\n{\n    tuple_impl_body!(1 => (0 T));\n}\n\ntuple_impls! {\n    2  => (0 T0 1 T1)\n    3  => (0 T0 1 T1 2 T2)\n    4  => (0 T0 1 T1 2 T2 3 T3)\n    5  => (0 T0 1 T1 2 T2 3 T3 4 T4)\n    6  => (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5)\n    7  => (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6)\n    8  => (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7)\n    9  => (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8)\n    10 => (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9)\n    11 => (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10)\n    12 => (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11)\n    13 => (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11 12 T12)\n    14 => (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11 12 T12 13 T13)\n    15 => (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11 12 T12 13 T13 14 T14)\n    16 => (0 T0 1 T1 2 T2 3 T3 4 T4 5 T5 6 T6 7 T7 8 T8 9 T9 10 T10 11 T11 12 T12 13 T13 14 T14 15 T15)\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nmacro_rules! map_impl {\n    (\n        $(#[$attr:meta])*\n        $ty:ident <K $(: $kbound1:ident $(+ $kbound2:ident)*)*, V $(, $typaram:ident : $bound1:ident $(+ $bound2:ident)*)*>,\n        $access:ident,\n        $with_capacity:expr,\n    ) => {\n        $(#[$attr])*\n        impl<'de, K, V $(, $typaram)*> Deserialize<'de> for $ty<K, V $(, $typaram)*>\n        where\n            K: Deserialize<'de> $(+ $kbound1 $(+ $kbound2)*)*,\n            V: Deserialize<'de>,\n            $($typaram: $bound1 $(+ $bound2)*),*\n        {\n            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n            where\n                D: Deserializer<'de>,\n            {\n                struct MapVisitor<K, V $(, $typaram)*> {\n                    marker: PhantomData<$ty<K, V $(, $typaram)*>>,\n                }\n\n                impl<'de, K, V $(, $typaram)*> Visitor<'de> for MapVisitor<K, V $(, $typaram)*>\n                where\n                    K: Deserialize<'de> $(+ $kbound1 $(+ $kbound2)*)*,\n                    V: Deserialize<'de>,\n                    $($typaram: $bound1 $(+ $bound2)*),*\n                {\n                    type Value = $ty<K, V $(, $typaram)*>;\n\n                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                        formatter.write_str(\"a map\")\n                    }\n\n                    #[inline]\n                    fn visit_map<A>(self, mut $access: A) -> Result<Self::Value, A::Error>\n                    where\n                        A: MapAccess<'de>,\n                    {\n                        let mut values = $with_capacity;\n\n                        while let Some((key, value)) = tri!($access.next_entry()) {\n                            values.insert(key, value);\n                        }\n\n                        Ok(values)\n                    }\n                }\n\n                let visitor = MapVisitor { marker: PhantomData };\n                deserializer.deserialize_map(visitor)\n            }\n        }\n    }\n}\n\nmap_impl! {\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    #[cfg_attr(docsrs, doc(cfg(any(feature = \"std\", feature = \"alloc\"))))]\n    BTreeMap<K: Ord, V>,\n    map,\n    BTreeMap::new(),\n}\n\nmap_impl! {\n    #[cfg(feature = \"std\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"std\")))]\n    HashMap<K: Eq + Hash, V, S: BuildHasher + Default>,\n    map,\n    HashMap::with_capacity_and_hasher(size_hint::cautious::<(K, V)>(map.size_hint()), S::default()),\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(any(feature = \"std\", not(no_core_net)))]\nmacro_rules! parse_ip_impl {\n    ($ty:ty, $expecting:expr, $size:tt) => {\n        impl<'de> Deserialize<'de> for $ty {\n            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n            where\n                D: Deserializer<'de>,\n            {\n                if deserializer.is_human_readable() {\n                    deserializer.deserialize_str(FromStrVisitor::new($expecting))\n                } else {\n                    <[u8; $size]>::deserialize(deserializer).map(<$ty>::from)\n                }\n            }\n        }\n    };\n}\n\n#[cfg(any(feature = \"std\", not(no_core_net)))]\nmacro_rules! variant_identifier {\n    (\n        $name_kind:ident ($($variant:ident; $bytes:expr; $index:expr),*)\n        $expecting_message:expr,\n        $variants_name:ident\n    ) => {\n        enum $name_kind {\n            $($variant),*\n        }\n\n        static $variants_name: &[&str] = &[$(stringify!($variant)),*];\n\n        impl<'de> Deserialize<'de> for $name_kind {\n            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n            where\n                D: Deserializer<'de>,\n            {\n                struct KindVisitor;\n\n                impl<'de> Visitor<'de> for KindVisitor {\n                    type Value = $name_kind;\n\n                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                        formatter.write_str($expecting_message)\n                    }\n\n                    fn visit_u64<E>(self, value: u64) -> Result<Self::Value, E>\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            $(\n                                $index => Ok($name_kind :: $variant),\n                            )*\n                            _ => Err(Error::invalid_value(Unexpected::Unsigned(value), &self),),\n                        }\n                    }\n\n                    fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            $(\n                                stringify!($variant) => Ok($name_kind :: $variant),\n                            )*\n                            _ => Err(Error::unknown_variant(value, $variants_name)),\n                        }\n                    }\n\n                    fn visit_bytes<E>(self, value: &[u8]) -> Result<Self::Value, E>\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            $(\n                                $bytes => Ok($name_kind :: $variant),\n                            )*\n                            _ => {\n                                match str::from_utf8(value) {\n                                    Ok(value) => Err(Error::unknown_variant(value, $variants_name)),\n                                    Err(_) => Err(Error::invalid_value(Unexpected::Bytes(value), &self)),\n                                }\n                            }\n                        }\n                    }\n                }\n\n                deserializer.deserialize_identifier(KindVisitor)\n            }\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", not(no_core_net)))]\nmacro_rules! deserialize_enum {\n    (\n        $name:ident $name_kind:ident ($($variant:ident; $bytes:expr; $index:expr),*)\n        $expecting_message:expr,\n        $deserializer:expr\n    ) => {\n        variant_identifier! {\n            $name_kind ($($variant; $bytes; $index),*)\n            $expecting_message,\n            VARIANTS\n        }\n\n        struct EnumVisitor;\n        impl<'de> Visitor<'de> for EnumVisitor {\n            type Value = $name;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(concat!(\"a \", stringify!($name)))\n            }\n\n\n            fn visit_enum<A>(self, data: A) -> Result<Self::Value, A::Error>\n            where\n                A: EnumAccess<'de>,\n            {\n                match tri!(data.variant()) {\n                    $(\n                        ($name_kind :: $variant, v) => v.newtype_variant().map($name :: $variant),\n                    )*\n                }\n            }\n        }\n        $deserializer.deserialize_enum(stringify!($name), VARIANTS, EnumVisitor)\n    }\n}\n\n#[cfg(any(feature = \"std\", not(no_core_net)))]\nimpl<'de> Deserialize<'de> for net::IpAddr {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        if deserializer.is_human_readable() {\n            deserializer.deserialize_str(FromStrVisitor::new(\"IP address\"))\n        } else {\n            use crate::lib::net::IpAddr;\n            deserialize_enum! {\n                IpAddr IpAddrKind (V4; b\"V4\"; 0, V6; b\"V6\"; 1)\n                \"`V4` or `V6`\",\n                deserializer\n            }\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", not(no_core_net)))]\nparse_ip_impl!(net::Ipv4Addr, \"IPv4 address\", 4);\n\n#[cfg(any(feature = \"std\", not(no_core_net)))]\nparse_ip_impl!(net::Ipv6Addr, \"IPv6 address\", 16);\n\n#[cfg(any(feature = \"std\", not(no_core_net)))]\nmacro_rules! parse_socket_impl {\n    (\n        $ty:ty, $expecting:tt,\n        $new:expr,\n    ) => {\n        impl<'de> Deserialize<'de> for $ty {\n            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n            where\n                D: Deserializer<'de>,\n            {\n                if deserializer.is_human_readable() {\n                    deserializer.deserialize_str(FromStrVisitor::new($expecting))\n                } else {\n                    <(_, u16)>::deserialize(deserializer).map($new)\n                }\n            }\n        }\n    };\n}\n\n#[cfg(any(feature = \"std\", not(no_core_net)))]\nimpl<'de> Deserialize<'de> for net::SocketAddr {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        if deserializer.is_human_readable() {\n            deserializer.deserialize_str(FromStrVisitor::new(\"socket address\"))\n        } else {\n            use crate::lib::net::SocketAddr;\n            deserialize_enum! {\n                SocketAddr SocketAddrKind (V4; b\"V4\"; 0, V6; b\"V6\"; 1)\n                \"`V4` or `V6`\",\n                deserializer\n            }\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", not(no_core_net)))]\nparse_socket_impl! {\n    net::SocketAddrV4, \"IPv4 socket address\",\n    |(ip, port)| net::SocketAddrV4::new(ip, port),\n}\n\n#[cfg(any(feature = \"std\", not(no_core_net)))]\nparse_socket_impl! {\n    net::SocketAddrV6, \"IPv6 socket address\",\n    |(ip, port)| net::SocketAddrV6::new(ip, port, 0, 0),\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(feature = \"std\")]\nstruct PathVisitor;\n\n#[cfg(feature = \"std\")]\nimpl<'a> Visitor<'a> for PathVisitor {\n    type Value = &'a Path;\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(\"a borrowed path\")\n    }\n\n    fn visit_borrowed_str<E>(self, v: &'a str) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Ok(v.as_ref())\n    }\n\n    fn visit_borrowed_bytes<E>(self, v: &'a [u8]) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        str::from_utf8(v)\n            .map(AsRef::as_ref)\n            .map_err(|_| Error::invalid_value(Unexpected::Bytes(v), &self))\n    }\n}\n\n#[cfg(feature = \"std\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"std\")))]\nimpl<'de: 'a, 'a> Deserialize<'de> for &'a Path {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        deserializer.deserialize_str(PathVisitor)\n    }\n}\n\n#[cfg(feature = \"std\")]\nstruct PathBufVisitor;\n\n#[cfg(feature = \"std\")]\nimpl<'de> Visitor<'de> for PathBufVisitor {\n    type Value = PathBuf;\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(\"path string\")\n    }\n\n    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Ok(From::from(v))\n    }\n\n    fn visit_string<E>(self, v: String) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        Ok(From::from(v))\n    }\n\n    fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        str::from_utf8(v)\n            .map(From::from)\n            .map_err(|_| Error::invalid_value(Unexpected::Bytes(v), &self))\n    }\n\n    fn visit_byte_buf<E>(self, v: Vec<u8>) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        String::from_utf8(v)\n            .map(From::from)\n            .map_err(|e| Error::invalid_value(Unexpected::Bytes(&e.into_bytes()), &self))\n    }\n}\n\n#[cfg(feature = \"std\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"std\")))]\nimpl<'de> Deserialize<'de> for PathBuf {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        deserializer.deserialize_string(PathBufVisitor)\n    }\n}\n\nforwarded_impl! {\n    #[cfg(feature = \"std\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"std\")))]\n    (), Box<Path>, PathBuf::into_boxed_path\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n// If this were outside of the serde crate, it would just use:\n//\n//    #[derive(Deserialize)]\n//    #[serde(variant_identifier)]\n#[cfg(all(feature = \"std\", any(unix, windows)))]\nvariant_identifier! {\n    OsStringKind (Unix; b\"Unix\"; 0, Windows; b\"Windows\"; 1)\n    \"`Unix` or `Windows`\",\n    OSSTR_VARIANTS\n}\n\n#[cfg(all(feature = \"std\", any(unix, windows)))]\nstruct OsStringVisitor;\n\n#[cfg(all(feature = \"std\", any(unix, windows)))]\nimpl<'de> Visitor<'de> for OsStringVisitor {\n    type Value = OsString;\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(\"os string\")\n    }\n\n    #[cfg(unix)]\n    fn visit_enum<A>(self, data: A) -> Result<Self::Value, A::Error>\n    where\n        A: EnumAccess<'de>,\n    {\n        use std::os::unix::ffi::OsStringExt;\n\n        match tri!(data.variant()) {\n            (OsStringKind::Unix, v) => v.newtype_variant().map(OsString::from_vec),\n            (OsStringKind::Windows, _) => Err(Error::custom(\n                \"cannot deserialize Windows OS string on Unix\",\n            )),\n        }\n    }\n\n    #[cfg(windows)]\n    fn visit_enum<A>(self, data: A) -> Result<Self::Value, A::Error>\n    where\n        A: EnumAccess<'de>,\n    {\n        use std::os::windows::ffi::OsStringExt;\n\n        match tri!(data.variant()) {\n            (OsStringKind::Windows, v) => v\n                .newtype_variant::<Vec<u16>>()\n                .map(|vec| OsString::from_wide(&vec)),\n            (OsStringKind::Unix, _) => Err(Error::custom(\n                \"cannot deserialize Unix OS string on Windows\",\n            )),\n        }\n    }\n}\n\n#[cfg(all(feature = \"std\", any(unix, windows)))]\n#[cfg_attr(docsrs, doc(cfg(all(feature = \"std\", any(unix, windows)))))]\nimpl<'de> Deserialize<'de> for OsString {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        deserializer.deserialize_enum(\"OsString\", OSSTR_VARIANTS, OsStringVisitor)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nforwarded_impl! {\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    #[cfg_attr(docsrs, doc(cfg(any(feature = \"std\", feature = \"alloc\"))))]\n    (T), Box<T>, Box::new\n}\n\nforwarded_impl! {\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    #[cfg_attr(docsrs, doc(cfg(any(feature = \"std\", feature = \"alloc\"))))]\n    (T), Box<[T]>, Vec::into_boxed_slice\n}\n\nforwarded_impl! {\n    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n    #[cfg_attr(docsrs, doc(cfg(any(feature = \"std\", feature = \"alloc\"))))]\n    (), Box<str>, String::into_boxed_str\n}\n\nforwarded_impl! {\n    #[cfg(all(feature = \"std\", any(unix, windows)))]\n    #[cfg_attr(docsrs, doc(cfg(all(feature = \"std\", any(unix, windows)))))]\n    (), Box<OsStr>, OsString::into_boxed_os_str\n}\n\n#[cfg(any(feature = \"std\", feature = \"alloc\"))]\n#[cfg_attr(docsrs, doc(cfg(any(feature = \"std\", feature = \"alloc\"))))]\nimpl<'de, 'a, T> Deserialize<'de> for Cow<'a, T>\nwhere\n    T: ?Sized + ToOwned,\n    T::Owned: Deserialize<'de>,\n{\n    #[inline]\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        T::Owned::deserialize(deserializer).map(Cow::Owned)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n/// This impl requires the [`\"rc\"`] Cargo feature of Serde. The resulting\n/// `Weak<T>` has a reference count of 0 and cannot be upgraded.\n///\n/// [`\"rc\"`]: https://serde.rs/feature-flags.html#-features-rc\n#[cfg(all(feature = \"rc\", any(feature = \"std\", feature = \"alloc\")))]\n#[cfg_attr(\n    docsrs,\n    doc(cfg(all(feature = \"rc\", any(feature = \"std\", feature = \"alloc\"))))\n)]\nimpl<'de, T> Deserialize<'de> for RcWeak<T>\nwhere\n    T: Deserialize<'de>,\n{\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        tri!(Option::<T>::deserialize(deserializer));\n        Ok(RcWeak::new())\n    }\n}\n\n/// This impl requires the [`\"rc\"`] Cargo feature of Serde. The resulting\n/// `Weak<T>` has a reference count of 0 and cannot be upgraded.\n///\n/// [`\"rc\"`]: https://serde.rs/feature-flags.html#-features-rc\n#[cfg(all(feature = \"rc\", any(feature = \"std\", feature = \"alloc\")))]\n#[cfg_attr(\n    docsrs,\n    doc(cfg(all(feature = \"rc\", any(feature = \"std\", feature = \"alloc\"))))\n)]\nimpl<'de, T> Deserialize<'de> for ArcWeak<T>\nwhere\n    T: Deserialize<'de>,\n{\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        tri!(Option::<T>::deserialize(deserializer));\n        Ok(ArcWeak::new())\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nmacro_rules! box_forwarded_impl {\n    (\n        $(#[$attr:meta])*\n        $t:ident\n    ) => {\n        $(#[$attr])*\n        impl<'de, T> Deserialize<'de> for $t<T>\n        where\n            T: ?Sized,\n            Box<T>: Deserialize<'de>,\n        {\n            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n            where\n                D: Deserializer<'de>,\n            {\n                Box::deserialize(deserializer).map(Into::into)\n            }\n        }\n    };\n}\n\nbox_forwarded_impl! {\n    /// This impl requires the [`\"rc\"`] Cargo feature of Serde.\n    ///\n    /// Deserializing a data structure containing `Rc` will not attempt to\n    /// deduplicate `Rc` references to the same data. Every deserialized `Rc`\n    /// will end up with a strong count of 1.\n    ///\n    /// [`\"rc\"`]: https://serde.rs/feature-flags.html#-features-rc\n    #[cfg(all(feature = \"rc\", any(feature = \"std\", feature = \"alloc\")))]\n    #[cfg_attr(docsrs, doc(cfg(all(feature = \"rc\", any(feature = \"std\", feature = \"alloc\")))))]\n    Rc\n}\n\nbox_forwarded_impl! {\n    /// This impl requires the [`\"rc\"`] Cargo feature of Serde.\n    ///\n    /// Deserializing a data structure containing `Arc` will not attempt to\n    /// deduplicate `Arc` references to the same data. Every deserialized `Arc`\n    /// will end up with a strong count of 1.\n    ///\n    /// [`\"rc\"`]: https://serde.rs/feature-flags.html#-features-rc\n    #[cfg(all(feature = \"rc\", any(feature = \"std\", feature = \"alloc\")))]\n    #[cfg_attr(docsrs, doc(cfg(all(feature = \"rc\", any(feature = \"std\", feature = \"alloc\")))))]\n    Arc\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nimpl<'de, T> Deserialize<'de> for Cell<T>\nwhere\n    T: Deserialize<'de> + Copy,\n{\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        T::deserialize(deserializer).map(Cell::new)\n    }\n}\n\nforwarded_impl! {\n    (T), RefCell<T>, RefCell::new\n}\n\nforwarded_impl! {\n    #[cfg(feature = \"std\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"std\")))]\n    (T), Mutex<T>, Mutex::new\n}\n\nforwarded_impl! {\n    #[cfg(feature = \"std\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"std\")))]\n    (T), RwLock<T>, RwLock::new\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n// This is a cleaned-up version of the impl generated by:\n//\n//     #[derive(Deserialize)]\n//     #[serde(deny_unknown_fields)]\n//     struct Duration {\n//         secs: u64,\n//         nanos: u32,\n//     }\nimpl<'de> Deserialize<'de> for Duration {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        // If this were outside of the serde crate, it would just use:\n        //\n        //    #[derive(Deserialize)]\n        //    #[serde(field_identifier, rename_all = \"lowercase\")]\n        enum Field {\n            Secs,\n            Nanos,\n        }\n\n        impl<'de> Deserialize<'de> for Field {\n            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n            where\n                D: Deserializer<'de>,\n            {\n                struct FieldVisitor;\n\n                impl<'de> Visitor<'de> for FieldVisitor {\n                    type Value = Field;\n\n                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                        formatter.write_str(\"`secs` or `nanos`\")\n                    }\n\n                    fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            \"secs\" => Ok(Field::Secs),\n                            \"nanos\" => Ok(Field::Nanos),\n                            _ => Err(Error::unknown_field(value, FIELDS)),\n                        }\n                    }\n\n                    fn visit_bytes<E>(self, value: &[u8]) -> Result<Self::Value, E>\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            b\"secs\" => Ok(Field::Secs),\n                            b\"nanos\" => Ok(Field::Nanos),\n                            _ => {\n                                let value = crate::__private::from_utf8_lossy(value);\n                                Err(Error::unknown_field(&*value, FIELDS))\n                            }\n                        }\n                    }\n                }\n\n                deserializer.deserialize_identifier(FieldVisitor)\n            }\n        }\n\n        fn check_overflow<E>(secs: u64, nanos: u32) -> Result<(), E>\n        where\n            E: Error,\n        {\n            static NANOS_PER_SEC: u32 = 1_000_000_000;\n            match secs.checked_add((nanos / NANOS_PER_SEC) as u64) {\n                Some(_) => Ok(()),\n                None => Err(E::custom(\"overflow deserializing Duration\")),\n            }\n        }\n\n        struct DurationVisitor;\n\n        impl<'de> Visitor<'de> for DurationVisitor {\n            type Value = Duration;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(\"struct Duration\")\n            }\n\n            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>\n            where\n                A: SeqAccess<'de>,\n            {\n                let secs: u64 = match tri!(seq.next_element()) {\n                    Some(value) => value,\n                    None => {\n                        return Err(Error::invalid_length(0, &self));\n                    }\n                };\n                let nanos: u32 = match tri!(seq.next_element()) {\n                    Some(value) => value,\n                    None => {\n                        return Err(Error::invalid_length(1, &self));\n                    }\n                };\n                tri!(check_overflow(secs, nanos));\n                Ok(Duration::new(secs, nanos))\n            }\n\n            fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>\n            where\n                A: MapAccess<'de>,\n            {\n                let mut secs: Option<u64> = None;\n                let mut nanos: Option<u32> = None;\n                while let Some(key) = tri!(map.next_key()) {\n                    match key {\n                        Field::Secs => {\n                            if secs.is_some() {\n                                return Err(<A::Error as Error>::duplicate_field(\"secs\"));\n                            }\n                            secs = Some(tri!(map.next_value()));\n                        }\n                        Field::Nanos => {\n                            if nanos.is_some() {\n                                return Err(<A::Error as Error>::duplicate_field(\"nanos\"));\n                            }\n                            nanos = Some(tri!(map.next_value()));\n                        }\n                    }\n                }\n                let secs = match secs {\n                    Some(secs) => secs,\n                    None => return Err(<A::Error as Error>::missing_field(\"secs\")),\n                };\n                let nanos = match nanos {\n                    Some(nanos) => nanos,\n                    None => return Err(<A::Error as Error>::missing_field(\"nanos\")),\n                };\n                tri!(check_overflow(secs, nanos));\n                Ok(Duration::new(secs, nanos))\n            }\n        }\n\n        const FIELDS: &[&str] = &[\"secs\", \"nanos\"];\n        deserializer.deserialize_struct(\"Duration\", FIELDS, DurationVisitor)\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[cfg(feature = \"std\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"std\")))]\nimpl<'de> Deserialize<'de> for SystemTime {\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        // Reuse duration\n        enum Field {\n            Secs,\n            Nanos,\n        }\n\n        impl<'de> Deserialize<'de> for Field {\n            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n            where\n                D: Deserializer<'de>,\n            {\n                struct FieldVisitor;\n\n                impl<'de> Visitor<'de> for FieldVisitor {\n                    type Value = Field;\n\n                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                        formatter.write_str(\"`secs_since_epoch` or `nanos_since_epoch`\")\n                    }\n\n                    fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            \"secs_since_epoch\" => Ok(Field::Secs),\n                            \"nanos_since_epoch\" => Ok(Field::Nanos),\n                            _ => Err(Error::unknown_field(value, FIELDS)),\n                        }\n                    }\n\n                    fn visit_bytes<E>(self, value: &[u8]) -> Result<Self::Value, E>\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            b\"secs_since_epoch\" => Ok(Field::Secs),\n                            b\"nanos_since_epoch\" => Ok(Field::Nanos),\n                            _ => {\n                                let value = String::from_utf8_lossy(value);\n                                Err(Error::unknown_field(&value, FIELDS))\n                            }\n                        }\n                    }\n                }\n\n                deserializer.deserialize_identifier(FieldVisitor)\n            }\n        }\n\n        fn check_overflow<E>(secs: u64, nanos: u32) -> Result<(), E>\n        where\n            E: Error,\n        {\n            static NANOS_PER_SEC: u32 = 1_000_000_000;\n            match secs.checked_add((nanos / NANOS_PER_SEC) as u64) {\n                Some(_) => Ok(()),\n                None => Err(E::custom(\"overflow deserializing SystemTime epoch offset\")),\n            }\n        }\n\n        struct DurationVisitor;\n\n        impl<'de> Visitor<'de> for DurationVisitor {\n            type Value = Duration;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(\"struct SystemTime\")\n            }\n\n            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>\n            where\n                A: SeqAccess<'de>,\n            {\n                let secs: u64 = match tri!(seq.next_element()) {\n                    Some(value) => value,\n                    None => {\n                        return Err(Error::invalid_length(0, &self));\n                    }\n                };\n                let nanos: u32 = match tri!(seq.next_element()) {\n                    Some(value) => value,\n                    None => {\n                        return Err(Error::invalid_length(1, &self));\n                    }\n                };\n                tri!(check_overflow(secs, nanos));\n                Ok(Duration::new(secs, nanos))\n            }\n\n            fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>\n            where\n                A: MapAccess<'de>,\n            {\n                let mut secs: Option<u64> = None;\n                let mut nanos: Option<u32> = None;\n                while let Some(key) = tri!(map.next_key()) {\n                    match key {\n                        Field::Secs => {\n                            if secs.is_some() {\n                                return Err(<A::Error as Error>::duplicate_field(\n                                    \"secs_since_epoch\",\n                                ));\n                            }\n                            secs = Some(tri!(map.next_value()));\n                        }\n                        Field::Nanos => {\n                            if nanos.is_some() {\n                                return Err(<A::Error as Error>::duplicate_field(\n                                    \"nanos_since_epoch\",\n                                ));\n                            }\n                            nanos = Some(tri!(map.next_value()));\n                        }\n                    }\n                }\n                let secs = match secs {\n                    Some(secs) => secs,\n                    None => return Err(<A::Error as Error>::missing_field(\"secs_since_epoch\")),\n                };\n                let nanos = match nanos {\n                    Some(nanos) => nanos,\n                    None => return Err(<A::Error as Error>::missing_field(\"nanos_since_epoch\")),\n                };\n                tri!(check_overflow(secs, nanos));\n                Ok(Duration::new(secs, nanos))\n            }\n        }\n\n        const FIELDS: &[&str] = &[\"secs_since_epoch\", \"nanos_since_epoch\"];\n        let duration = tri!(deserializer.deserialize_struct(\"SystemTime\", FIELDS, DurationVisitor));\n        #[cfg(not(no_systemtime_checked_add))]\n        let ret = UNIX_EPOCH\n            .checked_add(duration)\n            .ok_or_else(|| D::Error::custom(\"overflow deserializing SystemTime\"));\n        #[cfg(no_systemtime_checked_add)]\n        let ret = Ok(UNIX_EPOCH + duration);\n        ret\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n// Similar to:\n//\n//     #[derive(Deserialize)]\n//     #[serde(deny_unknown_fields)]\n//     struct Range<Idx> {\n//         start: Idx,\n//         end: Idx,\n//     }\nimpl<'de, Idx> Deserialize<'de> for Range<Idx>\nwhere\n    Idx: Deserialize<'de>,\n{\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        let (start, end) = tri!(deserializer.deserialize_struct(\n            \"Range\",\n            range::FIELDS,\n            range::RangeVisitor {\n                expecting: \"struct Range\",\n                phantom: PhantomData,\n            },\n        ));\n        Ok(start..end)\n    }\n}\n\nimpl<'de, Idx> Deserialize<'de> for RangeInclusive<Idx>\nwhere\n    Idx: Deserialize<'de>,\n{\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        let (start, end) = tri!(deserializer.deserialize_struct(\n            \"RangeInclusive\",\n            range::FIELDS,\n            range::RangeVisitor {\n                expecting: \"struct RangeInclusive\",\n                phantom: PhantomData,\n            },\n        ));\n        Ok(RangeInclusive::new(start, end))\n    }\n}\n\nmod range {\n    use crate::lib::*;\n\n    use crate::de::{Deserialize, Deserializer, Error, MapAccess, SeqAccess, Visitor};\n\n    pub const FIELDS: &[&str] = &[\"start\", \"end\"];\n\n    // If this were outside of the serde crate, it would just use:\n    //\n    //    #[derive(Deserialize)]\n    //    #[serde(field_identifier, rename_all = \"lowercase\")]\n    enum Field {\n        Start,\n        End,\n    }\n\n    impl<'de> Deserialize<'de> for Field {\n        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n        where\n            D: Deserializer<'de>,\n        {\n            struct FieldVisitor;\n\n            impl<'de> Visitor<'de> for FieldVisitor {\n                type Value = Field;\n\n                fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                    formatter.write_str(\"`start` or `end`\")\n                }\n\n                fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>\n                where\n                    E: Error,\n                {\n                    match value {\n                        \"start\" => Ok(Field::Start),\n                        \"end\" => Ok(Field::End),\n                        _ => Err(Error::unknown_field(value, FIELDS)),\n                    }\n                }\n\n                fn visit_bytes<E>(self, value: &[u8]) -> Result<Self::Value, E>\n                where\n                    E: Error,\n                {\n                    match value {\n                        b\"start\" => Ok(Field::Start),\n                        b\"end\" => Ok(Field::End),\n                        _ => {\n                            let value = crate::__private::from_utf8_lossy(value);\n                            Err(Error::unknown_field(&*value, FIELDS))\n                        }\n                    }\n                }\n            }\n\n            deserializer.deserialize_identifier(FieldVisitor)\n        }\n    }\n\n    pub struct RangeVisitor<Idx> {\n        pub expecting: &'static str,\n        pub phantom: PhantomData<Idx>,\n    }\n\n    impl<'de, Idx> Visitor<'de> for RangeVisitor<Idx>\n    where\n        Idx: Deserialize<'de>,\n    {\n        type Value = (Idx, Idx);\n\n        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n            formatter.write_str(self.expecting)\n        }\n\n        fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>\n        where\n            A: SeqAccess<'de>,\n        {\n            let start: Idx = match tri!(seq.next_element()) {\n                Some(value) => value,\n                None => {\n                    return Err(Error::invalid_length(0, &self));\n                }\n            };\n            let end: Idx = match tri!(seq.next_element()) {\n                Some(value) => value,\n                None => {\n                    return Err(Error::invalid_length(1, &self));\n                }\n            };\n            Ok((start, end))\n        }\n\n        fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>\n        where\n            A: MapAccess<'de>,\n        {\n            let mut start: Option<Idx> = None;\n            let mut end: Option<Idx> = None;\n            while let Some(key) = tri!(map.next_key()) {\n                match key {\n                    Field::Start => {\n                        if start.is_some() {\n                            return Err(<A::Error as Error>::duplicate_field(\"start\"));\n                        }\n                        start = Some(tri!(map.next_value()));\n                    }\n                    Field::End => {\n                        if end.is_some() {\n                            return Err(<A::Error as Error>::duplicate_field(\"end\"));\n                        }\n                        end = Some(tri!(map.next_value()));\n                    }\n                }\n            }\n            let start = match start {\n                Some(start) => start,\n                None => return Err(<A::Error as Error>::missing_field(\"start\")),\n            };\n            let end = match end {\n                Some(end) => end,\n                None => return Err(<A::Error as Error>::missing_field(\"end\")),\n            };\n            Ok((start, end))\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n// Similar to:\n//\n//     #[derive(Deserialize)]\n//     #[serde(deny_unknown_fields)]\n//     struct RangeFrom<Idx> {\n//         start: Idx,\n//     }\nimpl<'de, Idx> Deserialize<'de> for RangeFrom<Idx>\nwhere\n    Idx: Deserialize<'de>,\n{\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        let start = tri!(deserializer.deserialize_struct(\n            \"RangeFrom\",\n            range_from::FIELDS,\n            range_from::RangeFromVisitor {\n                expecting: \"struct RangeFrom\",\n                phantom: PhantomData,\n            },\n        ));\n        Ok(start..)\n    }\n}\n\nmod range_from {\n    use crate::lib::*;\n\n    use crate::de::{Deserialize, Deserializer, Error, MapAccess, SeqAccess, Visitor};\n\n    pub const FIELDS: &[&str] = &[\"start\"];\n\n    // If this were outside of the serde crate, it would just use:\n    //\n    //    #[derive(Deserialize)]\n    //    #[serde(field_identifier, rename_all = \"lowercase\")]\n    enum Field {\n        Start,\n    }\n\n    impl<'de> Deserialize<'de> for Field {\n        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n        where\n            D: Deserializer<'de>,\n        {\n            struct FieldVisitor;\n\n            impl<'de> Visitor<'de> for FieldVisitor {\n                type Value = Field;\n\n                fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                    formatter.write_str(\"`start`\")\n                }\n\n                fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>\n                where\n                    E: Error,\n                {\n                    match value {\n                        \"start\" => Ok(Field::Start),\n                        _ => Err(Error::unknown_field(value, FIELDS)),\n                    }\n                }\n\n                fn visit_bytes<E>(self, value: &[u8]) -> Result<Self::Value, E>\n                where\n                    E: Error,\n                {\n                    match value {\n                        b\"start\" => Ok(Field::Start),\n                        _ => {\n                            let value = crate::__private::from_utf8_lossy(value);\n                            Err(Error::unknown_field(&*value, FIELDS))\n                        }\n                    }\n                }\n            }\n\n            deserializer.deserialize_identifier(FieldVisitor)\n        }\n    }\n\n    pub struct RangeFromVisitor<Idx> {\n        pub expecting: &'static str,\n        pub phantom: PhantomData<Idx>,\n    }\n\n    impl<'de, Idx> Visitor<'de> for RangeFromVisitor<Idx>\n    where\n        Idx: Deserialize<'de>,\n    {\n        type Value = Idx;\n\n        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n            formatter.write_str(self.expecting)\n        }\n\n        fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>\n        where\n            A: SeqAccess<'de>,\n        {\n            let start: Idx = match tri!(seq.next_element()) {\n                Some(value) => value,\n                None => {\n                    return Err(Error::invalid_length(0, &self));\n                }\n            };\n            Ok(start)\n        }\n\n        fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>\n        where\n            A: MapAccess<'de>,\n        {\n            let mut start: Option<Idx> = None;\n            while let Some(key) = tri!(map.next_key()) {\n                match key {\n                    Field::Start => {\n                        if start.is_some() {\n                            return Err(<A::Error as Error>::duplicate_field(\"start\"));\n                        }\n                        start = Some(tri!(map.next_value()));\n                    }\n                }\n            }\n            let start = match start {\n                Some(start) => start,\n                None => return Err(<A::Error as Error>::missing_field(\"start\")),\n            };\n            Ok(start)\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n// Similar to:\n//\n//     #[derive(Deserialize)]\n//     #[serde(deny_unknown_fields)]\n//     struct RangeTo<Idx> {\n//         end: Idx,\n//     }\nimpl<'de, Idx> Deserialize<'de> for RangeTo<Idx>\nwhere\n    Idx: Deserialize<'de>,\n{\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        let end = tri!(deserializer.deserialize_struct(\n            \"RangeTo\",\n            range_to::FIELDS,\n            range_to::RangeToVisitor {\n                expecting: \"struct RangeTo\",\n                phantom: PhantomData,\n            },\n        ));\n        Ok(..end)\n    }\n}\n\nmod range_to {\n    use crate::lib::*;\n\n    use crate::de::{Deserialize, Deserializer, Error, MapAccess, SeqAccess, Visitor};\n\n    pub const FIELDS: &[&str] = &[\"end\"];\n\n    // If this were outside of the serde crate, it would just use:\n    //\n    //    #[derive(Deserialize)]\n    //    #[serde(field_identifier, rename_all = \"lowercase\")]\n    enum Field {\n        End,\n    }\n\n    impl<'de> Deserialize<'de> for Field {\n        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n        where\n            D: Deserializer<'de>,\n        {\n            struct FieldVisitor;\n\n            impl<'de> Visitor<'de> for FieldVisitor {\n                type Value = Field;\n\n                fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                    formatter.write_str(\"`end`\")\n                }\n\n                fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>\n                where\n                    E: Error,\n                {\n                    match value {\n                        \"end\" => Ok(Field::End),\n                        _ => Err(Error::unknown_field(value, FIELDS)),\n                    }\n                }\n\n                fn visit_bytes<E>(self, value: &[u8]) -> Result<Self::Value, E>\n                where\n                    E: Error,\n                {\n                    match value {\n                        b\"end\" => Ok(Field::End),\n                        _ => {\n                            let value = crate::__private::from_utf8_lossy(value);\n                            Err(Error::unknown_field(&*value, FIELDS))\n                        }\n                    }\n                }\n            }\n\n            deserializer.deserialize_identifier(FieldVisitor)\n        }\n    }\n\n    pub struct RangeToVisitor<Idx> {\n        pub expecting: &'static str,\n        pub phantom: PhantomData<Idx>,\n    }\n\n    impl<'de, Idx> Visitor<'de> for RangeToVisitor<Idx>\n    where\n        Idx: Deserialize<'de>,\n    {\n        type Value = Idx;\n\n        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n            formatter.write_str(self.expecting)\n        }\n\n        fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>\n        where\n            A: SeqAccess<'de>,\n        {\n            let end: Idx = match tri!(seq.next_element()) {\n                Some(value) => value,\n                None => {\n                    return Err(Error::invalid_length(0, &self));\n                }\n            };\n            Ok(end)\n        }\n\n        fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>\n        where\n            A: MapAccess<'de>,\n        {\n            let mut end: Option<Idx> = None;\n            while let Some(key) = tri!(map.next_key()) {\n                match key {\n                    Field::End => {\n                        if end.is_some() {\n                            return Err(<A::Error as Error>::duplicate_field(\"end\"));\n                        }\n                        end = Some(tri!(map.next_value()));\n                    }\n                }\n            }\n            let end = match end {\n                Some(end) => end,\n                None => return Err(<A::Error as Error>::missing_field(\"end\")),\n            };\n            Ok(end)\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nimpl<'de, T> Deserialize<'de> for Bound<T>\nwhere\n    T: Deserialize<'de>,\n{\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        enum Field {\n            Unbounded,\n            Included,\n            Excluded,\n        }\n\n        impl<'de> Deserialize<'de> for Field {\n            #[inline]\n            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n            where\n                D: Deserializer<'de>,\n            {\n                struct FieldVisitor;\n\n                impl<'de> Visitor<'de> for FieldVisitor {\n                    type Value = Field;\n\n                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                        formatter.write_str(\"`Unbounded`, `Included` or `Excluded`\")\n                    }\n\n                    fn visit_u64<E>(self, value: u64) -> Result<Self::Value, E>\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            0 => Ok(Field::Unbounded),\n                            1 => Ok(Field::Included),\n                            2 => Ok(Field::Excluded),\n                            _ => Err(Error::invalid_value(Unexpected::Unsigned(value), &self)),\n                        }\n                    }\n\n                    fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            \"Unbounded\" => Ok(Field::Unbounded),\n                            \"Included\" => Ok(Field::Included),\n                            \"Excluded\" => Ok(Field::Excluded),\n                            _ => Err(Error::unknown_variant(value, VARIANTS)),\n                        }\n                    }\n\n                    fn visit_bytes<E>(self, value: &[u8]) -> Result<Self::Value, E>\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            b\"Unbounded\" => Ok(Field::Unbounded),\n                            b\"Included\" => Ok(Field::Included),\n                            b\"Excluded\" => Ok(Field::Excluded),\n                            _ => match str::from_utf8(value) {\n                                Ok(value) => Err(Error::unknown_variant(value, VARIANTS)),\n                                Err(_) => {\n                                    Err(Error::invalid_value(Unexpected::Bytes(value), &self))\n                                }\n                            },\n                        }\n                    }\n                }\n\n                deserializer.deserialize_identifier(FieldVisitor)\n            }\n        }\n\n        struct BoundVisitor<T>(PhantomData<Bound<T>>);\n\n        impl<'de, T> Visitor<'de> for BoundVisitor<T>\n        where\n            T: Deserialize<'de>,\n        {\n            type Value = Bound<T>;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(\"enum Bound\")\n            }\n\n            fn visit_enum<A>(self, data: A) -> Result<Self::Value, A::Error>\n            where\n                A: EnumAccess<'de>,\n            {\n                match tri!(data.variant()) {\n                    (Field::Unbounded, v) => v.unit_variant().map(|()| Bound::Unbounded),\n                    (Field::Included, v) => v.newtype_variant().map(Bound::Included),\n                    (Field::Excluded, v) => v.newtype_variant().map(Bound::Excluded),\n                }\n            }\n        }\n\n        const VARIANTS: &[&str] = &[\"Unbounded\", \"Included\", \"Excluded\"];\n\n        deserializer.deserialize_enum(\"Bound\", VARIANTS, BoundVisitor(PhantomData))\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nimpl<'de, T, E> Deserialize<'de> for Result<T, E>\nwhere\n    T: Deserialize<'de>,\n    E: Deserialize<'de>,\n{\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        // If this were outside of the serde crate, it would just use:\n        //\n        //    #[derive(Deserialize)]\n        //    #[serde(variant_identifier)]\n        enum Field {\n            Ok,\n            Err,\n        }\n\n        impl<'de> Deserialize<'de> for Field {\n            #[inline]\n            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n            where\n                D: Deserializer<'de>,\n            {\n                struct FieldVisitor;\n\n                impl<'de> Visitor<'de> for FieldVisitor {\n                    type Value = Field;\n\n                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                        formatter.write_str(\"`Ok` or `Err`\")\n                    }\n\n                    fn visit_u64<E>(self, value: u64) -> Result<Self::Value, E>\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            0 => Ok(Field::Ok),\n                            1 => Ok(Field::Err),\n                            _ => Err(Error::invalid_value(Unexpected::Unsigned(value), &self)),\n                        }\n                    }\n\n                    fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            \"Ok\" => Ok(Field::Ok),\n                            \"Err\" => Ok(Field::Err),\n                            _ => Err(Error::unknown_variant(value, VARIANTS)),\n                        }\n                    }\n\n                    fn visit_bytes<E>(self, value: &[u8]) -> Result<Self::Value, E>\n                    where\n                        E: Error,\n                    {\n                        match value {\n                            b\"Ok\" => Ok(Field::Ok),\n                            b\"Err\" => Ok(Field::Err),\n                            _ => match str::from_utf8(value) {\n                                Ok(value) => Err(Error::unknown_variant(value, VARIANTS)),\n                                Err(_) => {\n                                    Err(Error::invalid_value(Unexpected::Bytes(value), &self))\n                                }\n                            },\n                        }\n                    }\n                }\n\n                deserializer.deserialize_identifier(FieldVisitor)\n            }\n        }\n\n        struct ResultVisitor<T, E>(PhantomData<Result<T, E>>);\n\n        impl<'de, T, E> Visitor<'de> for ResultVisitor<T, E>\n        where\n            T: Deserialize<'de>,\n            E: Deserialize<'de>,\n        {\n            type Value = Result<T, E>;\n\n            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n                formatter.write_str(\"enum Result\")\n            }\n\n            fn visit_enum<A>(self, data: A) -> Result<Self::Value, A::Error>\n            where\n                A: EnumAccess<'de>,\n            {\n                match tri!(data.variant()) {\n                    (Field::Ok, v) => v.newtype_variant().map(Ok),\n                    (Field::Err, v) => v.newtype_variant().map(Err),\n                }\n            }\n        }\n\n        const VARIANTS: &[&str] = &[\"Ok\", \"Err\"];\n\n        deserializer.deserialize_enum(\"Result\", VARIANTS, ResultVisitor(PhantomData))\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nimpl<'de, T> Deserialize<'de> for Wrapping<T>\nwhere\n    T: Deserialize<'de>,\n{\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n    where\n        D: Deserializer<'de>,\n    {\n        Deserialize::deserialize(deserializer).map(Wrapping)\n    }\n}\n\n#[cfg(all(feature = \"std\", not(no_std_atomic)))]\nmacro_rules! atomic_impl {\n    ($($ty:ident $size:expr)*) => {\n        $(\n            #[cfg(any(no_target_has_atomic, target_has_atomic = $size))]\n            #[cfg_attr(docsrs, doc(cfg(all(feature = \"std\", target_has_atomic = $size))))]\n            impl<'de> Deserialize<'de> for $ty {\n                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n                where\n                    D: Deserializer<'de>,\n                {\n                    Deserialize::deserialize(deserializer).map(Self::new)\n                }\n            }\n        )*\n    };\n}\n\n#[cfg(all(feature = \"std\", not(no_std_atomic)))]\natomic_impl! {\n    AtomicBool \"8\"\n    AtomicI8 \"8\"\n    AtomicI16 \"16\"\n    AtomicI32 \"32\"\n    AtomicIsize \"ptr\"\n    AtomicU8 \"8\"\n    AtomicU16 \"16\"\n    AtomicU32 \"32\"\n    AtomicUsize \"ptr\"\n}\n\n#[cfg(all(feature = \"std\", not(no_std_atomic64)))]\natomic_impl! {\n    AtomicI64 \"64\"\n    AtomicU64 \"64\"\n}\n\n#[cfg(any(feature = \"std\", not(no_core_net)))]\nstruct FromStrVisitor<T> {\n    expecting: &'static str,\n    ty: PhantomData<T>,\n}\n\n#[cfg(any(feature = \"std\", not(no_core_net)))]\nimpl<T> FromStrVisitor<T> {\n    fn new(expecting: &'static str) -> Self {\n        FromStrVisitor {\n            expecting,\n            ty: PhantomData,\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", not(no_core_net)))]\nimpl<'de, T> Visitor<'de> for FromStrVisitor<T>\nwhere\n    T: str::FromStr,\n    T::Err: fmt::Display,\n{\n    type Value = T;\n\n    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(self.expecting)\n    }\n\n    fn visit_str<E>(self, s: &str) -> Result<Self::Value, E>\n    where\n        E: Error,\n    {\n        s.parse().map_err(Error::custom)\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "e4ec36a2133d1a26576f733987b815c04b88340b",
    "func": "fn main() {\n  tauri_build::build()\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "156e44fc0b092b229d87f393ec54f96e5b929c21",
    "func": "#![allow(clippy::unreadable_literal)]\n\n//! A module for defining color palettes.\n\npub mod material;\npub mod tailwind;\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "53a8bf7f66d185a10f39299a1c13cd27f830d47a",
    "func": "// Copyright 2024 Cloudflare, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! A simple HTTP application trait that maps a request to a response\n\nuse async_trait::async_trait;\nuse http::Response;\nuse log::{debug, error, trace};\nuse pingora_http::ResponseHeader;\nuse std::sync::Arc;\n\nuse crate::apps::HttpServerApp;\nuse crate::modules::http::{HttpModules, ModuleBuilder};\nuse crate::protocols::http::HttpTask;\nuse crate::protocols::http::ServerSession;\nuse crate::protocols::Stream;\nuse crate::server::ShutdownWatch;\n\n/// This trait defines how to map a request to a response\n#[async_trait]\npub trait ServeHttp {\n    /// Define the mapping from a request to a response.\n    /// Note that the request header is already read, but the implementation needs to read the\n    /// request body if any.\n    ///\n    /// # Limitation\n    /// In this API, the entire response has to be generated before the end of this call.\n    /// So it is not suitable for streaming response or interactive communications.\n    /// Users need to implement their own [`super::HttpServerApp`] for those use cases.\n    async fn response(&self, http_session: &mut ServerSession) -> Response<Vec<u8>>;\n}\n\n// TODO: remove this in favor of HttpServer?\n#[async_trait]\nimpl<SV> HttpServerApp for SV\nwhere\n    SV: ServeHttp + Send + Sync,\n{\n    async fn process_new_http(\n        self: &Arc<Self>,\n        mut http: ServerSession,\n        shutdown: &ShutdownWatch,\n    ) -> Option<Stream> {\n        match http.read_request().await {\n            Ok(res) => match res {\n                false => {\n                    debug!(\"Failed to read request header\");\n                    return None;\n                }\n                true => {\n                    debug!(\"Successfully get a new request\");\n                }\n            },\n            Err(e) => {\n                error!(\"HTTP server fails to read from downstream: {e}\");\n                return None;\n            }\n        }\n        trace!(\"{:?}\", http.req_header());\n        if *shutdown.borrow() {\n            http.set_keepalive(None);\n        } else {\n            http.set_keepalive(Some(60));\n        }\n        let new_response = self.response(&mut http).await;\n        let (parts, body) = new_response.into_parts();\n        let resp_header: ResponseHeader = parts.into();\n        match http.write_response_header(Box::new(resp_header)).await {\n            Ok(()) => {\n                debug!(\"HTTP response header done.\");\n            }\n            Err(e) => {\n                error!(\n                    \"HTTP server fails to write to downstream: {e}, {}\",\n                    http.request_summary()\n                );\n            }\n        }\n        if !body.is_empty() {\n            // TODO: check if chunked encoding is needed\n            match http.write_response_body(body.into(), true).await {\n                Ok(_) => debug!(\"HTTP response written.\"),\n                Err(e) => error!(\n                    \"HTTP server fails to write to downstream: {e}, {}\",\n                    http.request_summary()\n                ),\n            }\n        }\n        match http.finish().await {\n            Ok(c) => c,\n            Err(e) => {\n                error!(\"HTTP server fails to finish the request: {e}\");\n                None\n            }\n        }\n    }\n}\n\n/// A helper struct for HTTP server with http modules embedded\npub struct HttpServer<SV> {\n    app: SV,\n    modules: HttpModules,\n}\n\nimpl<SV> HttpServer<SV> {\n    /// Create a new [HttpServer] with the given app which implements [ServeHttp]\n    pub fn new_app(app: SV) -> Self {\n        HttpServer {\n            app,\n            modules: HttpModules::new(),\n        }\n    }\n\n    /// Add [ModuleBuilder] to this [HttpServer]\n    pub fn add_module(&mut self, module: ModuleBuilder) {\n        self.modules.add_module(module)\n    }\n}\n\n#[async_trait]\nimpl<SV> HttpServerApp for HttpServer<SV>\nwhere\n    SV: ServeHttp + Send + Sync,\n{\n    async fn process_new_http(\n        self: &Arc<Self>,\n        mut http: ServerSession,\n        shutdown: &ShutdownWatch,\n    ) -> Option<Stream> {\n        match http.read_request().await {\n            Ok(res) => match res {\n                false => {\n                    debug!(\"Failed to read request header\");\n                    return None;\n                }\n                true => {\n                    debug!(\"Successfully get a new request\");\n                }\n            },\n            Err(e) => {\n                error!(\"HTTP server fails to read from downstream: {e}\");\n                return None;\n            }\n        }\n        trace!(\"{:?}\", http.req_header());\n        if *shutdown.borrow() {\n            http.set_keepalive(None);\n        } else {\n            http.set_keepalive(Some(60));\n        }\n        let mut module_ctx = self.modules.build_ctx();\n        let req = http.req_header_mut();\n        module_ctx.request_header_filter(req).await.ok()?;\n        let new_response = self.app.response(&mut http).await;\n        let (parts, body) = new_response.into_parts();\n        let mut resp_header: ResponseHeader = parts.into();\n        module_ctx\n            .response_header_filter(&mut resp_header, body.is_empty())\n            .await\n            .ok()?;\n\n        let task = HttpTask::Header(Box::new(resp_header), body.is_empty());\n        trace!(\"{task:?}\");\n\n        match http.response_duplex_vec(vec![task]).await {\n            Ok(_) => {\n                debug!(\"HTTP response header done.\");\n            }\n            Err(e) => {\n                error!(\n                    \"HTTP server fails to write to downstream: {e}, {}\",\n                    http.request_summary()\n                );\n            }\n        }\n\n        let mut body = Some(body.into());\n        module_ctx.response_body_filter(&mut body, true).ok()?;\n\n        let task = HttpTask::Body(body, true);\n\n        trace!(\"{task:?}\");\n\n        // TODO: check if chunked encoding is needed\n        match http.response_duplex_vec(vec![task]).await {\n            Ok(_) => debug!(\"HTTP response written.\"),\n            Err(e) => error!(\n                \"HTTP server fails to write to downstream: {e}, {}\",\n                http.request_summary()\n            ),\n        }\n        match http.finish().await {\n            Ok(c) => c,\n            Err(e) => {\n                error!(\"HTTP server fails to finish the request: {e}\");\n                None\n            }\n        }\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "27c11c3dab3b1877a438b4b7f3bae0500cfb1a21",
    "func": "#![warn(rust_2018_idioms)]\n#![cfg(feature = \"full\")]\n#![cfg(windows)]\n#![cfg(not(miri))]\n\nuse tokio::process::Command;\nuse windows_sys::Win32::System::Threading::GetProcessId;\n\n#[tokio::test]\nasync fn obtain_raw_handle() {\n    let mut cmd = Command::new(\"cmd\");\n    cmd.kill_on_drop(true);\n    cmd.arg(\"/c\");\n    cmd.arg(\"pause\");\n\n    let child = cmd.spawn().unwrap();\n\n    let orig_id = child.id().expect(\"missing id\");\n    assert!(orig_id > 0);\n\n    let handle = child.raw_handle().expect(\"process stopped\");\n    let handled_id = unsafe { GetProcessId(handle as _) };\n    assert_eq!(handled_id, orig_id);\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "607d0fbec37e3e1626260a6e1ef3c7198c2e08f4",
    "func": "//! This example shows how to use a custom index.html and custom <HEAD> extensions\n//! to add things like stylesheets, scripts, and third-party JS libraries.\n\nuse dioxus::prelude::*;\n\nfn main() {\n    dioxus::LaunchBuilder::new()\n        .with_cfg(\n            dioxus::desktop::Config::new().with_custom_index(\n                r#\"\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>Dioxus app</title>\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <style>body { background-color: olive; }</style>\n  </head>\n  <body>\n    <h1>External HTML</h1>\n    <div id=\"main\"></div>\n  </body>\n</html>\n        \"#\n                .into(),\n            ),\n        )\n        .launch(app);\n}\n\nfn app() -> Element {\n    rsx! {\n        h1 { \"Custom HTML!\" }\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "a683a8957c2c55c0492dfc932ba7fc82deb43451",
    "func": "pub mod downloader;\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "5c7c27a1645d1101021c6bb09acc523b16cce2fb",
    "func": "//! SeaORM Entity. Generated by sea-orm-codegen 0.10.0\n\nuse sea_orm::entity::prelude::*;\n\n#[derive(Copy, Clone, Default, Debug, DeriveEntity)]\npub struct Entity;\n\nimpl EntityName for Entity {\n    fn schema_name(&self) -> Option< &str > {\n        Some(\"schema_name\")\n    }\n\n    fn table_name(&self) -> &str {\n        \"child\"\n    }\n}\n\n#[derive(Clone, Debug, PartialEq, DeriveModel, DeriveActiveModel, Eq)]\npub struct Model {\n    pub id: i32,\n    pub parent_id1: i32,\n    pub parent_id2: i32,\n}\n\n#[derive(Copy, Clone, Debug, EnumIter, DeriveColumn)]\npub enum Column {\n    Id,\n    ParentId1,\n    ParentId2,\n}\n\n#[derive(Copy, Clone, Debug, EnumIter, DerivePrimaryKey)]\npub enum PrimaryKey {\n    Id,\n}\n\nimpl PrimaryKeyTrait for PrimaryKey {\n    type ValueType = i32;\n    fn auto_increment() -> bool {\n        true\n    }\n}\n\n#[derive(Copy, Clone, Debug, EnumIter)]\npub enum Relation {\n    Parent,\n}\n\nimpl ColumnTrait for Column {\n    type EntityName = Entity;\n    fn def(&self) -> ColumnDef {\n        match self {\n            Self::Id => ColumnType::Integer.def(),\n            Self::ParentId1 => ColumnType::Integer.def(),\n            Self::ParentId2 => ColumnType::Integer.def(),\n        }\n    }\n}\n\nimpl RelationTrait for Relation {\n    fn def(&self) -> RelationDef {\n        match self {\n            Self::Parent => Entity::belongs_to(super::parent::Entity)\n                .from((Column::ParentId1, Column::ParentId2))\n                .to((super::parent::Column::Id1, super::parent::Column::Id2))\n                .into(),\n        }\n    }\n}\n\nimpl Related<super::parent::Entity> for Entity {\n    fn to() -> RelationDef {\n        Relation::Parent.def()\n    }\n}\n\nimpl ActiveModelBehavior for ActiveModel {}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "46398425810b39dbc13f55698350ecd4bbeeb4b0",
    "func": "//! This example illustrates the use of [`SubStates`] for more complex state handling patterns.\n//!\n//! [`SubStates`] are [`States`] that only exist while the App is in another [`State`]. They can\n//! be used to create more complex patterns while relying on simple enums, or to de-couple certain\n//! elements of complex state objects.\n//!\n//! In this case, we're transitioning from a `Menu` state to an `InGame` state, at which point we create\n//! a substate called `IsPaused` to track whether the game is paused or not.\n\nuse bevy::{dev_tools::states::*, prelude::*};\n\nuse ui::*;\n\n#[derive(Debug, Clone, Copy, Default, Eq, PartialEq, Hash, States)]\nenum AppState {\n    #[default]\n    Menu,\n    InGame,\n}\n\n// In this case, instead of deriving `States`, we derive `SubStates`\n#[derive(Debug, Clone, Copy, Default, Eq, PartialEq, Hash, SubStates)]\n// And we need to add an attribute to let us know what the source state is\n// and what value it needs to have. This will ensure that unless we're\n// in [`AppState::InGame`], the [`IsPaused`] state resource\n// will not exist.\n#[source(AppState = AppState::InGame)]\nenum IsPaused {\n    #[default]\n    Running,\n    Paused,\n}\n\nfn main() {\n    App::new()\n        .add_plugins(DefaultPlugins)\n        .init_state::<AppState>()\n        .add_sub_state::<IsPaused>() // We set the substate up here.\n        // Most of these remain the same\n        .add_systems(Startup, setup)\n        .add_systems(OnEnter(AppState::Menu), setup_menu)\n        .add_systems(Update, menu.run_if(in_state(AppState::Menu)))\n        .add_systems(OnExit(AppState::Menu), cleanup_menu)\n        .add_systems(OnEnter(AppState::InGame), setup_game)\n        .add_systems(OnEnter(IsPaused::Paused), setup_paused_screen)\n        .enable_state_scoped_entities::<IsPaused>()\n        .add_systems(\n            Update,\n            (\n                // Instead of relying on [`AppState::InGame`] here, we're relying on\n                // [`IsPaused::Running`], since we don't want movement or color changes\n                // if we're paused\n                (movement, change_color).run_if(in_state(IsPaused::Running)),\n                // The pause toggle, on the other hand, needs to work whether we're\n                // paused or not, so it uses [`AppState::InGame`] instead.\n                toggle_pause.run_if(in_state(AppState::InGame)),\n            ),\n        )\n        .add_systems(Update, log_transitions::<AppState>)\n        .run();\n}\n\nfn menu(\n    mut next_state: ResMut<NextState<AppState>>,\n    mut interaction_query: Query<\n        (&Interaction, &mut BackgroundColor),\n        (Changed<Interaction>, With<Button>),\n    >,\n) {\n    for (interaction, mut color) in &mut interaction_query {\n        match *interaction {\n            Interaction::Pressed => {\n                *color = PRESSED_BUTTON.into();\n                next_state.set(AppState::InGame);\n            }\n            Interaction::Hovered => {\n                *color = HOVERED_BUTTON.into();\n            }\n            Interaction::None => {\n                *color = NORMAL_BUTTON.into();\n            }\n        }\n    }\n}\n\nfn cleanup_menu(mut commands: Commands, menu_data: Res<MenuData>) {\n    commands.entity(menu_data.button_entity).despawn_recursive();\n}\n\nconst SPEED: f32 = 100.0;\nfn movement(\n    time: Res<Time>,\n    input: Res<ButtonInput<KeyCode>>,\n    mut query: Query<&mut Transform, With<Sprite>>,\n) {\n    for mut transform in &mut query {\n        let mut direction = Vec3::ZERO;\n        if input.pressed(KeyCode::ArrowLeft) {\n            direction.x -= 1.0;\n        }\n        if input.pressed(KeyCode::ArrowRight) {\n            direction.x += 1.0;\n        }\n        if input.pressed(KeyCode::ArrowUp) {\n            direction.y += 1.0;\n        }\n        if input.pressed(KeyCode::ArrowDown) {\n            direction.y -= 1.0;\n        }\n\n        if direction != Vec3::ZERO {\n            transform.translation += direction.normalize() * SPEED * time.delta_secs();\n        }\n    }\n}\n\nfn change_color(time: Res<Time>, mut query: Query<&mut Sprite>) {\n    for mut sprite in &mut query {\n        let new_color = LinearRgba {\n            blue: ops::sin(time.elapsed_secs() * 0.5) + 2.0,\n            ..LinearRgba::from(sprite.color)\n        };\n\n        sprite.color = new_color.into();\n    }\n}\n\nfn toggle_pause(\n    input: Res<ButtonInput<KeyCode>>,\n    current_state: Res<State<IsPaused>>,\n    mut next_state: ResMut<NextState<IsPaused>>,\n) {\n    if input.just_pressed(KeyCode::Space) {\n        next_state.set(match current_state.get() {\n            IsPaused::Running => IsPaused::Paused,\n            IsPaused::Paused => IsPaused::Running,\n        });\n    }\n}\n\nmod ui {\n    use crate::*;\n\n    #[derive(Resource)]\n    pub struct MenuData {\n        pub button_entity: Entity,\n    }\n\n    pub const NORMAL_BUTTON: Color = Color::srgb(0.15, 0.15, 0.15);\n    pub const HOVERED_BUTTON: Color = Color::srgb(0.25, 0.25, 0.25);\n    pub const PRESSED_BUTTON: Color = Color::srgb(0.35, 0.75, 0.35);\n\n    pub fn setup(mut commands: Commands) {\n        commands.spawn(Camera2d);\n    }\n\n    pub fn setup_menu(mut commands: Commands) {\n        let button_entity = commands\n            .spawn(Node {\n                // center button\n                width: Val::Percent(100.),\n                height: Val::Percent(100.),\n                justify_content: JustifyContent::Center,\n                align_items: AlignItems::Center,\n                ..default()\n            })\n            .with_children(|parent| {\n                parent\n                    .spawn((\n                        Button,\n                        Node {\n                            width: Val::Px(150.),\n                            height: Val::Px(65.),\n                            // horizontally center child text\n                            justify_content: JustifyContent::Center,\n                            // vertically center child text\n                            align_items: AlignItems::Center,\n                            ..default()\n                        },\n                        BackgroundColor(NORMAL_BUTTON),\n                    ))\n                    .with_children(|parent| {\n                        parent.spawn((\n                            Text::new(\"Play\"),\n                            TextFont {\n                                font_size: 33.0,\n                                ..default()\n                            },\n                            TextColor(Color::srgb(0.9, 0.9, 0.9)),\n                        ));\n                    });\n            })\n            .id();\n        commands.insert_resource(MenuData { button_entity });\n    }\n\n    pub fn setup_game(mut commands: Commands, asset_server: Res<AssetServer>) {\n        commands.spawn(Sprite::from_image(asset_server.load(\"branding/icon.png\")));\n    }\n\n    pub fn setup_paused_screen(mut commands: Commands) {\n        commands\n            .spawn((\n                StateScoped(IsPaused::Paused),\n                Node {\n                    // center button\n                    width: Val::Percent(100.),\n                    height: Val::Percent(100.),\n                    justify_content: JustifyContent::Center,\n                    align_items: AlignItems::Center,\n                    flex_direction: FlexDirection::Column,\n                    row_gap: Val::Px(10.),\n                    ..default()\n                },\n            ))\n            .with_children(|parent| {\n                parent\n                    .spawn((\n                        Node {\n                            width: Val::Px(400.),\n                            height: Val::Px(400.),\n                            // horizontally center child text\n                            justify_content: JustifyContent::Center,\n                            // vertically center child text\n                            align_items: AlignItems::Center,\n                            ..default()\n                        },\n                        BackgroundColor(NORMAL_BUTTON),\n                    ))\n                    .with_children(|parent| {\n                        parent.spawn((\n                            Text::new(\"Paused\"),\n                            TextFont {\n                                font_size: 33.0,\n                                ..default()\n                            },\n                            TextColor(Color::srgb(0.9, 0.9, 0.9)),\n                        ));\n                    });\n            });\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "b520484997588eb30f33945668f4d233652101f5",
    "func": "\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "b132c04cf050123ac269ab09a8a3fbb443a1ce5b",
    "func": "//! Example of how to draw to a texture from the CPU.\n//!\n//! You can set the values of individual pixels to whatever you want.\n//! Bevy provides user-friendly APIs that work with [`Color`](bevy::color::Color)\n//! values and automatically perform any necessary conversions and encoding\n//! into the texture's native pixel format.\n\nuse bevy::color::{color_difference::EuclideanDistance, palettes::css};\nuse bevy::prelude::*;\nuse bevy::render::{\n    render_asset::RenderAssetUsages,\n    render_resource::{Extent3d, TextureDimension, TextureFormat},\n};\nuse rand::Rng;\n\nconst IMAGE_WIDTH: u32 = 256;\nconst IMAGE_HEIGHT: u32 = 256;\n\nfn main() {\n    App::new()\n        .add_plugins(DefaultPlugins)\n        // In this example, we will use a fixed timestep to draw a pattern on the screen\n        // one pixel at a time, so the pattern will gradually emerge over time, and\n        // the speed at which it appears is not tied to the framerate.\n        // Let's make the fixed update very fast, so it doesn't take too long. :)\n        .insert_resource(Time::<Fixed>::from_hz(1024.0))\n        .add_systems(Startup, setup)\n        .add_systems(FixedUpdate, draw)\n        .run();\n}\n\n/// Store the image handle that we will draw to, here.\n#[derive(Resource)]\nstruct MyProcGenImage(Handle<Image>);\n\nfn setup(mut commands: Commands, mut images: ResMut<Assets<Image>>) {\n    // spawn a camera\n    commands.spawn(Camera2d);\n\n    // create an image that we are going to draw into\n    let mut image = Image::new_fill(\n        // 2D image of size 256x256\n        Extent3d {\n            width: IMAGE_WIDTH,\n            height: IMAGE_HEIGHT,\n            depth_or_array_layers: 1,\n        },\n        TextureDimension::D2,\n        // Initialize it with a beige color\n        &(css::BEIGE.to_u8_array()),\n        // Use the same encoding as the color we set\n        TextureFormat::Rgba8UnormSrgb,\n        RenderAssetUsages::MAIN_WORLD | RenderAssetUsages::RENDER_WORLD,\n    );\n\n    // to make it extra fancy, we can set the Alpha of each pixel\n    // so that it fades out in a circular fashion\n    for y in 0..IMAGE_HEIGHT {\n        for x in 0..IMAGE_WIDTH {\n            let center = Vec2::new(IMAGE_WIDTH as f32 / 2.0, IMAGE_HEIGHT as f32 / 2.0);\n            let max_radius = IMAGE_HEIGHT.min(IMAGE_WIDTH) as f32 / 2.0;\n            let r = Vec2::new(x as f32, y as f32).distance(center);\n            let a = 1.0 - (r / max_radius).clamp(0.0, 1.0);\n\n            // here we will set the A value by accessing the raw data bytes\n            // (it is the 4th byte of each pixel, as per our `TextureFormat`)\n\n            // find our pixel by its coordinates\n            let pixel_bytes = image.pixel_bytes_mut(UVec3::new(x, y, 0)).unwrap();\n            // convert our f32 to u8\n            pixel_bytes[3] = (a * u8::MAX as f32) as u8;\n        }\n    }\n\n    // add it to Bevy's assets, so it can be used for rendering\n    // this will give us a handle we can use\n    // (to display it in a sprite, or as part of UI, etc.)\n    let handle = images.add(image);\n\n    // create a sprite entity using our image\n    commands.spawn(Sprite::from_image(handle.clone()));\n    commands.insert_resource(MyProcGenImage(handle));\n}\n\n/// Every fixed update tick, draw one more pixel to make a spiral pattern\nfn draw(\n    my_handle: Res<MyProcGenImage>,\n    mut images: ResMut<Assets<Image>>,\n    // used to keep track of where we are\n    mut i: Local<u32>,\n    mut draw_color: Local<Color>,\n) {\n    let mut rng = rand::thread_rng();\n\n    if *i == 0 {\n        // Generate a random color on first run.\n        *draw_color = Color::linear_rgb(rng.gen(), rng.gen(), rng.gen());\n    }\n\n    // Get the image from Bevy's asset storage.\n    let image = images.get_mut(&my_handle.0).expect(\"Image not found\");\n\n    // Compute the position of the pixel to draw.\n\n    let center = Vec2::new(IMAGE_WIDTH as f32 / 2.0, IMAGE_HEIGHT as f32 / 2.0);\n    let max_radius = IMAGE_HEIGHT.min(IMAGE_WIDTH) as f32 / 2.0;\n    let rot_speed = 0.0123;\n    let period = 0.12345;\n\n    let r = ops::sin(*i as f32 * period) * max_radius;\n    let xy = Vec2::from_angle(*i as f32 * rot_speed) * r + center;\n    let (x, y) = (xy.x as u32, xy.y as u32);\n\n    // Get the old color of that pixel.\n    let old_color = image.get_color_at(x, y).unwrap();\n\n    // If the old color is our current color, change our drawing color.\n    let tolerance = 1.0 / 255.0;\n    if old_color.distance(&draw_color) <= tolerance {\n        *draw_color = Color::linear_rgb(rng.gen(), rng.gen(), rng.gen());\n    }\n\n    // Set the new color, but keep old alpha value from image.\n    image\n        .set_color_at(x, y, draw_color.with_alpha(old_color.alpha()))\n        .unwrap();\n\n    *i += 1;\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "e14af121f31701a12c4ba8a498a57e97dbe887bd",
    "func": "#[macro_use] extern crate rocket;\n\nuse rocket::Request;\n\n#[catch(404)]\nstruct Catcher(String);\n\n#[catch(404)]\nconst CATCH: &str = \"Catcher\";\n\n#[catch(\"404\")]\nfn e1(_request: &Request) { }\n\n#[catch(code = \"404\")]\nfn e2(_request: &Request) { }\n\n#[catch(code = 404)]\nfn e3(_request: &Request) { }\n\n#[catch(99)]\nfn e4(_request: &Request) { }\n\n#[catch(600)]\nfn e5(_request: &Request) { }\n\n#[catch(400, message = \"foo\")]\nfn e5(_request: &Request) { }\n\n#[catch(404)]\nfn f3(_request: &Request, _other: bool) { }\n\nfn main() { }\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "da7c02ce57127c3c06ed265da863b9e83db4ed62",
    "func": "#![cfg(feature = \"tls\")]\n\nuse rocket::fs::relative;\nuse rocket::local::asynchronous::Client;\nuse rocket::tls::{TlsConfig, CipherSuite};\nuse rocket::figment::providers::Serialized;\n\n#[rocket::async_test]\nasync fn can_launch_tls() {\n    let cert_path = relative!(\"examples/tls/private/rsa_sha256_cert.pem\");\n    let key_path = relative!(\"examples/tls/private/rsa_sha256_key.pem\");\n\n    let tls = TlsConfig::from_paths(cert_path, key_path)\n        .with_ciphers([\n            CipherSuite::TLS_AES_128_GCM_SHA256,\n            CipherSuite::TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,\n        ]);\n\n    let config = rocket::Config::figment().merge(Serialized::defaults(tls));\n    let client = Client::debug(rocket::custom(config)).await.unwrap();\n    client.rocket().shutdown().notify();\n    client.rocket().shutdown().await;\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "54a08cc4d977412c674103f56837deac0735a378",
    "func": "use crate::*;\n\npub trait TableRefBuilder: QuotedBuilder {\n    /// Translate [`TableRef`] that without values into SQL statement.\n    fn prepare_table_ref_iden(&self, table_ref: &TableRef, sql: &mut dyn SqlWriter) {\n        match table_ref {\n            TableRef::Table(iden) => {\n                iden.prepare(sql.as_writer(), self.quote());\n            }\n            TableRef::SchemaTable(schema, table) => {\n                schema.prepare(sql.as_writer(), self.quote());\n                write!(sql, \".\").unwrap();\n                table.prepare(sql.as_writer(), self.quote());\n            }\n            TableRef::DatabaseSchemaTable(database, schema, table) => {\n                database.prepare(sql.as_writer(), self.quote());\n                write!(sql, \".\").unwrap();\n                schema.prepare(sql.as_writer(), self.quote());\n                write!(sql, \".\").unwrap();\n                table.prepare(sql.as_writer(), self.quote());\n            }\n            TableRef::TableAlias(iden, alias) => {\n                iden.prepare(sql.as_writer(), self.quote());\n                write!(sql, \" AS \").unwrap();\n                alias.prepare(sql.as_writer(), self.quote());\n            }\n            TableRef::SchemaTableAlias(schema, table, alias) => {\n                schema.prepare(sql.as_writer(), self.quote());\n                write!(sql, \".\").unwrap();\n                table.prepare(sql.as_writer(), self.quote());\n                write!(sql, \" AS \").unwrap();\n                alias.prepare(sql.as_writer(), self.quote());\n            }\n            TableRef::DatabaseSchemaTableAlias(database, schema, table, alias) => {\n                database.prepare(sql.as_writer(), self.quote());\n                write!(sql, \".\").unwrap();\n                schema.prepare(sql.as_writer(), self.quote());\n                write!(sql, \".\").unwrap();\n                table.prepare(sql.as_writer(), self.quote());\n                write!(sql, \" AS \").unwrap();\n                alias.prepare(sql.as_writer(), self.quote());\n            }\n            TableRef::SubQuery(_, _)\n            | TableRef::ValuesList(_, _)\n            | TableRef::FunctionCall(_, _) => {\n                panic!(\"TableRef with values is not support\")\n            }\n        }\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "d834564479a504c40446291969a0255dcfa5099c",
    "func": "#![allow(unknown_lints, unexpected_cfgs)]\n#![warn(rust_2018_idioms)]\n#![cfg(all(feature = \"full\", not(target_os = \"wasi\")))]\n#![cfg(tokio_unstable)]\n\nuse tokio::io::{AsyncReadExt, AsyncWriteExt};\nuse tokio::net::{TcpListener, TcpStream};\nuse tokio::runtime;\nuse tokio::sync::oneshot;\nuse tokio_test::{assert_err, assert_ok};\n\nuse std::future::{poll_fn, Future};\nuse std::pin::Pin;\nuse std::sync::atomic::AtomicUsize;\nuse std::sync::atomic::Ordering::Relaxed;\nuse std::sync::{mpsc, Arc, Mutex};\nuse std::task::{Context, Poll, Waker};\n\nmacro_rules! cfg_metrics {\n    ($($t:tt)*) => {\n        #[cfg(all(tokio_unstable, target_has_atomic = \"64\"))]\n        {\n            $( $t )*\n        }\n    }\n}\n\n#[test]\nfn single_thread() {\n    // No panic when starting a runtime w/ a single thread\n    let _ = runtime::Builder::new_multi_thread_alt()\n        .enable_all()\n        .worker_threads(1)\n        .build()\n        .unwrap();\n}\n\n#[test]\n#[ignore] // https://github.com/tokio-rs/tokio/issues/5995\nfn many_oneshot_futures() {\n    // used for notifying the main thread\n    const NUM: usize = 1_000;\n\n    for _ in 0..5 {\n        let (tx, rx) = mpsc::channel();\n\n        let rt = rt();\n        let cnt = Arc::new(AtomicUsize::new(0));\n\n        for _ in 0..NUM {\n            let cnt = cnt.clone();\n            let tx = tx.clone();\n\n            rt.spawn(async move {\n                let num = cnt.fetch_add(1, Relaxed) + 1;\n\n                if num == NUM {\n                    tx.send(()).unwrap();\n                }\n            });\n        }\n\n        rx.recv().unwrap();\n\n        // Wait for the pool to shutdown\n        drop(rt);\n    }\n}\n\n#[test]\nfn spawn_two() {\n    let rt = rt();\n\n    let out = rt.block_on(async {\n        let (tx, rx) = oneshot::channel();\n\n        tokio::spawn(async move {\n            tokio::spawn(async move {\n                tx.send(\"ZOMG\").unwrap();\n            });\n        });\n\n        assert_ok!(rx.await)\n    });\n\n    assert_eq!(out, \"ZOMG\");\n\n    cfg_metrics! {\n        let metrics = rt.metrics();\n        drop(rt);\n        assert_eq!(1, metrics.remote_schedule_count());\n\n        let mut local = 0;\n        for i in 0..metrics.num_workers() {\n            local += metrics.worker_local_schedule_count(i);\n        }\n\n        assert_eq!(1, local);\n    }\n}\n\n#[test]\nfn many_multishot_futures() {\n    const CHAIN: usize = 200;\n    const CYCLES: usize = 5;\n    const TRACKS: usize = 50;\n\n    for _ in 0..50 {\n        let rt = rt();\n        let mut start_txs = Vec::with_capacity(TRACKS);\n        let mut final_rxs = Vec::with_capacity(TRACKS);\n\n        for _ in 0..TRACKS {\n            let (start_tx, mut chain_rx) = tokio::sync::mpsc::channel(10);\n\n            for _ in 0..CHAIN {\n                let (next_tx, next_rx) = tokio::sync::mpsc::channel(10);\n\n                // Forward all the messages\n                rt.spawn(async move {\n                    while let Some(v) = chain_rx.recv().await {\n                        next_tx.send(v).await.unwrap();\n                    }\n                });\n\n                chain_rx = next_rx;\n            }\n\n            // This final task cycles if needed\n            let (final_tx, final_rx) = tokio::sync::mpsc::channel(10);\n            let cycle_tx = start_tx.clone();\n            let mut rem = CYCLES;\n\n            rt.spawn(async move {\n                for _ in 0..CYCLES {\n                    let msg = chain_rx.recv().await.unwrap();\n\n                    rem -= 1;\n\n                    if rem == 0 {\n                        final_tx.send(msg).await.unwrap();\n                    } else {\n                        cycle_tx.send(msg).await.unwrap();\n                    }\n                }\n            });\n\n            start_txs.push(start_tx);\n            final_rxs.push(final_rx);\n        }\n\n        {\n            rt.block_on(async move {\n                for start_tx in start_txs {\n                    start_tx.send(\"ping\").await.unwrap();\n                }\n\n                for mut final_rx in final_rxs {\n                    final_rx.recv().await.unwrap();\n                }\n            });\n        }\n    }\n}\n\n#[test]\nfn lifo_slot_budget() {\n    async fn my_fn() {\n        spawn_another();\n    }\n\n    fn spawn_another() {\n        tokio::spawn(my_fn());\n    }\n\n    let rt = runtime::Builder::new_multi_thread_alt()\n        .enable_all()\n        .worker_threads(1)\n        .build()\n        .unwrap();\n\n    let (send, recv) = oneshot::channel();\n\n    rt.spawn(async move {\n        tokio::spawn(my_fn());\n        let _ = send.send(());\n    });\n\n    let _ = rt.block_on(recv);\n}\n\n#[test]\nfn spawn_shutdown() {\n    let rt = rt();\n    let (tx, rx) = mpsc::channel();\n\n    rt.block_on(async {\n        tokio::spawn(client_server(tx.clone()));\n    });\n\n    // Use spawner\n    rt.spawn(client_server(tx));\n\n    assert_ok!(rx.recv());\n    assert_ok!(rx.recv());\n\n    drop(rt);\n    assert_err!(rx.try_recv());\n}\n\nasync fn client_server(tx: mpsc::Sender<()>) {\n    let server = assert_ok!(TcpListener::bind(\"127.0.0.1:0\").await);\n\n    // Get the assigned address\n    let addr = assert_ok!(server.local_addr());\n\n    // Spawn the server\n    tokio::spawn(async move {\n        // Accept a socket\n        let (mut socket, _) = server.accept().await.unwrap();\n\n        // Write some data\n        socket.write_all(b\"hello\").await.unwrap();\n    });\n\n    let mut client = TcpStream::connect(&addr).await.unwrap();\n\n    let mut buf = vec![];\n    client.read_to_end(&mut buf).await.unwrap();\n\n    assert_eq!(buf, b\"hello\");\n    tx.send(()).unwrap();\n}\n\n#[test]\nfn drop_threadpool_drops_futures() {\n    for _ in 0..1_000 {\n        let num_inc = Arc::new(AtomicUsize::new(0));\n        let num_dec = Arc::new(AtomicUsize::new(0));\n        let num_drop = Arc::new(AtomicUsize::new(0));\n\n        struct Never(Arc<AtomicUsize>);\n\n        impl Future for Never {\n            type Output = ();\n\n            fn poll(self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<()> {\n                Poll::Pending\n            }\n        }\n\n        impl Drop for Never {\n            fn drop(&mut self) {\n                self.0.fetch_add(1, Relaxed);\n            }\n        }\n\n        let a = num_inc.clone();\n        let b = num_dec.clone();\n\n        let rt = runtime::Builder::new_multi_thread_alt()\n            .enable_all()\n            .on_thread_start(move || {\n                a.fetch_add(1, Relaxed);\n            })\n            .on_thread_stop(move || {\n                b.fetch_add(1, Relaxed);\n            })\n            .build()\n            .unwrap();\n\n        rt.spawn(Never(num_drop.clone()));\n\n        // Wait for the pool to shutdown\n        drop(rt);\n\n        // Assert that only a single thread was spawned.\n        let a = num_inc.load(Relaxed);\n        assert!(a >= 1);\n\n        // Assert that all threads shutdown\n        let b = num_dec.load(Relaxed);\n        assert_eq!(a, b);\n\n        // Assert that the future was dropped\n        let c = num_drop.load(Relaxed);\n        assert_eq!(c, 1);\n    }\n}\n\n#[test]\nfn start_stop_callbacks_called() {\n    use std::sync::atomic::{AtomicUsize, Ordering};\n\n    let after_start = Arc::new(AtomicUsize::new(0));\n    let before_stop = Arc::new(AtomicUsize::new(0));\n\n    let after_inner = after_start.clone();\n    let before_inner = before_stop.clone();\n    let rt = tokio::runtime::Builder::new_multi_thread_alt()\n        .enable_all()\n        .on_thread_start(move || {\n            after_inner.clone().fetch_add(1, Ordering::Relaxed);\n        })\n        .on_thread_stop(move || {\n            before_inner.clone().fetch_add(1, Ordering::Relaxed);\n        })\n        .build()\n        .unwrap();\n\n    let (tx, rx) = oneshot::channel();\n\n    rt.spawn(async move {\n        assert_ok!(tx.send(()));\n    });\n\n    assert_ok!(rt.block_on(rx));\n\n    drop(rt);\n\n    assert!(after_start.load(Ordering::Relaxed) > 0);\n    assert!(before_stop.load(Ordering::Relaxed) > 0);\n}\n\n#[test]\nfn blocking_task() {\n    // used for notifying the main thread\n    const NUM: usize = 1_000;\n\n    for _ in 0..10 {\n        let (tx, rx) = mpsc::channel();\n\n        let rt = rt();\n        let cnt = Arc::new(AtomicUsize::new(0));\n\n        // there are four workers in the pool\n        // so, if we run 4 blocking tasks, we know that handoff must have happened\n        let block = Arc::new(std::sync::Barrier::new(5));\n        for _ in 0..4 {\n            let block = block.clone();\n            rt.spawn(async move {\n                tokio::task::block_in_place(move || {\n                    block.wait();\n                    block.wait();\n                })\n            });\n        }\n        block.wait();\n\n        for _ in 0..NUM {\n            let cnt = cnt.clone();\n            let tx = tx.clone();\n\n            rt.spawn(async move {\n                let num = cnt.fetch_add(1, Relaxed) + 1;\n\n                if num == NUM {\n                    tx.send(()).unwrap();\n                }\n            });\n        }\n\n        rx.recv().unwrap();\n\n        // Wait for the pool to shutdown\n        block.wait();\n    }\n}\n\n#[test]\nfn multi_threadpool() {\n    use tokio::sync::oneshot;\n\n    let rt1 = rt();\n    let rt2 = rt();\n\n    let (tx, rx) = oneshot::channel();\n    let (done_tx, done_rx) = mpsc::channel();\n\n    rt2.spawn(async move {\n        rx.await.unwrap();\n        done_tx.send(()).unwrap();\n    });\n\n    rt1.spawn(async move {\n        tx.send(()).unwrap();\n    });\n\n    done_rx.recv().unwrap();\n}\n\n// When `block_in_place` returns, it attempts to reclaim the yielded runtime\n// worker. In this case, the remainder of the task is on the runtime worker and\n// must take part in the cooperative task budgeting system.\n//\n// The test ensures that, when this happens, attempting to consume from a\n// channel yields occasionally even if there are values ready to receive.\n#[test]\nfn coop_and_block_in_place() {\n    let rt = tokio::runtime::Builder::new_multi_thread_alt()\n        // Setting max threads to 1 prevents another thread from claiming the\n        // runtime worker yielded as part of `block_in_place` and guarantees the\n        // same thread will reclaim the worker at the end of the\n        // `block_in_place` call.\n        .max_blocking_threads(1)\n        .build()\n        .unwrap();\n\n    rt.block_on(async move {\n        let (tx, mut rx) = tokio::sync::mpsc::channel(1024);\n\n        // Fill the channel\n        for _ in 0..1024 {\n            tx.send(()).await.unwrap();\n        }\n\n        drop(tx);\n\n        tokio::spawn(async move {\n            // Block in place without doing anything\n            tokio::task::block_in_place(|| {});\n\n            // Receive all the values, this should trigger a `Pending` as the\n            // coop limit will be reached.\n            poll_fn(|cx| {\n                while let Poll::Ready(v) = {\n                    tokio::pin! {\n                        let fut = rx.recv();\n                    }\n\n                    Pin::new(&mut fut).poll(cx)\n                } {\n                    if v.is_none() {\n                        panic!(\"did not yield\");\n                    }\n                }\n\n                Poll::Ready(())\n            })\n            .await\n        })\n        .await\n        .unwrap();\n    });\n}\n\n#[test]\nfn yield_after_block_in_place() {\n    let rt = tokio::runtime::Builder::new_multi_thread_alt()\n        .worker_threads(1)\n        .build()\n        .unwrap();\n\n    rt.block_on(async {\n        tokio::spawn(async move {\n            // Block in place then enter a new runtime\n            tokio::task::block_in_place(|| {\n                let rt = tokio::runtime::Builder::new_current_thread()\n                    .build()\n                    .unwrap();\n\n                rt.block_on(async {});\n            });\n\n            // Yield, then complete\n            tokio::task::yield_now().await;\n        })\n        .await\n        .unwrap()\n    });\n}\n\n// Testing this does not panic\n#[test]\nfn max_blocking_threads() {\n    let _rt = tokio::runtime::Builder::new_multi_thread_alt()\n        .max_blocking_threads(1)\n        .build()\n        .unwrap();\n}\n\n#[test]\n#[should_panic]\nfn max_blocking_threads_set_to_zero() {\n    let _rt = tokio::runtime::Builder::new_multi_thread_alt()\n        .max_blocking_threads(0)\n        .build()\n        .unwrap();\n}\n\n/// Regression test for #6445.\n///\n/// After #6445, setting `global_queue_interval` to 1 is now technically valid.\n/// This test confirms that there is no regression in `multi_thread_runtime`\n/// when global_queue_interval is set to 1.\n#[test]\nfn global_queue_interval_set_to_one() {\n    let rt = tokio::runtime::Builder::new_multi_thread_alt()\n        .global_queue_interval(1)\n        .build()\n        .unwrap();\n\n    // Perform a simple work.\n    let cnt = Arc::new(AtomicUsize::new(0));\n    rt.block_on(async {\n        let mut set = tokio::task::JoinSet::new();\n        for _ in 0..10 {\n            let cnt = cnt.clone();\n            set.spawn(async move { cnt.fetch_add(1, Relaxed) });\n        }\n        while let Some(res) = set.join_next().await {\n            res.unwrap();\n        }\n    });\n    assert_eq!(cnt.load(Relaxed), 10);\n}\n\n#[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\nasync fn hang_on_shutdown() {\n    let (sync_tx, sync_rx) = std::sync::mpsc::channel::<()>();\n    tokio::spawn(async move {\n        tokio::task::block_in_place(|| sync_rx.recv().ok());\n    });\n\n    tokio::spawn(async {\n        tokio::time::sleep(std::time::Duration::from_secs(2)).await;\n        drop(sync_tx);\n    });\n    tokio::time::sleep(std::time::Duration::from_secs(1)).await;\n}\n\n/// Demonstrates tokio-rs/tokio#3869\n#[test]\nfn wake_during_shutdown() {\n    struct Shared {\n        waker: Option<Waker>,\n    }\n\n    struct MyFuture {\n        shared: Arc<Mutex<Shared>>,\n        put_waker: bool,\n    }\n\n    impl MyFuture {\n        fn new() -> (Self, Self) {\n            let shared = Arc::new(Mutex::new(Shared { waker: None }));\n            let f1 = MyFuture {\n                shared: shared.clone(),\n                put_waker: true,\n            };\n            let f2 = MyFuture {\n                shared,\n                put_waker: false,\n            };\n            (f1, f2)\n        }\n    }\n\n    impl Future for MyFuture {\n        type Output = ();\n\n        fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {\n            let me = Pin::into_inner(self);\n            let mut lock = me.shared.lock().unwrap();\n            if me.put_waker {\n                lock.waker = Some(cx.waker().clone());\n            }\n            Poll::Pending\n        }\n    }\n\n    impl Drop for MyFuture {\n        fn drop(&mut self) {\n            let mut lock = self.shared.lock().unwrap();\n            if !self.put_waker {\n                lock.waker.take().unwrap().wake();\n            }\n            drop(lock);\n        }\n    }\n\n    let rt = tokio::runtime::Builder::new_multi_thread_alt()\n        .worker_threads(1)\n        .enable_all()\n        .build()\n        .unwrap();\n\n    let (f1, f2) = MyFuture::new();\n\n    rt.spawn(f1);\n    rt.spawn(f2);\n\n    rt.block_on(async { tokio::time::sleep(tokio::time::Duration::from_millis(20)).await });\n}\n\n#[should_panic]\n#[tokio::test]\nasync fn test_block_in_place1() {\n    tokio::task::block_in_place(|| {});\n}\n\n#[tokio::test(flavor = \"multi_thread\")]\nasync fn test_block_in_place2() {\n    tokio::task::block_in_place(|| {});\n}\n\n#[should_panic]\n#[tokio::main(flavor = \"current_thread\")]\n#[test]\nasync fn test_block_in_place3() {\n    tokio::task::block_in_place(|| {});\n}\n\n#[tokio::main]\n#[test]\nasync fn test_block_in_place4() {\n    tokio::task::block_in_place(|| {});\n}\n\n// Testing the tuning logic is tricky as it is inherently timing based, and more\n// of a heuristic than an exact behavior. This test checks that the interval\n// changes over time based on load factors. There are no assertions, completion\n// is sufficient. If there is a regression, this test will hang. In theory, we\n// could add limits, but that would be likely to fail on CI.\n#[test]\n#[cfg(not(tokio_no_tuning_tests))]\nfn test_tuning() {\n    use std::sync::atomic::AtomicBool;\n    use std::time::Duration;\n\n    let rt = runtime::Builder::new_multi_thread_alt()\n        .worker_threads(1)\n        .build()\n        .unwrap();\n\n    fn iter(flag: Arc<AtomicBool>, counter: Arc<AtomicUsize>, stall: bool) {\n        if flag.load(Relaxed) {\n            if stall {\n                std::thread::sleep(Duration::from_micros(5));\n            }\n\n            counter.fetch_add(1, Relaxed);\n            tokio::spawn(async move { iter(flag, counter, stall) });\n        }\n    }\n\n    let flag = Arc::new(AtomicBool::new(true));\n    let counter = Arc::new(AtomicUsize::new(61));\n    let interval = Arc::new(AtomicUsize::new(61));\n\n    {\n        let flag = flag.clone();\n        let counter = counter.clone();\n        rt.spawn(async move { iter(flag, counter, true) });\n    }\n\n    // Now, hammer the injection queue until the interval drops.\n    let mut n = 0;\n    loop {\n        let curr = interval.load(Relaxed);\n\n        if curr <= 8 {\n            n += 1;\n        } else {\n            n = 0;\n        }\n\n        // Make sure we get a few good rounds. Jitter in the tuning could result\n        // in one \"good\" value without being representative of reaching a good\n        // state.\n        if n == 3 {\n            break;\n        }\n\n        if Arc::strong_count(&interval) < 5_000 {\n            let counter = counter.clone();\n            let interval = interval.clone();\n\n            rt.spawn(async move {\n                let prev = counter.swap(0, Relaxed);\n                interval.store(prev, Relaxed);\n            });\n\n            std::thread::yield_now();\n        }\n    }\n\n    flag.store(false, Relaxed);\n\n    let w = Arc::downgrade(&interval);\n    drop(interval);\n\n    while w.strong_count() > 0 {\n        std::thread::sleep(Duration::from_micros(500));\n    }\n\n    // Now, run it again with a faster task\n    let flag = Arc::new(AtomicBool::new(true));\n    // Set it high, we know it shouldn't ever really be this high\n    let counter = Arc::new(AtomicUsize::new(10_000));\n    let interval = Arc::new(AtomicUsize::new(10_000));\n\n    {\n        let flag = flag.clone();\n        let counter = counter.clone();\n        rt.spawn(async move { iter(flag, counter, false) });\n    }\n\n    // Now, hammer the injection queue until the interval reaches the expected range.\n    let mut n = 0;\n    loop {\n        let curr = interval.load(Relaxed);\n\n        if curr <= 1_000 && curr > 32 {\n            n += 1;\n        } else {\n            n = 0;\n        }\n\n        if n == 3 {\n            break;\n        }\n\n        if Arc::strong_count(&interval) <= 5_000 {\n            let counter = counter.clone();\n            let interval = interval.clone();\n\n            rt.spawn(async move {\n                let prev = counter.swap(0, Relaxed);\n                interval.store(prev, Relaxed);\n            });\n        }\n\n        std::thread::yield_now();\n    }\n\n    flag.store(false, Relaxed);\n}\n\nfn rt() -> runtime::Runtime {\n    runtime::Builder::new_multi_thread_alt()\n        .enable_all()\n        .build()\n        .unwrap()\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "a043d485fa7059088d85db52a895b7da0d0627d4",
    "func": "use std::rc::Rc;\n\nuse gloo::timers::callback::Interval;\nuse instant::Instant;\nuse yew::prelude::*;\n\nconst RESOLUTION: u32 = 500;\nconst MIN_INTERVAL_MS: u32 = 50;\n\npub enum ValueAction {\n    Tick,\n    Props(Props),\n}\n\n#[derive(Clone, PartialEq, Debug)]\npub struct ValueState {\n    start: Instant,\n\n    value: f64,\n\n    props: Props,\n}\n\nimpl Reducible for ValueState {\n    type Action = ValueAction;\n\n    fn reduce(self: Rc<Self>, action: Self::Action) -> Rc<Self> {\n        match action {\n            Self::Action::Props(props) => Self {\n                start: self.start,\n                value: self.value,\n                props,\n            }\n            .into(),\n\n            Self::Action::Tick => {\n                let elapsed = self.start.elapsed().as_millis() as u32;\n                let value = elapsed as f64 / self.props.duration_ms as f64;\n\n                let mut start = self.start;\n\n                if elapsed > self.props.duration_ms {\n                    self.props.on_complete.emit(());\n                    start = Instant::now();\n                } else {\n                    self.props.on_progress.emit(self.value);\n                }\n\n                Self {\n                    start,\n                    value,\n                    props: self.props.clone(),\n                }\n                .into()\n            }\n        }\n    }\n}\n\n#[derive(Clone, Debug, PartialEq, Properties)]\npub struct Props {\n    pub duration_ms: u32,\n    pub on_complete: Callback<()>,\n    #[prop_or_default]\n    pub on_progress: Callback<f64>,\n}\n\n#[function_component]\npub fn ProgressDelay(props: &Props) -> Html {\n    let Props { duration_ms, .. } = props.clone();\n\n    let value = {\n        let props = props.clone();\n        use_reducer(move || ValueState {\n            start: Instant::now(),\n            value: 0.0,\n\n            props,\n        })\n    };\n\n    {\n        let value = value.clone();\n        use_effect_with((), move |_| {\n            let interval = (duration_ms / RESOLUTION).min(MIN_INTERVAL_MS);\n            let interval = Interval::new(interval, move || value.dispatch(ValueAction::Tick));\n\n            || {\n                let _interval = interval;\n            }\n        });\n    }\n\n    {\n        let value = value.clone();\n        use_effect_with(props.clone(), move |props| {\n            value.dispatch(ValueAction::Props(props.clone()));\n            || {}\n        });\n    }\n\n    let value = &value.value;\n\n    html! {\n        <progress class=\"progress is-primary\" value={value.to_string()} max=1.0>\n            { format!(\"{:.0}%\", 100.0 * value) }\n        </progress>\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "187b5374d7e617683e929546d7b8caddbdaad7ee",
    "func": "use sea_orm::entity::prelude::*;\n\n#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]\n#[sea_orm(table_name = \"fruit\")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    #[cfg_attr(feature = \"with-json\", serde(skip_deserializing))]\n    pub id: i32,\n    pub name: String,\n    pub cake_id: Option<i32>,\n}\n\n#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]\npub enum Relation {\n    #[sea_orm(\n        belongs_to = \"super::cake::Entity\",\n        from = \"Column::CakeId\",\n        to = \"super::cake::Column::Id\"\n    )]\n    Cake,\n}\n\nimpl Related<super::cake::Entity> for Entity {\n    fn to() -> RelationDef {\n        Relation::Cake.def()\n    }\n}\n\nimpl ActiveModelBehavior for ActiveModel {}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "7b41de35420568677c3b8eea19db5d7d0da52e3f",
    "func": "use super::sea_orm_active_enums::*;\nuse crate as sea_orm;\nuse crate::entity::prelude::*;\n\n#[derive(Copy, Clone, Default, Debug, DeriveEntity)]\npub struct Entity;\n\nimpl EntityName for Entity {\n    fn table_name(&self) -> &str {\n        \"lunch_set\"\n    }\n}\n\n#[derive(Clone, Debug, PartialEq, Eq, DeriveModel, DeriveActiveModel)]\n#[sea_orm(table_name = \"lunch_set\")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    pub name: String,\n    pub tea: Tea,\n}\n\n#[derive(Copy, Clone, Debug, EnumIter, DeriveColumn)]\npub enum Column {\n    Id,\n    Name,\n    Tea,\n}\n\n#[derive(Copy, Clone, Debug, EnumIter, DerivePrimaryKey)]\npub enum PrimaryKey {\n    Id,\n}\n\nimpl PrimaryKeyTrait for PrimaryKey {\n    type ValueType = i32;\n\n    fn auto_increment() -> bool {\n        true\n    }\n}\n\n#[derive(Copy, Clone, Debug, EnumIter)]\npub enum Relation {}\n\nimpl ColumnTrait for Column {\n    type EntityName = Entity;\n\n    fn def(&self) -> ColumnDef {\n        match self {\n            Self::Id => ColumnType::Integer.def(),\n            Self::Name => ColumnType::String(StringLen::None).def(),\n            Self::Tea => Tea::db_type().def(),\n        }\n    }\n}\n\nimpl RelationTrait for Relation {\n    fn def(&self) -> RelationDef {\n        panic!(\"No RelationDef\")\n    }\n}\n\nimpl ActiveModelBehavior for ActiveModel {}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "1555408f10f052fb015d3ed7f6332ca52e683a4c",
    "func": "mod cake;\nuse sea_orm::*;\n\n#[async_std::main]\npub async fn main() {\n    let db = Database::connect(\"mysql://sea:sea@localhost/bakery\")\n        .await\n        .unwrap();\n\n    async_std::task::spawn(async move {\n        cake::Entity::find().one(&db).await.unwrap();\n    })\n    .await;\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "21905964d5f98cbad38e01c54f7f61f1471dd3fe",
    "func": "use std::borrow::Borrow;\nuse std::rc::Rc;\n\nuse super::use_mut_ref;\nuse crate::functional::hook;\n\n/// Get a immutable reference to a memoized value.\n///\n/// This version allows for a key cache key derivation that only borrows\n/// like the original argument. For example, using ` K = Rc<D>`, we only\n/// create a shared reference to dependencies *after* they change.\n#[hook]\npub(crate) fn use_memo_base<T, F, D, K>(f: F, deps: D) -> Rc<T>\nwhere\n    T: 'static,\n    F: FnOnce(D) -> (T, K),\n    K: 'static + Borrow<D>,\n    D: PartialEq,\n{\n    struct MemoState<T, K> {\n        memo_key: K,\n        result: Rc<T>,\n    }\n    let state = use_mut_ref(|| -> Option<MemoState<T, K>> { None });\n\n    let mut state = state.borrow_mut();\n    match &*state {\n        Some(existing) if existing.memo_key.borrow() != &deps => {\n            // Drop old state if it's outdated\n            *state = None;\n        }\n        _ => {}\n    };\n    let state = state.get_or_insert_with(|| {\n        let (result, memo_key) = f(deps);\n        let result = Rc::new(result);\n        MemoState { result, memo_key }\n    });\n    state.result.clone()\n}\n\n/// Get a immutable reference to a memoized value.\n///\n/// Memoization means it will only get recalculated when provided dependencies update/change.\n///\n/// It can be useful for keeping things in scope for the lifetime of the component,\n/// so long as you don't store a clone of the resulting `Rc` anywhere that outlives the component.\n///\n/// # Example\n///\n/// ```rust\n/// use yew::prelude::*;\n///\n/// #[derive(PartialEq, Properties)]\n/// pub struct Props {\n///     pub step: usize,\n/// }\n///\n/// #[function_component(UseMemo)]\n/// fn memo(props: &Props) -> Html {\n///     // Will only get recalculated if `props.step` value changes\n///     let message = use_memo(props.step, |step| {\n///         format!(\"{}. Do Some Expensive Calculation\", step)\n///     });\n///\n///     html! {\n///         <div>\n///             <span>{ (*message).clone() }</span>\n///         </div>\n///     }\n/// }\n/// ```\n#[hook]\npub fn use_memo<T, F, D>(deps: D, f: F) -> Rc<T>\nwhere\n    T: 'static,\n    F: FnOnce(&D) -> T,\n    D: 'static + PartialEq,\n{\n    use_memo_base(|d| (f(&d), d), deps)\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "9dbc39a88943017d702521df96da87a890e2863d",
    "func": "use super::{Context, Module, ModuleConfig};\n\nuse crate::configs::quarto::QuartoConfig;\nuse crate::formatter::{StringFormatter, VersionFormatter};\n\n/// Creates a module with the current Quarto version\npub fn module<'a>(context: &'a Context) -> Option<Module<'a>> {\n    let mut module = context.new_module(\"quarto\");\n    let config = QuartoConfig::try_load(module.config);\n\n    let is_quarto_project = context\n        .try_begin_scan()?\n        .set_files(&config.detect_files)\n        .set_extensions(&config.detect_extensions)\n        .set_folders(&config.detect_folders)\n        .is_match();\n\n    if !is_quarto_project {\n        return None;\n    }\n\n    let parsed = StringFormatter::new(config.format).and_then(|formatter| {\n        formatter\n            .map_meta(|var, _| match var {\n                \"symbol\" => Some(config.symbol),\n                _ => None,\n            })\n            .map_style(|variable| match variable {\n                \"style\" => Some(Ok(config.style)),\n                _ => None,\n            })\n            .map(|variable| match variable {\n                \"version\" => {\n                    let version = context\n                        .exec_cmd(\"quarto\", &[\"--version\"])?\n                        .stdout\n                        .trim_end()\n                        .to_owned();\n                    VersionFormatter::format_module_version(\n                        module.get_name(),\n                        &version,\n                        config.version_format,\n                    )\n                    .map(Ok)\n                }\n                _ => None,\n            })\n            .parse(None, Some(context))\n    });\n\n    module.set_segments(match parsed {\n        Ok(segments) => segments,\n        Err(error) => {\n            log::warn!(\"Error in module `quarto`:\\n{}\", error);\n            return None;\n        }\n    });\n\n    Some(module)\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::test::ModuleRenderer;\n    use nu_ansi_term::Color;\n    use std::fs::File;\n    use std::io;\n    #[test]\n    fn read_quarto_not_present() -> io::Result<()> {\n        let dir = tempfile::tempdir()?;\n\n        let actual = ModuleRenderer::new(\"quarto\").path(dir.path()).collect();\n\n        let expected = None;\n        assert_eq!(expected, actual);\n        dir.close()\n    }\n\n    #[test]\n    fn read_quarto_present() -> io::Result<()> {\n        let dir = tempfile::tempdir()?;\n\n        File::create(dir.path().join(\"test.qmd\"))?.sync_all()?;\n\n        let actual = ModuleRenderer::new(\"quarto\").path(dir.path()).collect();\n        let expected = Some(format!(\n            \"via {}\",\n            Color::Rgb(117, 170, 219).bold().paint(\"\u2a01 v1.4.549 \")\n        ));\n        assert_eq!(expected, actual);\n        dir.close()\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "0df4c06fd20ad64e8eaf5a3e3c6d2a8baa1bbb59",
    "func": "use crate::io::{Interest, PollEvented, ReadBuf, Ready};\nuse crate::net::{to_socket_addrs, ToSocketAddrs};\n\nuse std::fmt;\nuse std::io;\nuse std::net::{self, Ipv4Addr, Ipv6Addr, SocketAddr};\nuse std::task::{ready, Context, Poll};\n\ncfg_io_util! {\n    use bytes::BufMut;\n}\n\ncfg_net! {\n    /// A UDP socket.\n    ///\n    /// UDP is \"connectionless\", unlike TCP. Meaning, regardless of what address you've bound to, a `UdpSocket`\n    /// is free to communicate with many different remotes. In tokio there are basically two main ways to use `UdpSocket`:\n    ///\n    /// * one to many: [`bind`](`UdpSocket::bind`) and use [`send_to`](`UdpSocket::send_to`)\n    ///   and [`recv_from`](`UdpSocket::recv_from`) to communicate with many different addresses\n    /// * one to one: [`connect`](`UdpSocket::connect`) and associate with a single address, using [`send`](`UdpSocket::send`)\n    ///   and [`recv`](`UdpSocket::recv`) to communicate only with that remote address\n    ///\n    /// This type does not provide a `split` method, because this functionality\n    /// can be achieved by instead wrapping the socket in an [`Arc`]. Note that\n    /// you do not need a `Mutex` to share the `UdpSocket` \u2014 an `Arc<UdpSocket>`\n    /// is enough. This is because all of the methods take `&self` instead of\n    /// `&mut self`. Once you have wrapped it in an `Arc`, you can call\n    /// `.clone()` on the `Arc<UdpSocket>` to get multiple shared handles to the\n    /// same socket. An example of such usage can be found further down.\n    ///\n    /// [`Arc`]: std::sync::Arc\n    ///\n    /// # Streams\n    ///\n    /// If you need to listen over UDP and produce a [`Stream`], you can look\n    /// at [`UdpFramed`].\n    ///\n    /// [`UdpFramed`]: https://docs.rs/tokio-util/latest/tokio_util/udp/struct.UdpFramed.html\n    /// [`Stream`]: https://docs.rs/futures/0.3/futures/stream/trait.Stream.html\n    ///\n    /// # Example: one to many (bind)\n    ///\n    /// Using `bind` we can create a simple echo server that sends and recv's with many different clients:\n    /// ```no_run\n    /// use tokio::net::UdpSocket;\n    /// use std::io;\n    ///\n    /// #[tokio::main]\n    /// async fn main() -> io::Result<()> {\n    ///     let sock = UdpSocket::bind(\"0.0.0.0:8080\").await?;\n    ///     let mut buf = [0; 1024];\n    ///     loop {\n    ///         let (len, addr) = sock.recv_from(&mut buf).await?;\n    ///         println!(\"{:?} bytes received from {:?}\", len, addr);\n    ///\n    ///         let len = sock.send_to(&buf[..len], addr).await?;\n    ///         println!(\"{:?} bytes sent\", len);\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// # Example: one to one (connect)\n    ///\n    /// Or using `connect` we can echo with a single remote address using `send` and `recv`:\n    /// ```no_run\n    /// use tokio::net::UdpSocket;\n    /// use std::io;\n    ///\n    /// #[tokio::main]\n    /// async fn main() -> io::Result<()> {\n    ///     let sock = UdpSocket::bind(\"0.0.0.0:8080\").await?;\n    ///\n    ///     let remote_addr = \"127.0.0.1:59611\";\n    ///     sock.connect(remote_addr).await?;\n    ///     let mut buf = [0; 1024];\n    ///     loop {\n    ///         let len = sock.recv(&mut buf).await?;\n    ///         println!(\"{:?} bytes received from {:?}\", len, remote_addr);\n    ///\n    ///         let len = sock.send(&buf[..len]).await?;\n    ///         println!(\"{:?} bytes sent\", len);\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// # Example: Splitting with `Arc`\n    ///\n    /// Because `send_to` and `recv_from` take `&self`. It's perfectly alright\n    /// to use an `Arc<UdpSocket>` and share the references to multiple tasks.\n    /// Here is a similar \"echo\" example that supports concurrent\n    /// sending/receiving:\n    ///\n    /// ```no_run\n    /// use tokio::{net::UdpSocket, sync::mpsc};\n    /// use std::{io, net::SocketAddr, sync::Arc};\n    ///\n    /// #[tokio::main]\n    /// async fn main() -> io::Result<()> {\n    ///     let sock = UdpSocket::bind(\"0.0.0.0:8080\".parse::<SocketAddr>().unwrap()).await?;\n    ///     let r = Arc::new(sock);\n    ///     let s = r.clone();\n    ///     let (tx, mut rx) = mpsc::channel::<(Vec<u8>, SocketAddr)>(1_000);\n    ///\n    ///     tokio::spawn(async move {\n    ///         while let Some((bytes, addr)) = rx.recv().await {\n    ///             let len = s.send_to(&bytes, &addr).await.unwrap();\n    ///             println!(\"{:?} bytes sent\", len);\n    ///         }\n    ///     });\n    ///\n    ///     let mut buf = [0; 1024];\n    ///     loop {\n    ///         let (len, addr) = r.recv_from(&mut buf).await?;\n    ///         println!(\"{:?} bytes received from {:?}\", len, addr);\n    ///         tx.send((buf[..len].to_vec(), addr)).await.unwrap();\n    ///     }\n    /// }\n    /// ```\n    ///\n    pub struct UdpSocket {\n        io: PollEvented<mio::net::UdpSocket>,\n    }\n}\n\nimpl UdpSocket {\n    /// This function will create a new UDP socket and attempt to bind it to\n    /// the `addr` provided.\n    ///\n    /// Binding with a port number of 0 will request that the OS assigns a port\n    /// to this listener. The port allocated can be queried via the `local_addr`\n    /// method.\n    ///\n    /// # Example\n    ///\n    /// ```no_run\n    /// use tokio::net::UdpSocket;\n    /// use std::io;\n    ///\n    /// #[tokio::main]\n    /// async fn main() -> io::Result<()> {\n    ///     let sock = UdpSocket::bind(\"0.0.0.0:8080\").await?;\n    ///     // use `sock`\n    /// #   let _ = sock;\n    ///     Ok(())\n    /// }\n    /// ```\n    pub async fn bind<A: ToSocketAddrs>(addr: A) -> io::Result<UdpSocket> {\n        let addrs = to_socket_addrs(addr).await?;\n        let mut last_err = None;\n\n        for addr in addrs {\n            match UdpSocket::bind_addr(addr) {\n                Ok(socket) => return Ok(socket),\n                Err(e) => last_err = Some(e),\n            }\n        }\n\n        Err(last_err.unwrap_or_else(|| {\n            io::Error::new(\n                io::ErrorKind::InvalidInput,\n                \"could not resolve to any address\",\n            )\n        }))\n    }\n\n    fn bind_addr(addr: SocketAddr) -> io::Result<UdpSocket> {\n        let sys = mio::net::UdpSocket::bind(addr)?;\n        UdpSocket::new(sys)\n    }\n\n    #[track_caller]\n    fn new(socket: mio::net::UdpSocket) -> io::Result<UdpSocket> {\n        let io = PollEvented::new(socket)?;\n        Ok(UdpSocket { io })\n    }\n\n    /// Creates new `UdpSocket` from a previously bound `std::net::UdpSocket`.\n    ///\n    /// This function is intended to be used to wrap a UDP socket from the\n    /// standard library in the Tokio equivalent.\n    ///\n    /// This can be used in conjunction with `socket2`'s `Socket` interface to\n    /// configure a socket before it's handed off, such as setting options like\n    /// `reuse_address` or binding to multiple addresses.\n    ///\n    /// # Notes\n    ///\n    /// The caller is responsible for ensuring that the socket is in\n    /// non-blocking mode. Otherwise all I/O operations on the socket\n    /// will block the thread, which will cause unexpected behavior.\n    /// Non-blocking mode can be set using [`set_nonblocking`].\n    ///\n    /// [`set_nonblocking`]: std::net::UdpSocket::set_nonblocking\n    ///\n    /// # Panics\n    ///\n    /// This function panics if thread-local runtime is not set.\n    ///\n    /// The runtime is usually set implicitly when this function is called\n    /// from a future driven by a tokio runtime, otherwise runtime can be set\n    /// explicitly with [`Runtime::enter`](crate::runtime::Runtime::enter) function.\n    ///\n    /// # Example\n    ///\n    /// ```no_run\n    /// use tokio::net::UdpSocket;\n    /// # use std::{io, net::SocketAddr};\n    ///\n    /// # #[tokio::main]\n    /// # async fn main() -> io::Result<()> {\n    /// let addr = \"0.0.0.0:8080\".parse::<SocketAddr>().unwrap();\n    /// let std_sock = std::net::UdpSocket::bind(addr)?;\n    /// std_sock.set_nonblocking(true)?;\n    /// let sock = UdpSocket::from_std(std_sock)?;\n    /// // use `sock`\n    /// # Ok(())\n    /// # }\n    /// ```\n    #[track_caller]\n    pub fn from_std(socket: net::UdpSocket) -> io::Result<UdpSocket> {\n        let io = mio::net::UdpSocket::from_std(socket);\n        UdpSocket::new(io)\n    }\n\n    /// Turns a [`tokio::net::UdpSocket`] into a [`std::net::UdpSocket`].\n    ///\n    /// The returned [`std::net::UdpSocket`] will have nonblocking mode set as\n    /// `true`.  Use [`set_nonblocking`] to change the blocking mode if needed.\n    ///\n    /// # Examples\n    ///\n    /// ```rust,no_run\n    /// use std::error::Error;\n    ///\n    /// #[tokio::main]\n    /// async fn main() -> Result<(), Box<dyn Error>> {\n    ///     let tokio_socket = tokio::net::UdpSocket::bind(\"127.0.0.1:0\").await?;\n    ///     let std_socket = tokio_socket.into_std()?;\n    ///     std_socket.set_nonblocking(false)?;\n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// [`tokio::net::UdpSocket`]: UdpSocket\n    /// [`std::net::UdpSocket`]: std::net::UdpSocket\n    /// [`set_nonblocking`]: fn@std::net::UdpSocket::set_nonblocking\n    pub fn into_std(self) -> io::Result<std::net::UdpSocket> {\n        #[cfg(unix)]\n        {\n            use std::os::unix::io::{FromRawFd, IntoRawFd};\n            self.io\n                .into_inner()\n                .map(IntoRawFd::into_raw_fd)\n                .map(|raw_fd| unsafe { std::net::UdpSocket::from_raw_fd(raw_fd) })\n        }\n\n        #[cfg(windows)]\n        {\n            use std::os::windows::io::{FromRawSocket, IntoRawSocket};\n            self.io\n                .into_inner()\n                .map(|io| io.into_raw_socket())\n                .map(|raw_socket| unsafe { std::net::UdpSocket::from_raw_socket(raw_socket) })\n        }\n    }\n\n    fn as_socket(&self) -> socket2::SockRef<'_> {\n        socket2::SockRef::from(self)\n    }\n\n    /// Returns the local address that this socket is bound to.\n    ///\n    /// # Example\n    ///\n    /// ```no_run\n    /// use tokio::net::UdpSocket;\n    /// # use std::{io, net::SocketAddr};\n    ///\n    /// # #[tokio::main]\n    /// # async fn main() -> io::Result<()> {\n    /// let addr = \"0.0.0.0:8080\".parse::<SocketAddr>().unwrap();\n    /// let sock = UdpSocket::bind(addr).await?;\n    /// // the address the socket is bound to\n    /// let local_addr = sock.local_addr()?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n        self.io.local_addr()\n    }\n\n    /// Returns the socket address of the remote peer this socket was connected to.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use tokio::net::UdpSocket;\n    ///\n    /// # use std::{io, net::SocketAddr};\n    /// # #[tokio::main]\n    /// # async fn main() -> io::Result<()> {\n    /// let addr = \"0.0.0.0:8080\".parse::<SocketAddr>().unwrap();\n    /// let peer = \"127.0.0.1:11100\".parse::<SocketAddr>().unwrap();\n    /// let sock = UdpSocket::bind(addr).await?;\n    /// sock.connect(peer).await?;\n    /// assert_eq!(peer, sock.peer_addr()?);\n    /// #    Ok(())\n    /// # }\n    /// ```\n    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n        self.io.peer_addr()\n    }\n\n    /// Connects the UDP socket setting the default destination for send() and\n    /// limiting packets that are read via `recv` from the address specified in\n    /// `addr`.\n    ///\n    /// # Example\n    ///\n    /// ```no_run\n    /// use tokio::net::UdpSocket;\n    /// # use std::{io, net::SocketAddr};\n    ///\n    /// # #[tokio::main]\n    /// # async fn main() -> io::Result<()> {\n    /// let sock = UdpSocket::bind(\"0.0.0.0:8080\".parse::<SocketAddr>().unwrap()).await?;\n    ///\n    /// let remote_addr = \"127.0.0.1:59600\".parse::<SocketAddr>().unwrap();\n    /// sock.connect(remote_addr).await?;\n    /// let mut buf = [0u8; 32];\n    /// // recv from remote_addr\n    /// let len = sock.recv(&mut buf).await?;\n    /// // send to remote_addr\n    /// let _len = sock.send(&buf[..len]).await?;\n    /// # Ok(())\n    /// # }\n    /// ```\n    pub async fn connect<A: ToSocketAddrs>(&self, addr: A) -> io::Result<()> {\n        let addrs = to_socket_addrs(addr).await?;\n        let mut last_err = None;\n\n        for addr in addrs {\n            match self.io.connect(addr) {\n                Ok(()) => return Ok(()),\n                Err(e) => last_err = Some(e),\n            }\n        }\n\n        Err(last_err.unwrap_or_else(|| {\n            io::Error::new(\n                io::ErrorKind::InvalidInput,\n                \"could not resolve to any address\",\n            )\n        }))\n    }\n\n    /// Waits for any of the requested ready states.\n    ///\n    /// This function is usually paired with `try_recv()` or `try_send()`. It\n    /// can be used to concurrently `recv` / `send` to the same socket on a single\n    /// task without splitting the socket.\n    ///\n    /// The function may complete without the socket being ready. This is a\n    /// false-positive and attempting an operation will return with\n    /// `io::ErrorKind::WouldBlock`. The function can also return with an empty\n    /// [`Ready`] set, so you should always check the returned value and possibly\n    /// wait again if the requested states are not set.\n    ///\n    /// # Cancel safety\n    ///\n    /// This method is cancel safe. Once a readiness event occurs, the method\n    /// will continue to return immediately until the readiness event is\n    /// consumed by an attempt to read or write that fails with `WouldBlock` or\n    /// `Poll::Pending`.\n    ///\n    /// # Examples\n    ///\n    /// Concurrently receive from and send to the socket on the same task\n    /// without splitting.\n    ///\n    /// ```no_run\n    /// use tokio::io::{self, Interest};\n    /// use tokio::net::UdpSocket;\n    ///\n    /// #[tokio::main]\n    /// async fn main() -> io::Result<()> {\n    ///     let socket = UdpSocket::bind(\"127.0.0.1:8080\").await?;\n    ///     socket.connect(\"127.0.0.1:8081\").await?;\n    ///\n    ///     loop {\n    ///         let ready = socket.ready(Interest::READABLE | Interest::WRITABLE).await?;\n    ///\n    ///         if ready.is_readable() {\n    ///             // The buffer is **not** included in the async task and will only exist\n    ///             // on the stack.\n    ///             let mut data = [0; 1024];\n    ///             match socket.try_recv(&mut data[..]) {\n    ///                 Ok(n) => {\n    ///                     println!(\"received {:?}\", &data[..n]);\n    ///                 }\n    ///                 // False-positive, continue\n    ///                 Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {}\n    ///                 Err(e) => {\n    ///                     return Err(e);\n    ///                 }\n    ///             }\n    ///         }\n    ///\n    ///         if ready.is_writable() {\n    ///             // Write some data\n    ///             match socket.try_send(b\"hello world\") {\n    ///                 Ok(n) => {\n    ///                     println!(\"sent {} bytes\", n);\n    ///                 }\n    ///                 // False-positive, continue\n    ///                 Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {}\n    ///                 Err(e) => {\n    ///                     return Err(e);\n    ///                 }\n    ///             }\n    ///         }\n    ///     }\n    /// }\n    /// ```\n    pub async fn ready(&self, interest: Interest) -> io::Result<Ready> {\n        let event = self.io.registration().readiness(interest).await?;\n        Ok(event.ready)\n    }\n\n    /// Waits for the socket to become writable.\n    ///\n    /// This function is equivalent to `ready(Interest::WRITABLE)` and is\n    /// usually paired with `try_send()` or `try_send_to()`.\n    ///\n    /// The function may complete without the socket being writable. This is a\n    /// false-positive and attempting a `try_send()` will return with\n    /// `io::ErrorKind::WouldBlock`.\n    ///\n    /// # Cancel safety\n    ///\n    /// This method is cancel safe. Once a readiness event occurs, the method\n    /// will continue to return immediately until the readiness event is\n    /// consumed by an attempt to write that fails with `WouldBlock` or\n    /// `Poll::Pending`.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use tokio::net::UdpSocket;\n    /// use std::io;\n    ///\n    /// #[tokio::main]\n    /// async fn main() -> io::Result<()> {\n    ///     // Bind socket\n    ///     let socket = UdpSocket::bind(\"127.0.0.1:8080\").await?;\n    ///     socket.connect(\"127.0.0.1:8081\").await?;\n    ///\n    ///     loop {\n    ///         // Wait for the socket to be writable\n    ///         socket.writable().await?;\n    ///\n    ///         // Try to send data, this may still fail with `WouldBlock`\n    ///         // if the readiness event is a false positive.\n    ///         match socket.try_send(b\"hello world\") {\n    ///             Ok(n) => {\n    ///                 break;\n    ///             }\n    ///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {\n    ///                 continue;\n    ///             }\n    ///             Err(e) => {\n    ///                 return Err(e);\n    ///             }\n    ///         }\n    ///     }\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    pub async fn writable(&self) -> io::Result<()> {\n        self.ready(Interest::WRITABLE).await?;\n        Ok(())\n    }\n\n    /// Polls for write/send readiness.\n    ///\n    /// If the udp stream is not currently ready for sending, this method will\n    /// store a clone of the `Waker` from the provided `Context`. When the udp\n    /// stream becomes ready for sending, `Waker::wake` will be called on the\n    /// waker.\n    ///\n    /// Note that on multiple calls to `poll_send_ready` or `poll_send`, only\n    /// the `Waker` from the `Context` passed to the most recent call is\n    /// scheduled to receive a wakeup. (However, `poll_recv_ready` retains a\n    /// second, independent waker.)\n    ///\n    /// This function is intended for cases where creating and pinning a future\n    /// via [`writable`] is not feasible. Where possible, using [`writable`] is\n    /// preferred, as this supports polling from multiple tasks at once.\n    ///\n    /// # Return value\n    ///\n    /// The function returns:\n    ///\n    /// * `Poll::Pending` if the udp stream is not ready for writing.\n    /// * `Poll::Ready(Ok(()))` if the udp stream is ready for writing.\n    /// * `Poll::Ready(Err(e))` if an error is encountered.\n    ///\n    /// # Errors\n    ///\n    /// This function may encounter any standard I/O error except `WouldBlock`.\n    ///\n    /// [`writable`]: method@Self::writable\n    pub fn poll_send_ready(&self, cx: &mut Context<'_>) -> Poll<io::Result<()>> {\n        self.io.registration().poll_write_ready(cx).map_ok(|_| ())\n    }\n\n    /// Sends data on the socket to the remote address that the socket is\n    /// connected to.\n    ///\n    /// The [`connect`] method will connect this socket to a remote address.\n    /// This method will fail if the socket is not connected.\n    ///\n    /// [`connect`]: method@Self::connect\n    ///\n    /// # Return\n    ///\n    /// On success, the number of bytes sent is returned, otherwise, the\n    /// encountered error is returned.\n    ///\n    /// # Cancel safety\n    ///\n    /// This method is cancel safe. If `send` is used as the event in a\n    /// [`tokio::select!`](crate::select) statement and some other branch\n    /// completes first, then it is guaranteed that the message was not sent.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use tokio::io;\n    /// use tokio::net::UdpSocket;\n    ///\n    /// #[tokio::main]\n    /// async fn main() -> io::Result<()> {\n    ///     // Bind socket\n    ///     let socket = UdpSocket::bind(\"127.0.0.1:8080\").await?;\n    ///     socket.connect(\"127.0.0.1:8081\").await?;\n    ///\n    ///     // Send a message\n    ///     socket.send(b\"hello world\").await?;\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    pub async fn send(&self, buf: &[u8]) -> io::Result<usize> {\n        self.io\n            .registration()\n            .async_io(Interest::WRITABLE, || self.io.send(buf))\n            .await\n    }\n\n    /// Attempts to send data on the socket to the remote address to which it\n    /// was previously `connect`ed.\n    ///\n    /// The [`connect`] method will connect this socket to a remote address.\n    /// This method will fail if the socket is not connected.\n    ///\n    /// Note that on multiple calls to a `poll_*` method in the send direction,\n    /// only the `Waker` from the `Context` passed to the most recent call will\n    /// be scheduled to receive a wakeup.\n    ///\n    /// # Return value\n    ///\n    /// The function returns:\n    ///\n    /// * `Poll::Pending` if the socket is not available to write\n    /// * `Poll::Ready(Ok(n))` `n` is the number of bytes sent\n    /// * `Poll::Ready(Err(e))` if an error is encountered.\n    ///\n    /// # Errors\n    ///\n    /// This function may encounter any standard I/O error except `WouldBlock`.\n    ///\n    /// [`connect`]: method@Self::connect\n    pub fn poll_send(&self, cx: &mut Context<'_>, buf: &[u8]) -> Poll<io::Result<usize>> {\n        self.io\n            .registration()\n            .poll_write_io(cx, || self.io.send(buf))\n    }\n\n    /// Tries to send data on the socket to the remote address to which it is\n    /// connected.\n    ///\n    /// When the socket buffer is full, `Err(io::ErrorKind::WouldBlock)` is\n    /// returned. This function is usually paired with `writable()`.\n    ///\n    /// # Returns\n    ///\n    /// If successful, `Ok(n)` is returned, where `n` is the number of bytes\n    /// sent. If the socket is not ready to send data,\n    /// `Err(ErrorKind::WouldBlock)` is returned.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use tokio::net::UdpSocket;\n    /// use std::io;\n    ///\n    /// #[tokio::main]\n    /// async fn main() -> io::Result<()> {\n    ///     // Bind a UDP socket\n    ///     let socket = UdpSocket::bind(\"127.0.0.1:8080\").await?;\n    ///\n    ///     // Connect to a peer\n    ///     socket.connect(\"127.0.0.1:8081\").await?;\n    ///\n    ///     loop {\n    ///         // Wait for the socket to be writable\n    ///         socket.writable().await?;\n    ///\n    ///         // Try to send data, this may still fail with `WouldBlock`\n    ///         // if the readiness event is a false positive.\n    ///         match socket.try_send(b\"hello world\") {\n    ///             Ok(n) => {\n    ///                 break;\n    ///             }\n    ///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {\n    ///                 continue;\n    ///             }\n    ///             Err(e) => {\n    ///                 return Err(e);\n    ///             }\n    ///         }\n    ///     }\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn try_send(&self, buf: &[u8]) -> io::Result<usize> {\n        self.io\n            .registration()\n            .try_io(Interest::WRITABLE, || self.io.send(buf))\n    }\n\n    /// Waits for the socket to become readable.\n    ///\n    /// This function is equivalent to `ready(Interest::READABLE)` and is usually\n    /// paired with `try_recv()`.\n    ///\n    /// The function may complete without the socket being readable. This is a\n    /// false-positive and attempting a `try_recv()` will return with\n    /// `io::ErrorKind::WouldBlock`.\n    ///\n    /// # Cancel safety\n    ///\n    /// This method is cancel safe. Once a readiness event occurs, the method\n    /// will continue to return immediately until the readiness event is\n    /// consumed by an attempt to read that fails with `WouldBlock` or\n    /// `Poll::Pending`.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use tokio::net::UdpSocket;\n    /// use std::io;\n    ///\n    /// #[tokio::main]\n    /// async fn main() -> io::Result<()> {\n    ///     // Connect to a peer\n    ///     let socket = UdpSocket::bind(\"127.0.0.1:8080\").await?;\n    ///     socket.connect(\"127.0.0.1:8081\").await?;\n    ///\n    ///     loop {\n    ///         // Wait for the socket to be readable\n    ///         socket.readable().await?;\n    ///\n    ///         // The buffer is **not** included in the async task and will\n    ///         // only exist on the stack.\n    ///         let mut buf = [0; 1024];\n    ///\n    ///         // Try to recv data, this may still fail with `WouldBlock`\n    ///         // if the readiness event is a false positive.\n    ///         match socket.try_recv(&mut buf) {\n    ///             Ok(n) => {\n    ///                 println!(\"GOT {:?}\", &buf[..n]);\n    ///                 break;\n    ///             }\n    ///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {\n    ///                 continue;\n    ///             }\n    ///             Err(e) => {\n    ///                 return Err(e);\n    ///             }\n    ///         }\n    ///     }\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    pub async fn readable(&self) -> io::Result<()> {\n        self.ready(Interest::READABLE).await?;\n        Ok(())\n    }\n\n    /// Polls for read/receive readiness.\n    ///\n    /// If the udp stream is not currently ready for receiving, this method will\n    /// store a clone of the `Waker` from the provided `Context`. When the udp\n    /// socket becomes ready for reading, `Waker::wake` will be called on the\n    /// waker.\n    ///\n    /// Note that on multiple calls to `poll_recv_ready`, `poll_recv` or\n    /// `poll_peek`, only the `Waker` from the `Context` passed to the most\n    /// recent call is scheduled to receive a wakeup. (However,\n    /// `poll_send_ready` retains a second, independent waker.)\n    ///\n    /// This function is intended for cases where creating and pinning a future\n    /// via [`readable`] is not feasible. Where possible, using [`readable`] is\n    /// preferred, as this supports polling from multiple tasks at once.\n    ///\n    /// # Return value\n    ///\n    /// The function returns:\n    ///\n    /// * `Poll::Pending` if the udp stream is not ready for reading.\n    /// * `Poll::Ready(Ok(()))` if the udp stream is ready for reading.\n    /// * `Poll::Ready(Err(e))` if an error is encountered.\n    ///\n    /// # Errors\n    ///\n    /// This function may encounter any standard I/O error except `WouldBlock`.\n    ///\n    /// [`readable`]: method@Self::readable\n    pub fn poll_recv_ready(&self, cx: &mut Context<'_>) -> Poll<io::Result<()>> {\n        self.io.registration().poll_read_ready(cx).map_ok(|_| ())\n    }\n\n    /// Receives a single datagram message on the socket from the remote address\n    /// to which it is connected. On success, returns the number of bytes read.\n    ///\n    /// The function must be called with valid byte array `buf` of sufficient\n    /// size to hold the message bytes. If a message is too long to fit in the\n    /// supplied buffer, excess bytes may be discarded.\n    ///\n    /// The [`connect`] method will connect this socket to a remote address.\n    /// This method will fail if the socket is not connected.\n    ///\n    /// # Cancel safety\n    ///\n    /// This method is cancel safe. If `recv` is used as the event in a\n    /// [`tokio::select!`](crate::select) statement and some other branch\n    /// completes first, it is guaranteed that no messages were received on this\n    /// socket.\n    ///\n    /// [`connect`]: method@Self::connect\n    ///\n    /// ```no_run\n    /// use tokio::net::UdpSocket;\n    /// use std::io;\n    ///\n    /// #[tokio::main]\n    /// async fn main() -> io::Result<()> {\n    ///     // Bind socket\n    ///     let socket = UdpSocket::bind(\"127.0.0.1:8080\").await?;\n    ///     socket.connect(\"127.0.0.1:8081\").await?;\n    ///\n    ///     let mut buf = vec![0; 10];\n    ///     let n = socket.recv(&mut buf).await?;\n    ///\n    ///     println!(\"received {} bytes {:?}\", n, &buf[..n]);\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    pub async fn recv(&self, buf: &mut [u8]) -> io::Result<usize> {\n        self.io\n            .registration()\n            .async_io(Interest::READABLE, || self.io.recv(buf))\n            .await\n    }\n\n    /// Attempts to receive a single datagram message on the socket from the remote\n    /// address to which it is `connect`ed.\n    ///\n    /// The [`connect`] method will connect this socket to a remote address. This method\n    /// resolves to an error if the socket is not connected.\n    ///\n    /// Note that on multiple calls to a `poll_*` method in the `recv` direction, only the\n    /// `Waker` from the `Context` passed to the most recent call will be scheduled to\n    /// receive a wakeup.\n    ///\n    /// # Return value\n    ///\n    /// The function returns:\n    ///\n    /// * `Poll::Pending` if the socket is not ready to read\n    /// * `Poll::Ready(Ok(()))` reads data `ReadBuf` if the socket is ready\n    /// * `Poll::Ready(Err(e))` if an error is encountered.\n    ///\n    /// # Errors\n    ///\n    /// This function may encounter any standard I/O error except `WouldBlock`.\n    ///\n    /// [`connect`]: method@Self::connect\n    pub fn poll_recv(&self, cx: &mut Context<'_>, buf: &mut ReadBuf<'_>) -> Poll<io::Result<()>> {\n        #[allow(clippy::blocks_in_conditions)]\n        let n = ready!(self.io.registration().poll_read_io(cx, || {\n            // Safety: will not read the maybe uninitialized bytes.\n            let b = unsafe {\n                &mut *(buf.unfilled_mut() as *mut [std::mem::MaybeUninit<u8>] as *mut [u8])\n            };\n\n            self.io.recv(b)\n        }))?;\n\n        // Safety: We trust `recv` to have filled up `n` bytes in the buffer.\n        unsafe {\n            buf.assume_init(n);\n        }\n        buf.advance(n);\n        Poll::Ready(Ok(()))\n    }\n\n    /// Tries to receive a single datagram message on the socket from the remote\n    /// address to which it is connected. On success, returns the number of\n    /// bytes read.\n    ///\n    /// This method must be called with valid byte array `buf` of sufficient size\n    /// to hold the message bytes. If a message is too long to fit in the\n    /// supplied buffer, excess bytes may be discarded.\n    ///\n    /// When there is no pending data, `Err(io::ErrorKind::WouldBlock)` is\n    /// returned. This function is usually paired with `readable()`.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use tokio::net::UdpSocket;\n    /// use std::io;\n    ///\n    /// #[tokio::main]\n    /// async fn main() -> io::Result<()> {\n    ///     // Connect to a peer\n    ///     let socket = UdpSocket::bind(\"127.0.0.1:8080\").await?;\n    ///     socket.connect(\"127.0.0.1:8081\").await?;\n    ///\n    ///     loop {\n    ///         // Wait for the socket to be readable\n    ///         socket.readable().await?;\n    ///\n    ///         // The buffer is **not** included in the async task and will\n    ///         // only exist on the stack.\n    ///         let mut buf = [0; 1024];\n    ///\n    ///         // Try to recv data, this may still fail with `WouldBlock`\n    ///         // if the readiness event is a false positive.\n    ///         match socket.try_recv(&mut buf) {\n    ///             Ok(n) => {\n    ///                 println!(\"GOT {:?}\", &buf[..n]);\n    ///                 break;\n    ///             }\n    ///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {\n    ///                 continue;\n    ///             }\n    ///             Err(e) => {\n    ///                 return Err(e);\n    ///             }\n    ///         }\n    ///     }\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn try_recv(&self, buf: &mut [u8]) -> io::Result<usize> {\n        self.io\n            .registration()\n            .try_io(Interest::READABLE, || self.io.recv(buf))\n    }\n\n    cfg_io_util! {\n        /// Tries to receive data from the stream into the provided buffer, advancing the\n        /// buffer's internal cursor, returning how many bytes were read.\n        ///\n        /// This method must be called with valid byte array `buf` of sufficient size\n        /// to hold the message bytes. If a message is too long to fit in the\n        /// supplied buffer, excess bytes may be discarded.\n        ///\n        /// This method can be used even if `buf` is uninitialized.\n        ///\n        /// When there is no pending data, `Err(io::ErrorKind::WouldBlock)` is\n        /// returned. This function is usually paired with `readable()`.\n        ///\n        /// # Examples\n        ///\n        /// ```no_run\n        /// use tokio::net::UdpSocket;\n        /// use std::io;\n        ///\n        /// #[tokio::main]\n        /// async fn main() -> io::Result<()> {\n        ///     // Connect to a peer\n        ///     let socket = UdpSocket::bind(\"127.0.0.1:8080\").await?;\n        ///     socket.connect(\"127.0.0.1:8081\").await?;\n        ///\n        ///     loop {\n        ///         // Wait for the socket to be readable\n        ///         socket.readable().await?;\n        ///\n        ///         let mut buf = Vec::with_capacity(1024);\n        ///\n        ///         // Try to recv data, this may still fail with `WouldBlock`\n        ///         // if the readiness event is a false positive.\n        ///         match socket.try_recv_buf(&mut buf) {\n        ///             Ok(n) => {\n        ///                 println!(\"GOT {:?}\", &buf[..n]);\n        ///                 break;\n        ///             }\n        ///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {\n        ///                 continue;\n        ///             }\n        ///             Err(e) => {\n        ///                 return Err(e);\n        ///             }\n        ///         }\n        ///     }\n        ///\n        ///     Ok(())\n        /// }\n        /// ```\n        pub fn try_recv_buf<B: BufMut>(&self, buf: &mut B) -> io::Result<usize> {\n            self.io.registration().try_io(Interest::READABLE, || {\n                let dst = buf.chunk_mut();\n                let dst =\n                    unsafe { &mut *(dst as *mut _ as *mut [std::mem::MaybeUninit<u8>] as *mut [u8]) };\n\n                let n = (*self.io).recv(dst)?;\n\n                // Safety: We trust `UdpSocket::recv` to have filled up `n` bytes in the\n                // buffer.\n                unsafe {\n                    buf.advance_mut(n);\n                }\n\n                Ok(n)\n            })\n        }\n\n        /// Receives a single datagram message on the socket from the remote address\n        /// to which it is connected, advancing the buffer's internal cursor,\n        /// returning how many bytes were read.\n        ///\n        /// This method must be called with valid byte array `buf` of sufficient size\n        /// to hold the message bytes. If a message is too long to fit in the\n        /// supplied buffer, excess bytes may be discarded.\n        ///\n        /// This method can be used even if `buf` is uninitialized.\n        ///\n        /// # Examples\n        ///\n        /// ```no_run\n        /// use tokio::net::UdpSocket;\n        /// use std::io;\n        ///\n        /// #[tokio::main]\n        /// async fn main() -> io::Result<()> {\n        ///     // Connect to a peer\n        ///     let socket = UdpSocket::bind(\"127.0.0.1:8080\").await?;\n        ///     socket.connect(\"127.0.0.1:8081\").await?;\n        ///\n        ///     let mut buf = Vec::with_capacity(512);\n        ///     let len = socket.recv_buf(&mut buf).await?;\n        ///\n        ///     println!(\"received {} bytes {:?}\", len, &buf[..len]);\n        ///\n        ///     Ok(())\n        /// }\n        /// ```\n        pub async fn recv_buf<B: BufMut>(&self, buf: &mut B) -> io::Result<usize> {\n            self.io.registration().async_io(Interest::READABLE, || {\n                let dst = buf.chunk_mut();\n                let dst =\n                    unsafe { &mut *(dst as *mut _ as *mut [std::mem::MaybeUninit<u8>] as *mut [u8]) };\n\n                let n = (*self.io).recv(dst)?;\n\n                // Safety: We trust `UdpSocket::recv` to have filled up `n` bytes in the\n                // buffer.\n                unsafe {\n                    buf.advance_mut(n);\n                }\n\n                Ok(n)\n            }).await\n        }\n\n        /// Tries to receive a single datagram message on the socket. On success,\n        /// returns the number of bytes read and the origin.\n        ///\n        /// This method must be called with valid byte array `buf` of sufficient size\n        /// to hold the message bytes. If a message is too long to fit in the\n        /// supplied buffer, excess bytes may be discarded.\n        ///\n        /// This method can be used even if `buf` is uninitialized.\n        ///\n        /// When there is no pending data, `Err(io::ErrorKind::WouldBlock)` is\n        /// returned. This function is usually paired with `readable()`.\n        ///\n        /// # Notes\n        /// Note that the socket address **cannot** be implicitly trusted, because it is relatively\n        /// trivial to send a UDP datagram with a spoofed origin in a [packet injection attack].\n        /// Because UDP is stateless and does not validate the origin of a packet,\n        /// the attacker does not need to be able to intercept traffic in order to interfere.\n        /// It is important to be aware of this when designing your application-level protocol.\n        ///\n        /// [packet injection attack]: https://en.wikipedia.org/wiki/Packet_injection\n        ///\n        /// # Examples\n        ///\n        /// ```no_run\n        /// use tokio::net::UdpSocket;\n        /// use std::io;\n        ///\n        /// #[tokio::main]\n        /// async fn main() -> io::Result<()> {\n        ///     // Connect to a peer\n        ///     let socket = UdpSocket::bind(\"127.0.0.1:8080\").await?;\n        ///\n        ///     loop {\n        ///         // Wait for the socket to be readable\n        ///         socket.readable().await?;\n        ///\n        ///         let mut buf = Vec::with_capacity(1024);\n        ///\n        ///         // Try to recv data, this may still fail with `WouldBlock`\n        ///         // if the readiness event is a false positive.\n        ///         match socket.try_recv_buf_from(&mut buf) {\n        ///             Ok((n, _addr)) => {\n        ///                 println!(\"GOT {:?}\", &buf[..n]);\n        ///                 break;\n        ///             }\n        ///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {\n        ///                 continue;\n        ///             }\n        ///             Err(e) => {\n        ///                 return Err(e);\n        ///             }\n        ///         }\n        ///     }\n        ///\n        ///     Ok(())\n        /// }\n        /// ```\n        pub fn try_recv_buf_from<B: BufMut>(&self, buf: &mut B) -> io::Result<(usize, SocketAddr)> {\n            self.io.registration().try_io(Interest::READABLE, || {\n                let dst = buf.chunk_mut();\n                let dst =\n                    unsafe { &mut *(dst as *mut _ as *mut [std::mem::MaybeUninit<u8>] as *mut [u8]) };\n\n                let (n, addr) = (*self.io).recv_from(dst)?;\n\n                // Safety: We trust `UdpSocket::recv_from` to have filled up `n` bytes in the\n                // buffer.\n                unsafe {\n                    buf.advance_mut(n);\n                }\n\n                Ok((n, addr))\n            })\n        }\n\n        /// Receives a single datagram message on the socket, advancing the\n        /// buffer's internal cursor, returning how many bytes were read and the origin.\n        ///\n        /// This method must be called with valid byte array `buf` of sufficient size\n        /// to hold the message bytes. If a message is too long to fit in the\n        /// supplied buffer, excess bytes may be discarded.\n        ///\n        /// This method can be used even if `buf` is uninitialized.\n        ///\n        /// # Notes\n        /// Note that the socket address **cannot** be implicitly trusted, because it is relatively\n        /// trivial to send a UDP datagram with a spoofed origin in a [packet injection attack].\n        /// Because UDP is stateless and does not validate the origin of a packet,\n        /// the attacker does not need to be able to intercept traffic in order to interfere.\n        /// It is important to be aware of this when designing your application-level protocol.\n        ///\n        /// [packet injection attack]: https://en.wikipedia.org/wiki/Packet_injection\n        ///\n        /// # Examples\n        ///\n        /// ```no_run\n        /// use tokio::net::UdpSocket;\n        /// use std::io;\n        ///\n        /// #[tokio::main]\n        /// async fn main() -> io::Result<()> {\n        ///     // Connect to a peer\n        ///     let socket = UdpSocket::bind(\"127.0.0.1:8080\").await?;\n        ///     socket.connect(\"127.0.0.1:8081\").await?;\n        ///\n        ///     let mut buf = Vec::with_capacity(512);\n        ///     let (len, addr) = socket.recv_buf_from(&mut buf).await?;\n        ///\n        ///     println!(\"received {:?} bytes from {:?}\", len, addr);\n        ///\n        ///     Ok(())\n        /// }\n        /// ```\n        pub async fn recv_buf_from<B: BufMut>(&self, buf: &mut B) -> io::Result<(usize, SocketAddr)> {\n            self.io.registration().async_io(Interest::READABLE, || {\n                let dst = buf.chunk_mut();\n                let dst =\n                    unsafe { &mut *(dst as *mut _ as *mut [std::mem::MaybeUninit<u8>] as *mut [u8]) };\n\n                let (n, addr) = (*self.io).recv_from(dst)?;\n\n                // Safety: We trust `UdpSocket::recv_from` to have filled up `n` bytes in the\n                // buffer.\n                unsafe {\n                    buf.advance_mut(n);\n                }\n\n                Ok((n,addr))\n            }).await\n        }\n    }\n\n    /// Sends data on the socket to the given address. On success, returns the\n    /// number of bytes written.\n    ///\n    /// Address type can be any implementor of [`ToSocketAddrs`] trait. See its\n    /// documentation for concrete examples.\n    ///\n    /// It is possible for `addr` to yield multiple addresses, but `send_to`\n    /// will only send data to the first address yielded by `addr`.\n    ///\n    /// This will return an error when the IP version of the local socket does\n    /// not match that returned from [`ToSocketAddrs`].\n    ///\n    /// [`ToSocketAddrs`]: crate::net::ToSocketAddrs\n    ///\n    /// # Cancel safety\n    ///\n    /// This method is cancel safe. If `send_to` is used as the event in a\n    /// [`tokio::select!`](crate::select) statement and some other branch\n    /// completes first, then it is guaranteed that the message was not sent.\n    ///\n    /// # Example\n    ///\n    /// ```no_run\n    /// use tokio::net::UdpSocket;\n    /// use std::io;\n    ///\n    /// #[tokio::main]\n    /// async fn main() -> io::Result<()> {\n    ///     let socket = UdpSocket::bind(\"127.0.0.1:8080\").await?;\n    ///     let len = socket.send_to(b\"hello world\", \"127.0.0.1:8081\").await?;\n    ///\n    ///     println!(\"Sent {} bytes\", len);\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    pub async fn send_to<A: ToSocketAddrs>(&self, buf: &[u8], target: A) -> io::Result<usize> {\n        let mut addrs = to_socket_addrs(target).await?;\n\n        match addrs.next() {\n            Some(target) => self.send_to_addr(buf, target).await,\n            None => Err(io::Error::new(\n                io::ErrorKind::InvalidInput,\n                \"no addresses to send data to\",\n            )),\n        }\n    }\n\n    /// Attempts to send data on the socket to a given address.\n    ///\n    /// Note that on multiple calls to a `poll_*` method in the send direction, only the\n    /// `Waker` from the `Context` passed to the most recent call will be scheduled to\n    /// receive a wakeup.\n    ///\n    /// # Return value\n    ///\n    /// The function returns:\n    ///\n    /// * `Poll::Pending` if the socket is not ready to write\n    /// * `Poll::Ready(Ok(n))` `n` is the number of bytes sent.\n    /// * `Poll::Ready(Err(e))` if an error is encountered.\n    ///\n    /// # Errors\n    ///\n    /// This function may encounter any standard I/O error except `WouldBlock`.\n    pub fn poll_send_to(\n        &self,\n        cx: &mut Context<'_>,\n        buf: &[u8],\n        target: SocketAddr,\n    ) -> Poll<io::Result<usize>> {\n        self.io\n            .registration()\n            .poll_write_io(cx, || self.io.send_to(buf, target))\n    }\n\n    /// Tries to send data on the socket to the given address, but if the send is\n    /// blocked this will return right away.\n    ///\n    /// This function is usually paired with `writable()`.\n    ///\n    /// # Returns\n    ///\n    /// If successful, returns the number of bytes sent\n    ///\n    /// Users should ensure that when the remote cannot receive, the\n    /// [`ErrorKind::WouldBlock`] is properly handled. An error can also occur\n    /// if the IP version of the socket does not match that of `target`.\n    ///\n    /// [`ErrorKind::WouldBlock`]: std::io::ErrorKind::WouldBlock\n    ///\n    /// # Example\n    ///\n    /// ```no_run\n    /// use tokio::net::UdpSocket;\n    /// use std::error::Error;\n    /// use std::io;\n    ///\n    /// #[tokio::main]\n    /// async fn main() -> Result<(), Box<dyn Error>> {\n    ///     let socket = UdpSocket::bind(\"127.0.0.1:8080\").await?;\n    ///\n    ///     let dst = \"127.0.0.1:8081\".parse()?;\n    ///\n    ///     loop {\n    ///         socket.writable().await?;\n    ///\n    ///         match socket.try_send_to(&b\"hello world\"[..], dst) {\n    ///             Ok(sent) => {\n    ///                 println!(\"sent {} bytes\", sent);\n    ///                 break;\n    ///             }\n    ///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {\n    ///                 // Writable false positive.\n    ///                 continue;\n    ///             }\n    ///             Err(e) => return Err(e.into()),\n    ///         }\n    ///     }\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn try_send_to(&self, buf: &[u8], target: SocketAddr) -> io::Result<usize> {\n        self.io\n            .registration()\n            .try_io(Interest::WRITABLE, || self.io.send_to(buf, target))\n    }\n\n    async fn send_to_addr(&self, buf: &[u8], target: SocketAddr) -> io::Result<usize> {\n        self.io\n            .registration()\n            .async_io(Interest::WRITABLE, || self.io.send_to(buf, target))\n            .await\n    }\n\n    /// Receives a single datagram message on the socket. On success, returns\n    /// the number of bytes read and the origin.\n    ///\n    /// The function must be called with valid byte array `buf` of sufficient\n    /// size to hold the message bytes. If a message is too long to fit in the\n    /// supplied buffer, excess bytes may be discarded.\n    ///\n    /// # Cancel safety\n    ///\n    /// This method is cancel safe. If `recv_from` is used as the event in a\n    /// [`tokio::select!`](crate::select) statement and some other branch\n    /// completes first, it is guaranteed that no messages were received on this\n    /// socket.\n    ///\n    /// # Example\n    ///\n    /// ```no_run\n    /// use tokio::net::UdpSocket;\n    /// use std::io;\n    ///\n    /// #[tokio::main]\n    /// async fn main() -> io::Result<()> {\n    ///     let socket = UdpSocket::bind(\"127.0.0.1:8080\").await?;\n    ///\n    ///     let mut buf = vec![0u8; 32];\n    ///     let (len, addr) = socket.recv_from(&mut buf).await?;\n    ///\n    ///     println!(\"received {:?} bytes from {:?}\", len, addr);\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// # Notes\n    /// Note that the socket address **cannot** be implicitly trusted, because it is relatively\n    /// trivial to send a UDP datagram with a spoofed origin in a [packet injection attack].\n    /// Because UDP is stateless and does not validate the origin of a packet,\n    /// the attacker does not need to be able to intercept traffic in order to interfere.\n    /// It is important to be aware of this when designing your application-level protocol.\n    ///\n    /// [packet injection attack]: https://en.wikipedia.org/wiki/Packet_injection\n    pub async fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n        self.io\n            .registration()\n            .async_io(Interest::READABLE, || self.io.recv_from(buf))\n            .await\n    }\n\n    /// Attempts to receive a single datagram on the socket.\n    ///\n    /// Note that on multiple calls to a `poll_*` method in the `recv` direction, only the\n    /// `Waker` from the `Context` passed to the most recent call will be scheduled to\n    /// receive a wakeup.\n    ///\n    /// # Return value\n    ///\n    /// The function returns:\n    ///\n    /// * `Poll::Pending` if the socket is not ready to read\n    /// * `Poll::Ready(Ok(addr))` reads data from `addr` into `ReadBuf` if the socket is ready\n    /// * `Poll::Ready(Err(e))` if an error is encountered.\n    ///\n    /// # Errors\n    ///\n    /// This function may encounter any standard I/O error except `WouldBlock`.\n    ///\n    /// # Notes\n    /// Note that the socket address **cannot** be implicitly trusted, because it is relatively\n    /// trivial to send a UDP datagram with a spoofed origin in a [packet injection attack].\n    /// Because UDP is stateless and does not validate the origin of a packet,\n    /// the attacker does not need to be able to intercept traffic in order to interfere.\n    /// It is important to be aware of this when designing your application-level protocol.\n    ///\n    /// [packet injection attack]: https://en.wikipedia.org/wiki/Packet_injection\n    pub fn poll_recv_from(\n        &self,\n        cx: &mut Context<'_>,\n        buf: &mut ReadBuf<'_>,\n    ) -> Poll<io::Result<SocketAddr>> {\n        #[allow(clippy::blocks_in_conditions)]\n        let (n, addr) = ready!(self.io.registration().poll_read_io(cx, || {\n            // Safety: will not read the maybe uninitialized bytes.\n            let b = unsafe {\n                &mut *(buf.unfilled_mut() as *mut [std::mem::MaybeUninit<u8>] as *mut [u8])\n            };\n\n            self.io.recv_from(b)\n        }))?;\n\n        // Safety: We trust `recv` to have filled up `n` bytes in the buffer.\n        unsafe {\n            buf.assume_init(n);\n        }\n        buf.advance(n);\n        Poll::Ready(Ok(addr))\n    }\n\n    /// Tries to receive a single datagram message on the socket. On success,\n    /// returns the number of bytes read and the origin.\n    ///\n    /// This method must be called with valid byte array `buf` of sufficient size\n    /// to hold the message bytes. If a message is too long to fit in the\n    /// supplied buffer, excess bytes may be discarded.\n    ///\n    /// When there is no pending data, `Err(io::ErrorKind::WouldBlock)` is\n    /// returned. This function is usually paired with `readable()`.\n    ///\n    /// # Notes\n    ///\n    /// Note that the socket address **cannot** be implicitly trusted, because it is relatively\n    /// trivial to send a UDP datagram with a spoofed origin in a [packet injection attack].\n    /// Because UDP is stateless and does not validate the origin of a packet,\n    /// the attacker does not need to be able to intercept traffic in order to interfere.\n    /// It is important to be aware of this when designing your application-level protocol.\n    ///\n    /// [packet injection attack]: https://en.wikipedia.org/wiki/Packet_injection\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use tokio::net::UdpSocket;\n    /// use std::io;\n    ///\n    /// #[tokio::main]\n    /// async fn main() -> io::Result<()> {\n    ///     // Connect to a peer\n    ///     let socket = UdpSocket::bind(\"127.0.0.1:8080\").await?;\n    ///\n    ///     loop {\n    ///         // Wait for the socket to be readable\n    ///         socket.readable().await?;\n    ///\n    ///         // The buffer is **not** included in the async task and will\n    ///         // only exist on the stack.\n    ///         let mut buf = [0; 1024];\n    ///\n    ///         // Try to recv data, this may still fail with `WouldBlock`\n    ///         // if the readiness event is a false positive.\n    ///         match socket.try_recv_from(&mut buf) {\n    ///             Ok((n, _addr)) => {\n    ///                 println!(\"GOT {:?}\", &buf[..n]);\n    ///                 break;\n    ///             }\n    ///             Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {\n    ///                 continue;\n    ///             }\n    ///             Err(e) => {\n    ///                 return Err(e);\n    ///             }\n    ///         }\n    ///     }\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn try_recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n        self.io\n            .registration()\n            .try_io(Interest::READABLE, || self.io.recv_from(buf))\n    }\n\n    /// Tries to read or write from the socket using a user-provided IO operation.\n    ///\n    /// If the socket is ready, the provided closure is called. The closure\n    /// should attempt to perform IO operation on the socket by manually\n    /// calling the appropriate syscall. If the operation fails because the\n    /// socket is not actually ready, then the closure should return a\n    /// `WouldBlock` error and the readiness flag is cleared. The return value\n    /// of the closure is then returned by `try_io`.\n    ///\n    /// If the socket is not ready, then the closure is not called\n    /// and a `WouldBlock` error is returned.\n    ///\n    /// The closure should only return a `WouldBlock` error if it has performed\n    /// an IO operation on the socket that failed due to the socket not being\n    /// ready. Returning a `WouldBlock` error in any other situation will\n    /// incorrectly clear the readiness flag, which can cause the socket to\n    /// behave incorrectly.\n    ///\n    /// The closure should not perform the IO operation using any of the methods\n    /// defined on the Tokio `UdpSocket` type, as this will mess with the\n    /// readiness flag and can cause the socket to behave incorrectly.\n    ///\n    /// This method is not intended to be used with combined interests.\n    /// The closure should perform only one type of IO operation, so it should not\n    /// require more than one ready state. This method may panic or sleep forever\n    /// if it is called with a combined interest.\n    ///\n    /// Usually, [`readable()`], [`writable()`] or [`ready()`] is used with this function.\n    ///\n    /// [`readable()`]: UdpSocket::readable()\n    /// [`writable()`]: UdpSocket::writable()\n    /// [`ready()`]: UdpSocket::ready()\n    pub fn try_io<R>(\n        &self,\n        interest: Interest,\n        f: impl FnOnce() -> io::Result<R>,\n    ) -> io::Result<R> {\n        self.io\n            .registration()\n            .try_io(interest, || self.io.try_io(f))\n    }\n\n    /// Reads or writes from the socket using a user-provided IO operation.\n    ///\n    /// The readiness of the socket is awaited and when the socket is ready,\n    /// the provided closure is called. The closure should attempt to perform\n    /// IO operation on the socket by manually calling the appropriate syscall.\n    /// If the operation fails because the socket is not actually ready,\n    /// then the closure should return a `WouldBlock` error. In such case the\n    /// readiness flag is cleared and the socket readiness is awaited again.\n    /// This loop is repeated until the closure returns an `Ok` or an error\n    /// other than `WouldBlock`.\n    ///\n    /// The closure should only return a `WouldBlock` error if it has performed\n    /// an IO operation on the socket that failed due to the socket not being\n    /// ready. Returning a `WouldBlock` error in any other situation will\n    /// incorrectly clear the readiness flag, which can cause the socket to\n    /// behave incorrectly.\n    ///\n    /// The closure should not perform the IO operation using any of the methods\n    /// defined on the Tokio `UdpSocket` type, as this will mess with the\n    /// readiness flag and can cause the socket to behave incorrectly.\n    ///\n    /// This method is not intended to be used with combined interests.\n    /// The closure should perform only one type of IO operation, so it should not\n    /// require more than one ready state. This method may panic or sleep forever\n    /// if it is called with a combined interest.\n    pub async fn async_io<R>(\n        &self,\n        interest: Interest,\n        mut f: impl FnMut() -> io::Result<R>,\n    ) -> io::Result<R> {\n        self.io\n            .registration()\n            .async_io(interest, || self.io.try_io(&mut f))\n            .await\n    }\n\n    /// Receives data from the socket, without removing it from the input queue.\n    /// On success, returns the number of bytes read and the address from whence\n    /// the data came.\n    ///\n    /// # Notes\n    ///\n    /// On Windows, if the data is larger than the buffer specified, the buffer\n    /// is filled with the first part of the data, and `peek_from` returns the error\n    /// `WSAEMSGSIZE(10040)`. The excess data is lost.\n    /// Make sure to always use a sufficiently large buffer to hold the\n    /// maximum UDP packet size, which can be up to 65536 bytes in size.\n    ///\n    /// MacOS will return an error if you pass a zero-sized buffer.\n    ///\n    /// If you're merely interested in learning the sender of the data at the head of the queue,\n    /// try [`peek_sender`].\n    ///\n    /// Note that the socket address **cannot** be implicitly trusted, because it is relatively\n    /// trivial to send a UDP datagram with a spoofed origin in a [packet injection attack].\n    /// Because UDP is stateless and does not validate the origin of a packet,\n    /// the attacker does not need to be able to intercept traffic in order to interfere.\n    /// It is important to be aware of this when designing your application-level protocol.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use tokio::net::UdpSocket;\n    /// use std::io;\n    ///\n    /// #[tokio::main]\n    /// async fn main() -> io::Result<()> {\n    ///     let socket = UdpSocket::bind(\"127.0.0.1:8080\").await?;\n    ///\n    ///     let mut buf = vec![0u8; 32];\n    ///     let (len, addr) = socket.peek_from(&mut buf).await?;\n    ///\n    ///     println!(\"peeked {:?} bytes from {:?}\", len, addr);\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    ///\n    /// [`peek_sender`]: method@Self::peek_sender\n    /// [packet injection attack]: https://en.wikipedia.org/wiki/Packet_injection\n    pub async fn peek_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n        self.io\n            .registration()\n            .async_io(Interest::READABLE, || self.io.peek_from(buf))\n            .await\n    }\n\n    /// Receives data from the socket, without removing it from the input queue.\n    /// On success, returns the sending address of the datagram.\n    ///\n    /// # Notes\n    ///\n    /// Note that on multiple calls to a `poll_*` method in the `recv` direction, only the\n    /// `Waker` from the `Context` passed to the most recent call will be scheduled to\n    /// receive a wakeup\n    ///\n    /// On Windows, if the data is larger than the buffer specified, the buffer\n    /// is filled with the first part of the data, and peek returns the error\n    /// `WSAEMSGSIZE(10040)`. The excess data is lost.\n    /// Make sure to always use a sufficiently large buffer to hold the\n    /// maximum UDP packet size, which can be up to 65536 bytes in size.\n    ///\n    /// MacOS will return an error if you pass a zero-sized buffer.\n    ///\n    /// If you're merely interested in learning the sender of the data at the head of the queue,\n    /// try [`poll_peek_sender`].\n    ///\n    /// Note that the socket address **cannot** be implicitly trusted, because it is relatively\n    /// trivial to send a UDP datagram with a spoofed origin in a [packet injection attack].\n    /// Because UDP is stateless and does not validate the origin of a packet,\n    /// the attacker does not need to be able to intercept traffic in order to interfere.\n    /// It is important to be aware of this when designing your application-level protocol.\n    ///\n    /// # Return value\n    ///\n    /// The function returns:\n    ///\n    /// * `Poll::Pending` if the socket is not ready to read\n    /// * `Poll::Ready(Ok(addr))` reads data from `addr` into `ReadBuf` if the socket is ready\n    /// * `Poll::Ready(Err(e))` if an error is encountered.\n    ///\n    /// # Errors\n    ///\n    /// This function may encounter any standard I/O error except `WouldBlock`.\n    ///\n    /// [`poll_peek_sender`]: method@Self::poll_peek_sender\n    /// [packet injection attack]: https://en.wikipedia.org/wiki/Packet_injection\n    pub fn poll_peek_from(\n        &self,\n        cx: &mut Context<'_>,\n        buf: &mut ReadBuf<'_>,\n    ) -> Poll<io::Result<SocketAddr>> {\n        #[allow(clippy::blocks_in_conditions)]\n        let (n, addr) = ready!(self.io.registration().poll_read_io(cx, || {\n            // Safety: will not read the maybe uninitialized bytes.\n            let b = unsafe {\n                &mut *(buf.unfilled_mut() as *mut [std::mem::MaybeUninit<u8>] as *mut [u8])\n            };\n\n            self.io.peek_from(b)\n        }))?;\n\n        // Safety: We trust `recv` to have filled up `n` bytes in the buffer.\n        unsafe {\n            buf.assume_init(n);\n        }\n        buf.advance(n);\n        Poll::Ready(Ok(addr))\n    }\n\n    /// Tries to receive data on the socket without removing it from the input queue.\n    /// On success, returns the number of bytes read and the sending address of the\n    /// datagram.\n    ///\n    /// When there is no pending data, `Err(io::ErrorKind::WouldBlock)` is\n    /// returned. This function is usually paired with `readable()`.\n    ///\n    /// # Notes\n    ///\n    /// On Windows, if the data is larger than the buffer specified, the buffer\n    /// is filled with the first part of the data, and peek returns the error\n    /// `WSAEMSGSIZE(10040)`. The excess data is lost.\n    /// Make sure to always use a sufficiently large buffer to hold the\n    /// maximum UDP packet size, which can be up to 65536 bytes in size.\n    ///\n    /// MacOS will return an error if you pass a zero-sized buffer.\n    ///\n    /// If you're merely interested in learning the sender of the data at the head of the queue,\n    /// try [`try_peek_sender`].\n    ///\n    /// Note that the socket address **cannot** be implicitly trusted, because it is relatively\n    /// trivial to send a UDP datagram with a spoofed origin in a [packet injection attack].\n    /// Because UDP is stateless and does not validate the origin of a packet,\n    /// the attacker does not need to be able to intercept traffic in order to interfere.\n    /// It is important to be aware of this when designing your application-level protocol.\n    ///\n    /// [`try_peek_sender`]: method@Self::try_peek_sender\n    /// [packet injection attack]: https://en.wikipedia.org/wiki/Packet_injection\n    pub fn try_peek_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n        self.io\n            .registration()\n            .try_io(Interest::READABLE, || self.io.peek_from(buf))\n    }\n\n    /// Retrieve the sender of the data at the head of the input queue, waiting if empty.\n    ///\n    /// This is equivalent to calling [`peek_from`] with a zero-sized buffer,\n    /// but suppresses the `WSAEMSGSIZE` error on Windows and the \"invalid argument\" error on macOS.\n    ///\n    /// Note that the socket address **cannot** be implicitly trusted, because it is relatively\n    /// trivial to send a UDP datagram with a spoofed origin in a [packet injection attack].\n    /// Because UDP is stateless and does not validate the origin of a packet,\n    /// the attacker does not need to be able to intercept traffic in order to interfere.\n    /// It is important to be aware of this when designing your application-level protocol.\n    ///\n    /// [`peek_from`]: method@Self::peek_from\n    /// [packet injection attack]: https://en.wikipedia.org/wiki/Packet_injection\n    pub async fn peek_sender(&self) -> io::Result<SocketAddr> {\n        self.io\n            .registration()\n            .async_io(Interest::READABLE, || self.peek_sender_inner())\n            .await\n    }\n\n    /// Retrieve the sender of the data at the head of the input queue,\n    /// scheduling a wakeup if empty.\n    ///\n    /// This is equivalent to calling [`poll_peek_from`] with a zero-sized buffer,\n    /// but suppresses the `WSAEMSGSIZE` error on Windows and the \"invalid argument\" error on macOS.\n    ///\n    /// # Notes\n    ///\n    /// Note that on multiple calls to a `poll_*` method in the `recv` direction, only the\n    /// `Waker` from the `Context` passed to the most recent call will be scheduled to\n    /// receive a wakeup.\n    ///\n    /// Note that the socket address **cannot** be implicitly trusted, because it is relatively\n    /// trivial to send a UDP datagram with a spoofed origin in a [packet injection attack].\n    /// Because UDP is stateless and does not validate the origin of a packet,\n    /// the attacker does not need to be able to intercept traffic in order to interfere.\n    /// It is important to be aware of this when designing your application-level protocol.\n    ///\n    /// [`poll_peek_from`]: method@Self::poll_peek_from\n    /// [packet injection attack]: https://en.wikipedia.org/wiki/Packet_injection\n    pub fn poll_peek_sender(&self, cx: &mut Context<'_>) -> Poll<io::Result<SocketAddr>> {\n        self.io\n            .registration()\n            .poll_read_io(cx, || self.peek_sender_inner())\n    }\n\n    /// Try to retrieve the sender of the data at the head of the input queue.\n    ///\n    /// When there is no pending data, `Err(io::ErrorKind::WouldBlock)` is\n    /// returned. This function is usually paired with `readable()`.\n    ///\n    /// Note that the socket address **cannot** be implicitly trusted, because it is relatively\n    /// trivial to send a UDP datagram with a spoofed origin in a [packet injection attack].\n    /// Because UDP is stateless and does not validate the origin of a packet,\n    /// the attacker does not need to be able to intercept traffic in order to interfere.\n    /// It is important to be aware of this when designing your application-level protocol.\n    ///\n    /// [packet injection attack]: https://en.wikipedia.org/wiki/Packet_injection\n    pub fn try_peek_sender(&self) -> io::Result<SocketAddr> {\n        self.io\n            .registration()\n            .try_io(Interest::READABLE, || self.peek_sender_inner())\n    }\n\n    #[inline]\n    fn peek_sender_inner(&self) -> io::Result<SocketAddr> {\n        self.io.try_io(|| {\n            self.as_socket()\n                .peek_sender()?\n                // May be `None` if the platform doesn't populate the sender for some reason.\n                // In testing, that only occurred on macOS if you pass a zero-sized buffer,\n                // but the implementation of `Socket::peek_sender()` covers that.\n                .as_socket()\n                .ok_or_else(|| io::Error::new(io::ErrorKind::Other, \"sender not available\"))\n        })\n    }\n\n    /// Gets the value of the `SO_BROADCAST` option for this socket.\n    ///\n    /// For more information about this option, see [`set_broadcast`].\n    ///\n    /// [`set_broadcast`]: method@Self::set_broadcast\n    pub fn broadcast(&self) -> io::Result<bool> {\n        self.io.broadcast()\n    }\n\n    /// Sets the value of the `SO_BROADCAST` option for this socket.\n    ///\n    /// When enabled, this socket is allowed to send packets to a broadcast\n    /// address.\n    pub fn set_broadcast(&self, on: bool) -> io::Result<()> {\n        self.io.set_broadcast(on)\n    }\n\n    /// Gets the value of the `IP_MULTICAST_LOOP` option for this socket.\n    ///\n    /// For more information about this option, see [`set_multicast_loop_v4`].\n    ///\n    /// [`set_multicast_loop_v4`]: method@Self::set_multicast_loop_v4\n    pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n        self.io.multicast_loop_v4()\n    }\n\n    /// Sets the value of the `IP_MULTICAST_LOOP` option for this socket.\n    ///\n    /// If enabled, multicast packets will be looped back to the local socket.\n    ///\n    /// # Note\n    ///\n    /// This may not have any affect on IPv6 sockets.\n    pub fn set_multicast_loop_v4(&self, on: bool) -> io::Result<()> {\n        self.io.set_multicast_loop_v4(on)\n    }\n\n    /// Gets the value of the `IP_MULTICAST_TTL` option for this socket.\n    ///\n    /// For more information about this option, see [`set_multicast_ttl_v4`].\n    ///\n    /// [`set_multicast_ttl_v4`]: method@Self::set_multicast_ttl_v4\n    pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n        self.io.multicast_ttl_v4()\n    }\n\n    /// Sets the value of the `IP_MULTICAST_TTL` option for this socket.\n    ///\n    /// Indicates the time-to-live value of outgoing multicast packets for\n    /// this socket. The default value is 1 which means that multicast packets\n    /// don't leave the local network unless explicitly requested.\n    ///\n    /// # Note\n    ///\n    /// This may not have any affect on IPv6 sockets.\n    pub fn set_multicast_ttl_v4(&self, ttl: u32) -> io::Result<()> {\n        self.io.set_multicast_ttl_v4(ttl)\n    }\n\n    /// Gets the value of the `IPV6_MULTICAST_LOOP` option for this socket.\n    ///\n    /// For more information about this option, see [`set_multicast_loop_v6`].\n    ///\n    /// [`set_multicast_loop_v6`]: method@Self::set_multicast_loop_v6\n    pub fn multicast_loop_v6(&self) -> io::Result<bool> {\n        self.io.multicast_loop_v6()\n    }\n\n    /// Sets the value of the `IPV6_MULTICAST_LOOP` option for this socket.\n    ///\n    /// Controls whether this socket sees the multicast packets it sends itself.\n    ///\n    /// # Note\n    ///\n    /// This may not have any affect on IPv4 sockets.\n    pub fn set_multicast_loop_v6(&self, on: bool) -> io::Result<()> {\n        self.io.set_multicast_loop_v6(on)\n    }\n\n    /// Gets the value of the `IP_TTL` option for this socket.\n    ///\n    /// For more information about this option, see [`set_ttl`].\n    ///\n    /// [`set_ttl`]: method@Self::set_ttl\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use tokio::net::UdpSocket;\n    /// # use std::io;\n    ///\n    /// # async fn dox() -> io::Result<()> {\n    /// let sock = UdpSocket::bind(\"127.0.0.1:8080\").await?;\n    ///\n    /// println!(\"{:?}\", sock.ttl()?);\n    /// # Ok(())\n    /// # }\n    /// ```\n    pub fn ttl(&self) -> io::Result<u32> {\n        self.io.ttl()\n    }\n\n    /// Sets the value for the `IP_TTL` option on this socket.\n    ///\n    /// This value sets the time-to-live field that is used in every packet sent\n    /// from this socket.\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use tokio::net::UdpSocket;\n    /// # use std::io;\n    ///\n    /// # async fn dox() -> io::Result<()> {\n    /// let sock = UdpSocket::bind(\"127.0.0.1:8080\").await?;\n    /// sock.set_ttl(60)?;\n    ///\n    /// # Ok(())\n    /// # }\n    /// ```\n    pub fn set_ttl(&self, ttl: u32) -> io::Result<()> {\n        self.io.set_ttl(ttl)\n    }\n\n    /// Gets the value of the `IP_TOS` option for this socket.\n    ///\n    /// For more information about this option, see [`set_tos`].\n    ///\n    /// **NOTE:** On Windows, `IP_TOS` is only supported on [Windows 8+ or\n    /// Windows Server 2012+.](https://docs.microsoft.com/en-us/windows/win32/winsock/ipproto-ip-socket-options)\n    ///\n    /// [`set_tos`]: Self::set_tos\n    // https://docs.rs/socket2/0.5.3/src/socket2/socket.rs.html#1464\n    #[cfg(not(any(\n        target_os = \"fuchsia\",\n        target_os = \"redox\",\n        target_os = \"solaris\",\n        target_os = \"illumos\",\n    )))]\n    #[cfg_attr(\n        docsrs,\n        doc(cfg(not(any(\n            target_os = \"fuchsia\",\n            target_os = \"redox\",\n            target_os = \"solaris\",\n            target_os = \"illumos\",\n        ))))\n    )]\n    pub fn tos(&self) -> io::Result<u32> {\n        self.as_socket().tos()\n    }\n\n    /// Sets the value for the `IP_TOS` option on this socket.\n    ///\n    /// This value sets the type-of-service field that is used in every packet\n    /// sent from this socket.\n    ///\n    /// **NOTE:** On Windows, `IP_TOS` is only supported on [Windows 8+ or\n    /// Windows Server 2012+.](https://docs.microsoft.com/en-us/windows/win32/winsock/ipproto-ip-socket-options)\n    // https://docs.rs/socket2/0.5.3/src/socket2/socket.rs.html#1446\n    #[cfg(not(any(\n        target_os = \"fuchsia\",\n        target_os = \"redox\",\n        target_os = \"solaris\",\n        target_os = \"illumos\",\n    )))]\n    #[cfg_attr(\n        docsrs,\n        doc(cfg(not(any(\n            target_os = \"fuchsia\",\n            target_os = \"redox\",\n            target_os = \"solaris\",\n            target_os = \"illumos\",\n        ))))\n    )]\n    pub fn set_tos(&self, tos: u32) -> io::Result<()> {\n        self.as_socket().set_tos(tos)\n    }\n\n    /// Gets the value for the `SO_BINDTODEVICE` option on this socket\n    ///\n    /// This value gets the socket-bound device's interface name.\n    #[cfg(any(target_os = \"android\", target_os = \"fuchsia\", target_os = \"linux\",))]\n    #[cfg_attr(\n        docsrs,\n        doc(cfg(any(target_os = \"android\", target_os = \"fuchsia\", target_os = \"linux\",)))\n    )]\n    pub fn device(&self) -> io::Result<Option<Vec<u8>>> {\n        self.as_socket().device()\n    }\n\n    /// Sets the value for the `SO_BINDTODEVICE` option on this socket\n    ///\n    /// If a socket is bound to an interface, only packets received from that\n    /// particular interface are processed by the socket. Note that this only\n    /// works for some socket types, particularly `AF_INET` sockets.\n    ///\n    /// If `interface` is `None` or an empty string it removes the binding.\n    #[cfg(any(target_os = \"android\", target_os = \"fuchsia\", target_os = \"linux\"))]\n    #[cfg_attr(\n        docsrs,\n        doc(cfg(all(any(target_os = \"android\", target_os = \"fuchsia\", target_os = \"linux\"))))\n    )]\n    pub fn bind_device(&self, interface: Option<&[u8]>) -> io::Result<()> {\n        self.as_socket().bind_device(interface)\n    }\n\n    /// Executes an operation of the `IP_ADD_MEMBERSHIP` type.\n    ///\n    /// This function specifies a new multicast group for this socket to join.\n    /// The address must be a valid multicast address, and `interface` is the\n    /// address of the local interface with which the system should join the\n    /// multicast group. If it's equal to `INADDR_ANY` then an appropriate\n    /// interface is chosen by the system.\n    pub fn join_multicast_v4(&self, multiaddr: Ipv4Addr, interface: Ipv4Addr) -> io::Result<()> {\n        self.io.join_multicast_v4(&multiaddr, &interface)\n    }\n\n    /// Executes an operation of the `IPV6_ADD_MEMBERSHIP` type.\n    ///\n    /// This function specifies a new multicast group for this socket to join.\n    /// The address must be a valid multicast address, and `interface` is the\n    /// index of the interface to join/leave (or 0 to indicate any interface).\n    pub fn join_multicast_v6(&self, multiaddr: &Ipv6Addr, interface: u32) -> io::Result<()> {\n        self.io.join_multicast_v6(multiaddr, interface)\n    }\n\n    /// Executes an operation of the `IP_DROP_MEMBERSHIP` type.\n    ///\n    /// For more information about this option, see [`join_multicast_v4`].\n    ///\n    /// [`join_multicast_v4`]: method@Self::join_multicast_v4\n    pub fn leave_multicast_v4(&self, multiaddr: Ipv4Addr, interface: Ipv4Addr) -> io::Result<()> {\n        self.io.leave_multicast_v4(&multiaddr, &interface)\n    }\n\n    /// Executes an operation of the `IPV6_DROP_MEMBERSHIP` type.\n    ///\n    /// For more information about this option, see [`join_multicast_v6`].\n    ///\n    /// [`join_multicast_v6`]: method@Self::join_multicast_v6\n    pub fn leave_multicast_v6(&self, multiaddr: &Ipv6Addr, interface: u32) -> io::Result<()> {\n        self.io.leave_multicast_v6(multiaddr, interface)\n    }\n\n    /// Returns the value of the `SO_ERROR` option.\n    ///\n    /// # Examples\n    /// ```\n    /// use tokio::net::UdpSocket;\n    /// use std::io;\n    ///\n    /// #[tokio::main]\n    /// async fn main() -> io::Result<()> {\n    ///     // Create a socket\n    ///     let socket = UdpSocket::bind(\"0.0.0.0:8080\").await?;\n    ///\n    ///     if let Ok(Some(err)) = socket.take_error() {\n    ///         println!(\"Got error: {:?}\", err);\n    ///     }\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n        self.io.take_error()\n    }\n}\n\nimpl TryFrom<std::net::UdpSocket> for UdpSocket {\n    type Error = io::Error;\n\n    /// Consumes stream, returning the tokio I/O object.\n    ///\n    /// This is equivalent to\n    /// [`UdpSocket::from_std(stream)`](UdpSocket::from_std).\n    fn try_from(stream: std::net::UdpSocket) -> Result<Self, Self::Error> {\n        Self::from_std(stream)\n    }\n}\n\nimpl fmt::Debug for UdpSocket {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.io.fmt(f)\n    }\n}\n\n#[cfg(unix)]\nmod sys {\n    use super::UdpSocket;\n    use std::os::unix::prelude::*;\n\n    impl AsRawFd for UdpSocket {\n        fn as_raw_fd(&self) -> RawFd {\n            self.io.as_raw_fd()\n        }\n    }\n\n    impl AsFd for UdpSocket {\n        fn as_fd(&self) -> BorrowedFd<'_> {\n            unsafe { BorrowedFd::borrow_raw(self.as_raw_fd()) }\n        }\n    }\n}\n\ncfg_windows! {\n    use crate::os::windows::io::{AsRawSocket, RawSocket};\n    use crate::os::windows::io::{AsSocket, BorrowedSocket};\n\n    impl AsRawSocket for UdpSocket {\n        fn as_raw_socket(&self) -> RawSocket {\n            self.io.as_raw_socket()\n        }\n    }\n\n    impl AsSocket for UdpSocket {\n        fn as_socket(&self) -> BorrowedSocket<'_> {\n            unsafe { BorrowedSocket::borrow_raw(self.as_raw_socket()) }\n        }\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "ccb6359ed0c76e6106db53e5418fe1797ceef96c",
    "func": "use crate::{Image, TextureFormatPixelInfo};\nuse bevy_asset::RenderAssetUsages;\nuse derive_more::derive::{Display, Error};\nuse image::{DynamicImage, ImageBuffer};\nuse wgpu::{Extent3d, TextureDimension, TextureFormat};\n\nimpl Image {\n    /// Converts a [`DynamicImage`] to an [`Image`].\n    pub fn from_dynamic(\n        dyn_img: DynamicImage,\n        is_srgb: bool,\n        asset_usage: RenderAssetUsages,\n    ) -> Image {\n        use bytemuck::cast_slice;\n        let width;\n        let height;\n\n        let data: Vec<u8>;\n        let format: TextureFormat;\n\n        match dyn_img {\n            DynamicImage::ImageLuma8(image) => {\n                let i = DynamicImage::ImageLuma8(image).into_rgba8();\n                width = i.width();\n                height = i.height();\n                format = if is_srgb {\n                    TextureFormat::Rgba8UnormSrgb\n                } else {\n                    TextureFormat::Rgba8Unorm\n                };\n\n                data = i.into_raw();\n            }\n            DynamicImage::ImageLumaA8(image) => {\n                let i = DynamicImage::ImageLumaA8(image).into_rgba8();\n                width = i.width();\n                height = i.height();\n                format = if is_srgb {\n                    TextureFormat::Rgba8UnormSrgb\n                } else {\n                    TextureFormat::Rgba8Unorm\n                };\n\n                data = i.into_raw();\n            }\n            DynamicImage::ImageRgb8(image) => {\n                let i = DynamicImage::ImageRgb8(image).into_rgba8();\n                width = i.width();\n                height = i.height();\n                format = if is_srgb {\n                    TextureFormat::Rgba8UnormSrgb\n                } else {\n                    TextureFormat::Rgba8Unorm\n                };\n\n                data = i.into_raw();\n            }\n            DynamicImage::ImageRgba8(image) => {\n                width = image.width();\n                height = image.height();\n                format = if is_srgb {\n                    TextureFormat::Rgba8UnormSrgb\n                } else {\n                    TextureFormat::Rgba8Unorm\n                };\n\n                data = image.into_raw();\n            }\n            DynamicImage::ImageLuma16(image) => {\n                width = image.width();\n                height = image.height();\n                format = TextureFormat::R16Uint;\n\n                let raw_data = image.into_raw();\n\n                data = cast_slice(&raw_data).to_owned();\n            }\n            DynamicImage::ImageLumaA16(image) => {\n                width = image.width();\n                height = image.height();\n                format = TextureFormat::Rg16Uint;\n\n                let raw_data = image.into_raw();\n\n                data = cast_slice(&raw_data).to_owned();\n            }\n            DynamicImage::ImageRgb16(image) => {\n                let i = DynamicImage::ImageRgb16(image).into_rgba16();\n                width = i.width();\n                height = i.height();\n                format = TextureFormat::Rgba16Unorm;\n\n                let raw_data = i.into_raw();\n\n                data = cast_slice(&raw_data).to_owned();\n            }\n            DynamicImage::ImageRgba16(image) => {\n                width = image.width();\n                height = image.height();\n                format = TextureFormat::Rgba16Unorm;\n\n                let raw_data = image.into_raw();\n\n                data = cast_slice(&raw_data).to_owned();\n            }\n            DynamicImage::ImageRgb32F(image) => {\n                width = image.width();\n                height = image.height();\n                format = TextureFormat::Rgba32Float;\n\n                let mut local_data =\n                    Vec::with_capacity(width as usize * height as usize * format.pixel_size());\n\n                for pixel in image.into_raw().chunks_exact(3) {\n                    // TODO: use the array_chunks method once stabilized\n                    // https://github.com/rust-lang/rust/issues/74985\n                    let r = pixel[0];\n                    let g = pixel[1];\n                    let b = pixel[2];\n                    let a = 1f32;\n\n                    local_data.extend_from_slice(&r.to_le_bytes());\n                    local_data.extend_from_slice(&g.to_le_bytes());\n                    local_data.extend_from_slice(&b.to_le_bytes());\n                    local_data.extend_from_slice(&a.to_le_bytes());\n                }\n\n                data = local_data;\n            }\n            DynamicImage::ImageRgba32F(image) => {\n                width = image.width();\n                height = image.height();\n                format = TextureFormat::Rgba32Float;\n\n                let raw_data = image.into_raw();\n\n                data = cast_slice(&raw_data).to_owned();\n            }\n            // DynamicImage is now non exhaustive, catch future variants and convert them\n            _ => {\n                let image = dyn_img.into_rgba8();\n                width = image.width();\n                height = image.height();\n                format = TextureFormat::Rgba8UnormSrgb;\n\n                data = image.into_raw();\n            }\n        }\n\n        Image::new(\n            Extent3d {\n                width,\n                height,\n                depth_or_array_layers: 1,\n            },\n            TextureDimension::D2,\n            data,\n            format,\n            asset_usage,\n        )\n    }\n\n    /// Convert a [`Image`] to a [`DynamicImage`]. Useful for editing image\n    /// data. Not all [`TextureFormat`] are covered, therefore it will return an\n    /// error if the format is unsupported. Supported formats are:\n    /// - `TextureFormat::R8Unorm`\n    /// - `TextureFormat::Rg8Unorm`\n    /// - `TextureFormat::Rgba8UnormSrgb`\n    /// - `TextureFormat::Bgra8UnormSrgb`\n    ///\n    /// To convert [`Image`] to a different format see: [`Image::convert`].\n    pub fn try_into_dynamic(self) -> Result<DynamicImage, IntoDynamicImageError> {\n        match self.texture_descriptor.format {\n            TextureFormat::R8Unorm => ImageBuffer::from_raw(self.width(), self.height(), self.data)\n                .map(DynamicImage::ImageLuma8),\n            TextureFormat::Rg8Unorm => {\n                ImageBuffer::from_raw(self.width(), self.height(), self.data)\n                    .map(DynamicImage::ImageLumaA8)\n            }\n            TextureFormat::Rgba8UnormSrgb => {\n                ImageBuffer::from_raw(self.width(), self.height(), self.data)\n                    .map(DynamicImage::ImageRgba8)\n            }\n            // This format is commonly used as the format for the swapchain texture\n            // This conversion is added here to support screenshots\n            TextureFormat::Bgra8UnormSrgb | TextureFormat::Bgra8Unorm => {\n                ImageBuffer::from_raw(self.width(), self.height(), {\n                    let mut data = self.data;\n                    for bgra in data.chunks_exact_mut(4) {\n                        bgra.swap(0, 2);\n                    }\n                    data\n                })\n                .map(DynamicImage::ImageRgba8)\n            }\n            // Throw and error if conversion isn't supported\n            texture_format => return Err(IntoDynamicImageError::UnsupportedFormat(texture_format)),\n        }\n        .ok_or(IntoDynamicImageError::UnknownConversionError(\n            self.texture_descriptor.format,\n        ))\n    }\n}\n\n/// Errors that occur while converting an [`Image`] into a [`DynamicImage`]\n#[non_exhaustive]\n#[derive(Error, Display, Debug)]\npub enum IntoDynamicImageError {\n    /// Conversion into dynamic image not supported for source format.\n    #[display(\"Conversion into dynamic image not supported for {_0:?}.\")]\n    #[error(ignore)]\n    UnsupportedFormat(TextureFormat),\n\n    /// Encountered an unknown error during conversion.\n    #[display(\"Failed to convert into {_0:?}.\")]\n    #[error(ignore)]\n    UnknownConversionError(TextureFormat),\n}\n\n#[cfg(test)]\nmod test {\n    use image::{GenericImage, Rgba};\n\n    use super::*;\n\n    #[test]\n    fn two_way_conversion() {\n        // Check to see if color is preserved through an rgba8 conversion and back.\n        let mut initial = DynamicImage::new_rgba8(1, 1);\n        initial.put_pixel(0, 0, Rgba::from([132, 3, 7, 200]));\n\n        let image = Image::from_dynamic(initial.clone(), true, RenderAssetUsages::RENDER_WORLD);\n\n        // NOTE: Fails if `is_srbg = false` or the dynamic image is of the type rgb8.\n        assert_eq!(initial, image.try_into_dynamic().unwrap());\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "06dacdbfcc16c80c701fedf69b1c110975c68c86",
    "func": "//! Generic types allow us to reuse logic across many related systems,\n//! allowing us to specialize our function's behavior based on which type (or types) are passed in.\n//!\n//! This is commonly useful for working on related components or resources,\n//! where we want to have unique types for querying purposes but want them all to work the same way.\n//! This is particularly powerful when combined with user-defined traits to add more functionality to these related types.\n//! Remember to insert a specialized copy of the system into the schedule for each type that you want to operate on!\n//!\n//! For more advice on working with generic types in Rust, check out <https://doc.rust-lang.org/book/ch10-01-syntax.html>\n//! or <https://doc.rust-lang.org/rust-by-example/generics.html>\n\nuse bevy::prelude::*;\n\n#[derive(Debug, Default, Clone, Copy, Eq, PartialEq, Hash, States)]\nenum AppState {\n    #[default]\n    MainMenu,\n    InGame,\n}\n\n#[derive(Component)]\nstruct TextToPrint(String);\n\n#[derive(Component, Deref, DerefMut)]\nstruct PrinterTick(Timer);\n\n#[derive(Component)]\nstruct MenuClose;\n\n#[derive(Component)]\nstruct LevelUnload;\n\nfn main() {\n    App::new()\n        .add_plugins(DefaultPlugins)\n        .init_state::<AppState>()\n        .add_systems(Startup, setup_system)\n        .add_systems(\n            Update,\n            (\n                print_text_system,\n                transition_to_in_game_system.run_if(in_state(AppState::MainMenu)),\n            ),\n        )\n        // Cleanup systems.\n        // Pass in the types your system should operate on using the ::<T> (turbofish) syntax\n        .add_systems(OnExit(AppState::MainMenu), cleanup_system::<MenuClose>)\n        .add_systems(OnExit(AppState::InGame), cleanup_system::<LevelUnload>)\n        .run();\n}\n\nfn setup_system(mut commands: Commands) {\n    commands.spawn((\n        PrinterTick(Timer::from_seconds(1.0, TimerMode::Repeating)),\n        TextToPrint(\"I will print until you press space.\".to_string()),\n        MenuClose,\n    ));\n\n    commands.spawn((\n        PrinterTick(Timer::from_seconds(1.0, TimerMode::Repeating)),\n        TextToPrint(\"I will always print\".to_string()),\n        LevelUnload,\n    ));\n}\n\nfn print_text_system(time: Res<Time>, mut query: Query<(&mut PrinterTick, &TextToPrint)>) {\n    for (mut timer, text) in &mut query {\n        if timer.tick(time.delta()).just_finished() {\n            info!(\"{}\", text.0);\n        }\n    }\n}\n\nfn transition_to_in_game_system(\n    mut next_state: ResMut<NextState<AppState>>,\n    keyboard_input: Res<ButtonInput<KeyCode>>,\n) {\n    if keyboard_input.pressed(KeyCode::Space) {\n        next_state.set(AppState::InGame);\n    }\n}\n\n// Type arguments on functions come after the function name, but before ordinary arguments.\n// Here, the `Component` trait is a trait bound on T, our generic type\nfn cleanup_system<T: Component>(mut commands: Commands, query: Query<Entity, With<T>>) {\n    for e in &query {\n        commands.entity(e).despawn_recursive();\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "0e2fc0ac1eb3d549be05887e95905eaf844956f1",
    "func": "//! Launch helper macros for fullstack apps\n#![allow(clippy::new_without_default)]\n#![allow(unused)]\nuse dioxus_config_macro::*;\nuse dioxus_core::LaunchConfig;\nuse std::any::Any;\n\nuse crate::prelude::*;\n\n/// A builder for a fullstack app.\n#[must_use]\npub struct LaunchBuilder {\n    launch_fn: LaunchFn,\n    contexts: Vec<ContextFn>,\n    configs: Vec<Box<dyn Any>>,\n}\n\npub type LaunchFn = fn(fn() -> Element, Vec<ContextFn>, Vec<Box<dyn Any>>);\n/// A context function is a Send and Sync closure that returns a boxed trait object\npub type ContextFn = Box<dyn Fn() -> Box<dyn Any> + Send + Sync + 'static>;\n\n#[cfg(any(\n    feature = \"fullstack\",\n    feature = \"static-generation\",\n    feature = \"liveview\"\n))]\ntype ValidContext = SendContext;\n\n#[cfg(not(any(\n    feature = \"fullstack\",\n    feature = \"static-generation\",\n    feature = \"liveview\"\n)))]\ntype ValidContext = UnsendContext;\n\ntype SendContext = dyn Fn() -> Box<dyn Any + Send + Sync> + Send + Sync + 'static;\n\ntype UnsendContext = dyn Fn() -> Box<dyn Any> + 'static;\n\n#[allow(clippy::redundant_closure)] // clippy doesnt doesn't understand our coercion to fn\nimpl LaunchBuilder {\n    /// Create a new builder for your application. This will create a launch configuration for the current platform based on the features enabled on the `dioxus` crate.\n    // If you aren't using a third party renderer and this is not a docs.rs build, generate a warning about no renderer being enabled\n    #[cfg_attr(\n        all(not(any(\n            docsrs,\n            feature = \"third-party-renderer\",\n            feature = \"liveview\",\n            feature = \"desktop\",\n            feature = \"mobile\",\n            feature = \"web\",\n            feature = \"fullstack\",\n            feature = \"static-generation\"\n        ))),\n        deprecated(\n            note = \"No renderer is enabled. You must enable a renderer feature on the dioxus crate before calling the launch function.\\nAdd `web`, `desktop`, `mobile`, `fullstack`, or `static-generation` to the `features` of dioxus field in your Cargo.toml.\\n# Example\\n```toml\\n# ...\\n[dependencies]\\ndioxus = { version = \\\"0.5.0\\\", features = [\\\"web\\\"] }\\n# ...\\n```\"\n        )\n    )]\n    pub fn new() -> LaunchBuilder {\n        LaunchBuilder {\n            // We can't use the `current_platform::launch` function directly because it may return ! or ()\n            launch_fn: |root, contexts, cfg| current_platform::launch(root, contexts, cfg),\n            contexts: Vec::new(),\n            configs: Vec::new(),\n        }\n    }\n\n    /// Launch your web application.\n    #[cfg(feature = \"web\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"web\")))]\n    pub fn web() -> LaunchBuilder {\n        LaunchBuilder {\n            launch_fn: web_launch,\n            contexts: Vec::new(),\n            configs: Vec::new(),\n        }\n    }\n\n    /// Launch your desktop application.\n    #[cfg(feature = \"desktop\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"desktop\")))]\n    pub fn desktop() -> LaunchBuilder {\n        LaunchBuilder {\n            launch_fn: |root, contexts, cfg| dioxus_desktop::launch::launch(root, contexts, cfg),\n            contexts: Vec::new(),\n            configs: Vec::new(),\n        }\n    }\n\n    /// Launch your fullstack axum server.\n    #[cfg(all(feature = \"fullstack\", feature = \"server\"))]\n    #[cfg_attr(docsrs, doc(cfg(all(feature = \"fullstack\", feature = \"server\"))))]\n    pub fn server() -> LaunchBuilder {\n        LaunchBuilder {\n            launch_fn: |root, contexts, cfg| {\n                dioxus_fullstack::server::launch::launch(root, contexts, cfg)\n            },\n            contexts: Vec::new(),\n            configs: Vec::new(),\n        }\n    }\n\n    /// Launch your static site generation application.\n    #[cfg(all(feature = \"static-generation\", feature = \"server\"))]\n    #[cfg_attr(\n        docsrs,\n        doc(cfg(all(feature = \"static-generation\", feature = \"server\")))\n    )]\n    pub fn static_generation() -> LaunchBuilder {\n        LaunchBuilder {\n            launch_fn: |root, contexts, cfg| {\n                dioxus_static_site_generation::launch::launch(root, contexts, cfg)\n            },\n            contexts: Vec::new(),\n            configs: Vec::new(),\n        }\n    }\n\n    /// Launch your fullstack application.\n    #[cfg(feature = \"mobile\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"mobile\")))]\n    pub fn mobile() -> LaunchBuilder {\n        LaunchBuilder {\n            launch_fn: |root, contexts, cfg| dioxus_mobile::launch::launch(root, contexts, cfg),\n            contexts: Vec::new(),\n            configs: Vec::new(),\n        }\n    }\n\n    /// Provide a custom launch function for your application.\n    ///\n    /// Useful for third party renderers to tap into the launch builder API without having to reimplement it.\n    ///\n    /// # Example\n    /// ```rust, no_run\n    /// use dioxus::prelude::*;\n    /// use std::any::Any;\n    ///\n    /// #[derive(Default)]\n    /// struct Config;\n    ///\n    /// fn my_custom_launcher(root: fn() -> Element, contexts: Vec<Box<dyn Fn() -> Box<dyn Any> + Send + Sync>>, cfg: Vec<Box<dyn Any>>) {\n    ///     println!(\"launching with root: {:?}\", root());\n    ///     loop {\n    ///         println!(\"running...\");\n    ///     }\n    /// }\n    ///\n    /// fn app() -> Element {\n    ///     rsx! {\n    ///         div { \"Hello, world!\" }\n    ///     }\n    /// }\n    ///\n    /// dioxus::LaunchBuilder::custom(my_custom_launcher).launch(app);\n    /// ```\n    pub fn custom(launch_fn: LaunchFn) -> LaunchBuilder {\n        LaunchBuilder {\n            launch_fn,\n            contexts: vec![],\n            configs: Vec::new(),\n        }\n    }\n}\n\nimpl LaunchBuilder {\n    /// Inject state into the root component's context that is created on the thread that the app is launched on.\n    pub fn with_context_provider(\n        mut self,\n        state: impl Fn() -> Box<dyn Any> + Send + Sync + 'static,\n    ) -> Self {\n        self.contexts.push(Box::new(state));\n        self\n    }\n\n    /// Inject state into the root component's context.\n    pub fn with_context(mut self, state: impl Any + Clone + Send + Sync + 'static) -> Self {\n        self.contexts\n            .push(Box::new(move || Box::new(state.clone())));\n        self\n    }\n}\n\nimpl LaunchBuilder {\n    /// Provide a platform-specific config to the builder.\n    pub fn with_cfg(mut self, config: impl LaunchConfig) -> Self {\n        self.configs.push(Box::new(config));\n        self\n    }\n\n    // Static generation is the only platform that may exit. We can't use the `!` type here\n    #[cfg(any(feature = \"static-generation\", feature = \"web\"))]\n    /// Launch your application.\n    pub fn launch(self, app: fn() -> Element) {\n        let cfg = self.configs;\n\n        (self.launch_fn)(app, self.contexts, cfg)\n    }\n\n    #[cfg(not(any(feature = \"static-generation\", feature = \"web\")))]\n    /// Launch your application.\n    pub fn launch(self, app: fn() -> Element) -> ! {\n        let cfg = self.configs;\n\n        (self.launch_fn)(app, self.contexts, cfg);\n        unreachable!(\"Launching an application will never exit\")\n    }\n}\n\n/// Re-export the platform we expect the user wants\n///\n/// If multiple platforms are enabled, we use this priority (from highest to lowest):\n/// - `fullstack`\n/// - `desktop`\n/// - `mobile`\n/// - `static-generation`\n/// - `web`\n/// - `liveview`\nmod current_platform {\n    #[cfg(all(feature = \"fullstack\", feature = \"server\"))]\n    pub use dioxus_fullstack::server::launch::*;\n\n    #[cfg(all(\n        feature = \"desktop\",\n        not(all(feature = \"fullstack\", feature = \"server\"))\n    ))]\n    pub use dioxus_desktop::launch::*;\n\n    #[cfg(all(\n        feature = \"mobile\",\n        not(feature = \"desktop\"),\n        not(all(feature = \"fullstack\", feature = \"server\"))\n    ))]\n    pub use dioxus_mobile::launch::*;\n\n    #[cfg(all(\n        all(feature = \"static-generation\", feature = \"server\"),\n        not(all(feature = \"fullstack\", feature = \"server\")),\n        not(feature = \"desktop\"),\n        not(feature = \"mobile\")\n    ))]\n    pub use dioxus_static_site_generation::launch::*;\n\n    #[cfg(all(\n        feature = \"web\",\n        not(all(feature = \"fullstack\", feature = \"server\")),\n        not(all(feature = \"static-generation\", feature = \"server\")),\n        not(feature = \"desktop\"),\n        not(feature = \"mobile\"),\n    ))]\n    pub fn launch(\n        root: fn() -> dioxus_core::Element,\n        contexts: Vec<super::ContextFn>,\n        platform_config: Vec<Box<dyn std::any::Any>>,\n    ) {\n        super::web_launch(root, contexts, platform_config);\n    }\n\n    #[cfg(all(\n        feature = \"liveview\",\n        not(all(feature = \"fullstack\", feature = \"server\")),\n        not(all(feature = \"static-generation\", feature = \"server\")),\n        not(feature = \"desktop\"),\n        not(feature = \"mobile\"),\n        not(feature = \"web\"),\n    ))]\n    pub use dioxus_liveview::launch::*;\n\n    #[cfg(not(any(\n        feature = \"liveview\",\n        all(feature = \"fullstack\", feature = \"server\"),\n        all(feature = \"static-generation\", feature = \"server\"),\n        feature = \"desktop\",\n        feature = \"mobile\",\n        feature = \"web\",\n    )))]\n    pub fn launch(\n        root: fn() -> dioxus_core::Element,\n        contexts: Vec<super::ContextFn>,\n        platform_config: Vec<Box<dyn std::any::Any>>,\n    ) -> ! {\n        #[cfg(feature = \"third-party-renderer\")]\n        panic!(\"No first party renderer feature enabled. It looks like you are trying to use a third party renderer. You will need to use the launch function from the third party renderer crate.\");\n\n        panic!(\"No platform feature enabled. Please enable one of the following features: liveview, desktop, mobile, web, tui, fullstack to use the launch API.\")\n    }\n}\n\n// ! is unstable, so we can't name the type with an alias. Instead we need to generate different variants of items with macros\nmacro_rules! impl_launch {\n    ($($return_type:tt),*) => {\n        /// Launch your application without any additional configuration. See [`LaunchBuilder`] for more options.\n        pub fn launch(app: fn() -> Element) -> $($return_type)* {\n            #[allow(deprecated)]\n            LaunchBuilder::new().launch(app)\n        }\n    };\n}\n\n// Static generation is the only platform that may exit. We can't use the `!` type here\n#[cfg(any(feature = \"static-generation\", feature = \"web\"))]\nimpl_launch!(());\n#[cfg(not(any(feature = \"static-generation\", feature = \"web\")))]\nimpl_launch!(!);\n\n#[cfg(feature = \"web\")]\nfn web_launch(\n    root: fn() -> dioxus_core::Element,\n    contexts: Vec<super::ContextFn>,\n    platform_config: Vec<Box<dyn std::any::Any>>,\n) {\n    // If the server feature is enabled, launch the client with hydration enabled\n    #[cfg(any(feature = \"static-generation\", feature = \"fullstack\"))]\n    {\n        let platform_config = platform_config\n            .into_iter()\n            .find_map(|cfg| cfg.downcast::<dioxus_web::Config>().ok())\n            .unwrap_or_default()\n            .hydrate(true);\n\n        let factory = move || {\n            let mut vdom = dioxus_core::VirtualDom::new(root);\n            for context in contexts {\n                vdom.insert_any_root_context(context());\n            }\n            #[cfg(feature = \"document\")]\n            {\n                #[cfg(feature = \"fullstack\")]\n                use dioxus_fullstack::document;\n                #[cfg(all(feature = \"static-generation\", not(feature = \"fullstack\")))]\n                use dioxus_static_site_generation::document;\n                let document = std::rc::Rc::new(document::web::FullstackWebDocument)\n                    as std::rc::Rc<dyn crate::prelude::document::Document>;\n                vdom.provide_root_context(document);\n            }\n            vdom\n        };\n\n        dioxus_web::launch::launch_virtual_dom(factory(), platform_config)\n    }\n    #[cfg(not(any(feature = \"static-generation\", feature = \"fullstack\")))]\n    dioxus_web::launch::launch(root, contexts, platform_config);\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "8bd4a1013a1a0f5b3001f621e827536c20a783b9",
    "func": "use sea_query::Iden;\n\n#[derive(Iden)]\nenum Asset {\n    Table,\n    Id,\n    AssetName,\n    #[iden]\n    Creation,\n}\n\nfn main() {}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "6cd49b17de3e8efb76e28e263253637d814f9dc4",
    "func": "//! A simple example on how to use assets loading from the filesystem.\n//!\n//! If the feature \"collect-assets\" is enabled, the assets will be collected via the dioxus CLI and embedded into the\n//! final bundle. This lets you do various useful things like minify, compress, and optimize your assets.\n//!\n//! We can still use assets without the CLI middleware, but generally larger apps will benefit from it.\n\nuse dioxus::prelude::*;\n\n#[cfg(not(feature = \"collect-assets\"))]\nstatic ASSET_PATH: &str = \"examples/assets/logo.png\";\n\n#[cfg(feature = \"collect-assets\")]\nstatic ASSET_PATH: &str = asset!(\"examples/assets/logo.png\".format(ImageType::Avif));\n\nfn main() {\n    dioxus::launch(app);\n}\n\nfn app() -> Element {\n    rsx! {\n        div {\n            h1 { \"This should show an image:\" }\n            img { src: ASSET_PATH.to_string() }\n        }\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "cf9daeadceab5328167616fdf85694095fa0be30",
    "func": "use bytes::BytesMut;\nuse std::io;\n\n/// Trait of helper objects to write out messages as bytes, for use with\n/// [`FramedWrite`].\n///\n/// [`FramedWrite`]: crate::codec::FramedWrite\npub trait Encoder<Item> {\n    /// The type of encoding errors.\n    ///\n    /// [`FramedWrite`] requires `Encoder`s errors to implement `From<io::Error>`\n    /// in the interest of letting it return `Error`s directly.\n    ///\n    /// [`FramedWrite`]: crate::codec::FramedWrite\n    type Error: From<io::Error>;\n\n    /// Encodes a frame into the buffer provided.\n    ///\n    /// This method will encode `item` into the byte buffer provided by `dst`.\n    /// The `dst` provided is an internal buffer of the [`FramedWrite`] instance and\n    /// will be written out when possible.\n    ///\n    /// [`FramedWrite`]: crate::codec::FramedWrite\n    fn encode(&mut self, item: Item, dst: &mut BytesMut) -> Result<(), Self::Error>;\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "1b5b7a4699e727a8fdb35d9a0c252a90eba81806",
    "func": "#[macro_use]\nextern crate diesel;\n\ntable! {\n    users {\n        id -> Integer,\n        name -> Text,\n    }\n}\n\n#[derive(AsChangeset)]\n#[diesel(table_name = users)]\n#[diesel(treat_none_as_null(\"true\"))]\nstruct UserForm1 {\n    id: i32,\n    name: String,\n}\n\n#[derive(AsChangeset)]\n#[diesel(table_name = users)]\n#[diesel(treat_none_as_null)]\nstruct UserForm2 {\n    id: i32,\n    name: String,\n}\n\n#[derive(AsChangeset)]\n#[diesel(table_name = users)]\n#[diesel(treat_none_as_null = \"foo\")]\nstruct UserForm3 {\n    id: i32,\n    name: String,\n}\n\n#[derive(AsChangeset)]\n#[diesel(table_name = users)]\nstruct UserForm4 {\n    id: i32,\n    #[diesel(treat_none_as_null = true)]\n    name: String,\n}\n\nfn main() {}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "3a75c76e3f7c1b3184276848e37b431a2e4059b8",
    "func": "// Copyright 2024 Cloudflare, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse rand::distributions::WeightedIndex;\nuse rand::prelude::*;\nuse std::sync::Arc;\nuse std::thread;\nuse std::time::Instant;\n\n// Non-uniform distributions, 100 items, 10 of them are 100x more likely to appear\nconst WEIGHTS: &[usize] = &[\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 100, 100, 100,\n    100, 100, 100, 100, 100, 100, 100,\n];\n\nconst ITERATIONS: usize = 5_000_000;\nconst THREADS: usize = 8;\n\nfn main() {\n    let lru = parking_lot::Mutex::new(lru::LruCache::<u64, ()>::unbounded());\n\n    let plru = pingora_lru::Lru::<(), 10>::with_capacity(1000, 100);\n    // populate first, then we bench access/promotion\n    for i in 0..WEIGHTS.len() {\n        lru.lock().put(i as u64, ());\n    }\n    for i in 0..WEIGHTS.len() {\n        plru.admit(i as u64, (), 1);\n    }\n\n    // single thread\n    let mut rng = thread_rng();\n    let dist = WeightedIndex::new(WEIGHTS).unwrap();\n\n    let before = Instant::now();\n    for _ in 0..ITERATIONS {\n        lru.lock().get(&(dist.sample(&mut rng) as u64));\n    }\n    let elapsed = before.elapsed();\n    println!(\n        \"lru promote total {elapsed:?}, {:?} avg per operation\",\n        elapsed / ITERATIONS as u32\n    );\n\n    let before = Instant::now();\n    for _ in 0..ITERATIONS {\n        plru.promote(dist.sample(&mut rng) as u64);\n    }\n    let elapsed = before.elapsed();\n    println!(\n        \"pingora lru promote total {elapsed:?}, {:?} avg per operation\",\n        elapsed / ITERATIONS as u32\n    );\n\n    let before = Instant::now();\n    for _ in 0..ITERATIONS {\n        plru.promote_top_n(dist.sample(&mut rng) as u64, 10);\n    }\n    let elapsed = before.elapsed();\n    println!(\n        \"pingora lru promote_top_10 total {elapsed:?}, {:?} avg per operation\",\n        elapsed / ITERATIONS as u32\n    );\n\n    // concurrent\n\n    let lru = Arc::new(lru);\n    let mut handlers = vec![];\n    for i in 0..THREADS {\n        let lru = lru.clone();\n        let handler = thread::spawn(move || {\n            let mut rng = thread_rng();\n            let dist = WeightedIndex::new(WEIGHTS).unwrap();\n            let before = Instant::now();\n            for _ in 0..ITERATIONS {\n                lru.lock().get(&(dist.sample(&mut rng) as u64));\n            }\n            let elapsed = before.elapsed();\n            println!(\n                \"lru promote total {elapsed:?}, {:?} avg per operation thread {i}\",\n                elapsed / ITERATIONS as u32\n            );\n        });\n        handlers.push(handler);\n    }\n    for thread in handlers {\n        thread.join().unwrap();\n    }\n\n    let plru = Arc::new(plru);\n\n    let mut handlers = vec![];\n    for i in 0..THREADS {\n        let plru = plru.clone();\n        let handler = thread::spawn(move || {\n            let mut rng = thread_rng();\n            let dist = WeightedIndex::new(WEIGHTS).unwrap();\n            let before = Instant::now();\n            for _ in 0..ITERATIONS {\n                plru.promote(dist.sample(&mut rng) as u64);\n            }\n            let elapsed = before.elapsed();\n            println!(\n                \"pingora lru promote total {elapsed:?}, {:?} avg per operation thread {i}\",\n                elapsed / ITERATIONS as u32\n            );\n        });\n        handlers.push(handler);\n    }\n    for thread in handlers {\n        thread.join().unwrap();\n    }\n\n    let mut handlers = vec![];\n    for i in 0..THREADS {\n        let plru = plru.clone();\n        let handler = thread::spawn(move || {\n            let mut rng = thread_rng();\n            let dist = WeightedIndex::new(WEIGHTS).unwrap();\n            let before = Instant::now();\n            for _ in 0..ITERATIONS {\n                plru.promote_top_n(dist.sample(&mut rng) as u64, 10);\n            }\n            let elapsed = before.elapsed();\n            println!(\n                \"pingora lru promote_top_10 total {elapsed:?}, {:?} avg per operation thread {i}\",\n                elapsed / ITERATIONS as u32\n            );\n        });\n        handlers.push(handler);\n    }\n    for thread in handlers {\n        thread.join().unwrap();\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "777e92ca19415c6803964a78f2e7e1a4b75d63db",
    "func": "use unicode_width::UnicodeWidthStr;\n\nuse crate::{\n    buffer::Buffer,\n    layout::Rect,\n    widgets::{\n        block::BlockExt, List, ListDirection, ListState, StatefulWidget, StatefulWidgetRef, Widget,\n        WidgetRef,\n    },\n};\n\nimpl Widget for List<'_> {\n    fn render(self, area: Rect, buf: &mut Buffer) {\n        WidgetRef::render_ref(&self, area, buf);\n    }\n}\n\nimpl WidgetRef for List<'_> {\n    fn render_ref(&self, area: Rect, buf: &mut Buffer) {\n        let mut state = ListState::default();\n        StatefulWidgetRef::render_ref(self, area, buf, &mut state);\n    }\n}\n\nimpl StatefulWidget for List<'_> {\n    type State = ListState;\n\n    fn render(self, area: Rect, buf: &mut Buffer, state: &mut Self::State) {\n        StatefulWidgetRef::render_ref(&self, area, buf, state);\n    }\n}\n\n// Note: remove this when StatefulWidgetRef is stabilized and replace with the blanket impl\nimpl StatefulWidget for &List<'_> {\n    type State = ListState;\n    fn render(self, area: Rect, buf: &mut Buffer, state: &mut Self::State) {\n        StatefulWidgetRef::render_ref(self, area, buf, state);\n    }\n}\n\nimpl StatefulWidgetRef for List<'_> {\n    type State = ListState;\n\n    fn render_ref(&self, area: Rect, buf: &mut Buffer, state: &mut Self::State) {\n        buf.set_style(area, self.style);\n        self.block.render_ref(area, buf);\n        let list_area = self.block.inner_if_some(area);\n\n        if list_area.is_empty() {\n            return;\n        }\n\n        if self.items.is_empty() {\n            state.select(None);\n            return;\n        }\n\n        // If the selected index is out of bounds, set it to the last item\n        if state.selected.is_some_and(|s| s >= self.items.len()) {\n            state.select(Some(self.items.len().saturating_sub(1)));\n        }\n\n        let list_height = list_area.height as usize;\n\n        let (first_visible_index, last_visible_index) =\n            self.get_items_bounds(state.selected, state.offset, list_height);\n\n        // Important: this changes the state's offset to be the beginning of the now viewable items\n        state.offset = first_visible_index;\n\n        // Get our set highlighted symbol (if one was set)\n        let highlight_symbol = self.highlight_symbol.unwrap_or(\"\");\n        let blank_symbol = \" \".repeat(highlight_symbol.width());\n\n        let mut current_height = 0;\n        let selection_spacing = self.highlight_spacing.should_add(state.selected.is_some());\n        for (i, item) in self\n            .items\n            .iter()\n            .enumerate()\n            .skip(state.offset)\n            .take(last_visible_index - first_visible_index)\n        {\n            let (x, y) = if self.direction == ListDirection::BottomToTop {\n                current_height += item.height() as u16;\n                (list_area.left(), list_area.bottom() - current_height)\n            } else {\n                let pos = (list_area.left(), list_area.top() + current_height);\n                current_height += item.height() as u16;\n                pos\n            };\n\n            let row_area = Rect {\n                x,\n                y,\n                width: list_area.width,\n                height: item.height() as u16,\n            };\n\n            let item_style = self.style.patch(item.style);\n            buf.set_style(row_area, item_style);\n\n            let is_selected = state.selected.map_or(false, |s| s == i);\n\n            let item_area = if selection_spacing {\n                let highlight_symbol_width = self.highlight_symbol.unwrap_or(\"\").width() as u16;\n                Rect {\n                    x: row_area.x + highlight_symbol_width,\n                    width: row_area.width.saturating_sub(highlight_symbol_width),\n                    ..row_area\n                }\n            } else {\n                row_area\n            };\n            item.content.render_ref(item_area, buf);\n\n            for j in 0..item.content.height() {\n                // if the item is selected, we need to display the highlight symbol:\n                // - either for the first line of the item only,\n                // - or for each line of the item if the appropriate option is set\n                let symbol = if is_selected && (j == 0 || self.repeat_highlight_symbol) {\n                    highlight_symbol\n                } else {\n                    &blank_symbol\n                };\n                if selection_spacing {\n                    buf.set_stringn(\n                        x,\n                        y + j as u16,\n                        symbol,\n                        list_area.width as usize,\n                        item_style,\n                    );\n                }\n            }\n\n            if is_selected {\n                buf.set_style(row_area, self.highlight_style);\n            }\n        }\n    }\n}\n\nimpl List<'_> {\n    /// Given an offset, calculate which items can fit in a given area\n    fn get_items_bounds(\n        &self,\n        selected: Option<usize>,\n        offset: usize,\n        max_height: usize,\n    ) -> (usize, usize) {\n        let offset = offset.min(self.items.len().saturating_sub(1));\n\n        // Note: visible here implies visible in the given area\n        let mut first_visible_index = offset;\n        let mut last_visible_index = offset;\n\n        // Current height of all items in the list to render, beginning at the offset\n        let mut height_from_offset = 0;\n\n        // Calculate the last visible index and total height of the items\n        // that will fit in the available space\n        for item in self.items.iter().skip(offset) {\n            if height_from_offset + item.height() > max_height {\n                break;\n            }\n\n            height_from_offset += item.height();\n\n            last_visible_index += 1;\n        }\n\n        // Get the selected index and apply scroll_padding to it, but still honor the offset if\n        // nothing is selected. This allows for the list to stay at a position after select()ing\n        // None.\n        let index_to_display = self\n            .apply_scroll_padding_to_selected_index(\n                selected,\n                max_height,\n                first_visible_index,\n                last_visible_index,\n            )\n            .unwrap_or(offset);\n\n        // Recall that last_visible_index is the index of what we\n        // can render up to in the given space after the offset\n        // If we have an item selected that is out of the viewable area (or\n        // the offset is still set), we still need to show this item\n        while index_to_display >= last_visible_index {\n            height_from_offset =\n                height_from_offset.saturating_add(self.items[last_visible_index].height());\n\n            last_visible_index += 1;\n\n            // Now we need to hide previous items since we didn't have space\n            // for the selected/offset item\n            while height_from_offset > max_height {\n                height_from_offset =\n                    height_from_offset.saturating_sub(self.items[first_visible_index].height());\n\n                // Remove this item to view by starting at the next item index\n                first_visible_index += 1;\n            }\n        }\n\n        // Here we're doing something similar to what we just did above\n        // If the selected item index is not in the viewable area, let's try to show the item\n        while index_to_display < first_visible_index {\n            first_visible_index -= 1;\n\n            height_from_offset =\n                height_from_offset.saturating_add(self.items[first_visible_index].height());\n\n            // Don't show an item if it is beyond our viewable height\n            while height_from_offset > max_height {\n                last_visible_index -= 1;\n\n                height_from_offset =\n                    height_from_offset.saturating_sub(self.items[last_visible_index].height());\n            }\n        }\n\n        (first_visible_index, last_visible_index)\n    }\n\n    /// Applies scroll padding to the selected index, reducing the padding value to keep the\n    /// selected item on screen even with items of inconsistent sizes\n    ///\n    /// This function is sensitive to how the bounds checking function handles item height\n    fn apply_scroll_padding_to_selected_index(\n        &self,\n        selected: Option<usize>,\n        max_height: usize,\n        first_visible_index: usize,\n        last_visible_index: usize,\n    ) -> Option<usize> {\n        let last_valid_index = self.items.len().saturating_sub(1);\n        let selected = selected?.min(last_valid_index);\n\n        // The bellow loop handles situations where the list item sizes may not be consistent,\n        // where the offset would have excluded some items that we want to include, or could\n        // cause the offset value to be set to an inconsistent value each time we render.\n        // The padding value will be reduced in case any of these issues would occur\n        let mut scroll_padding = self.scroll_padding;\n        while scroll_padding > 0 {\n            let mut height_around_selected = 0;\n            for index in selected.saturating_sub(scroll_padding)\n                ..=selected\n                    .saturating_add(scroll_padding)\n                    .min(last_valid_index)\n            {\n                height_around_selected += self.items[index].height();\n            }\n            if height_around_selected <= max_height {\n                break;\n            }\n            scroll_padding -= 1;\n        }\n\n        Some(\n            if (selected + scroll_padding).min(last_valid_index) >= last_visible_index {\n                selected + scroll_padding\n            } else if selected.saturating_sub(scroll_padding) < first_visible_index {\n                selected.saturating_sub(scroll_padding)\n            } else {\n                selected\n            }\n            .min(last_valid_index),\n        )\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use pretty_assertions::assert_eq;\n    use rstest::{fixture, rstest};\n\n    use super::*;\n    use crate::{\n        backend,\n        layout::{Alignment, Rect},\n        style::{Color, Modifier, Style, Stylize},\n        text::Line,\n        widgets::{Block, HighlightSpacing, ListItem, StatefulWidget, Widget},\n        Terminal,\n    };\n\n    #[fixture]\n    fn single_line_buf() -> Buffer {\n        Buffer::empty(Rect::new(0, 0, 10, 1))\n    }\n\n    #[rstest]\n    fn empty_list(mut single_line_buf: Buffer) {\n        let mut state = ListState::default();\n\n        let items: Vec<ListItem> = Vec::new();\n        let list = List::new(items);\n        state.select_first();\n        StatefulWidget::render(list, single_line_buf.area, &mut single_line_buf, &mut state);\n        assert_eq!(state.selected, None);\n    }\n\n    #[rstest]\n    fn single_item(mut single_line_buf: Buffer) {\n        let mut state = ListState::default();\n\n        let items = vec![ListItem::new(\"Item 1\")];\n        let list = List::new(items);\n        state.select_first();\n        StatefulWidget::render(\n            &list,\n            single_line_buf.area,\n            &mut single_line_buf,\n            &mut state,\n        );\n        assert_eq!(state.selected, Some(0));\n\n        state.select_last();\n        StatefulWidget::render(\n            &list,\n            single_line_buf.area,\n            &mut single_line_buf,\n            &mut state,\n        );\n        assert_eq!(state.selected, Some(0));\n\n        state.select_previous();\n        StatefulWidget::render(\n            &list,\n            single_line_buf.area,\n            &mut single_line_buf,\n            &mut state,\n        );\n        assert_eq!(state.selected, Some(0));\n\n        state.select_next();\n        StatefulWidget::render(\n            &list,\n            single_line_buf.area,\n            &mut single_line_buf,\n            &mut state,\n        );\n        assert_eq!(state.selected, Some(0));\n    }\n\n    /// helper method to render a widget to an empty buffer with the default state\n    fn widget(widget: List<'_>, width: u16, height: u16) -> Buffer {\n        let mut buffer = Buffer::empty(Rect::new(0, 0, width, height));\n        Widget::render(widget, buffer.area, &mut buffer);\n        buffer\n    }\n\n    /// helper method to render a widget to an empty buffer with a given state\n    fn stateful_widget(widget: List<'_>, state: &mut ListState, width: u16, height: u16) -> Buffer {\n        let mut buffer = Buffer::empty(Rect::new(0, 0, width, height));\n        StatefulWidget::render(widget, buffer.area, &mut buffer, state);\n        buffer\n    }\n\n    #[test]\n    fn does_not_render_in_small_space() {\n        let items = vec![\"Item 0\", \"Item 1\", \"Item 2\"];\n        let list = List::new(items.clone()).highlight_symbol(\">>\");\n        let mut buffer = Buffer::empty(Rect::new(0, 0, 15, 3));\n\n        // attempt to render into an area of the buffer with 0 width\n        Widget::render(list.clone(), Rect::new(0, 0, 0, 3), &mut buffer);\n        assert_eq!(&buffer, &Buffer::empty(buffer.area));\n\n        // attempt to render into an area of the buffer with 0 height\n        Widget::render(list.clone(), Rect::new(0, 0, 15, 0), &mut buffer);\n        assert_eq!(&buffer, &Buffer::empty(buffer.area));\n\n        let list = List::new(items)\n            .highlight_symbol(\">>\")\n            .block(Block::bordered());\n        // attempt to render into an area of the buffer with zero height after\n        // setting the block borders\n        Widget::render(list, Rect::new(0, 0, 15, 2), &mut buffer);\n        #[rustfmt::skip]\n        let expected = Buffer::with_lines([\n            \"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\",\n            \"\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\",\n            \"               \",\n        ]);\n        assert_eq!(buffer, expected,);\n    }\n\n    #[allow(clippy::too_many_lines)]\n    #[test]\n    fn combinations() {\n        #[track_caller]\n        fn test_case_render<'line, Lines>(items: &[ListItem], expected: Lines)\n        where\n            Lines: IntoIterator,\n            Lines::Item: Into<Line<'line>>,\n        {\n            let list = List::new(items.to_owned()).highlight_symbol(\">>\");\n            let mut buffer = Buffer::empty(Rect::new(0, 0, 10, 5));\n            Widget::render(list, buffer.area, &mut buffer);\n            assert_eq!(buffer, Buffer::with_lines(expected));\n        }\n\n        #[track_caller]\n        fn test_case_render_stateful<'line, Lines>(\n            items: &[ListItem],\n            selected: Option<usize>,\n            expected: Lines,\n        ) where\n            Lines: IntoIterator,\n            Lines::Item: Into<Line<'line>>,\n        {\n            let list = List::new(items.to_owned()).highlight_symbol(\">>\");\n            let mut state = ListState::default().with_selected(selected);\n            let mut buffer = Buffer::empty(Rect::new(0, 0, 10, 5));\n            StatefulWidget::render(list, buffer.area, &mut buffer, &mut state);\n            assert_eq!(buffer, Buffer::with_lines(expected));\n        }\n\n        let empty_items = Vec::new();\n        let single_item = vec![\"Item 0\".into()];\n        let multiple_items = vec![\"Item 0\".into(), \"Item 1\".into(), \"Item 2\".into()];\n        let multi_line_items = vec![\"Item 0\\nLine 2\".into(), \"Item 1\".into(), \"Item 2\".into()];\n\n        // empty list\n        test_case_render(\n            &empty_items,\n            [\n                \"          \",\n                \"          \",\n                \"          \",\n                \"          \",\n                \"          \",\n            ],\n        );\n        test_case_render_stateful(\n            &empty_items,\n            None,\n            [\n                \"          \",\n                \"          \",\n                \"          \",\n                \"          \",\n                \"          \",\n            ],\n        );\n        test_case_render_stateful(\n            &empty_items,\n            Some(0),\n            [\n                \"          \",\n                \"          \",\n                \"          \",\n                \"          \",\n                \"          \",\n            ],\n        );\n\n        // single item\n        test_case_render(\n            &single_item,\n            [\n                \"Item 0    \",\n                \"          \",\n                \"          \",\n                \"          \",\n                \"          \",\n            ],\n        );\n        test_case_render_stateful(\n            &single_item,\n            None,\n            [\n                \"Item 0    \",\n                \"          \",\n                \"          \",\n                \"          \",\n                \"          \",\n            ],\n        );\n        test_case_render_stateful(\n            &single_item,\n            Some(0),\n            [\n                \">>Item 0  \",\n                \"          \",\n                \"          \",\n                \"          \",\n                \"          \",\n            ],\n        );\n        test_case_render_stateful(\n            &single_item,\n            Some(1),\n            [\n                \">>Item 0  \",\n                \"          \",\n                \"          \",\n                \"          \",\n                \"          \",\n            ],\n        );\n\n        // multiple items\n        test_case_render(\n            &multiple_items,\n            [\n                \"Item 0    \",\n                \"Item 1    \",\n                \"Item 2    \",\n                \"          \",\n                \"          \",\n            ],\n        );\n        test_case_render_stateful(\n            &multiple_items,\n            None,\n            [\n                \"Item 0    \",\n                \"Item 1    \",\n                \"Item 2    \",\n                \"          \",\n                \"          \",\n            ],\n        );\n        test_case_render_stateful(\n            &multiple_items,\n            Some(0),\n            [\n                \">>Item 0  \",\n                \"  Item 1  \",\n                \"  Item 2  \",\n                \"          \",\n                \"          \",\n            ],\n        );\n        test_case_render_stateful(\n            &multiple_items,\n            Some(1),\n            [\n                \"  Item 0  \",\n                \">>Item 1  \",\n                \"  Item 2  \",\n                \"          \",\n                \"          \",\n            ],\n        );\n        test_case_render_stateful(\n            &multiple_items,\n            Some(3),\n            [\n                \"  Item 0  \",\n                \"  Item 1  \",\n                \">>Item 2  \",\n                \"          \",\n                \"          \",\n            ],\n        );\n\n        // multi line items\n        test_case_render(\n            &multi_line_items,\n            [\n                \"Item 0    \",\n                \"Line 2    \",\n                \"Item 1    \",\n                \"Item 2    \",\n                \"          \",\n            ],\n        );\n        test_case_render_stateful(\n            &multi_line_items,\n            None,\n            [\n                \"Item 0    \",\n                \"Line 2    \",\n                \"Item 1    \",\n                \"Item 2    \",\n                \"          \",\n            ],\n        );\n        test_case_render_stateful(\n            &multi_line_items,\n            Some(0),\n            [\n                \">>Item 0  \",\n                \"  Line 2  \",\n                \"  Item 1  \",\n                \"  Item 2  \",\n                \"          \",\n            ],\n        );\n        test_case_render_stateful(\n            &multi_line_items,\n            Some(1),\n            [\n                \"  Item 0  \",\n                \"  Line 2  \",\n                \">>Item 1  \",\n                \"  Item 2  \",\n                \"          \",\n            ],\n        );\n    }\n\n    #[test]\n    fn items() {\n        let list = List::default().items([\"Item 0\", \"Item 1\", \"Item 2\"]);\n        let buffer = widget(list, 10, 5);\n        let expected = Buffer::with_lines([\n            \"Item 0    \",\n            \"Item 1    \",\n            \"Item 2    \",\n            \"          \",\n            \"          \",\n        ]);\n        assert_eq!(buffer, expected);\n    }\n\n    #[test]\n    fn empty_strings() {\n        let list = List::new([\"Item 0\", \"\", \"\", \"Item 1\", \"Item 2\"])\n            .block(Block::bordered().title(\"List\"));\n        let buffer = widget(list, 10, 7);\n        let expected = Buffer::with_lines([\n            \"\u250cList\u2500\u2500\u2500\u2500\u2510\",\n            \"\u2502Item 0  \u2502\",\n            \"\u2502        \u2502\",\n            \"\u2502        \u2502\",\n            \"\u2502Item 1  \u2502\",\n            \"\u2502Item 2  \u2502\",\n            \"\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\",\n        ]);\n        assert_eq!(buffer, expected);\n    }\n\n    #[test]\n    fn block() {\n        let list = List::new([\"Item 0\", \"Item 1\", \"Item 2\"]).block(Block::bordered().title(\"List\"));\n        let buffer = widget(list, 10, 7);\n        let expected = Buffer::with_lines([\n            \"\u250cList\u2500\u2500\u2500\u2500\u2510\",\n            \"\u2502Item 0  \u2502\",\n            \"\u2502Item 1  \u2502\",\n            \"\u2502Item 2  \u2502\",\n            \"\u2502        \u2502\",\n            \"\u2502        \u2502\",\n            \"\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\",\n        ]);\n        assert_eq!(buffer, expected);\n    }\n\n    #[test]\n    fn style() {\n        let list = List::new([\"Item 0\", \"Item 1\", \"Item 2\"]).style(Style::default().fg(Color::Red));\n        let buffer = widget(list, 10, 5);\n        let expected = Buffer::with_lines([\n            \"Item 0    \".red(),\n            \"Item 1    \".red(),\n            \"Item 2    \".red(),\n            \"          \".red(),\n            \"          \".red(),\n        ]);\n        assert_eq!(buffer, expected);\n    }\n\n    #[test]\n    fn highlight_symbol_and_style() {\n        let list = List::new([\"Item 0\", \"Item 1\", \"Item 2\"])\n            .highlight_symbol(\">>\")\n            .highlight_style(Style::default().fg(Color::Yellow));\n        let mut state = ListState::default();\n        state.select(Some(1));\n        let buffer = stateful_widget(list, &mut state, 10, 5);\n        let expected = Buffer::with_lines([\n            \"  Item 0  \".into(),\n            \">>Item 1  \".yellow(),\n            \"  Item 2  \".into(),\n            \"          \".into(),\n            \"          \".into(),\n        ]);\n        assert_eq!(buffer, expected);\n    }\n\n    #[test]\n    fn highlight_spacing_default_when_selected() {\n        // when not selected\n        {\n            let list = List::new([\"Item 0\", \"Item 1\", \"Item 2\"]).highlight_symbol(\">>\");\n            let mut state = ListState::default();\n            let buffer = stateful_widget(list, &mut state, 10, 5);\n            let expected = Buffer::with_lines([\n                \"Item 0    \",\n                \"Item 1    \",\n                \"Item 2    \",\n                \"          \",\n                \"          \",\n            ]);\n            assert_eq!(buffer, expected);\n        }\n\n        // when selected\n        {\n            let list = List::new([\"Item 0\", \"Item 1\", \"Item 2\"]).highlight_symbol(\">>\");\n            let mut state = ListState::default();\n            state.select(Some(1));\n            let buffer = stateful_widget(list, &mut state, 10, 5);\n            let expected = Buffer::with_lines([\n                \"  Item 0  \",\n                \">>Item 1  \",\n                \"  Item 2  \",\n                \"          \",\n                \"          \",\n            ]);\n            assert_eq!(buffer, expected);\n        }\n    }\n\n    #[test]\n    fn highlight_spacing_default_always() {\n        // when not selected\n        {\n            let list = List::new([\"Item 0\", \"Item 1\", \"Item 2\"])\n                .highlight_symbol(\">>\")\n                .highlight_spacing(HighlightSpacing::Always);\n            let mut state = ListState::default();\n            let buffer = stateful_widget(list, &mut state, 10, 5);\n            let expected = Buffer::with_lines([\n                \"  Item 0  \",\n                \"  Item 1  \",\n                \"  Item 2  \",\n                \"          \",\n                \"          \",\n            ]);\n            assert_eq!(buffer, expected);\n        }\n\n        // when selected\n        {\n            let list = List::new([\"Item 0\", \"Item 1\", \"Item 2\"])\n                .highlight_symbol(\">>\")\n                .highlight_spacing(HighlightSpacing::Always);\n            let mut state = ListState::default();\n            state.select(Some(1));\n            let buffer = stateful_widget(list, &mut state, 10, 5);\n            let expected = Buffer::with_lines([\n                \"  Item 0  \",\n                \">>Item 1  \",\n                \"  Item 2  \",\n                \"          \",\n                \"          \",\n            ]);\n            assert_eq!(buffer, expected);\n        }\n    }\n\n    #[test]\n    fn highlight_spacing_default_never() {\n        // when not selected\n        {\n            let list = List::new([\"Item 0\", \"Item 1\", \"Item 2\"])\n                .highlight_symbol(\">>\")\n                .highlight_spacing(HighlightSpacing::Never);\n            let mut state = ListState::default();\n            let buffer = stateful_widget(list, &mut state, 10, 5);\n            let expected = Buffer::with_lines([\n                \"Item 0    \",\n                \"Item 1    \",\n                \"Item 2    \",\n                \"          \",\n                \"          \",\n            ]);\n            assert_eq!(buffer, expected);\n        }\n\n        // when selected\n        {\n            let list = List::new([\"Item 0\", \"Item 1\", \"Item 2\"])\n                .highlight_symbol(\">>\")\n                .highlight_spacing(HighlightSpacing::Never);\n            let mut state = ListState::default();\n            state.select(Some(1));\n            let buffer = stateful_widget(list, &mut state, 10, 5);\n            let expected = Buffer::with_lines([\n                \"Item 0    \",\n                \"Item 1    \",\n                \"Item 2    \",\n                \"          \",\n                \"          \",\n            ]);\n            assert_eq!(buffer, expected);\n        }\n    }\n\n    #[test]\n    fn repeat_highlight_symbol() {\n        let list = List::new([\"Item 0\\nLine 2\", \"Item 1\", \"Item 2\"])\n            .highlight_symbol(\">>\")\n            .highlight_style(Style::default().fg(Color::Yellow))\n            .repeat_highlight_symbol(true);\n        let mut state = ListState::default();\n        state.select(Some(0));\n        let buffer = stateful_widget(list, &mut state, 10, 5);\n        let expected = Buffer::with_lines([\n            \">>Item 0  \".yellow(),\n            \">>Line 2  \".yellow(),\n            \"  Item 1  \".into(),\n            \"  Item 2  \".into(),\n            \"          \".into(),\n        ]);\n        assert_eq!(buffer, expected);\n    }\n\n    #[rstest]\n    #[case::top_to_bottom(ListDirection::TopToBottom, [\n        \"Item 0    \",\n        \"Item 1    \",\n        \"Item 2    \",\n        \"          \",\n    ])]\n    #[case::top_to_bottom(ListDirection::BottomToTop, [\n        \"          \",\n        \"Item 2    \",\n        \"Item 1    \",\n        \"Item 0    \",\n    ])]\n    fn list_direction<'line, Lines>(#[case] direction: ListDirection, #[case] expected: Lines)\n    where\n        Lines: IntoIterator,\n        Lines::Item: Into<Line<'line>>,\n    {\n        let list = List::new([\"Item 0\", \"Item 1\", \"Item 2\"]).direction(direction);\n        let buffer = widget(list, 10, 4);\n        assert_eq!(buffer, Buffer::with_lines(expected));\n    }\n\n    #[test]\n    fn truncate_items() {\n        let list = List::new([\"Item 0\", \"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\"]);\n        let buffer = widget(list, 10, 3);\n        #[rustfmt::skip]\n        let expected = Buffer::with_lines([\n            \"Item 0    \",\n            \"Item 1    \",\n            \"Item 2    \",\n        ]);\n        assert_eq!(buffer, expected);\n    }\n\n    #[test]\n    fn offset_renders_shifted() {\n        let list = List::new([\n            \"Item 0\", \"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\", \"Item 5\", \"Item 6\",\n        ]);\n        let mut state = ListState::default().with_offset(3);\n        let buffer = stateful_widget(list, &mut state, 6, 3);\n\n        let expected = Buffer::with_lines([\"Item 3\", \"Item 4\", \"Item 5\"]);\n        assert_eq!(buffer, expected);\n    }\n\n    #[rstest]\n    #[case(None, [\n        \"Item 0 with a v\",\n        \"Item 1         \",\n        \"Item 2         \",\n    ])]\n    #[case(Some(0), [\n        \">>Item 0 with a\",\n        \"  Item 1       \",\n        \"  Item 2       \",\n    ])]\n    fn long_lines<'line, Lines>(#[case] selected: Option<usize>, #[case] expected: Lines)\n    where\n        Lines: IntoIterator,\n        Lines::Item: Into<Line<'line>>,\n    {\n        let items = [\n            \"Item 0 with a very long line that will be truncated\",\n            \"Item 1\",\n            \"Item 2\",\n        ];\n        let list = List::new(items).highlight_symbol(\">>\");\n        let mut state = ListState::default().with_selected(selected);\n        let buffer = stateful_widget(list, &mut state, 15, 3);\n        assert_eq!(buffer, Buffer::with_lines(expected));\n    }\n\n    #[test]\n    fn selected_item_ensures_selected_item_is_visible_when_offset_is_before_visible_range() {\n        let items = [\n            \"Item 0\", \"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\", \"Item 5\", \"Item 6\",\n        ];\n        let list = List::new(items).highlight_symbol(\">>\");\n        // Set the initial visible range to items 3, 4, and 5\n        let mut state = ListState::default().with_selected(Some(1)).with_offset(3);\n        let buffer = stateful_widget(list, &mut state, 10, 3);\n\n        #[rustfmt::skip]\n        let expected = Buffer::with_lines([\n            \">>Item 1  \",\n            \"  Item 2  \",\n            \"  Item 3  \",\n        ]);\n\n        assert_eq!(buffer, expected);\n        assert_eq!(state.selected, Some(1));\n        assert_eq!(\n            state.offset, 1,\n            \"did not scroll the selected item into view\"\n        );\n    }\n\n    #[test]\n    fn selected_item_ensures_selected_item_is_visible_when_offset_is_after_visible_range() {\n        let items = [\n            \"Item 0\", \"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\", \"Item 5\", \"Item 6\",\n        ];\n        let list = List::new(items).highlight_symbol(\">>\");\n        // Set the initial visible range to items 3, 4, and 5\n        let mut state = ListState::default().with_selected(Some(6)).with_offset(3);\n        let buffer = stateful_widget(list, &mut state, 10, 3);\n\n        #[rustfmt::skip]\n        let expected = Buffer::with_lines([\n            \"  Item 4  \",\n            \"  Item 5  \",\n            \">>Item 6  \",\n        ]);\n\n        assert_eq!(buffer, expected);\n        assert_eq!(state.selected, Some(6));\n        assert_eq!(\n            state.offset, 4,\n            \"did not scroll the selected item into view\"\n        );\n    }\n\n    #[test]\n    fn can_be_stylized() {\n        assert_eq!(\n            List::new::<Vec<&str>>(vec![])\n                .black()\n                .on_white()\n                .bold()\n                .not_dim()\n                .style,\n            Style::default()\n                .fg(Color::Black)\n                .bg(Color::White)\n                .add_modifier(Modifier::BOLD)\n                .remove_modifier(Modifier::DIM)\n        );\n    }\n\n    #[test]\n    fn with_alignment() {\n        let list = List::new([\n            Line::from(\"Left\").alignment(Alignment::Left),\n            Line::from(\"Center\").alignment(Alignment::Center),\n            Line::from(\"Right\").alignment(Alignment::Right),\n        ]);\n        let buffer = widget(list, 10, 4);\n        let expected = Buffer::with_lines([\"Left      \", \"  Center  \", \"     Right\", \"\"]);\n        assert_eq!(buffer, expected);\n    }\n\n    #[test]\n    fn alignment_odd_line_odd_area() {\n        let list = List::new([\n            Line::from(\"Odd\").alignment(Alignment::Left),\n            Line::from(\"Even\").alignment(Alignment::Center),\n            Line::from(\"Width\").alignment(Alignment::Right),\n        ]);\n        let buffer = widget(list, 7, 4);\n        let expected = Buffer::with_lines([\"Odd    \", \" Even  \", \"  Width\", \"\"]);\n        assert_eq!(buffer, expected);\n    }\n\n    #[test]\n    fn alignment_even_line_even_area() {\n        let list = List::new([\n            Line::from(\"Odd\").alignment(Alignment::Left),\n            Line::from(\"Even\").alignment(Alignment::Center),\n            Line::from(\"Width\").alignment(Alignment::Right),\n        ]);\n        let buffer = widget(list, 6, 4);\n        let expected = Buffer::with_lines([\"Odd   \", \" Even \", \" Width\", \"\"]);\n        assert_eq!(buffer, expected);\n    }\n\n    #[test]\n    fn alignment_odd_line_even_area() {\n        let list = List::new([\n            Line::from(\"Odd\").alignment(Alignment::Left),\n            Line::from(\"Even\").alignment(Alignment::Center),\n            Line::from(\"Width\").alignment(Alignment::Right),\n        ]);\n        let buffer = widget(list, 8, 4);\n        let expected = Buffer::with_lines([\"Odd     \", \"  Even  \", \"   Width\", \"\"]);\n        assert_eq!(buffer, expected);\n    }\n\n    #[test]\n    fn alignment_even_line_odd_area() {\n        let list = List::new([\n            Line::from(\"Odd\").alignment(Alignment::Left),\n            Line::from(\"Even\").alignment(Alignment::Center),\n            Line::from(\"Width\").alignment(Alignment::Right),\n        ]);\n        let buffer = widget(list, 6, 4);\n        let expected = Buffer::with_lines([\"Odd   \", \" Even \", \" Width\", \"\"]);\n        assert_eq!(buffer, expected);\n    }\n\n    #[test]\n    fn alignment_zero_line_width() {\n        let list = List::new([Line::from(\"This line has zero width\").alignment(Alignment::Center)]);\n        let buffer = widget(list, 0, 2);\n        assert_eq!(buffer, Buffer::with_lines([\"\"; 2]));\n    }\n\n    #[test]\n    fn alignment_zero_area_width() {\n        let list = List::new([Line::from(\"Text\").alignment(Alignment::Left)]);\n        let mut buffer = Buffer::empty(Rect::new(0, 0, 4, 1));\n        Widget::render(list, Rect::new(0, 0, 4, 0), &mut buffer);\n        assert_eq!(buffer, Buffer::with_lines([\"    \"]));\n    }\n\n    #[test]\n    fn alignment_line_less_than_width() {\n        let list = List::new([Line::from(\"Small\").alignment(Alignment::Center)]);\n        let buffer = widget(list, 10, 2);\n        let expected = Buffer::with_lines([\"  Small   \", \"\"]);\n        assert_eq!(buffer, expected);\n    }\n\n    #[test]\n    fn alignment_line_equal_to_width() {\n        let list = List::new([Line::from(\"Exact\").alignment(Alignment::Left)]);\n        let buffer = widget(list, 5, 2);\n        assert_eq!(buffer, Buffer::with_lines([\"Exact\", \"\"]));\n    }\n\n    #[test]\n    fn alignment_line_greater_than_width() {\n        let list = List::new([Line::from(\"Large line\").alignment(Alignment::Left)]);\n        let buffer = widget(list, 5, 2);\n        assert_eq!(buffer, Buffer::with_lines([\"Large\", \"\"]));\n    }\n\n    #[rstest]\n    #[case::no_padding(\n        4,\n        2, // Offset\n        0, // Padding\n        Some(2), // Selected\n        [\n            \">> Item 2 \",\n            \"   Item 3 \",\n            \"   Item 4 \",\n            \"   Item 5 \",\n        ]\n    )]\n    #[case::one_before(\n        4,\n        2, // Offset\n        1, // Padding\n        Some(2), // Selected\n        [\n            \"   Item 1 \",\n            \">> Item 2 \",\n            \"   Item 3 \",\n            \"   Item 4 \",\n        ]\n    )]\n    #[case::one_after(\n        4,\n        1, // Offset\n        1, // Padding\n        Some(4), // Selected\n        [\n            \"   Item 2 \",\n            \"   Item 3 \",\n            \">> Item 4 \",\n            \"   Item 5 \",\n        ]\n    )]\n    #[case::check_padding_overflow(\n        4,\n        1, // Offset\n        2, // Padding\n        Some(4), // Selected\n        [\n            \"   Item 2 \",\n            \"   Item 3 \",\n            \">> Item 4 \",\n            \"   Item 5 \",\n        ]\n    )]\n    #[case::no_padding_offset_behavior(\n        5, // Render Area Height\n        2, // Offset\n        0, // Padding\n        Some(3), // Selected\n        [\n            \"   Item 2 \",\n            \">> Item 3 \",\n            \"   Item 4 \",\n            \"   Item 5 \",\n            \"          \",\n        ]\n    )]\n    #[case::two_before(\n        5, // Render Area Height\n        2, // Offset\n        2, // Padding\n        Some(3), // Selected\n        [\n            \"   Item 1 \",\n            \"   Item 2 \",\n            \">> Item 3 \",\n            \"   Item 4 \",\n            \"   Item 5 \",\n        ]\n    )]\n    #[case::keep_selected_visible(\n        4,\n        0, // Offset\n        4, // Padding\n        Some(1), // Selected\n        [\n            \"   Item 0 \",\n            \">> Item 1 \",\n            \"   Item 2 \",\n            \"   Item 3 \",\n        ]\n    )]\n    fn with_padding<'line, Lines>(\n        #[case] render_height: u16,\n        #[case] offset: usize,\n        #[case] padding: usize,\n        #[case] selected: Option<usize>,\n        #[case] expected: Lines,\n    ) where\n        Lines: IntoIterator,\n        Lines::Item: Into<Line<'line>>,\n    {\n        let backend = backend::TestBackend::new(10, render_height);\n        let mut terminal = Terminal::new(backend).unwrap();\n        let mut state = ListState::default();\n\n        *state.offset_mut() = offset;\n        state.select(selected);\n\n        let list = List::new([\"Item 0\", \"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\", \"Item 5\"])\n            .scroll_padding(padding)\n            .highlight_symbol(\">> \");\n        terminal\n            .draw(|f| f.render_stateful_widget(list, f.area(), &mut state))\n            .unwrap();\n        terminal.backend().assert_buffer_lines(expected);\n    }\n\n    /// If there isn't enough room for the selected item and the requested padding the list can jump\n    /// up and down every frame if something isn't done about it. This code tests to make sure that\n    /// isn't currently happening\n    #[test]\n    fn padding_flicker() {\n        let backend = backend::TestBackend::new(10, 5);\n        let mut terminal = Terminal::new(backend).unwrap();\n        let mut state = ListState::default();\n\n        *state.offset_mut() = 2;\n        state.select(Some(4));\n\n        let items = [\n            \"Item 0\", \"Item 1\", \"Item 2\", \"Item 3\", \"Item 4\", \"Item 5\", \"Item 6\", \"Item 7\",\n        ];\n        let list = List::new(items).scroll_padding(3).highlight_symbol(\">> \");\n\n        terminal\n            .draw(|f| f.render_stateful_widget(&list, f.area(), &mut state))\n            .unwrap();\n\n        let offset_after_render = state.offset();\n\n        terminal\n            .draw(|f| f.render_stateful_widget(&list, f.area(), &mut state))\n            .unwrap();\n\n        // Offset after rendering twice should remain the same as after once\n        assert_eq!(offset_after_render, state.offset());\n    }\n\n    #[test]\n    fn padding_inconsistent_item_sizes() {\n        let backend = backend::TestBackend::new(10, 3);\n        let mut terminal = Terminal::new(backend).unwrap();\n        let mut state = ListState::default().with_offset(0).with_selected(Some(3));\n\n        let items = [\n            ListItem::new(\"Item 0\"),\n            ListItem::new(\"Item 1\"),\n            ListItem::new(\"Item 2\"),\n            ListItem::new(\"Item 3\"),\n            ListItem::new(\"Item 4\\nTest\\nTest\"),\n            ListItem::new(\"Item 5\"),\n        ];\n        let list = List::new(items).scroll_padding(1).highlight_symbol(\">> \");\n\n        terminal\n            .draw(|f| f.render_stateful_widget(list, f.area(), &mut state))\n            .unwrap();\n\n        #[rustfmt::skip]\n        let expected = [\n            \"   Item 1 \",\n            \"   Item 2 \",\n            \">> Item 3 \",\n        ];\n        terminal.backend().assert_buffer_lines(expected);\n    }\n\n    // Tests to make sure when it's pushing back the first visible index value that it doesnt\n    // include an item that's too large\n    #[test]\n    fn padding_offset_pushback_break() {\n        let backend = backend::TestBackend::new(10, 4);\n        let mut terminal = Terminal::new(backend).unwrap();\n        let mut state = ListState::default();\n\n        *state.offset_mut() = 1;\n        state.select(Some(2));\n\n        let items = [\n            ListItem::new(\"Item 0\\nTest\\nTest\"),\n            ListItem::new(\"Item 1\"),\n            ListItem::new(\"Item 2\"),\n            ListItem::new(\"Item 3\"),\n        ];\n        let list = List::new(items).scroll_padding(2).highlight_symbol(\">> \");\n\n        terminal\n            .draw(|f| f.render_stateful_widget(list, f.area(), &mut state))\n            .unwrap();\n\n        terminal.backend().assert_buffer_lines([\n            \"   Item 1 \",\n            \">> Item 2 \",\n            \"   Item 3 \",\n            \"          \",\n        ]);\n    }\n\n    /// Regression test for a bug where highlight symbol being greater than width caused a panic due\n    /// to subtraction with underflow.\n    ///\n    /// See [#949](https://github.com/ratatui/ratatui/pull/949) for details\n    #[rstest]\n    #[case::under(\">>>>\", \"Item1\", \">>>>Item1 \")] // enough space to render the highlight symbol\n    #[case::exact(\">>>>>\", \"Item1\", \">>>>>Item1\")] // exact space to render the highlight symbol\n    #[case::overflow(\">>>>>>\", \"Item1\", \">>>>>>Item\")] // not enough space\n    fn highlight_symbol_overflow(\n        #[case] highlight_symbol: &str,\n        #[case] item: &str,\n        #[case] expected: &str,\n        mut single_line_buf: Buffer,\n    ) {\n        let list = List::new([item]).highlight_symbol(highlight_symbol);\n        let mut state = ListState::default();\n        state.select(Some(0));\n        StatefulWidget::render(list, single_line_buf.area, &mut single_line_buf, &mut state);\n        assert_eq!(single_line_buf, Buffer::with_lines([expected]));\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "870e19f5837334407a0a946518deee53d8c4f63a",
    "func": "use serde::{Deserialize, Serialize};\n\n#[derive(Clone, Deserialize, Serialize)]\n#[cfg_attr(\n    feature = \"config-schema\",\n    derive(schemars::JsonSchema),\n    schemars(deny_unknown_fields)\n)]\n#[serde(default)]\npub struct RakuConfig<'a> {\n    pub format: &'a str,\n    pub version_format: &'a str,\n    pub symbol: &'a str,\n    pub style: &'a str,\n    pub disabled: bool,\n    pub detect_extensions: Vec<&'a str>,\n    pub detect_files: Vec<&'a str>,\n    pub detect_folders: Vec<&'a str>,\n}\n\nimpl<'a> Default for RakuConfig<'a> {\n    fn default() -> Self {\n        RakuConfig {\n            format: \"via [$symbol($version-$vm_version )]($style)\",\n            version_format: \"${raw}\",\n            symbol: \"\ud83e\udd8b \",\n            style: \"149 bold\",\n            disabled: false,\n            detect_extensions: vec![\"p6\", \"pm6\", \"pod6\", \"raku\", \"rakumod\"],\n            detect_files: vec![\"META6.json\"],\n            detect_folders: vec![],\n        }\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "823d5d65e4c17773289a953b6a842a534b2ec429",
    "func": "#![cfg(feature = \"rustls-0_23\")]\n\nextern crate tls_rustls_023 as rustls;\n\nuse std::{\n    convert::Infallible,\n    io::{self, BufReader, Write},\n    net::{SocketAddr, TcpStream as StdTcpStream},\n    sync::Arc,\n    task::Poll,\n    time::Duration,\n};\n\nuse actix_http::{\n    body::{BodyStream, BoxBody, SizedStream},\n    error::PayloadError,\n    header::{self, HeaderName, HeaderValue},\n    Error, HttpService, Method, Request, Response, StatusCode, TlsAcceptorConfig, Version,\n};\nuse actix_http_test::test_server;\nuse actix_rt::pin;\nuse actix_service::{fn_factory_with_config, fn_service};\nuse actix_tls::connect::rustls_0_23::webpki_roots_cert_store;\nuse actix_utils::future::{err, ok, poll_fn};\nuse bytes::{Bytes, BytesMut};\nuse derive_more::derive::{Display, Error};\nuse futures_core::{ready, Stream};\nuse futures_util::stream::once;\nuse rustls::{pki_types::ServerName, ServerConfig as RustlsServerConfig};\nuse rustls_pemfile::{certs, pkcs8_private_keys};\n\nasync fn load_body<S>(stream: S) -> Result<BytesMut, PayloadError>\nwhere\n    S: Stream<Item = Result<Bytes, PayloadError>>,\n{\n    let mut buf = BytesMut::new();\n\n    pin!(stream);\n\n    poll_fn(|cx| loop {\n        let body = stream.as_mut();\n\n        match ready!(body.poll_next(cx)) {\n            Some(Ok(bytes)) => buf.extend_from_slice(&bytes),\n            None => return Poll::Ready(Ok(())),\n            Some(Err(err)) => return Poll::Ready(Err(err)),\n        }\n    })\n    .await?;\n\n    Ok(buf)\n}\n\nfn tls_config() -> RustlsServerConfig {\n    let rcgen::CertifiedKey { cert, key_pair } =\n        rcgen::generate_simple_self_signed([\"localhost\".to_owned()]).unwrap();\n    let cert_file = cert.pem();\n    let key_file = key_pair.serialize_pem();\n\n    let cert_file = &mut BufReader::new(cert_file.as_bytes());\n    let key_file = &mut BufReader::new(key_file.as_bytes());\n\n    let cert_chain = certs(cert_file).collect::<Result<Vec<_>, _>>().unwrap();\n    let mut keys = pkcs8_private_keys(key_file)\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n\n    let mut config = RustlsServerConfig::builder()\n        .with_no_client_auth()\n        .with_single_cert(\n            cert_chain,\n            rustls::pki_types::PrivateKeyDer::Pkcs8(keys.remove(0)),\n        )\n        .unwrap();\n\n    config.alpn_protocols.push(HTTP1_1_ALPN_PROTOCOL.to_vec());\n    config.alpn_protocols.push(H2_ALPN_PROTOCOL.to_vec());\n\n    config\n}\n\npub fn get_negotiated_alpn_protocol(\n    addr: SocketAddr,\n    client_alpn_protocol: &[u8],\n) -> Option<Vec<u8>> {\n    let mut config = rustls::ClientConfig::builder()\n        .with_root_certificates(webpki_roots_cert_store())\n        .with_no_client_auth();\n\n    config.alpn_protocols.push(client_alpn_protocol.to_vec());\n\n    let mut sess =\n        rustls::ClientConnection::new(Arc::new(config), ServerName::try_from(\"localhost\").unwrap())\n            .unwrap();\n\n    let mut sock = StdTcpStream::connect(addr).unwrap();\n    let mut stream = rustls::Stream::new(&mut sess, &mut sock);\n\n    // The handshake will fails because the client will not be able to verify the server\n    // certificate, but it doesn't matter here as we are just interested in the negotiated ALPN\n    // protocol\n    let _ = stream.flush();\n\n    sess.alpn_protocol().map(|proto| proto.to_vec())\n}\n\n#[actix_rt::test]\nasync fn h1() -> io::Result<()> {\n    let srv = test_server(move || {\n        HttpService::build()\n            .h1(|_| ok::<_, Error>(Response::ok()))\n            .rustls_0_23(tls_config())\n    })\n    .await;\n\n    let response = srv.sget(\"/\").send().await.unwrap();\n    assert!(response.status().is_success());\n    Ok(())\n}\n\n#[actix_rt::test]\nasync fn h2() -> io::Result<()> {\n    let srv = test_server(move || {\n        HttpService::build()\n            .h2(|_| ok::<_, Error>(Response::ok()))\n            .rustls_0_23(tls_config())\n    })\n    .await;\n\n    let response = srv.sget(\"/\").send().await.unwrap();\n    assert!(response.status().is_success());\n    Ok(())\n}\n\n#[actix_rt::test]\nasync fn h1_1() -> io::Result<()> {\n    let srv = test_server(move || {\n        HttpService::build()\n            .h1(|req: Request| {\n                assert!(req.peer_addr().is_some());\n                assert_eq!(req.version(), Version::HTTP_11);\n                ok::<_, Error>(Response::ok())\n            })\n            .rustls_0_23(tls_config())\n    })\n    .await;\n\n    let response = srv.sget(\"/\").send().await.unwrap();\n    assert!(response.status().is_success());\n    Ok(())\n}\n\n#[actix_rt::test]\nasync fn h2_1() -> io::Result<()> {\n    let srv = test_server(move || {\n        HttpService::build()\n            .finish(|req: Request| {\n                assert!(req.peer_addr().is_some());\n                assert_eq!(req.version(), Version::HTTP_2);\n                ok::<_, Error>(Response::ok())\n            })\n            .rustls_0_23_with_config(\n                tls_config(),\n                TlsAcceptorConfig::default().handshake_timeout(Duration::from_secs(5)),\n            )\n    })\n    .await;\n\n    let response = srv.sget(\"/\").send().await.unwrap();\n    assert!(response.status().is_success());\n    Ok(())\n}\n\n#[actix_rt::test]\nasync fn h2_body1() -> io::Result<()> {\n    let data = \"HELLOWORLD\".to_owned().repeat(64 * 1024);\n    let mut srv = test_server(move || {\n        HttpService::build()\n            .h2(|mut req: Request<_>| async move {\n                let body = load_body(req.take_payload()).await?;\n                Ok::<_, Error>(Response::ok().set_body(body))\n            })\n            .rustls_0_23(tls_config())\n    })\n    .await;\n\n    let response = srv.sget(\"/\").send_body(data.clone()).await.unwrap();\n    assert!(response.status().is_success());\n\n    let body = srv.load_body(response).await.unwrap();\n    assert_eq!(&body, data.as_bytes());\n    Ok(())\n}\n\n#[actix_rt::test]\nasync fn h2_content_length() {\n    let srv = test_server(move || {\n        HttpService::build()\n            .h2(|req: Request| {\n                let indx: usize = req.uri().path()[1..].parse().unwrap();\n                let statuses = [\n                    StatusCode::CONTINUE,\n                    StatusCode::NO_CONTENT,\n                    StatusCode::OK,\n                    StatusCode::NOT_FOUND,\n                ];\n                ok::<_, Infallible>(Response::new(statuses[indx]))\n            })\n            .rustls_0_23(tls_config())\n    })\n    .await;\n\n    let header = HeaderName::from_static(\"content-length\");\n    let value = HeaderValue::from_static(\"0\");\n\n    {\n        #[allow(clippy::single_element_loop)]\n        for &i in &[0] {\n            let req = srv\n                .request(Method::HEAD, srv.surl(&format!(\"/{}\", i)))\n                .send();\n            let _response = req.await.expect_err(\"should timeout on recv 1xx frame\");\n            // assert_eq!(response.headers().get(&header), None);\n\n            let req = srv\n                .request(Method::GET, srv.surl(&format!(\"/{}\", i)))\n                .send();\n            let _response = req.await.expect_err(\"should timeout on recv 1xx frame\");\n            // assert_eq!(response.headers().get(&header), None);\n        }\n\n        #[allow(clippy::single_element_loop)]\n        for &i in &[1] {\n            let req = srv\n                .request(Method::GET, srv.surl(&format!(\"/{}\", i)))\n                .send();\n            let response = req.await.unwrap();\n            assert_eq!(response.headers().get(&header), None);\n        }\n\n        for &i in &[2, 3] {\n            let req = srv\n                .request(Method::GET, srv.surl(&format!(\"/{}\", i)))\n                .send();\n            let response = req.await.unwrap();\n            assert_eq!(response.headers().get(&header), Some(&value));\n        }\n    }\n}\n\n#[actix_rt::test]\nasync fn h2_headers() {\n    let data = STR.repeat(10);\n    let data2 = data.clone();\n\n    let mut srv = test_server(move || {\n        let data = data.clone();\n        HttpService::build()\n            .h2(move |_| {\n                let mut config = Response::build(StatusCode::OK);\n                for idx in 0..90 {\n                    config.insert_header((\n                    format!(\"X-TEST-{}\", idx).as_str(),\n                    \"TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST \\\n                        TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST \\\n                        TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST \\\n                        TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST \\\n                        TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST \\\n                        TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST \\\n                        TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST \\\n                        TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST \\\n                        TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST \\\n                        TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST \\\n                        TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST \\\n                        TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST \\\n                        TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST \",\n                ));\n                }\n                ok::<_, Infallible>(config.body(data.clone()))\n            })\n            .rustls_0_23(tls_config())\n    })\n    .await;\n\n    let response = srv.sget(\"/\").send().await.unwrap();\n    assert!(response.status().is_success());\n\n    // read response\n    let bytes = srv.load_body(response).await.unwrap();\n    assert_eq!(bytes, Bytes::from(data2));\n}\n\nconst STR: &str = \"Hello World Hello World Hello World Hello World Hello World \\\n                   Hello World Hello World Hello World Hello World Hello World \\\n                   Hello World Hello World Hello World Hello World Hello World \\\n                   Hello World Hello World Hello World Hello World Hello World \\\n                   Hello World Hello World Hello World Hello World Hello World \\\n                   Hello World Hello World Hello World Hello World Hello World \\\n                   Hello World Hello World Hello World Hello World Hello World \\\n                   Hello World Hello World Hello World Hello World Hello World \\\n                   Hello World Hello World Hello World Hello World Hello World \\\n                   Hello World Hello World Hello World Hello World Hello World \\\n                   Hello World Hello World Hello World Hello World Hello World \\\n                   Hello World Hello World Hello World Hello World Hello World \\\n                   Hello World Hello World Hello World Hello World Hello World \\\n                   Hello World Hello World Hello World Hello World Hello World \\\n                   Hello World Hello World Hello World Hello World Hello World \\\n                   Hello World Hello World Hello World Hello World Hello World \\\n                   Hello World Hello World Hello World Hello World Hello World \\\n                   Hello World Hello World Hello World Hello World Hello World \\\n                   Hello World Hello World Hello World Hello World Hello World \\\n                   Hello World Hello World Hello World Hello World Hello World \\\n                   Hello World Hello World Hello World Hello World Hello World\";\n\n#[actix_rt::test]\nasync fn h2_body2() {\n    let mut srv = test_server(move || {\n        HttpService::build()\n            .h2(|_| ok::<_, Infallible>(Response::ok().set_body(STR)))\n            .rustls_0_23(tls_config())\n    })\n    .await;\n\n    let response = srv.sget(\"/\").send().await.unwrap();\n    assert!(response.status().is_success());\n\n    // read response\n    let bytes = srv.load_body(response).await.unwrap();\n    assert_eq!(bytes, Bytes::from_static(STR.as_ref()));\n}\n\n#[actix_rt::test]\nasync fn h2_head_empty() {\n    let mut srv = test_server(move || {\n        HttpService::build()\n            .finish(|_| ok::<_, Infallible>(Response::ok().set_body(STR)))\n            .rustls_0_23(tls_config())\n    })\n    .await;\n\n    let response = srv.shead(\"/\").send().await.unwrap();\n    assert!(response.status().is_success());\n    assert_eq!(response.version(), Version::HTTP_2);\n\n    {\n        let len = response\n            .headers()\n            .get(http::header::CONTENT_LENGTH)\n            .unwrap();\n        assert_eq!(format!(\"{}\", STR.len()), len.to_str().unwrap());\n    }\n\n    // read response\n    let bytes = srv.load_body(response).await.unwrap();\n    assert!(bytes.is_empty());\n}\n\n#[actix_rt::test]\nasync fn h2_head_binary() {\n    let mut srv = test_server(move || {\n        HttpService::build()\n            .h2(|_| ok::<_, Infallible>(Response::ok().set_body(STR)))\n            .rustls_0_23(tls_config())\n    })\n    .await;\n\n    let response = srv.shead(\"/\").send().await.unwrap();\n    assert!(response.status().is_success());\n\n    {\n        let len = response\n            .headers()\n            .get(http::header::CONTENT_LENGTH)\n            .unwrap();\n        assert_eq!(format!(\"{}\", STR.len()), len.to_str().unwrap());\n    }\n\n    // read response\n    let bytes = srv.load_body(response).await.unwrap();\n    assert!(bytes.is_empty());\n}\n\n#[actix_rt::test]\nasync fn h2_head_binary2() {\n    let srv = test_server(move || {\n        HttpService::build()\n            .h2(|_| ok::<_, Infallible>(Response::ok().set_body(STR)))\n            .rustls_0_23(tls_config())\n    })\n    .await;\n\n    let response = srv.shead(\"/\").send().await.unwrap();\n    assert!(response.status().is_success());\n\n    {\n        let len = response\n            .headers()\n            .get(http::header::CONTENT_LENGTH)\n            .unwrap();\n        assert_eq!(format!(\"{}\", STR.len()), len.to_str().unwrap());\n    }\n}\n\n#[actix_rt::test]\nasync fn h2_body_length() {\n    let mut srv = test_server(move || {\n        HttpService::build()\n            .h2(|_| {\n                let body = once(ok::<_, Infallible>(Bytes::from_static(STR.as_ref())));\n                ok::<_, Infallible>(\n                    Response::ok().set_body(SizedStream::new(STR.len() as u64, body)),\n                )\n            })\n            .rustls_0_23(tls_config())\n    })\n    .await;\n\n    let response = srv.sget(\"/\").send().await.unwrap();\n    assert!(response.status().is_success());\n\n    // read response\n    let bytes = srv.load_body(response).await.unwrap();\n    assert_eq!(bytes, Bytes::from_static(STR.as_ref()));\n}\n\n#[actix_rt::test]\nasync fn h2_body_chunked_explicit() {\n    let mut srv = test_server(move || {\n        HttpService::build()\n            .h2(|_| {\n                let body = once(ok::<_, Error>(Bytes::from_static(STR.as_ref())));\n                ok::<_, Infallible>(\n                    Response::build(StatusCode::OK)\n                        .insert_header((header::TRANSFER_ENCODING, \"chunked\"))\n                        .body(BodyStream::new(body)),\n                )\n            })\n            .rustls_0_23(tls_config())\n    })\n    .await;\n\n    let response = srv.sget(\"/\").send().await.unwrap();\n    assert!(response.status().is_success());\n    assert!(!response.headers().contains_key(header::TRANSFER_ENCODING));\n\n    // read response\n    let bytes = srv.load_body(response).await.unwrap();\n\n    // decode\n    assert_eq!(bytes, Bytes::from_static(STR.as_ref()));\n}\n\n#[actix_rt::test]\nasync fn h2_response_http_error_handling() {\n    let mut srv = test_server(move || {\n        HttpService::build()\n            .h2(fn_factory_with_config(|_: ()| {\n                ok::<_, Infallible>(fn_service(|_| {\n                    let broken_header = Bytes::from_static(b\"\\0\\0\\0\");\n                    ok::<_, Infallible>(\n                        Response::build(StatusCode::OK)\n                            .insert_header((http::header::CONTENT_TYPE, broken_header))\n                            .body(STR),\n                    )\n                }))\n            }))\n            .rustls_0_23(tls_config())\n    })\n    .await;\n\n    let response = srv.sget(\"/\").send().await.unwrap();\n    assert_eq!(response.status(), http::StatusCode::INTERNAL_SERVER_ERROR);\n\n    // read response\n    let bytes = srv.load_body(response).await.unwrap();\n    assert_eq!(\n        bytes,\n        Bytes::from_static(b\"error processing HTTP: failed to parse header value\")\n    );\n}\n\n#[derive(Debug, Display, Error)]\n#[display(\"error\")]\nstruct BadRequest;\n\nimpl From<BadRequest> for Response<BoxBody> {\n    fn from(_: BadRequest) -> Self {\n        Response::bad_request().set_body(BoxBody::new(\"error\"))\n    }\n}\n\n#[actix_rt::test]\nasync fn h2_service_error() {\n    let mut srv = test_server(move || {\n        HttpService::build()\n            .h2(|_| err::<Response<BoxBody>, _>(BadRequest))\n            .rustls_0_23(tls_config())\n    })\n    .await;\n\n    let response = srv.sget(\"/\").send().await.unwrap();\n    assert_eq!(response.status(), http::StatusCode::BAD_REQUEST);\n\n    // read response\n    let bytes = srv.load_body(response).await.unwrap();\n    assert_eq!(bytes, Bytes::from_static(b\"error\"));\n}\n\n#[actix_rt::test]\nasync fn h1_service_error() {\n    let mut srv = test_server(move || {\n        HttpService::build()\n            .h1(|_| err::<Response<BoxBody>, _>(BadRequest))\n            .rustls_0_23(tls_config())\n    })\n    .await;\n\n    let response = srv.sget(\"/\").send().await.unwrap();\n    assert_eq!(response.status(), http::StatusCode::BAD_REQUEST);\n\n    // read response\n    let bytes = srv.load_body(response).await.unwrap();\n    assert_eq!(bytes, Bytes::from_static(b\"error\"));\n}\n\nconst H2_ALPN_PROTOCOL: &[u8] = b\"h2\";\nconst HTTP1_1_ALPN_PROTOCOL: &[u8] = b\"http/1.1\";\nconst CUSTOM_ALPN_PROTOCOL: &[u8] = b\"custom\";\n\n#[actix_rt::test]\nasync fn alpn_h1() -> io::Result<()> {\n    let srv = test_server(move || {\n        let mut config = tls_config();\n        config.alpn_protocols.push(CUSTOM_ALPN_PROTOCOL.to_vec());\n        HttpService::build()\n            .h1(|_| ok::<_, Error>(Response::ok()))\n            .rustls_0_23(config)\n    })\n    .await;\n\n    assert_eq!(\n        get_negotiated_alpn_protocol(srv.addr(), CUSTOM_ALPN_PROTOCOL),\n        Some(CUSTOM_ALPN_PROTOCOL.to_vec())\n    );\n\n    let response = srv.sget(\"/\").send().await.unwrap();\n    assert!(response.status().is_success());\n\n    Ok(())\n}\n\n#[actix_rt::test]\nasync fn alpn_h2() -> io::Result<()> {\n    let srv = test_server(move || {\n        let mut config = tls_config();\n        config.alpn_protocols.push(CUSTOM_ALPN_PROTOCOL.to_vec());\n        HttpService::build()\n            .h2(|_| ok::<_, Error>(Response::ok()))\n            .rustls_0_23(config)\n    })\n    .await;\n\n    assert_eq!(\n        get_negotiated_alpn_protocol(srv.addr(), H2_ALPN_PROTOCOL),\n        Some(H2_ALPN_PROTOCOL.to_vec())\n    );\n    assert_eq!(\n        get_negotiated_alpn_protocol(srv.addr(), CUSTOM_ALPN_PROTOCOL),\n        Some(CUSTOM_ALPN_PROTOCOL.to_vec())\n    );\n\n    let response = srv.sget(\"/\").send().await.unwrap();\n    assert!(response.status().is_success());\n\n    Ok(())\n}\n\n#[actix_rt::test]\nasync fn alpn_h2_1() -> io::Result<()> {\n    let srv = test_server(move || {\n        let mut config = tls_config();\n        config.alpn_protocols.push(CUSTOM_ALPN_PROTOCOL.to_vec());\n        HttpService::build()\n            .finish(|_| ok::<_, Error>(Response::ok()))\n            .rustls_0_23(config)\n    })\n    .await;\n\n    assert_eq!(\n        get_negotiated_alpn_protocol(srv.addr(), H2_ALPN_PROTOCOL),\n        Some(H2_ALPN_PROTOCOL.to_vec())\n    );\n    assert_eq!(\n        get_negotiated_alpn_protocol(srv.addr(), HTTP1_1_ALPN_PROTOCOL),\n        Some(HTTP1_1_ALPN_PROTOCOL.to_vec())\n    );\n    assert_eq!(\n        get_negotiated_alpn_protocol(srv.addr(), CUSTOM_ALPN_PROTOCOL),\n        Some(CUSTOM_ALPN_PROTOCOL.to_vec())\n    );\n\n    let response = srv.sget(\"/\").send().await.unwrap();\n    assert!(response.status().is_success());\n\n    Ok(())\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "05844b56fab57a57b6fa899afa2f48b2de59e04e",
    "func": "use crate::runtime::RuntimeError;\nuse crate::{innerlude::SuspendedFuture, runtime::Runtime, CapturedError, Element, ScopeId, Task};\nuse std::future::Future;\nuse std::sync::Arc;\n\n/// Get the current scope id\npub fn current_scope_id() -> Result<ScopeId, RuntimeError> {\n    Runtime::with(|rt| rt.current_scope_id().ok())\n        .ok()\n        .flatten()\n        .ok_or(RuntimeError::new())\n}\n\n#[doc(hidden)]\n/// Check if the virtual dom is currently inside of the body of a component\npub fn vdom_is_rendering() -> bool {\n    Runtime::with(|rt| rt.rendering.get()).unwrap_or_default()\n}\n\n/// Throw a [`CapturedError`] into the current scope. The error will bubble up to the nearest [`crate::prelude::ErrorBoundary()`] or the root of the app.\n///\n/// # Examples\n/// ```rust, no_run\n/// # use dioxus::prelude::*;\n/// fn Component() -> Element {\n///     let request = spawn(async move {\n///         match reqwest::get(\"https://api.example.com\").await {\n///             Ok(_) => unimplemented!(),\n///             // You can explicitly throw an error into a scope with throw_error\n///             Err(err) => ScopeId::APP.throw_error(err)\n///         }\n///     });\n///\n///     unimplemented!()\n/// }\n/// ```\npub fn throw_error(error: impl Into<CapturedError> + 'static) {\n    current_scope_id()\n        .unwrap_or_else(|e| panic!(\"{}\", e))\n        .throw_error(error)\n}\n\n/// Consume context from the current scope\npub fn try_consume_context<T: 'static + Clone>() -> Option<T> {\n    Runtime::with_current_scope(|cx| cx.consume_context::<T>())\n        .ok()\n        .flatten()\n}\n\n/// Consume context from the current scope\npub fn consume_context<T: 'static + Clone>() -> T {\n    Runtime::with_current_scope(|cx| cx.consume_context::<T>())\n        .ok()\n        .flatten()\n        .unwrap_or_else(|| panic!(\"Could not find context {}\", std::any::type_name::<T>()))\n}\n\n/// Consume context from the current scope\npub fn consume_context_from_scope<T: 'static + Clone>(scope_id: ScopeId) -> Option<T> {\n    Runtime::with(|rt| {\n        rt.get_state(scope_id)\n            .and_then(|cx| cx.consume_context::<T>())\n    })\n    .ok()\n    .flatten()\n}\n\n/// Check if the current scope has a context\npub fn has_context<T: 'static + Clone>() -> Option<T> {\n    Runtime::with_current_scope(|cx| cx.has_context::<T>())\n        .ok()\n        .flatten()\n}\n\n/// Provide context to the current scope\npub fn provide_context<T: 'static + Clone>(value: T) -> T {\n    Runtime::with_current_scope(|cx| cx.provide_context(value)).unwrap()\n}\n\n/// Provide a context to the root scope\npub fn provide_root_context<T: 'static + Clone>(value: T) -> T {\n    Runtime::with_current_scope(|cx| cx.provide_root_context(value)).unwrap()\n}\n\n/// Suspended the current component on a specific task and then return None\npub fn suspend(task: Task) -> Element {\n    Err(crate::innerlude::RenderError::Suspended(\n        SuspendedFuture::new(task),\n    ))\n}\n\n/// Start a new future on the same thread as the rest of the VirtualDom.\n///\n/// **You should generally use `spawn` instead of this method unless you specifically need to run a task during suspense**\n///\n/// This future will not contribute to suspense resolving but it will run during suspense.\n///\n/// Because this future runs during suspense, you need to be careful to work with hydration. It is not recommended to do any async IO work in this future, as it can easily cause hydration issues. However, you can use isomorphic tasks to do work that can be consistently replicated on the server and client like logging or responding to state changes.\n///\n/// ```rust, no_run\n/// # use dioxus::prelude::*;\n/// // \u274c Do not do requests in isomorphic tasks. It may resolve at a different time on the server and client, causing hydration issues.\n/// let mut state = use_signal(|| None);\n/// spawn_isomorphic(async move {\n///     state.set(Some(reqwest::get(\"https://api.example.com\").await));\n/// });\n///\n/// // \u2705 You may wait for a signal to change and then log it\n/// let mut state = use_signal(|| 0);\n/// spawn_isomorphic(async move {\n///     loop {\n///         tokio::time::sleep(std::time::Duration::from_secs(1)).await;\n///         println!(\"State is {state}\");\n///     }\n/// });\n/// ```\n///\n#[doc = include_str!(\"../docs/common_spawn_errors.md\")]\npub fn spawn_isomorphic(fut: impl Future<Output = ()> + 'static) -> Task {\n    Runtime::with_current_scope(|cx| cx.spawn_isomorphic(fut)).unwrap()\n}\n\n/// Spawns the future but does not return the [`Task`]. This task will automatically be canceled when the component is dropped.\n///\n/// # Example\n/// ```rust\n/// use dioxus::prelude::*;\n///\n/// fn App() -> Element {\n///     rsx! {\n///         button {\n///             onclick: move |_| {\n///                 spawn(async move {\n///                     tokio::time::sleep(std::time::Duration::from_secs(1)).await;\n///                     println!(\"Hello World\");\n///                 });\n///             },\n///             \"Print hello in one second\"\n///         }\n///     }\n/// }\n/// ```\n///\n#[doc = include_str!(\"../docs/common_spawn_errors.md\")]\npub fn spawn(fut: impl Future<Output = ()> + 'static) -> Task {\n    Runtime::with_current_scope(|cx| cx.spawn(fut)).unwrap()\n}\n\n/// Queue an effect to run after the next render. You generally shouldn't need to interact with this function directly. [use_effect](https://docs.rs/dioxus-hooks/latest/dioxus_hooks/fn.use_effect.html) will call this function for you.\npub fn queue_effect(f: impl FnOnce() + 'static) {\n    Runtime::with_current_scope(|cx| cx.queue_effect(f)).unwrap()\n}\n\n/// Spawn a future that Dioxus won't clean up when this component is unmounted\n///\n/// This is good for tasks that need to be run after the component has been dropped.\n///\n/// **This will run the task in the root scope. Any calls to global methods inside the future (including `context`) will be run in the root scope.**\n///\n/// # Example\n///\n/// ```rust\n/// use dioxus::prelude::*;\n///\n/// // The parent component can create and destroy children dynamically\n/// fn App() -> Element {\n///     let mut count = use_signal(|| 0);\n///\n///     rsx! {\n///         button {\n///             onclick: move |_| count += 1,\n///             \"Increment\"\n///         }\n///         button {\n///             onclick: move |_| count -= 1,\n///             \"Decrement\"\n///         }\n///\n///         for id in 0..10 {\n///             Child { id }\n///         }\n///     }\n/// }\n///\n/// #[component]\n/// fn Child(id: i32) -> Element {\n///     rsx! {\n///         button {\n///             onclick: move |_| {\n///                 // This will spawn a task in the root scope that will run forever\n///                 // It will keep running even if you drop the child component by decreasing the count\n///                 spawn_forever(async move {\n///                     loop {\n///                         tokio::time::sleep(std::time::Duration::from_secs(1)).await;\n///                         println!(\"Running task spawned in child component {id}\");\n///                     }\n///                 });\n///             },\n///             \"Spawn background task\"\n///         }\n///     }\n/// }\n/// ```\n///\n#[doc = include_str!(\"../docs/common_spawn_errors.md\")]\npub fn spawn_forever(fut: impl Future<Output = ()> + 'static) -> Option<Task> {\n    Runtime::with_scope(ScopeId::ROOT, |cx| cx.spawn(fut)).ok()\n}\n\n/// Informs the scheduler that this task is no longer needed and should be removed.\n///\n/// This drops the task immediately.\npub fn remove_future(id: Task) {\n    Runtime::with(|rt| rt.remove_task(id)).expect(\"Runtime to exist\");\n}\n\n/// Store a value between renders. The foundational hook for all other hooks.\n///\n/// Accepts an `initializer` closure, which is run on the first use of the hook (typically the initial render).\n/// `use_hook` will return a clone of the value on every render.\n///\n/// In order to clean up resources you would need to implement the [`Drop`] trait for an inner value stored in a RC or similar (Signals for instance),\n/// as these only drop their inner value once all references have been dropped, which only happens when the component is dropped.\n///\n/// # Example\n///\n/// ```rust, no_run\n/// use dioxus::prelude::*;\n///\n/// // prints a greeting on the initial render\n/// pub fn use_hello_world() {\n///     use_hook(|| println!(\"Hello, world!\"));\n/// }\n/// ```\n///\n/// # Custom Hook Example\n///\n/// ```rust, no_run\n/// use dioxus::prelude::*;\n///\n/// pub struct InnerCustomState(usize);\n///\n/// impl Drop for InnerCustomState {\n///     fn drop(&mut self){\n///         println!(\"Component has been dropped.\");\n///     }\n/// }\n///\n/// #[derive(Clone, Copy)]\n/// pub struct CustomState {\n///     inner: Signal<InnerCustomState>\n/// }\n///\n/// pub fn use_custom_state() -> CustomState {\n///     use_hook(|| CustomState {\n///         inner: Signal::new(InnerCustomState(0))\n///     })\n/// }\n/// ```\n#[track_caller]\npub fn use_hook<State: Clone + 'static>(initializer: impl FnOnce() -> State) -> State {\n    Runtime::with_current_scope(|cx| cx.use_hook(initializer)).unwrap()\n}\n\n/// Get the current render since the inception of this component\n///\n/// This can be used as a helpful diagnostic when debugging hooks/renders, etc\npub fn generation() -> usize {\n    Runtime::with_current_scope(|cx| cx.generation()).unwrap()\n}\n\n/// Get the parent of the current scope if it exists\npub fn parent_scope() -> Option<ScopeId> {\n    Runtime::with_current_scope(|cx| cx.parent_id())\n        .ok()\n        .flatten()\n}\n\n/// Mark the current scope as dirty, causing it to re-render\npub fn needs_update() {\n    let _ = Runtime::with_current_scope(|cx| cx.needs_update());\n}\n\n/// Mark the current scope as dirty, causing it to re-render\npub fn needs_update_any(id: ScopeId) {\n    let _ = Runtime::with_current_scope(|cx| cx.needs_update_any(id));\n}\n\n/// Schedule an update for the current component\n///\n/// Note: Unlike [`needs_update`], the function returned by this method will work outside of the dioxus runtime.\n///\n/// You should prefer [`schedule_update_any`] if you need to update multiple components.\n#[track_caller]\npub fn schedule_update() -> Arc<dyn Fn() + Send + Sync> {\n    Runtime::with_current_scope(|cx| cx.schedule_update()).unwrap_or_else(|e| panic!(\"{}\", e))\n}\n\n/// Schedule an update for any component given its [`ScopeId`].\n///\n/// A component's [`ScopeId`] can be obtained from the [`current_scope_id`] method.\n///\n/// Note: Unlike [`needs_update`], the function returned by this method will work outside of the dioxus runtime.\n#[track_caller]\npub fn schedule_update_any() -> Arc<dyn Fn(ScopeId) + Send + Sync> {\n    Runtime::with_current_scope(|cx| cx.schedule_update_any()).unwrap_or_else(|e| panic!(\"{}\", e))\n}\n\n/// Creates a callback that will be run before the component is removed.\n/// This can be used to clean up side effects from the component\n/// (created with [`use_effect`](dioxus::prelude::use_effect)).\n///\n/// Note:\n/// Effects do not run on the server, but use_drop **DOES**. It runs any time the component is dropped including during SSR rendering on the server. If your clean up logic targets web, the logic has to be gated by a feature, see the below example for details.\n///\n/// Example:\n/// ```rust\n/// use dioxus::prelude::*;\n///\n/// fn app() -> Element {\n///     let mut state = use_signal(|| true);\n///     rsx! {\n///         for _ in 0..100 {\n///             h1 {\n///                 \"spacer\"\n///             }\n///         }\n///         if state() {\n///             child_component {}\n///         }\n///         button {\n///             onclick: move |_| {\n///                 state.toggle()\n///             },\n///             \"Unmount element\"\n///         }\n///     }\n/// }\n///\n/// fn child_component() -> Element {\n///     let mut original_scroll_position = use_signal(|| 0.0);\n///\n///     use_effect(move || {\n///         let window = web_sys::window().unwrap();\n///         let document = window.document().unwrap();\n///         let element = document.get_element_by_id(\"my_element\").unwrap();\n///         element.scroll_into_view();\n///         original_scroll_position.set(window.scroll_y().unwrap());\n///     });\n///\n///     use_drop(move || {\n///         // This only make sense to web and hence the `web!` macro\n///         web! {\n///             /// restore scroll to the top of the page\n///             let window = web_sys::window().unwrap();\n///             window.scroll_with_x_and_y(original_scroll_position(), 0.0);\n///         }\n///     });\n///\n///     rsx! {\n///         div {\n///             id: \"my_element\",\n///             \"hello\"\n///         }\n///     }\n/// }\n/// ```\n#[doc(alias = \"use_on_unmount\")]\npub fn use_drop<D: FnOnce() + 'static>(destroy: D) {\n    struct LifeCycle<D: FnOnce()> {\n        /// Wrap the closure in an option so that we can take it out on drop.\n        ondestroy: Option<D>,\n    }\n\n    /// On drop, we want to run the closure.\n    impl<D: FnOnce()> Drop for LifeCycle<D> {\n        fn drop(&mut self) {\n            if let Some(f) = self.ondestroy.take() {\n                f();\n            }\n        }\n    }\n\n    // We need to impl clone for the lifecycle, but we don't want the drop handler for the closure to be called twice.\n    impl<D: FnOnce()> Clone for LifeCycle<D> {\n        fn clone(&self) -> Self {\n            Self { ondestroy: None }\n        }\n    }\n\n    use_hook(|| LifeCycle {\n        ondestroy: Some(destroy),\n    });\n}\n\n/// A hook that allows you to insert a \"before render\" function.\n///\n/// This function will always be called before dioxus tries to render your component. This should be used for safely handling\n/// early returns\npub fn use_before_render(f: impl FnMut() + 'static) {\n    use_hook(|| before_render(f));\n}\n\n/// Push this function to be run after the next render\n///\n/// This function will always be called before dioxus tries to render your component. This should be used for safely handling\n/// early returns\npub fn use_after_render(f: impl FnMut() + 'static) {\n    use_hook(|| after_render(f));\n}\n\n/// Push a function to be run before the next render\n/// This is a hook and will always run, so you can't unschedule it\n/// Will run for every progression of suspense, though this might change in the future\npub fn before_render(f: impl FnMut() + 'static) {\n    let _ = Runtime::with_current_scope(|cx| cx.push_before_render(f));\n}\n\n/// Push a function to be run after the render is complete, even if it didn't complete successfully\npub fn after_render(f: impl FnMut() + 'static) {\n    let _ = Runtime::with_current_scope(|cx| cx.push_after_render(f));\n}\n\n/// Use a hook with a cleanup function\npub fn use_hook_with_cleanup<T: Clone + 'static>(\n    hook: impl FnOnce() -> T,\n    cleanup: impl FnOnce(T) + 'static,\n) -> T {\n    let value = use_hook(hook);\n    let _value = value.clone();\n    use_drop(move || cleanup(_value));\n    value\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "fe16e7374bc6a9a5c0476f6872efcebc0445e3a9",
    "func": "use std::fmt::Write as _;\nuse std::process;\nuse std::process::Stdio;\nuse std::str::FromStr;\n\nuse crate::config::ModuleConfig;\nuse crate::config::StarshipConfig;\nuse crate::configs::PROMPT_ORDER;\nuse crate::context::Context;\nuse crate::utils;\nuse std::fs::File;\nuse std::io::Write;\nuse toml_edit::DocumentMut;\n\n#[cfg(not(windows))]\nconst STD_EDITOR: &str = \"vi\";\n#[cfg(windows)]\nconst STD_EDITOR: &str = \"notepad.exe\";\n\npub fn update_configuration(context: &Context, name: &str, value: &str) {\n    let mut doc = get_configuration_edit(context);\n\n    match handle_update_configuration(&mut doc, name, value) {\n        Err(e) => {\n            eprintln!(\"{e}\");\n            process::exit(1);\n        }\n        _ => write_configuration(context, &doc),\n    }\n}\n\nfn handle_update_configuration(\n    doc: &mut DocumentMut,\n    name: &str,\n    value: &str,\n) -> Result<(), String> {\n    let mut keys = name.split('.');\n\n    let first_key = keys.next().unwrap_or_default();\n    if first_key.is_empty() {\n        return Err(\"Empty table keys are not supported\".to_owned());\n    }\n\n    let table = doc.as_table_mut();\n    let mut current_item = table.entry(first_key).or_insert_with(toml_edit::table);\n\n    for key in keys {\n        if !current_item.is_table_like() {\n            return Err(\"This command can only index into TOML tables\".to_owned());\n        }\n\n        if key.is_empty() {\n            return Err(\"Empty table keys are not supported\".to_owned());\n        }\n\n        let table = current_item.as_table_like_mut().unwrap();\n\n        if !table.contains_key(key) {\n            table.insert(key, toml_edit::table());\n        }\n\n        current_item = table.get_mut(key).unwrap();\n    }\n\n    let mut new_value = toml_edit::Value::from_str(value)\n        .map_or_else(|_| toml_edit::value(value), toml_edit::Item::Value);\n\n    if let Some(value) = current_item.as_value() {\n        *new_value.as_value_mut().unwrap().decor_mut() = value.decor().clone();\n    }\n\n    *current_item = new_value;\n\n    Ok(())\n}\n\npub fn print_configuration(context: &Context, use_default: bool, paths: &[String]) -> String {\n    let config = if use_default {\n        // Get default config\n        let default_config = crate::configs::FullConfig::default();\n        // Convert back to Value because toml can't serialize FullConfig directly\n        toml::value::Value::try_from(default_config).unwrap()\n    } else {\n        // Get config as toml::Value\n        let user_config = get_configuration(context);\n        // Convert into FullConfig and fill in default values\n        let user_config = crate::configs::FullConfig::load(&user_config);\n        // Convert back to Value because toml can't serialize FullConfig directly\n        toml::value::Value::try_from(user_config).unwrap()\n    };\n\n    println!(\"# Warning: This config does not include keys that have an unset value\\n\");\n\n    // These are only used for format specifiers so don't print them if we aren't showing formats.\n    if paths.is_empty()\n        || paths\n            .iter()\n            .any(|path| path == \"format\" || path == \"right_format\")\n    {\n        println!(\n            \"# $all is shorthand for {}\",\n            PROMPT_ORDER\n                .iter()\n                .fold(String::new(), |mut output, module_name| {\n                    let _ = write!(output, \"${module_name}\");\n                    output\n                })\n        );\n\n        // Unwrapping is fine because config is based on FullConfig\n        let custom_modules = config.get(\"custom\").unwrap().as_table().unwrap();\n        if !use_default && !custom_modules.is_empty() {\n            println!(\n                \"# $custom (excluding any modules already listed in `format`) is shorthand for {}\",\n                custom_modules.keys().fold(String::new(), |mut output, b| {\n                    let _ = write!(output, \"${{custom.{b}}}\");\n                    output\n                })\n            );\n        }\n    }\n\n    let print_config = if paths.is_empty() {\n        config\n    } else {\n        extract_toml_paths(config, paths)\n    };\n\n    let string_config = toml::to_string_pretty(&print_config).unwrap();\n\n    println!(\"{string_config}\");\n    string_config\n}\n\nfn extract_toml_paths(mut config: toml::Value, paths: &[String]) -> toml::Value {\n    // Extract all the requested sections into a new configuration.\n    let mut subset = toml::value::Table::new();\n    let Some(config) = config.as_table_mut() else {\n        // This function doesn't make any sense if the root is not a table.\n        return toml::Value::Table(subset);\n    };\n\n    'paths: for path in paths {\n        let path_segments: Vec<_> = path.split('.').collect();\n        let (&end, parents) = path_segments.split_last().unwrap_or((&\"\", &[]));\n\n        // Locate the parent table to remove the value from.\n        let mut source_cursor = &mut *config;\n        for &segment in parents {\n            source_cursor = if let Some(child) = source_cursor\n                .get_mut(segment)\n                .and_then(toml::Value::as_table_mut)\n            {\n                child\n            } else {\n                // We didn't find a value for this path, so move on to the next path.\n                continue 'paths;\n            }\n        }\n\n        // Extract the value to move.\n        let Some(value) = source_cursor.remove(end) else {\n            // We didn't find a value for this path, so move on to the next path.\n            continue 'paths;\n        };\n\n        // Create a destination for that value.\n        let mut destination_cursor = &mut subset;\n        for &segment in &path_segments[..path_segments.len() - 1] {\n            // Because we initialize `subset` to be a table, and only add additional values that\n            // exist in `config`, it's impossible for the value here to not be a table.\n            destination_cursor = destination_cursor\n                .entry(segment)\n                .or_insert_with(|| toml::Value::Table(toml::value::Table::new()))\n                .as_table_mut()\n                .unwrap();\n        }\n\n        destination_cursor.insert(end.to_owned(), value);\n    }\n\n    toml::Value::Table(subset)\n}\n\npub fn toggle_configuration(context: &Context, name: &str, key: &str) {\n    let mut doc = get_configuration_edit(context);\n\n    match handle_toggle_configuration(&mut doc, name, key) {\n        Err(e) => {\n            eprintln!(\"{e}\");\n            process::exit(1);\n        }\n        _ => write_configuration(context, &doc),\n    }\n}\n\nfn handle_toggle_configuration(doc: &mut DocumentMut, name: &str, key: &str) -> Result<(), String> {\n    if name.is_empty() || key.is_empty() {\n        return Err(\"Empty table keys are not supported\".to_owned());\n    }\n\n    let table = doc.as_table_mut();\n\n    let values = table\n        .get_mut(name)\n        .ok_or_else(|| format!(\"Given module '{name}' not found in config file\"))?\n        .as_table_like_mut()\n        .ok_or_else(|| format!(\"Given config entry '{key}' is not a module\"))?;\n\n    let old_value = values\n        .get(key)\n        .ok_or_else(|| format!(\"Given config key '{key}' must exist in config file\"))?;\n\n    let old = old_value\n        .as_bool()\n        .ok_or_else(|| format!(\"Given config key '{key}' must be in 'boolean' format\"))?;\n\n    let mut new_value = toml_edit::value(!old);\n    // Above code already checks if it is a value (bool)\n    *new_value.as_value_mut().unwrap().decor_mut() = old_value.as_value().unwrap().decor().clone();\n\n    values.insert(key, new_value);\n    Ok(())\n}\n\npub fn get_configuration(context: &Context) -> toml::Table {\n    let starship_config = StarshipConfig::initialize(&context.get_config_path_os());\n\n    starship_config.config.unwrap_or_default()\n}\n\npub fn get_configuration_edit(context: &Context) -> DocumentMut {\n    let config_file_path = context.get_config_path_os();\n    let toml_content = StarshipConfig::read_config_content_as_str(&config_file_path);\n\n    toml_content\n        .unwrap_or_default()\n        .parse::<DocumentMut>()\n        .expect(\"Failed to load starship config\")\n}\n\npub fn write_configuration(context: &Context, doc: &DocumentMut) {\n    let config_path = context.get_config_path_os().unwrap_or_else(|| {\n        eprintln!(\"config path required to write configuration\");\n        process::exit(1);\n    });\n\n    let config_str = doc.to_string();\n\n    File::create(config_path)\n        .and_then(|mut file| file.write_all(config_str.as_ref()))\n        .expect(\"Error writing starship config\");\n}\n\npub fn edit_configuration(\n    context: &Context,\n    editor_override: Option<&str>,\n) -> Result<(), Box<dyn std::error::Error>> {\n    // Argument currently only used for testing, but could be used to specify\n    // an editor override on the command line.\n    let config_path = context.get_config_path_os().unwrap_or_else(|| {\n        eprintln!(\"config path required to edit configuration\");\n        process::exit(1);\n    });\n\n    let editor_cmd = shell_words::split(&get_editor(editor_override))?;\n    let mut command = match utils::create_command(&editor_cmd[0]) {\n        Ok(cmd) => cmd,\n        Err(e) => {\n            eprintln!(\n                \"Unable to find editor {:?}. Are $VISUAL and $EDITOR set correctly?\",\n                editor_cmd[0]\n            );\n            return Err(Box::new(e));\n        }\n    };\n\n    let res = command\n        .stdin(Stdio::inherit())\n        .stdout(Stdio::inherit())\n        .stderr(Stdio::inherit())\n        .args(&editor_cmd[1..])\n        .arg(config_path)\n        .status();\n\n    if let Err(e) = res {\n        eprintln!(\"Unable to launch editor {editor_cmd:?}\");\n        return Err(Box::new(e));\n    }\n\n    Ok(())\n}\n\nfn get_editor(editor_override: Option<&str>) -> String {\n    if let Some(cmd) = editor_override {\n        cmd.to_string()\n    } else {\n        get_editor_internal(std::env::var(\"VISUAL\").ok(), std::env::var(\"EDITOR\").ok())\n    }\n}\n\nfn get_editor_internal(visual: Option<String>, editor: Option<String>) -> String {\n    let editor_name = visual.unwrap_or_default();\n    if !editor_name.is_empty() {\n        return editor_name;\n    }\n    let editor_name = editor.unwrap_or_default();\n    if !editor_name.is_empty() {\n        return editor_name;\n    }\n    STD_EDITOR.into()\n}\n\n#[cfg(test)]\nmod tests {\n    use std::{fs::create_dir, io};\n\n    use tempfile::TempDir;\n    use toml_edit::Item;\n\n    use crate::{\n        context::{Shell, Target},\n        context_env::Env,\n    };\n\n    use super::*;\n\n    // This is every possible permutation, 3\u00b2 = 9.\n    #[test]\n    fn visual_set_editor_set() {\n        let actual = get_editor_internal(Some(\"foo\".into()), Some(\"bar\".into()));\n        assert_eq!(\"foo\", actual);\n    }\n    #[test]\n    fn visual_set_editor_empty() {\n        let actual = get_editor_internal(Some(\"foo\".into()), None);\n        assert_eq!(\"foo\", actual);\n    }\n    #[test]\n    fn visual_set_editor_not_set() {\n        let actual = get_editor_internal(Some(\"foo\".into()), None);\n        assert_eq!(\"foo\", actual);\n    }\n\n    #[test]\n    fn visual_empty_editor_set() {\n        let actual = get_editor_internal(Some(String::new()), Some(\"bar\".into()));\n        assert_eq!(\"bar\", actual);\n    }\n    #[test]\n    fn visual_empty_editor_empty() {\n        let actual = get_editor_internal(Some(String::new()), Some(String::new()));\n        assert_eq!(STD_EDITOR, actual);\n    }\n    #[test]\n    fn visual_empty_editor_not_set() {\n        let actual = get_editor_internal(Some(String::new()), None);\n        assert_eq!(STD_EDITOR, actual);\n    }\n\n    #[test]\n    fn visual_not_set_editor_set() {\n        let actual = get_editor_internal(None, Some(\"bar\".into()));\n        assert_eq!(\"bar\", actual);\n    }\n    #[test]\n    fn visual_not_set_editor_empty() {\n        let actual = get_editor_internal(None, Some(String::new()));\n        assert_eq!(STD_EDITOR, actual);\n    }\n    #[test]\n    fn visual_not_set_editor_not_set() {\n        let actual = get_editor_internal(None, None);\n        assert_eq!(STD_EDITOR, actual);\n    }\n\n    #[test]\n    fn no_panic_when_editor_unparsable() {\n        let outcome = edit_configuration(&Default::default(), Some(\"\\\"vim\"));\n        assert!(outcome.is_err());\n    }\n\n    #[test]\n    fn no_panic_when_editor_not_found() {\n        let outcome = edit_configuration(&Default::default(), Some(\"this_editor_does_not_exist\"));\n        assert!(outcome.is_err());\n    }\n\n    #[test]\n    fn test_extract_toml_paths() {\n        let config = toml::toml! {\n            extract_root = true\n            ignore_root = false\n\n            [extract_section]\n            ok = true\n\n            [extract_section.subsection]\n            ok = true\n\n            [ignore_section]\n            ok = false\n\n            [extract_subsection]\n            ok = false\n\n            [extract_subsection.extracted]\n            ok = true\n\n            [extract_subsection.ignored]\n            ok = false\n        };\n        let expected_config = toml::toml! {\n            extract_root = true\n\n            [extract_section]\n            ok = true\n\n            [extract_section.subsection]\n            ok = true\n\n            [extract_subsection.extracted]\n            ok = true\n        };\n        let actual_config = extract_toml_paths(\n            toml::Value::Table(config),\n            &[\n                \"extract_root\".to_owned(),\n                \"extract_section\".to_owned(),\n                \"extract_subsection.extracted\".to_owned(),\n            ],\n        );\n\n        assert_eq!(toml::Value::Table(expected_config), actual_config);\n    }\n\n    fn create_doc() -> DocumentMut {\n        let config = concat!(\n            \" # comment\\n\",\n            \"  [status] # comment\\n\",\n            \"disabled =    false # comment\\n\",\n            \"# comment\\n\",\n            \"\\n\"\n        );\n\n        config.parse::<DocumentMut>().unwrap()\n    }\n\n    #[test]\n    fn test_toggle_simple() {\n        let mut doc = create_doc();\n\n        assert!(!doc[\"status\"][\"disabled\"].as_bool().unwrap());\n\n        handle_toggle_configuration(&mut doc, \"status\", \"disabled\").unwrap();\n\n        assert!(doc[\"status\"][\"disabled\"].as_bool().unwrap());\n\n        let new_config = concat!(\n            \" # comment\\n\",\n            \"  [status] # comment\\n\",\n            \"disabled =    true # comment\\n\",\n            \"# comment\\n\",\n            \"\\n\"\n        );\n\n        assert_eq!(doc.to_string(), new_config)\n    }\n\n    #[test]\n    fn test_toggle_missing_module() {\n        let mut doc = create_doc();\n        assert!(handle_toggle_configuration(&mut doc, \"missing_module\", \"disabled\").is_err());\n    }\n\n    #[test]\n    fn test_toggle_missing_key() {\n        let mut doc = create_doc();\n        assert!(handle_toggle_configuration(&mut doc, \"status\", \"missing\").is_err());\n    }\n\n    #[test]\n    fn test_toggle_wrong_type() {\n        let mut doc = create_doc();\n        doc[\"status\"][\"disabled\"] = toml_edit::value(\"a\");\n\n        assert!(handle_toggle_configuration(&mut doc, \"status\", \"disabled\").is_err());\n\n        doc[\"format\"] = toml_edit::value(\"$all\");\n\n        assert!(handle_toggle_configuration(&mut doc, \"format\", \"disabled\").is_err());\n    }\n\n    #[test]\n    fn test_toggle_empty() {\n        let mut doc = create_doc();\n\n        doc[\"status\"][\"\"] = toml_edit::value(true);\n        doc[\"\"][\"disabled\"] = toml_edit::value(true);\n\n        assert!(handle_toggle_configuration(&mut doc, \"status\", \"\").is_err());\n        assert!(handle_toggle_configuration(&mut doc, \"\", \"disabled\").is_err());\n    }\n\n    #[test]\n    fn test_update_config_wrong_type() {\n        let mut doc = create_doc();\n\n        assert!(\n            handle_update_configuration(&mut doc, \"status.disabled.not_a_table\", \"true\").is_err()\n        );\n    }\n\n    #[test]\n    fn test_update_config_simple() {\n        let mut doc = create_doc();\n\n        assert!(!doc[\"status\"][\"disabled\"].as_bool().unwrap());\n\n        handle_update_configuration(&mut doc, \"status.disabled\", \"true\").unwrap();\n\n        assert!(doc[\"status\"][\"disabled\"].as_bool().unwrap());\n\n        let new_config = concat!(\n            \" # comment\\n\",\n            \"  [status] # comment\\n\",\n            \"disabled =    true # comment\\n\",\n            \"# comment\\n\",\n            \"\\n\"\n        );\n\n        assert_eq!(doc.to_string(), new_config)\n    }\n\n    #[test]\n    fn test_update_config_parse() {\n        let mut doc = create_doc();\n\n        handle_update_configuration(&mut doc, \"test\", \"true\").unwrap();\n\n        assert!(doc[\"test\"].as_bool().unwrap());\n\n        handle_update_configuration(&mut doc, \"test\", \"0\").unwrap();\n\n        assert_eq!(doc[\"test\"].as_integer().unwrap(), 0);\n\n        handle_update_configuration(&mut doc, \"test\", \"0.0\").unwrap();\n\n        assert!(doc[\"test\"].is_float());\n\n        handle_update_configuration(&mut doc, \"test\", \"a string\").unwrap();\n\n        assert_eq!(doc[\"test\"].as_str().unwrap(), \"a string\");\n\n        handle_update_configuration(&mut doc, \"test\", \"\\\"true\\\"\").unwrap();\n\n        assert_eq!(doc[\"test\"].as_str().unwrap(), \"true\");\n    }\n\n    #[test]\n    fn test_update_config_empty() {\n        let mut doc = create_doc();\n\n        assert!(handle_update_configuration(&mut doc, \"\", \"true\").is_err());\n        assert!(handle_update_configuration(&mut doc, \".....\", \"true\").is_err());\n        assert!(handle_update_configuration(&mut doc, \"a.a.a..a.a\", \"true\").is_err());\n        assert!(handle_update_configuration(&mut doc, \"a.a.a.a.a.\", \"true\").is_err());\n        assert!(handle_update_configuration(&mut doc, \".a.a.a.a.a\", \"true\").is_err());\n    }\n\n    #[test]\n    fn test_update_config_deep() {\n        let mut doc = create_doc();\n\n        handle_update_configuration(&mut doc, \"a.b.c.d.e.f.g.h\", \"true\").unwrap();\n\n        assert!(doc[\"a\"][\"b\"][\"c\"][\"d\"][\"e\"][\"f\"][\"g\"][\"h\"]\n            .as_bool()\n            .unwrap())\n    }\n\n    #[test]\n    fn write_and_get_configuration_test() -> io::Result<()> {\n        let dir = tempfile::tempdir()?;\n        let context = setup_config(&dir, true, StarshipConfigEnvScenario::NotSpecified)?;\n        let mut doc = get_configuration_edit(&context);\n        doc[\"directory\"][\"format\"] = Item::Value(\"myformat\".into());\n        write_configuration(&context, &doc);\n        let doc_reloaded = get_configuration_edit(&context);\n        assert_eq!(\n            \"myformat\",\n            doc_reloaded[\"directory\"][\"format\"].as_str().unwrap()\n        );\n        dir.close()\n    }\n\n    const PRINT_CONFIG_DEFAULT: &str = \"[custom]\";\n    const PRINT_CONFIG_HOME: &str = \"[custom.home]\";\n    const PRINT_CONFIG_ENV: &str = \"[custom.STARSHIP_CONFIG]\";\n\n    #[test]\n    fn print_configuration_scenarios() -> io::Result<()> {\n        run_print_configuration_test(\n            \"~/.config/starship.toml, no STARSHIP_CONFIG uses home\",\n            true,\n            StarshipConfigEnvScenario::NotSpecified,\n            PRINT_CONFIG_HOME,\n        )?;\n        run_print_configuration_test(\n            \"no ~/.config/starship.toml, no STARSHIP_CONFIG uses default\",\n            false,\n            StarshipConfigEnvScenario::NotSpecified,\n            PRINT_CONFIG_DEFAULT,\n        )?;\n        run_print_configuration_test(\n            \"~/.config/starship.toml, STARSHIP_CONFIG nonexisting file uses default\",\n            true,\n            StarshipConfigEnvScenario::NonExistingFile,\n            PRINT_CONFIG_DEFAULT,\n        )?;\n        run_print_configuration_test(\n            \"~/.config/starship.toml, STARSHIP_CONFIG existing file uses STARSHIP_CONFIG file\",\n            true,\n            StarshipConfigEnvScenario::ExistingFile,\n            PRINT_CONFIG_ENV,\n        )?;\n        Ok(())\n    }\n\n    enum StarshipConfigEnvScenario {\n        NotSpecified,\n        NonExistingFile,\n        ExistingFile,\n    }\n\n    fn run_print_configuration_test(\n        message: &str,\n        home_file_exists: bool,\n        starship_config_env_scenario: StarshipConfigEnvScenario,\n        expected_first_line: &str,\n    ) -> io::Result<()> {\n        let dir = tempfile::tempdir()?;\n        let context = setup_config(&dir, home_file_exists, starship_config_env_scenario)?;\n        let config = print_configuration(&context, false, &[\"custom\".to_string()]);\n        let first_line = config.split('\\n').next().unwrap();\n        assert_eq!(expected_first_line, first_line, \"{message}\");\n        dir.close()\n    }\n\n    fn setup_config(\n        dir: &TempDir,\n        home_file_exists: bool,\n        starship_config_env_scenario: StarshipConfigEnvScenario,\n    ) -> io::Result<Context> {\n        let config_path = dir.path().to_path_buf().join(\".config\");\n        create_dir(&config_path)?;\n        let home_starship_toml = config_path.join(\"starship.toml\");\n        let env_toml = dir.path().join(\"env.toml\");\n        if home_file_exists {\n            let mut home_file = File::create(home_starship_toml)?;\n            home_file.write_all(PRINT_CONFIG_HOME.as_bytes())?;\n        }\n\n        let env_starship_config = match starship_config_env_scenario {\n            StarshipConfigEnvScenario::NotSpecified => None,\n            StarshipConfigEnvScenario::NonExistingFile => Some(env_toml),\n            StarshipConfigEnvScenario::ExistingFile => {\n                let mut env_toml_file = File::create(&env_toml)?;\n                env_toml_file.write_all(PRINT_CONFIG_ENV.as_bytes())?;\n                Some(env_toml)\n            }\n        };\n\n        let mut env = Env::default();\n        if let Some(v) = env_starship_config {\n            env.insert(\"STARSHIP_CONFIG\", v.to_string_lossy().to_string());\n        }\n        env.insert(\n            \"HOME\",\n            dir.path().to_path_buf().to_string_lossy().to_string(),\n        );\n\n        Ok(Context::new_with_shell_and_path(\n            Default::default(),\n            Shell::Unknown,\n            Target::Main,\n            Default::default(),\n            Default::default(),\n            env,\n        ))\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "82bf1ac0c4ca827dc1283602e740119065ba90f4",
    "func": "use inherent::inherent;\n\nuse crate::{backend::SchemaBuilder, types::*, SchemaStatementBuilder};\n\n/// Drop a table\n///\n/// # Examples\n///\n/// ```\n/// use sea_query::{tests_cfg::*, *};\n///\n/// let table = Table::drop()\n///     .table(Glyph::Table)\n///     .table(Char::Table)\n///     .to_owned();\n///\n/// assert_eq!(\n///     table.to_string(MysqlQueryBuilder),\n///     r#\"DROP TABLE `glyph`, `character`\"#\n/// );\n/// assert_eq!(\n///     table.to_string(PostgresQueryBuilder),\n///     r#\"DROP TABLE \"glyph\", \"character\"\"#\n/// );\n/// assert_eq!(\n///     table.to_string(SqliteQueryBuilder),\n///     r#\"DROP TABLE \"glyph\", \"character\"\"#\n/// );\n/// ```\n#[derive(Default, Debug, Clone)]\npub struct TableDropStatement {\n    pub(crate) tables: Vec<TableRef>,\n    pub(crate) options: Vec<TableDropOpt>,\n    pub(crate) if_exists: bool,\n}\n\n/// All available table drop options\n#[derive(Debug, Clone)]\npub enum TableDropOpt {\n    Restrict,\n    Cascade,\n}\n\nimpl TableDropStatement {\n    /// Construct drop table statement\n    pub fn new() -> Self {\n        Self::default()\n    }\n\n    /// Set table name\n    pub fn table<T>(&mut self, table: T) -> &mut Self\n    where\n        T: IntoTableRef,\n    {\n        self.tables.push(table.into_table_ref());\n        self\n    }\n\n    /// Drop table if exists\n    pub fn if_exists(&mut self) -> &mut Self {\n        self.if_exists = true;\n        self\n    }\n\n    /// Drop option restrict\n    pub fn restrict(&mut self) -> &mut Self {\n        self.options.push(TableDropOpt::Restrict);\n        self\n    }\n\n    /// Drop option cacade\n    pub fn cascade(&mut self) -> &mut Self {\n        self.options.push(TableDropOpt::Cascade);\n        self\n    }\n\n    pub fn take(&mut self) -> Self {\n        Self {\n            tables: std::mem::take(&mut self.tables),\n            options: std::mem::take(&mut self.options),\n            if_exists: self.if_exists,\n        }\n    }\n}\n\n#[inherent]\nimpl SchemaStatementBuilder for TableDropStatement {\n    pub fn build<T: SchemaBuilder>(&self, schema_builder: T) -> String {\n        let mut sql = String::with_capacity(256);\n        schema_builder.prepare_table_drop_statement(self, &mut sql);\n        sql\n    }\n\n    pub fn build_any(&self, schema_builder: &dyn SchemaBuilder) -> String {\n        let mut sql = String::with_capacity(256);\n        schema_builder.prepare_table_drop_statement(self, &mut sql);\n        sql\n    }\n\n    pub fn to_string<T: SchemaBuilder>(&self, schema_builder: T) -> String;\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "06ff1a1bc1e25d82d79b980c7ae7fb219697d001",
    "func": "use criterion::{black_box, criterion_group, BatchSize, Bencher, BenchmarkId, Criterion};\nuse ratatui::{\n    buffer::Buffer,\n    layout::Rect,\n    widgets::{Paragraph, Widget, Wrap},\n};\n\n/// because the scroll offset is a u16, the maximum number of lines that can be scrolled is 65535.\n/// This is a limitation of the current implementation and may be fixed by changing the type of the\n/// scroll offset to a u32.\nconst MAX_SCROLL_OFFSET: u16 = u16::MAX;\nconst NO_WRAP_WIDTH: u16 = 200;\nconst WRAP_WIDTH: u16 = 100;\n\n/// Benchmark for rendering a paragraph with a given number of lines. The design of this benchmark\n/// allows comparison of the performance of rendering a paragraph with different numbers of lines.\n/// as well as comparing with the various settings on the scroll and wrap features.\nfn paragraph(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"paragraph\");\n    for line_count in [64, 2048, MAX_SCROLL_OFFSET] {\n        let lines = random_lines(line_count);\n        let lines = lines.as_str();\n\n        // benchmark that measures the overhead of creating a paragraph separately from rendering\n        group.bench_with_input(BenchmarkId::new(\"new\", line_count), lines, |b, lines| {\n            b.iter(|| Paragraph::new(black_box(lines)));\n        });\n\n        // render the paragraph with no scroll\n        group.bench_with_input(\n            BenchmarkId::new(\"render\", line_count),\n            &Paragraph::new(lines),\n            |bencher, paragraph| render(bencher, paragraph, NO_WRAP_WIDTH),\n        );\n\n        // scroll the paragraph by half the number of lines and render\n        group.bench_with_input(\n            BenchmarkId::new(\"render_scroll_half\", line_count),\n            &Paragraph::new(lines).scroll((0, line_count / 2)),\n            |bencher, paragraph| render(bencher, paragraph, NO_WRAP_WIDTH),\n        );\n\n        // scroll the paragraph by the full number of lines and render\n        group.bench_with_input(\n            BenchmarkId::new(\"render_scroll_full\", line_count),\n            &Paragraph::new(lines).scroll((0, line_count)),\n            |bencher, paragraph| render(bencher, paragraph, NO_WRAP_WIDTH),\n        );\n\n        // render the paragraph wrapped to 100 characters\n        group.bench_with_input(\n            BenchmarkId::new(\"render_wrap\", line_count),\n            &Paragraph::new(lines).wrap(Wrap { trim: false }),\n            |bencher, paragraph| render(bencher, paragraph, WRAP_WIDTH),\n        );\n\n        // scroll the paragraph by the full number of lines and render wrapped to 100 characters\n        group.bench_with_input(\n            BenchmarkId::new(\"render_wrap_scroll_full\", line_count),\n            &Paragraph::new(lines)\n                .wrap(Wrap { trim: false })\n                .scroll((0, line_count)),\n            |bencher, paragraph| render(bencher, paragraph, WRAP_WIDTH),\n        );\n    }\n    group.finish();\n}\n\n/// render the paragraph into a buffer with the given width\nfn render(bencher: &mut Bencher, paragraph: &Paragraph, width: u16) {\n    let mut buffer = Buffer::empty(Rect::new(0, 0, width, 50));\n    // We use `iter_batched` to clone the value in the setup function.\n    // See https://github.com/ratatui/ratatui/pull/377.\n    bencher.iter_batched(\n        || paragraph.to_owned(),\n        |bench_paragraph| {\n            bench_paragraph.render(buffer.area, &mut buffer);\n        },\n        BatchSize::LargeInput,\n    );\n}\n\n/// Create a string with the given number of lines filled with nonsense words\n///\n/// English language has about 5.1 average characters per word so including the space between words\n/// this should emit around 200 characters per paragraph on average.\nfn random_lines(count: u16) -> String {\n    let count = i64::from(count);\n    let sentence_count = 3;\n    let word_count = 11;\n    fakeit::words::paragraph(count, sentence_count, word_count, \"\\n\".into())\n}\n\ncriterion_group!(benches, paragraph);\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "c5e78e705f70c8ac2fcad3ffbdf4b2a9aa623156",
    "func": "use core::fmt::{Display, Formatter};\n\n/// A trait for getting the ownership of a type.\n///\n/// This trait exists so that [`TypedFunction`] can automatically generate\n/// [`FunctionInfo`] containing the proper [`Ownership`] for its [argument] types.\n///\n/// This trait is automatically implemented when using the `Reflect` [derive macro].\n///\n/// [`TypedFunction`]: crate::func::TypedFunction\n/// [`FunctionInfo`]: crate::func::FunctionInfo\n/// [argument]: crate::func::args::Arg\n/// [derive macro]: derive@crate::Reflect\npub trait GetOwnership {\n    /// Returns the ownership of [`Self`].\n    fn ownership() -> Ownership;\n}\n\n/// The ownership of a type.\n#[derive(Debug, Copy, Clone, PartialEq, Eq)]\npub enum Ownership {\n    /// The type is a reference (i.e. `&T`).\n    Ref,\n    /// The type is a mutable reference (i.e. `&mut T`).\n    Mut,\n    /// The type is owned (i.e. `T`).\n    Owned,\n}\n\nimpl Display for Ownership {\n    fn fmt(&self, f: &mut Formatter<'_>) -> core::fmt::Result {\n        match self {\n            Self::Ref => write!(f, \"reference\"),\n            Self::Mut => write!(f, \"mutable reference\"),\n            Self::Owned => write!(f, \"owned\"),\n        }\n    }\n}\n\n/// Implements the [`GetOwnership`] trait for the given type.\n///\n/// This will implement it for `$ty`, `&$ty`, and `&mut $ty`.\n///\n/// See [`impl_function_traits`] for details on syntax.\n///\n/// [`impl_function_traits`]: crate::func::macros::impl_function_traits\nmacro_rules! impl_get_ownership {\n    (\n        $ty: ty\n        $(;\n            <\n                $($T: ident $(: $T1: tt $(+ $T2: tt)*)?),*\n            >\n        )?\n        $(\n            [\n                $(const $N: ident : $size: ident),*\n            ]\n        )?\n        $(\n            where\n                $($U: ty $(: $U1: tt $(+ $U2: tt)*)?),*\n        )?\n    ) => {\n        impl <\n            $($($T $(: $T1 $(+ $T2)*)?),*)?\n            $(, $(const $N : $size),*)?\n        > $crate::func::args::GetOwnership for $ty\n        $(\n            where\n                $($U $(: $U1 $(+ $U2)*)?),*\n        )?\n        {\n            fn ownership() -> $crate::func::args::Ownership {\n                $crate::func::args::Ownership::Owned\n            }\n        }\n\n        impl <\n            $($($T $(: $T1 $(+ $T2)*)?),*)?\n            $(, $(const $N : $size),*)?\n        > $crate::func::args::GetOwnership for &'_ $ty\n        $(\n            where\n                $($U $(: $U1 $(+ $U2)*)?),*\n        )?\n        {\n            fn ownership() -> $crate::func::args::Ownership {\n                $crate::func::args::Ownership::Ref\n            }\n        }\n\n        impl <\n            $($($T $(: $T1 $(+ $T2)*)?),*)?\n            $(, $(const $N : $size),*)?\n        > $crate::func::args::GetOwnership for &'_ mut $ty\n        $(\n            where\n                $($U $(: $U1 $(+ $U2)*)?),*\n        )?\n        {\n            fn ownership() -> $crate::func::args::Ownership {\n                $crate::func::args::Ownership::Mut\n            }\n        }\n    };\n}\n\npub(crate) use impl_get_ownership;\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "b373b8fd31165cb265717165e4a077652d2c5fab",
    "func": "#![doc = include_str!(\"../README.md\")]\n#![doc(html_logo_url = \"https://avatars.githubusercontent.com/u/79236386\")]\n#![doc(html_favicon_url = \"https://avatars.githubusercontent.com/u/79236386\")]\n\nuse component::ComponentBody;\nuse proc_macro::TokenStream;\nuse quote::ToTokens;\nuse syn::parse_macro_input;\n\nmod component;\nmod props;\nmod utils;\n\nuse dioxus_rsx as rsx;\n\n#[doc = include_str!(\"../docs/props.md\")]\n#[proc_macro_derive(Props, attributes(props))]\npub fn derive_props(input: TokenStream) -> TokenStream {\n    let input = parse_macro_input!(input as syn::DeriveInput);\n    match props::impl_my_derive(&input) {\n        Ok(output) => output.into(),\n        Err(error) => error.to_compile_error().into(),\n    }\n}\n\n#[doc = include_str!(\"../docs/rsx.md\")]\n#[proc_macro]\npub fn rsx(tokens: TokenStream) -> TokenStream {\n    match syn::parse::<rsx::CallBody>(tokens) {\n        Err(err) => err.to_compile_error().into(),\n        Ok(body) => body.into_token_stream().into(),\n    }\n}\n\n#[doc = include_str!(\"../docs/component.md\")]\n#[proc_macro_attribute]\npub fn component(_args: TokenStream, input: TokenStream) -> TokenStream {\n    parse_macro_input!(input as ComponentBody)\n        .into_token_stream()\n        .into()\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "d91c514aa0a5e5f3cb3887718a9f84d64795f38d",
    "func": "//! Tests for task instrumentation.\n//!\n//! These tests ensure that the instrumentation for task spawning and task\n//! lifecycles is correct.\n\nuse std::{mem, time::Duration};\n\nuse tokio::task;\nuse tracing_mock::{expect, span::NewSpan, subscriber};\n\n#[tokio::test]\nasync fn task_spawn_creates_span() {\n    let task_span = expect::span()\n        .named(\"runtime.spawn\")\n        .with_target(\"tokio::task\");\n\n    let (subscriber, handle) = subscriber::mock()\n        .new_span(task_span.clone())\n        .enter(task_span.clone())\n        .exit(task_span.clone())\n        // The task span is entered once more when it gets dropped\n        .enter(task_span.clone())\n        .exit(task_span.clone())\n        .drop_span(task_span)\n        .run_with_handle();\n\n    {\n        let _guard = tracing::subscriber::set_default(subscriber);\n        tokio::spawn(futures::future::ready(()))\n            .await\n            .expect(\"failed to await join handle\");\n    }\n\n    handle.assert_finished();\n}\n\n#[tokio::test]\nasync fn task_spawn_loc_file_recorded() {\n    let task_span = expect::span()\n        .named(\"runtime.spawn\")\n        .with_target(\"tokio::task\")\n        .with_field(expect::field(\"loc.file\").with_value(&file!()));\n\n    let (subscriber, handle) = subscriber::mock().new_span(task_span).run_with_handle();\n\n    {\n        let _guard = tracing::subscriber::set_default(subscriber);\n\n        tokio::spawn(futures::future::ready(()))\n            .await\n            .expect(\"failed to await join handle\");\n    }\n\n    handle.assert_finished();\n}\n\n#[tokio::test]\nasync fn task_builder_name_recorded() {\n    let task_span = expect_task_named(\"test-task\");\n\n    let (subscriber, handle) = subscriber::mock().new_span(task_span).run_with_handle();\n\n    {\n        let _guard = tracing::subscriber::set_default(subscriber);\n        task::Builder::new()\n            .name(\"test-task\")\n            .spawn(futures::future::ready(()))\n            .unwrap()\n            .await\n            .expect(\"failed to await join handle\");\n    }\n\n    handle.assert_finished();\n}\n\n#[tokio::test]\nasync fn task_builder_loc_file_recorded() {\n    let task_span = expect::span()\n        .named(\"runtime.spawn\")\n        .with_target(\"tokio::task\")\n        .with_field(expect::field(\"loc.file\").with_value(&file!()));\n\n    let (subscriber, handle) = subscriber::mock().new_span(task_span).run_with_handle();\n\n    {\n        let _guard = tracing::subscriber::set_default(subscriber);\n\n        task::Builder::new()\n            .spawn(futures::future::ready(()))\n            .unwrap()\n            .await\n            .expect(\"failed to await join handle\");\n    }\n\n    handle.assert_finished();\n}\n\n#[tokio::test]\nasync fn task_spawn_sizes_recorded() {\n    let future = futures::future::ready(());\n    let size = mem::size_of_val(&future) as u64;\n\n    let task_span = expect::span()\n        .named(\"runtime.spawn\")\n        .with_target(\"tokio::task\")\n        // TODO(hds): check that original_size.bytes is NOT recorded when this can be done in\n        // tracing-mock without listing every other field.\n        .with_field(expect::field(\"size.bytes\").with_value(&size));\n\n    let (subscriber, handle) = subscriber::mock().new_span(task_span).run_with_handle();\n\n    {\n        let _guard = tracing::subscriber::set_default(subscriber);\n\n        task::Builder::new()\n            .spawn(future)\n            .unwrap()\n            .await\n            .expect(\"failed to await join handle\");\n    }\n\n    handle.assert_finished();\n}\n\n#[tokio::test]\nasync fn task_big_spawn_sizes_recorded() {\n    let future = {\n        async fn big<const N: usize>() {\n            let mut a = [0_u8; N];\n            for (idx, item) in a.iter_mut().enumerate() {\n                *item = (idx % 256) as u8;\n            }\n            tokio::time::sleep(Duration::from_millis(10)).await;\n            for (idx, item) in a.iter_mut().enumerate() {\n                assert_eq!(*item, (idx % 256) as u8);\n            }\n        }\n\n        // This is larger than the release auto-boxing threshold\n        big::<20_000>()\n    };\n\n    fn boxed_size<T>(_: &T) -> usize {\n        mem::size_of::<Box<T>>()\n    }\n    let size = mem::size_of_val(&future) as u64;\n    let boxed_size = boxed_size(&future);\n\n    let task_span = expect::span()\n        .named(\"runtime.spawn\")\n        .with_target(\"tokio::task\")\n        .with_field(\n            expect::field(\"size.bytes\")\n                .with_value(&boxed_size)\n                .and(expect::field(\"original_size.bytes\").with_value(&size)),\n        );\n\n    let (subscriber, handle) = subscriber::mock().new_span(task_span).run_with_handle();\n\n    {\n        let _guard = tracing::subscriber::set_default(subscriber);\n\n        task::Builder::new()\n            .spawn(future)\n            .unwrap()\n            .await\n            .expect(\"failed to await join handle\");\n    }\n\n    handle.assert_finished();\n}\n\n/// Expect a task with name\n///\n/// This is a convenience function to create the expectation for a new task\n/// with the `task.name` field set to the provided name.\nfn expect_task_named(name: &str) -> NewSpan {\n    expect::span()\n        .named(\"runtime.spawn\")\n        .with_target(\"tokio::task\")\n        .with_field(\n            expect::field(\"task.name\").with_value(&tracing::field::debug(format_args!(\"{}\", name))),\n        )\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "4147a23b23938a43bc83c84e2e67e9eda9387270",
    "func": "pub mod query_root;\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "6f24cf1dda321839cffe5d5212b2e7f0c34095fa",
    "func": "#![allow(dead_code)]\nuse std::{error::Error, io, sync::mpsc, thread, time::Duration};\n\nuse ratatui::{\n    backend::{Backend, TermionBackend},\n    termion::{\n        event::Key,\n        input::{MouseTerminal, TermRead},\n        raw::IntoRawMode,\n        screen::IntoAlternateScreen,\n    },\n    Terminal,\n};\n\nuse crate::{app::App, ui};\n\npub fn run(tick_rate: Duration, enhanced_graphics: bool) -> Result<(), Box<dyn Error>> {\n    // setup terminal\n    let stdout = io::stdout()\n        .into_raw_mode()\n        .unwrap()\n        .into_alternate_screen()\n        .unwrap();\n    let stdout = MouseTerminal::from(stdout);\n    let backend = TermionBackend::new(stdout);\n    let mut terminal = Terminal::new(backend)?;\n\n    // create app and run it\n    let app = App::new(\"Termion demo\", enhanced_graphics);\n    run_app(&mut terminal, app, tick_rate)?;\n\n    Ok(())\n}\n\nfn run_app<B: Backend>(\n    terminal: &mut Terminal<B>,\n    mut app: App,\n    tick_rate: Duration,\n) -> Result<(), Box<dyn Error>> {\n    let events = events(tick_rate);\n    loop {\n        terminal.draw(|frame| ui::draw(frame, &mut app))?;\n\n        match events.recv()? {\n            Event::Input(key) => match key {\n                Key::Up | Key::Char('k') => app.on_up(),\n                Key::Down | Key::Char('j') => app.on_down(),\n                Key::Left | Key::Char('h') => app.on_left(),\n                Key::Right | Key::Char('l') => app.on_right(),\n                Key::Char(c) => app.on_key(c),\n                _ => {}\n            },\n            Event::Tick => app.on_tick(),\n        }\n        if app.should_quit {\n            return Ok(());\n        }\n    }\n}\n\nenum Event {\n    Input(Key),\n    Tick,\n}\n\nfn events(tick_rate: Duration) -> mpsc::Receiver<Event> {\n    let (tx, rx) = mpsc::channel();\n    let keys_tx = tx.clone();\n    thread::spawn(move || {\n        let stdin = io::stdin();\n        for key in stdin.keys().flatten() {\n            if let Err(err) = keys_tx.send(Event::Input(key)) {\n                eprintln!(\"{err}\");\n                return;\n            }\n        }\n    });\n    thread::spawn(move || loop {\n        if let Err(err) = tx.send(Event::Tick) {\n            eprintln!(\"{err}\");\n            break;\n        }\n        thread::sleep(tick_rate);\n    });\n    rx\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "796c22bfe8eb64d9e2cefdb0200ad81f7ea25ad1",
    "func": "// Copyright 2024 Cloudflare, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse ahash::RandomState;\nuse std::hash::Hash;\nuse std::sync::atomic::{AtomicU8, AtomicUsize, Ordering};\n\nstruct Estimator {\n    estimator: Box<[(Box<[AtomicU8]>, RandomState)]>,\n}\n\nimpl Estimator {\n    fn optimal_paras(items: usize) -> (usize, usize) {\n        use std::cmp::max;\n        // derived from https://en.wikipedia.org/wiki/Count%E2%80%93min_sketch\n        // width = ceil(e / \u03b5)\n        // depth = ceil(ln(1 \u2212 \u03b4) / ln(1 / 2))\n        let error_range = 1.0 / (items as f64);\n        let failure_probability = 1.0 / (items as f64);\n        (\n            max((std::f64::consts::E / error_range).ceil() as usize, 16),\n            max((failure_probability.ln() / 0.5f64.ln()).ceil() as usize, 2),\n        )\n    }\n\n    fn optimal(items: usize) -> Self {\n        let (slots, hashes) = Self::optimal_paras(items);\n        Self::new(hashes, slots, RandomState::new)\n    }\n\n    fn compact(items: usize) -> Self {\n        let (slots, hashes) = Self::optimal_paras(items / 100);\n        Self::new(hashes, slots, RandomState::new)\n    }\n\n    #[cfg(test)]\n    fn seeded(items: usize) -> Self {\n        let (slots, hashes) = Self::optimal_paras(items);\n        Self::new(hashes, slots, || RandomState::with_seeds(2, 3, 4, 5))\n    }\n\n    #[cfg(test)]\n    fn seeded_compact(items: usize) -> Self {\n        let (slots, hashes) = Self::optimal_paras(items / 100);\n        Self::new(hashes, slots, || RandomState::with_seeds(2, 3, 4, 5))\n    }\n\n    /// Create a new `Estimator` with the given amount of hashes and columns (slots) using\n    /// the given random source.\n    pub fn new(hashes: usize, slots: usize, random: impl Fn() -> RandomState) -> Self {\n        let mut estimator = Vec::with_capacity(hashes);\n        for _ in 0..hashes {\n            let mut slot = Vec::with_capacity(slots);\n            for _ in 0..slots {\n                slot.push(AtomicU8::new(0));\n            }\n            estimator.push((slot.into_boxed_slice(), random()));\n        }\n\n        Estimator {\n            estimator: estimator.into_boxed_slice(),\n        }\n    }\n\n    pub fn incr<T: Hash>(&self, key: T) -> u8 {\n        let mut min = u8::MAX;\n        for (slot, hasher) in self.estimator.iter() {\n            let hash = hasher.hash_one(&key) as usize;\n            let counter = &slot[hash % slot.len()];\n            let (_current, new) = incr_no_overflow(counter);\n            min = std::cmp::min(min, new);\n        }\n        min\n    }\n\n    /// Get the estimated frequency of `key`.\n    pub fn get<T: Hash>(&self, key: T) -> u8 {\n        let mut min = u8::MAX;\n        for (slot, hasher) in self.estimator.iter() {\n            let hash = hasher.hash_one(&key) as usize;\n            let counter = &slot[hash % slot.len()];\n            let current = counter.load(Ordering::Relaxed);\n            min = std::cmp::min(min, current);\n        }\n        min\n    }\n\n    /// right shift all values inside this `Estimator`.\n    pub fn age(&self, shift: u8) {\n        for (slot, _) in self.estimator.iter() {\n            for counter in slot.iter() {\n                // we don't CAS because the only update between the load and store\n                // is fetch_add(1), which should be fine to miss/ignore\n                let c = counter.load(Ordering::Relaxed);\n                counter.store(c >> shift, Ordering::Relaxed);\n            }\n        }\n    }\n}\n\nfn incr_no_overflow(var: &AtomicU8) -> (u8, u8) {\n    loop {\n        let current = var.load(Ordering::Relaxed);\n        if current == u8::MAX {\n            return (current, current);\n        }\n        let new = if current == u8::MAX - 1 {\n            u8::MAX\n        } else {\n            current + 1\n        };\n        if let Err(new) = var.compare_exchange(current, new, Ordering::Acquire, Ordering::Relaxed) {\n            // someone else beat us to it\n            if new == u8::MAX {\n                // already max\n                return (current, new);\n            } // else, try again\n        } else {\n            return (current, new);\n        }\n    }\n}\n\n// bare-minimum TinyLfu with CM-Sketch, no doorkeeper for now\npub(crate) struct TinyLfu {\n    estimator: Estimator,\n    window_counter: AtomicUsize,\n    window_limit: usize,\n}\n\nimpl TinyLfu {\n    pub fn get<T: Hash>(&self, key: T) -> u8 {\n        self.estimator.get(key)\n    }\n\n    pub fn incr<T: Hash>(&self, key: T) -> u8 {\n        let window_size = self.window_counter.fetch_add(1, Ordering::Relaxed);\n        // When window_size concurrently increases, only one resets the window and age the estimator.\n        // > self.window_limit * 2 is a safety net in case for whatever reason window_size grows\n        // out of control\n        if window_size == self.window_limit || window_size > self.window_limit * 2 {\n            self.window_counter.store(0, Ordering::Relaxed);\n            self.estimator.age(1); // right shift 1 bit\n        }\n        self.estimator.incr(key)\n    }\n\n    // because we use 8-bits counters, window size can be 256 * the cache size\n    pub fn new(cache_size: usize) -> Self {\n        Self {\n            estimator: Estimator::optimal(cache_size),\n            window_counter: Default::default(),\n            // 8x: just a heuristic to balance the memory usage and accuracy\n            window_limit: cache_size * 8,\n        }\n    }\n\n    pub fn new_compact(cache_size: usize) -> Self {\n        Self {\n            estimator: Estimator::compact(cache_size),\n            window_counter: Default::default(),\n            // 8x: just a heuristic to balance the memory usage and accuracy\n            window_limit: cache_size * 8,\n        }\n    }\n\n    #[cfg(test)]\n    pub fn new_seeded(cache_size: usize) -> Self {\n        Self {\n            estimator: Estimator::seeded(cache_size),\n            window_counter: Default::default(),\n            // 8x: just a heuristic to balance the memory usage and accuracy\n            window_limit: cache_size * 8,\n        }\n    }\n\n    #[cfg(test)]\n    pub fn new_compact_seeded(cache_size: usize) -> Self {\n        Self {\n            estimator: Estimator::seeded_compact(cache_size),\n            window_counter: Default::default(),\n            // 8x: just a heuristic to balance the memory usage and accuracy\n            window_limit: cache_size * 8,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_cmk_paras() {\n        let (slots, hashes) = Estimator::optimal_paras(1_000_000);\n        // just smoke check some standard input\n        assert_eq!(slots, 2718282);\n        assert_eq!(hashes, 20);\n    }\n\n    #[test]\n    fn test_tiny_lfu() {\n        let tiny = TinyLfu::new(1);\n        assert_eq!(tiny.get(1), 0);\n        assert_eq!(tiny.incr(1), 1);\n        assert_eq!(tiny.incr(1), 2);\n        assert_eq!(tiny.get(1), 2);\n\n        // Might have hash collisions for the others, need to\n        // get() before can assert on the incr() value.\n        let two = tiny.get(2);\n        assert_eq!(tiny.incr(2), two + 1);\n        assert_eq!(tiny.incr(2), two + 2);\n        assert_eq!(tiny.get(2), two + 2);\n\n        let three = tiny.get(3);\n        assert_eq!(tiny.incr(3), three + 1);\n        assert_eq!(tiny.incr(3), three + 2);\n        assert_eq!(tiny.incr(3), three + 3);\n        assert_eq!(tiny.incr(3), three + 4);\n\n        // 8 incr(), now resets on next incr\n        // can only assert they are greater than or equal\n        // to the incr() we do per key.\n\n        assert!(tiny.incr(3) >= 3); // had 4, reset to 2, added another.\n        assert!(tiny.incr(1) >= 2); // had 2, reset to 1, added another.\n        assert!(tiny.incr(2) >= 2); // had 2, reset to 1, added another.\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "a61e03213d084804cbf328b49afd91fec87fb8cc",
    "func": "use std::ffi::OsStr;\nuse std::io::{self, Result};\nuse std::iter::once;\nuse std::os::windows::ffi::OsStrExt;\nuse std::sync::mpsc::TryRecvError;\nuse std::sync::Arc;\n\nuse crate::event::{OnResize, WindowSize};\nuse crate::tty::windows::child::ChildExitWatcher;\nuse crate::tty::{ChildEvent, EventedPty, EventedReadWrite, Options, Shell};\n\nmod blocking;\nmod child;\nmod conpty;\n\nuse blocking::{UnblockedReader, UnblockedWriter};\nuse conpty::Conpty as Backend;\nuse miow::pipe::{AnonRead, AnonWrite};\nuse polling::{Event, Poller};\n\npub const PTY_CHILD_EVENT_TOKEN: usize = 1;\npub const PTY_READ_WRITE_TOKEN: usize = 2;\n\ntype ReadPipe = UnblockedReader<AnonRead>;\ntype WritePipe = UnblockedWriter<AnonWrite>;\n\npub struct Pty {\n    // XXX: Backend is required to be the first field, to ensure correct drop order. Dropping\n    // `conout` before `backend` will cause a deadlock (with Conpty).\n    backend: Backend,\n    conout: ReadPipe,\n    conin: WritePipe,\n    child_watcher: ChildExitWatcher,\n}\n\npub fn new(config: &Options, window_size: WindowSize, _window_id: u64) -> Result<Pty> {\n    conpty::new(config, window_size)\n}\n\nimpl Pty {\n    fn new(\n        backend: impl Into<Backend>,\n        conout: impl Into<ReadPipe>,\n        conin: impl Into<WritePipe>,\n        child_watcher: ChildExitWatcher,\n    ) -> Self {\n        Self { backend: backend.into(), conout: conout.into(), conin: conin.into(), child_watcher }\n    }\n\n    pub fn child_watcher(&self) -> &ChildExitWatcher {\n        &self.child_watcher\n    }\n}\n\nfn with_key(mut event: Event, key: usize) -> Event {\n    event.key = key;\n    event\n}\n\nimpl EventedReadWrite for Pty {\n    type Reader = ReadPipe;\n    type Writer = WritePipe;\n\n    #[inline]\n    unsafe fn register(\n        &mut self,\n        poll: &Arc<Poller>,\n        interest: polling::Event,\n        poll_opts: polling::PollMode,\n    ) -> io::Result<()> {\n        self.conin.register(poll, with_key(interest, PTY_READ_WRITE_TOKEN), poll_opts);\n        self.conout.register(poll, with_key(interest, PTY_READ_WRITE_TOKEN), poll_opts);\n        self.child_watcher.register(poll, with_key(interest, PTY_CHILD_EVENT_TOKEN));\n\n        Ok(())\n    }\n\n    #[inline]\n    fn reregister(\n        &mut self,\n        poll: &Arc<Poller>,\n        interest: polling::Event,\n        poll_opts: polling::PollMode,\n    ) -> io::Result<()> {\n        self.conin.register(poll, with_key(interest, PTY_READ_WRITE_TOKEN), poll_opts);\n        self.conout.register(poll, with_key(interest, PTY_READ_WRITE_TOKEN), poll_opts);\n        self.child_watcher.register(poll, with_key(interest, PTY_CHILD_EVENT_TOKEN));\n\n        Ok(())\n    }\n\n    #[inline]\n    fn deregister(&mut self, _poll: &Arc<Poller>) -> io::Result<()> {\n        self.conin.deregister();\n        self.conout.deregister();\n        self.child_watcher.deregister();\n\n        Ok(())\n    }\n\n    #[inline]\n    fn reader(&mut self) -> &mut Self::Reader {\n        &mut self.conout\n    }\n\n    #[inline]\n    fn writer(&mut self) -> &mut Self::Writer {\n        &mut self.conin\n    }\n}\n\nimpl EventedPty for Pty {\n    fn next_child_event(&mut self) -> Option<ChildEvent> {\n        match self.child_watcher.event_rx().try_recv() {\n            Ok(ev) => Some(ev),\n            Err(TryRecvError::Empty) => None,\n            Err(TryRecvError::Disconnected) => Some(ChildEvent::Exited(None)),\n        }\n    }\n}\n\nimpl OnResize for Pty {\n    fn on_resize(&mut self, window_size: WindowSize) {\n        self.backend.on_resize(window_size)\n    }\n}\n\nfn cmdline(config: &Options) -> String {\n    let default_shell = Shell::new(\"powershell\".to_owned(), Vec::new());\n    let shell = config.shell.as_ref().unwrap_or(&default_shell);\n\n    once(shell.program.as_str())\n        .chain(shell.args.iter().map(|s| s.as_str()))\n        .collect::<Vec<_>>()\n        .join(\" \")\n}\n\n/// Converts the string slice into a Windows-standard representation for \"W\"-\n/// suffixed function variants, which accept UTF-16 encoded string values.\npub fn win32_string<S: AsRef<OsStr> + ?Sized>(value: &S) -> Vec<u16> {\n    OsStr::new(value).encode_wide().chain(once(0)).collect()\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "14634fa59fb2823fa607e6b17bf78b609b8edabd",
    "func": "#[macro_use] extern crate rocket;\n\nuse rocket::form::Form;\nuse rocket::http::ContentType;\nuse rocket::local::blocking::Client;\n\n#[derive(FromForm)]\nstruct Data<'r> {\n    foo: &'r str,\n    bar: &'r str,\n    baz: &'r str,\n}\n\n#[rocket::post(\"/\", data = \"<form>\")]\nfn form(form: Form<Data<'_>>) -> String {\n    form.foo.to_string() + form.bar + form.baz\n}\n\n#[test]\nfn test_multipart_raw_strings_from_files() {\n    let body = &[\n        \"--X-BOUNDARY\",\n        r#\"Content-Disposition: form-data; name=\"foo\"; filename=\"foo.txt\"\"#,\n        \"Content-Type: text/plain\",\n        \"\",\n        \"hi\",\n        \"--X-BOUNDARY\",\n        r#\"Content-Disposition: form-data; name=\"bar\"; filename=\"bar.txt\"\"#,\n        \"Content-Type: text/plain\",\n        \"\",\n        \"hey\",\n        \"--X-BOUNDARY\",\n        r#\"Content-Disposition: form-data; name=\"baz\"; filename=\"baz.txt\"\"#,\n        \"Content-Type: text/plain\",\n        \"\",\n        \"bye\",\n        \"--X-BOUNDARY--\",\n        \"\",\n    ].join(\"\\r\\n\");\n\n    let client = Client::debug_with(rocket::routes![form]).unwrap();\n    let response = client.post(\"/\")\n        .header(\"multipart/form-data; boundary=X-BOUNDARY\".parse::<ContentType>().unwrap())\n        .body(body)\n        .dispatch();\n\n    assert_eq!(response.into_string().unwrap(), \"hiheybye\");\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "f8c0f9b22e266bb6e3507d05e4dff1d884a260f9",
    "func": "//! State like [`ListState`], [`TableState`] and [`ScrollbarState`] can be serialized and\n//! deserialized through serde. This allows saving your entire state to disk when the user exits the\n//! the app, and restore it again upon re-opening the app.\n//! This way, they get right back to where they were, without having to re-seek to their previous\n//! position, if that's applicable for the app at hand.\n//!\n//! **Note**: For this pattern to work easily, you need to have some toplevel struct which stores\n//! _only_ state and not any draw commands.\n//!\n//! **Note**: For many applications, it might be beneficial to instead keep your own state and\n//! instead construct the state for widgets on the fly instead, if that allows you to express you\n//! the semantic meaning of your state better or only fetch part of a dataset.\n\n// not too happy about the redundancy in these tests,\n// but if that helps readability then it's ok i guess /shrug\n\nuse ratatui::{\n    backend::TestBackend,\n    layout::{Constraint, Direction, Layout},\n    text::Line,\n    widgets::{\n        Block, Borders, List, ListState, Row, Scrollbar, ScrollbarOrientation, ScrollbarState,\n        Table, TableState,\n    },\n    Terminal,\n};\n\n#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]\nstruct AppState {\n    list: ListState,\n    table: TableState,\n    scrollbar: ScrollbarState,\n}\n\nimpl Default for AppState {\n    fn default() -> Self {\n        Self {\n            list: ListState::default(),\n            table: TableState::default(),\n            scrollbar: ScrollbarState::new(10),\n        }\n    }\n}\nimpl AppState {\n    fn select(&mut self, index: usize) {\n        self.list.select(Some(index));\n        self.table.select_cell(Some((index, index)));\n        self.scrollbar = self.scrollbar.position(index);\n    }\n}\n\n/// Renders the list to a `TestBackend` and asserts that the result matches the expected buffer.\n#[track_caller]\nfn assert_buffer<'line, Lines>(state: &mut AppState, expected: Lines)\nwhere\n    Lines: IntoIterator,\n    Lines::Item: Into<Line<'line>>,\n{\n    let backend = TestBackend::new(21, 5);\n    let mut terminal = Terminal::new(backend).unwrap();\n    terminal\n        .draw(|f| {\n            let items = [\n                \"awa\", \"banana\", \"Cats!!\", \"d20\", \"Echo\", \"Foxtrot\", \"Golf\", \"Hotel\", \"IwI\",\n                \"Juliett\",\n            ];\n\n            let layout = Layout::default()\n                .direction(Direction::Horizontal)\n                .constraints([\n                    Constraint::Length(10),\n                    Constraint::Length(10),\n                    Constraint::Length(1),\n                ])\n                .split(f.area());\n            let list = List::new(items)\n                .highlight_symbol(\">>\")\n                .block(Block::new().borders(Borders::RIGHT));\n            f.render_stateful_widget(list, layout[0], &mut state.list);\n\n            let table = Table::new(\n                items.into_iter().map(|i| Row::new(vec![i])),\n                [Constraint::Length(10); 1],\n            )\n            .highlight_symbol(\">>\");\n            f.render_stateful_widget(table, layout[1], &mut state.table);\n\n            let scrollbar = Scrollbar::new(ScrollbarOrientation::VerticalRight);\n            f.render_stateful_widget(scrollbar, layout[2], &mut state.scrollbar);\n        })\n        .unwrap();\n    terminal.backend().assert_buffer_lines(expected);\n}\n\nconst DEFAULT_STATE_BUFFER: [&str; 5] = [\n    \"awa      \u2502awa       \u25b2\",\n    \"banana   \u2502banana    \u2588\",\n    \"Cats!!   \u2502Cats!!    \u2551\",\n    \"d20      \u2502d20       \u2551\",\n    \"Echo     \u2502Echo      \u25bc\",\n];\n\nconst DEFAULT_STATE_REPR: &str = r#\"{\n  \"list\": {\n    \"offset\": 0,\n    \"selected\": null\n  },\n  \"table\": {\n    \"offset\": 0,\n    \"selected\": null,\n    \"selected_column\": null\n  },\n  \"scrollbar\": {\n    \"content_length\": 10,\n    \"position\": 0,\n    \"viewport_content_length\": 0\n  }\n}\"#;\n\n#[test]\nfn default_state_serialize() {\n    let mut state = AppState::default();\n    assert_buffer(&mut state, DEFAULT_STATE_BUFFER);\n    let state = serde_json::to_string_pretty(&state).unwrap();\n    assert_eq!(state, DEFAULT_STATE_REPR);\n}\n\n#[test]\nfn default_state_deserialize() {\n    let mut state: AppState = serde_json::from_str(DEFAULT_STATE_REPR).unwrap();\n    assert_buffer(&mut state, DEFAULT_STATE_BUFFER);\n}\n\nconst SELECTED_STATE_BUFFER: [&str; 5] = [\n    \"  awa    \u2502  awa     \u25b2\",\n    \">>banana \u2502>>banana  \u2588\",\n    \"  Cats!! \u2502  Cats!!  \u2551\",\n    \"  d20    \u2502  d20     \u2551\",\n    \"  Echo   \u2502  Echo    \u25bc\",\n];\nconst SELECTED_STATE_REPR: &str = r#\"{\n  \"list\": {\n    \"offset\": 0,\n    \"selected\": 1\n  },\n  \"table\": {\n    \"offset\": 0,\n    \"selected\": 1,\n    \"selected_column\": 0\n  },\n  \"scrollbar\": {\n    \"content_length\": 10,\n    \"position\": 1,\n    \"viewport_content_length\": 0\n  }\n}\"#;\n\n#[test]\nfn selected_state_serialize() {\n    let mut state = AppState::default();\n    state.select(1);\n    assert_buffer(&mut state, SELECTED_STATE_BUFFER);\n    let state = serde_json::to_string_pretty(&state).unwrap();\n    assert_eq!(state, SELECTED_STATE_REPR);\n}\n\n#[test]\nfn selected_state_deserialize() {\n    let mut state: AppState = serde_json::from_str(SELECTED_STATE_REPR).unwrap();\n    assert_buffer(&mut state, SELECTED_STATE_BUFFER);\n}\n\nconst SCROLLED_STATE_BUFFER: [&str; 5] = [\n    \"  Echo   \u2502  Echo    \u25b2\",\n    \"  Foxtrot\u2502  Foxtrot \u2551\",\n    \"  Golf   \u2502  Golf    \u2551\",\n    \"  Hotel  \u2502  Hotel   \u2588\",\n    \">>IwI    \u2502>>IwI     \u25bc\",\n];\n\nconst SCROLLED_STATE_REPR: &str = r#\"{\n  \"list\": {\n    \"offset\": 4,\n    \"selected\": 8\n  },\n  \"table\": {\n    \"offset\": 4,\n    \"selected\": 8,\n    \"selected_column\": 0\n  },\n  \"scrollbar\": {\n    \"content_length\": 10,\n    \"position\": 8,\n    \"viewport_content_length\": 0\n  }\n}\"#;\n\n#[test]\nfn scrolled_state_serialize() {\n    let mut state = AppState::default();\n    state.select(8);\n    assert_buffer(&mut state, SCROLLED_STATE_BUFFER);\n    let state = serde_json::to_string_pretty(&state).unwrap();\n    assert_eq!(state, SCROLLED_STATE_REPR);\n}\n\n#[test]\nfn scrolled_state_deserialize() {\n    let mut state: AppState = serde_json::from_str(SCROLLED_STATE_REPR).unwrap();\n    assert_buffer(&mut state, SCROLLED_STATE_BUFFER);\n}\n\n// For backwards compatibility these fields should be enough to deserialize the state.\nconst OLD_TABLE_DESERIALIZE: &str = r#\"{\n    \"offset\": 0,\n    \"selected\": 1\n}\"#;\n\nconst NEW_TABLE_DESERIALIZE: &str = r#\"{\n    \"offset\": 0,\n    \"selected\": 1,\n    \"selected_column\": null\n}\"#;\n\n// This test is to check for backwards compatibility with the old states.\n#[test]\nfn table_state_backwards_compatibility() {\n    let old_state: TableState = serde_json::from_str(OLD_TABLE_DESERIALIZE).unwrap();\n    let new_state: TableState = serde_json::from_str(NEW_TABLE_DESERIALIZE).unwrap();\n    assert_eq!(old_state, new_state);\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "f7f1eeb4e7102256783d750143019e7a4050807c",
    "func": "// Copyright 2019-2024 Tauri Programme within The Commons Conservancy\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n\n// taken from https://github.com/rust-lang/cargo/blob/b0c9586f4cbf426914df47c65de38ea323772c74/src/cargo/util/flock.rs\n#![allow(dead_code)]\n\nuse std::fs::{create_dir_all, File, OpenOptions};\nuse std::io;\nuse std::io::{Read, Seek, SeekFrom, Write};\nuse std::path::{Path, PathBuf};\n\nuse crate::Result;\nuse anyhow::Context as _;\nuse sys::*;\n\n#[derive(Debug)]\npub struct FileLock {\n  f: Option<File>,\n  path: PathBuf,\n  state: State,\n}\n\n#[derive(PartialEq, Debug)]\nenum State {\n  Unlocked,\n  Shared,\n  Exclusive,\n}\n\nimpl FileLock {\n  /// Returns the underlying file handle of this lock.\n  pub fn file(&self) -> &File {\n    self.f.as_ref().unwrap()\n  }\n\n  /// Returns the underlying path that this lock points to.\n  ///\n  /// Note that special care must be taken to ensure that the path is not\n  /// referenced outside the lifetime of this lock.\n  pub fn path(&self) -> &Path {\n    assert_ne!(self.state, State::Unlocked);\n    &self.path\n  }\n\n  /// Returns the parent path containing this file\n  pub fn parent(&self) -> &Path {\n    assert_ne!(self.state, State::Unlocked);\n    self.path.parent().unwrap()\n  }\n}\n\nimpl Read for FileLock {\n  fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n    self.file().read(buf)\n  }\n}\n\nimpl Seek for FileLock {\n  fn seek(&mut self, to: SeekFrom) -> io::Result<u64> {\n    self.file().seek(to)\n  }\n}\n\nimpl Write for FileLock {\n  fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n    self.file().write(buf)\n  }\n\n  fn flush(&mut self) -> io::Result<()> {\n    self.file().flush()\n  }\n}\n\nimpl Drop for FileLock {\n  fn drop(&mut self) {\n    if self.state != State::Unlocked {\n      if let Some(f) = self.f.take() {\n        let _ = unlock(&f);\n      }\n    }\n  }\n}\n\n/// Opens exclusive access to a file, returning the locked version of a\n/// file.\n///\n/// This function will create a file at `path` if it doesn't already exist\n/// (including intermediate directories), and then it will acquire an\n/// exclusive lock on `path`. If the process must block waiting for the\n/// lock, the `msg` is logged.\n///\n/// The returned file can be accessed to look at the path and also has\n/// read/write access to the underlying file.\npub fn open_rw<P>(path: P, msg: &str) -> Result<FileLock>\nwhere\n  P: AsRef<Path>,\n{\n  open(\n    path.as_ref(),\n    OpenOptions::new().read(true).write(true).create(true),\n    State::Exclusive,\n    msg,\n  )\n}\n\n/// Opens shared access to a file, returning the locked version of a file.\n///\n/// This function will fail if `path` doesn't already exist, but if it does\n/// then it will acquire a shared lock on `path`. If the process must block\n/// waiting for the lock, the `msg` is logged.\n///\n/// The returned file can be accessed to look at the path and also has read\n/// access to the underlying file. Any writes to the file will return an\n/// error.\npub fn open_ro<P>(path: P, msg: &str) -> Result<FileLock>\nwhere\n  P: AsRef<Path>,\n{\n  open(\n    path.as_ref(),\n    OpenOptions::new().read(true),\n    State::Shared,\n    msg,\n  )\n}\n\nfn open(path: &Path, opts: &OpenOptions, state: State, msg: &str) -> Result<FileLock> {\n  // If we want an exclusive lock then if we fail because of NotFound it's\n  // likely because an intermediate directory didn't exist, so try to\n  // create the directory and then continue.\n  let f = opts\n    .open(path)\n    .or_else(|e| {\n      if e.kind() == io::ErrorKind::NotFound && state == State::Exclusive {\n        create_dir_all(path.parent().unwrap())?;\n        Ok(opts.open(path)?)\n      } else {\n        Err(anyhow::Error::from(e))\n      }\n    })\n    .with_context(|| format!(\"failed to open: {}\", path.display()))?;\n  match state {\n    State::Exclusive => {\n      acquire(msg, path, &|| try_lock_exclusive(&f), &|| {\n        lock_exclusive(&f)\n      })?;\n    }\n    State::Shared => {\n      acquire(msg, path, &|| try_lock_shared(&f), &|| lock_shared(&f))?;\n    }\n    State::Unlocked => {}\n  }\n  Ok(FileLock {\n    f: Some(f),\n    path: path.to_path_buf(),\n    state,\n  })\n}\n\n/// Acquires a lock on a file in a \"nice\" manner.\n///\n/// Almost all long-running blocking actions in Cargo have a status message\n/// associated with them as we're not sure how long they'll take. Whenever a\n/// conflicted file lock happens, this is the case (we're not sure when the lock\n/// will be released).\n///\n/// This function will acquire the lock on a `path`, printing out a nice message\n/// to the console if we have to wait for it. It will first attempt to use `try`\n/// to acquire a lock on the crate, and in the case of contention it will emit a\n/// status message based on `msg` to `config`'s shell, and then use `block` to\n/// block waiting to acquire a lock.\n///\n/// Returns an error if the lock could not be acquired or if any error other\n/// than a contention error happens.\nfn acquire(\n  msg: &str,\n  path: &Path,\n  lock_try: &dyn Fn() -> io::Result<()>,\n  lock_block: &dyn Fn() -> io::Result<()>,\n) -> Result<()> {\n  // File locking on Unix is currently implemented via `flock`, which is known\n  // to be broken on NFS. We could in theory just ignore errors that happen on\n  // NFS, but apparently the failure mode [1] for `flock` on NFS is **blocking\n  // forever**, even if the \"non-blocking\" flag is passed!\n  //\n  // As a result, we just skip all file locks entirely on NFS mounts. That\n  // should avoid calling any `flock` functions at all, and it wouldn't work\n  // there anyway.\n  //\n  // [1]: https://github.com/rust-lang/cargo/issues/2615\n  if is_on_nfs_mount(path) {\n    return Ok(());\n  }\n\n  match lock_try() {\n    Ok(()) => return Ok(()),\n\n    // In addition to ignoring NFS which is commonly not working we also\n    // just ignore locking on filesystems that look like they don't\n    // implement file locking.\n    Err(e) if error_unsupported(&e) => return Ok(()),\n\n    Err(e) => {\n      if !error_contended(&e) {\n        let e = anyhow::Error::from(e);\n        let cx = format!(\"failed to lock file: {}\", path.display());\n        return Err(e.context(cx));\n      }\n    }\n  }\n  let msg = format!(\"waiting for file lock on {msg}\");\n  log::info!(action = \"Blocking\"; \"{}\", &msg);\n\n  lock_block().with_context(|| format!(\"failed to lock file: {}\", path.display()))?;\n  return Ok(());\n\n  #[cfg(all(target_os = \"linux\", not(target_env = \"musl\")))]\n  fn is_on_nfs_mount(path: &Path) -> bool {\n    use std::ffi::CString;\n    use std::mem;\n    use std::os::unix::prelude::*;\n\n    let path = match CString::new(path.as_os_str().as_bytes()) {\n      Ok(path) => path,\n      Err(_) => return false,\n    };\n\n    unsafe {\n      let mut buf: libc::statfs = mem::zeroed();\n      let r = libc::statfs(path.as_ptr(), &mut buf);\n\n      r == 0 && buf.f_type as u32 == libc::NFS_SUPER_MAGIC as u32\n    }\n  }\n\n  #[cfg(any(not(target_os = \"linux\"), target_env = \"musl\"))]\n  fn is_on_nfs_mount(_path: &Path) -> bool {\n    false\n  }\n}\n\n#[cfg(unix)]\nmod sys {\n  use std::fs::File;\n  use std::io::{Error, Result};\n  use std::os::unix::io::AsRawFd;\n\n  pub(super) fn lock_shared(file: &File) -> Result<()> {\n    flock(file, libc::LOCK_SH)\n  }\n\n  pub(super) fn lock_exclusive(file: &File) -> Result<()> {\n    flock(file, libc::LOCK_EX)\n  }\n\n  pub(super) fn try_lock_shared(file: &File) -> Result<()> {\n    flock(file, libc::LOCK_SH | libc::LOCK_NB)\n  }\n\n  pub(super) fn try_lock_exclusive(file: &File) -> Result<()> {\n    flock(file, libc::LOCK_EX | libc::LOCK_NB)\n  }\n\n  pub(super) fn unlock(file: &File) -> Result<()> {\n    flock(file, libc::LOCK_UN)\n  }\n\n  pub(super) fn error_contended(err: &Error) -> bool {\n    err.raw_os_error().map_or(false, |x| x == libc::EWOULDBLOCK)\n  }\n\n  pub(super) fn error_unsupported(err: &Error) -> bool {\n    match err.raw_os_error() {\n      // Unfortunately, depending on the target, these may or may not be the same.\n      // For targets in which they are the same, the duplicate pattern causes a warning.\n      #[allow(unreachable_patterns)]\n      Some(libc::ENOTSUP | libc::EOPNOTSUPP) => true,\n      Some(libc::ENOSYS) => true,\n      _ => false,\n    }\n  }\n\n  #[cfg(not(target_os = \"solaris\"))]\n  fn flock(file: &File, flag: libc::c_int) -> Result<()> {\n    let ret = unsafe { libc::flock(file.as_raw_fd(), flag) };\n    if ret < 0 {\n      Err(Error::last_os_error())\n    } else {\n      Ok(())\n    }\n  }\n\n  #[cfg(target_os = \"solaris\")]\n  fn flock(file: &File, flag: libc::c_int) -> Result<()> {\n    // Solaris lacks flock(), so simply succeed with a no-op\n    Ok(())\n  }\n}\n\n#[cfg(windows)]\nmod sys {\n  use std::fs::File;\n  use std::io::{Error, Result};\n  use std::mem;\n  use std::os::windows::io::AsRawHandle;\n\n  use windows_sys::Win32::Foundation::{ERROR_INVALID_FUNCTION, ERROR_LOCK_VIOLATION, HANDLE};\n  use windows_sys::Win32::Storage::FileSystem::{\n    LockFileEx, UnlockFile, LOCKFILE_EXCLUSIVE_LOCK, LOCKFILE_FAIL_IMMEDIATELY, LOCK_FILE_FLAGS,\n  };\n\n  pub(super) fn lock_shared(file: &File) -> Result<()> {\n    lock_file(file, 0)\n  }\n\n  pub(super) fn lock_exclusive(file: &File) -> Result<()> {\n    lock_file(file, LOCKFILE_EXCLUSIVE_LOCK)\n  }\n\n  pub(super) fn try_lock_shared(file: &File) -> Result<()> {\n    lock_file(file, LOCKFILE_FAIL_IMMEDIATELY)\n  }\n\n  pub(super) fn try_lock_exclusive(file: &File) -> Result<()> {\n    lock_file(file, LOCKFILE_EXCLUSIVE_LOCK | LOCKFILE_FAIL_IMMEDIATELY)\n  }\n\n  pub(super) fn error_contended(err: &Error) -> bool {\n    err\n      .raw_os_error()\n      .map_or(false, |x| x == ERROR_LOCK_VIOLATION as i32)\n  }\n\n  pub(super) fn error_unsupported(err: &Error) -> bool {\n    err\n      .raw_os_error()\n      .map_or(false, |x| x == ERROR_INVALID_FUNCTION as i32)\n  }\n\n  pub(super) fn unlock(file: &File) -> Result<()> {\n    let ret = unsafe { UnlockFile(file.as_raw_handle() as HANDLE, 0, 0, !0, !0) };\n    if ret == 0 {\n      Err(Error::last_os_error())\n    } else {\n      Ok(())\n    }\n  }\n\n  fn lock_file(file: &File, flags: LOCK_FILE_FLAGS) -> Result<()> {\n    let ret = unsafe {\n      let mut overlapped = mem::zeroed();\n      LockFileEx(\n        file.as_raw_handle() as HANDLE,\n        flags,\n        0,\n        !0,\n        !0,\n        &mut overlapped,\n      )\n    };\n\n    if ret == 0 {\n      Err(Error::last_os_error())\n    } else {\n      Ok(())\n    }\n  }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "fd95b6043ad27da47003167fab668fa7738a54e2",
    "func": "//! Demonstrates how to use masks to limit the scope of animations.\n\nuse bevy::{\n    animation::{AnimationTarget, AnimationTargetId},\n    color::palettes::css::{LIGHT_GRAY, WHITE},\n    prelude::*,\n    utils::hashbrown::HashSet,\n};\n\n// IDs of the mask groups we define for the running fox model.\n//\n// Each mask group defines a set of bones for which animations can be toggled on\n// and off.\nconst MASK_GROUP_HEAD: u32 = 0;\nconst MASK_GROUP_LEFT_FRONT_LEG: u32 = 1;\nconst MASK_GROUP_RIGHT_FRONT_LEG: u32 = 2;\nconst MASK_GROUP_LEFT_HIND_LEG: u32 = 3;\nconst MASK_GROUP_RIGHT_HIND_LEG: u32 = 4;\nconst MASK_GROUP_TAIL: u32 = 5;\n\n// The width in pixels of the small buttons that allow the user to toggle a mask\n// group on or off.\nconst MASK_GROUP_BUTTON_WIDTH: f32 = 250.0;\n\n// The names of the bones that each mask group consists of. Each mask group is\n// defined as a (prefix, suffix) tuple. The mask group consists of a single\n// bone chain rooted at the prefix. For example, if the chain's prefix is\n// \"A/B/C\" and the suffix is \"D/E\", then the bones that will be included in the\n// mask group are \"A/B/C\", \"A/B/C/D\", and \"A/B/C/D/E\".\n//\n// The fact that our mask groups are single chains of bones isn't an engine\n// requirement; it just so happens to be the case for the model we're using. A\n// mask group can consist of any set of animation targets, regardless of whether\n// they form a single chain.\nconst MASK_GROUP_PATHS: [(&str, &str); 6] = [\n    // Head\n    (\n        \"root/_rootJoint/b_Root_00/b_Hip_01/b_Spine01_02/b_Spine02_03\",\n        \"b_Neck_04/b_Head_05\",\n    ),\n    // Left front leg\n    (\n        \"root/_rootJoint/b_Root_00/b_Hip_01/b_Spine01_02/b_Spine02_03/b_LeftUpperArm_09\",\n        \"b_LeftForeArm_010/b_LeftHand_011\",\n    ),\n    // Right front leg\n    (\n        \"root/_rootJoint/b_Root_00/b_Hip_01/b_Spine01_02/b_Spine02_03/b_RightUpperArm_06\",\n        \"b_RightForeArm_07/b_RightHand_08\",\n    ),\n    // Left hind leg\n    (\n        \"root/_rootJoint/b_Root_00/b_Hip_01/b_LeftLeg01_015\",\n        \"b_LeftLeg02_016/b_LeftFoot01_017/b_LeftFoot02_018\",\n    ),\n    // Right hind leg\n    (\n        \"root/_rootJoint/b_Root_00/b_Hip_01/b_RightLeg01_019\",\n        \"b_RightLeg02_020/b_RightFoot01_021/b_RightFoot02_022\",\n    ),\n    // Tail\n    (\n        \"root/_rootJoint/b_Root_00/b_Hip_01/b_Tail01_012\",\n        \"b_Tail02_013/b_Tail03_014\",\n    ),\n];\n\n#[derive(Clone, Copy, Component)]\nstruct AnimationControl {\n    // The ID of the mask group that this button controls.\n    group_id: u32,\n    label: AnimationLabel,\n}\n\n#[derive(Clone, Copy, Component, PartialEq, Debug)]\nenum AnimationLabel {\n    Idle = 0,\n    Walk = 1,\n    Run = 2,\n    Off = 3,\n}\n\n#[derive(Clone, Debug, Resource)]\nstruct AnimationNodes([AnimationNodeIndex; 3]);\n\n#[derive(Clone, Copy, Debug, Resource)]\nstruct AppState([MaskGroupState; 6]);\n\n#[derive(Clone, Copy, Debug)]\nstruct MaskGroupState {\n    clip: u8,\n}\n\n// The application entry point.\nfn main() {\n    App::new()\n        .add_plugins(DefaultPlugins.set(WindowPlugin {\n            primary_window: Some(Window {\n                title: \"Bevy Animation Masks Example\".into(),\n                ..default()\n            }),\n            ..default()\n        }))\n        .add_systems(Startup, (setup_scene, setup_ui))\n        .add_systems(Update, setup_animation_graph_once_loaded)\n        .add_systems(Update, handle_button_toggles)\n        .add_systems(Update, update_ui)\n        .insert_resource(AmbientLight {\n            color: WHITE.into(),\n            brightness: 100.0,\n        })\n        .init_resource::<AppState>()\n        .run();\n}\n\n// Spawns the 3D objects in the scene, and loads the fox animation from the glTF\n// file.\nfn setup_scene(\n    mut commands: Commands,\n    asset_server: Res<AssetServer>,\n    mut meshes: ResMut<Assets<Mesh>>,\n    mut materials: ResMut<Assets<StandardMaterial>>,\n) {\n    // Spawn the camera.\n    commands.spawn((\n        Camera3d::default(),\n        Transform::from_xyz(-15.0, 10.0, 20.0).looking_at(Vec3::new(0., 1., 0.), Vec3::Y),\n    ));\n\n    // Spawn the light.\n    commands.spawn((\n        PointLight {\n            intensity: 10_000_000.0,\n            shadows_enabled: true,\n            ..default()\n        },\n        Transform::from_xyz(-4.0, 8.0, 13.0),\n    ));\n\n    // Spawn the fox.\n    commands.spawn((\n        SceneRoot(\n            asset_server.load(GltfAssetLabel::Scene(0).from_asset(\"models/animated/Fox.glb\")),\n        ),\n        Transform::from_scale(Vec3::splat(0.07)),\n    ));\n\n    // Spawn the ground.\n    commands.spawn((\n        Mesh3d(meshes.add(Circle::new(7.0))),\n        MeshMaterial3d(materials.add(Color::srgb(0.3, 0.5, 0.3))),\n        Transform::from_rotation(Quat::from_rotation_x(-std::f32::consts::FRAC_PI_2)),\n    ));\n}\n\n// Creates the UI.\nfn setup_ui(mut commands: Commands) {\n    // Add help text.\n    commands.spawn((\n        Text::new(\"Click on a button to toggle animations for its associated bones\"),\n        Node {\n            position_type: PositionType::Absolute,\n            left: Val::Px(12.0),\n            top: Val::Px(12.0),\n            ..default()\n        },\n    ));\n\n    // Add the buttons that allow the user to toggle mask groups on and off.\n    commands\n        .spawn(Node {\n            flex_direction: FlexDirection::Column,\n            position_type: PositionType::Absolute,\n            row_gap: Val::Px(6.0),\n            left: Val::Px(12.0),\n            bottom: Val::Px(12.0),\n            ..default()\n        })\n        .with_children(|parent| {\n            let row_node = Node {\n                flex_direction: FlexDirection::Row,\n                column_gap: Val::Px(6.0),\n                ..default()\n            };\n\n            add_mask_group_control(parent, \"Head\", Val::Auto, MASK_GROUP_HEAD);\n\n            parent.spawn(row_node.clone()).with_children(|parent| {\n                add_mask_group_control(\n                    parent,\n                    \"Left Front Leg\",\n                    Val::Px(MASK_GROUP_BUTTON_WIDTH),\n                    MASK_GROUP_LEFT_FRONT_LEG,\n                );\n                add_mask_group_control(\n                    parent,\n                    \"Right Front Leg\",\n                    Val::Px(MASK_GROUP_BUTTON_WIDTH),\n                    MASK_GROUP_RIGHT_FRONT_LEG,\n                );\n            });\n\n            parent.spawn(row_node).with_children(|parent| {\n                add_mask_group_control(\n                    parent,\n                    \"Left Hind Leg\",\n                    Val::Px(MASK_GROUP_BUTTON_WIDTH),\n                    MASK_GROUP_LEFT_HIND_LEG,\n                );\n                add_mask_group_control(\n                    parent,\n                    \"Right Hind Leg\",\n                    Val::Px(MASK_GROUP_BUTTON_WIDTH),\n                    MASK_GROUP_RIGHT_HIND_LEG,\n                );\n            });\n\n            add_mask_group_control(parent, \"Tail\", Val::Auto, MASK_GROUP_TAIL);\n        });\n}\n\n// Adds a button that allows the user to toggle a mask group on and off.\n//\n// The button will automatically become a child of the parent that owns the\n// given `ChildBuilder`.\nfn add_mask_group_control(parent: &mut ChildBuilder, label: &str, width: Val, mask_group_id: u32) {\n    let button_text_style = (\n        TextFont {\n            font_size: 14.0,\n            ..default()\n        },\n        TextColor::WHITE,\n    );\n    let selected_button_text_style = (button_text_style.0.clone(), TextColor::BLACK);\n    let label_text_style = (\n        button_text_style.0.clone(),\n        TextColor(Color::Srgba(LIGHT_GRAY)),\n    );\n\n    parent\n        .spawn((\n            Node {\n                border: UiRect::all(Val::Px(1.0)),\n                width,\n                flex_direction: FlexDirection::Column,\n                justify_content: JustifyContent::Center,\n                align_items: AlignItems::Center,\n                padding: UiRect::ZERO,\n                margin: UiRect::ZERO,\n                ..default()\n            },\n            BorderColor(Color::WHITE),\n            BorderRadius::all(Val::Px(3.0)),\n            BackgroundColor(Color::BLACK),\n        ))\n        .with_children(|builder| {\n            builder\n                .spawn((\n                    Node {\n                        border: UiRect::ZERO,\n                        width: Val::Percent(100.0),\n                        justify_content: JustifyContent::Center,\n                        align_items: AlignItems::Center,\n                        padding: UiRect::ZERO,\n                        margin: UiRect::ZERO,\n                        ..default()\n                    },\n                    BackgroundColor(Color::BLACK),\n                ))\n                .with_child((\n                    Text::new(label),\n                    label_text_style.clone(),\n                    Node {\n                        margin: UiRect::vertical(Val::Px(3.0)),\n                        ..default()\n                    },\n                ));\n\n            builder\n                .spawn((\n                    Node {\n                        width: Val::Percent(100.0),\n                        flex_direction: FlexDirection::Row,\n                        justify_content: JustifyContent::Center,\n                        align_items: AlignItems::Center,\n                        border: UiRect::top(Val::Px(1.0)),\n                        ..default()\n                    },\n                    BorderColor(Color::WHITE),\n                ))\n                .with_children(|builder| {\n                    for (index, label) in [\n                        AnimationLabel::Run,\n                        AnimationLabel::Walk,\n                        AnimationLabel::Idle,\n                        AnimationLabel::Off,\n                    ]\n                    .iter()\n                    .enumerate()\n                    {\n                        builder\n                            .spawn((\n                                Button,\n                                BackgroundColor(if index > 0 {\n                                    Color::BLACK\n                                } else {\n                                    Color::WHITE\n                                }),\n                                Node {\n                                    flex_grow: 1.0,\n                                    border: if index > 0 {\n                                        UiRect::left(Val::Px(1.0))\n                                    } else {\n                                        UiRect::ZERO\n                                    },\n                                    ..default()\n                                },\n                                BorderColor(Color::WHITE),\n                                AnimationControl {\n                                    group_id: mask_group_id,\n                                    label: *label,\n                                },\n                            ))\n                            .with_child((\n                                Text(format!(\"{:?}\", label)),\n                                if index > 0 {\n                                    button_text_style.clone()\n                                } else {\n                                    selected_button_text_style.clone()\n                                },\n                                TextLayout::new_with_justify(JustifyText::Center),\n                                Node {\n                                    flex_grow: 1.0,\n                                    margin: UiRect::vertical(Val::Px(3.0)),\n                                    ..default()\n                                },\n                            ));\n                    }\n                });\n        });\n}\n\n// Builds up the animation graph, including the mask groups, and adds it to the\n// entity with the `AnimationPlayer` that the glTF loader created.\nfn setup_animation_graph_once_loaded(\n    mut commands: Commands,\n    asset_server: Res<AssetServer>,\n    mut animation_graphs: ResMut<Assets<AnimationGraph>>,\n    mut players: Query<(Entity, &mut AnimationPlayer), Added<AnimationPlayer>>,\n    targets: Query<(Entity, &AnimationTarget)>,\n) {\n    for (entity, mut player) in &mut players {\n        // Load the animation clip from the glTF file.\n        let mut animation_graph = AnimationGraph::new();\n        let blend_node = animation_graph.add_additive_blend(1.0, animation_graph.root);\n\n        let animation_graph_nodes: [AnimationNodeIndex; 3] =\n            std::array::from_fn(|animation_index| {\n                let handle = asset_server.load(\n                    GltfAssetLabel::Animation(animation_index)\n                        .from_asset(\"models/animated/Fox.glb\"),\n                );\n                let mask = if animation_index == 0 { 0 } else { 0x3f };\n                animation_graph.add_clip_with_mask(handle, mask, 0.0, blend_node)\n            });\n\n        // Create each mask group.\n        let mut all_animation_target_ids = HashSet::new();\n        for (mask_group_index, (mask_group_prefix, mask_group_suffix)) in\n            MASK_GROUP_PATHS.iter().enumerate()\n        {\n            // Split up the prefix and suffix, and convert them into `Name`s.\n            let prefix: Vec<_> = mask_group_prefix.split('/').map(Name::new).collect();\n            let suffix: Vec<_> = mask_group_suffix.split('/').map(Name::new).collect();\n\n            // Add each bone in the chain to the appropriate mask group.\n            for chain_length in 0..=suffix.len() {\n                let animation_target_id = AnimationTargetId::from_names(\n                    prefix.iter().chain(suffix[0..chain_length].iter()),\n                );\n                animation_graph\n                    .add_target_to_mask_group(animation_target_id, mask_group_index as u32);\n                all_animation_target_ids.insert(animation_target_id);\n            }\n        }\n\n        // We're doing constructing the animation graph. Add it as an asset.\n        let animation_graph = animation_graphs.add(animation_graph);\n        commands\n            .entity(entity)\n            .insert(AnimationGraphHandle(animation_graph));\n\n        // Remove animation targets that aren't in any of the mask groups. If we\n        // don't do that, those bones will play all animations at once, which is\n        // ugly.\n        for (target_entity, target) in &targets {\n            if !all_animation_target_ids.contains(&target.id) {\n                commands.entity(target_entity).remove::<AnimationTarget>();\n            }\n        }\n\n        // Play the animation.\n        for animation_graph_node in animation_graph_nodes {\n            player.play(animation_graph_node).repeat();\n        }\n\n        // Record the graph nodes.\n        commands.insert_resource(AnimationNodes(animation_graph_nodes));\n    }\n}\n\n// A system that handles requests from the user to toggle mask groups on and\n// off.\nfn handle_button_toggles(\n    mut interactions: Query<(&Interaction, &mut AnimationControl), Changed<Interaction>>,\n    mut animation_players: Query<&AnimationGraphHandle, With<AnimationPlayer>>,\n    mut animation_graphs: ResMut<Assets<AnimationGraph>>,\n    mut animation_nodes: Option<ResMut<AnimationNodes>>,\n    mut app_state: ResMut<AppState>,\n) {\n    let Some(ref mut animation_nodes) = animation_nodes else {\n        return;\n    };\n\n    for (interaction, animation_control) in interactions.iter_mut() {\n        // We only care about press events.\n        if *interaction != Interaction::Pressed {\n            continue;\n        }\n\n        // Toggle the state of the clip.\n        app_state.0[animation_control.group_id as usize].clip = animation_control.label as u8;\n\n        // Now grab the animation player. (There's only one in our case, but we\n        // iterate just for clarity's sake.)\n        for animation_graph_handle in animation_players.iter_mut() {\n            // The animation graph needs to have loaded.\n            let Some(animation_graph) = animation_graphs.get_mut(animation_graph_handle) else {\n                continue;\n            };\n\n            for (clip_index, &animation_node_index) in animation_nodes.0.iter().enumerate() {\n                let Some(animation_node) = animation_graph.get_mut(animation_node_index) else {\n                    continue;\n                };\n\n                if animation_control.label as usize == clip_index {\n                    animation_node.mask &= !(1 << animation_control.group_id);\n                } else {\n                    animation_node.mask |= 1 << animation_control.group_id;\n                }\n            }\n        }\n    }\n}\n\n// A system that updates the UI based on the current app state.\nfn update_ui(\n    mut animation_controls: Query<(&AnimationControl, &mut BackgroundColor, &Children)>,\n    texts: Query<Entity, With<Text>>,\n    mut writer: TextUiWriter,\n    app_state: Res<AppState>,\n) {\n    for (animation_control, mut background_color, kids) in animation_controls.iter_mut() {\n        let enabled =\n            app_state.0[animation_control.group_id as usize].clip == animation_control.label as u8;\n\n        *background_color = if enabled {\n            BackgroundColor(Color::WHITE)\n        } else {\n            BackgroundColor(Color::BLACK)\n        };\n\n        for &kid in kids {\n            let Ok(text) = texts.get(kid) else {\n                continue;\n            };\n\n            writer.for_each_color(text, |mut color| {\n                color.0 = if enabled { Color::BLACK } else { Color::WHITE };\n            });\n        }\n    }\n}\n\nimpl Default for AppState {\n    fn default() -> Self {\n        AppState([MaskGroupState { clip: 0 }; 6])\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "47951eaed8440f67ce5a208b8bfa526517e80284",
    "func": "use std::collections::HashMap;\n\nuse crate::request::{Request, ConnectionMeta};\nuse crate::local::blocking::Client;\n\nmacro_rules! assert_headers {\n    ($($key:expr => [$($value:expr),+]),+) => ({\n        // Create a new Hyper request. Add all of the passed in headers.\n        let mut req = hyper::Request::get(\"/test\").body(()).unwrap();\n        $($(\n            req.headers_mut()\n                .append($key, hyper::header::HeaderValue::from_str($value).unwrap());\n        )+)+\n\n        // Build up what we expect the headers to actually be.\n        let mut expected = HashMap::new();\n        $(expected.entry($key).or_insert(vec![]).append(&mut vec![$($value),+]);)+\n\n        // Create a valid `Rocket` and convert the hyper req to a Rocket one.\n        let client = Client::debug_with(vec![]).unwrap();\n        let hyper = req.into_parts().0;\n        let meta = ConnectionMeta::default();\n        let req = Request::from_hyp(client.rocket(), &hyper, meta).unwrap();\n\n        // Dispatch the request and check that the headers match.\n        let actual_headers = req.headers();\n        for (key, values) in expected.iter() {\n            let actual: Vec<_> = actual_headers.get(key).collect();\n            assert_eq!(*values, actual);\n        }\n    })\n}\n\n#[test]\nfn test_multiple_headers_from_hyp() {\n    assert_headers!(\"friends\" => [\"alice\"]);\n    assert_headers!(\"friends\" => [\"alice\", \"bob\"]);\n    assert_headers!(\"friends\" => [\"alice\", \"bob, carol\"]);\n    assert_headers!(\"friends\" => [\"alice, david\", \"bob, carol\", \"eric, frank\"]);\n    assert_headers!(\"friends\" => [\"alice\"], \"enemies\" => [\"victor\"]);\n    assert_headers!(\"friends\" => [\"alice\", \"bob\"], \"enemies\" => [\"david\", \"emily\"]);\n}\n\n#[test]\nfn test_multiple_headers_merge_into_one_from_hyp() {\n    assert_headers!(\"friend\" => [\"alice\"], \"friend\" => [\"bob\"]);\n    assert_headers!(\"friend\" => [\"alice\"], \"friend\" => [\"bob\"], \"friend\" => [\"carol\"]);\n    assert_headers!(\"friend\" => [\"alice\"], \"friend\" => [\"bob\"], \"enemy\" => [\"carol\"]);\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "3e12fc11030bb6211e36a7965892a2a576665976",
    "func": "use crate::loom::cell::UnsafeCell;\n\nuse std::rc::Rc;\n\n/// This is exactly like `Cell<Option<Rc<T>>>`, except that it provides a `get`\n/// method even though `Rc` is not `Copy`.\npub(crate) struct RcCell<T> {\n    inner: UnsafeCell<Option<Rc<T>>>,\n}\n\nimpl<T> RcCell<T> {\n    #[cfg(not(all(loom, test)))]\n    pub(crate) const fn new() -> Self {\n        Self {\n            inner: UnsafeCell::new(None),\n        }\n    }\n\n    // The UnsafeCell in loom does not have a const `new` fn.\n    #[cfg(all(loom, test))]\n    pub(crate) fn new() -> Self {\n        Self {\n            inner: UnsafeCell::new(None),\n        }\n    }\n\n    /// Safety: This method may not be called recursively.\n    #[inline]\n    unsafe fn with_inner<F, R>(&self, f: F) -> R\n    where\n        F: FnOnce(&mut Option<Rc<T>>) -> R,\n    {\n        // safety: This type is not Sync, so concurrent calls of this method\n        // cannot happen. Furthermore, the caller guarantees that the method is\n        // not called recursively. Finally, this is the only place that can\n        // create mutable references to the inner Rc. This ensures that any\n        // mutable references created here are exclusive.\n        self.inner.with_mut(|ptr| f(&mut *ptr))\n    }\n\n    pub(crate) fn get(&self) -> Option<Rc<T>> {\n        // safety: The `Rc::clone` method will not call any unknown user-code,\n        // so it will not result in a recursive call to `with_inner`.\n        unsafe { self.with_inner(|rc| rc.clone()) }\n    }\n\n    pub(crate) fn replace(&self, val: Option<Rc<T>>) -> Option<Rc<T>> {\n        // safety: No destructors or other unknown user-code will run inside the\n        // `with_inner` call, so no recursive call to `with_inner` can happen.\n        unsafe { self.with_inner(|rc| std::mem::replace(rc, val)) }\n    }\n\n    pub(crate) fn set(&self, val: Option<Rc<T>>) {\n        let old = self.replace(val);\n        drop(old);\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "aaf29789031c707e02fff74babd82275a529f9f9",
    "func": "use dioxus_core::Event;\n\npub type ToggleEvent = Event<ToggleData>;\n\npub struct ToggleData {\n    inner: Box<dyn HasToggleData>,\n}\n\nimpl<E: HasToggleData> From<E> for ToggleData {\n    fn from(e: E) -> Self {\n        Self { inner: Box::new(e) }\n    }\n}\n\nimpl std::fmt::Debug for ToggleData {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        f.debug_struct(\"ToggleData\").finish()\n    }\n}\n\nimpl PartialEq for ToggleData {\n    fn eq(&self, _other: &Self) -> bool {\n        true\n    }\n}\n\nimpl ToggleData {\n    /// Create a new ToggleData\n    pub fn new(inner: impl HasToggleData + 'static) -> Self {\n        Self {\n            inner: Box::new(inner),\n        }\n    }\n\n    /// Downcast this event to a concrete event type\n    #[inline(always)]\n    pub fn downcast<T: 'static>(&self) -> Option<&T> {\n        self.inner.as_any().downcast_ref::<T>()\n    }\n}\n\n#[cfg(feature = \"serialize\")]\n/// A serialized version of ToggleData\n#[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq, Clone)]\npub struct SerializedToggleData {}\n\n#[cfg(feature = \"serialize\")]\nimpl From<&ToggleData> for SerializedToggleData {\n    fn from(_: &ToggleData) -> Self {\n        Self {}\n    }\n}\n\n#[cfg(feature = \"serialize\")]\nimpl HasToggleData for SerializedToggleData {\n    fn as_any(&self) -> &dyn std::any::Any {\n        self\n    }\n}\n\n#[cfg(feature = \"serialize\")]\nimpl serde::Serialize for ToggleData {\n    fn serialize<S: serde::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {\n        SerializedToggleData::from(self).serialize(serializer)\n    }\n}\n\n#[cfg(feature = \"serialize\")]\nimpl<'de> serde::Deserialize<'de> for ToggleData {\n    fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {\n        let data = SerializedToggleData::deserialize(deserializer)?;\n        Ok(Self {\n            inner: Box::new(data),\n        })\n    }\n}\n\npub trait HasToggleData: std::any::Any {\n    /// return self as Any\n    fn as_any(&self) -> &dyn std::any::Any;\n}\n\nimpl_event! {\n    ToggleData;\n\n    /// ontoggle\n    ontoggle\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "7347120ae64240a83ab703f9b3a2cb288ab3f164",
    "func": "#![warn(rust_2018_idioms)]\n#![cfg(feature = \"full\")]\n\nuse std::io::ErrorKind;\nuse tokio::io::{AsyncBufReadExt, BufReader, Error};\nuse tokio_test::{assert_ok, io::Builder};\n\nuse std::io::Cursor;\n\n#[tokio::test]\nasync fn read_line() {\n    let mut buf = String::new();\n    let mut rd = Cursor::new(b\"hello\\nworld\\n\\n\");\n\n    let n = assert_ok!(rd.read_line(&mut buf).await);\n    assert_eq!(n, 6);\n    assert_eq!(buf, \"hello\\n\");\n    buf.clear();\n    let n = assert_ok!(rd.read_line(&mut buf).await);\n    assert_eq!(n, 6);\n    assert_eq!(buf, \"world\\n\");\n    buf.clear();\n    let n = assert_ok!(rd.read_line(&mut buf).await);\n    assert_eq!(n, 1);\n    assert_eq!(buf, \"\\n\");\n    buf.clear();\n    let n = assert_ok!(rd.read_line(&mut buf).await);\n    assert_eq!(n, 0);\n    assert_eq!(buf, \"\");\n}\n\n#[tokio::test]\nasync fn read_line_not_all_ready() {\n    let mock = Builder::new()\n        .read(b\"Hello Wor\")\n        .read(b\"ld\\nFizzBuz\")\n        .read(b\"z\\n1\\n2\")\n        .build();\n\n    let mut read = BufReader::new(mock);\n\n    let mut line = \"We say \".to_string();\n    let bytes = read.read_line(&mut line).await.unwrap();\n    assert_eq!(bytes, \"Hello World\\n\".len());\n    assert_eq!(line.as_str(), \"We say Hello World\\n\");\n\n    line = \"I solve \".to_string();\n    let bytes = read.read_line(&mut line).await.unwrap();\n    assert_eq!(bytes, \"FizzBuzz\\n\".len());\n    assert_eq!(line.as_str(), \"I solve FizzBuzz\\n\");\n\n    line.clear();\n    let bytes = read.read_line(&mut line).await.unwrap();\n    assert_eq!(bytes, 2);\n    assert_eq!(line.as_str(), \"1\\n\");\n\n    line.clear();\n    let bytes = read.read_line(&mut line).await.unwrap();\n    assert_eq!(bytes, 1);\n    assert_eq!(line.as_str(), \"2\");\n}\n\n#[tokio::test]\nasync fn read_line_invalid_utf8() {\n    let mock = Builder::new().read(b\"Hello Wor\\xffld.\\n\").build();\n\n    let mut read = BufReader::new(mock);\n\n    let mut line = \"Foo\".to_string();\n    let err = read.read_line(&mut line).await.expect_err(\"Should fail\");\n    assert_eq!(err.kind(), ErrorKind::InvalidData);\n    assert_eq!(err.to_string(), \"stream did not contain valid UTF-8\");\n    assert_eq!(line.as_str(), \"Foo\");\n}\n\n#[tokio::test]\nasync fn read_line_fail() {\n    let mock = Builder::new()\n        .read(b\"Hello Wor\")\n        .read_error(Error::new(ErrorKind::Other, \"The world has no end\"))\n        .build();\n\n    let mut read = BufReader::new(mock);\n\n    let mut line = \"Foo\".to_string();\n    let err = read.read_line(&mut line).await.expect_err(\"Should fail\");\n    assert_eq!(err.kind(), ErrorKind::Other);\n    assert_eq!(err.to_string(), \"The world has no end\");\n    assert_eq!(line.as_str(), \"FooHello Wor\");\n}\n\n#[tokio::test]\nasync fn read_line_fail_and_utf8_fail() {\n    let mock = Builder::new()\n        .read(b\"Hello Wor\")\n        .read(b\"\\xff\\xff\\xff\")\n        .read_error(Error::new(ErrorKind::Other, \"The world has no end\"))\n        .build();\n\n    let mut read = BufReader::new(mock);\n\n    let mut line = \"Foo\".to_string();\n    let err = read.read_line(&mut line).await.expect_err(\"Should fail\");\n    assert_eq!(err.kind(), ErrorKind::Other);\n    assert_eq!(err.to_string(), \"The world has no end\");\n    assert_eq!(line.as_str(), \"Foo\");\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "18c7438c13747bcc4bd46e4a382a7fea4f2967dc",
    "func": "use async_graphql::*;\nuse sea_orm::{entity::prelude::*, DeleteMany};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel, Serialize, Deserialize, SimpleObject)]\n#[sea_orm(table_name = \"notes\")]\n#[graphql(concrete(name = \"Note\", params()))]\npub struct Model {\n    #[sea_orm(primary_key)]\n    #[serde(skip_deserializing)]\n    pub id: i32,\n    pub title: String,\n    pub text: String,\n}\n\n#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]\npub enum Relation {}\n\nimpl ActiveModelBehavior for ActiveModel {}\n\nimpl Entity {\n    pub fn find_by_id(id: i32) -> Select<Entity> {\n        Self::find().filter(Column::Id.eq(id))\n    }\n\n    pub fn find_by_title(title: &str) -> Select<Entity> {\n        Self::find().filter(Column::Title.eq(title))\n    }\n\n    pub fn delete_by_id(id: i32) -> DeleteMany<Entity> {\n        Self::delete_many().filter(Column::Id.eq(id))\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "ad0ceba5ae74d1a7dd6f645379e2c1b151e8ca8e",
    "func": "use dioxus_core::internal::HotReloadTemplateWithLocation;\nuse serde::{Deserialize, Serialize};\nuse std::path::PathBuf;\n\n/// A message the hot reloading server sends to the client\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]\npub enum DevserverMsg {\n    /// Attempt a hotreload\n    /// This includes all the templates/literals/assets/binary patches that have changed in one shot\n    HotReload(HotReloadMsg),\n\n    /// The devserver is starting a full rebuild.\n    FullReloadStart,\n\n    /// The full reload failed.\n    FullReloadFailed,\n\n    /// The app should reload completely if it can\n    FullReloadCommand,\n\n    /// The program is shutting down completely - maybe toss up a splash screen or something?\n    Shutdown,\n}\n\n/// A message the client sends from the frontend to the devserver\n///\n/// This is used to communicate with the devserver\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]\npub enum ClientMsg {\n    Log {\n        level: String,\n        messages: Vec<String>,\n    },\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]\npub struct HotReloadMsg {\n    pub templates: Vec<HotReloadTemplateWithLocation>,\n    pub assets: Vec<PathBuf>,\n    pub unknown_files: Vec<PathBuf>,\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "2f544fc2c5aa904576429d15e97c93601683cce7",
    "func": "use serde::{Deserialize, Serialize};\n\n#[derive(Clone, Deserialize, Serialize)]\n#[cfg_attr(\n    feature = \"config-schema\",\n    derive(schemars::JsonSchema),\n    schemars(deny_unknown_fields)\n)]\n#[serde(default)]\npub struct SudoConfig<'a> {\n    pub format: &'a str,\n    pub symbol: &'a str,\n    pub style: &'a str,\n    pub allow_windows: bool,\n    pub disabled: bool,\n}\n\nimpl<'a> Default for SudoConfig<'a> {\n    fn default() -> Self {\n        SudoConfig {\n            format: \"[as $symbol]($style)\",\n            symbol: \"\ud83e\uddd9 \",\n            style: \"bold blue\",\n            allow_windows: false,\n            disabled: true,\n        }\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "97ae0ba4c83c26591de7e0a57dfc4cc7dad60a22",
    "func": "use super::{Context, Module, ModuleConfig};\n\nuse crate::configs::vagrant::VagrantConfig;\nuse crate::formatter::StringFormatter;\nuse crate::formatter::VersionFormatter;\n\n/// Creates a module with the current Vagrant version\npub fn module<'a>(context: &'a Context) -> Option<Module<'a>> {\n    let mut module = context.new_module(\"vagrant\");\n    let config = VagrantConfig::try_load(module.config);\n\n    let is_vagrant_project = context\n        .try_begin_scan()?\n        .set_files(&config.detect_files)\n        .set_extensions(&config.detect_extensions)\n        .set_folders(&config.detect_folders)\n        .is_match();\n\n    if !is_vagrant_project {\n        return None;\n    }\n\n    let parsed = StringFormatter::new(config.format).and_then(|formatter| {\n        formatter\n            .map_meta(|var, _| match var {\n                \"symbol\" => Some(config.symbol),\n                _ => None,\n            })\n            .map_style(|variable| match variable {\n                \"style\" => Some(Ok(config.style)),\n                _ => None,\n            })\n            .map(|variable| match variable {\n                \"version\" => {\n                    let vagrant_version = parse_vagrant_version(\n                        &context.exec_cmd(\"vagrant\", &[\"--version\"])?.stdout,\n                    )?;\n                    VersionFormatter::format_module_version(\n                        module.get_name(),\n                        &vagrant_version,\n                        config.version_format,\n                    )\n                }\n                .map(Ok),\n                _ => None,\n            })\n            .parse(None, Some(context))\n    });\n\n    module.set_segments(match parsed {\n        Ok(segments) => segments,\n        Err(error) => {\n            log::warn!(\"Error in module `vagrant`:\\n{}\", error);\n            return None;\n        }\n    });\n\n    Some(module)\n}\n\nfn parse_vagrant_version(vagrant_stdout: &str) -> Option<String> {\n    // `vagrant --version` output looks like this:\n    // Vagrant 2.2.10\n    let version = vagrant_stdout\n        // split into [\"Vagrant\", \"2.2.10\"]\n        .split_whitespace()\n        // return \"2.2.10\"\n        .nth(1)?;\n\n    Some(version.to_string())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::test::ModuleRenderer;\n    use nu_ansi_term::Color;\n    use std::fs::File;\n    use std::io;\n\n    #[test]\n    fn folder_without_vagrant_files() -> io::Result<()> {\n        let dir = tempfile::tempdir()?;\n\n        let actual = ModuleRenderer::new(\"vagrant\").path(dir.path()).collect();\n\n        let expected = None;\n        assert_eq!(expected, actual);\n        dir.close()\n    }\n\n    #[test]\n    fn folder_with_vagrant_file() -> io::Result<()> {\n        let dir = tempfile::tempdir()?;\n        File::create(dir.path().join(\"Vagrantfile\"))?.sync_all()?;\n\n        let actual = ModuleRenderer::new(\"vagrant\").path(dir.path()).collect();\n\n        let expected = Some(format!(\"via {}\", Color::Cyan.bold().paint(\"\u2371 v2.2.10 \")));\n        assert_eq!(expected, actual);\n        dir.close()\n    }\n\n    #[test]\n    fn test_parse_vagrant_version() {\n        let vagrant = \"Vagrant 2.2.10\\n\";\n        assert_eq!(parse_vagrant_version(vagrant), Some(\"2.2.10\".to_string()));\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "45e719e6ca3f8da2db46715e7a025edfc42ff8a3",
    "func": "//! Demonstrates how the `AlignItems` and `JustifyContent` properties can be composed to layout text.\nuse bevy::prelude::*;\n\nconst ALIGN_ITEMS_COLOR: Color = Color::srgb(1., 0.066, 0.349);\nconst JUSTIFY_CONTENT_COLOR: Color = Color::srgb(0.102, 0.522, 1.);\nconst MARGIN: Val = Val::Px(12.);\n\nfn main() {\n    App::new()\n        .add_plugins(DefaultPlugins.set(WindowPlugin {\n            primary_window: Some(Window {\n                title: \"Bevy Flex Layout Example\".to_string(),\n                ..Default::default()\n            }),\n            ..Default::default()\n        }))\n        .add_systems(Startup, spawn_layout)\n        .run();\n}\n\nfn spawn_layout(mut commands: Commands, asset_server: Res<AssetServer>) {\n    let font = asset_server.load(\"fonts/FiraSans-Bold.ttf\");\n    commands.spawn(Camera2d);\n    commands\n        .spawn((\n            Node {\n                // fill the entire window\n                width: Val::Percent(100.),\n                height: Val::Percent(100.),\n                flex_direction: FlexDirection::Column,\n                align_items: AlignItems::Center,\n                padding: UiRect::all(MARGIN),\n                row_gap: MARGIN,\n                ..Default::default()\n            },\n            BackgroundColor(Color::BLACK),\n        ))\n        .with_children(|builder| {\n            // spawn the key\n            builder\n                .spawn(Node {\n                    flex_direction: FlexDirection::Row,\n                    ..default()\n                })\n                .with_children(|builder| {\n                    spawn_nested_text_bundle(\n                        builder,\n                        font.clone(),\n                        ALIGN_ITEMS_COLOR,\n                        UiRect::right(MARGIN),\n                        \"AlignItems\",\n                    );\n                    spawn_nested_text_bundle(\n                        builder,\n                        font.clone(),\n                        JUSTIFY_CONTENT_COLOR,\n                        UiRect::default(),\n                        \"JustifyContent\",\n                    );\n                });\n\n            builder\n                .spawn(Node {\n                    width: Val::Percent(100.),\n                    height: Val::Percent(100.),\n                    flex_direction: FlexDirection::Column,\n                    row_gap: MARGIN,\n                    ..default()\n                })\n                .with_children(|builder| {\n                    // spawn one child node for each combination of `AlignItems` and `JustifyContent`\n                    let justifications = [\n                        JustifyContent::FlexStart,\n                        JustifyContent::Center,\n                        JustifyContent::FlexEnd,\n                        JustifyContent::SpaceEvenly,\n                        JustifyContent::SpaceAround,\n                        JustifyContent::SpaceBetween,\n                    ];\n                    let alignments = [\n                        AlignItems::Baseline,\n                        AlignItems::FlexStart,\n                        AlignItems::Center,\n                        AlignItems::FlexEnd,\n                        AlignItems::Stretch,\n                    ];\n                    for align_items in alignments {\n                        builder\n                            .spawn(Node {\n                                width: Val::Percent(100.),\n                                height: Val::Percent(100.),\n                                flex_direction: FlexDirection::Row,\n                                column_gap: MARGIN,\n                                ..Default::default()\n                            })\n                            .with_children(|builder| {\n                                for justify_content in justifications {\n                                    spawn_child_node(\n                                        builder,\n                                        font.clone(),\n                                        align_items,\n                                        justify_content,\n                                    );\n                                }\n                            });\n                    }\n                });\n        });\n}\n\nfn spawn_child_node(\n    builder: &mut ChildBuilder,\n    font: Handle<Font>,\n    align_items: AlignItems,\n    justify_content: JustifyContent,\n) {\n    builder\n        .spawn((\n            Node {\n                flex_direction: FlexDirection::Column,\n                align_items,\n                justify_content,\n                width: Val::Percent(100.),\n                height: Val::Percent(100.),\n                ..default()\n            },\n            BackgroundColor(Color::srgb(0.25, 0.25, 0.25)),\n        ))\n        .with_children(|builder| {\n            let labels = [\n                (format!(\"{align_items:?}\"), ALIGN_ITEMS_COLOR, 0.),\n                (format!(\"{justify_content:?}\"), JUSTIFY_CONTENT_COLOR, 3.),\n            ];\n            for (text, color, top_margin) in labels {\n                // We nest the text within a parent node because margins and padding can't be directly applied to text nodes currently.\n                spawn_nested_text_bundle(\n                    builder,\n                    font.clone(),\n                    color,\n                    UiRect::top(Val::Px(top_margin)),\n                    &text,\n                );\n            }\n        });\n}\n\nfn spawn_nested_text_bundle(\n    builder: &mut ChildBuilder,\n    font: Handle<Font>,\n    background_color: Color,\n    margin: UiRect,\n    text: &str,\n) {\n    builder\n        .spawn((\n            Node {\n                margin,\n                padding: UiRect::axes(Val::Px(5.), Val::Px(1.)),\n                ..default()\n            },\n            BackgroundColor(background_color),\n        ))\n        .with_children(|builder| {\n            builder.spawn((\n                Text::new(text),\n                TextFont { font, ..default() },\n                TextColor::BLACK,\n            ));\n        });\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "f80d9a5b8fcb3ceca55b9e8b8835cda86dc34a6b",
    "func": "#![allow(unused_imports, dead_code)]\n\npub mod common;\npub use common::{features::*, setup::*, TestContext};\nuse sea_orm::entity::prelude::*;\n\n#[derive(DeriveIden)]\npub enum ClassName {\n    Table,\n    Id,\n    Title,\n    Text,\n}\n\n#[derive(DeriveIden)]\npub enum Book {\n    #[sea_orm(iden = \"book_table\")]\n    Table,\n    Id,\n    #[sea_orm(iden = \"turtle\")]\n    Title,\n    #[sea_orm(iden = \"TeXt\")]\n    Text,\n    #[sea_orm(iden = \"ty_pe\")]\n    Type,\n}\n\n#[derive(DeriveIden)]\nstruct GlyphToken;\n\n#[derive(DeriveIden)]\n#[sea_orm(iden = \"weRd\")]\nstruct Word;\n\n#[test]\nfn main() -> Result<(), DbErr> {\n    assert_eq!(ClassName::Table.to_string(), \"class_name\");\n    assert_eq!(ClassName::Id.to_string(), \"id\");\n    assert_eq!(ClassName::Title.to_string(), \"title\");\n    assert_eq!(ClassName::Text.to_string(), \"text\");\n\n    assert_eq!(Book::Id.to_string(), \"id\");\n    assert_eq!(Book::Table.to_string(), \"book_table\");\n    assert_eq!(Book::Title.to_string(), \"turtle\");\n    assert_eq!(Book::Text.to_string(), \"TeXt\");\n    assert_eq!(Book::Type.to_string(), \"ty_pe\");\n\n    assert_eq!(GlyphToken.to_string(), \"glyph_token\");\n\n    assert_eq!(Word.to_string(), \"weRd\");\n    Ok(())\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "6185ac568f776100a47ebddfda3c256310156985",
    "func": "use itertools::Itertools;\nuse ratatui::{\n    buffer::Buffer,\n    layout::{Alignment, Constraint, Layout, Margin, Rect},\n    style::{Style, Stylize},\n    text::Line,\n    widgets::{\n        Block, Clear, Padding, Paragraph, Row, Scrollbar, ScrollbarOrientation, ScrollbarState,\n        StatefulWidget, Table, TableState, Widget, Wrap,\n    },\n};\n\nuse crate::{RgbSwatch, THEME};\n\n#[derive(Debug, Default, Clone, Copy)]\nstruct Ingredient {\n    quantity: &'static str,\n    name: &'static str,\n}\n\nimpl Ingredient {\n    #[allow(clippy::cast_possible_truncation)]\n    fn height(&self) -> u16 {\n        self.name.lines().count() as u16\n    }\n}\n\nimpl<'a> From<Ingredient> for Row<'a> {\n    fn from(i: Ingredient) -> Self {\n        Row::new(vec![i.quantity, i.name]).height(i.height())\n    }\n}\n\n// https://www.realsimple.com/food-recipes/browse-all-recipes/ratatouille\nconst RECIPE: &[(&str, &str)] = &[\n    (\n        \"Step 1: \",\n        \"Over medium-low heat, add the oil to a large skillet with the onion, garlic, and bay \\\n        leaf, stirring occasionally, until the onion has softened.\",\n    ),\n    (\n        \"Step 2: \",\n        \"Add the eggplant and cook, stirring occasionally, for 8 minutes or until the eggplant \\\n        has softened. Stir in the zucchini, red bell pepper, tomatoes, and salt, and cook over \\\n        medium heat, stirring occasionally, for 5 to 7 minutes or until the vegetables are \\\n        tender. Stir in the basil and few grinds of pepper to taste.\",\n    ),\n];\n\nconst INGREDIENTS: &[Ingredient] = &[\n    Ingredient {\n        quantity: \"4 tbsp\",\n        name: \"olive oil\",\n    },\n    Ingredient {\n        quantity: \"1\",\n        name: \"onion thinly sliced\",\n    },\n    Ingredient {\n        quantity: \"4\",\n        name: \"cloves garlic\\npeeled and sliced\",\n    },\n    Ingredient {\n        quantity: \"1\",\n        name: \"small bay leaf\",\n    },\n    Ingredient {\n        quantity: \"1\",\n        name: \"small eggplant cut\\ninto 1/2 inch cubes\",\n    },\n    Ingredient {\n        quantity: \"1\",\n        name: \"small zucchini halved\\nlengthwise and cut\\ninto thin slices\",\n    },\n    Ingredient {\n        quantity: \"1\",\n        name: \"red bell pepper cut\\ninto slivers\",\n    },\n    Ingredient {\n        quantity: \"4\",\n        name: \"plum tomatoes\\ncoarsely chopped\",\n    },\n    Ingredient {\n        quantity: \"1 tsp\",\n        name: \"kosher salt\",\n    },\n    Ingredient {\n        quantity: \"1/4 cup\",\n        name: \"shredded fresh basil\\nleaves\",\n    },\n    Ingredient {\n        quantity: \"\",\n        name: \"freshly ground black\\npepper\",\n    },\n];\n\n#[derive(Debug, Default, Clone, Copy, PartialEq, Eq)]\npub struct RecipeTab {\n    row_index: usize,\n}\n\nimpl RecipeTab {\n    /// Select the previous item in the ingredients list (with wrap around)\n    pub fn prev(&mut self) {\n        self.row_index = self.row_index.saturating_add(INGREDIENTS.len() - 1) % INGREDIENTS.len();\n    }\n\n    /// Select the next item in the ingredients list (with wrap around)\n    pub fn next(&mut self) {\n        self.row_index = self.row_index.saturating_add(1) % INGREDIENTS.len();\n    }\n}\n\nimpl Widget for RecipeTab {\n    fn render(self, area: Rect, buf: &mut Buffer) {\n        RgbSwatch.render(area, buf);\n        let area = area.inner(Margin {\n            vertical: 1,\n            horizontal: 2,\n        });\n        Clear.render(area, buf);\n        Block::new()\n            .title(\"Ratatouille Recipe\".bold().white())\n            .title_alignment(Alignment::Center)\n            .style(THEME.content)\n            .padding(Padding::new(1, 1, 2, 1))\n            .render(area, buf);\n\n        let scrollbar_area = Rect {\n            y: area.y + 2,\n            height: area.height - 3,\n            ..area\n        };\n        render_scrollbar(self.row_index, scrollbar_area, buf);\n\n        let area = area.inner(Margin {\n            horizontal: 2,\n            vertical: 1,\n        });\n        let [recipe, ingredients] =\n            Layout::horizontal([Constraint::Length(44), Constraint::Min(0)]).areas(area);\n\n        render_recipe(recipe, buf);\n        render_ingredients(self.row_index, ingredients, buf);\n    }\n}\n\nfn render_recipe(area: Rect, buf: &mut Buffer) {\n    let lines = RECIPE\n        .iter()\n        .map(|(step, text)| Line::from(vec![step.white().bold(), text.gray()]))\n        .collect_vec();\n    Paragraph::new(lines)\n        .wrap(Wrap { trim: true })\n        .block(Block::new().padding(Padding::new(0, 1, 0, 0)))\n        .render(area, buf);\n}\n\nfn render_ingredients(selected_row: usize, area: Rect, buf: &mut Buffer) {\n    let mut state = TableState::default().with_selected(Some(selected_row));\n    let rows = INGREDIENTS.iter().copied();\n    let theme = THEME.recipe;\n    StatefulWidget::render(\n        Table::new(rows, [Constraint::Length(7), Constraint::Length(30)])\n            .block(Block::new().style(theme.ingredients))\n            .header(Row::new(vec![\"Qty\", \"Ingredient\"]).style(theme.ingredients_header))\n            .row_highlight_style(Style::new().light_yellow()),\n        area,\n        buf,\n        &mut state,\n    );\n}\n\nfn render_scrollbar(position: usize, area: Rect, buf: &mut Buffer) {\n    let mut state = ScrollbarState::default()\n        .content_length(INGREDIENTS.len())\n        .viewport_content_length(6)\n        .position(position);\n    Scrollbar::new(ScrollbarOrientation::VerticalRight)\n        .begin_symbol(None)\n        .end_symbol(None)\n        .track_symbol(None)\n        .thumb_symbol(\"\u2590\")\n        .render(area, buf, &mut state);\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "41e753b152f5deb3da40d937faa3223ed917c6cd",
    "func": "use crate::ButtonInput;\nuse bevy_ecs::system::Res;\nuse core::hash::Hash;\n\n/// Stateful run condition that can be toggled via a input press using [`ButtonInput::just_pressed`].\n///\n/// ```no_run\n/// # use bevy_app::{App, NoopPluginGroup as DefaultPlugins, Update};\n/// # use bevy_ecs::prelude::IntoSystemConfigs;\n/// # use bevy_input::{common_conditions::input_toggle_active, prelude::KeyCode};\n///\n/// fn main() {\n///     App::new()\n///         .add_plugins(DefaultPlugins)\n///         .add_systems(Update, pause_menu.run_if(input_toggle_active(false, KeyCode::Escape)))\n///         .run();\n/// }\n///\n/// fn pause_menu() {\n///     println!(\"in pause menu\");\n/// }\n/// ```\n///\n/// If you want other systems to be able to access whether the toggled state is active,\n/// you should use a custom resource or a state for that:\n/// ```no_run\n/// # use bevy_app::{App, NoopPluginGroup as DefaultPlugins, Update};\n/// # use bevy_ecs::prelude::{IntoSystemConfigs, Res, ResMut, Resource};\n/// # use bevy_input::{common_conditions::input_just_pressed, prelude::KeyCode};\n///\n/// #[derive(Resource, Default)]\n/// struct Paused(bool);\n///\n/// fn main() {\n///     App::new()\n///         .add_plugins(DefaultPlugins)\n///         .init_resource::<Paused>()\n///         .add_systems(Update, toggle_pause_state.run_if(input_just_pressed(KeyCode::Escape)))\n///         .add_systems(Update, pause_menu.run_if(|paused: Res<Paused>| paused.0))\n///         .run();\n/// }\n///\n/// fn toggle_pause_state(mut paused: ResMut<Paused>) {\n///     paused.0 = !paused.0;\n/// }\n///\n/// fn pause_menu() {\n///     println!(\"in pause menu\");\n/// }\n/// ```\npub fn input_toggle_active<T>(\n    default: bool,\n    input: T,\n) -> impl FnMut(Res<ButtonInput<T>>) -> bool + Clone\nwhere\n    T: Copy + Eq + Hash + Send + Sync + 'static,\n{\n    let mut active = default;\n    move |inputs: Res<ButtonInput<T>>| {\n        active ^= inputs.just_pressed(input);\n        active\n    }\n}\n\n/// Run condition that is active if [`ButtonInput::pressed`] is true for the given input.\npub fn input_pressed<T>(input: T) -> impl FnMut(Res<ButtonInput<T>>) -> bool + Clone\nwhere\n    T: Copy + Eq + Hash + Send + Sync + 'static,\n{\n    move |inputs: Res<ButtonInput<T>>| inputs.pressed(input)\n}\n\n/// Run condition that is active if [`ButtonInput::just_pressed`] is true for the given input.\n///\n/// ```no_run\n/// # use bevy_app::{App, NoopPluginGroup as DefaultPlugins, Update};\n/// # use bevy_ecs::prelude::IntoSystemConfigs;\n/// # use bevy_input::{common_conditions::input_just_pressed, prelude::KeyCode};\n/// fn main() {\n///     App::new()\n///         .add_plugins(DefaultPlugins)\n///         .add_systems(Update, jump.run_if(input_just_pressed(KeyCode::Space)))\n///         .run();\n/// }\n///\n/// # fn jump() {}\n/// ```\npub fn input_just_pressed<T>(input: T) -> impl FnMut(Res<ButtonInput<T>>) -> bool + Clone\nwhere\n    T: Copy + Eq + Hash + Send + Sync + 'static,\n{\n    move |inputs: Res<ButtonInput<T>>| inputs.just_pressed(input)\n}\n\n/// Run condition that is active if [`ButtonInput::just_released`] is true for the given input.\npub fn input_just_released<T>(input: T) -> impl FnMut(Res<ButtonInput<T>>) -> bool + Clone\nwhere\n    T: Copy + Eq + Hash + Send + Sync + 'static,\n{\n    move |inputs: Res<ButtonInput<T>>| inputs.just_released(input)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::prelude::KeyCode;\n    use bevy_ecs::schedule::{IntoSystemConfigs, Schedule};\n\n    fn test_system() {}\n\n    // Ensure distributive_run_if compiles with the common conditions.\n    #[test]\n    fn distributive_run_if_compiles() {\n        Schedule::default().add_systems(\n            (test_system, test_system)\n                .distributive_run_if(input_toggle_active(false, KeyCode::Escape))\n                .distributive_run_if(input_pressed(KeyCode::Escape))\n                .distributive_run_if(input_just_pressed(KeyCode::Escape))\n                .distributive_run_if(input_just_released(KeyCode::Escape)),\n        );\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "556b891ba22f7f04b325e3f4c29607a1638f9ca1",
    "func": "#[macro_use] extern crate rocket;\n\nuse rocket::local::blocking::Client;\n\n#[get(\"/easy/<id>\")]\nfn easy(id: i32) -> String {\n    format!(\"easy id: {}\", id)\n}\n\nmacro_rules! make_handler {\n    () => {\n        #[get(\"/hard/<id>\")]\n        fn hard(id: i32) -> String {\n            format!(\"hard id: {}\", id)\n        }\n    }\n}\n\nmake_handler!();\n\n\nmacro_rules! foo {\n    ($addr:expr, $name:ident) => {\n        #[get($addr)]\n        fn hi($name: String) -> String {\n            $name\n        }\n    };\n}\n\n// regression test for `#[get] panicking if used inside a macro\nfoo!(\"/hello/<name>\", name);\n\n#[test]\nfn test_reexpansion() {\n    let rocket = rocket::build().mount(\"/\", routes![easy, hard, hi]);\n    let client = Client::debug(rocket).unwrap();\n\n    let response = client.get(\"/easy/327\").dispatch();\n    assert_eq!(response.into_string().unwrap(), \"easy id: 327\");\n\n    let response = client.get(\"/hard/72\").dispatch();\n    assert_eq!(response.into_string().unwrap(), \"hard id: 72\");\n\n    let response = client.get(\"/hello/fish\").dispatch();\n    assert_eq!(response.into_string().unwrap(), \"fish\");\n}\n\nmacro_rules! index {\n    ($type:ty) => {\n        #[get(\"/\")]\n        fn index(thing: &rocket::State<$type>) -> String {\n            format!(\"Thing: {}\", thing)\n        }\n    }\n}\n\nindex!(i32);\n\n#[test]\nfn test_index() {\n    let rocket = rocket::build().mount(\"/\", routes![index]).manage(100i32);\n    let client = Client::debug(rocket).unwrap();\n\n    let response = client.get(\"/\").dispatch();\n    assert_eq!(response.into_string().unwrap(), \"Thing: 100\");\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "a99dd43ca703750a990046893c30338e51e94670",
    "func": "use std::{collections::VecDeque, mem};\n\nuse unicode_segmentation::UnicodeSegmentation;\nuse unicode_width::UnicodeWidthStr;\n\nuse crate::{layout::Alignment, text::StyledGrapheme};\n\n/// A state machine to pack styled symbols into lines.\n/// Cannot implement it as Iterator since it yields slices of the internal buffer (need streaming\n/// iterators for that).\npub trait LineComposer<'a> {\n    fn next_line<'lend>(&'lend mut self) -> Option<WrappedLine<'lend, 'a>>;\n}\n\npub struct WrappedLine<'lend, 'text> {\n    /// One line reflowed to the correct width\n    pub line: &'lend [StyledGrapheme<'text>],\n    /// The width of the line\n    pub width: u16,\n    /// Whether the line was aligned left or right\n    pub alignment: Alignment,\n}\n\n/// A state machine that wraps lines on word boundaries.\n#[derive(Debug, Default, Clone)]\npub struct WordWrapper<'a, O, I>\nwhere\n    // Outer iterator providing the individual lines\n    O: Iterator<Item = (I, Alignment)>,\n    // Inner iterator providing the styled symbols of a line Each line consists of an alignment and\n    // a series of symbols\n    I: Iterator<Item = StyledGrapheme<'a>>,\n{\n    /// The given, unprocessed lines\n    input_lines: O,\n    max_line_width: u16,\n    wrapped_lines: VecDeque<Vec<StyledGrapheme<'a>>>,\n    current_alignment: Alignment,\n    current_line: Vec<StyledGrapheme<'a>>,\n    /// Removes the leading whitespace from lines\n    trim: bool,\n\n    // These are cached allocations that hold no state across next_line invocations\n    pending_word: Vec<StyledGrapheme<'a>>,\n    pending_whitespace: VecDeque<StyledGrapheme<'a>>,\n    pending_line_pool: Vec<Vec<StyledGrapheme<'a>>>,\n}\n\nimpl<'a, O, I> WordWrapper<'a, O, I>\nwhere\n    O: Iterator<Item = (I, Alignment)>,\n    I: Iterator<Item = StyledGrapheme<'a>>,\n{\n    pub const fn new(lines: O, max_line_width: u16, trim: bool) -> Self {\n        Self {\n            input_lines: lines,\n            max_line_width,\n            wrapped_lines: VecDeque::new(),\n            current_alignment: Alignment::Left,\n            current_line: vec![],\n            trim,\n\n            pending_word: Vec::new(),\n            pending_line_pool: Vec::new(),\n            pending_whitespace: VecDeque::new(),\n        }\n    }\n\n    /// Split an input line (`line_symbols`) into wrapped lines\n    /// and cache them to be emitted later\n    fn process_input(&mut self, line_symbols: impl IntoIterator<Item = StyledGrapheme<'a>>) {\n        let mut pending_line = self.pending_line_pool.pop().unwrap_or_default();\n        let mut line_width = 0;\n        let mut word_width = 0;\n        let mut whitespace_width = 0;\n        let mut non_whitespace_previous = false;\n\n        self.pending_word.clear();\n        self.pending_whitespace.clear();\n        pending_line.clear();\n\n        for grapheme in line_symbols {\n            let is_whitespace = grapheme.is_whitespace();\n            let symbol_width = grapheme.symbol.width() as u16;\n\n            // ignore symbols wider than line limit\n            if symbol_width > self.max_line_width {\n                continue;\n            }\n\n            let word_found = non_whitespace_previous && is_whitespace;\n            // current word would overflow after removing whitespace\n            let trimmed_overflow = pending_line.is_empty()\n                && self.trim\n                && word_width + symbol_width > self.max_line_width;\n            // separated whitespace would overflow on its own\n            let whitespace_overflow = pending_line.is_empty()\n                && self.trim\n                && whitespace_width + symbol_width > self.max_line_width;\n            // current full word (including whitespace) would overflow\n            let untrimmed_overflow = pending_line.is_empty()\n                && !self.trim\n                && word_width + whitespace_width + symbol_width > self.max_line_width;\n\n            // append finished segment to current line\n            if word_found || trimmed_overflow || whitespace_overflow || untrimmed_overflow {\n                if !pending_line.is_empty() || !self.trim {\n                    pending_line.extend(self.pending_whitespace.drain(..));\n                    line_width += whitespace_width;\n                }\n\n                pending_line.append(&mut self.pending_word);\n                line_width += word_width;\n\n                self.pending_whitespace.clear();\n                whitespace_width = 0;\n                word_width = 0;\n            }\n\n            // pending line fills up limit\n            let line_full = line_width >= self.max_line_width;\n            // pending word would overflow line limit\n            let pending_word_overflow = symbol_width > 0\n                && line_width + whitespace_width + word_width >= self.max_line_width;\n\n            // add finished wrapped line to remaining lines\n            if line_full || pending_word_overflow {\n                let mut remaining_width = u16::saturating_sub(self.max_line_width, line_width);\n\n                self.wrapped_lines.push_back(mem::take(&mut pending_line));\n                line_width = 0;\n\n                // remove whitespace up to the end of line\n                while let Some(grapheme) = self.pending_whitespace.front() {\n                    let width = grapheme.symbol.width() as u16;\n\n                    if width > remaining_width {\n                        break;\n                    }\n\n                    whitespace_width -= width;\n                    remaining_width -= width;\n                    self.pending_whitespace.pop_front();\n                }\n\n                // don't count first whitespace toward next word\n                if is_whitespace && self.pending_whitespace.is_empty() {\n                    continue;\n                }\n            }\n\n            // append symbol to a pending buffer\n            if is_whitespace {\n                whitespace_width += symbol_width;\n                self.pending_whitespace.push_back(grapheme);\n            } else {\n                word_width += symbol_width;\n                self.pending_word.push(grapheme);\n            }\n\n            non_whitespace_previous = !is_whitespace;\n        }\n\n        // append remaining text parts\n        if pending_line.is_empty()\n            && self.pending_word.is_empty()\n            && !self.pending_whitespace.is_empty()\n        {\n            self.wrapped_lines.push_back(vec![]);\n        }\n        if !pending_line.is_empty() || !self.trim {\n            pending_line.extend(self.pending_whitespace.drain(..));\n        }\n        pending_line.append(&mut self.pending_word);\n\n        #[allow(clippy::else_if_without_else)]\n        if !pending_line.is_empty() {\n            self.wrapped_lines.push_back(pending_line);\n        } else if pending_line.capacity() > 0 {\n            self.pending_line_pool.push(pending_line);\n        }\n        if self.wrapped_lines.is_empty() {\n            self.wrapped_lines.push_back(vec![]);\n        }\n    }\n\n    fn replace_current_line(&mut self, line: Vec<StyledGrapheme<'a>>) {\n        let cache = mem::replace(&mut self.current_line, line);\n        if cache.capacity() > 0 {\n            self.pending_line_pool.push(cache);\n        }\n    }\n}\n\nimpl<'a, O, I> LineComposer<'a> for WordWrapper<'a, O, I>\nwhere\n    O: Iterator<Item = (I, Alignment)>,\n    I: Iterator<Item = StyledGrapheme<'a>>,\n{\n    #[allow(clippy::too_many_lines)]\n    fn next_line<'lend>(&'lend mut self) -> Option<WrappedLine<'lend, 'a>> {\n        if self.max_line_width == 0 {\n            return None;\n        }\n\n        loop {\n            // emit next cached line if present\n            if let Some(line) = self.wrapped_lines.pop_front() {\n                let line_width = line\n                    .iter()\n                    .map(|grapheme| grapheme.symbol.width() as u16)\n                    .sum();\n\n                self.replace_current_line(line);\n                return Some(WrappedLine {\n                    line: &self.current_line,\n                    width: line_width,\n                    alignment: self.current_alignment,\n                });\n            }\n\n            // otherwise, process pending wrapped lines from input\n            let (line_symbols, line_alignment) = self.input_lines.next()?;\n            self.current_alignment = line_alignment;\n            self.process_input(line_symbols);\n        }\n    }\n}\n\n/// A state machine that truncates overhanging lines.\n#[derive(Debug, Default, Clone)]\npub struct LineTruncator<'a, O, I>\nwhere\n    // Outer iterator providing the individual lines\n    O: Iterator<Item = (I, Alignment)>,\n    // Inner iterator providing the styled symbols of a line Each line consists of an alignment and\n    // a series of symbols\n    I: Iterator<Item = StyledGrapheme<'a>>,\n{\n    /// The given, unprocessed lines\n    input_lines: O,\n    max_line_width: u16,\n    current_line: Vec<StyledGrapheme<'a>>,\n    /// Record the offset to skip render\n    horizontal_offset: u16,\n}\n\nimpl<'a, O, I> LineTruncator<'a, O, I>\nwhere\n    O: Iterator<Item = (I, Alignment)>,\n    I: Iterator<Item = StyledGrapheme<'a>>,\n{\n    pub const fn new(lines: O, max_line_width: u16) -> Self {\n        Self {\n            input_lines: lines,\n            max_line_width,\n            horizontal_offset: 0,\n            current_line: vec![],\n        }\n    }\n\n    pub fn set_horizontal_offset(&mut self, horizontal_offset: u16) {\n        self.horizontal_offset = horizontal_offset;\n    }\n}\n\nimpl<'a, O, I> LineComposer<'a> for LineTruncator<'a, O, I>\nwhere\n    O: Iterator<Item = (I, Alignment)>,\n    I: Iterator<Item = StyledGrapheme<'a>>,\n{\n    fn next_line<'lend>(&'lend mut self) -> Option<WrappedLine<'lend, 'a>> {\n        if self.max_line_width == 0 {\n            return None;\n        }\n\n        self.current_line.truncate(0);\n        let mut current_line_width = 0;\n\n        let mut lines_exhausted = true;\n        let mut horizontal_offset = self.horizontal_offset as usize;\n        let mut current_alignment = Alignment::Left;\n        if let Some((current_line, alignment)) = &mut self.input_lines.next() {\n            lines_exhausted = false;\n            current_alignment = *alignment;\n\n            for StyledGrapheme { symbol, style } in current_line {\n                // Ignore characters wider that the total max width.\n                if symbol.width() as u16 > self.max_line_width {\n                    continue;\n                }\n\n                if current_line_width + symbol.width() as u16 > self.max_line_width {\n                    // Truncate line\n                    break;\n                }\n\n                let symbol = if horizontal_offset == 0 || Alignment::Left != *alignment {\n                    symbol\n                } else {\n                    let w = symbol.width();\n                    if w > horizontal_offset {\n                        let t = trim_offset(symbol, horizontal_offset);\n                        horizontal_offset = 0;\n                        t\n                    } else {\n                        horizontal_offset -= w;\n                        \"\"\n                    }\n                };\n                current_line_width += symbol.width() as u16;\n                self.current_line.push(StyledGrapheme { symbol, style });\n            }\n        }\n\n        if lines_exhausted {\n            None\n        } else {\n            Some(WrappedLine {\n                line: &self.current_line,\n                width: current_line_width,\n                alignment: current_alignment,\n            })\n        }\n    }\n}\n\n/// This function will return a str slice which start at specified offset.\n/// As src is a unicode str, start offset has to be calculated with each character.\nfn trim_offset(src: &str, mut offset: usize) -> &str {\n    let mut start = 0;\n    for c in UnicodeSegmentation::graphemes(src, true) {\n        let w = c.width();\n        if w <= offset {\n            offset -= w;\n            start += c.len();\n        } else {\n            break;\n        }\n    }\n    #[allow(clippy::string_slice)] // Is safe as it comes from UnicodeSegmentation\n    &src[start..]\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use crate::{\n        style::Style,\n        text::{Line, Text},\n    };\n\n    #[derive(Clone, Copy)]\n    enum Composer {\n        WordWrapper { trim: bool },\n        LineTruncator,\n    }\n\n    fn run_composer<'a>(\n        which: Composer,\n        text: impl Into<Text<'a>>,\n        text_area_width: u16,\n    ) -> (Vec<String>, Vec<u16>, Vec<Alignment>) {\n        let text = text.into();\n        let styled_lines = text.iter().map(|line| {\n            (\n                line.iter()\n                    .flat_map(|span| span.styled_graphemes(Style::default())),\n                line.alignment.unwrap_or(Alignment::Left),\n            )\n        });\n\n        let mut composer: Box<dyn LineComposer> = match which {\n            Composer::WordWrapper { trim } => {\n                Box::new(WordWrapper::new(styled_lines, text_area_width, trim))\n            }\n            Composer::LineTruncator => Box::new(LineTruncator::new(styled_lines, text_area_width)),\n        };\n        let mut lines = vec![];\n        let mut widths = vec![];\n        let mut alignments = vec![];\n        while let Some(WrappedLine {\n            line: styled,\n            width,\n            alignment,\n        }) = composer.next_line()\n        {\n            let line = styled\n                .iter()\n                .map(|StyledGrapheme { symbol, .. }| *symbol)\n                .collect::<String>();\n            assert!(width <= text_area_width);\n            lines.push(line);\n            widths.push(width);\n            alignments.push(alignment);\n        }\n        (lines, widths, alignments)\n    }\n\n    #[test]\n    fn line_composer_one_line() {\n        let width = 40;\n        for i in 1..width {\n            let text = \"a\".repeat(i);\n            let (word_wrapper, _, _) =\n                run_composer(Composer::WordWrapper { trim: true }, &*text, width as u16);\n            let (line_truncator, _, _) =\n                run_composer(Composer::LineTruncator, &*text, width as u16);\n            let expected = vec![text];\n            assert_eq!(word_wrapper, expected);\n            assert_eq!(line_truncator, expected);\n        }\n    }\n\n    #[test]\n    fn line_composer_short_lines() {\n        let width = 20;\n        let text =\n            \"abcdefg\\nhijklmno\\npabcdefg\\nhijklmn\\nopabcdefghijk\\nlmnopabcd\\n\\n\\nefghijklmno\";\n        let (word_wrapper, _, _) = run_composer(Composer::WordWrapper { trim: true }, text, width);\n        let (line_truncator, _, _) = run_composer(Composer::LineTruncator, text, width);\n\n        let wrapped: Vec<&str> = text.split('\\n').collect();\n        assert_eq!(word_wrapper, wrapped);\n        assert_eq!(line_truncator, wrapped);\n    }\n\n    #[test]\n    fn line_composer_long_word() {\n        let width = 20;\n        let text = \"abcdefghijklmnopabcdefghijklmnopabcdefghijklmnopabcdefghijklmno\";\n        let (word_wrapper, _, _) =\n            run_composer(Composer::WordWrapper { trim: true }, text, width as u16);\n        let (line_truncator, _, _) = run_composer(Composer::LineTruncator, text, width as u16);\n\n        let wrapped = vec![\n            text.get(..width).unwrap(),\n            text.get(width..width * 2).unwrap(),\n            text.get(width * 2..width * 3).unwrap(),\n            text.get(width * 3..).unwrap(),\n        ];\n        assert_eq!(\n            word_wrapper, wrapped,\n            \"WordWrapper should detect the line cannot be broken on word boundary and \\\n             break it at line width limit.\"\n        );\n        assert_eq!(line_truncator, [text.get(..width).unwrap()]);\n    }\n\n    #[test]\n    fn line_composer_long_sentence() {\n        let width = 20;\n        let text =\n            \"abcd efghij klmnopabcd efgh ijklmnopabcdefg hijkl mnopab c d e f g h i j k l m n o\";\n        let text_multi_space =\n            \"abcd efghij    klmnopabcd efgh     ijklmnopabcdefg hijkl mnopab c d e f g h i j k l \\\n             m n o\";\n        let (word_wrapper_single_space, _, _) =\n            run_composer(Composer::WordWrapper { trim: true }, text, width as u16);\n        let (word_wrapper_multi_space, _, _) = run_composer(\n            Composer::WordWrapper { trim: true },\n            text_multi_space,\n            width as u16,\n        );\n        let (line_truncator, _, _) = run_composer(Composer::LineTruncator, text, width as u16);\n\n        let word_wrapped = vec![\n            \"abcd efghij\",\n            \"klmnopabcd efgh\",\n            \"ijklmnopabcdefg\",\n            \"hijkl mnopab c d e f\",\n            \"g h i j k l m n o\",\n        ];\n        assert_eq!(word_wrapper_single_space, word_wrapped);\n        assert_eq!(word_wrapper_multi_space, word_wrapped);\n\n        assert_eq!(line_truncator, [text.get(..width).unwrap()]);\n    }\n\n    #[test]\n    fn line_composer_zero_width() {\n        let width = 0;\n        let text = \"abcd efghij klmnopabcd efgh ijklmnopabcdefg hijkl mnopab \";\n        let (word_wrapper, _, _) = run_composer(Composer::WordWrapper { trim: true }, text, width);\n        let (line_truncator, _, _) = run_composer(Composer::LineTruncator, text, width);\n\n        let expected: Vec<&str> = Vec::new();\n        assert_eq!(word_wrapper, expected);\n        assert_eq!(line_truncator, expected);\n    }\n\n    #[test]\n    fn line_composer_max_line_width_of_1() {\n        let width = 1;\n        let text = \"abcd efghij klmnopabcd efgh ijklmnopabcdefg hijkl mnopab \";\n        let (word_wrapper, _, _) = run_composer(Composer::WordWrapper { trim: true }, text, width);\n        let (line_truncator, _, _) = run_composer(Composer::LineTruncator, text, width);\n\n        let expected: Vec<&str> = UnicodeSegmentation::graphemes(text, true)\n            .filter(|g| g.chars().any(|c| !c.is_whitespace()))\n            .collect();\n        assert_eq!(word_wrapper, expected);\n        assert_eq!(line_truncator, [\"a\"]);\n    }\n\n    #[test]\n    fn line_composer_max_line_width_of_1_double_width_characters() {\n        let width = 1;\n        let text =\n            \"\u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u4e0a\u3067\u6587\u5b57\u3092\u6271\u3046\u5834\u5408\u3001\u5178\u578b\u7684\u306b\u306f\u6587\u5b57\\naaa\\na\u306b\u3088\u308b\u901a\u4fe1\u3092\u884c\u3046\u5834\u5408\u306b\u305d\u306e\\\n                    \u4e21\u7aef\u70b9\u3067\u306f\u3001\";\n        let (word_wrapper, _, _) = run_composer(Composer::WordWrapper { trim: true }, text, width);\n        let (line_truncator, _, _) = run_composer(Composer::LineTruncator, text, width);\n        assert_eq!(word_wrapper, [\"\", \"a\", \"a\", \"a\", \"a\"]);\n        assert_eq!(line_truncator, [\"\", \"a\", \"a\"]);\n    }\n\n    /// Tests `WordWrapper` with words some of which exceed line length and some not.\n    #[test]\n    fn line_composer_word_wrapper_mixed_length() {\n        let width = 20;\n        let text = \"abcd efghij klmnopabcdefghijklmnopabcdefghijkl mnopab cdefghi j klmno\";\n        let (word_wrapper, _, _) = run_composer(Composer::WordWrapper { trim: true }, text, width);\n        assert_eq!(\n            word_wrapper,\n            vec![\n                \"abcd efghij\",\n                \"klmnopabcdefghijklmn\",\n                \"opabcdefghijkl\",\n                \"mnopab cdefghi j\",\n                \"klmno\",\n            ]\n        );\n    }\n\n    #[test]\n    fn line_composer_double_width_chars() {\n        let width = 20;\n        let text = \"\u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u4e0a\u3067\u6587\u5b57\u3092\u6271\u3046\u5834\u5408\u3001\u5178\u578b\u7684\u306b\u306f\u6587\u5b57\u306b\u3088\u308b\u901a\u4fe1\u3092\u884c\u3046\u5834\u5408\u306b\u305d\u306e\u4e21\u7aef\u70b9\\\n                    \u3067\u306f\u3001\";\n        let (word_wrapper, word_wrapper_width, _) =\n            run_composer(Composer::WordWrapper { trim: true }, text, width);\n        let (line_truncator, _, _) = run_composer(Composer::LineTruncator, text, width);\n        assert_eq!(line_truncator, [\"\u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u4e0a\u3067\u6587\u5b57\"]);\n        let wrapped = [\n            \"\u30b3\u30f3\u30d4\u30e5\u30fc\u30bf\u4e0a\u3067\u6587\u5b57\",\n            \"\u3092\u6271\u3046\u5834\u5408\u3001\u5178\u578b\u7684\u306b\",\n            \"\u306f\u6587\u5b57\u306b\u3088\u308b\u901a\u4fe1\u3092\u884c\",\n            \"\u3046\u5834\u5408\u306b\u305d\u306e\u4e21\u7aef\u70b9\u3067\",\n            \"\u306f\u3001\",\n        ];\n        assert_eq!(word_wrapper, wrapped);\n        assert_eq!(word_wrapper_width, [width, width, width, width, 4]);\n    }\n\n    #[test]\n    fn line_composer_leading_whitespace_removal() {\n        let width = 20;\n        let text = \"AAAAAAAAAAAAAAAAAAAA    AAA\";\n        let (word_wrapper, _, _) = run_composer(Composer::WordWrapper { trim: true }, text, width);\n        let (line_truncator, _, _) = run_composer(Composer::LineTruncator, text, width);\n        assert_eq!(word_wrapper, [\"AAAAAAAAAAAAAAAAAAAA\", \"AAA\"]);\n        assert_eq!(line_truncator, [\"AAAAAAAAAAAAAAAAAAAA\"]);\n    }\n\n    /// Tests truncation of leading whitespace.\n    #[test]\n    fn line_composer_lots_of_spaces() {\n        let width = 20;\n        let text = \"                                                                     \";\n        let (word_wrapper, _, _) = run_composer(Composer::WordWrapper { trim: true }, text, width);\n        let (line_truncator, _, _) = run_composer(Composer::LineTruncator, text, width);\n        assert_eq!(word_wrapper, [\"\"]);\n        assert_eq!(line_truncator, [\"                    \"]);\n    }\n\n    /// Tests an input starting with a letter, followed by spaces - some of the behaviour is\n    /// incidental.\n    #[test]\n    fn line_composer_char_plus_lots_of_spaces() {\n        let width = 20;\n        let text = \"a                                                                     \";\n        let (word_wrapper, _, _) = run_composer(Composer::WordWrapper { trim: true }, text, width);\n        let (line_truncator, _, _) = run_composer(Composer::LineTruncator, text, width);\n        // What's happening below is: the first line gets consumed, trailing spaces discarded,\n        // after 20 of which a word break occurs (probably shouldn't). The second line break\n        // discards all whitespace. The result should probably be vec![\"a\"] but it doesn't matter\n        // that much.\n        assert_eq!(word_wrapper, [\"a\", \"\"]);\n        assert_eq!(line_truncator, [\"a                   \"]);\n    }\n\n    #[test]\n    fn line_composer_word_wrapper_double_width_chars_mixed_with_spaces() {\n        let width = 20;\n        // Japanese seems not to use spaces but we should break on spaces anyway... We're using it\n        // to test double-width chars.\n        // You are more than welcome to add word boundary detection based of alterations of\n        // hiragana and katakana...\n        // This happens to also be a test case for mixed width because regular spaces are single\n        // width.\n        let text = \"\u30b3\u30f3\u30d4\u30e5 \u30fc\u30bf\u4e0a\u3067\u6587\u5b57\u3092\u6271\u3046\u5834\u5408\u3001 \u5178\u578b\u7684\u306b\u306f\u6587 \u5b57\u306b\u3088\u308b \u901a\u4fe1\u3092\u884c \u3046\u5834\u5408\u306b\u305d\u306e\u4e21\u7aef\u70b9\u3067\u306f\u3001\";\n        let (word_wrapper, word_wrapper_width, _) =\n            run_composer(Composer::WordWrapper { trim: true }, text, width);\n        assert_eq!(\n            word_wrapper,\n            vec![\n                \"\u30b3\u30f3\u30d4\u30e5\",\n                \"\u30fc\u30bf\u4e0a\u3067\u6587\u5b57\u3092\u6271\u3046\u5834\",\n                \"\u5408\u3001 \u5178\u578b\u7684\u306b\u306f\u6587\",\n                \"\u5b57\u306b\u3088\u308b \u901a\u4fe1\u3092\u884c\",\n                \"\u3046\u5834\u5408\u306b\u305d\u306e\u4e21\u7aef\u70b9\u3067\",\n                \"\u306f\u3001\",\n            ]\n        );\n        // Odd-sized lines have a space in them.\n        assert_eq!(word_wrapper_width, [8, 20, 17, 17, 20, 4]);\n    }\n\n    /// Ensure words separated by nbsp are wrapped as if they were a single one.\n    #[test]\n    fn line_composer_word_wrapper_nbsp() {\n        let width = 20;\n        let text = \"AAAAAAAAAAAAAAA AAAA\\u{00a0}AAA\";\n        let (word_wrapper, word_wrapper_widths, _) =\n            run_composer(Composer::WordWrapper { trim: true }, text, width);\n        assert_eq!(word_wrapper, [\"AAAAAAAAAAAAAAA\", \"AAAA\\u{00a0}AAA\"]);\n        assert_eq!(word_wrapper_widths, [15, 8]);\n\n        // Ensure that if the character was a regular space, it would be wrapped differently.\n        let text_space = text.replace('\\u{00a0}', \" \");\n        let (word_wrapper_space, word_wrapper_widths, _) =\n            run_composer(Composer::WordWrapper { trim: true }, text_space, width);\n        assert_eq!(word_wrapper_space, [\"AAAAAAAAAAAAAAA AAAA\", \"AAA\"]);\n        assert_eq!(word_wrapper_widths, [20, 3]);\n    }\n\n    #[test]\n    fn line_composer_word_wrapper_preserve_indentation() {\n        let width = 20;\n        let text = \"AAAAAAAAAAAAAAAAAAAA    AAA\";\n        let (word_wrapper, _, _) = run_composer(Composer::WordWrapper { trim: false }, text, width);\n        assert_eq!(word_wrapper, [\"AAAAAAAAAAAAAAAAAAAA\", \"   AAA\"]);\n    }\n\n    #[test]\n    fn line_composer_word_wrapper_preserve_indentation_with_wrap() {\n        let width = 10;\n        let text = \"AAA AAA AAAAA AA AAAAAA\\n B\\n  C\\n   D\";\n        let (word_wrapper, _, _) = run_composer(Composer::WordWrapper { trim: false }, text, width);\n        assert_eq!(\n            word_wrapper,\n            vec![\"AAA AAA\", \"AAAAA AA\", \"AAAAAA\", \" B\", \"  C\", \"   D\"]\n        );\n    }\n\n    #[test]\n    fn line_composer_word_wrapper_preserve_indentation_lots_of_whitespace() {\n        let width = 10;\n        let text = \"               4 Indent\\n                 must wrap!\";\n        let (word_wrapper, _, _) = run_composer(Composer::WordWrapper { trim: false }, text, width);\n        assert_eq!(\n            word_wrapper,\n            vec![\n                \"          \",\n                \"    4\",\n                \"Indent\",\n                \"          \",\n                \"      must\",\n                \"wrap!\"\n            ]\n        );\n    }\n\n    #[test]\n    fn line_composer_zero_width_at_end() {\n        let width = 3;\n        let line = \"foo\\u{200B}\";\n        let (word_wrapper, _, _) = run_composer(Composer::WordWrapper { trim: true }, line, width);\n        let (line_truncator, _, _) = run_composer(Composer::LineTruncator, line, width);\n        assert_eq!(word_wrapper, [\"foo\"]);\n        assert_eq!(line_truncator, [\"foo\\u{200B}\"]);\n    }\n\n    #[test]\n    fn line_composer_preserves_line_alignment() {\n        let width = 20;\n        let lines = vec![\n            Line::from(\"Something that is left aligned.\").alignment(Alignment::Left),\n            Line::from(\"This is right aligned and half short.\").alignment(Alignment::Right),\n            Line::from(\"This should sit in the center.\").alignment(Alignment::Center),\n        ];\n        let (_, _, wrapped_alignments) =\n            run_composer(Composer::WordWrapper { trim: true }, lines.clone(), width);\n        let (_, _, truncated_alignments) = run_composer(Composer::LineTruncator, lines, width);\n        assert_eq!(\n            wrapped_alignments,\n            vec![\n                Alignment::Left,\n                Alignment::Left,\n                Alignment::Right,\n                Alignment::Right,\n                Alignment::Right,\n                Alignment::Center,\n                Alignment::Center\n            ]\n        );\n        assert_eq!(\n            truncated_alignments,\n            vec![Alignment::Left, Alignment::Right, Alignment::Center]\n        );\n    }\n\n    #[test]\n    fn line_composer_zero_width_white_space() {\n        let width = 3;\n        let line = \"foo\\u{200b}bar\";\n        let (word_wrapper, _, _) = run_composer(Composer::WordWrapper { trim: true }, line, width);\n        assert_eq!(word_wrapper, [\"foo\", \"bar\"]);\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "c6cd1990ff9a3d7cfb8d2deed6622caa4973dee6",
    "func": "use crate::io::{AsyncBufRead, AsyncRead, ReadBuf};\n\nuse pin_project_lite::pin_project;\nuse std::fmt;\nuse std::io;\nuse std::pin::Pin;\nuse std::task::{ready, Context, Poll};\n\npin_project! {\n    /// Stream for the [`chain`](super::AsyncReadExt::chain) method.\n    #[must_use = \"streams do nothing unless polled\"]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"io-util\")))]\n    pub struct Chain<T, U> {\n        #[pin]\n        first: T,\n        #[pin]\n        second: U,\n        done_first: bool,\n    }\n}\n\npub(super) fn chain<T, U>(first: T, second: U) -> Chain<T, U>\nwhere\n    T: AsyncRead,\n    U: AsyncRead,\n{\n    Chain {\n        first,\n        second,\n        done_first: false,\n    }\n}\n\nimpl<T, U> Chain<T, U>\nwhere\n    T: AsyncRead,\n    U: AsyncRead,\n{\n    /// Gets references to the underlying readers in this `Chain`.\n    pub fn get_ref(&self) -> (&T, &U) {\n        (&self.first, &self.second)\n    }\n\n    /// Gets mutable references to the underlying readers in this `Chain`.\n    ///\n    /// Care should be taken to avoid modifying the internal I/O state of the\n    /// underlying readers as doing so may corrupt the internal state of this\n    /// `Chain`.\n    pub fn get_mut(&mut self) -> (&mut T, &mut U) {\n        (&mut self.first, &mut self.second)\n    }\n\n    /// Gets pinned mutable references to the underlying readers in this `Chain`.\n    ///\n    /// Care should be taken to avoid modifying the internal I/O state of the\n    /// underlying readers as doing so may corrupt the internal state of this\n    /// `Chain`.\n    pub fn get_pin_mut(self: Pin<&mut Self>) -> (Pin<&mut T>, Pin<&mut U>) {\n        let me = self.project();\n        (me.first, me.second)\n    }\n\n    /// Consumes the `Chain`, returning the wrapped readers.\n    pub fn into_inner(self) -> (T, U) {\n        (self.first, self.second)\n    }\n}\n\nimpl<T, U> fmt::Debug for Chain<T, U>\nwhere\n    T: fmt::Debug,\n    U: fmt::Debug,\n{\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Chain\")\n            .field(\"t\", &self.first)\n            .field(\"u\", &self.second)\n            .finish()\n    }\n}\n\nimpl<T, U> AsyncRead for Chain<T, U>\nwhere\n    T: AsyncRead,\n    U: AsyncRead,\n{\n    fn poll_read(\n        self: Pin<&mut Self>,\n        cx: &mut Context<'_>,\n        buf: &mut ReadBuf<'_>,\n    ) -> Poll<io::Result<()>> {\n        let me = self.project();\n\n        if !*me.done_first {\n            let rem = buf.remaining();\n            ready!(me.first.poll_read(cx, buf))?;\n            if buf.remaining() == rem {\n                *me.done_first = true;\n            } else {\n                return Poll::Ready(Ok(()));\n            }\n        }\n        me.second.poll_read(cx, buf)\n    }\n}\n\nimpl<T, U> AsyncBufRead for Chain<T, U>\nwhere\n    T: AsyncBufRead,\n    U: AsyncBufRead,\n{\n    fn poll_fill_buf(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<io::Result<&[u8]>> {\n        let me = self.project();\n\n        if !*me.done_first {\n            match ready!(me.first.poll_fill_buf(cx)?) {\n                [] => {\n                    *me.done_first = true;\n                }\n                buf => return Poll::Ready(Ok(buf)),\n            }\n        }\n        me.second.poll_fill_buf(cx)\n    }\n\n    fn consume(self: Pin<&mut Self>, amt: usize) {\n        let me = self.project();\n        if !*me.done_first {\n            me.first.consume(amt)\n        } else {\n            me.second.consume(amt)\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn assert_unpin() {\n        crate::is_unpin::<Chain<(), ()>>();\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "ab0ef33e8b3744699ace14d58f6f1c88f9a6d69c",
    "func": "mod tests {\n    // currently ok\n    #[test]\n    fn insert_do_nothing_postgres() {\n        assert_eq!(\n            Insert::<cake::ActiveModel>::new()\n                .add(cake::Model {\n                    id: 1,\n                    name: \"Apple Pie\".to_owned(),\n                })\n                .on_conflict(OnConflict::new()\n                    .do_nothing()\n                    .to_owned()\n                )\n                .build(DbBackend::Postgres)\n                .to_string(),\n            r#\"INSERT INTO \"cake\" (\"id\", \"name\") VALUES (1, 'Apple Pie') ON CONFLICT DO NOTHING\"#,\n        );\n    }\n\n    //failed to run\n    #[test]\n    fn insert_do_nothing_mysql() {\n        assert_eq!(\n            Insert::<cake::ActiveModel>::new()\n                .add(cake::Model {\n                    id: 1,\n                    name: \"Apple Pie\".to_owned(),\n                })\n                .on_conflict(OnConflict::new()\n                    .do_nothing()\n                    .to_owned()\n                )\n                .build(DbBackend::Mysql)\n                .to_string(),\n            r#\"INSERT IGNORE INTO \"cake\" (\"id\", \"name\") VALUES (1, 'Apple Pie')\"#,\n        );\n    }\n\n    // currently ok\n    #[test]\n    fn insert_do_nothing() {\n        assert_eq!(\n            Insert::<cake::ActiveModel>::new()\n                .add(cake::Model {\n                    id: 1,\n                    name: \"Apple Pie\".to_owned(),\n                })\n                .on_conflict(OnConflict::new()\n                    .do_nothing()\n                    .to_owned()\n                )\n                .build(DbBackend::Sqlite)\n                .to_string(),\n            r#\"INSERT IGNORE INTO \"cake\" (\"id\", \"name\") VALUES (1, 'Apple Pie')\"#,\n        );\n    }\n}"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "124c294edca975efe0b7f529b02cd67d785b4790",
    "func": "//! Run with\n//!\n//! ```not_rust\n//! cargo run -p example-tracing-aka-logging\n//! ```\n\nuse axum::{\n    body::Bytes,\n    extract::MatchedPath,\n    http::{HeaderMap, Request},\n    response::{Html, Response},\n    routing::get,\n    Router,\n};\nuse std::time::Duration;\nuse tokio::net::TcpListener;\nuse tower_http::{classify::ServerErrorsFailureClass, trace::TraceLayer};\nuse tracing::{info_span, Span};\nuse tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};\n\n#[tokio::main]\nasync fn main() {\n    tracing_subscriber::registry()\n        .with(\n            tracing_subscriber::EnvFilter::try_from_default_env().unwrap_or_else(|_| {\n                // axum logs rejections from built-in extractors with the `axum::rejection`\n                // target, at `TRACE` level. `axum::rejection=trace` enables showing those events\n                format!(\n                    \"{}=debug,tower_http=debug,axum::rejection=trace\",\n                    env!(\"CARGO_CRATE_NAME\")\n                )\n                .into()\n            }),\n        )\n        .with(tracing_subscriber::fmt::layer())\n        .init();\n\n    // build our application with a route\n    let app = Router::new()\n        .route(\"/\", get(handler))\n        // `TraceLayer` is provided by tower-http so you have to add that as a dependency.\n        // It provides good defaults but is also very customizable.\n        //\n        // See https://docs.rs/tower-http/0.1.1/tower_http/trace/index.html for more details.\n        //\n        // If you want to customize the behavior using closures here is how.\n        .layer(\n            TraceLayer::new_for_http()\n                .make_span_with(|request: &Request<_>| {\n                    // Log the matched route's path (with placeholders not filled in).\n                    // Use request.uri() or OriginalUri if you want the real path.\n                    let matched_path = request\n                        .extensions()\n                        .get::<MatchedPath>()\n                        .map(MatchedPath::as_str);\n\n                    info_span!(\n                        \"http_request\",\n                        method = ?request.method(),\n                        matched_path,\n                        some_other_field = tracing::field::Empty,\n                    )\n                })\n                .on_request(|_request: &Request<_>, _span: &Span| {\n                    // You can use `_span.record(\"some_other_field\", value)` in one of these\n                    // closures to attach a value to the initially empty field in the info_span\n                    // created above.\n                })\n                .on_response(|_response: &Response, _latency: Duration, _span: &Span| {\n                    // ...\n                })\n                .on_body_chunk(|_chunk: &Bytes, _latency: Duration, _span: &Span| {\n                    // ...\n                })\n                .on_eos(\n                    |_trailers: Option<&HeaderMap>, _stream_duration: Duration, _span: &Span| {\n                        // ...\n                    },\n                )\n                .on_failure(\n                    |_error: ServerErrorsFailureClass, _latency: Duration, _span: &Span| {\n                        // ...\n                    },\n                ),\n        );\n\n    // run it\n    let listener = TcpListener::bind(\"127.0.0.1:3000\").await.unwrap();\n    tracing::debug!(\"listening on {}\", listener.local_addr().unwrap());\n    axum::serve(listener, app).await.unwrap();\n}\n\nasync fn handler() -> Html<&'static str> {\n    Html(\"<h1>Hello, World!</h1>\")\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "594a10b455edb1ba5baf21f62e52fcd0d23068d1",
    "func": "//! Run with\n//!\n//! ```not_rust\n//! cargo run -p example-diesel-postgres\n//! ```\n//!\n//! Checkout the [diesel webpage](https://diesel.rs) for\n//! longer guides about diesel\n//!\n//! Checkout the [crates.io source code](https://github.com/rust-lang/crates.io/)\n//! for a real world application using axum and diesel\n\nuse axum::{\n    extract::State,\n    http::StatusCode,\n    response::Json,\n    routing::{get, post},\n    Router,\n};\nuse diesel::prelude::*;\nuse diesel_migrations::{embed_migrations, EmbeddedMigrations, MigrationHarness};\nuse std::net::SocketAddr;\nuse tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};\n\n// this embeds the migrations into the application binary\n// the migration path is relative to the `CARGO_MANIFEST_DIR`\npub const MIGRATIONS: EmbeddedMigrations = embed_migrations!(\"migrations/\");\n\n// normally part of your generated schema.rs file\ntable! {\n    users (id) {\n        id -> Integer,\n        name -> Text,\n        hair_color -> Nullable<Text>,\n    }\n}\n\n#[derive(serde::Serialize, Selectable, Queryable)]\nstruct User {\n    id: i32,\n    name: String,\n    hair_color: Option<String>,\n}\n\n#[derive(serde::Deserialize, Insertable)]\n#[diesel(table_name = users)]\nstruct NewUser {\n    name: String,\n    hair_color: Option<String>,\n}\n\n#[tokio::main]\nasync fn main() {\n    tracing_subscriber::registry()\n        .with(\n            tracing_subscriber::EnvFilter::try_from_default_env()\n                .unwrap_or_else(|_| format!(\"{}=debug\", env!(\"CARGO_CRATE_NAME\")).into()),\n        )\n        .with(tracing_subscriber::fmt::layer())\n        .init();\n\n    let db_url = std::env::var(\"DATABASE_URL\").unwrap();\n\n    // set up connection pool\n    let manager = deadpool_diesel::postgres::Manager::new(db_url, deadpool_diesel::Runtime::Tokio1);\n    let pool = deadpool_diesel::postgres::Pool::builder(manager)\n        .build()\n        .unwrap();\n\n    // run the migrations on server startup\n    {\n        let conn = pool.get().await.unwrap();\n        conn.interact(|conn| conn.run_pending_migrations(MIGRATIONS).map(|_| ()))\n            .await\n            .unwrap()\n            .unwrap();\n    }\n\n    // build our application with some routes\n    let app = Router::new()\n        .route(\"/user/list\", get(list_users))\n        .route(\"/user/create\", post(create_user))\n        .with_state(pool);\n\n    // run it with hyper\n    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));\n    tracing::debug!(\"listening on {addr}\");\n    let listener = tokio::net::TcpListener::bind(addr).await.unwrap();\n    axum::serve(listener, app).await.unwrap();\n}\n\nasync fn create_user(\n    State(pool): State<deadpool_diesel::postgres::Pool>,\n    Json(new_user): Json<NewUser>,\n) -> Result<Json<User>, (StatusCode, String)> {\n    let conn = pool.get().await.map_err(internal_error)?;\n    let res = conn\n        .interact(|conn| {\n            diesel::insert_into(users::table)\n                .values(new_user)\n                .returning(User::as_returning())\n                .get_result(conn)\n        })\n        .await\n        .map_err(internal_error)?\n        .map_err(internal_error)?;\n    Ok(Json(res))\n}\n\nasync fn list_users(\n    State(pool): State<deadpool_diesel::postgres::Pool>,\n) -> Result<Json<Vec<User>>, (StatusCode, String)> {\n    let conn = pool.get().await.map_err(internal_error)?;\n    let res = conn\n        .interact(|conn| users::table.select(User::as_select()).load(conn))\n        .await\n        .map_err(internal_error)?\n        .map_err(internal_error)?;\n    Ok(Json(res))\n}\n\n/// Utility function for mapping any error into a `500 Internal Server Error`\n/// response.\nfn internal_error<E>(err: E) -> (StatusCode, String)\nwhere\n    E: std::error::Error,\n{\n    (StatusCode::INTERNAL_SERVER_ERROR, err.to_string())\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "680fd4fbe76532881bd34ff64adf4d085230893e",
    "func": "// Adapted from https://github.com/Alexhuszagh/rust-lexical.\n\n//! Algorithms to efficiently convert strings to floats.\n\nuse super::bhcomp::*;\nuse super::cached::*;\nuse super::errors::*;\nuse super::float::ExtendedFloat;\nuse super::num::*;\nuse super::small_powers::*;\n\n// FAST\n// ----\n\n/// Convert mantissa to exact value for a non-base2 power.\n///\n/// Returns the resulting float and if the value can be represented exactly.\npub(crate) fn fast_path<F>(mantissa: u64, exponent: i32) -> Option<F>\nwhere\n    F: Float,\n{\n    // `mantissa >> (F::MANTISSA_SIZE+1) != 0` effectively checks if the\n    // value has a no bits above the hidden bit, which is what we want.\n    let (min_exp, max_exp) = F::exponent_limit();\n    let shift_exp = F::mantissa_limit();\n    let mantissa_size = F::MANTISSA_SIZE + 1;\n    if mantissa == 0 {\n        Some(F::ZERO)\n    } else if mantissa >> mantissa_size != 0 {\n        // Would require truncation of the mantissa.\n        None\n    } else if exponent == 0 {\n        // 0 exponent, same as value, exact representation.\n        let float = F::as_cast(mantissa);\n        Some(float)\n    } else if exponent >= min_exp && exponent <= max_exp {\n        // Value can be exactly represented, return the value.\n        // Do not use powi, since powi can incrementally introduce\n        // error.\n        let float = F::as_cast(mantissa);\n        Some(float.pow10(exponent))\n    } else if exponent >= 0 && exponent <= max_exp + shift_exp {\n        // Check to see if we have a disguised fast-path, where the\n        // number of digits in the mantissa is very small, but and\n        // so digits can be shifted from the exponent to the mantissa.\n        // https://www.exploringbinary.com/fast-path-decimal-to-floating-point-conversion/\n        let small_powers = POW10_64;\n        let shift = exponent - max_exp;\n        let power = small_powers[shift as usize];\n\n        // Compute the product of the power, if it overflows,\n        // prematurely return early, otherwise, if we didn't overshoot,\n        // we can get an exact value.\n        let value = match mantissa.checked_mul(power) {\n            None => return None,\n            Some(value) => value,\n        };\n        if value >> mantissa_size != 0 {\n            None\n        } else {\n            // Use powi, since it's correct, and faster on\n            // the fast-path.\n            let float = F::as_cast(value);\n            Some(float.pow10(max_exp))\n        }\n    } else {\n        // Cannot be exactly represented, exponent too small or too big,\n        // would require truncation.\n        None\n    }\n}\n\n// MODERATE\n// --------\n\n/// Multiply the floating-point by the exponent.\n///\n/// Multiply by pre-calculated powers of the base, modify the extended-\n/// float, and return if new value and if the value can be represented\n/// accurately.\nfn multiply_exponent_extended<F>(fp: &mut ExtendedFloat, exponent: i32, truncated: bool) -> bool\nwhere\n    F: Float,\n{\n    let powers = ExtendedFloat::get_powers();\n    let exponent = exponent.saturating_add(powers.bias);\n    let small_index = exponent % powers.step;\n    let large_index = exponent / powers.step;\n    if exponent < 0 {\n        // Guaranteed underflow (assign 0).\n        fp.mant = 0;\n        true\n    } else if large_index as usize >= powers.large.len() {\n        // Overflow (assign infinity)\n        fp.mant = 1 << 63;\n        fp.exp = 0x7FF;\n        true\n    } else {\n        // Within the valid exponent range, multiply by the large and small\n        // exponents and return the resulting value.\n\n        // Track errors to as a factor of unit in last-precision.\n        let mut errors: u32 = 0;\n        if truncated {\n            errors += u64::error_halfscale();\n        }\n\n        // Multiply by the small power.\n        // Check if we can directly multiply by an integer, if not,\n        // use extended-precision multiplication.\n        match fp\n            .mant\n            .overflowing_mul(powers.get_small_int(small_index as usize))\n        {\n            // Overflow, multiplication unsuccessful, go slow path.\n            (_, true) => {\n                fp.normalize();\n                fp.imul(&powers.get_small(small_index as usize));\n                errors += u64::error_halfscale();\n            }\n            // No overflow, multiplication successful.\n            (mant, false) => {\n                fp.mant = mant;\n                fp.normalize();\n            }\n        }\n\n        // Multiply by the large power\n        fp.imul(&powers.get_large(large_index as usize));\n        if errors > 0 {\n            errors += 1;\n        }\n        errors += u64::error_halfscale();\n\n        // Normalize the floating point (and the errors).\n        let shift = fp.normalize();\n        errors <<= shift;\n\n        u64::error_is_accurate::<F>(errors, fp)\n    }\n}\n\n/// Create a precise native float using an intermediate extended-precision float.\n///\n/// Return the float approximation and if the value can be accurately\n/// represented with mantissa bits of precision.\n#[inline]\npub(crate) fn moderate_path<F>(\n    mantissa: u64,\n    exponent: i32,\n    truncated: bool,\n) -> (ExtendedFloat, bool)\nwhere\n    F: Float,\n{\n    let mut fp = ExtendedFloat {\n        mant: mantissa,\n        exp: 0,\n    };\n    let valid = multiply_exponent_extended::<F>(&mut fp, exponent, truncated);\n    (fp, valid)\n}\n\n// FALLBACK\n// --------\n\n/// Fallback path when the fast path does not work.\n///\n/// Uses the moderate path, if applicable, otherwise, uses the slow path\n/// as required.\npub(crate) fn fallback_path<F>(\n    integer: &[u8],\n    fraction: &[u8],\n    mantissa: u64,\n    exponent: i32,\n    mantissa_exponent: i32,\n    truncated: bool,\n) -> F\nwhere\n    F: Float,\n{\n    // Moderate path (use an extended 80-bit representation).\n    let (fp, valid) = moderate_path::<F>(mantissa, mantissa_exponent, truncated);\n    if valid {\n        return fp.into_float::<F>();\n    }\n\n    // Slow path, fast path didn't work.\n    let b = fp.into_downward_float::<F>();\n    if b.is_special() {\n        // We have a non-finite number, we get to leave early.\n        b\n    } else {\n        bhcomp(b, integer, fraction, exponent)\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "43d6536a1962fb96421ca4c505f80cffca679a2b",
    "func": "#![allow(unused_imports, dead_code)]\n\npub mod common;\n\npub use common::{features::*, setup::*, TestContext};\nuse pretty_assertions::assert_eq;\nuse sea_orm::{entity::prelude::*, entity::*, DatabaseConnection};\nuse serde_json::json;\n\n#[sea_orm_macros::test]\nasync fn main() -> Result<(), DbErr> {\n    let ctx = TestContext::new(\"bakery_chain_schema_uuid_tests\").await;\n    create_tables(&ctx.db).await?;\n    create_and_update_metadata(&ctx.db).await?;\n    insert_metadata(&ctx.db).await?;\n    ctx.delete().await;\n\n    Ok(())\n}\n\npub async fn insert_metadata(db: &DatabaseConnection) -> Result<(), DbErr> {\n    let metadata = metadata::Model {\n        uuid: Uuid::new_v4(),\n        ty: \"Type\".to_owned(),\n        key: \"markup\".to_owned(),\n        value: \"1.18\".to_owned(),\n        bytes: vec![1, 2, 3],\n        date: Some(Date::from_ymd_opt(2021, 9, 27).unwrap()),\n        time: Some(Time::from_hms_opt(11, 32, 55).unwrap()),\n    };\n\n    let result = metadata.clone().into_active_model().insert(db).await?;\n\n    assert_eq!(result, metadata);\n\n    let json = metadata::Entity::find()\n        .filter(metadata::Column::Uuid.eq(metadata.uuid))\n        .into_json()\n        .one(db)\n        .await?;\n\n    assert_eq!(\n        json,\n        Some(json!({\n            \"uuid\": metadata.uuid,\n            \"type\": metadata.ty,\n            \"key\": metadata.key,\n            \"value\": metadata.value,\n            \"bytes\": metadata.bytes,\n            \"date\": metadata.date,\n            \"time\": metadata.time,\n        }))\n    );\n\n    Ok(())\n}\n\npub async fn create_and_update_metadata(db: &DatabaseConnection) -> Result<(), DbErr> {\n    let metadata = metadata::Model {\n        uuid: Uuid::new_v4(),\n        ty: \"Type\".to_owned(),\n        key: \"markup\".to_owned(),\n        value: \"1.18\".to_owned(),\n        bytes: vec![1, 2, 3],\n        date: Some(Date::from_ymd_opt(2021, 9, 27).unwrap()),\n        time: Some(Time::from_hms_opt(11, 32, 55).unwrap()),\n    };\n\n    let res = Metadata::insert(metadata.clone().into_active_model())\n        .exec(db)\n        .await?;\n\n    assert_eq!(Metadata::find().one(db).await?, Some(metadata.clone()));\n\n    assert_eq!(res.last_insert_id, metadata.uuid);\n\n    let update_res = Metadata::update(metadata::ActiveModel {\n        value: Set(\"0.22\".to_owned()),\n        ..metadata.clone().into_active_model()\n    })\n    .filter(metadata::Column::Uuid.eq(Uuid::default()))\n    .exec(db)\n    .await;\n\n    assert_eq!(update_res, Err(DbErr::RecordNotUpdated));\n\n    Ok(())\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "2f4da6747f548f7b2d1de92dd7bf323ec16b0eed",
    "func": "use diesel::r2d2::R2D2Connection;\nuse diesel::PgConnection;\nuse diesel_migrations::{embed_migrations, EmbeddedMigrations, MigrationHarness};\nuse std::error::Error;\n\npub mod model;\nmod schema;\n// Alias for a pooled connection.\n// pub type Connection = diesel::r2d2::PooledConnection<diesel::r2d2::ConnectionManager<diesel::pg::PgConnection>>;\n\n// Alias for a normal, single, connection.\npub type Connection = PgConnection;\n\npub const MIGRATIONS: EmbeddedMigrations = embed_migrations!(\"migrations\");\n\n/// Runs all pending database migrations.\n///\n/// Will return an error if the database connection is invalid, or if any of the\n/// migrations fail. Otherwise, it returns Ok()\n///\n/// # Errors\n///\n/// * If the database connection is invalid\n/// * If checking for pending database migrations fails\n/// * If any of the database migrations fail\n///\npub fn run_db_migration(\n    conn: &mut Connection,\n) -> Result<(), Box<dyn Error + Send + Sync + 'static>> {\n    // Check DB connection!\n    match conn.ping() {\n        Ok(_) => {}\n        Err(e) => {\n            eprint!(\"[run_db_migration]: Error connecting to database: {}\", e);\n            return Err(Box::new(e));\n        }\n    }\n\n    // Run all pending migrations.\n    match conn.run_pending_migrations(MIGRATIONS) {\n        Ok(_) => Ok(()),\n        Err(e) => {\n            eprint!(\"[run_db_migration]: Error migrating database: {}\", e);\n            Err(e)\n        }\n    }\n}\n\n/// Revert all pending database migrations.\n///\n/// # Arguments\n///\n/// * `conn` - A mutable reference to a `Connection` object.\n///\n/// # Errors\n///\n/// * If there is an error while connecting to the database.\n/// * If there is an error while reverting the database migrations.\n///\npub fn revert_db_migration(\n    conn: &mut Connection,\n) -> Result<(), Box<dyn Error + Send + Sync + 'static>> {\n    // Check DB connection!\n    if conn.ping().is_ok() {\n    } else if let Err(e) = conn.ping() {\n        eprint!(\"[pg_cmdb]: Error connecting to database: {}\", e);\n        return Err(Box::new(e));\n    }\n\n    // Revert all pending migrations\n    match conn.revert_all_migrations(MIGRATIONS) {\n        Ok(_) => Ok(()),\n        Err(e) => {\n            eprint!(\"[pg_cmdb]: Error reverting database migrations: {}\", e);\n            Err(e)\n        }\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "9457519b174c677454aa27d688a3ed4799bebccf",
    "func": "use std::{\n    borrow::{Borrow, Cow},\n    collections::HashMap,\n    hash::{BuildHasher, Hash, Hasher},\n    mem,\n};\n\nuse tracing::error;\n\nuse crate::{\n    path::PathItem,\n    regex_set::{escape, Regex, RegexSet},\n    IntoPatterns, Patterns, Resource, ResourcePath,\n};\n\nconst MAX_DYNAMIC_SEGMENTS: usize = 16;\n\n/// Regex flags to allow '.' in regex to match '\\n'\n///\n/// See the docs under: https://docs.rs/regex/1/regex/#grouping-and-flags\nconst REGEX_FLAGS: &str = \"(?s-m)\";\n\n/// Describes the set of paths that match to a resource.\n///\n/// `ResourceDef`s are effectively a way to transform the a custom resource pattern syntax into\n/// suitable regular expressions from which to check matches with paths and capture portions of a\n/// matched path into variables. Common cases are on a fast path that avoids going through the\n/// regex engine.\n///\n///\n/// # Pattern Format and Matching Behavior\n/// Resource pattern is defined as a string of zero or more _segments_ where each segment is\n/// preceded by a slash `/`.\n///\n/// This means that pattern string __must__ either be empty or begin with a slash (`/`). This also\n/// implies that a trailing slash in pattern defines an empty segment. For example, the pattern\n/// `\"/user/\"` has two segments: `[\"user\", \"\"]`\n///\n/// A key point to understand is that `ResourceDef` matches segments, not strings. Segments are\n/// matched individually. For example, the pattern `/user/` is not considered a prefix for the path\n/// `/user/123/456`, because the second segment doesn't match: `[\"user\", \"\"]`\n/// vs `[\"user\", \"123\", \"456\"]`.\n///\n/// This definition is consistent with the definition of absolute URL path in\n/// [RFC 3986 \u00a73.3](https://datatracker.ietf.org/doc/html/rfc3986#section-3.3)\n///\n///\n/// # Static Resources\n/// A static resource is the most basic type of definition. Pass a pattern to [new][Self::new].\n/// Conforming paths must match the pattern exactly.\n///\n/// ## Examples\n/// ```\n/// # use actix_router::ResourceDef;\n/// let resource = ResourceDef::new(\"/home\");\n///\n/// assert!(resource.is_match(\"/home\"));\n///\n/// assert!(!resource.is_match(\"/home/\"));\n/// assert!(!resource.is_match(\"/home/new\"));\n/// assert!(!resource.is_match(\"/homes\"));\n/// assert!(!resource.is_match(\"/search\"));\n/// ```\n///\n/// # Dynamic Segments\n/// Also known as \"path parameters\". Resources can define sections of a pattern that be extracted\n/// from a conforming path, if it conforms to (one of) the resource pattern(s).\n///\n/// The marker for a dynamic segment is curly braces wrapping an identifier. For example,\n/// `/user/{id}` would match paths like `/user/123` or `/user/james` and be able to extract the user\n/// IDs \"123\" and \"james\", respectively.\n///\n/// However, this resource pattern (`/user/{id}`) would, not cover `/user/123/stars` (unless\n/// constructed as a prefix; see next section) since the default pattern for segments matches all\n/// characters until it finds a `/` character (or the end of the path). Custom segment patterns are\n/// covered further down.\n///\n/// Dynamic segments do not need to be delimited by `/` characters, they can be defined within a\n/// path segment. For example, `/rust-is-{opinion}` can match the paths `/rust-is-cool` and\n/// `/rust-is-hard`.\n///\n/// For information on capturing segment values from paths or other custom resource types,\n/// see [`capture_match_info`][Self::capture_match_info]\n/// and [`capture_match_info_fn`][Self::capture_match_info_fn].\n///\n/// A resource definition can contain at most 16 dynamic segments.\n///\n/// ## Examples\n/// ```\n/// use actix_router::{Path, ResourceDef};\n///\n/// let resource = ResourceDef::prefix(\"/user/{id}\");\n///\n/// assert!(resource.is_match(\"/user/123\"));\n/// assert!(!resource.is_match(\"/user\"));\n/// assert!(!resource.is_match(\"/user/\"));\n///\n/// let mut path = Path::new(\"/user/123\");\n/// resource.capture_match_info(&mut path);\n/// assert_eq!(path.get(\"id\").unwrap(), \"123\");\n/// ```\n///\n/// # Prefix Resources\n/// A prefix resource is defined as pattern that can match just the start of a path, up to a\n/// segment boundary.\n///\n/// Prefix patterns with a trailing slash may have an unexpected, though correct, behavior.\n/// They define and therefore require an empty segment in order to match. It is easier to understand\n/// this behavior after reading the [matching behavior section]. Examples are given below.\n///\n/// The empty pattern (`\"\"`), as a prefix, matches any path.\n///\n/// Prefix resources can contain dynamic segments.\n///\n/// ## Examples\n/// ```\n/// # use actix_router::ResourceDef;\n/// let resource = ResourceDef::prefix(\"/home\");\n/// assert!(resource.is_match(\"/home\"));\n/// assert!(resource.is_match(\"/home/new\"));\n/// assert!(!resource.is_match(\"/homes\"));\n///\n/// // prefix pattern with a trailing slash\n/// let resource = ResourceDef::prefix(\"/user/{id}/\");\n/// assert!(resource.is_match(\"/user/123/\"));\n/// assert!(resource.is_match(\"/user/123//stars\"));\n/// assert!(!resource.is_match(\"/user/123/stars\"));\n/// assert!(!resource.is_match(\"/user/123\"));\n/// ```\n///\n/// # Custom Regex Segments\n/// Dynamic segments can be customised to only match a specific regular expression. It can be\n/// helpful to do this if resource definitions would otherwise conflict and cause one to\n/// be inaccessible.\n///\n/// The regex used when capturing segment values can be specified explicitly using this syntax:\n/// `{name:regex}`. For example, `/user/{id:\\d+}` will only match paths where the user ID\n/// is numeric.\n///\n/// The regex could potentially match multiple segments. If this is not wanted, then care must be\n/// taken to avoid matching a slash `/`. It is guaranteed, however, that the match ends at a\n/// segment boundary; the pattern `r\"(/|$)` is always appended to the regex.\n///\n/// By default, dynamic segments use this regex: `[^/]+`. This shows why it is the case, as shown in\n/// the earlier section, that segments capture a slice of the path up to the next `/` character.\n///\n/// Custom regex segments can be used in static and prefix resource definition variants.\n///\n/// ## Examples\n/// ```\n/// # use actix_router::ResourceDef;\n/// let resource = ResourceDef::new(r\"/user/{id:\\d+}\");\n/// assert!(resource.is_match(\"/user/123\"));\n/// assert!(resource.is_match(\"/user/314159\"));\n/// assert!(!resource.is_match(\"/user/abc\"));\n/// ```\n///\n/// # Tail Segments\n/// As a shortcut to defining a custom regex for matching _all_ remaining characters (not just those\n/// up until a `/` character), there is a special pattern to match (and capture) the remaining\n/// path portion.\n///\n/// To do this, use the segment pattern: `{name}*`. Since a tail segment also has a name, values are\n/// extracted in the same way as non-tail dynamic segments.\n///\n/// ## Examples\n/// ```\n/// # use actix_router::{Path, ResourceDef};\n/// let resource = ResourceDef::new(\"/blob/{tail}*\");\n/// assert!(resource.is_match(\"/blob/HEAD/Cargo.toml\"));\n/// assert!(resource.is_match(\"/blob/HEAD/README.md\"));\n///\n/// let mut path = Path::new(\"/blob/main/LICENSE\");\n/// resource.capture_match_info(&mut path);\n/// assert_eq!(path.get(\"tail\").unwrap(), \"main/LICENSE\");\n/// ```\n///\n/// # Multi-Pattern Resources\n/// For resources that can map to multiple distinct paths, it may be suitable to use\n/// multi-pattern resources by passing an array/vec to [`new`][Self::new]. They will be combined\n/// into a regex set which is usually quicker to check matches on than checking each\n/// pattern individually.\n///\n/// Multi-pattern resources can contain dynamic segments just like single pattern ones.\n/// However, take care to use consistent and semantically-equivalent segment names; it could affect\n/// expectations in the router using these definitions and cause runtime panics.\n///\n/// ## Examples\n/// ```\n/// # use actix_router::ResourceDef;\n/// let resource = ResourceDef::new([\"/home\", \"/index\"]);\n/// assert!(resource.is_match(\"/home\"));\n/// assert!(resource.is_match(\"/index\"));\n/// ```\n///\n/// # Trailing Slashes\n/// It should be noted that this library takes no steps to normalize intra-path or trailing slashes.\n/// As such, all resource definitions implicitly expect a pre-processing step to normalize paths if\n/// you wish to accommodate \"recoverable\" path errors. Below are several examples of resource-path\n/// pairs that would not be compatible.\n///\n/// ## Examples\n/// ```\n/// # use actix_router::ResourceDef;\n/// assert!(!ResourceDef::new(\"/root\").is_match(\"/root/\"));\n/// assert!(!ResourceDef::new(\"/root/\").is_match(\"/root\"));\n/// assert!(!ResourceDef::prefix(\"/root/\").is_match(\"/root\"));\n/// ```\n///\n/// [matching behavior section]: #pattern-format-and-matching-behavior\n#[derive(Clone, Debug)]\npub struct ResourceDef {\n    id: u16,\n\n    /// Optional name of resource.\n    name: Option<String>,\n\n    /// Pattern that generated the resource definition.\n    patterns: Patterns,\n\n    is_prefix: bool,\n\n    /// Pattern type.\n    pat_type: PatternType,\n\n    /// List of segments that compose the pattern, in order.\n    segments: Vec<PatternSegment>,\n}\n\n#[derive(Debug, Clone, PartialEq)]\nenum PatternSegment {\n    /// Literal slice of pattern.\n    Const(String),\n\n    /// Name of dynamic segment.\n    Var(String),\n}\n\n#[derive(Debug, Clone)]\n#[allow(clippy::large_enum_variant)]\nenum PatternType {\n    /// Single constant/literal segment.\n    Static(String),\n\n    /// Single regular expression and list of dynamic segment names.\n    Dynamic(Regex, Vec<&'static str>),\n\n    /// Regular expression set and list of component expressions plus dynamic segment names.\n    DynamicSet(RegexSet, Vec<(Regex, Vec<&'static str>)>),\n}\n\nimpl ResourceDef {\n    /// Constructs a new resource definition from patterns.\n    ///\n    /// Multi-pattern resources can be constructed by providing a slice (or vec) of patterns.\n    ///\n    /// # Panics\n    /// Panics if any path patterns are malformed.\n    ///\n    /// # Examples\n    /// ```\n    /// use actix_router::ResourceDef;\n    ///\n    /// let resource = ResourceDef::new(\"/user/{id}\");\n    /// assert!(resource.is_match(\"/user/123\"));\n    /// assert!(!resource.is_match(\"/user/123/stars\"));\n    /// assert!(!resource.is_match(\"user/1234\"));\n    /// assert!(!resource.is_match(\"/foo\"));\n    ///\n    /// let resource = ResourceDef::new([\"/profile\", \"/user/{id}\"]);\n    /// assert!(resource.is_match(\"/profile\"));\n    /// assert!(resource.is_match(\"/user/123\"));\n    /// assert!(!resource.is_match(\"user/123\"));\n    /// assert!(!resource.is_match(\"/foo\"));\n    /// ```\n    pub fn new<T: IntoPatterns>(paths: T) -> Self {\n        Self::construct(paths, false)\n    }\n\n    /// Constructs a new resource definition using a pattern that performs prefix matching.\n    ///\n    /// More specifically, the regular expressions generated for matching are different when using\n    /// this method vs using `new`; they will not be appended with the `$` meta-character that\n    /// matches the end of an input.\n    ///\n    /// Although it will compile and run correctly, it is meaningless to construct a prefix\n    /// resource definition with a tail segment; use [`new`][Self::new] in this case.\n    ///\n    /// # Panics\n    /// Panics if path pattern is malformed.\n    ///\n    /// # Examples\n    /// ```\n    /// use actix_router::ResourceDef;\n    ///\n    /// let resource = ResourceDef::prefix(\"/user/{id}\");\n    /// assert!(resource.is_match(\"/user/123\"));\n    /// assert!(resource.is_match(\"/user/123/stars\"));\n    /// assert!(!resource.is_match(\"user/123\"));\n    /// assert!(!resource.is_match(\"user/123/stars\"));\n    /// assert!(!resource.is_match(\"/foo\"));\n    /// ```\n    pub fn prefix<T: IntoPatterns>(paths: T) -> Self {\n        ResourceDef::construct(paths, true)\n    }\n\n    /// Constructs a new resource definition using a string pattern that performs prefix matching,\n    /// ensuring a leading `/` if pattern is not empty.\n    ///\n    /// # Panics\n    /// Panics if path pattern is malformed.\n    ///\n    /// # Examples\n    /// ```\n    /// use actix_router::ResourceDef;\n    ///\n    /// let resource = ResourceDef::root_prefix(\"user/{id}\");\n    ///\n    /// assert_eq!(&resource, &ResourceDef::prefix(\"/user/{id}\"));\n    /// assert_eq!(&resource, &ResourceDef::root_prefix(\"/user/{id}\"));\n    /// assert_ne!(&resource, &ResourceDef::new(\"user/{id}\"));\n    /// assert_ne!(&resource, &ResourceDef::new(\"/user/{id}\"));\n    ///\n    /// assert!(resource.is_match(\"/user/123\"));\n    /// assert!(!resource.is_match(\"user/123\"));\n    /// ```\n    pub fn root_prefix(path: &str) -> Self {\n        ResourceDef::prefix(insert_slash(path).into_owned())\n    }\n\n    /// Returns a numeric resource ID.\n    ///\n    /// If not explicitly set using [`set_id`][Self::set_id], this will return `0`.\n    ///\n    /// # Examples\n    /// ```\n    /// # use actix_router::ResourceDef;\n    /// let mut resource = ResourceDef::new(\"/root\");\n    /// assert_eq!(resource.id(), 0);\n    ///\n    /// resource.set_id(42);\n    /// assert_eq!(resource.id(), 42);\n    /// ```\n    pub fn id(&self) -> u16 {\n        self.id\n    }\n\n    /// Set numeric resource ID.\n    ///\n    /// # Examples\n    /// ```\n    /// # use actix_router::ResourceDef;\n    /// let mut resource = ResourceDef::new(\"/root\");\n    /// resource.set_id(42);\n    /// assert_eq!(resource.id(), 42);\n    /// ```\n    pub fn set_id(&mut self, id: u16) {\n        self.id = id;\n    }\n\n    /// Returns resource definition name, if set.\n    ///\n    /// # Examples\n    /// ```\n    /// # use actix_router::ResourceDef;\n    /// let mut resource = ResourceDef::new(\"/root\");\n    /// assert!(resource.name().is_none());\n    ///\n    /// resource.set_name(\"root\");\n    /// assert_eq!(resource.name().unwrap(), \"root\");\n    pub fn name(&self) -> Option<&str> {\n        self.name.as_deref()\n    }\n\n    /// Assigns a new name to the resource.\n    ///\n    /// # Panics\n    /// Panics if `name` is an empty string.\n    ///\n    /// # Examples\n    /// ```\n    /// # use actix_router::ResourceDef;\n    /// let mut resource = ResourceDef::new(\"/root\");\n    /// resource.set_name(\"root\");\n    /// assert_eq!(resource.name().unwrap(), \"root\");\n    /// ```\n    pub fn set_name(&mut self, name: impl Into<String>) {\n        let name = name.into();\n\n        assert!(!name.is_empty(), \"resource name should not be empty\");\n\n        self.name = Some(name)\n    }\n\n    /// Returns `true` if pattern type is prefix.\n    ///\n    /// # Examples\n    /// ```\n    /// # use actix_router::ResourceDef;\n    /// assert!(ResourceDef::prefix(\"/user\").is_prefix());\n    /// assert!(!ResourceDef::new(\"/user\").is_prefix());\n    /// ```\n    pub fn is_prefix(&self) -> bool {\n        self.is_prefix\n    }\n\n    /// Returns the pattern string that generated the resource definition.\n    ///\n    /// If definition is constructed with multiple patterns, the first pattern is returned. To get\n    /// all patterns, use [`patterns_iter`][Self::pattern_iter]. If resource has 0 patterns,\n    /// returns `None`.\n    ///\n    /// # Examples\n    /// ```\n    /// # use actix_router::ResourceDef;\n    /// let mut resource = ResourceDef::new(\"/user/{id}\");\n    /// assert_eq!(resource.pattern().unwrap(), \"/user/{id}\");\n    ///\n    /// let mut resource = ResourceDef::new([\"/profile\", \"/user/{id}\"]);\n    /// assert_eq!(resource.pattern(), Some(\"/profile\"));\n    pub fn pattern(&self) -> Option<&str> {\n        match &self.patterns {\n            Patterns::Single(pattern) => Some(pattern.as_str()),\n            Patterns::List(patterns) => patterns.first().map(AsRef::as_ref),\n        }\n    }\n\n    /// Returns iterator of pattern strings that generated the resource definition.\n    ///\n    /// # Examples\n    /// ```\n    /// # use actix_router::ResourceDef;\n    /// let mut resource = ResourceDef::new(\"/root\");\n    /// let mut iter = resource.pattern_iter();\n    /// assert_eq!(iter.next().unwrap(), \"/root\");\n    /// assert!(iter.next().is_none());\n    ///\n    /// let mut resource = ResourceDef::new([\"/root\", \"/backup\"]);\n    /// let mut iter = resource.pattern_iter();\n    /// assert_eq!(iter.next().unwrap(), \"/root\");\n    /// assert_eq!(iter.next().unwrap(), \"/backup\");\n    /// assert!(iter.next().is_none());\n    pub fn pattern_iter(&self) -> impl Iterator<Item = &str> {\n        struct PatternIter<'a> {\n            patterns: &'a Patterns,\n            list_idx: usize,\n            done: bool,\n        }\n\n        impl<'a> Iterator for PatternIter<'a> {\n            type Item = &'a str;\n\n            fn next(&mut self) -> Option<Self::Item> {\n                match &self.patterns {\n                    Patterns::Single(pattern) => {\n                        if self.done {\n                            return None;\n                        }\n\n                        self.done = true;\n                        Some(pattern.as_str())\n                    }\n                    Patterns::List(patterns) if patterns.is_empty() => None,\n                    Patterns::List(patterns) => match patterns.get(self.list_idx) {\n                        Some(pattern) => {\n                            self.list_idx += 1;\n                            Some(pattern.as_str())\n                        }\n                        None => {\n                            // fast path future call\n                            self.done = true;\n                            None\n                        }\n                    },\n                }\n            }\n\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                match &self.patterns {\n                    Patterns::Single(_) => (1, Some(1)),\n                    Patterns::List(patterns) => (patterns.len(), Some(patterns.len())),\n                }\n            }\n        }\n\n        PatternIter {\n            patterns: &self.patterns,\n            list_idx: 0,\n            done: false,\n        }\n    }\n\n    /// Joins two resources.\n    ///\n    /// Resulting resource is prefix if `other` is prefix.\n    ///\n    /// # Examples\n    /// ```\n    /// # use actix_router::ResourceDef;\n    /// let joined = ResourceDef::prefix(\"/root\").join(&ResourceDef::prefix(\"/seg\"));\n    /// assert_eq!(joined, ResourceDef::prefix(\"/root/seg\"));\n    /// ```\n    pub fn join(&self, other: &ResourceDef) -> ResourceDef {\n        let patterns = self\n            .pattern_iter()\n            .flat_map(move |this| other.pattern_iter().map(move |other| (this, other)))\n            .map(|(this, other)| {\n                let mut pattern = String::with_capacity(this.len() + other.len());\n                pattern.push_str(this);\n                pattern.push_str(other);\n                pattern\n            })\n            .collect::<Vec<_>>();\n\n        match patterns.len() {\n            1 => ResourceDef::construct(&patterns[0], other.is_prefix()),\n            _ => ResourceDef::construct(patterns, other.is_prefix()),\n        }\n    }\n\n    /// Returns `true` if `path` matches this resource.\n    ///\n    /// The behavior of this method depends on how the `ResourceDef` was constructed. For example,\n    /// static resources will not be able to match as many paths as dynamic and prefix resources.\n    /// See [`ResourceDef`] struct docs for details on resource definition types.\n    ///\n    /// This method will always agree with [`find_match`][Self::find_match] on whether the path\n    /// matches or not.\n    ///\n    /// # Examples\n    /// ```\n    /// use actix_router::ResourceDef;\n    ///\n    /// // static resource\n    /// let resource = ResourceDef::new(\"/user\");\n    /// assert!(resource.is_match(\"/user\"));\n    /// assert!(!resource.is_match(\"/users\"));\n    /// assert!(!resource.is_match(\"/user/123\"));\n    /// assert!(!resource.is_match(\"/foo\"));\n    ///\n    /// // dynamic resource\n    /// let resource = ResourceDef::new(\"/user/{user_id}\");\n    /// assert!(resource.is_match(\"/user/123\"));\n    /// assert!(!resource.is_match(\"/user/123/stars\"));\n    ///\n    /// // prefix resource\n    /// let resource = ResourceDef::prefix(\"/root\");\n    /// assert!(resource.is_match(\"/root\"));\n    /// assert!(resource.is_match(\"/root/leaf\"));\n    /// assert!(!resource.is_match(\"/roots\"));\n    ///\n    /// // more examples are shown in the `ResourceDef` struct docs\n    /// ```\n    #[inline]\n    pub fn is_match(&self, path: &str) -> bool {\n        // this function could be expressed as:\n        // `self.find_match(path).is_some()`\n        // but this skips some checks and uses potentially faster regex methods\n\n        match &self.pat_type {\n            PatternType::Static(pattern) => self.static_match(pattern, path).is_some(),\n            PatternType::Dynamic(re, _) => re.is_match(path),\n            PatternType::DynamicSet(re, _) => re.is_match(path),\n        }\n    }\n\n    /// Tries to match `path` to this resource, returning the position in the path where the\n    /// match ends.\n    ///\n    /// This method will always agree with [`is_match`][Self::is_match] on whether the path matches\n    /// or not.\n    ///\n    /// # Examples\n    /// ```\n    /// use actix_router::ResourceDef;\n    ///\n    /// // static resource\n    /// let resource = ResourceDef::new(\"/user\");\n    /// assert_eq!(resource.find_match(\"/user\"), Some(5));\n    /// assert!(resource.find_match(\"/user/\").is_none());\n    /// assert!(resource.find_match(\"/user/123\").is_none());\n    /// assert!(resource.find_match(\"/foo\").is_none());\n    ///\n    /// // constant prefix resource\n    /// let resource = ResourceDef::prefix(\"/user\");\n    /// assert_eq!(resource.find_match(\"/user\"), Some(5));\n    /// assert_eq!(resource.find_match(\"/user/\"), Some(5));\n    /// assert_eq!(resource.find_match(\"/user/123\"), Some(5));\n    ///\n    /// // dynamic prefix resource\n    /// let resource = ResourceDef::prefix(\"/user/{id}\");\n    /// assert_eq!(resource.find_match(\"/user/123\"), Some(9));\n    /// assert_eq!(resource.find_match(\"/user/1234/\"), Some(10));\n    /// assert_eq!(resource.find_match(\"/user/12345/stars\"), Some(11));\n    /// assert!(resource.find_match(\"/user/\").is_none());\n    ///\n    /// // multi-pattern resource\n    /// let resource = ResourceDef::new([\"/user/{id}\", \"/profile/{id}\"]);\n    /// assert_eq!(resource.find_match(\"/user/123\"), Some(9));\n    /// assert_eq!(resource.find_match(\"/profile/1234\"), Some(13));\n    /// ```\n    pub fn find_match(&self, path: &str) -> Option<usize> {\n        match &self.pat_type {\n            PatternType::Static(pattern) => self.static_match(pattern, path),\n\n            PatternType::Dynamic(re, _) => Some(re.captures(path)?[1].len()),\n\n            PatternType::DynamicSet(re, params) => {\n                let idx = re.first_match_idx(path)?;\n                let (ref pattern, _) = params[idx];\n                Some(pattern.captures(path)?[1].len())\n            }\n        }\n    }\n\n    /// Collects dynamic segment values into `resource`.\n    ///\n    /// Returns `true` if `path` matches this resource.\n    ///\n    /// # Examples\n    /// ```\n    /// use actix_router::{Path, ResourceDef};\n    ///\n    /// let resource = ResourceDef::prefix(\"/user/{id}\");\n    /// let mut path = Path::new(\"/user/123/stars\");\n    /// assert!(resource.capture_match_info(&mut path));\n    /// assert_eq!(path.get(\"id\").unwrap(), \"123\");\n    /// assert_eq!(path.unprocessed(), \"/stars\");\n    ///\n    /// let resource = ResourceDef::new(\"/blob/{path}*\");\n    /// let mut path = Path::new(\"/blob/HEAD/Cargo.toml\");\n    /// assert!(resource.capture_match_info(&mut path));\n    /// assert_eq!(path.get(\"path\").unwrap(), \"HEAD/Cargo.toml\");\n    /// assert_eq!(path.unprocessed(), \"\");\n    /// ```\n    pub fn capture_match_info<R: Resource>(&self, resource: &mut R) -> bool {\n        self.capture_match_info_fn(resource, |_| true)\n    }\n\n    /// Collects dynamic segment values into `resource` after matching paths and executing\n    /// check function.\n    ///\n    /// The check function is given a reference to the passed resource and optional arbitrary data.\n    /// This is useful if you want to conditionally match on some non-path related aspect of the\n    /// resource type.\n    ///\n    /// Returns `true` if resource path matches this resource definition _and_ satisfies the\n    /// given check function.\n    ///\n    /// # Examples\n    /// ```\n    /// use actix_router::{Path, ResourceDef};\n    ///\n    /// fn try_match(resource: &ResourceDef, path: &mut Path<&str>) -> bool {\n    ///     let admin_allowed = std::env::var(\"ADMIN_ALLOWED\").is_ok();\n    ///\n    ///     resource.capture_match_info_fn(\n    ///         path,\n    ///         // when env var is not set, reject when path contains \"admin\"\n    ///         |path| !(!admin_allowed && path.as_str().contains(\"admin\")),\n    ///     )\n    /// }\n    ///\n    /// let resource = ResourceDef::prefix(\"/user/{id}\");\n    ///\n    /// // path matches; segment values are collected into path\n    /// let mut path = Path::new(\"/user/james/stars\");\n    /// assert!(try_match(&resource, &mut path));\n    /// assert_eq!(path.get(\"id\").unwrap(), \"james\");\n    /// assert_eq!(path.unprocessed(), \"/stars\");\n    ///\n    /// // path matches but fails check function; no segments are collected\n    /// let mut path = Path::new(\"/user/admin/stars\");\n    /// assert!(!try_match(&resource, &mut path));\n    /// assert_eq!(path.unprocessed(), \"/user/admin/stars\");\n    /// ```\n    pub fn capture_match_info_fn<R, F>(&self, resource: &mut R, check_fn: F) -> bool\n    where\n        R: Resource,\n        F: FnOnce(&R) -> bool,\n    {\n        let mut segments = <[PathItem; MAX_DYNAMIC_SEGMENTS]>::default();\n        let path = resource.resource_path();\n        let path_str = path.unprocessed();\n\n        let (matched_len, matched_vars) = match &self.pat_type {\n            PatternType::Static(pattern) => match self.static_match(pattern, path_str) {\n                Some(len) => (len, None),\n                None => return false,\n            },\n\n            PatternType::Dynamic(re, names) => {\n                let captures = match re.captures(path.unprocessed()) {\n                    Some(captures) => captures,\n                    _ => return false,\n                };\n\n                for (no, name) in names.iter().enumerate() {\n                    if let Some(m) = captures.name(name) {\n                        segments[no] = PathItem::Segment(m.start() as u16, m.end() as u16);\n                    } else {\n                        error!(\"Dynamic path match but not all segments found: {}\", name);\n                        return false;\n                    }\n                }\n\n                (captures[1].len(), Some(names))\n            }\n\n            PatternType::DynamicSet(re, params) => {\n                let path = path.unprocessed();\n                let (pattern, names) = match re.first_match_idx(path) {\n                    Some(idx) => &params[idx],\n                    _ => return false,\n                };\n\n                let captures = match pattern.captures(path.path()) {\n                    Some(captures) => captures,\n                    _ => return false,\n                };\n\n                for (no, name) in names.iter().enumerate() {\n                    if let Some(m) = captures.name(name) {\n                        segments[no] = PathItem::Segment(m.start() as u16, m.end() as u16);\n                    } else {\n                        error!(\"Dynamic path match but not all segments found: {}\", name);\n                        return false;\n                    }\n                }\n\n                (captures[1].len(), Some(names))\n            }\n        };\n\n        if !check_fn(resource) {\n            return false;\n        }\n\n        // Modify `path` to skip matched part and store matched segments\n        let path = resource.resource_path();\n\n        if let Some(vars) = matched_vars {\n            for i in 0..vars.len() {\n                path.add(vars[i], mem::take(&mut segments[i]));\n            }\n        }\n\n        path.skip(matched_len as u16);\n\n        true\n    }\n\n    /// Assembles resource path using a closure that maps variable segment names to values.\n    fn build_resource_path<F, I>(&self, path: &mut String, mut vars: F) -> bool\n    where\n        F: FnMut(&str) -> Option<I>,\n        I: AsRef<str>,\n    {\n        for segment in &self.segments {\n            match segment {\n                PatternSegment::Const(val) => path.push_str(val),\n                PatternSegment::Var(name) => match vars(name) {\n                    Some(val) => path.push_str(val.as_ref()),\n                    _ => return false,\n                },\n            }\n        }\n\n        true\n    }\n\n    /// Assembles full resource path from iterator of dynamic segment values.\n    ///\n    /// Returns `true` on success.\n    ///\n    /// For multi-pattern resources, the first pattern is used under the assumption that it would be\n    /// equivalent to any other choice.\n    ///\n    /// # Examples\n    /// ```\n    /// # use actix_router::ResourceDef;\n    /// let mut s = String::new();\n    /// let resource = ResourceDef::new(\"/user/{id}/post/{title}\");\n    ///\n    /// assert!(resource.resource_path_from_iter(&mut s, &[\"123\", \"my-post\"]));\n    /// assert_eq!(s, \"/user/123/post/my-post\");\n    /// ```\n    pub fn resource_path_from_iter<I>(&self, path: &mut String, values: I) -> bool\n    where\n        I: IntoIterator,\n        I::Item: AsRef<str>,\n    {\n        let mut iter = values.into_iter();\n        self.build_resource_path(path, |_| iter.next())\n    }\n\n    /// Assembles resource path from map of dynamic segment values.\n    ///\n    /// Returns `true` on success.\n    ///\n    /// For multi-pattern resources, the first pattern is used under the assumption that it would be\n    /// equivalent to any other choice.\n    ///\n    /// # Examples\n    /// ```\n    /// # use std::collections::HashMap;\n    /// # use actix_router::ResourceDef;\n    /// let mut s = String::new();\n    /// let resource = ResourceDef::new(\"/user/{id}/post/{title}\");\n    ///\n    /// let mut map = HashMap::new();\n    /// map.insert(\"id\", \"123\");\n    /// map.insert(\"title\", \"my-post\");\n    ///\n    /// assert!(resource.resource_path_from_map(&mut s, &map));\n    /// assert_eq!(s, \"/user/123/post/my-post\");\n    /// ```\n    pub fn resource_path_from_map<K, V, S>(\n        &self,\n        path: &mut String,\n        values: &HashMap<K, V, S>,\n    ) -> bool\n    where\n        K: Borrow<str> + Eq + Hash,\n        V: AsRef<str>,\n        S: BuildHasher,\n    {\n        self.build_resource_path(path, |name| values.get(name))\n    }\n\n    /// Returns true if `prefix` acts as a proper prefix (i.e., separated by a slash) in `path`.\n    fn static_match(&self, pattern: &str, path: &str) -> Option<usize> {\n        let rem = path.strip_prefix(pattern)?;\n\n        match self.is_prefix {\n            // resource is not a prefix so an exact match is needed\n            false if rem.is_empty() => Some(pattern.len()),\n\n            // resource is a prefix so rem should start with a path delimiter\n            true if rem.is_empty() || rem.starts_with('/') => Some(pattern.len()),\n\n            // otherwise, no match\n            _ => None,\n        }\n    }\n\n    fn construct<T: IntoPatterns>(paths: T, is_prefix: bool) -> Self {\n        let patterns = paths.patterns();\n\n        let (pat_type, segments) = match &patterns {\n            Patterns::Single(pattern) => ResourceDef::parse(pattern, is_prefix, false),\n\n            // since zero length pattern sets are possible\n            // just return a useless `ResourceDef`\n            Patterns::List(patterns) if patterns.is_empty() => (\n                PatternType::DynamicSet(RegexSet::empty(), Vec::new()),\n                Vec::new(),\n            ),\n\n            Patterns::List(patterns) => {\n                let mut re_set = Vec::with_capacity(patterns.len());\n                let mut pattern_data = Vec::new();\n                let mut segments = None;\n\n                for pattern in patterns {\n                    match ResourceDef::parse(pattern, is_prefix, true) {\n                        (PatternType::Dynamic(re, names), segs) => {\n                            re_set.push(re.as_str().to_owned());\n                            pattern_data.push((re, names));\n                            segments.get_or_insert(segs);\n                        }\n                        _ => unreachable!(),\n                    }\n                }\n\n                let pattern_re_set = RegexSet::new(re_set);\n                let segments = segments.unwrap_or_default();\n\n                (\n                    PatternType::DynamicSet(pattern_re_set, pattern_data),\n                    segments,\n                )\n            }\n        };\n\n        ResourceDef {\n            id: 0,\n            name: None,\n            patterns,\n            is_prefix,\n            pat_type,\n            segments,\n        }\n    }\n\n    /// Parses a dynamic segment definition from a pattern.\n    ///\n    /// The returned tuple includes:\n    /// - the segment descriptor, either `Var` or `Tail`\n    /// - the segment's regex to check values against\n    /// - the remaining, unprocessed string slice\n    /// - whether the parsed parameter represents a tail pattern\n    ///\n    /// # Panics\n    /// Panics if given patterns does not contain a dynamic segment.\n    fn parse_param(pattern: &str) -> (PatternSegment, String, &str, bool) {\n        const DEFAULT_PATTERN: &str = \"[^/]+\";\n        const DEFAULT_PATTERN_TAIL: &str = \".*\";\n\n        let mut params_nesting = 0usize;\n        let close_idx = pattern\n            .find(|c| match c {\n                '{' => {\n                    params_nesting += 1;\n                    false\n                }\n                '}' => {\n                    params_nesting -= 1;\n                    params_nesting == 0\n                }\n                _ => false,\n            })\n            .unwrap_or_else(|| {\n                panic!(\n                    r#\"pattern \"{}\" contains malformed dynamic segment\"#,\n                    pattern\n                )\n            });\n\n        let (mut param, mut unprocessed) = pattern.split_at(close_idx + 1);\n\n        // remove outer curly brackets\n        param = &param[1..param.len() - 1];\n\n        let tail = unprocessed == \"*\";\n\n        let (name, pattern) = match param.find(':') {\n            Some(idx) => {\n                assert!(!tail, \"custom regex is not supported for tail match\");\n\n                let (name, pattern) = param.split_at(idx);\n                (name, &pattern[1..])\n            }\n            None => (\n                param,\n                if tail {\n                    unprocessed = &unprocessed[1..];\n                    DEFAULT_PATTERN_TAIL\n                } else {\n                    DEFAULT_PATTERN\n                },\n            ),\n        };\n\n        let segment = PatternSegment::Var(name.to_string());\n        let regex = format!(r\"(?P<{}>{})\", &name, &pattern);\n\n        (segment, regex, unprocessed, tail)\n    }\n\n    /// Parse `pattern` using `is_prefix` and `force_dynamic` flags.\n    ///\n    /// Parameters:\n    /// - `is_prefix`: Use `true` if `pattern` should be treated as a prefix; i.e., a conforming\n    ///   path will be a match even if it has parts remaining to process\n    /// - `force_dynamic`: Use `true` to disallow the return of static and prefix segments.\n    ///\n    /// The returned tuple includes:\n    /// - the pattern type detected, either `Static`, `Prefix`, or `Dynamic`\n    /// - a list of segment descriptors from the pattern\n    fn parse(\n        pattern: &str,\n        is_prefix: bool,\n        force_dynamic: bool,\n    ) -> (PatternType, Vec<PatternSegment>) {\n        if !force_dynamic && pattern.find('{').is_none() && !pattern.ends_with('*') {\n            // pattern is static\n            return (\n                PatternType::Static(pattern.to_owned()),\n                vec![PatternSegment::Const(pattern.to_owned())],\n            );\n        }\n\n        let mut unprocessed = pattern;\n        let mut segments = Vec::new();\n        let mut re = format!(\"{}^\", REGEX_FLAGS);\n        let mut dyn_segment_count = 0;\n        let mut has_tail_segment = false;\n\n        while let Some(idx) = unprocessed.find('{') {\n            let (prefix, rem) = unprocessed.split_at(idx);\n\n            segments.push(PatternSegment::Const(prefix.to_owned()));\n            re.push_str(&escape(prefix));\n\n            let (param_pattern, re_part, rem, tail) = Self::parse_param(rem);\n\n            if tail {\n                has_tail_segment = true;\n            }\n\n            segments.push(param_pattern);\n            re.push_str(&re_part);\n\n            unprocessed = rem;\n            dyn_segment_count += 1;\n        }\n\n        if is_prefix && has_tail_segment {\n            // tail segments in prefixes have no defined semantics\n\n            #[cfg(not(test))]\n            tracing::warn!(\n                \"Prefix resources should not have tail segments. \\\n                Use `ResourceDef::new` constructor. \\\n                This may become a panic in the future.\"\n            );\n\n            // panic in tests to make this case detectable\n            #[cfg(test)]\n            panic!(\"prefix resource definitions should not have tail segments\");\n        }\n\n        if unprocessed.ends_with('*') {\n            // unnamed tail segment\n\n            #[cfg(not(test))]\n            tracing::warn!(\n                \"Tail segments must have names. \\\n                Consider `.../{{tail}}*`. \\\n                This may become a panic in the future.\"\n            );\n\n            // panic in tests to make this case detectable\n            #[cfg(test)]\n            panic!(\"tail segments must have names\");\n        } else if !has_tail_segment && !unprocessed.is_empty() {\n            // prevent `Const(\"\")` element from being added after last dynamic segment\n\n            segments.push(PatternSegment::Const(unprocessed.to_owned()));\n            re.push_str(&escape(unprocessed));\n        }\n\n        assert!(\n            dyn_segment_count <= MAX_DYNAMIC_SEGMENTS,\n            \"Only {} dynamic segments are allowed, provided: {}\",\n            MAX_DYNAMIC_SEGMENTS,\n            dyn_segment_count\n        );\n\n        // Store the pattern in capture group #1 to have context info outside it\n        let mut re = format!(\"({})\", re);\n\n        // Ensure the match ends at a segment boundary\n        if !has_tail_segment {\n            if is_prefix {\n                re.push_str(r\"(/|$)\");\n            } else {\n                re.push('$');\n            }\n        }\n\n        let re = match Regex::new(&re) {\n            Ok(re) => re,\n            Err(err) => panic!(\"Wrong path pattern: \\\"{}\\\" {}\", pattern, err),\n        };\n\n        // `Bok::leak(Box::new(name))` is an intentional memory leak. In typical applications the\n        // routing table is only constructed once (per worker) so leak is bounded. If you are\n        // constructing `ResourceDef`s more than once in your application's lifecycle you would\n        // expect a linear increase in leaked memory over time.\n        let names = re\n            .capture_names()\n            .filter_map(|name| name.map(|name| Box::leak(Box::new(name.to_owned())).as_str()))\n            .collect();\n\n        (PatternType::Dynamic(re, names), segments)\n    }\n}\n\nimpl Eq for ResourceDef {}\n\nimpl PartialEq for ResourceDef {\n    fn eq(&self, other: &ResourceDef) -> bool {\n        self.patterns == other.patterns && self.is_prefix == other.is_prefix\n    }\n}\n\nimpl Hash for ResourceDef {\n    fn hash<H: Hasher>(&self, state: &mut H) {\n        self.patterns.hash(state);\n    }\n}\n\nimpl<'a> From<&'a str> for ResourceDef {\n    fn from(path: &'a str) -> ResourceDef {\n        ResourceDef::new(path)\n    }\n}\n\nimpl From<String> for ResourceDef {\n    fn from(path: String) -> ResourceDef {\n        ResourceDef::new(path)\n    }\n}\n\npub(crate) fn insert_slash(path: &str) -> Cow<'_, str> {\n    if !path.is_empty() && !path.starts_with('/') {\n        let mut new_path = String::with_capacity(path.len() + 1);\n        new_path.push('/');\n        new_path.push_str(path);\n        Cow::Owned(new_path)\n    } else {\n        Cow::Borrowed(path)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::Path;\n\n    #[test]\n    fn equivalence() {\n        assert_eq!(\n            ResourceDef::root_prefix(\"/root\"),\n            ResourceDef::prefix(\"/root\")\n        );\n        assert_eq!(\n            ResourceDef::root_prefix(\"root\"),\n            ResourceDef::prefix(\"/root\")\n        );\n        assert_eq!(\n            ResourceDef::root_prefix(\"/{id}\"),\n            ResourceDef::prefix(\"/{id}\")\n        );\n        assert_eq!(\n            ResourceDef::root_prefix(\"{id}\"),\n            ResourceDef::prefix(\"/{id}\")\n        );\n\n        assert_eq!(ResourceDef::new(\"/\"), ResourceDef::new([\"/\"]));\n        assert_eq!(ResourceDef::new(\"/\"), ResourceDef::new(vec![\"/\"]));\n\n        assert_ne!(ResourceDef::new(\"\"), ResourceDef::prefix(\"\"));\n        assert_ne!(ResourceDef::new(\"/\"), ResourceDef::prefix(\"/\"));\n        assert_ne!(ResourceDef::new(\"/{id}\"), ResourceDef::prefix(\"/{id}\"));\n    }\n\n    #[test]\n    fn parse_static() {\n        let re = ResourceDef::new(\"\");\n\n        assert!(!re.is_prefix());\n\n        assert!(re.is_match(\"\"));\n        assert!(!re.is_match(\"/\"));\n        assert_eq!(re.find_match(\"\"), Some(0));\n        assert_eq!(re.find_match(\"/\"), None);\n\n        let re = ResourceDef::new(\"/\");\n        assert!(re.is_match(\"/\"));\n        assert!(!re.is_match(\"\"));\n        assert!(!re.is_match(\"/foo\"));\n\n        let re = ResourceDef::new(\"/name\");\n        assert!(re.is_match(\"/name\"));\n        assert!(!re.is_match(\"/name1\"));\n        assert!(!re.is_match(\"/name/\"));\n        assert!(!re.is_match(\"/name~\"));\n\n        let mut path = Path::new(\"/name\");\n        assert!(re.capture_match_info(&mut path));\n        assert_eq!(path.unprocessed(), \"\");\n\n        assert_eq!(re.find_match(\"/name\"), Some(5));\n        assert_eq!(re.find_match(\"/name1\"), None);\n        assert_eq!(re.find_match(\"/name/\"), None);\n        assert_eq!(re.find_match(\"/name~\"), None);\n\n        let re = ResourceDef::new(\"/name/\");\n        assert!(re.is_match(\"/name/\"));\n        assert!(!re.is_match(\"/name\"));\n        assert!(!re.is_match(\"/name/gs\"));\n\n        let re = ResourceDef::new(\"/user/profile\");\n        assert!(re.is_match(\"/user/profile\"));\n        assert!(!re.is_match(\"/user/profile/profile\"));\n\n        let mut path = Path::new(\"/user/profile\");\n        assert!(re.capture_match_info(&mut path));\n        assert_eq!(path.unprocessed(), \"\");\n    }\n\n    #[test]\n    fn parse_param() {\n        let re = ResourceDef::new(\"/user/{id}\");\n        assert!(re.is_match(\"/user/profile\"));\n        assert!(re.is_match(\"/user/2345\"));\n        assert!(!re.is_match(\"/user/2345/\"));\n        assert!(!re.is_match(\"/user/2345/sdg\"));\n\n        let mut path = Path::new(\"/user/profile\");\n        assert!(re.capture_match_info(&mut path));\n        assert_eq!(path.get(\"id\").unwrap(), \"profile\");\n        assert_eq!(path.unprocessed(), \"\");\n\n        let mut path = Path::new(\"/user/1245125\");\n        assert!(re.capture_match_info(&mut path));\n        assert_eq!(path.get(\"id\").unwrap(), \"1245125\");\n        assert_eq!(path.unprocessed(), \"\");\n\n        let re = ResourceDef::new(\"/v{version}/resource/{id}\");\n        assert!(re.is_match(\"/v1/resource/320120\"));\n        assert!(!re.is_match(\"/v/resource/1\"));\n        assert!(!re.is_match(\"/resource\"));\n\n        let mut path = Path::new(\"/v151/resource/adage32\");\n        assert!(re.capture_match_info(&mut path));\n        assert_eq!(path.get(\"version\").unwrap(), \"151\");\n        assert_eq!(path.get(\"id\").unwrap(), \"adage32\");\n        assert_eq!(path.unprocessed(), \"\");\n\n        let re = ResourceDef::new(\"/{id:[[:digit:]]{6}}\");\n        assert!(re.is_match(\"/012345\"));\n        assert!(!re.is_match(\"/012\"));\n        assert!(!re.is_match(\"/01234567\"));\n        assert!(!re.is_match(\"/XXXXXX\"));\n\n        let mut path = Path::new(\"/012345\");\n        assert!(re.capture_match_info(&mut path));\n        assert_eq!(path.get(\"id\").unwrap(), \"012345\");\n        assert_eq!(path.unprocessed(), \"\");\n    }\n\n    #[allow(clippy::cognitive_complexity)]\n    #[test]\n    fn dynamic_set() {\n        let re = ResourceDef::new(vec![\n            \"/user/{id}\",\n            \"/v{version}/resource/{id}\",\n            \"/{id:[[:digit:]]{6}}\",\n            \"/static\",\n        ]);\n        assert!(re.is_match(\"/user/profile\"));\n        assert!(re.is_match(\"/user/2345\"));\n        assert!(!re.is_match(\"/user/2345/\"));\n        assert!(!re.is_match(\"/user/2345/sdg\"));\n\n        let mut path = Path::new(\"/user/profile\");\n        assert!(re.capture_match_info(&mut path));\n        assert_eq!(path.get(\"id\").unwrap(), \"profile\");\n        assert_eq!(path.unprocessed(), \"\");\n\n        let mut path = Path::new(\"/user/1245125\");\n        assert!(re.capture_match_info(&mut path));\n        assert_eq!(path.get(\"id\").unwrap(), \"1245125\");\n        assert_eq!(path.unprocessed(), \"\");\n\n        assert!(re.is_match(\"/v1/resource/320120\"));\n        assert!(!re.is_match(\"/v/resource/1\"));\n        assert!(!re.is_match(\"/resource\"));\n\n        let mut path = Path::new(\"/v151/resource/adage32\");\n        assert!(re.capture_match_info(&mut path));\n        assert_eq!(path.get(\"version\").unwrap(), \"151\");\n        assert_eq!(path.get(\"id\").unwrap(), \"adage32\");\n\n        assert!(re.is_match(\"/012345\"));\n        assert!(!re.is_match(\"/012\"));\n        assert!(!re.is_match(\"/01234567\"));\n        assert!(!re.is_match(\"/XXXXXX\"));\n\n        assert!(re.is_match(\"/static\"));\n        assert!(!re.is_match(\"/a/static\"));\n        assert!(!re.is_match(\"/static/a\"));\n\n        let mut path = Path::new(\"/012345\");\n        assert!(re.capture_match_info(&mut path));\n        assert_eq!(path.get(\"id\").unwrap(), \"012345\");\n\n        let re = ResourceDef::new([\n            \"/user/{id}\",\n            \"/v{version}/resource/{id}\",\n            \"/{id:[[:digit:]]{6}}\",\n        ]);\n        assert!(re.is_match(\"/user/profile\"));\n        assert!(re.is_match(\"/user/2345\"));\n        assert!(!re.is_match(\"/user/2345/\"));\n        assert!(!re.is_match(\"/user/2345/sdg\"));\n\n        let re = ResourceDef::new([\n            \"/user/{id}\".to_string(),\n            \"/v{version}/resource/{id}\".to_string(),\n            \"/{id:[[:digit:]]{6}}\".to_string(),\n        ]);\n        assert!(re.is_match(\"/user/profile\"));\n        assert!(re.is_match(\"/user/2345\"));\n        assert!(!re.is_match(\"/user/2345/\"));\n        assert!(!re.is_match(\"/user/2345/sdg\"));\n    }\n\n    #[test]\n    fn dynamic_set_prefix() {\n        let re = ResourceDef::prefix(vec![\"/u/{id}\", \"/{id:[[:digit:]]{3}}\"]);\n\n        assert_eq!(re.find_match(\"/u/abc\"), Some(6));\n        assert_eq!(re.find_match(\"/u/abc/123\"), Some(6));\n        assert_eq!(re.find_match(\"/s/user/profile\"), None);\n\n        assert_eq!(re.find_match(\"/123\"), Some(4));\n        assert_eq!(re.find_match(\"/123/456\"), Some(4));\n        assert_eq!(re.find_match(\"/12345\"), None);\n\n        let mut path = Path::new(\"/151/res\");\n        assert!(re.capture_match_info(&mut path));\n        assert_eq!(path.get(\"id\").unwrap(), \"151\");\n        assert_eq!(path.unprocessed(), \"/res\");\n    }\n\n    #[test]\n    fn parse_tail() {\n        let re = ResourceDef::new(\"/user/-{id}*\");\n\n        let mut path = Path::new(\"/user/-profile\");\n        assert!(re.capture_match_info(&mut path));\n        assert_eq!(path.get(\"id\").unwrap(), \"profile\");\n\n        let mut path = Path::new(\"/user/-2345\");\n        assert!(re.capture_match_info(&mut path));\n        assert_eq!(path.get(\"id\").unwrap(), \"2345\");\n\n        let mut path = Path::new(\"/user/-2345/\");\n        assert!(re.capture_match_info(&mut path));\n        assert_eq!(path.get(\"id\").unwrap(), \"2345/\");\n\n        let mut path = Path::new(\"/user/-2345/sdg\");\n        assert!(re.capture_match_info(&mut path));\n        assert_eq!(path.get(\"id\").unwrap(), \"2345/sdg\");\n    }\n\n    #[test]\n    fn static_tail() {\n        let re = ResourceDef::new(\"/user{tail}*\");\n        assert!(re.is_match(\"/users\"));\n        assert!(re.is_match(\"/user-foo\"));\n        assert!(re.is_match(\"/user/profile\"));\n        assert!(re.is_match(\"/user/2345\"));\n        assert!(re.is_match(\"/user/2345/\"));\n        assert!(re.is_match(\"/user/2345/sdg\"));\n        assert!(!re.is_match(\"/foo/profile\"));\n\n        let re = ResourceDef::new(\"/user/{tail}*\");\n        assert!(re.is_match(\"/user/profile\"));\n        assert!(re.is_match(\"/user/2345\"));\n        assert!(re.is_match(\"/user/2345/\"));\n        assert!(re.is_match(\"/user/2345/sdg\"));\n        assert!(!re.is_match(\"/foo/profile\"));\n    }\n\n    #[test]\n    fn dynamic_tail() {\n        let re = ResourceDef::new(\"/user/{id}/{tail}*\");\n        assert!(!re.is_match(\"/user/2345\"));\n        let mut path = Path::new(\"/user/2345/sdg\");\n        assert!(re.capture_match_info(&mut path));\n        assert_eq!(path.get(\"id\").unwrap(), \"2345\");\n        assert_eq!(path.get(\"tail\").unwrap(), \"sdg\");\n        assert_eq!(path.unprocessed(), \"\");\n    }\n\n    #[test]\n    fn newline_patterns_and_paths() {\n        let re = ResourceDef::new(\"/user/a\\nb\");\n        assert!(re.is_match(\"/user/a\\nb\"));\n        assert!(!re.is_match(\"/user/a\\nb/profile\"));\n\n        let re = ResourceDef::new(\"/a{x}b/test/a{y}b\");\n        let mut path = Path::new(\"/a\\nb/test/a\\nb\");\n        assert!(re.capture_match_info(&mut path));\n        assert_eq!(path.get(\"x\").unwrap(), \"\\n\");\n        assert_eq!(path.get(\"y\").unwrap(), \"\\n\");\n\n        let re = ResourceDef::new(\"/user/{tail}*\");\n        assert!(re.is_match(\"/user/a\\nb/\"));\n\n        let re = ResourceDef::new(\"/user/{id}*\");\n        let mut path = Path::new(\"/user/a\\nb/a\\nb\");\n        assert!(re.capture_match_info(&mut path));\n        assert_eq!(path.get(\"id\").unwrap(), \"a\\nb/a\\nb\");\n\n        let re = ResourceDef::new(\"/user/{id:.*}\");\n        let mut path = Path::new(\"/user/a\\nb/a\\nb\");\n        assert!(re.capture_match_info(&mut path));\n        assert_eq!(path.get(\"id\").unwrap(), \"a\\nb/a\\nb\");\n    }\n\n    #[cfg(feature = \"http\")]\n    #[test]\n    fn parse_urlencoded_param() {\n        let re = ResourceDef::new(\"/user/{id}/test\");\n\n        let mut path = Path::new(\"/user/2345/test\");\n        assert!(re.capture_match_info(&mut path));\n        assert_eq!(path.get(\"id\").unwrap(), \"2345\");\n\n        let mut path = Path::new(\"/user/qwe%25/test\");\n        assert!(re.capture_match_info(&mut path));\n        assert_eq!(path.get(\"id\").unwrap(), \"qwe%25\");\n\n        let uri = http::Uri::try_from(\"/user/qwe%25/test\").unwrap();\n        let mut path = Path::new(uri);\n        assert!(re.capture_match_info(&mut path));\n        assert_eq!(path.get(\"id\").unwrap(), \"qwe%25\");\n    }\n\n    #[test]\n    fn prefix_static() {\n        let re = ResourceDef::prefix(\"/name\");\n\n        assert!(re.is_prefix());\n\n        assert!(re.is_match(\"/name\"));\n        assert!(re.is_match(\"/name/\"));\n        assert!(re.is_match(\"/name/test/test\"));\n        assert!(!re.is_match(\"/name1\"));\n        assert!(!re.is_match(\"/name~\"));\n\n        let mut path = Path::new(\"/name\");\n        assert!(re.capture_match_info(&mut path));\n        assert_eq!(path.unprocessed(), \"\");\n\n        let mut path = Path::new(\"/name/test\");\n        assert!(re.capture_match_info(&mut path));\n        assert_eq!(path.unprocessed(), \"/test\");\n\n        assert_eq!(re.find_match(\"/name\"), Some(5));\n        assert_eq!(re.find_match(\"/name/\"), Some(5));\n        assert_eq!(re.find_match(\"/name/test/test\"), Some(5));\n        assert_eq!(re.find_match(\"/name1\"), None);\n        assert_eq!(re.find_match(\"/name~\"), None);\n\n        let re = ResourceDef::prefix(\"/name/\");\n        assert!(re.is_match(\"/name/\"));\n        assert!(re.is_match(\"/name//gs\"));\n        assert!(!re.is_match(\"/name/gs\"));\n        assert!(!re.is_match(\"/name\"));\n\n        let mut path = Path::new(\"/name/gs\");\n        assert!(!re.capture_match_info(&mut path));\n\n        let mut path = Path::new(\"/name//gs\");\n        assert!(re.capture_match_info(&mut path));\n        assert_eq!(path.unprocessed(), \"/gs\");\n\n        let re = ResourceDef::root_prefix(\"name/\");\n        assert!(re.is_match(\"/name/\"));\n        assert!(re.is_match(\"/name//gs\"));\n        assert!(!re.is_match(\"/name/gs\"));\n        assert!(!re.is_match(\"/name\"));\n\n        let mut path = Path::new(\"/name/gs\");\n        assert!(!re.capture_match_info(&mut path));\n    }\n\n    #[test]\n    fn prefix_dynamic() {\n        let re = ResourceDef::prefix(\"/{name}\");\n\n        assert!(re.is_prefix());\n\n        assert!(re.is_match(\"/name/\"));\n        assert!(re.is_match(\"/name/gs\"));\n        assert!(re.is_match(\"/name\"));\n\n        assert_eq!(re.find_match(\"/name/\"), Some(5));\n        assert_eq!(re.find_match(\"/name/gs\"), Some(5));\n        assert_eq!(re.find_match(\"/name\"), Some(5));\n        assert_eq!(re.find_match(\"\"), None);\n\n        let mut path = Path::new(\"/test2/\");\n        assert!(re.capture_match_info(&mut path));\n        assert_eq!(&path[\"name\"], \"test2\");\n        assert_eq!(&path[0], \"test2\");\n        assert_eq!(path.unprocessed(), \"/\");\n\n        let mut path = Path::new(\"/test2/subpath1/subpath2/index.html\");\n        assert!(re.capture_match_info(&mut path));\n        assert_eq!(&path[\"name\"], \"test2\");\n        assert_eq!(&path[0], \"test2\");\n        assert_eq!(path.unprocessed(), \"/subpath1/subpath2/index.html\");\n\n        let resource = ResourceDef::prefix(\"/user\");\n        // input string shorter than prefix\n        assert!(resource.find_match(\"/foo\").is_none());\n    }\n\n    #[test]\n    fn prefix_empty() {\n        let re = ResourceDef::prefix(\"\");\n\n        assert!(re.is_prefix());\n\n        assert!(re.is_match(\"\"));\n        assert!(re.is_match(\"/\"));\n        assert!(re.is_match(\"/name/test/test\"));\n    }\n\n    #[test]\n    fn build_path_list() {\n        let mut s = String::new();\n        let resource = ResourceDef::new(\"/user/{item1}/test\");\n        assert!(resource.resource_path_from_iter(&mut s, &mut [\"user1\"].iter()));\n        assert_eq!(s, \"/user/user1/test\");\n\n        let mut s = String::new();\n        let resource = ResourceDef::new(\"/user/{item1}/{item2}/test\");\n        assert!(resource.resource_path_from_iter(&mut s, &mut [\"item\", \"item2\"].iter()));\n        assert_eq!(s, \"/user/item/item2/test\");\n\n        let mut s = String::new();\n        let resource = ResourceDef::new(\"/user/{item1}/{item2}\");\n        assert!(resource.resource_path_from_iter(&mut s, &mut [\"item\", \"item2\"].iter()));\n        assert_eq!(s, \"/user/item/item2\");\n\n        let mut s = String::new();\n        let resource = ResourceDef::new(\"/user/{item1}/{item2}/\");\n        assert!(resource.resource_path_from_iter(&mut s, &mut [\"item\", \"item2\"].iter()));\n        assert_eq!(s, \"/user/item/item2/\");\n\n        let mut s = String::new();\n        assert!(!resource.resource_path_from_iter(&mut s, &mut [\"item\"].iter()));\n\n        let mut s = String::new();\n        assert!(resource.resource_path_from_iter(&mut s, &mut [\"item\", \"item2\"].iter()));\n        assert_eq!(s, \"/user/item/item2/\");\n        assert!(!resource.resource_path_from_iter(&mut s, &mut [\"item\"].iter()));\n\n        let mut s = String::new();\n\n        assert!(resource.resource_path_from_iter(\n            &mut s,\n            #[allow(clippy::useless_vec)]\n            &mut vec![\"item\", \"item2\"].iter()\n        ));\n        assert_eq!(s, \"/user/item/item2/\");\n    }\n\n    #[test]\n    fn multi_pattern_build_path() {\n        let resource = ResourceDef::new([\"/user/{id}\", \"/profile/{id}\"]);\n        let mut s = String::new();\n        assert!(resource.resource_path_from_iter(&mut s, &mut [\"123\"].iter()));\n        assert_eq!(s, \"/user/123\");\n    }\n\n    #[test]\n    fn multi_pattern_capture_segment_values() {\n        let resource = ResourceDef::new([\"/user/{id}\", \"/profile/{id}\"]);\n\n        let mut path = Path::new(\"/user/123\");\n        assert!(resource.capture_match_info(&mut path));\n        assert!(path.get(\"id\").is_some());\n\n        let mut path = Path::new(\"/profile/123\");\n        assert!(resource.capture_match_info(&mut path));\n        assert!(path.get(\"id\").is_some());\n\n        let resource = ResourceDef::new([\"/user/{id}\", \"/profile/{uid}\"]);\n\n        let mut path = Path::new(\"/user/123\");\n        assert!(resource.capture_match_info(&mut path));\n        assert!(path.get(\"id\").is_some());\n        assert!(path.get(\"uid\").is_none());\n\n        let mut path = Path::new(\"/profile/123\");\n        assert!(resource.capture_match_info(&mut path));\n        assert!(path.get(\"id\").is_none());\n        assert!(path.get(\"uid\").is_some());\n    }\n\n    #[test]\n    fn dynamic_prefix_proper_segmentation() {\n        let resource = ResourceDef::prefix(r\"/id/{id:\\d{3}}\");\n\n        assert!(resource.is_match(\"/id/123\"));\n        assert!(resource.is_match(\"/id/123/foo\"));\n        assert!(!resource.is_match(\"/id/1234\"));\n        assert!(!resource.is_match(\"/id/123a\"));\n\n        assert_eq!(resource.find_match(\"/id/123\"), Some(7));\n        assert_eq!(resource.find_match(\"/id/123/foo\"), Some(7));\n        assert_eq!(resource.find_match(\"/id/1234\"), None);\n        assert_eq!(resource.find_match(\"/id/123a\"), None);\n    }\n\n    #[test]\n    fn build_path_map() {\n        let resource = ResourceDef::new(\"/user/{item1}/{item2}/\");\n\n        let mut map = HashMap::new();\n        map.insert(\"item1\", \"item\");\n\n        let mut s = String::new();\n        assert!(!resource.resource_path_from_map(&mut s, &map));\n\n        map.insert(\"item2\", \"item2\");\n\n        let mut s = String::new();\n        assert!(resource.resource_path_from_map(&mut s, &map));\n        assert_eq!(s, \"/user/item/item2/\");\n    }\n\n    #[test]\n    fn build_path_tail() {\n        let resource = ResourceDef::new(\"/user/{item1}*\");\n\n        let mut s = String::new();\n        assert!(!resource.resource_path_from_iter(&mut s, &mut [\"\"; 0].iter()));\n\n        let mut s = String::new();\n        assert!(resource.resource_path_from_iter(&mut s, &mut [\"user1\"].iter()));\n        assert_eq!(s, \"/user/user1\");\n\n        let mut s = String::new();\n        let mut map = HashMap::new();\n        map.insert(\"item1\", \"item\");\n        assert!(resource.resource_path_from_map(&mut s, &map));\n        assert_eq!(s, \"/user/item\");\n    }\n\n    #[test]\n    fn prefix_trailing_slash() {\n        // The prefix \"/abc/\" matches two segments: [\"user\", \"\"]\n\n        // These are not prefixes\n        let re = ResourceDef::prefix(\"/abc/\");\n        assert_eq!(re.find_match(\"/abc/def\"), None);\n        assert_eq!(re.find_match(\"/abc//def\"), Some(5));\n\n        let re = ResourceDef::prefix(\"/{id}/\");\n        assert_eq!(re.find_match(\"/abc/def\"), None);\n        assert_eq!(re.find_match(\"/abc//def\"), Some(5));\n    }\n\n    #[test]\n    fn join() {\n        // test joined defs match the same paths as each component separately\n\n        fn seq_find_match(re1: &ResourceDef, re2: &ResourceDef, path: &str) -> Option<usize> {\n            let len1 = re1.find_match(path)?;\n            let len2 = re2.find_match(&path[len1..])?;\n            Some(len1 + len2)\n        }\n\n        macro_rules! join_test {\n            ($pat1:expr, $pat2:expr => $($test:expr),+) => {{\n                let pat1 = $pat1;\n                let pat2 = $pat2;\n                $({\n                    let _path = $test;\n                    let (re1, re2) = (ResourceDef::prefix(pat1), ResourceDef::new(pat2));\n                    let _seq = seq_find_match(&re1, &re2, _path);\n                    let _join = re1.join(&re2).find_match(_path);\n                    assert_eq!(\n                        _seq, _join,\n                        \"patterns: prefix {:?}, {:?}; mismatch on \\\"{}\\\"; seq={:?}; join={:?}\",\n                        pat1, pat2, _path, _seq, _join\n                    );\n                    assert!(!re1.join(&re2).is_prefix());\n\n                    let (re1, re2) = (ResourceDef::prefix(pat1), ResourceDef::prefix(pat2));\n                    let _seq = seq_find_match(&re1, &re2, _path);\n                    let _join = re1.join(&re2).find_match(_path);\n                    assert_eq!(\n                        _seq, _join,\n                        \"patterns: prefix {:?}, prefix {:?}; mismatch on \\\"{}\\\"; seq={:?}; join={:?}\",\n                        pat1, pat2, _path, _seq, _join\n                    );\n                    assert!(re1.join(&re2).is_prefix());\n                })+\n            }}\n        }\n\n        join_test!(\"\", \"\" => \"\", \"/hello\", \"/\");\n        join_test!(\"/user\", \"\" => \"\", \"/user\", \"/user/123\", \"/user11\", \"user\", \"user/123\");\n        join_test!(\"\",  \"/user\" => \"\", \"/user\", \"foo\", \"/user11\", \"user\", \"user/123\");\n        join_test!(\"/user\",  \"/xx\" => \"\", \"\",  \"/\", \"/user\", \"/xx\", \"/userxx\", \"/user/xx\");\n\n        join_test!([\"/ver/{v}\", \"/v{v}\"], [\"/req/{req}\", \"/{req}\"] => \"/v1/abc\", \n                   \"/ver/1/abc\", \"/v1/req/abc\", \"/ver/1/req/abc\", \"/v1/abc/def\",\n                   \"/ver1/req/abc/def\", \"\", \"/\", \"/v1/\");\n    }\n\n    #[test]\n    fn match_methods_agree() {\n        macro_rules! match_methods_agree {\n            ($pat:expr => $($test:expr),+) => {{\n                match_methods_agree!(finish $pat, ResourceDef::new($pat), $($test),+);\n            }};\n            (prefix $pat:expr => $($test:expr),+) => {{\n                match_methods_agree!(finish $pat, ResourceDef::prefix($pat), $($test),+);\n            }};\n            (finish $pat:expr, $re:expr, $($test:expr),+) => {{\n                let re = $re;\n                $({\n                    let _is = re.is_match($test);\n                    let _find = re.find_match($test).is_some();\n                    assert_eq!(\n                        _is, _find,\n                        \"pattern: {:?}; mismatch on \\\"{}\\\"; is={}; find={}\",\n                        $pat, $test, _is, _find\n                    );\n                })+\n            }}\n        }\n\n        match_methods_agree!(\"\" => \"\", \"/\", \"/foo\");\n        match_methods_agree!(\"/\" => \"\", \"/\", \"/foo\");\n        match_methods_agree!(\"/user\" => \"user\", \"/user\", \"/users\", \"/user/123\", \"/foo\");\n        match_methods_agree!(\"/v{v}\" => \"v\", \"/v\", \"/v1\", \"/v222\", \"/foo\");\n        match_methods_agree!([\"/v{v}\", \"/version/{v}\"] => \"/v\", \"/v1\", \"/version\", \"/version/1\", \"/foo\");\n\n        match_methods_agree!(\"/path{tail}*\" => \"/path\", \"/path1\", \"/path/123\");\n        match_methods_agree!(\"/path/{tail}*\" => \"/path\", \"/path1\", \"/path/123\");\n\n        match_methods_agree!(prefix \"\" => \"\", \"/\", \"/foo\");\n        match_methods_agree!(prefix \"/user\" => \"user\", \"/user\", \"/users\", \"/user/123\", \"/foo\");\n        match_methods_agree!(prefix r\"/id/{id:\\d{3}}\" => \"/id/123\", \"/id/1234\");\n        match_methods_agree!([\"/v{v}\", \"/ver/{v}\"] => \"\", \"s/v\", \"/v1\", \"/v1/xx\", \"/ver/i3/5\", \"/ver/1\");\n    }\n\n    #[test]\n    #[should_panic]\n    fn duplicate_segment_name() {\n        ResourceDef::new(\"/user/{id}/post/{id}\");\n    }\n\n    #[test]\n    #[should_panic]\n    fn invalid_dynamic_segment_delimiter() {\n        ResourceDef::new(\"/user/{username\");\n    }\n\n    #[test]\n    #[should_panic]\n    fn invalid_dynamic_segment_name() {\n        ResourceDef::new(\"/user/{}\");\n    }\n\n    #[test]\n    #[should_panic]\n    fn invalid_too_many_dynamic_segments() {\n        // valid\n        ResourceDef::new(\"/{a}/{b}/{c}/{d}/{e}/{f}/{g}/{h}/{i}/{j}/{k}/{l}/{m}/{n}/{o}/{p}\");\n\n        // panics\n        ResourceDef::new(\"/{a}/{b}/{c}/{d}/{e}/{f}/{g}/{h}/{i}/{j}/{k}/{l}/{m}/{n}/{o}/{p}/{q}\");\n    }\n\n    #[test]\n    #[should_panic]\n    fn invalid_custom_regex_for_tail() {\n        ResourceDef::new(r\"/{tail:\\d+}*\");\n    }\n\n    #[test]\n    #[should_panic]\n    fn invalid_unnamed_tail_segment() {\n        ResourceDef::new(\"/*\");\n    }\n\n    #[test]\n    #[should_panic]\n    fn prefix_plus_tail_match_disallowed() {\n        ResourceDef::prefix(\"/user/{id}*\");\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "b85cf5224b63d084b2ca32c15fdeb7a87774e5a0",
    "func": "use bevy_math::UVec2;\n\nuse crate::{ClusterConfig, Clusters};\n\nfn test_cluster_tiling(config: ClusterConfig, screen_size: UVec2) -> Clusters {\n    let dims = config.dimensions_for_screen_size(screen_size);\n\n    // note: near & far do not affect tiling\n    let mut clusters = Clusters::default();\n    clusters.update(screen_size, dims);\n\n    // check we cover the screen\n    assert!(clusters.tile_size.x * clusters.dimensions.x >= screen_size.x);\n    assert!(clusters.tile_size.y * clusters.dimensions.y >= screen_size.y);\n    // check a smaller number of clusters would not cover the screen\n    assert!(clusters.tile_size.x * (clusters.dimensions.x - 1) < screen_size.x);\n    assert!(clusters.tile_size.y * (clusters.dimensions.y - 1) < screen_size.y);\n    // check a smaller tile size would not cover the screen\n    assert!((clusters.tile_size.x - 1) * clusters.dimensions.x < screen_size.x);\n    assert!((clusters.tile_size.y - 1) * clusters.dimensions.y < screen_size.y);\n    // check we don't have more clusters than pixels\n    assert!(clusters.dimensions.x <= screen_size.x);\n    assert!(clusters.dimensions.y <= screen_size.y);\n\n    clusters\n}\n\n#[test]\n// check tiling for small screen sizes\nfn test_default_cluster_setup_small_screensizes() {\n    for x in 1..100 {\n        for y in 1..100 {\n            let screen_size = UVec2::new(x, y);\n            let clusters = test_cluster_tiling(ClusterConfig::default(), screen_size);\n            assert!(clusters.dimensions.x * clusters.dimensions.y * clusters.dimensions.z <= 4096);\n        }\n    }\n}\n\n#[test]\n// check tiling for long thin screen sizes\nfn test_default_cluster_setup_small_x() {\n    for x in 1..10 {\n        for y in 1..5000 {\n            let screen_size = UVec2::new(x, y);\n            let clusters = test_cluster_tiling(ClusterConfig::default(), screen_size);\n            assert!(clusters.dimensions.x * clusters.dimensions.y * clusters.dimensions.z <= 4096);\n\n            let screen_size = UVec2::new(y, x);\n            let clusters = test_cluster_tiling(ClusterConfig::default(), screen_size);\n            assert!(clusters.dimensions.x * clusters.dimensions.y * clusters.dimensions.z <= 4096);\n        }\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "c98c7b55de088c489db7697bf44d554ed3661a80",
    "func": "//! Traits related to relationships between multiple tables.\n//!\n//! Associations in Diesel are always child-to-parent.\n//! You can declare an association between two records with `#[diesel(belongs_to)]`.\n//! Unlike other ORMs, Diesel has no concept of `has many`\n//!\n//! ```rust\n//! # include!(\"../doctest_setup.rs\");\n//! use schema::{posts, users};\n//!\n//! #[derive(Identifiable, Queryable, PartialEq, Debug)]\n//! #[diesel(table_name = users)]\n//! pub struct User {\n//!     id: i32,\n//!     name: String,\n//! }\n//!\n//! #[derive(Identifiable, Queryable, Associations, PartialEq, Debug)]\n//! #[diesel(belongs_to(User))]\n//! #[diesel(table_name = posts)]\n//! pub struct Post {\n//!     id: i32,\n//!     user_id: i32,\n//!     title: String,\n//! }\n//!\n//! # fn main() {\n//! #     run_test().unwrap();\n//! # }\n//! #\n//! # fn run_test() -> QueryResult<()> {\n//! #     let connection = &mut establish_connection();\n//! #     use self::users::dsl::*;\n//! let user = users.find(2).get_result::<User>(connection)?;\n//! let users_post = Post::belonging_to(&user)\n//!     .first(connection)?;\n//! let expected = Post { id: 3, user_id: 2, title: \"My first post too\".into() };\n//! assert_eq!(expected, users_post);\n//! #     Ok(())\n//! # }\n//! ```\n//!\n//! Note that in addition to the `#[diesel(belongs_to)]` annotation, we also need to\n//! `#[derive(Associations)]`\n//!\n//! `#[diesel(belongs_to)]` is given the name of the struct that represents the parent.\n//! Both the parent and child must implement [`Identifiable`].\n//! The struct given to `#[diesel(belongs_to)]` must be in scope,\n//! so you will need `use some_module::User` if `User` is defined in another module.\n//!\n//! If the parent record is generic over lifetimes, they can be written as `'_`.\n//! You will also need to wrap the type in quotes until\n//! `unrestricted_attribute_tokens` is stable.\n//!\n//! ```rust\n//! # include!(\"../doctest_setup.rs\");\n//! # use schema::{posts, users};\n//! # use std::borrow::Cow;\n//! #\n//! #[derive(Identifiable)]\n//! #[diesel(table_name = users)]\n//! pub struct User<'a> {\n//!     id: i32,\n//!     name: Cow<'a, str>,\n//! }\n//!\n//! #[derive(Associations)]\n//! #[diesel(belongs_to(User<'_>))]\n//! #[diesel(table_name = posts)]\n//! pub struct Post {\n//!     id: i32,\n//!     user_id: i32,\n//!     title: String,\n//! }\n//! #\n//! # fn main() {}\n//! ```\n//!\n//!\n//! By default, Diesel assumes that your foreign keys will follow the convention `table_name_id`.\n//! If your foreign key has a different name,\n//! you can provide the `foreign_key` argument to `#[diesel(belongs_to)]`.\n//! For example, `#[diesel(belongs_to(Foo, foreign_key = mykey))]`.\n//!\n//! Associated data is typically loaded in multiple queries (one query per table).\n//! This is usually more efficient than using a join,\n//! especially if 3 or more tables are involved.\n//! For most datasets,\n//! using a join to load in a single query transmits so much duplicate data\n//! that it costs more time than the extra round trip would have.\n//!\n//! You can load the children for one or more parents using\n//! [`belonging_to`]\n//!\n//! [`belonging_to`]: crate::query_dsl::BelongingToDsl::belonging_to\n//!\n//! ```rust\n//! # include!(\"../doctest_setup.rs\");\n//! # use schema::users;\n//! # use schema::posts;\n//! #\n//! # #[derive(Debug, PartialEq, Identifiable, Queryable)]\n//! # pub struct User {\n//! #     id: i32,\n//! #     name: String,\n//! # }\n//! #\n//! # #[derive(Debug, PartialEq, Identifiable, Queryable, Associations)]\n//! # #[diesel(belongs_to(User))]\n//! # pub struct Post {\n//! #     id: i32,\n//! #     user_id: i32,\n//! #     title: String,\n//! # }\n//! #\n//! # fn main() {\n//! #   use self::users::dsl::*;\n//! #   let connection = &mut establish_connection();\n//! #\n//! let user = users.find(1).first::<User>(connection).expect(\"Error loading user\");\n//! let post_list = Post::belonging_to(&user)\n//!     .load::<Post>(connection)\n//!     .expect(\"Error loading posts\");\n//! let expected = vec![\n//!     Post { id: 1, user_id: 1, title: \"My first post\".to_string() },\n//!     Post { id: 2, user_id: 1, title: \"About Rust\".to_string() },\n//! ];\n//!\n//! assert_eq!(post_list, expected);\n//! # }\n//! ```\n//!\n//! If you're coming from other ORMs, you'll notice that this design is quite different from most.\n//! There you would have an instance method on the parent, or have the children stored somewhere on\n//! the posts. This design leads to many problems, including [N+1 query\n//! bugs][load-your-entire-database-into-memory-lol], and runtime errors when accessing an\n//! association that isn't there.\n//!\n//! [load-your-entire-database-into-memory-lol]: https://stackoverflow.com/q/97197/1254484\n//!\n//! In Diesel, data and its associations are considered to be separate. If you want to pass around\n//! a user and all of its posts, that type is `(User, Vec<Post>)`.\n//!\n//! Next lets look at how to load the children for more than one parent record.\n//! [`belonging_to`] can be used to load the data, but we'll also need to group it\n//! with its parents. For this we use an additional method [`grouped_by`].\n//!\n//! [`grouped_by`]: GroupedBy::grouped_by\n//! [`belonging_to`]: crate::query_dsl::BelongingToDsl::belonging_to\n//!\n//! ```rust\n//! # include!(\"../doctest_setup.rs\");\n//! # use schema::{posts, users};\n//! #\n//! # #[derive(Identifiable, Queryable)]\n//! # pub struct User {\n//! #     id: i32,\n//! #     name: String,\n//! # }\n//! #\n//! # #[derive(Debug, PartialEq)]\n//! # #[derive(Identifiable, Queryable, Associations)]\n//! # #[diesel(belongs_to(User))]\n//! # pub struct Post {\n//! #     id: i32,\n//! #     user_id: i32,\n//! #     title: String,\n//! # }\n//! #\n//! # fn main() {\n//! #     run_test();\n//! # }\n//! #\n//! # fn run_test() -> QueryResult<()> {\n//! #     let connection = &mut establish_connection();\n//! #     use self::users::dsl::*;\n//! #     use self::posts::dsl::{posts, title};\n//! let sean = users.filter(name.eq(\"Sean\")).first::<User>(connection)?;\n//! let tess = users.filter(name.eq(\"Tess\")).first::<User>(connection)?;\n//!\n//! let seans_posts = Post::belonging_to(&sean)\n//!     .select(title)\n//!     .load::<String>(connection)?;\n//! assert_eq!(vec![\"My first post\", \"About Rust\"], seans_posts);\n//!\n//! // A vec or slice can be passed as well\n//! let more_posts = Post::belonging_to(&vec![sean, tess])\n//!     .select(title)\n//!     .load::<String>(connection)?;\n//! assert_eq!(vec![\"My first post\", \"About Rust\", \"My first post too\"], more_posts);\n//! #     Ok(())\n//! # }\n//! ```\n//!\n//! Typically you will want to group up the children with their parents.\n//! In other ORMs, this is often called a `has_many` relationship.\n//! Diesel provides support for doing this grouping, once the data has been\n//! loaded.\n//!\n//! [`grouped_by`] is called on a `Vec<Child>` with a `&[Parent]`.\n//! The return value will be `Vec<Vec<Child>>` indexed to match their parent.\n//! Or to put it another way, the returned data can be passed to `zip`,\n//! and it will be combined with its parent.\n//!\n//! ```rust\n//! # include!(\"../doctest_setup.rs\");\n//! # use schema::{posts, users};\n//! #\n//! # #[derive(Identifiable, Queryable, PartialEq, Debug)]\n//! # pub struct User {\n//! #     id: i32,\n//! #     name: String,\n//! # }\n//! #\n//! # #[derive(Debug, PartialEq)]\n//! # #[derive(Identifiable, Queryable, Associations)]\n//! # #[diesel(belongs_to(User))]\n//! # pub struct Post {\n//! #     id: i32,\n//! #     user_id: i32,\n//! #     title: String,\n//! # }\n//! #\n//! # fn main() {\n//! #     run_test();\n//! # }\n//! #\n//! # fn run_test() -> QueryResult<()> {\n//! #     let connection = &mut establish_connection();\n//! let users = users::table.load::<User>(connection)?;\n//! let posts = Post::belonging_to(&users)\n//!     .load::<Post>(connection)?\n//!     .grouped_by(&users);\n//! let data = users.into_iter().zip(posts).collect::<Vec<_>>();\n//!\n//! let expected_data = vec![\n//!     (\n//!         User { id: 1, name: \"Sean\".into() },\n//!         vec![\n//!             Post { id: 1, user_id: 1, title: \"My first post\".into() },\n//!             Post { id: 2, user_id: 1, title: \"About Rust\".into() },\n//!         ],\n//!     ),\n//!     (\n//!         User { id: 2, name: \"Tess\".into() },\n//!         vec![\n//!             Post { id: 3, user_id: 2, title: \"My first post too\".into() },\n//!         ],\n//!     ),\n//! ];\n//!\n//! assert_eq!(expected_data, data);\n//! #     Ok(())\n//! # }\n//! ```\n//!\n//! [`grouped_by`] can be called multiple times\n//! if you have multiple children or grandchildren.\n//!\n//! For example, this code will load some users,\n//! all of their posts,\n//! and all of the comments on those posts.\n//! Explicit type annotations have been added\n//! to make each line a bit more clear.\n//!\n//! ```rust\n//! # include!(\"../doctest_setup.rs\");\n//! # use schema::{users, posts, comments};\n//! #\n//! # #[derive(Debug, PartialEq, Identifiable, Queryable)]\n//! # pub struct User {\n//! #     id: i32,\n//! #     name: String,\n//! # }\n//! #\n//! # #[derive(Debug, PartialEq, Identifiable, Queryable, Associations)]\n//! # #[diesel(belongs_to(User))]\n//! # pub struct Post {\n//! #     id: i32,\n//! #     user_id: i32,\n//! #     title: String,\n//! # }\n//! #\n//! # #[derive(Debug, PartialEq, Identifiable, Queryable, Associations)]\n//! # #[diesel(belongs_to(Post))]\n//! # pub struct Comment {\n//! #     id: i32,\n//! #     post_id: i32,\n//! #     body: String,\n//! # }\n//! #\n//! # fn main() {\n//! #   let connection = &mut establish_connection();\n//! #\n//! let users: Vec<User> = users::table.load::<User>(connection)\n//!     .expect(\"error loading users\");\n//! let posts: Vec<Post> = Post::belonging_to(&users)\n//!     .load::<Post>(connection)\n//!     .expect(\"error loading posts\");\n//! let comments: Vec<Comment> = Comment::belonging_to(&posts)\n//!     .load::<Comment>(connection)\n//!     .expect(\"Error loading comments\");\n//! let grouped_comments: Vec<Vec<Comment>> = comments.grouped_by(&posts);\n//! let posts_and_comments: Vec<Vec<(Post, Vec<Comment>)>> = posts\n//!     .into_iter()\n//!     .zip(grouped_comments)\n//!     .grouped_by(&users);\n//! let result: Vec<(User, Vec<(Post, Vec<Comment>)>)> = users\n//!     .into_iter()\n//!     .zip(posts_and_comments)\n//!     .collect();\n//! let expected = vec![\n//!     (\n//!         User { id: 1, name: \"Sean\".to_string() },\n//!         vec![\n//!             (\n//!                 Post { id: 1, user_id: 1, title: \"My first post\".to_string() },\n//!                 vec![ Comment { id: 1, post_id: 1, body: \"Great post\".to_string() } ]\n//!             ),\n//!             (\n//!                 Post { id: 2, user_id: 1, title: \"About Rust\".to_string() },\n//!                 vec![\n//!                     Comment { id: 2, post_id: 2, body: \"Yay! I am learning Rust\".to_string() }\n//!                 ]\n//!\n//!             )\n//!         ]\n//!     ),\n//!     (\n//!         User { id: 2, name: \"Tess\".to_string() },\n//!         vec![\n//!             (\n//!                 Post { id: 3, user_id: 2, title: \"My first post too\".to_string() },\n//!                 vec![ Comment { id: 3, post_id: 3, body: \"I enjoyed your post\".to_string() } ]\n//!             )\n//!         ]\n//!     )\n//! ];\n//!\n//! assert_eq!(result, expected);\n//! # }\n//! ```\n//!\n//! And that's it.\n//! It may seem odd to have load, group, and zip be explicit separate steps\n//! if you are coming from another ORM.\n//! However, the goal is to provide simple building blocks which can\n//! be used to construct the complex behavior applications need.\nmod belongs_to;\n\nuse std::hash::Hash;\n\nuse crate::query_source::Table;\n\npub use self::belongs_to::{BelongsTo, GroupedBy};\n\n#[doc(inline)]\npub use diesel_derives::Associations;\n\n/// This trait indicates that a struct is associated with a single database table.\n///\n/// This trait is implemented by structs which implement `Identifiable`,\n/// as well as database tables themselves.\npub trait HasTable {\n    /// The table this type is associated with.\n    type Table: Table;\n\n    /// Returns the table this type is associated with.\n    fn table() -> Self::Table;\n}\n\nimpl<'a, T: HasTable> HasTable for &'a T {\n    type Table = T::Table;\n\n    fn table() -> Self::Table {\n        T::table()\n    }\n}\n\n/// This trait indicates that a struct represents a single row in a database table.\n///\n/// This must be implemented to use associations.\n/// Additionally, implementing this trait allows you to pass your struct to `update`\n/// (`update(&your_struct)` is equivalent to\n/// `update(YourStruct::table().find(&your_struct.primary_key())`).\n///\n/// This trait is usually implemented on a reference to a struct,\n/// not on the struct itself. It can be [derived](derive@Identifiable).\n///\npub trait Identifiable: HasTable {\n    /// The type of this struct's identifier.\n    ///\n    /// For single-field primary keys, this is typically `&'a i32`, or `&'a String`\n    /// For composite primary keys, this is typically `(&'a i32, &'a i32)`\n    /// or `(&'a String, &'a String)`, etc.\n    type Id: Hash + Eq;\n\n    /// Returns the identifier for this record.\n    ///\n    /// This takes `self` by value, not reference.\n    /// This is because composite primary keys\n    /// are typically stored as multiple fields.\n    /// We could not return `&(String, String)` if each string is a separate field.\n    ///\n    /// Because of Rust's rules about specifying lifetimes,\n    /// this means that `Identifiable` is usually implemented on references\n    /// so that we have a lifetime to use for `Id`.\n    fn id(self) -> Self::Id;\n}\n\n#[doc(inline)]\npub use diesel_derives::Identifiable;\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "de72f5addd131fbb249410e0e6fe77167bc205b5",
    "func": "use crate::fs::asyncify;\n\nuse std::{io, path::Path};\n\n/// Creates a future which will open a file for reading and read the entire\n/// contents into a string and return said string.\n///\n/// This is the async equivalent of [`std::fs::read_to_string`][std].\n///\n/// This operation is implemented by running the equivalent blocking operation\n/// on a separate thread pool using [`spawn_blocking`].\n///\n/// [`spawn_blocking`]: crate::task::spawn_blocking\n/// [std]: fn@std::fs::read_to_string\n///\n/// # Examples\n///\n/// ```no_run\n/// use tokio::fs;\n///\n/// # async fn dox() -> std::io::Result<()> {\n/// let contents = fs::read_to_string(\"foo.txt\").await?;\n/// println!(\"foo.txt contains {} bytes\", contents.len());\n/// # Ok(())\n/// # }\n/// ```\npub async fn read_to_string(path: impl AsRef<Path>) -> io::Result<String> {\n    let path = path.as_ref().to_owned();\n    asyncify(move || std::fs::read_to_string(path)).await\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "929e3e3ccf6d4ece55ef7b3f6afa16f5fbc3cd61",
    "func": "/// Marker for types that are `Sync` but not `Send`\n#[allow(dead_code)]\npub(crate) struct SyncNotSend(#[allow(dead_code)] *mut ());\n\nunsafe impl Sync for SyncNotSend {}\n\ncfg_rt! {\n    pub(crate) struct NotSendOrSync(#[allow(dead_code)] *mut ());\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "eb7503662ae42fc22c9defc9fb22e49aedc215aa",
    "func": "use proc_macro::TokenStream;\n\nuse convert_case::{Case, Casing};\nuse quote::{quote, ToTokens, TokenStreamExt};\nuse syn::__private::TokenStream2;\nuse syn::parse::{Parse, ParseStream};\nuse syn::punctuated::Punctuated;\nuse syn::{braced, parse_macro_input, Ident, Token};\n\n#[proc_macro]\npub fn impl_extension_attributes(input: TokenStream) -> TokenStream {\n    let input = parse_macro_input!(input as ImplExtensionAttributes);\n    input.to_token_stream().into()\n}\n\nstruct ImplExtensionAttributes {\n    name: Ident,\n    attrs: Punctuated<Ident, Token![,]>,\n}\n\nimpl Parse for ImplExtensionAttributes {\n    fn parse(input: ParseStream) -> syn::Result<Self> {\n        let content;\n\n        let name = input.parse()?;\n        braced!(content in input);\n        let attrs = content.parse_terminated(Ident::parse, Token![,])?;\n\n        Ok(ImplExtensionAttributes { name, attrs })\n    }\n}\n\nimpl ToTokens for ImplExtensionAttributes {\n    fn to_tokens(&self, tokens: &mut TokenStream2) {\n        let name = &self.name;\n        let name_string = name.to_string();\n        let camel_name = name_string\n            .strip_prefix(\"r#\")\n            .unwrap_or(&name_string)\n            .to_case(Case::UpperCamel);\n        let extension_name = Ident::new(format!(\"{}Extension\", &camel_name).as_str(), name.span());\n\n        let impls = self.attrs.iter().map(|ident| {\n            let d = quote! { #name::#ident };\n            quote! {\n                fn #ident(self, value: impl IntoAttributeValue) -> Self {\n                    let d = #d;\n                    self.push_attribute(d.0, d.1, value, d.2)\n                }\n            }\n        });\n        tokens.append_all(quote! {\n            pub trait #extension_name: HasAttributes + Sized {\n                #(#impls)*\n            }\n        });\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "5d6898c98318824f69c863dff190254a4c9378e4",
    "func": "use crate::backend::Backend;\nuse crate::deserialize::{self, FromSql, Queryable, QueryableByName};\nuse crate::expression::bound::Bound;\nuse crate::expression::*;\nuse crate::query_builder::QueryId;\nuse crate::serialize::{self, IsNull, Output, ToSql};\nuse crate::sql_types::{is_nullable, HasSqlType, Nullable, SingleValue, SqlType};\nuse crate::NullableExpressionMethods;\n\nimpl<T, DB> HasSqlType<Nullable<T>> for DB\nwhere\n    DB: Backend + HasSqlType<T>,\n    T: SqlType,\n{\n    fn metadata(lookup: &mut DB::MetadataLookup) -> DB::TypeMetadata {\n        <DB as HasSqlType<T>>::metadata(lookup)\n    }\n}\n\nimpl<T> QueryId for Nullable<T>\nwhere\n    T: QueryId + SqlType<IsNull = is_nullable::NotNull>,\n{\n    type QueryId = T::QueryId;\n\n    const HAS_STATIC_QUERY_ID: bool = T::HAS_STATIC_QUERY_ID;\n}\n\nimpl<T, ST, DB> FromSql<Nullable<ST>, DB> for Option<T>\nwhere\n    T: FromSql<ST, DB>,\n    DB: Backend,\n    ST: SqlType<IsNull = is_nullable::NotNull>,\n{\n    fn from_sql(bytes: DB::RawValue<'_>) -> deserialize::Result<Self> {\n        T::from_sql(bytes).map(Some)\n    }\n\n    fn from_nullable_sql(bytes: Option<DB::RawValue<'_>>) -> deserialize::Result<Self> {\n        match bytes {\n            Some(bytes) => T::from_sql(bytes).map(Some),\n            None => Ok(None),\n        }\n    }\n}\n\nimpl<T, ST, DB> ToSql<Nullable<ST>, DB> for Option<T>\nwhere\n    T: ToSql<ST, DB>,\n    DB: Backend,\n    ST: SqlType<IsNull = is_nullable::NotNull>,\n{\n    fn to_sql<'b>(&'b self, out: &mut Output<'b, '_, DB>) -> serialize::Result {\n        if let Some(ref value) = *self {\n            value.to_sql(out)\n        } else {\n            Ok(IsNull::Yes)\n        }\n    }\n}\n\nimpl<T, ST> AsExpression<Nullable<ST>> for Option<T>\nwhere\n    ST: SqlType<IsNull = is_nullable::NotNull>,\n    Nullable<ST>: TypedExpressionType,\n{\n    type Expression = Bound<Nullable<ST>, Self>;\n\n    fn as_expression(self) -> Self::Expression {\n        Bound::new(self)\n    }\n}\n\nimpl<'a, T, ST> AsExpression<Nullable<ST>> for &'a Option<T>\nwhere\n    ST: SqlType<IsNull = is_nullable::NotNull>,\n    Nullable<ST>: TypedExpressionType,\n{\n    type Expression = Bound<Nullable<ST>, Self>;\n\n    fn as_expression(self) -> Self::Expression {\n        Bound::new(self)\n    }\n}\n\nimpl<T, DB> QueryableByName<DB> for Option<T>\nwhere\n    DB: Backend,\n    T: QueryableByName<DB>,\n{\n    fn build<'a>(row: &impl crate::row::NamedRow<'a, DB>) -> deserialize::Result<Self> {\n        match T::build(row) {\n            Ok(v) => Ok(Some(v)),\n            Err(e) if e.is::<crate::result::UnexpectedNullError>() => Ok(None),\n            Err(e) => Err(e),\n        }\n    }\n}\n\nimpl<ST, T, DB> Queryable<ST, DB> for Option<T>\nwhere\n    ST: SingleValue<IsNull = is_nullable::IsNullable>,\n    DB: Backend,\n    Self: FromSql<ST, DB>,\n{\n    type Row = Self;\n\n    fn build(row: Self::Row) -> deserialize::Result<Self> {\n        Ok(row)\n    }\n}\n\nimpl<T, DB> Selectable<DB> for Option<T>\nwhere\n    DB: Backend,\n    T: Selectable<DB>,\n    crate::dsl::Nullable<T::SelectExpression>: Expression,\n{\n    type SelectExpression = crate::dsl::Nullable<T::SelectExpression>;\n\n    fn construct_selection() -> Self::SelectExpression {\n        T::construct_selection().nullable()\n    }\n}\n\n#[test]\n#[cfg(feature = \"postgres\")]\nfn option_to_sql() {\n    use crate::pg::Pg;\n    use crate::query_builder::bind_collector::ByteWrapper;\n    use crate::sql_types;\n\n    type Type = sql_types::Nullable<sql_types::VarChar>;\n\n    let mut buffer = Vec::new();\n    let is_null = {\n        let mut bytes = Output::test(ByteWrapper(&mut buffer));\n        ToSql::<Type, Pg>::to_sql(&None::<String>, &mut bytes).unwrap()\n    };\n    assert_eq!(IsNull::Yes, is_null);\n    assert!(buffer.is_empty());\n\n    let is_null = {\n        let mut bytes = Output::test(ByteWrapper(&mut buffer));\n        ToSql::<Type, Pg>::to_sql(&Some(\"\"), &mut bytes).unwrap()\n    };\n    assert_eq!(IsNull::No, is_null);\n    assert!(buffer.is_empty());\n\n    let is_null = {\n        let mut bytes = Output::test(ByteWrapper(&mut buffer));\n        ToSql::<Type, Pg>::to_sql(&Some(\"Sean\"), &mut bytes).unwrap()\n    };\n    let expected_bytes = b\"Sean\".to_vec();\n    assert_eq!(IsNull::No, is_null);\n    assert_eq!(buffer, expected_bytes);\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "e155a3e50df200c648bfac8b703b89576426463c",
    "func": "use super::{Context, Module, ModuleConfig};\n\nuse crate::configs::go::GoConfig;\nuse crate::formatter::StringFormatter;\nuse crate::formatter::VersionFormatter;\n\nuse regex::Regex;\nuse semver::Version;\nuse semver::VersionReq;\nuse std::ops::Deref;\nuse std::sync::LazyLock;\n\n/// Creates a module with the current Go version\npub fn module<'a>(context: &'a Context) -> Option<Module<'a>> {\n    let mut module = context.new_module(\"golang\");\n    let config = GoConfig::try_load(module.config);\n    let is_go_project = context\n        .try_begin_scan()?\n        .set_files(&config.detect_files)\n        .set_extensions(&config.detect_extensions)\n        .set_folders(&config.detect_folders)\n        .is_match();\n\n    if !is_go_project {\n        return None;\n    }\n\n    let golang_version =\n        LazyLock::new(|| parse_go_version(&context.exec_cmd(\"go\", &[\"version\"])?.stdout));\n    let mod_version = LazyLock::new(|| get_go_mod_version(context));\n\n    let parsed = StringFormatter::new(config.format).and_then(|formatter| {\n        formatter\n            .map_meta(|var, _| match var {\n                \"symbol\" => Some(config.symbol),\n                _ => None,\n            })\n            .map_style(|variable| match variable {\n                \"style\" => {\n                    let in_mod_range =\n                        check_go_version(golang_version.as_deref(), mod_version.as_deref());\n\n                    if in_mod_range {\n                        Some(Ok(config.style))\n                    } else {\n                        Some(Ok(config.not_capable_style))\n                    }\n                }\n                _ => None,\n            })\n            .map(|variable| match variable {\n                \"version\" => {\n                    let go_ver = golang_version.deref().as_ref()?;\n\n                    VersionFormatter::format_module_version(\n                        module.get_name(),\n                        go_ver,\n                        config.version_format,\n                    )\n                    .map(Ok)\n                }\n                \"mod_version\" => {\n                    let in_mod_range =\n                        check_go_version(golang_version.as_deref(), mod_version.as_deref());\n                    let mod_ver = mod_version.as_deref()?.to_string();\n\n                    (!in_mod_range).then_some(Ok(mod_ver))\n                }\n                _ => None,\n            })\n            .parse(None, Some(context))\n    });\n\n    module.set_segments(match parsed {\n        Ok(segments) => segments,\n        Err(error) => {\n            log::warn!(\"Error in module `golang`:\\n{}\", error);\n            return None;\n        }\n    });\n\n    Some(module)\n}\n\nfn parse_go_version(go_stdout: &str) -> Option<String> {\n    // go version output looks like this:\n    // go version go1.13.3 linux/amd64\n\n    let version = go_stdout\n        // split into (\"\", \"1.12.4 linux/amd64\")\n        .split_once(\"go version go\")?\n        // return \"1.12.4 linux/amd64\"\n        .1\n        // split into [\"1.12.4\", \"linux/amd64\"]\n        .split_whitespace()\n        // return \"1.12.4\"\n        .next()?;\n\n    Some(version.to_string())\n}\n\nfn get_go_mod_version(context: &Context) -> Option<String> {\n    let mod_str = context.read_file_from_pwd(\"go.mod\")?;\n    let re = Regex::new(r\"(?:go\\s)(\\d+(\\.\\d+)+)\").unwrap();\n\n    if let Some(cap) = re.captures(&mod_str) {\n        let mod_ver = cap.get(1)?.as_str();\n        Some(mod_ver.to_string())\n    } else {\n        None\n    }\n}\n\nfn check_go_version(go_version: Option<&str>, mod_version: Option<&str>) -> bool {\n    let (Some(go_version), Some(mod_version)) = (go_version, mod_version) else {\n        return true;\n    };\n    let Ok(r) = VersionReq::parse(mod_version) else {\n        return true;\n    };\n    let Ok(v) = Version::parse(go_version) else {\n        return true;\n    };\n\n    r.matches(&v)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::test::ModuleRenderer;\n    use nu_ansi_term::Color;\n    use std::fs::{self, File};\n    use std::io;\n    use std::io::Write;\n\n    #[test]\n    fn folder_without_go_files() -> io::Result<()> {\n        let dir = tempfile::tempdir()?;\n\n        let actual = ModuleRenderer::new(\"golang\").path(dir.path()).collect();\n\n        let expected = None;\n        assert_eq!(expected, actual);\n        dir.close()\n    }\n\n    #[test]\n    fn folder_with_go_file() -> io::Result<()> {\n        let dir = tempfile::tempdir()?;\n        File::create(dir.path().join(\"main.go\"))?.sync_all()?;\n\n        let actual = ModuleRenderer::new(\"golang\").path(dir.path()).collect();\n\n        let expected = Some(format!(\"via {}\", Color::Cyan.bold().paint(\"\ud83d\udc39 v1.12.1 \")));\n        assert_eq!(expected, actual);\n        dir.close()\n    }\n\n    #[test]\n    fn folder_with_go_mod() -> io::Result<()> {\n        let dir = tempfile::tempdir()?;\n        File::create(dir.path().join(\"go.mod\"))?.sync_all()?;\n\n        let actual = ModuleRenderer::new(\"golang\").path(dir.path()).collect();\n\n        let expected = Some(format!(\"via {}\", Color::Cyan.bold().paint(\"\ud83d\udc39 v1.12.1 \")));\n        assert_eq!(expected, actual);\n        dir.close()\n    }\n\n    #[test]\n    fn folder_with_go_sum() -> io::Result<()> {\n        let dir = tempfile::tempdir()?;\n        File::create(dir.path().join(\"go.sum\"))?.sync_all()?;\n\n        let actual = ModuleRenderer::new(\"golang\").path(dir.path()).collect();\n\n        let expected = Some(format!(\"via {}\", Color::Cyan.bold().paint(\"\ud83d\udc39 v1.12.1 \")));\n        assert_eq!(expected, actual);\n        dir.close()\n    }\n\n    #[test]\n    fn folder_with_go_work() -> io::Result<()> {\n        let dir = tempfile::tempdir()?;\n        File::create(dir.path().join(\"go.work\"))?.sync_all()?;\n\n        let actual = ModuleRenderer::new(\"golang\").path(dir.path()).collect();\n\n        let expected = Some(format!(\"via {}\", Color::Cyan.bold().paint(\"\ud83d\udc39 v1.12.1 \")));\n        assert_eq!(expected, actual);\n        dir.close()\n    }\n\n    #[test]\n    fn folder_with_godeps() -> io::Result<()> {\n        let dir = tempfile::tempdir()?;\n        let godeps = dir.path().join(\"Godeps\");\n        fs::create_dir_all(godeps)?;\n\n        let actual = ModuleRenderer::new(\"golang\").path(dir.path()).collect();\n\n        let expected = Some(format!(\"via {}\", Color::Cyan.bold().paint(\"\ud83d\udc39 v1.12.1 \")));\n        assert_eq!(expected, actual);\n        dir.close()\n    }\n\n    #[test]\n    fn folder_with_glide_yaml() -> io::Result<()> {\n        let dir = tempfile::tempdir()?;\n        File::create(dir.path().join(\"glide.yaml\"))?.sync_all()?;\n\n        let actual = ModuleRenderer::new(\"golang\").path(dir.path()).collect();\n\n        let expected = Some(format!(\"via {}\", Color::Cyan.bold().paint(\"\ud83d\udc39 v1.12.1 \")));\n        assert_eq!(expected, actual);\n        dir.close()\n    }\n\n    #[test]\n    fn folder_with_gopkg_yml() -> io::Result<()> {\n        let dir = tempfile::tempdir()?;\n        File::create(dir.path().join(\"Gopkg.yml\"))?.sync_all()?;\n\n        let actual = ModuleRenderer::new(\"golang\").path(dir.path()).collect();\n\n        let expected = Some(format!(\"via {}\", Color::Cyan.bold().paint(\"\ud83d\udc39 v1.12.1 \")));\n        assert_eq!(expected, actual);\n        dir.close()\n    }\n    #[test]\n    fn folder_with_gopkg_lock() -> io::Result<()> {\n        let dir = tempfile::tempdir()?;\n        File::create(dir.path().join(\"Gopkg.lock\"))?.sync_all()?;\n\n        let actual = ModuleRenderer::new(\"golang\").path(dir.path()).collect();\n        let expected = Some(format!(\"via {}\", Color::Cyan.bold().paint(\"\ud83d\udc39 v1.12.1 \")));\n        assert_eq!(expected, actual);\n        dir.close()\n    }\n    #[test]\n    fn folder_with_go_version() -> io::Result<()> {\n        let dir = tempfile::tempdir()?;\n        File::create(dir.path().join(\".go-version\"))?.sync_all()?;\n\n        let actual = ModuleRenderer::new(\"golang\").path(dir.path()).collect();\n        let expected = Some(format!(\"via {}\", Color::Cyan.bold().paint(\"\ud83d\udc39 v1.12.1 \")));\n        assert_eq!(expected, actual);\n        dir.close()\n    }\n\n    #[test]\n    fn test_format_go_version() {\n        let input = \"go version go1.12 darwin/amd64\";\n        assert_eq!(parse_go_version(input), Some(\"1.12\".to_string()));\n    }\n\n    #[test]\n    fn show_mod_version_if_not_matching_go_version() -> io::Result<()> {\n        let dir = tempfile::tempdir()?;\n        let mut file = File::create(dir.path().join(\"go.mod\"))?;\n        file.write_all(\n            b\"package test\\n\\n\n            go 1.16\",\n        )?;\n        file.sync_all()?;\n\n        let actual = ModuleRenderer::new(\"golang\")\n            .path(dir.path())\n            .config(toml::toml! {\n                [golang]\n                format = \"via [$symbol($version )($mod_version )]($style)\"\n            })\n            .collect();\n        let expected = Some(format!(\n            \"via {}\",\n            Color::Red.bold().paint(\"\ud83d\udc39 v1.12.1 1.16 \")\n        ));\n\n        assert_eq!(expected, actual);\n        dir.close()\n    }\n\n    #[test]\n    fn hide_mod_version_when_it_matches_go_version() -> io::Result<()> {\n        let dir = tempfile::tempdir()?;\n        let mut file = File::create(dir.path().join(\"go.mod\"))?;\n        file.write_all(\n            b\"package test\\n\\n\n            go 1.12\",\n        )?;\n        file.sync_all()?;\n\n        let actual = ModuleRenderer::new(\"golang\")\n            .path(dir.path())\n            .config(toml::toml! {\n                [golang]\n                format = \"via [$symbol($version )($mod_version )]($style)\"\n            })\n            .collect();\n        let expected = Some(format!(\"via {}\", Color::Cyan.bold().paint(\"\ud83d\udc39 v1.12.1 \")));\n\n        assert_eq!(expected, actual);\n        dir.close()\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "3225dddac40d139b7588bfa2e29434b1c9b1bb35",
    "func": "use axum_macros::FromRequestParts;\nuse axum::{\n    extract::{FromRef, State, Query},\n    Router,\n    routing::get,\n};\nuse std::collections::HashMap;\n\nfn main() {\n    let _: axum::Router = Router::new()\n        .route(\"/b\", get(|_: Extractor| async {}))\n        .with_state(AppState::default());\n}\n\n#[derive(FromRequestParts)]\n#[from_request(state(AppState))]\nstruct Extractor {\n    inner_state: State<InnerState>,\n    other: Query<HashMap<String, String>>,\n}\n\n#[derive(Default, Clone)]\nstruct AppState {\n    inner: InnerState,\n}\n\n#[derive(Clone, Default)]\nstruct InnerState {}\n\nimpl FromRef<AppState> for InnerState {\n    fn from_ref(input: &AppState) -> Self {\n        input.inner.clone()\n    }\n}\n"
  }
]