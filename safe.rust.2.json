[
  {
    "project": "",
    "target": 0,
    "commit_id": "e16cd3f67881a64decb295bc8197c5232572e1e4",
    "func": "// Copyright 2019-2024 Tauri Programme within The Commons Conservancy\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n\nuse proc_macro2::TokenStream;\nuse quote::{quote, ToTokens};\nuse syn::parse::{Parse, ParseStream};\nuse syn::{\n  parse_quote, DeriveInput, Error, GenericParam, Ident, ItemTrait, ItemType, Token, Type, TypeParam,\n};\n\n#[derive(Clone)]\npub(crate) enum Input {\n  Derive(DeriveInput),\n  Trait(ItemTrait),\n  Type(ItemType),\n}\n\nimpl Parse for Input {\n  fn parse(input: ParseStream) -> syn::Result<Self> {\n    input\n      .parse::<DeriveInput>()\n      .map(Self::Derive)\n      .or_else(|_| input.parse().map(Self::Trait))\n      .or_else(|_| input.parse().map(Self::Type))\n      .map_err(|_| {\n        Error::new(\n          input.span(),\n          \"default_runtime only supports `struct`, `enum`, `type`, or `trait` definitions\",\n        )\n      })\n  }\n}\n\nimpl Input {\n  fn last_param_mut(&mut self) -> Option<&mut GenericParam> {\n    match self {\n      Input::Derive(d) => d.generics.params.last_mut(),\n      Input::Trait(t) => t.generics.params.last_mut(),\n      Input::Type(t) => t.generics.params.last_mut(),\n    }\n  }\n}\n\nimpl ToTokens for Input {\n  fn to_tokens(&self, tokens: &mut TokenStream) {\n    match self {\n      Input::Derive(d) => d.to_tokens(tokens),\n      Input::Trait(t) => t.to_tokens(tokens),\n      Input::Type(t) => t.to_tokens(tokens),\n    }\n  }\n}\n\n/// The default runtime type to enable when the provided feature is enabled.\npub(crate) struct Attributes {\n  default_type: Type,\n  feature: Ident,\n}\n\nimpl Parse for Attributes {\n  fn parse(input: ParseStream<'_>) -> syn::Result<Self> {\n    let default_type = input.parse()?;\n    input.parse::<Token![,]>()?;\n    Ok(Attributes {\n      default_type,\n      feature: input.parse()?,\n    })\n  }\n}\n\npub(crate) fn default_runtime(attributes: Attributes, input: Input) -> TokenStream {\n  // create a new copy to manipulate for the wry feature flag\n  let mut wry = input.clone();\n  let wry_runtime = wry\n    .last_param_mut()\n    .expect(\"default_runtime requires the item to have at least 1 generic parameter\");\n\n  // set the default value of the last generic parameter to the provided runtime type\n  match wry_runtime {\n    GenericParam::Type(\n      param @ TypeParam {\n        eq_token: None,\n        default: None,\n        ..\n      },\n    ) => {\n      param.eq_token = Some(parse_quote!(=));\n      param.default = Some(attributes.default_type);\n    }\n    _ => {\n      panic!(\"DefaultRuntime requires the last parameter to not have a default value\")\n    }\n  };\n\n  let feature = attributes.feature.to_string();\n\n  quote!(\n    #[cfg(feature = #feature)]\n    #wry\n\n    #[cfg(not(feature = #feature))]\n    #input\n  )\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "7a8df85b8f1f315d1901fed63ca09e539fc911a6",
    "func": "use crate::schema::*;\nuse diesel::*;\n\n#[test]\nfn filter_by_inequality() {\n    use crate::schema::users::dsl::*;\n\n    let connection = &mut connection_with_sean_and_tess_in_users_table();\n    let sean = User::new(1, \"Sean\");\n    let tess = User::new(2, \"Tess\");\n\n    assert_eq!(\n        vec![tess.clone()],\n        users.filter(name.ne(\"Sean\")).load(connection).unwrap()\n    );\n    assert_eq!(\n        vec![sean.clone()],\n        users.filter(name.ne(\"Tess\")).load(connection).unwrap()\n    );\n    assert_eq!(\n        vec![sean, tess],\n        users\n            .filter(name.ne(\"Jim\"))\n            .order(id.asc())\n            .load(connection)\n            .unwrap()\n    );\n}\n\n#[test]\nfn filter_by_gt() {\n    use crate::schema::users::dsl::*;\n\n    let connection = &mut connection_with_3_users();\n    let tess = User::new(2, \"Tess\");\n    let jim = User::new(3, \"Jim\");\n\n    assert_eq!(\n        vec![tess, jim.clone()],\n        users\n            .filter(id.gt(1))\n            .order(id.asc())\n            .load(connection)\n            .unwrap()\n    );\n    assert_eq!(vec![jim], users.filter(id.gt(2)).load(connection).unwrap());\n}\n\n#[test]\nfn filter_by_ge() {\n    use crate::schema::users::dsl::*;\n\n    let connection = &mut connection_with_3_users();\n    let tess = User::new(2, \"Tess\");\n    let jim = User::new(3, \"Jim\");\n\n    assert_eq!(\n        vec![tess, jim.clone()],\n        users\n            .filter(id.ge(2))\n            .order(id.asc())\n            .load(connection)\n            .unwrap()\n    );\n    assert_eq!(vec![jim], users.filter(id.ge(3)).load(connection).unwrap());\n}\n\n#[test]\nfn filter_by_lt() {\n    use crate::schema::users::dsl::*;\n\n    let connection = &mut connection_with_3_users();\n    let sean = User::new(1, \"Sean\");\n    let tess = User::new(2, \"Tess\");\n\n    assert_eq!(\n        vec![sean.clone(), tess],\n        users\n            .filter(id.lt(3))\n            .order(id.asc())\n            .load(connection)\n            .unwrap()\n    );\n    assert_eq!(vec![sean], users.filter(id.lt(2)).load(connection).unwrap());\n}\n\n#[test]\nfn filter_by_le() {\n    use crate::schema::users::dsl::*;\n\n    let connection = &mut connection_with_3_users();\n    let sean = User::new(1, \"Sean\");\n    let tess = User::new(2, \"Tess\");\n\n    assert_eq!(\n        vec![sean.clone(), tess],\n        users\n            .filter(id.le(2))\n            .order(id.asc())\n            .load(connection)\n            .unwrap()\n    );\n    assert_eq!(vec![sean], users.filter(id.le(1)).load(connection).unwrap());\n}\n\n#[test]\nfn filter_by_between() {\n    use crate::schema::users::dsl::*;\n\n    let connection = &mut connection_with_3_users();\n    let sean = User::new(1, \"Sean\");\n    let tess = User::new(2, \"Tess\");\n    let jim = User::new(3, \"Jim\");\n\n    assert_eq!(\n        vec![sean, tess.clone(), jim.clone()],\n        users\n            .filter(id.between(1, 3))\n            .order(id.asc())\n            .load(connection)\n            .unwrap()\n    );\n    assert_eq!(\n        vec![tess, jim],\n        users\n            .filter(id.between(2, 3))\n            .order(id.asc())\n            .load(connection)\n            .unwrap()\n    );\n}\n\n#[test]\nfn filter_by_like() {\n    use crate::schema::users::dsl::*;\n\n    let connection = &mut connection();\n    let data = vec![\n        NewUser::new(\"Sean Griffin\", None),\n        NewUser::new(\"Tess Griffin\", None),\n        NewUser::new(\"Jim\", None),\n    ];\n    insert_into(users)\n        .values(&data)\n        .execute(connection)\n        .unwrap();\n    let data = users.load::<User>(connection).unwrap();\n    let sean = data[0].clone();\n    let tess = data[1].clone();\n    let jim = data[2].clone();\n\n    assert_eq!(\n        vec![sean, tess],\n        users\n            .filter(name.like(\"%Griffin\"))\n            .order(id.asc())\n            .load(connection)\n            .unwrap()\n    );\n    assert_eq!(\n        vec![jim],\n        users\n            .filter(name.not_like(\"%Griffin\"))\n            .order(id.asc())\n            .load(connection)\n            .unwrap()\n    );\n}\n\n#[test]\n#[cfg(feature = \"postgres\")]\nfn filter_by_ilike() {\n    use crate::schema::users::dsl::*;\n\n    let connection = &mut connection();\n    let data = vec![\n        NewUser::new(\"Sean Griffin\", None),\n        NewUser::new(\"Tess Griffin\", None),\n        NewUser::new(\"Jim\", None),\n    ];\n    insert_into(users)\n        .values(&data)\n        .execute(connection)\n        .unwrap();\n    let data = users.load::<User>(connection).unwrap();\n    let sean = data[0].clone();\n    let tess = data[1].clone();\n    let jim = data[2].clone();\n\n    assert_eq!(\n        vec![sean, tess],\n        users\n            .filter(name.ilike(\"%grifFin\"))\n            .order(id.asc())\n            .load(connection)\n            .unwrap()\n    );\n    assert_eq!(\n        vec![jim],\n        users\n            .filter(name.not_ilike(\"%grifFin\"))\n            .order(id.asc())\n            .load(connection)\n            .unwrap()\n    );\n}\n\n#[test]\n#[cfg(feature = \"postgres\")]\nfn filter_by_any() {\n    use crate::schema::users::dsl::*;\n\n    let connection = &mut connection_with_3_users();\n    let sean = User::new(1, \"Sean\");\n    let tess = User::new(2, \"Tess\");\n    let jim = User::new(3, \"Jim\");\n\n    let owned_names = vec![\"Sean\", \"Tess\"];\n    let borrowed_names: &[&str] = &[\"Sean\", \"Jim\"];\n    assert_eq!(\n        vec![sean.clone(), tess],\n        users\n            .filter(name.eq_any(owned_names))\n            .order(id.asc())\n            .load(connection)\n            .unwrap()\n    );\n    assert_eq!(\n        vec![sean, jim],\n        users\n            .filter(name.eq_any(borrowed_names))\n            .order(id.asc())\n            .load(connection)\n            .unwrap()\n    );\n}\n\n#[test]\nfn filter_by_in() {\n    use crate::schema::users::dsl::*;\n\n    let connection = &mut connection_with_3_users();\n    let sean = User::new(1, \"Sean\");\n    let tess = User::new(2, \"Tess\");\n    let jim = User::new(3, \"Jim\");\n\n    let owned_names = vec![\"Sean\", \"Tess\"];\n    let borrowed_names: &[&str] = &[\"Sean\", \"Jim\"];\n    assert_eq!(\n        vec![sean.clone(), tess],\n        users\n            .filter(name.eq_any(owned_names))\n            .order(id.asc())\n            .load(connection)\n            .unwrap()\n    );\n    assert_eq!(\n        vec![sean, jim],\n        users\n            .filter(name.eq_any(borrowed_names))\n            .order(id.asc())\n            .load(connection)\n            .unwrap()\n    );\n}\n\nfn connection_with_3_users() -> TestConnection {\n    let mut connection = connection_with_sean_and_tess_in_users_table();\n    diesel::sql_query(\"INSERT INTO users (id, name) VALUES (3, 'Jim')\")\n        .execute(&mut connection)\n        .unwrap();\n    connection\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "b34ef697ed306bc5346ecd25c727dbafbe931b51",
    "func": "#![cfg(feature = \"tls\")]\n\nuse rocket::fs::relative;\nuse rocket::local::asynchronous::Client;\nuse rocket::tls::{TlsConfig, CipherSuite};\nuse rocket::figment::providers::Serialized;\n\n#[rocket::async_test]\nasync fn can_launch_tls() {\n    let cert_path = relative!(\"examples/tls/private/rsa_sha256_cert.pem\");\n    let key_path = relative!(\"examples/tls/private/rsa_sha256_key.pem\");\n\n    let tls = TlsConfig::from_paths(cert_path, key_path)\n        .with_ciphers([\n            CipherSuite::TLS_AES_128_GCM_SHA256,\n            CipherSuite::TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,\n        ]);\n\n    let config = rocket::Config::figment().merge(Serialized::defaults(tls));\n    let client = Client::debug(rocket::custom(config)).await.unwrap();\n    client.rocket().shutdown().notify();\n    client.rocket().shutdown().await;\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "7fd9f70bed0cfb7c15a3886a9b173b0fc4ae6129",
    "func": "#[macro_use] extern crate rocket;\n\nstruct BadType;\n\n#[derive(UriDisplayQuery)]\nstruct Bar1(BadType);\n\n#[derive(UriDisplayQuery)]\nstruct Bar2 {\n    field: BadType,\n}\n\n#[derive(UriDisplayQuery)]\nstruct Bar3 {\n    field: String,\n    bad: BadType,\n}\n\n#[derive(UriDisplayQuery)]\nenum Bar4 {\n    Inner(BadType),\n}\n\n#[derive(UriDisplayQuery)]\nenum Bar5 {\n    Inner {\n        field: BadType,\n    },\n}\n\n#[derive(UriDisplayQuery)]\nenum Bar6 {\n    Inner {\n        field: String,\n        other: BadType,\n    },\n}\n\n#[derive(UriDisplayPath)]\nstruct Baz(BadType);\n\nfn main() {  }\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "a612848d3e154f22796c52632ae1c423ace28023",
    "func": "use axum::{\n    extract::{FromRef, State},\n    routing::get,\n    Router,\n};\nuse axum_macros::FromRequest;\n\nfn main() {\n    let _: axum::Router = Router::new()\n        .route(\"/a\", get(|_: AppState| async {}))\n        .route(\"/b\", get(|_: InnerState| async {}))\n        .with_state(AppState::default());\n}\n\n#[derive(Clone, FromRequest)]\n#[from_request(via(State))]\nenum AppState {\n    One,\n}\n\nimpl Default for AppState {\n    fn default() -> AppState {\n        Self::One\n    }\n}\n\n#[derive(FromRequest)]\n#[from_request(via(State), state(AppState))]\nenum InnerState {}\n\nimpl FromRef<AppState> for InnerState {\n    fn from_ref(_: &AppState) -> Self {\n        todo!(\"\ud83e\udd37\")\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "3e556b596ae746f5f44c68da8c18dcea624ed75c",
    "func": "use proc_macro2::{Span, TokenStream};\nuse proc_macro_error::emit_error;\nuse quote::quote;\nuse syn::parse::{Parse, ParseStream};\nuse syn::{\n    parse_file, parse_quote, visit_mut, Attribute, Ident, ItemFn, LitStr, ReturnType, Signature,\n    Type,\n};\n\nmod body;\nmod lifetime;\nmod signature;\n\npub use body::BodyRewriter;\nuse signature::HookSignature;\n\n#[derive(Clone)]\npub struct HookFn {\n    inner: ItemFn,\n}\n\nimpl Parse for HookFn {\n    fn parse(input: ParseStream) -> syn::Result<Self> {\n        let func: ItemFn = input.parse()?;\n\n        let sig = func.sig.clone();\n\n        if sig.asyncness.is_some() {\n            emit_error!(sig.asyncness, \"async functions can't be hooks\");\n        }\n\n        if sig.constness.is_some() {\n            emit_error!(sig.constness, \"const functions can't be hooks\");\n        }\n\n        if sig.abi.is_some() {\n            emit_error!(sig.abi, \"extern functions can't be hooks\");\n        }\n\n        if sig.unsafety.is_some() {\n            emit_error!(sig.unsafety, \"unsafe functions can't be hooks\");\n        }\n\n        if !sig.ident.to_string().starts_with(\"use_\") {\n            emit_error!(sig.ident, \"hooks must have a name starting with `use_`\");\n        }\n\n        Ok(Self { inner: func })\n    }\n}\n\nimpl HookFn {\n    fn doc_attr(&self) -> Attribute {\n        let vis = &self.inner.vis;\n        let sig = &self.inner.sig;\n\n        let sig_s = quote! { #vis #sig {\n            __yew_macro_dummy_function_body__\n        } }\n        .to_string();\n\n        let sig_file = parse_file(&sig_s).unwrap();\n        let sig_formatted = prettyplease::unparse(&sig_file);\n\n        let literal = LitStr::new(\n            &format!(\n                r#\"\n# Note\n\nWhen used in function components and hooks, this hook is equivalent to:\n\n```\n{}\n```\n\"#,\n                sig_formatted.replace(\n                    \"__yew_macro_dummy_function_body__\",\n                    \"/* implementation omitted */\"\n                )\n            ),\n            Span::mixed_site(),\n        );\n\n        parse_quote!(#[doc = #literal])\n    }\n}\n\npub fn hook_impl(hook: HookFn) -> syn::Result<TokenStream> {\n    let doc_attr = hook.doc_attr();\n\n    let HookFn { inner: original_fn } = hook;\n\n    let ItemFn {\n        ref vis,\n        ref sig,\n        ref block,\n        ref attrs,\n    } = original_fn;\n    let mut block = *block.clone();\n\n    let hook_sig = HookSignature::rewrite(sig);\n\n    let Signature {\n        ref fn_token,\n        ref ident,\n        ref inputs,\n        output: ref hook_return_type,\n        ref generics,\n        ..\n    } = hook_sig.sig;\n\n    let output_type = &hook_sig.output_type;\n\n    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();\n    let call_generics = hook_sig.call_generics();\n\n    // We use _ctx so that if a hook does not use other hooks, it will not trigger unused_vars.\n    let ctx_ident = Ident::new(\"_ctx\", Span::mixed_site());\n\n    let mut body_rewriter = BodyRewriter::new(ctx_ident.clone());\n    visit_mut::visit_block_mut(&mut body_rewriter, &mut block);\n\n    let inner_fn_ident = Ident::new(\"inner_fn\", Span::mixed_site());\n    let input_args = hook_sig.input_args();\n\n    // there might be some overridden lifetimes in the return type.\n    let inner_fn_rt = match &sig.output {\n        ReturnType::Default => None,\n        ReturnType::Type(rarrow, _) => Some(quote! { #rarrow #output_type }),\n    };\n\n    let inner_fn = quote! { fn #inner_fn_ident #generics (#ctx_ident: &mut ::yew::functional::HookContext, #inputs) #inner_fn_rt #where_clause #block };\n\n    let inner_type_impl = if hook_sig.needs_boxing {\n        let with_output = !matches!(hook_sig.output_type, Type::ImplTrait(_),);\n        let inner_fn_rt = with_output.then_some(&inner_fn_rt);\n        let output_type = with_output.then_some(&output_type);\n\n        let hook_lifetime = &hook_sig.hook_lifetime;\n        let hook_lifetime_plus = quote! { #hook_lifetime + };\n\n        let boxed_inner_ident = Ident::new(\"boxed_inner\", Span::mixed_site());\n        let boxed_fn_type = quote! { ::std::boxed::Box<dyn #hook_lifetime_plus ::std::ops::FnOnce(&mut ::yew::functional::HookContext) #inner_fn_rt> };\n\n        let as_boxed_fn = with_output.then(|| quote! { as #boxed_fn_type });\n\n        let generic_types = generics.type_params().map(|t| &t.ident);\n\n        // We need boxing implementation for `impl Trait` arguments.\n        quote! {\n            let #boxed_inner_ident = ::std::boxed::Box::new(\n                    move |#ctx_ident: &mut ::yew::functional::HookContext| #inner_fn_rt {\n                        #inner_fn_ident :: <#(#generic_types,)*> (#ctx_ident, #(#input_args,)*)\n                    }\n                ) #as_boxed_fn;\n\n            ::yew::functional::BoxedHook::<#hook_lifetime, #output_type>::new(#boxed_inner_ident)\n        }\n    } else {\n        let input_types = hook_sig.input_types();\n\n        let args_ident = Ident::new(\"args\", Span::mixed_site());\n        let hook_struct_name = Ident::new(\"HookProvider\", Span::mixed_site());\n\n        let phantom_types = hook_sig.phantom_types();\n        let phantom_lifetimes = hook_sig.phantom_lifetimes();\n\n        quote! {\n            struct #hook_struct_name #generics #where_clause {\n                _marker: ::std::marker::PhantomData<( #(#phantom_types,)* #(#phantom_lifetimes,)* )>,\n                #args_ident: (#(#input_types,)*),\n            }\n\n            #[automatically_derived]\n            impl #impl_generics ::yew::functional::Hook for #hook_struct_name #ty_generics #where_clause {\n                type Output = #output_type;\n\n                fn run(mut self, #ctx_ident: &mut ::yew::functional::HookContext) -> Self::Output {\n                    let (#(#input_args,)*) = self.#args_ident;\n\n                    #inner_fn_ident #call_generics (#ctx_ident, #(#input_args,)*)\n                }\n            }\n\n            #[automatically_derived]\n            impl #impl_generics #hook_struct_name #ty_generics #where_clause {\n                fn new(#inputs) -> Self {\n                   #hook_struct_name {\n                        _marker: ::std::marker::PhantomData,\n                        #args_ident: (#(#input_args,)*),\n                    }\n                }\n            }\n\n            #hook_struct_name #call_generics ::new(#(#input_args,)*)\n        }\n    };\n\n    // There're some weird issues with doc tests that it cannot detect return types properly.\n    // So we print original implementation instead.\n    let output = quote! {\n        #[cfg(not(doctest))]\n        #(#attrs)*\n        #doc_attr\n        #vis #fn_token #ident #generics (#inputs) #hook_return_type #where_clause {\n            #inner_fn\n\n            #inner_type_impl\n        }\n\n        #[cfg(doctest)]\n        #original_fn\n    };\n\n    Ok(output)\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "be3174dd34d0f9f29ae0610911ab7ad99e5911a1",
    "func": "//! Originally taken from `hyper::header::parsing`.\n\nuse std::{fmt, str::FromStr};\n\nuse language_tags::LanguageTag;\n\nuse crate::header::{Charset, HTTP_VALUE};\n\n/// The value part of an extended parameter consisting of three parts:\n/// - The REQUIRED character set name (`charset`).\n/// - The OPTIONAL language information (`language_tag`).\n/// - A character sequence representing the actual value (`value`), separated by single quotes.\n///\n/// It is defined in [RFC 5987 \u00a73.2](https://datatracker.ietf.org/doc/html/rfc5987#section-3.2).\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct ExtendedValue {\n    /// The character set that is used to encode the `value` to a string.\n    pub charset: Charset,\n\n    /// The human language details of the `value`, if available.\n    pub language_tag: Option<LanguageTag>,\n\n    /// The parameter value, as expressed in octets.\n    pub value: Vec<u8>,\n}\n\n/// Parses extended header parameter values (`ext-value`), as defined\n/// in [RFC 5987 \u00a73.2](https://datatracker.ietf.org/doc/html/rfc5987#section-3.2).\n///\n/// Extended values are denoted by parameter names that end with `*`.\n///\n/// ## ABNF\n///\n/// ```plain\n/// ext-value     = charset  \"'\" [ language ] \"'\" value-chars\n///               ; like RFC 2231's <extended-initial-value>\n///               ; (see [RFC 2231 \u00a77])\n///\n/// charset       = \"UTF-8\" / \"ISO-8859-1\" / mime-charset\n///\n/// mime-charset  = 1*mime-charsetc\n/// mime-charsetc = ALPHA / DIGIT\n///               / \"!\" / \"#\" / \"$\" / \"%\" / \"&\"\n///               / \"+\" / \"-\" / \"^\" / \"_\" / \"`\"\n///               / \"{\" / \"}\" / \"~\"\n///               ; as <mime-charset> in [RFC 2978 \u00a72.3]\n///               ; except that the single quote is not included\n///               ; SHOULD be registered in the IANA charset registry\n///\n/// language      = <Language-Tag, defined in [RFC 5646 \u00a72.1]>\n///\n/// value-chars   = *( pct-encoded / attr-char )\n///\n/// pct-encoded   = \"%\" HEXDIG HEXDIG\n///               ; see [RFC 3986 \u00a72.1]\n///\n/// attr-char     = ALPHA / DIGIT\n///               / \"!\" / \"#\" / \"$\" / \"&\" / \"+\" / \"-\" / \".\"\n///               / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n///               ; token except ( \"*\" / \"'\" / \"%\" )\n/// ```\n///\n/// [RFC 2231 \u00a77]: https://datatracker.ietf.org/doc/html/rfc2231#section-7\n/// [RFC 2978 \u00a72.3]: https://datatracker.ietf.org/doc/html/rfc2978#section-2.3\n/// [RFC 3986 \u00a72.1]: https://datatracker.ietf.org/doc/html/rfc5646#section-2.1\npub fn parse_extended_value(val: &str) -> Result<ExtendedValue, crate::error::ParseError> {\n    // Break into three pieces separated by the single-quote character\n    let mut parts = val.splitn(3, '\\'');\n\n    // Interpret the first piece as a Charset\n    let charset: Charset = match parts.next() {\n        None => return Err(crate::error::ParseError::Header),\n        Some(n) => FromStr::from_str(n).map_err(|_| crate::error::ParseError::Header)?,\n    };\n\n    // Interpret the second piece as a language tag\n    let language_tag: Option<LanguageTag> = match parts.next() {\n        None => return Err(crate::error::ParseError::Header),\n        Some(\"\") => None,\n        Some(s) => match s.parse() {\n            Ok(lt) => Some(lt),\n            Err(_) => return Err(crate::error::ParseError::Header),\n        },\n    };\n\n    // Interpret the third piece as a sequence of value characters\n    let value: Vec<u8> = match parts.next() {\n        None => return Err(crate::error::ParseError::Header),\n        Some(v) => percent_encoding::percent_decode(v.as_bytes()).collect(),\n    };\n\n    Ok(ExtendedValue {\n        charset,\n        language_tag,\n        value,\n    })\n}\n\nimpl fmt::Display for ExtendedValue {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let encoded_value = percent_encoding::percent_encode(&self.value[..], HTTP_VALUE);\n        if let Some(ref lang) = self.language_tag {\n            write!(f, \"{}'{}'{}\", self.charset, lang, encoded_value)\n        } else {\n            write!(f, \"{}''{}\", self.charset, encoded_value)\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_parse_extended_value_with_encoding_and_language_tag() {\n        let expected_language_tag = \"en\".parse::<LanguageTag>().unwrap();\n        // RFC 5987, Section 3.2.2\n        // Extended notation, using the Unicode character U+00A3 (POUND SIGN)\n        let result = parse_extended_value(\"iso-8859-1'en'%A3%20rates\");\n        assert!(result.is_ok());\n        let extended_value = result.unwrap();\n        assert_eq!(Charset::Iso_8859_1, extended_value.charset);\n        assert!(extended_value.language_tag.is_some());\n        assert_eq!(expected_language_tag, extended_value.language_tag.unwrap());\n        assert_eq!(\n            vec![163, b' ', b'r', b'a', b't', b'e', b's'],\n            extended_value.value\n        );\n    }\n\n    #[test]\n    fn test_parse_extended_value_with_encoding() {\n        // RFC 5987, Section 3.2.2\n        // Extended notation, using the Unicode characters U+00A3 (POUND SIGN)\n        // and U+20AC (EURO SIGN)\n        let result = parse_extended_value(\"UTF-8''%c2%a3%20and%20%e2%82%ac%20rates\");\n        assert!(result.is_ok());\n        let extended_value = result.unwrap();\n        assert_eq!(Charset::Ext(\"UTF-8\".to_string()), extended_value.charset);\n        assert!(extended_value.language_tag.is_none());\n        assert_eq!(\n            vec![\n                194, 163, b' ', b'a', b'n', b'd', b' ', 226, 130, 172, b' ', b'r', b'a', b't',\n                b'e', b's',\n            ],\n            extended_value.value\n        );\n    }\n\n    #[test]\n    fn test_parse_extended_value_missing_language_tag_and_encoding() {\n        // From: https://greenbytes.de/tech/tc2231/#attwithfn2231quot2\n        let result = parse_extended_value(\"foo%20bar.html\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_parse_extended_value_partially_formatted() {\n        let result = parse_extended_value(\"UTF-8'missing third part\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_parse_extended_value_partially_formatted_blank() {\n        let result = parse_extended_value(\"blank second part'\");\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_fmt_extended_value_with_encoding_and_language_tag() {\n        let extended_value = ExtendedValue {\n            charset: Charset::Iso_8859_1,\n            language_tag: Some(\"en\".parse().expect(\"Could not parse language tag\")),\n            value: vec![163, b' ', b'r', b'a', b't', b'e', b's'],\n        };\n        assert_eq!(\"ISO-8859-1'en'%A3%20rates\", format!(\"{}\", extended_value));\n    }\n\n    #[test]\n    fn test_fmt_extended_value_with_encoding() {\n        let extended_value = ExtendedValue {\n            charset: Charset::Ext(\"UTF-8\".to_string()),\n            language_tag: None,\n            value: vec![\n                194, 163, b' ', b'a', b'n', b'd', b' ', 226, 130, 172, b' ', b'r', b'a', b't',\n                b'e', b's',\n            ],\n        };\n        assert_eq!(\n            \"UTF-8''%C2%A3%20and%20%E2%82%AC%20rates\",\n            format!(\"{}\", extended_value)\n        );\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "f36b5fcee7e746cd7143d3d5170b5abacb650966",
    "func": "use axum::{Router, routing::get, extract::{State, FromRef}};\n\n// This will implement `FromRef` for each field in the struct.\n#[derive(Clone, FromRef)]\nstruct AppState {\n    auth_token: String,\n}\n\n// So those types can be extracted via `State`\nasync fn handler(_: State<String>) {}\n\nfn main() {\n    let state = AppState {\n        auth_token: Default::default(),\n    };\n\n    let _: axum::Router = Router::new()\n        .route(\"/\", get(handler))\n        .with_state(state);\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "8dcb9a2a8120d2ff85cdf1dfd72dd4ac9f7a47f5",
    "func": "#![deny(trivial_numeric_casts)]\n#![allow(\n    clippy::derive_partial_eq_without_eq,\n    clippy::enum_variant_names,\n    clippy::redundant_field_names,\n    clippy::too_many_lines\n)]\n\nuse serde_derive::{Deserialize, Serialize};\nuse serde_test::{assert_de_tokens, assert_de_tokens_error, assert_tokens, Token};\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\n#[serde(tag = \"t\", content = \"c\")]\nenum AdjacentlyTagged<T> {\n    Unit,\n    Newtype(T),\n    Tuple(u8, u8),\n    Struct { f: u8 },\n}\n\nmod unit {\n    use super::*;\n\n    #[test]\n    fn map_str_tag_only() {\n        // Map: tag only\n        assert_tokens(\n            &AdjacentlyTagged::Unit::<u8>,\n            &[\n                Token::Struct {\n                    name: \"AdjacentlyTagged\",\n                    len: 1,\n                },\n                Token::Str(\"t\"),\n                Token::UnitVariant {\n                    name: \"AdjacentlyTagged\",\n                    variant: \"Unit\",\n                },\n                Token::StructEnd,\n            ],\n        );\n\n        // Map: tag only and incorrect hint for number of elements\n        assert_de_tokens(\n            &AdjacentlyTagged::Unit::<u8>,\n            &[\n                Token::Struct {\n                    name: \"AdjacentlyTagged\",\n                    len: 2,\n                },\n                Token::Str(\"t\"),\n                Token::UnitVariant {\n                    name: \"AdjacentlyTagged\",\n                    variant: \"Unit\",\n                },\n                Token::StructEnd,\n            ],\n        );\n    }\n\n    #[test]\n    fn map_int_tag_only() {\n        // Map: tag (as number) only\n        assert_de_tokens(\n            &AdjacentlyTagged::Unit::<u8>,\n            &[\n                Token::Struct {\n                    name: \"AdjacentlyTagged\",\n                    len: 1,\n                },\n                Token::U16(0),\n                Token::UnitVariant {\n                    name: \"AdjacentlyTagged\",\n                    variant: \"Unit\",\n                },\n                Token::StructEnd,\n            ],\n        );\n    }\n\n    #[test]\n    fn map_bytes_tag_only() {\n        // Map: tag only\n        assert_de_tokens(\n            &AdjacentlyTagged::Unit::<u8>,\n            &[\n                Token::Struct {\n                    name: \"AdjacentlyTagged\",\n                    len: 1,\n                },\n                Token::Bytes(b\"t\"),\n                Token::UnitVariant {\n                    name: \"AdjacentlyTagged\",\n                    variant: \"Unit\",\n                },\n                Token::StructEnd,\n            ],\n        );\n\n        // Map: tag only\n        assert_de_tokens(\n            &AdjacentlyTagged::Unit::<u8>,\n            &[\n                Token::Struct {\n                    name: \"AdjacentlyTagged\",\n                    len: 1,\n                },\n                Token::BorrowedBytes(b\"t\"),\n                Token::UnitVariant {\n                    name: \"AdjacentlyTagged\",\n                    variant: \"Unit\",\n                },\n                Token::StructEnd,\n            ],\n        );\n    }\n\n    #[test]\n    fn map_str_tag_content() {\n        // Map: tag + content\n        assert_de_tokens(\n            &AdjacentlyTagged::Unit::<u8>,\n            &[\n                Token::Struct {\n                    name: \"AdjacentlyTagged\",\n                    len: 2,\n                },\n                Token::Str(\"t\"),\n                Token::UnitVariant {\n                    name: \"AdjacentlyTagged\",\n                    variant: \"Unit\",\n                },\n                Token::Str(\"c\"),\n                Token::Unit,\n                Token::StructEnd,\n            ],\n        );\n        // Map: content + tag\n        assert_de_tokens(\n            &AdjacentlyTagged::Unit::<u8>,\n            &[\n                Token::Struct {\n                    name: \"AdjacentlyTagged\",\n                    len: 2,\n                },\n                Token::Str(\"c\"),\n                Token::Unit,\n                Token::Str(\"t\"),\n                Token::UnitVariant {\n                    name: \"AdjacentlyTagged\",\n                    variant: \"Unit\",\n                },\n                Token::StructEnd,\n            ],\n        );\n\n        // Map: tag + content + excess fields (f, g, h)\n        assert_de_tokens(\n            &AdjacentlyTagged::Unit::<u8>,\n            &[\n                Token::Struct {\n                    name: \"AdjacentlyTagged\",\n                    len: 2,\n                },\n                Token::Str(\"f\"),\n                Token::Unit,\n                Token::Str(\"t\"),\n                Token::UnitVariant {\n                    name: \"AdjacentlyTagged\",\n                    variant: \"Unit\",\n                },\n                Token::Str(\"g\"),\n                Token::Unit,\n                Token::Str(\"c\"),\n                Token::Unit,\n                Token::Str(\"h\"),\n                Token::Unit,\n                Token::StructEnd,\n            ],\n        );\n    }\n\n    #[test]\n    fn map_int_tag_content() {\n        // Map: tag (as number) + content (as number)\n        assert_de_tokens(\n            &AdjacentlyTagged::Unit::<u8>,\n            &[\n                Token::Struct {\n                    name: \"AdjacentlyTagged\",\n                    len: 2,\n                },\n                Token::U8(0),\n                Token::UnitVariant {\n                    name: \"AdjacentlyTagged\",\n                    variant: \"Unit\",\n                },\n                Token::U8(1),\n                Token::Unit,\n                Token::StructEnd,\n            ],\n        );\n\n        // Map: content (as number) + tag (as number)\n        assert_de_tokens(\n            &AdjacentlyTagged::Unit::<u8>,\n            &[\n                Token::Struct {\n                    name: \"AdjacentlyTagged\",\n                    len: 2,\n                },\n                Token::U64(1),\n                Token::Unit,\n                Token::U64(0),\n                Token::UnitVariant {\n                    name: \"AdjacentlyTagged\",\n                    variant: \"Unit\",\n                },\n                Token::StructEnd,\n            ],\n        );\n    }\n\n    #[test]\n    fn map_bytes_tag_content() {\n        // Map: tag + content\n        assert_de_tokens(\n            &AdjacentlyTagged::Unit::<u8>,\n            &[\n                Token::Struct {\n                    name: \"AdjacentlyTagged\",\n                    len: 2,\n                },\n                Token::BorrowedBytes(b\"t\"),\n                Token::UnitVariant {\n                    name: \"AdjacentlyTagged\",\n                    variant: \"Unit\",\n                },\n                Token::BorrowedBytes(b\"c\"),\n                Token::Unit,\n                Token::StructEnd,\n            ],\n        );\n\n        // Map: content + tag\n        assert_de_tokens(\n            &AdjacentlyTagged::Unit::<u8>,\n            &[\n                Token::Struct {\n                    name: \"AdjacentlyTagged\",\n                    len: 2,\n                },\n                Token::Bytes(b\"c\"),\n                Token::Unit,\n                Token::Bytes(b\"t\"),\n                Token::UnitVariant {\n                    name: \"AdjacentlyTagged\",\n                    variant: \"Unit\",\n                },\n                Token::StructEnd,\n            ],\n        );\n    }\n\n    #[test]\n    fn seq_tag_content() {\n        // Seq: tag and content\n        assert_de_tokens(\n            &AdjacentlyTagged::Unit::<u8>,\n            &[\n                Token::Seq { len: Some(2) },\n                Token::UnitVariant {\n                    name: \"AdjacentlyTagged\",\n                    variant: \"Unit\",\n                },\n                Token::Unit,\n                Token::SeqEnd,\n            ],\n        );\n\n        // Seq: tag (as string) and content\n        assert_de_tokens(\n            &AdjacentlyTagged::Unit::<u8>,\n            &[\n                Token::Seq { len: None },\n                Token::Str(\"Unit\"), // tag\n                Token::Unit,        // content\n                Token::SeqEnd,\n            ],\n        );\n\n        // Seq: tag (as borrowed string) and content\n        assert_de_tokens(\n            &AdjacentlyTagged::Unit::<u8>,\n            &[\n                Token::Seq { len: None },\n                Token::BorrowedStr(\"Unit\"), // tag\n                Token::Unit,                // content\n                Token::SeqEnd,\n            ],\n        );\n    }\n}\n\nmod newtype {\n    use super::*;\n\n    #[test]\n    fn map_tag_only() {\n        // optional newtype with no content field\n        assert_de_tokens(\n            &AdjacentlyTagged::Newtype::<Option<u8>>(None),\n            &[\n                Token::Struct {\n                    name: \"AdjacentlyTagged\",\n                    len: 1,\n                },\n                Token::Str(\"t\"),\n                Token::UnitVariant {\n                    name: \"AdjacentlyTagged\",\n                    variant: \"Newtype\",\n                },\n                Token::StructEnd,\n            ],\n        );\n    }\n\n    #[test]\n    fn map_tag_content() {\n        let value = AdjacentlyTagged::Newtype::<u8>(1);\n\n        // Map: tag + content\n        assert_tokens(\n            &value,\n            &[\n                Token::Struct {\n                    name: \"AdjacentlyTagged\",\n                    len: 2,\n                },\n                Token::Str(\"t\"),\n                Token::UnitVariant {\n                    name: \"AdjacentlyTagged\",\n                    variant: \"Newtype\",\n                },\n                Token::Str(\"c\"),\n                Token::U8(1),\n                Token::StructEnd,\n            ],\n        );\n\n        // Map: content + tag\n        assert_de_tokens(\n            &value,\n            &[\n                Token::Struct {\n                    name: \"AdjacentlyTagged\",\n                    len: 2,\n                },\n                Token::Str(\"c\"),\n                Token::U8(1),\n                Token::Str(\"t\"),\n                Token::UnitVariant {\n                    name: \"AdjacentlyTagged\",\n                    variant: \"Newtype\",\n                },\n                Token::StructEnd,\n            ],\n        );\n    }\n\n    #[test]\n    fn seq() {\n        let value = AdjacentlyTagged::Newtype::<u8>(1);\n\n        // Seq: tag and content\n        assert_de_tokens(\n            &value,\n            &[\n                Token::Seq { len: Some(2) },\n                Token::UnitVariant {\n                    name: \"AdjacentlyTagged\",\n                    variant: \"Newtype\",\n                },\n                Token::U8(1),\n                Token::SeqEnd,\n            ],\n        );\n\n        // Seq: tag (as string) and content\n        assert_de_tokens(\n            &value,\n            &[\n                Token::Seq { len: None },\n                Token::Str(\"Newtype\"), // tag\n                Token::U8(1),          // content\n                Token::SeqEnd,\n            ],\n        );\n\n        // Seq: tag (as borrowed string) and content\n        assert_de_tokens(\n            &value,\n            &[\n                Token::Seq { len: None },\n                Token::BorrowedStr(\"Newtype\"), // tag\n                Token::U8(1),                  // content\n                Token::SeqEnd,\n            ],\n        );\n    }\n}\n\n#[test]\nfn newtype_with_newtype() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    struct NewtypeStruct(u32);\n\n    assert_de_tokens(\n        &AdjacentlyTagged::Newtype(NewtypeStruct(5)),\n        &[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"c\"),\n            Token::NewtypeStruct {\n                name: \"NewtypeStruct\",\n            },\n            Token::U32(5),\n            Token::Str(\"t\"),\n            Token::UnitVariant {\n                name: \"AdjacentlyTagged\",\n                variant: \"Newtype\",\n            },\n            Token::StructEnd,\n        ],\n    );\n}\n\nmod tuple {\n    use super::*;\n\n    #[test]\n    fn map() {\n        let value = AdjacentlyTagged::Tuple::<u8>(1, 1);\n\n        // Map: tag + content\n        assert_tokens(\n            &value,\n            &[\n                Token::Struct {\n                    name: \"AdjacentlyTagged\",\n                    len: 2,\n                },\n                Token::Str(\"t\"),\n                Token::UnitVariant {\n                    name: \"AdjacentlyTagged\",\n                    variant: \"Tuple\",\n                },\n                Token::Str(\"c\"),\n                Token::Tuple { len: 2 },\n                Token::U8(1),\n                Token::U8(1),\n                Token::TupleEnd,\n                Token::StructEnd,\n            ],\n        );\n\n        // Map: content + tag\n        assert_de_tokens(\n            &value,\n            &[\n                Token::Struct {\n                    name: \"AdjacentlyTagged\",\n                    len: 2,\n                },\n                Token::Str(\"c\"),\n                Token::Tuple { len: 2 },\n                Token::U8(1),\n                Token::U8(1),\n                Token::TupleEnd,\n                Token::Str(\"t\"),\n                Token::UnitVariant {\n                    name: \"AdjacentlyTagged\",\n                    variant: \"Tuple\",\n                },\n                Token::StructEnd,\n            ],\n        );\n    }\n\n    #[test]\n    fn seq() {\n        let value = AdjacentlyTagged::Tuple::<u8>(1, 1);\n\n        // Seq: tag + content\n        assert_de_tokens(\n            &value,\n            &[\n                Token::Seq { len: Some(2) },\n                Token::UnitVariant {\n                    name: \"AdjacentlyTagged\",\n                    variant: \"Tuple\",\n                },\n                Token::Tuple { len: 2 },\n                Token::U8(1),\n                Token::U8(1),\n                Token::TupleEnd,\n                Token::SeqEnd,\n            ],\n        );\n    }\n}\n\nmod struct_ {\n    use super::*;\n\n    #[test]\n    fn map() {\n        let value = AdjacentlyTagged::Struct::<u8> { f: 1 };\n\n        // Map: tag + content\n        assert_tokens(\n            &value,\n            &[\n                Token::Struct {\n                    name: \"AdjacentlyTagged\",\n                    len: 2,\n                },\n                Token::Str(\"t\"),\n                Token::UnitVariant {\n                    name: \"AdjacentlyTagged\",\n                    variant: \"Struct\",\n                },\n                Token::Str(\"c\"),\n                Token::Struct {\n                    name: \"Struct\",\n                    len: 1,\n                },\n                Token::Str(\"f\"),\n                Token::U8(1),\n                Token::StructEnd,\n                Token::StructEnd,\n            ],\n        );\n\n        // Map: content + tag\n        assert_de_tokens(\n            &value,\n            &[\n                Token::Struct {\n                    name: \"AdjacentlyTagged\",\n                    len: 2,\n                },\n                Token::Str(\"c\"),\n                Token::Struct {\n                    name: \"Struct\",\n                    len: 1,\n                },\n                Token::Str(\"f\"),\n                Token::U8(1),\n                Token::StructEnd,\n                Token::Str(\"t\"),\n                Token::UnitVariant {\n                    name: \"AdjacentlyTagged\",\n                    variant: \"Struct\",\n                },\n                Token::StructEnd,\n            ],\n        );\n    }\n\n    #[test]\n    fn seq() {\n        let value = AdjacentlyTagged::Struct::<u8> { f: 1 };\n\n        // Seq: tag + content\n        assert_de_tokens(\n            &value,\n            &[\n                Token::Seq { len: Some(2) },\n                Token::UnitVariant {\n                    name: \"AdjacentlyTagged\",\n                    variant: \"Struct\",\n                },\n                Token::Struct {\n                    name: \"Struct\",\n                    len: 1,\n                },\n                Token::Str(\"f\"),\n                Token::U8(1),\n                Token::StructEnd,\n                Token::SeqEnd,\n            ],\n        );\n    }\n}\n\n#[test]\nfn struct_with_flatten() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    #[serde(tag = \"t\", content = \"c\")]\n    enum Data {\n        A {\n            a: i32,\n            #[serde(flatten)]\n            flat: Flat,\n        },\n    }\n\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    struct Flat {\n        b: i32,\n    }\n\n    let data = Data::A {\n        a: 0,\n        flat: Flat { b: 0 },\n    };\n\n    assert_tokens(\n        &data,\n        &[\n            Token::Struct {\n                name: \"Data\",\n                len: 2,\n            },\n            Token::Str(\"t\"),\n            Token::UnitVariant {\n                name: \"Data\",\n                variant: \"A\",\n            },\n            Token::Str(\"c\"),\n            Token::Map { len: None },\n            Token::Str(\"a\"),\n            Token::I32(0),\n            Token::Str(\"b\"),\n            Token::I32(0),\n            Token::MapEnd,\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn expecting_message() {\n    #[derive(Deserialize)]\n    #[serde(tag = \"tag\", content = \"content\")]\n    #[serde(expecting = \"something strange...\")]\n    enum Enum {\n        AdjacentlyTagged,\n    }\n\n    assert_de_tokens_error::<Enum>(\n        &[Token::Str(\"AdjacentlyTagged\")],\n        r#\"invalid type: string \"AdjacentlyTagged\", expected something strange...\"#,\n    );\n\n    assert_de_tokens_error::<Enum>(\n        &[Token::Map { len: None }, Token::Unit],\n        r#\"invalid type: unit value, expected \"tag\", \"content\", or other ignored fields\"#,\n    );\n\n    // Check that #[serde(expecting = \"...\")] doesn't affect variant identifier error message\n    assert_de_tokens_error::<Enum>(\n        &[Token::Map { len: None }, Token::Str(\"tag\"), Token::Unit],\n        \"invalid type: unit value, expected variant of enum Enum\",\n    );\n}\n\n#[test]\nfn partially_untagged() {\n    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n    #[serde(tag = \"t\", content = \"c\")]\n    enum Data {\n        A(u32),\n        B,\n        #[serde(untagged)]\n        Var(u32),\n    }\n\n    let data = Data::A(7);\n\n    assert_de_tokens(\n        &data,\n        &[\n            Token::Map { len: None },\n            Token::Str(\"t\"),\n            Token::Str(\"A\"),\n            Token::Str(\"c\"),\n            Token::U32(7),\n            Token::MapEnd,\n        ],\n    );\n\n    let data = Data::Var(42);\n\n    assert_de_tokens(&data, &[Token::U32(42)]);\n\n    // TODO test error output\n}\n\n#[test]\nfn deny_unknown_fields() {\n    #[derive(Debug, PartialEq, Deserialize)]\n    #[serde(tag = \"t\", content = \"c\", deny_unknown_fields)]\n    enum AdjacentlyTagged {\n        Unit,\n    }\n\n    assert_de_tokens(\n        &AdjacentlyTagged::Unit,\n        &[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"t\"),\n            Token::UnitVariant {\n                name: \"AdjacentlyTagged\",\n                variant: \"Unit\",\n            },\n            Token::Str(\"c\"),\n            Token::Unit,\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens_error::<AdjacentlyTagged>(\n        &[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"t\"),\n            Token::UnitVariant {\n                name: \"AdjacentlyTagged\",\n                variant: \"Unit\",\n            },\n            Token::Str(\"c\"),\n            Token::Unit,\n            Token::Str(\"h\"),\n        ],\n        r#\"invalid value: string \"h\", expected \"t\" or \"c\"\"#,\n    );\n\n    assert_de_tokens_error::<AdjacentlyTagged>(\n        &[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"h\"),\n        ],\n        r#\"invalid value: string \"h\", expected \"t\" or \"c\"\"#,\n    );\n\n    assert_de_tokens_error::<AdjacentlyTagged>(\n        &[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Str(\"c\"),\n            Token::Unit,\n            Token::Str(\"h\"),\n        ],\n        r#\"invalid value: string \"h\", expected \"t\" or \"c\"\"#,\n    );\n\n    assert_de_tokens_error::<AdjacentlyTagged>(\n        &[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::U64(0), // tag field\n            Token::UnitVariant {\n                name: \"AdjacentlyTagged\",\n                variant: \"Unit\",\n            },\n            Token::U64(3),\n        ],\n        r#\"invalid value: integer `3`, expected \"t\" or \"c\"\"#,\n    );\n\n    assert_de_tokens_error::<AdjacentlyTagged>(\n        &[\n            Token::Struct {\n                name: \"AdjacentlyTagged\",\n                len: 2,\n            },\n            Token::Bytes(b\"c\"),\n            Token::Unit,\n            Token::Bytes(b\"h\"),\n        ],\n        r#\"invalid value: byte array, expected \"t\" or \"c\"\"#,\n    );\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "d02a94bfc4a9f34b2ed84b4c22a61047a68a1734",
    "func": "// Copyright 2016-2019 Cargo-Bundle developers <https://github.com/burtonageo/cargo-bundle>\n// Copyright 2019-2024 Tauri Programme within The Commons Conservancy\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n\n//! [![](https://github.com/tauri-apps/tauri/raw/dev/.github/splash.png)](https://tauri.app)\n//!\n//! The Tauri bundler is a tool that generates installers or app bundles for executables.\n//! It supports auto updating through [tauri](https://docs.rs/tauri).\n//!\n//! # Platform support\n//! - macOS\n//!   - DMG and App bundles\n//! - Linux\n//!   - Appimage, Debian and RPM packages\n//! - Windows\n//!   - MSI using WiX\n\n#![doc(\n  html_logo_url = \"https://github.com/tauri-apps/tauri/raw/dev/.github/icon.png\",\n  html_favicon_url = \"https://github.com/tauri-apps/tauri/raw/dev/.github/icon.png\"\n)]\n#![warn(missing_docs, rust_2018_idioms)]\n\n/// The bundle API.\npub mod bundle;\nmod error;\npub use bundle::*;\npub use error::{Error, Result};\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "5faf29d7e97075f6158ce38473328040adba715e",
    "func": "#![cfg_attr(not(feature = \"net\"), allow(dead_code))]\n\nuse crate::io::interest::Interest;\nuse crate::runtime::io::{Direction, Handle, ReadyEvent, ScheduledIo};\nuse crate::runtime::scheduler;\n\nuse mio::event::Source;\nuse std::io;\nuse std::sync::Arc;\nuse std::task::{ready, Context, Poll};\n\ncfg_io_driver! {\n    /// Associates an I/O resource with the reactor instance that drives it.\n    ///\n    /// A registration represents an I/O resource registered with a Reactor such\n    /// that it will receive task notifications on readiness. This is the lowest\n    /// level API for integrating with a reactor.\n    ///\n    /// The association between an I/O resource is made by calling\n    /// [`new_with_interest_and_handle`].\n    /// Once the association is established, it remains established until the\n    /// registration instance is dropped.\n    ///\n    /// A registration instance represents two separate readiness streams. One\n    /// for the read readiness and one for write readiness. These streams are\n    /// independent and can be consumed from separate tasks.\n    ///\n    /// **Note**: while `Registration` is `Sync`, the caller must ensure that\n    /// there are at most two tasks that use a registration instance\n    /// concurrently. One task for [`poll_read_ready`] and one task for\n    /// [`poll_write_ready`]. While violating this requirement is \"safe\" from a\n    /// Rust memory safety point of view, it will result in unexpected behavior\n    /// in the form of lost notifications and tasks hanging.\n    ///\n    /// ## Platform-specific events\n    ///\n    /// `Registration` also allows receiving platform-specific `mio::Ready`\n    /// events. These events are included as part of the read readiness event\n    /// stream. The write readiness event stream is only for `Ready::writable()`\n    /// events.\n    ///\n    /// [`new_with_interest_and_handle`]: method@Self::new_with_interest_and_handle\n    /// [`poll_read_ready`]: method@Self::poll_read_ready`\n    /// [`poll_write_ready`]: method@Self::poll_write_ready`\n    #[derive(Debug)]\n    pub(crate) struct Registration {\n        /// Handle to the associated runtime.\n        ///\n        /// TODO: this can probably be moved into `ScheduledIo`.\n        handle: scheduler::Handle,\n\n        /// Reference to state stored by the driver.\n        shared: Arc<ScheduledIo>,\n    }\n}\n\nunsafe impl Send for Registration {}\nunsafe impl Sync for Registration {}\n\n// ===== impl Registration =====\n\nimpl Registration {\n    /// Registers the I/O resource with the reactor for the provided handle, for\n    /// a specific `Interest`. This does not add `hup` or `error` so if you are\n    /// interested in those states, you will need to add them to the readiness\n    /// state passed to this function.\n    ///\n    /// # Return\n    ///\n    /// - `Ok` if the registration happened successfully\n    /// - `Err` if an error was encountered during registration\n    #[track_caller]\n    pub(crate) fn new_with_interest_and_handle(\n        io: &mut impl Source,\n        interest: Interest,\n        handle: scheduler::Handle,\n    ) -> io::Result<Registration> {\n        let shared = handle.driver().io().add_source(io, interest)?;\n\n        Ok(Registration { handle, shared })\n    }\n\n    /// Deregisters the I/O resource from the reactor it is associated with.\n    ///\n    /// This function must be called before the I/O resource associated with the\n    /// registration is dropped.\n    ///\n    /// Note that deregistering does not guarantee that the I/O resource can be\n    /// registered with a different reactor. Some I/O resource types can only be\n    /// associated with a single reactor instance for their lifetime.\n    ///\n    /// # Return\n    ///\n    /// If the deregistration was successful, `Ok` is returned. Any calls to\n    /// `Reactor::turn` that happen after a successful call to `deregister` will\n    /// no longer result in notifications getting sent for this registration.\n    ///\n    /// `Err` is returned if an error is encountered.\n    pub(crate) fn deregister(&mut self, io: &mut impl Source) -> io::Result<()> {\n        self.handle().deregister_source(&self.shared, io)\n    }\n\n    pub(crate) fn clear_readiness(&self, event: ReadyEvent) {\n        self.shared.clear_readiness(event);\n    }\n\n    // Uses the poll path, requiring the caller to ensure mutual exclusion for\n    // correctness. Only the last task to call this function is notified.\n    pub(crate) fn poll_read_ready(&self, cx: &mut Context<'_>) -> Poll<io::Result<ReadyEvent>> {\n        self.poll_ready(cx, Direction::Read)\n    }\n\n    // Uses the poll path, requiring the caller to ensure mutual exclusion for\n    // correctness. Only the last task to call this function is notified.\n    pub(crate) fn poll_write_ready(&self, cx: &mut Context<'_>) -> Poll<io::Result<ReadyEvent>> {\n        self.poll_ready(cx, Direction::Write)\n    }\n\n    // Uses the poll path, requiring the caller to ensure mutual exclusion for\n    // correctness. Only the last task to call this function is notified.\n    #[cfg(not(target_os = \"wasi\"))]\n    pub(crate) fn poll_read_io<R>(\n        &self,\n        cx: &mut Context<'_>,\n        f: impl FnMut() -> io::Result<R>,\n    ) -> Poll<io::Result<R>> {\n        self.poll_io(cx, Direction::Read, f)\n    }\n\n    // Uses the poll path, requiring the caller to ensure mutual exclusion for\n    // correctness. Only the last task to call this function is notified.\n    pub(crate) fn poll_write_io<R>(\n        &self,\n        cx: &mut Context<'_>,\n        f: impl FnMut() -> io::Result<R>,\n    ) -> Poll<io::Result<R>> {\n        self.poll_io(cx, Direction::Write, f)\n    }\n\n    /// Polls for events on the I/O resource's `direction` readiness stream.\n    ///\n    /// If called with a task context, notify the task when a new event is\n    /// received.\n    fn poll_ready(\n        &self,\n        cx: &mut Context<'_>,\n        direction: Direction,\n    ) -> Poll<io::Result<ReadyEvent>> {\n        ready!(crate::trace::trace_leaf(cx));\n        // Keep track of task budget\n        let coop = ready!(crate::runtime::coop::poll_proceed(cx));\n        let ev = ready!(self.shared.poll_readiness(cx, direction));\n\n        if ev.is_shutdown {\n            return Poll::Ready(Err(gone()));\n        }\n\n        coop.made_progress();\n        Poll::Ready(Ok(ev))\n    }\n\n    fn poll_io<R>(\n        &self,\n        cx: &mut Context<'_>,\n        direction: Direction,\n        mut f: impl FnMut() -> io::Result<R>,\n    ) -> Poll<io::Result<R>> {\n        loop {\n            let ev = ready!(self.poll_ready(cx, direction))?;\n\n            match f() {\n                Ok(ret) => {\n                    return Poll::Ready(Ok(ret));\n                }\n                Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {\n                    self.clear_readiness(ev);\n                }\n                Err(e) => return Poll::Ready(Err(e)),\n            }\n        }\n    }\n\n    pub(crate) fn try_io<R>(\n        &self,\n        interest: Interest,\n        f: impl FnOnce() -> io::Result<R>,\n    ) -> io::Result<R> {\n        let ev = self.shared.ready_event(interest);\n\n        // Don't attempt the operation if the resource is not ready.\n        if ev.ready.is_empty() {\n            return Err(io::ErrorKind::WouldBlock.into());\n        }\n\n        match f() {\n            Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {\n                self.clear_readiness(ev);\n                Err(io::ErrorKind::WouldBlock.into())\n            }\n            res => res,\n        }\n    }\n\n    pub(crate) async fn readiness(&self, interest: Interest) -> io::Result<ReadyEvent> {\n        let ev = self.shared.readiness(interest).await;\n\n        if ev.is_shutdown {\n            return Err(gone());\n        }\n\n        Ok(ev)\n    }\n\n    pub(crate) async fn async_io<R>(\n        &self,\n        interest: Interest,\n        mut f: impl FnMut() -> io::Result<R>,\n    ) -> io::Result<R> {\n        loop {\n            let event = self.readiness(interest).await?;\n\n            let coop = std::future::poll_fn(crate::runtime::coop::poll_proceed).await;\n\n            match f() {\n                Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {\n                    self.clear_readiness(event);\n                }\n                x => {\n                    coop.made_progress();\n                    return x;\n                }\n            }\n        }\n    }\n\n    fn handle(&self) -> &Handle {\n        self.handle.driver().io()\n    }\n}\n\nimpl Drop for Registration {\n    fn drop(&mut self) {\n        // It is possible for a cycle to be created between wakers stored in\n        // `ScheduledIo` instances and `Arc<driver::Inner>`. To break this\n        // cycle, wakers are cleared. This is an imperfect solution as it is\n        // possible to store a `Registration` in a waker. In this case, the\n        // cycle would remain.\n        //\n        // See tokio-rs/tokio#3481 for more details.\n        self.shared.clear_wakers();\n    }\n}\n\nfn gone() -> io::Error {\n    io::Error::new(\n        io::ErrorKind::Other,\n        crate::util::error::RUNTIME_SHUTTING_DOWN_ERROR,\n    )\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "21df78791f6a1f185e69aba3202229d7ff8cd425",
    "func": "use bytes::BytesMut;\nuse std::io;\n\n/// Trait of helper objects to write out messages as bytes, for use with\n/// [`FramedWrite`].\n///\n/// [`FramedWrite`]: crate::codec::FramedWrite\npub trait Encoder<Item> {\n    /// The type of encoding errors.\n    ///\n    /// [`FramedWrite`] requires `Encoder`s errors to implement `From<io::Error>`\n    /// in the interest of letting it return `Error`s directly.\n    ///\n    /// [`FramedWrite`]: crate::codec::FramedWrite\n    type Error: From<io::Error>;\n\n    /// Encodes a frame into the buffer provided.\n    ///\n    /// This method will encode `item` into the byte buffer provided by `dst`.\n    /// The `dst` provided is an internal buffer of the [`FramedWrite`] instance and\n    /// will be written out when possible.\n    ///\n    /// [`FramedWrite`]: crate::codec::FramedWrite\n    fn encode(&mut self, item: Item, dst: &mut BytesMut) -> Result<(), Self::Error>;\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "277a856e6fa9f844ec4eaf4fec07af265b9aa880",
    "func": "use std::fmt;\nuse std::io::Cursor;\n\nuse crate::http::uri::Path;\nuse crate::http::ext::IntoOwned;\nuse crate::response::Response;\nuse crate::request::Request;\nuse crate::http::{Status, ContentType, uri};\nuse crate::catcher::{Handler, BoxFuture};\n\n/// An error catching route.\n///\n/// Catchers are routes that run when errors are produced by the application.\n/// They consist of a [`Handler`] and an optional status code to match against\n/// arising errors. Errors arise from the the following sources:\n///\n///   * A failing guard.\n///   * A failing responder.\n///   * A forwarding guard.\n///   * Routing failure.\n///\n/// Each error or forward is paired with a status code. Guards and responders\n/// indicate the status code themselves via their `Err` and `Outcome` return\n/// value. A complete routing failure is always a `404`. Rocket invokes the\n/// error handler for the catcher with an error's status code, or in the case of\n/// every route resulting in a forward, the last forwarded status code.\n///\n/// ### Error Handler Restrictions\n///\n/// Because error handlers are a last resort, they should not fail to produce a\n/// response. If an error handler _does_ fail, Rocket invokes its default `500`\n/// error catcher. Error handlers cannot forward.\n///\n/// # Routing\n///\n/// If a route fails by returning an error [`Outcome`], Rocket routes the\n/// erroring request to the highest precedence catcher among all the catchers\n/// that [match](Catcher::matches()). See [`Catcher::matches()`] for details on\n/// matching. Precedence is determined by the catcher's _base_, which is\n/// provided as the first argument to [`Rocket::register()`]. Catchers with more\n/// non-empty segments have a higher precedence.\n///\n/// Rocket provides [built-in defaults](#built-in-default), but _default_\n/// catchers can also be registered. A _default_ catcher is a catcher with no\n/// explicit status code: `None`.\n///\n/// [`Outcome`]: crate::request::Outcome\n/// [`Rocket::register()`]: crate::Rocket::register()\n///\n/// ## Collisions\n///\n/// Two catchers are said to _collide_ if there exists an error that matches\n/// both catchers. Colliding catchers present a routing ambiguity and are thus\n/// disallowed by Rocket. Because catchers can be constructed dynamically,\n/// collision checking is done at [`ignite`](crate::Rocket::ignite()) time,\n/// after it becomes statically impossible to register any more catchers on an\n/// instance of `Rocket`.\n///\n/// ## Built-In Default\n///\n/// Rocket's provides a built-in default catcher that can handle all errors. It\n/// produces HTML or JSON, depending on the value of the `Accept` header. As\n/// such, catchers only need to be registered if an error needs to be handled in\n/// a custom fashion. The built-in default never conflicts with any\n/// user-registered catchers.\n///\n/// # Code Generation\n///\n/// Catchers should rarely be constructed or used directly. Instead, they are\n/// typically generated via the [`catch`] attribute, as follows:\n///\n/// ```rust,no_run\n/// #[macro_use] extern crate rocket;\n///\n/// use rocket::Request;\n/// use rocket::http::Status;\n///\n/// #[catch(500)]\n/// fn internal_error() -> &'static str {\n///     \"Whoops! Looks like we messed up.\"\n/// }\n///\n/// #[catch(404)]\n/// fn not_found(req: &Request) -> String {\n///     format!(\"I couldn't find '{}'. Try something else?\", req.uri())\n/// }\n///\n/// #[catch(default)]\n/// fn default(status: Status, req: &Request) -> String {\n///     format!(\"{} ({})\", status, req.uri())\n/// }\n///\n/// #[launch]\n/// fn rocket() -> _ {\n///     rocket::build().register(\"/\", catchers![internal_error, not_found, default])\n/// }\n/// ```\n///\n/// A function decorated with `#[catch]` may take zero, one, or two arguments.\n/// It's type signature must be one of the following, where `R:`[`Responder`]:\n///\n///   * `fn() -> R`\n///   * `fn(`[`&Request`]`) -> R`\n///   * `fn(`[`Status`]`, `[`&Request`]`) -> R`\n///\n/// See the [`catch`] documentation for full details.\n///\n/// [`catch`]: crate::catch\n/// [`Responder`]: crate::response::Responder\n/// [`&Request`]: crate::request::Request\n/// [`Status`]: crate::http::Status\n#[derive(Clone)]\npub struct Catcher {\n    /// The name of this catcher, if one was given.\n    pub name: Option<Cow<'static, str>>,\n\n    /// The HTTP status to match against if this route is not `default`.\n    pub code: Option<u16>,\n\n    /// The catcher's associated error handler.\n    pub handler: Box<dyn Handler>,\n\n    /// The mount point.\n    pub(crate) base: uri::Origin<'static>,\n\n    /// The catcher's calculated rank.\n    ///\n    /// This is -(number of nonempty segments in base).\n    pub(crate) rank: isize,\n\n    /// The catcher's file, line, and column location.\n    pub(crate) location: Option<(&'static str, u32, u32)>,\n}\n\n// The rank is computed as -(number of nonempty segments in base) => catchers\n// with more nonempty segments have lower ranks => higher precedence.\nfn rank(base: Path<'_>) -> isize {\n    -(base.segments().filter(|s| !s.is_empty()).count() as isize)\n}\n\nimpl Catcher {\n    /// Creates a catcher for the given `status`, or a default catcher if\n    /// `status` is `None`, using the given error handler. This should only be\n    /// used when routing manually.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use rocket::request::Request;\n    /// use rocket::catcher::{Catcher, BoxFuture};\n    /// use rocket::response::Responder;\n    /// use rocket::http::Status;\n    ///\n    /// fn handle_404<'r>(status: Status, req: &'r Request<'_>) -> BoxFuture<'r> {\n    ///    let res = (status, format!(\"404: {}\", req.uri()));\n    ///    Box::pin(async move { res.respond_to(req) })\n    /// }\n    ///\n    /// fn handle_500<'r>(_: Status, req: &'r Request<'_>) -> BoxFuture<'r> {\n    ///     Box::pin(async move{ \"Whoops, we messed up!\".respond_to(req) })\n    /// }\n    ///\n    /// fn handle_default<'r>(status: Status, req: &'r Request<'_>) -> BoxFuture<'r> {\n    ///    let res = (status, format!(\"{}: {}\", status, req.uri()));\n    ///    Box::pin(async move { res.respond_to(req) })\n    /// }\n    ///\n    /// let not_found_catcher = Catcher::new(404, handle_404);\n    /// let internal_server_error_catcher = Catcher::new(500, handle_500);\n    /// let default_error_catcher = Catcher::new(None, handle_default);\n    /// ```\n    ///\n    /// # Panics\n    ///\n    /// Panics if `code` is not in the HTTP status code error range `[400,\n    /// 600)`.\n    #[inline(always)]\n    pub fn new<S, H>(code: S, handler: H) -> Catcher\n        where S: Into<Option<u16>>, H: Handler\n    {\n        let code = code.into();\n        if let Some(code) = code {\n            assert!(code >= 400 && code < 600);\n        }\n\n        Catcher {\n            name: None,\n            base: uri::Origin::root().clone(),\n            handler: Box::new(handler),\n            rank: rank(uri::Origin::root().path()),\n            code,\n            location: None,\n        }\n    }\n\n    /// Returns the mount point (base) of the catcher, which defaults to `/`.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::request::Request;\n    /// use rocket::catcher::{Catcher, BoxFuture};\n    /// use rocket::response::Responder;\n    /// use rocket::http::Status;\n    ///\n    /// fn handle_404<'r>(status: Status, req: &'r Request<'_>) -> BoxFuture<'r> {\n    ///    let res = (status, format!(\"404: {}\", req.uri()));\n    ///    Box::pin(async move { res.respond_to(req) })\n    /// }\n    ///\n    /// let catcher = Catcher::new(404, handle_404);\n    /// assert_eq!(catcher.base(), \"/\");\n    ///\n    /// let catcher = catcher.map_base(|base| format!(\"/foo/bar/{}\", base)).unwrap();\n    /// assert_eq!(catcher.base(), \"/foo/bar\");\n    /// ```\n    pub fn base(&self) -> Path<'_> {\n        self.base.path()\n    }\n\n    /// Prefix `base` to the current `base` in `self.`\n    ///\n    /// If the the current base is `/`, then the base is replaced by `base`.\n    /// Otherwise, `base` is prefixed to the existing `base`.\n    ///\n    /// ```rust\n    /// use rocket::request::Request;\n    /// use rocket::catcher::{Catcher, BoxFuture};\n    /// use rocket::response::Responder;\n    /// use rocket::http::Status;\n    /// # use rocket::uri;\n    ///\n    /// fn handle_404<'r>(status: Status, req: &'r Request<'_>) -> BoxFuture<'r> {\n    ///    let res = (status, format!(\"404: {}\", req.uri()));\n    ///    Box::pin(async move { res.respond_to(req) })\n    /// }\n    ///\n    /// let catcher = Catcher::new(404, handle_404);\n    /// assert_eq!(catcher.base(), \"/\");\n    ///\n    /// // Since the base is `/`, rebasing replaces the base.\n    /// let rebased = catcher.rebase(uri!(\"/boo\"));\n    /// assert_eq!(rebased.base(), \"/boo\");\n    ///\n    /// // Now every rebase prefixes.\n    /// let rebased = rebased.rebase(uri!(\"/base\"));\n    /// assert_eq!(rebased.base(), \"/base/boo\");\n    ///\n    /// // Note that trailing slashes have no effect and are thus removed:\n    /// let catcher = Catcher::new(404, handle_404);\n    /// let rebased = catcher.rebase(uri!(\"/boo/\"));\n    /// assert_eq!(rebased.base(), \"/boo\");\n    /// ```\n    pub fn rebase(mut self, mut base: uri::Origin<'_>) -> Self {\n        self.base = if self.base.path() == \"/\" {\n            base.clear_query();\n            base.into_normalized_nontrailing().into_owned()\n        } else {\n            uri::Origin::parse_owned(format!(\"{}{}\", base.path(), self.base))\n                .expect(\"catcher rebase: {new}{old} is valid origin URI\")\n                .into_normalized_nontrailing()\n        };\n\n        self.rank = rank(self.base());\n        self\n    }\n\n    /// Maps the `base` of this catcher using `mapper`, returning a new\n    /// `Catcher` with the returned base.\n    ///\n    /// **Note:** Prefer to use [`Catcher::rebase()`] whenever possible!\n    ///\n    /// `mapper` is called with the current base. The returned `String` is used\n    /// as the new base if it is a valid URI. If the returned base URI contains\n    /// a query, it is ignored. Returns an error if the base produced by\n    /// `mapper` is not a valid origin URI.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use rocket::request::Request;\n    /// use rocket::catcher::{Catcher, BoxFuture};\n    /// use rocket::response::Responder;\n    /// use rocket::http::Status;\n    ///\n    /// fn handle_404<'r>(status: Status, req: &'r Request<'_>) -> BoxFuture<'r> {\n    ///    let res = (status, format!(\"404: {}\", req.uri()));\n    ///    Box::pin(async move { res.respond_to(req) })\n    /// }\n    ///\n    /// let catcher = Catcher::new(404, handle_404);\n    /// assert_eq!(catcher.base(), \"/\");\n    ///\n    /// let catcher = catcher.map_base(|_| format!(\"/bar\")).unwrap();\n    /// assert_eq!(catcher.base(), \"/bar\");\n    ///\n    /// let catcher = catcher.map_base(|base| format!(\"/foo{}\", base)).unwrap();\n    /// assert_eq!(catcher.base(), \"/foo/bar\");\n    ///\n    /// let catcher = catcher.map_base(|base| format!(\"/foo ? {}\", base));\n    /// assert!(catcher.is_err());\n    /// ```\n    pub fn map_base<'a, F>(mut self, mapper: F) -> Result<Self, uri::Error<'static>>\n        where F: FnOnce(uri::Origin<'a>) -> String\n    {\n        let new_base = uri::Origin::parse_owned(mapper(self.base))?;\n        self.base = new_base.into_normalized_nontrailing();\n        self.base.clear_query();\n        self.rank = rank(self.base());\n        Ok(self)\n    }\n}\n\nimpl Default for Catcher {\n    fn default() -> Self {\n        fn handler<'r>(s: Status, req: &'r Request<'_>) -> BoxFuture<'r> {\n            Box::pin(async move { Ok(default_handler(s, req)) })\n        }\n\n        let mut catcher = Catcher::new(None, handler);\n        catcher.name = Some(\"<Rocket Catcher>\".into());\n        catcher\n    }\n}\n\n/// Information generated by the `catch` attribute during codegen.\n#[doc(hidden)]\npub struct StaticInfo {\n    /// The catcher's name, i.e, the name of the function.\n    pub name: &'static str,\n    /// The catcher's status code.\n    pub code: Option<u16>,\n    /// The catcher's handler, i.e, the annotated function.\n    pub handler: for<'r> fn(Status, &'r Request<'_>) -> BoxFuture<'r>,\n    /// The file, line, and column where the catcher was defined.\n    pub location: (&'static str, u32, u32),\n}\n\n#[doc(hidden)]\nimpl From<StaticInfo> for Catcher {\n    #[inline]\n    fn from(info: StaticInfo) -> Catcher {\n        let mut catcher = Catcher::new(info.code, info.handler);\n        catcher.name = Some(info.name.into());\n        catcher.location = Some(info.location);\n        catcher\n    }\n}\n\nimpl fmt::Debug for Catcher {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Catcher\")\n            .field(\"name\", &self.name)\n            .field(\"base\", &self.base)\n            .field(\"code\", &self.code)\n            .field(\"rank\", &self.rank)\n            .finish()\n    }\n}\n\nmacro_rules! html_error_template {\n    ($code:expr, $reason:expr, $description:expr) => (\n        concat!(\nr#\"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"utf-8\">\n    <meta name=\"color-scheme\" content=\"light dark\">\n    <title>\"#, $code, \" \", $reason, r#\"</title>\n</head>\n<body align=\"center\">\n    <div role=\"main\" align=\"center\">\n        <h1>\"#, $code, \": \", $reason, r#\"</h1>\n        <p>\"#, $description, r#\"</p>\n        <hr />\n    </div>\n    <div role=\"contentinfo\" align=\"center\">\n        <small>Rocket</small>\n    </div>\n</body>\n</html>\"#\n        )\n    )\n}\n\nmacro_rules! json_error_template {\n    ($code:expr, $reason:expr, $description:expr) => (\n        concat!(\nr#\"{\n  \"error\": {\n    \"code\": \"#, $code, r#\",\n    \"reason\": \"\"#, $reason, r#\"\",\n    \"description\": \"\"#, $description, r#\"\"\n  }\n}\"#\n        )\n    )\n}\n\n// This is unfortunate, but the `{`, `}` above make it unusable for `format!`.\nmacro_rules! json_error_fmt_template {\n    ($code:expr, $reason:expr, $description:expr) => (\n        concat!(\nr#\"{{\n  \"error\": {{\n    \"code\": \"#, $code, r#\",\n    \"reason\": \"\"#, $reason, r#\"\",\n    \"description\": \"\"#, $description, r#\"\"\n  }}\n}}\"#\n        )\n    )\n}\n\nmacro_rules! default_handler_fn {\n    ($($code:expr, $reason:expr, $description:expr),+) => (\n        use std::borrow::Cow;\n\n        pub(crate) fn default_handler<'r>(\n            status: Status,\n            req: &'r Request<'_>\n        ) -> Response<'r> {\n            let preferred = req.accept().map(|a| a.preferred());\n            let (mime, text) = if preferred.map_or(false, |a| a.is_json()) {\n                let json: Cow<'_, str> = match status.code {\n                    $($code => json_error_template!($code, $reason, $description).into(),)*\n                    code => format!(json_error_fmt_template!(\"{}\", \"Unknown Error\",\n                            \"An unknown error has occurred.\"), code).into()\n                };\n\n                (ContentType::JSON, json)\n            } else {\n                let html: Cow<'_, str> = match status.code {\n                    $($code => html_error_template!($code, $reason, $description).into(),)*\n                    code => format!(html_error_template!(\"{}\", \"Unknown Error\",\n                            \"An unknown error has occurred.\"), code, code).into(),\n                };\n\n                (ContentType::HTML, html)\n            };\n\n            let mut r = Response::build().status(status).header(mime).finalize();\n            match text {\n                Cow::Owned(v) => r.set_sized_body(v.len(), Cursor::new(v)),\n                Cow::Borrowed(v) => r.set_sized_body(v.len(), Cursor::new(v)),\n            };\n\n            r\n        }\n    )\n}\n\ndefault_handler_fn! {\n    400, \"Bad Request\", \"The request could not be understood by the server due \\\n        to malformed syntax.\",\n    401, \"Unauthorized\", \"The request requires user authentication.\",\n    402, \"Payment Required\", \"The request could not be processed due to lack of payment.\",\n    403, \"Forbidden\", \"The server refused to authorize the request.\",\n    404, \"Not Found\", \"The requested resource could not be found.\",\n    405, \"Method Not Allowed\", \"The request method is not supported for the requested resource.\",\n    406, \"Not Acceptable\", \"The requested resource is capable of generating only content not \\\n        acceptable according to the Accept headers sent in the request.\",\n    407, \"Proxy Authentication Required\", \"Authentication with the proxy is required.\",\n    408, \"Request Timeout\", \"The server timed out waiting for the request.\",\n    409, \"Conflict\", \"The request could not be processed because of a conflict in the request.\",\n    410, \"Gone\", \"The resource requested is no longer available and will not be available again.\",\n    411, \"Length Required\", \"The request did not specify the length of its content, which is \\\n        required by the requested resource.\",\n    412, \"Precondition Failed\", \"The server does not meet one of the \\\n        preconditions specified in the request.\",\n    413, \"Payload Too Large\", \"The request is larger than the server is \\\n        willing or able to process.\",\n    414, \"URI Too Long\", \"The URI provided was too long for the server to process.\",\n    415, \"Unsupported Media Type\", \"The request entity has a media type which \\\n        the server or resource does not support.\",\n    416, \"Range Not Satisfiable\", \"The portion of the requested file cannot be \\\n        supplied by the server.\",\n    417, \"Expectation Failed\", \"The server cannot meet the requirements of the \\\n        Expect request-header field.\",\n    418, \"I'm a teapot\", \"I was requested to brew coffee, and I am a teapot.\",\n    421, \"Misdirected Request\", \"The server cannot produce a response for this request.\",\n    422, \"Unprocessable Entity\", \"The request was well-formed but was unable to \\\n        be followed due to semantic errors.\",\n    426, \"Upgrade Required\", \"Switching to the protocol in the Upgrade header field is required.\",\n    428, \"Precondition Required\", \"The server requires the request to be conditional.\",\n    429, \"Too Many Requests\", \"Too many requests have been received recently.\",\n    431, \"Request Header Fields Too Large\", \"The server is unwilling to process \\\n        the request because either an individual header field, or all the header \\\n        fields collectively, are too large.\",\n    451, \"Unavailable For Legal Reasons\", \"The requested resource is unavailable \\\n        due to a legal demand to deny access to this resource.\",\n    500, \"Internal Server Error\", \"The server encountered an internal error while \\\n        processing this request.\",\n    501, \"Not Implemented\", \"The server either does not recognize the request \\\n        method, or it lacks the ability to fulfill the request.\",\n    503, \"Service Unavailable\", \"The server is currently unavailable.\",\n    504, \"Gateway Timeout\", \"The server did not receive a timely response from an upstream server.\",\n    510, \"Not Extended\", \"Further extensions to the request are required for \\\n        the server to fulfill it.\"\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "7362aa0ba4f1e8917972909c9a2a731f8d1251ad",
    "func": "//! Tests how different transforms behave when clipped with `Overflow::Hidden`\n\nuse bevy::{input::common_conditions::input_just_pressed, prelude::*, ui::widget::TextUiWriter};\nuse std::f32::consts::{FRAC_PI_2, PI, TAU};\n\nconst CONTAINER_SIZE: f32 = 150.0;\nconst HALF_CONTAINER_SIZE: f32 = CONTAINER_SIZE / 2.0;\nconst LOOP_LENGTH: f32 = 4.0;\n\nfn main() {\n    App::new()\n        .add_plugins(DefaultPlugins)\n        .init_resource::<AnimationState>()\n        .add_systems(Startup, setup)\n        .add_systems(\n            Update,\n            (\n                toggle_overflow.run_if(input_just_pressed(KeyCode::KeyO)),\n                next_container_size.run_if(input_just_pressed(KeyCode::KeyS)),\n                update_transform::<Move>,\n                update_transform::<Scale>,\n                update_transform::<Rotate>,\n                update_animation,\n            ),\n        )\n        .run();\n}\n\n#[derive(Component)]\nstruct Instructions;\n\n#[derive(Resource, Default)]\nstruct AnimationState {\n    playing: bool,\n    paused_at: f32,\n    paused_total: f32,\n    t: f32,\n}\n\n#[derive(Component)]\nstruct Container(u8);\n\ntrait UpdateTransform {\n    fn update(&self, t: f32, transform: &mut Transform);\n}\n\n#[derive(Component)]\nstruct Move;\n\nimpl UpdateTransform for Move {\n    fn update(&self, t: f32, transform: &mut Transform) {\n        transform.translation.x = ops::sin(t * TAU - FRAC_PI_2) * HALF_CONTAINER_SIZE;\n        transform.translation.y = -ops::cos(t * TAU - FRAC_PI_2) * HALF_CONTAINER_SIZE;\n    }\n}\n\n#[derive(Component)]\nstruct Scale;\n\nimpl UpdateTransform for Scale {\n    fn update(&self, t: f32, transform: &mut Transform) {\n        transform.scale.x = 1.0 + 0.5 * ops::cos(t * TAU).max(0.0);\n        transform.scale.y = 1.0 + 0.5 * ops::cos(t * TAU + PI).max(0.0);\n    }\n}\n\n#[derive(Component)]\nstruct Rotate;\n\nimpl UpdateTransform for Rotate {\n    fn update(&self, t: f32, transform: &mut Transform) {\n        transform.rotation =\n            Quat::from_axis_angle(Vec3::Z, (ops::cos(t * TAU) * 45.0).to_radians());\n    }\n}\n\nfn setup(mut commands: Commands, asset_server: Res<AssetServer>) {\n    // Camera\n\n    commands.spawn(Camera2d);\n\n    // Instructions\n\n    let text_font = TextFont::default();\n\n    commands\n        .spawn((\n            Text::new(\n                \"Next Overflow Setting (O)\\nNext Container Size (S)\\nToggle Animation (space)\\n\\n\",\n            ),\n            text_font.clone(),\n            Node {\n                position_type: PositionType::Absolute,\n                top: Val::Px(12.0),\n                left: Val::Px(12.0),\n                ..default()\n            },\n            Instructions,\n        ))\n        .with_child((\n            TextSpan::new(format!(\"{:?}\", Overflow::clip())),\n            text_font.clone(),\n        ));\n\n    // Overflow Debug\n\n    commands\n        .spawn(Node {\n            width: Val::Percent(100.),\n            height: Val::Percent(100.),\n            justify_content: JustifyContent::Center,\n            align_items: AlignItems::Center,\n            ..default()\n        })\n        .with_children(|parent| {\n            parent\n                .spawn(Node {\n                    display: Display::Grid,\n                    grid_template_columns: RepeatedGridTrack::px(3, CONTAINER_SIZE),\n                    grid_template_rows: RepeatedGridTrack::px(2, CONTAINER_SIZE),\n                    row_gap: Val::Px(80.),\n                    column_gap: Val::Px(80.),\n                    ..default()\n                })\n                .with_children(|parent| {\n                    spawn_image(parent, &asset_server, Move);\n                    spawn_image(parent, &asset_server, Scale);\n                    spawn_image(parent, &asset_server, Rotate);\n\n                    spawn_text(parent, &asset_server, Move);\n                    spawn_text(parent, &asset_server, Scale);\n                    spawn_text(parent, &asset_server, Rotate);\n                });\n        });\n}\n\nfn spawn_image(\n    parent: &mut ChildBuilder,\n    asset_server: &Res<AssetServer>,\n    update_transform: impl UpdateTransform + Component,\n) {\n    spawn_container(parent, update_transform, |parent| {\n        parent.spawn((\n            UiImage::new(asset_server.load(\"branding/bevy_logo_dark_big.png\")),\n            Node {\n                height: Val::Px(100.),\n                position_type: PositionType::Absolute,\n                top: Val::Px(-50.),\n                left: Val::Px(-200.),\n                ..default()\n            },\n        ));\n    });\n}\n\nfn spawn_text(\n    parent: &mut ChildBuilder,\n    asset_server: &Res<AssetServer>,\n    update_transform: impl UpdateTransform + Component,\n) {\n    spawn_container(parent, update_transform, |parent| {\n        parent.spawn((\n            Text::new(\"Bevy\"),\n            TextFont {\n                font: asset_server.load(\"fonts/FiraSans-Bold.ttf\"),\n                font_size: 100.0,\n                ..default()\n            },\n        ));\n    });\n}\n\nfn spawn_container(\n    parent: &mut ChildBuilder,\n    update_transform: impl UpdateTransform + Component,\n    spawn_children: impl FnOnce(&mut ChildBuilder),\n) {\n    let mut transform = Transform::default();\n\n    update_transform.update(0.0, &mut transform);\n\n    parent\n        .spawn((\n            Node {\n                width: Val::Percent(100.),\n                height: Val::Percent(100.),\n                align_items: AlignItems::Center,\n                justify_content: JustifyContent::Center,\n                overflow: Overflow::clip(),\n                ..default()\n            },\n            BackgroundColor(Color::srgb(0.25, 0.25, 0.25)),\n            Container(0),\n        ))\n        .with_children(|parent| {\n            parent\n                .spawn((\n                    Node {\n                        align_items: AlignItems::Center,\n                        justify_content: JustifyContent::Center,\n                        top: Val::Px(transform.translation.x),\n                        left: Val::Px(transform.translation.y),\n                        ..default()\n                    },\n                    transform,\n                    update_transform,\n                ))\n                .with_children(spawn_children);\n        });\n}\n\nfn update_animation(\n    mut animation: ResMut<AnimationState>,\n    time: Res<Time>,\n    keys: Res<ButtonInput<KeyCode>>,\n) {\n    let delta = time.elapsed_secs();\n\n    if keys.just_pressed(KeyCode::Space) {\n        animation.playing = !animation.playing;\n\n        if !animation.playing {\n            animation.paused_at = delta;\n        } else {\n            animation.paused_total += delta - animation.paused_at;\n        }\n    }\n\n    if animation.playing {\n        animation.t = (delta - animation.paused_total) % LOOP_LENGTH / LOOP_LENGTH;\n    }\n}\n\nfn update_transform<T: UpdateTransform + Component>(\n    animation: Res<AnimationState>,\n    mut containers: Query<(&mut Transform, &mut Node, &T)>,\n) {\n    for (mut transform, mut node, update_transform) in &mut containers {\n        update_transform.update(animation.t, &mut transform);\n\n        node.left = Val::Px(transform.translation.x);\n        node.top = Val::Px(transform.translation.y);\n    }\n}\n\nfn toggle_overflow(\n    mut containers: Query<&mut Node, With<Container>>,\n    instructions: Single<Entity, With<Instructions>>,\n    mut writer: TextUiWriter,\n) {\n    for mut node in &mut containers {\n        node.overflow = match node.overflow {\n            Overflow {\n                x: OverflowAxis::Visible,\n                y: OverflowAxis::Visible,\n            } => Overflow::clip_y(),\n            Overflow {\n                x: OverflowAxis::Visible,\n                y: OverflowAxis::Clip,\n            } => Overflow::clip_x(),\n            Overflow {\n                x: OverflowAxis::Clip,\n                y: OverflowAxis::Visible,\n            } => Overflow::clip(),\n            _ => Overflow::visible(),\n        };\n\n        let entity = *instructions;\n        *writer.text(entity, 1) = format!(\"{:?}\", node.overflow);\n    }\n}\n\nfn next_container_size(mut containers: Query<(&mut Node, &mut Container)>) {\n    for (mut node, mut container) in &mut containers {\n        container.0 = (container.0 + 1) % 3;\n\n        node.width = match container.0 {\n            2 => Val::Percent(30.),\n            _ => Val::Percent(100.),\n        };\n        node.height = match container.0 {\n            1 => Val::Percent(30.),\n            _ => Val::Percent(100.),\n        };\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "190b7feaf5714371459fdbc05cf6dec1eff42c0c",
    "func": "use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(field_identifier, variant_identifier)]\nenum F {\n    A,\n    B,\n}\n\nfn main() {}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "6d3fbaebd0a5395708174ceb70bd75db8b907ef6",
    "func": "use rocket::http::Header;\nuse rocket::local::blocking::Client;\n\n#[test]\nfn test_local_request_clone_soundness() {\n    let client = Client::debug_with(vec![]).unwrap();\n\n    // creates two LocalRequest instances that shouldn't share the same req\n    let r1 = client.get(\"/\").header(Header::new(\"key\", \"val1\"));\n    let mut r2 = r1.clone();\n\n    // save the iterator, which internally holds a slice\n    let mut iter = r1.inner().headers().get(\"key\");\n\n    // insert headers to force header map reallocation.\n    for i in 0..100 {\n        r2.add_header(Header::new(i.to_string(), i.to_string()));\n    }\n\n    // Replace the original key/val.\n    r2.add_header(Header::new(\"key\", \"val2\"));\n\n    // Heap massage: so we've got crud to print.\n    let _: Vec<usize> = vec![0, 0xcafebabe, 31337, 0];\n\n    // Ensure we're good.\n    let s = iter.next().unwrap();\n    println!(\"{}\", s);\n\n    // And that we've got the right data.\n    assert_eq!(r1.inner().headers().get(\"key\").collect::<Vec<_>>(), vec![\"val1\"]);\n    assert_eq!(r2.inner().headers().get(\"key\").collect::<Vec<_>>(), vec![\"val1\", \"val2\"]);\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "b41d29b57e246c56e898b96eec51b23a22163ce9",
    "func": "//! TCP listener.\n//!\n//! # Configuration\n//!\n//! Reads the following configuration parameters:\n//!\n//! | parameter | type         | default     | note                            |\n//! |-----------|--------------|-------------|---------------------------------|\n//! | `address` | [`Endpoint`] | `127.0.0.1` | must be `tcp:ip`                |\n//! | `port`    | `u16`        | `8000`      | replaces the port in `address ` |\n\nuse std::io;\nuse std::net::{Ipv4Addr, SocketAddr};\n\nuse either::{Either, Left, Right};\n\n#[doc(inline)]\npub use tokio::net::{TcpListener, TcpStream};\n\nuse crate::{Ignite, Rocket};\nuse crate::listener::{Bind, Connection, Endpoint, Listener};\n\nimpl Bind for TcpListener {\n    type Error = Either<figment::Error, io::Error>;\n\n    async fn bind(rocket: &Rocket<Ignite>) -> Result<Self, Self::Error> {\n        let endpoint = Self::bind_endpoint(&rocket)?;\n        let addr = endpoint.tcp()\n            .ok_or_else(|| io::Error::other(\"internal error: invalid endpoint\"))\n            .map_err(Right)?;\n\n        Self::bind(addr).await.map_err(Right)\n    }\n\n    fn bind_endpoint(rocket: &Rocket<Ignite>) -> Result<Endpoint, Self::Error> {\n        let figment = rocket.figment();\n        let mut address = Endpoint::fetch(figment, \"tcp\", \"address\", |e| {\n            let default = SocketAddr::new(Ipv4Addr::LOCALHOST.into(), 8000);\n            e.map(|e| e.tcp()).unwrap_or(Some(default))\n        }).map_err(Left)?;\n\n        if figment.contains(\"port\") {\n            let port = figment.extract_inner(\"port\").map_err(Left)?;\n            address.set_port(port);\n        }\n\n        Ok(Endpoint::Tcp(address))\n    }\n}\n\nimpl Listener for TcpListener {\n    type Accept = Self::Connection;\n\n    type Connection = TcpStream;\n\n    async fn accept(&self) -> io::Result<Self::Accept> {\n        let conn = self.accept().await?.0;\n        let _ = conn.set_nodelay(true);\n        let _ = conn.set_linger(None);\n        Ok(conn)\n    }\n\n    async fn connect(&self, conn: Self::Connection) -> io::Result<Self::Connection> {\n        Ok(conn)\n    }\n\n    fn endpoint(&self) -> io::Result<Endpoint> {\n        self.local_addr().map(Endpoint::Tcp)\n    }\n}\n\nimpl Connection for TcpStream {\n    fn endpoint(&self) -> io::Result<Endpoint> {\n        self.peer_addr().map(Endpoint::Tcp)\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "a256fca288a9d19ea695d16484fb59876c3070ce",
    "func": "// Copyright 2019-2024 Tauri Programme within The Commons Conservancy\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n\nuse std::{\n  cmp::Ordering,\n  env::current_dir,\n  ffi::OsStr,\n  path::{Path, PathBuf},\n  sync::OnceLock,\n};\n\nuse ignore::WalkBuilder;\n\nuse tauri_utils::{\n  config::parse::{folder_has_configuration_file, is_configuration_file, ConfigFormat},\n  platform::Target,\n};\n\nconst TAURI_GITIGNORE: &[u8] = include_bytes!(\"../../tauri.gitignore\");\n// path to the Tauri app (Rust crate) directory, usually <cwd>/src-tauri\nconst ENV_TAURI_APP_PATH: &str = \"TAURI_APP_PATH\";\n// path to the frontend app directory\nconst ENV_TAURI_FRONTEND_PATH: &str = \"TAURI_FRONTEND_PATH\";\n\nstatic APP_DIR: OnceLock<PathBuf> = OnceLock::new();\nstatic TAURI_DIR: OnceLock<PathBuf> = OnceLock::new();\n\npub fn walk_builder(path: &Path) -> WalkBuilder {\n  let mut default_gitignore = std::env::temp_dir();\n  default_gitignore.push(\".gitignore\");\n  if !default_gitignore.exists() {\n    if let Ok(mut file) = std::fs::File::create(default_gitignore.clone()) {\n      use std::io::Write;\n      let _ = file.write_all(TAURI_GITIGNORE);\n    }\n  }\n\n  let mut builder = WalkBuilder::new(path);\n  builder.add_custom_ignore_filename(\".taurignore\");\n  builder.git_global(false);\n  let _ = builder.add_ignore(default_gitignore);\n  builder\n}\n\nfn lookup<F: Fn(&PathBuf) -> bool>(dir: &Path, checker: F) -> Option<PathBuf> {\n  let mut builder = walk_builder(dir);\n  builder\n    .require_git(false)\n    .ignore(false)\n    .max_depth(Some(\n      std::env::var(\"TAURI_CLI_CONFIG_DEPTH\")\n        .map(|d| {\n          d.parse()\n            .expect(\"`TAURI_CLI_CONFIG_DEPTH` environment variable must be a positive integer\")\n        })\n        .unwrap_or(3),\n    ))\n    .sort_by_file_path(|a, _| {\n      if a.extension().is_some() {\n        Ordering::Less\n      } else {\n        Ordering::Greater\n      }\n    });\n\n  for entry in builder.build().flatten() {\n    let path = dir.join(entry.path());\n    if checker(&path) {\n      return Some(path);\n    }\n  }\n  None\n}\n\nfn env_tauri_app_path() -> Option<PathBuf> {\n  std::env::var(ENV_TAURI_APP_PATH)\n    .map(PathBuf::from)\n    .ok()?\n    .canonicalize()\n    .ok()\n}\n\nfn env_tauri_frontend_path() -> Option<PathBuf> {\n  std::env::var(ENV_TAURI_FRONTEND_PATH)\n    .map(PathBuf::from)\n    .ok()?\n    .canonicalize()\n    .ok()\n}\n\npub fn resolve_tauri_dir() -> Option<PathBuf> {\n  let src_dir = env_tauri_frontend_path().or_else(|| current_dir().ok())?;\n\n  if src_dir.join(ConfigFormat::Json.into_file_name()).exists()\n    || src_dir.join(ConfigFormat::Json5.into_file_name()).exists()\n    || src_dir.join(ConfigFormat::Toml.into_file_name()).exists()\n  {\n    return Some(src_dir);\n  }\n\n  lookup(&src_dir, |path| {\n    folder_has_configuration_file(Target::Linux, path) || is_configuration_file(Target::Linux, path)\n  })\n  .map(|p| {\n    if p.is_dir() {\n      p\n    } else {\n      p.parent().unwrap().to_path_buf()\n    }\n  })\n}\n\npub fn resolve() {\n  TAURI_DIR.set(resolve_tauri_dir().unwrap_or_else(|| {\n    let env_var_name = env_tauri_frontend_path().is_some().then(|| format!(\"`{ENV_TAURI_FRONTEND_PATH}`\"));\n    panic!(\"Couldn't recognize the {} folder as a Tauri project. It must contain a `{}`, `{}` or `{}` file in any subfolder.\",\n      env_var_name.as_deref().unwrap_or(\"current\"),\n      ConfigFormat::Json.into_file_name(),\n      ConfigFormat::Json5.into_file_name(),\n      ConfigFormat::Toml.into_file_name()\n    )\n  })).expect(\"tauri dir already resolved\");\n  APP_DIR\n    .set(resolve_app_dir().unwrap_or_else(|| tauri_dir().parent().unwrap().to_path_buf()))\n    .expect(\"app dir already resolved\");\n}\n\npub fn tauri_dir() -> &'static PathBuf {\n  TAURI_DIR\n    .get()\n    .expect(\"app paths not initialized, this is a Tauri CLI bug\")\n}\n\npub fn resolve_app_dir() -> Option<PathBuf> {\n  let app_dir = env_tauri_app_path().unwrap_or_else(|| current_dir().expect(\"failed to read cwd\"));\n\n  if app_dir.join(\"package.json\").exists() {\n    return Some(app_dir);\n  }\n\n  lookup(&app_dir, |path| {\n    if let Some(file_name) = path.file_name() {\n      file_name == OsStr::new(\"package.json\")\n    } else {\n      false\n    }\n  })\n  .map(|p| p.parent().unwrap().to_path_buf())\n}\n\npub fn app_dir() -> &'static PathBuf {\n  APP_DIR\n    .get()\n    .expect(\"app paths not initialized, this is a Tauri CLI bug\")\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "869abf70c30e92cf2c57d56b7c16c523b67bcf09",
    "func": "use sea_orm::entity::prelude::*;\n\n#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum)]\n#[sea_orm(rs_type = \"String\", db_type = \"String(StringLen::N(1))\")]\npub enum Category {\n    #[sea_orm(string_value = \"B\")]\n    Big,\n    #[sea_orm(string_value = \"S\")]\n    Small,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum)]\n#[sea_orm(rs_type = \"i32\", db_type = \"Integer\")]\npub enum Color {\n    #[sea_orm(num_value = 0)]\n    Black,\n    #[sea_orm(num_value = 1)]\n    White,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, DeriveDisplay)]\n#[sea_orm(rs_type = \"String\", db_type = \"Enum\", enum_name = \"tea\")]\npub enum Tea {\n    #[sea_orm(string_value = \"EverydayTea\")]\n    EverydayTea,\n    #[sea_orm(string_value = \"BreakfastTea\")]\n    BreakfastTea,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, Copy)]\n#[sea_orm(rs_type = \"String\", db_type = \"Enum\", enum_name = \"media_type\")]\npub enum MediaType {\n    #[sea_orm(string_value = \"UNKNOWN\")]\n    Unknown,\n    #[sea_orm(string_value = \"BITMAP\")]\n    Bitmap,\n    #[sea_orm(string_value = \"DRAWING\")]\n    Drawing,\n    #[sea_orm(string_value = \"AUDIO\")]\n    Audio,\n    #[sea_orm(string_value = \"VIDEO\")]\n    Video,\n    #[sea_orm(string_value = \"MULTIMEDIA\")]\n    Multimedia,\n    #[sea_orm(string_value = \"OFFICE\")]\n    Office,\n    #[sea_orm(string_value = \"TEXT\")]\n    Text,\n    #[sea_orm(string_value = \"EXECUTABLE\")]\n    Executable,\n    #[sea_orm(string_value = \"ARCHIVE\")]\n    Archive,\n    #[sea_orm(string_value = \"3D\")]\n    _3D,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, EnumIter, DeriveActiveEnum, DeriveDisplay)]\n#[sea_orm(rs_type = \"String\", db_type = \"Enum\", enum_name = \"tea\")]\npub enum DisplayTea {\n    #[sea_orm(string_value = \"EverydayTea\", display_value = \"Everyday\")]\n    EverydayTea,\n    #[sea_orm(string_value = \"BreakfastTea\", display_value = \"Breakfast\")]\n    BreakfastTea,\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "edfe642f98e27a6beac6e552378adf6bdb6e1568",
    "func": "use diesel::prelude::*;\n\n#[derive(Queryable, Selectable)]\n#[diesel(table_name = crate::schema::posts)]\n#[diesel(check_for_backend(diesel::mysql::Mysql))]\npub struct Post {\n    pub id: i32,\n    pub title: String,\n    pub body: String,\n    pub published: bool,\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "19b2ebeb8038fdd6fac90a0fdd9354d042771a58",
    "func": "use crate::backend::{Backend, DieselReserveSpecialization};\nuse crate::dsl::SqlTypeOf;\nuse crate::expression::{\n    AppearsOnTable, Expression, QueryMetadata, Selectable, SelectableExpression,\n    TypedExpressionType, ValidGrouping,\n};\nuse crate::query_builder::*;\nuse crate::result::QueryResult;\n\n#[derive(Debug)]\npub struct SelectBy<T: Selectable<DB>, DB: Backend> {\n    selection: T::SelectExpression,\n    p: std::marker::PhantomData<(T, DB)>,\n}\n\nimpl<T, DB> Clone for SelectBy<T, DB>\nwhere\n    DB: Backend,\n    T: Selectable<DB>,\n{\n    fn clone(&self) -> Self {\n        Self {\n            selection: T::construct_selection(),\n            p: std::marker::PhantomData,\n        }\n    }\n}\n\nimpl<T, DB> Copy for SelectBy<T, DB>\nwhere\n    T: Selectable<DB>,\n    DB: Backend,\n    T::SelectExpression: Copy,\n{\n}\n\nimpl<T, E, DB> QueryId for SelectBy<T, DB>\nwhere\n    DB: Backend,\n    T: Selectable<DB, SelectExpression = E>,\n    E: QueryId + Expression,\n{\n    type QueryId = E::QueryId;\n\n    const HAS_STATIC_QUERY_ID: bool = E::HAS_STATIC_QUERY_ID;\n}\n\nimpl<T, DB> SelectBy<T, DB>\nwhere\n    T: Selectable<DB>,\n    DB: Backend,\n{\n    pub(crate) fn new() -> Self {\n        Self {\n            selection: T::construct_selection(),\n            p: std::marker::PhantomData,\n        }\n    }\n}\n\nimpl<T, E, DB> Expression for SelectBy<T, DB>\nwhere\n    DB: Backend,\n    T: Selectable<DB, SelectExpression = E>,\n    E: QueryId + Expression,\n{\n    type SqlType = SelectBy<T, DB>;\n}\n\nimpl<T, DB> TypedExpressionType for SelectBy<T, DB>\nwhere\n    T: Selectable<DB>,\n    DB: Backend,\n{\n}\n\nimpl<T, GB, E, DB> ValidGrouping<GB> for SelectBy<T, DB>\nwhere\n    DB: Backend,\n    T: Selectable<DB, SelectExpression = E>,\n    E: Expression + ValidGrouping<GB>,\n{\n    type IsAggregate = E::IsAggregate;\n}\n\nimpl<T, DB> QueryMetadata<SelectBy<T, DB>> for DB\nwhere\n    DB: Backend,\n    T: Selectable<DB>,\n    DB: QueryMetadata<SqlTypeOf<T::SelectExpression>>,\n{\n    fn row_metadata(lookup: &mut Self::MetadataLookup, out: &mut Vec<Option<Self::TypeMetadata>>) {\n        <DB as QueryMetadata<SqlTypeOf<<T as Selectable<DB>>::SelectExpression>>>::row_metadata(\n            lookup, out,\n        )\n    }\n}\n\nimpl<T, DB> QueryFragment<DB> for SelectBy<T, DB>\nwhere\n    T: Selectable<DB>,\n    T::SelectExpression: QueryFragment<DB>,\n    DB: Backend + DieselReserveSpecialization,\n{\n    fn walk_ast<'b>(&'b self, out: AstPass<'_, 'b, DB>) -> QueryResult<()> {\n        self.selection.walk_ast(out)\n    }\n}\n\nimpl<T, QS, DB> SelectableExpression<QS> for SelectBy<T, DB>\nwhere\n    DB: Backend,\n    T: Selectable<DB>,\n    T::SelectExpression: SelectableExpression<QS>,\n    Self: AppearsOnTable<QS>,\n{\n}\n\nimpl<T, QS, DB> AppearsOnTable<QS> for SelectBy<T, DB>\nwhere\n    DB: Backend,\n    T: Selectable<DB>,\n    T::SelectExpression: AppearsOnTable<QS>,\n    Self: Expression,\n{\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "8487234bee9f7e51e4da5bd99350c5c561493199",
    "func": "use async_graphql::http::{playground_source, GraphQLPlaygroundConfig};\nuse axum::{body::Body, extract::Request};\nuse loco_rs::prelude::*;\nuse tower_service::Service;\n\nuse crate::graphql::query_root;\n\n// GraphQL playground UI\nasync fn graphql_playground() -> Result<Response> {\n    // The `GraphQLPlaygroundConfig` take one parameter\n    // which is the URL of the GraphQL handler: `/api/graphql`\n    let res = playground_source(GraphQLPlaygroundConfig::new(\"/api/graphql\"));\n\n    Ok(Response::new(res.into()))\n}\n\nasync fn graphql_handler(State(ctx): State<AppContext>, req: Request<Body>) -> Result<Response> {\n    const DEPTH: usize = 1_000;\n    const COMPLEXITY: usize = 1_000;\n    // Construct the the GraphQL query root\n    let schema = query_root::schema(ctx.db.clone(), DEPTH, COMPLEXITY).unwrap();\n    // GraphQL handler\n    let mut graphql_handler = async_graphql_axum::GraphQL::new(schema);\n    // Execute GraphQL request and fetch the results\n    let res = graphql_handler.call(req).await.unwrap();\n\n    Ok(res)\n}\n\npub fn routes() -> Routes {\n    // Define route\n    Routes::new()\n        // We put all GraphQL route behind `graphql` prefix\n        .prefix(\"graphql\")\n        // GraphQL playground page is a GET request\n        .add(\"/\", get(graphql_playground))\n        // GraphQL handler is a POST request\n        .add(\"/\", post(graphql_handler))\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "acb2892b8e2d85fe341a75edee6e0e24d33ae300",
    "func": "use crate::fs::asyncify;\n\nuse std::io;\nuse std::path::Path;\n\n/// Creates a new file symbolic link on the filesystem.\n///\n/// The `dst` path will be a file symbolic link pointing to the `src`\n/// path.\n///\n/// This is an async version of [`std::os::windows::fs::symlink_file`][std]\n///\n/// [std]: https://doc.rust-lang.org/std/os/windows/fs/fn.symlink_file.html\npub async fn symlink_file(src: impl AsRef<Path>, dst: impl AsRef<Path>) -> io::Result<()> {\n    let src = src.as_ref().to_owned();\n    let dst = dst.as_ref().to_owned();\n\n    asyncify(move || std::os::windows::fs::symlink_file(src, dst)).await\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "7d02ad16775547739c3943ed798173607535d58c",
    "func": "mod uri;\nmod uri_parsing;\nmod test_guide;\nmod export;\n\npub mod typed_stream;\n\nuse devise::Result;\nuse syn::{Path, punctuated::Punctuated, parse::Parser, Token};\nuse syn::spanned::Spanned;\nuse proc_macro2::TokenStream;\n\nfn struct_maker_vec(\n    input: proc_macro::TokenStream,\n    ty: TokenStream,\n    map: impl Fn(TokenStream) -> TokenStream,\n) -> Result<TokenStream> {\n    use crate::exports::_Vec;\n\n    // Parse a comma-separated list of paths.\n    let paths = <Punctuated<Path, Token![,]>>::parse_terminated.parse(input)?;\n    let exprs = paths.iter().map(|path| {\n        let expr = map(quote_spanned!(path.span() => ___struct));\n        quote_spanned!(path.span() => {\n            let ___struct = #path {};\n            let ___item: #ty = #expr;\n            ___item\n        })\n    });\n\n    Ok(quote!({\n        let ___vec: #_Vec<#ty> = vec![#(#exprs),*];\n        ___vec\n    }))\n}\n\npub fn routes_macro(input: proc_macro::TokenStream) -> TokenStream {\n    struct_maker_vec(input, quote!(::rocket::Route), |e| quote!(#e.into_route()))\n        .unwrap_or_else(|diag| diag.emit_as_expr_tokens())\n}\n\npub fn catchers_macro(input: proc_macro::TokenStream) -> TokenStream {\n    struct_maker_vec(input, quote!(::rocket::Catcher), |e| quote!(#e.into_catcher()))\n        .unwrap_or_else(|diag| diag.emit_as_expr_tokens())\n}\n\npub fn uri_macro(input: proc_macro::TokenStream) -> TokenStream {\n    uri::_uri_macro(input.into())\n        .unwrap_or_else(|diag| diag.emit_as_expr_tokens_or(quote! {\n            rocket::http::uri::Origin::root()\n        }))\n}\n\npub fn uri_internal_macro(input: proc_macro::TokenStream) -> TokenStream {\n    // TODO: Ideally we would generate a perfect `Origin::root()` so that we don't\n    // assist in propagating further errors. Alas, we can't set the span to the\n    // invocation of `uri!` without access to `span.parent()`, and\n    // `Span::call_site()` here points to the `#[route]`, immediate caller,\n    // generating a rather confusing error message when there's a type-mismatch.\n    uri::_uri_internal_macro(input.into())\n        .unwrap_or_else(|diag| diag.emit_as_expr_tokens_or(quote! {\n            rocket::http::uri::Origin::root()\n        }))\n}\n\npub fn guide_tests_internal(input: proc_macro::TokenStream) -> TokenStream {\n    test_guide::_macro(input)\n        .unwrap_or_else(|diag| diag.emit_as_item_tokens())\n}\n\npub fn export_internal(input: proc_macro::TokenStream) -> TokenStream {\n    export::_macro(input)\n        .unwrap_or_else(|diag| diag.emit_as_item_tokens())\n}\n\npub fn typed_stream(input: proc_macro::TokenStream) -> TokenStream {\n    typed_stream::_macro(input)\n        .unwrap_or_else(|diag| diag.emit_as_item_tokens())\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "1280d9ab3a2bef83b42781db30cb259f6feefbb5",
    "func": "use proc_macro2::TokenStream;\nuse devise::ext::{TypeExt, SpanDiagnosticExt, GenericsExt, quote_respanned};\nuse syn::parse::Parser;\nuse devise::*;\n\nuse crate::exports::*;\nuse crate::derive::form_field::FieldName::*;\nuse crate::derive::form_field::{FieldExt, default, first_duplicate, validators};\nuse crate::syn_ext::{GenericsExt as _, TypeExt as _};\n\ntype WherePredicates = syn::punctuated::Punctuated<syn::WherePredicate, syn::Token![,]>;\n\nmacro_rules! quote_spanned {\n    ($span:expr => $($token:tt)*) => (\n        quote::quote_spanned!(\n            proc_macro2::Span::call_site().located_at($span) => $($token)*\n        )\n    )\n}\n\n// F: fn(field_ty: Ty, field_context: Expr)\nfn fields_map<F>(fields: Fields<'_>, map_f: F) -> Result<TokenStream>\n    where F: Fn(&syn::Type, &syn::Expr) -> TokenStream\n{\n    let mut matchers = vec![];\n    for field in fields.iter() {\n        let (ident, ty) = (field.context_ident(), field.stripped_ty());\n        let field_context: syn::Expr = syn::parse2(quote_spanned!(ty.span() => {\n            let __o = __c.__opts;\n            __c.#ident.get_or_insert_with(|| <#ty as #_form::FromForm<'r>>::init(__o))\n        })).expect(\"form context expression\");\n\n        let push = map_f(&ty, &field_context);\n        if fields.are_unnamed() {\n            // If we have unnamed fields, then we have exactly one by virtue of\n            // the earlier validation. Push directly to it and return.\n            return Ok(quote_spanned!(ident.span() =>\n                __c.__parent = __f.name.parent();\n                 #push\n            ));\n        }\n\n        matchers.extend(field.field_names()?.into_iter().map(|f| match f {\n            Cased(f) => quote_spanned!(ty.span() => #f => { #push }),\n            Uncased(f) => quote_spanned!(ty.span() => __n if __n.as_uncased() == #f => { #push }),\n        }));\n    }\n\n    Ok(quote! {\n        __c.__parent = __f.name.parent();\n\n        match __f.name.key_lossy().as_str() {\n            #(#matchers,)*\n            __k if __k == \"_method\" || !__c.__opts.strict => { /* ok */ },\n            _ => __c.__errors.push(__f.unexpected()),\n        }\n    })\n}\n\nfn generic_bounds_tokens(input: Input<'_>) -> Result<TokenStream> {\n    MapperBuild::new()\n        .try_enum_map(|m, e| mapper::enum_null(m, e))\n        .try_fields_map(|_, fields| {\n            let generic_idents = fields.parent.input().generics().type_idents();\n\n            let bounds = fields.iter()\n                .filter(|f| !f.ty.is_concrete(&generic_idents))\n                .map(|f| f.ty.with_replaced_lifetimes(syn::Lifetime::new(\"'r\", f.ty.span())))\n                .map(|ty| quote_spanned!(ty.span() => #ty: #_form::FromForm<'r>));\n\n            Ok(quote!(#(#bounds),*))\n        })\n        .map_input(input)\n}\n\nfn generic_bounds(input: Input<'_>) -> Result<WherePredicates> {\n    Ok(WherePredicates::parse_terminated.parse2(generic_bounds_tokens(input)?)?)\n}\n\nfn context_type(input: Input<'_>) -> Result<(TokenStream, syn::Generics)> {\n    let mut gen = input.generics().clone();\n\n    let lifetime = syn::parse_quote!('r);\n    if !gen.replace_lifetime(0, &lifetime) {\n        gen.insert_lifetime(syn::LifetimeParam::new(lifetime.clone()));\n    }\n\n    gen.add_where_predicates(generic_bounds(input)?);\n    let ty = quote_spanned!(input.ident().span() => FromFormGeneratedContext);\n    Ok((ty, gen))\n}\n\npub fn derive_from_form(input: proc_macro::TokenStream) -> TokenStream {\n    DeriveGenerator::build_for(input, quote!(impl<'r> #_form::FromForm<'r>))\n        .support(Support::Struct | Support::Lifetime | Support::Type)\n        .replace_generic(0, 0)\n        .type_bound_mapper(MapperBuild::new().try_input_map(|_, i| generic_bounds_tokens(i)))\n        .validator(ValidatorBuild::new()\n            .input_validate(|_, i| match i.generics().lifetimes().enumerate().last() {\n                Some((i, lt)) if i >= 1 => Err(lt.span().error(\"only one lifetime is supported\")),\n                _ => Ok(())\n            })\n            .fields_validate(|_, fields| {\n                if fields.is_empty() {\n                    return Err(fields.span().error(\"at least one field is required\"));\n                } else if fields.are_unnamed() && fields.count() != 1 {\n                    return Err(fields.span().error(\"tuple struct must have exactly one field\"));\n                } else if let Some(d) = first_duplicate(fields.iter(), |f| f.field_names())? {\n                    let (field_a_i, field_a, name_a) = d.0;\n                    let (field_b_i, field_b, name_b) = d.1;\n\n                    if field_a_i == field_b_i {\n                        return Err(field_a.error(\"field has conflicting names\")\n                            .span_note(name_a, \"this field name...\")\n                            .span_note(name_b, \"...conflicts with this field name\"));\n                    }\n\n                    return Err(name_b.error(\"field name conflicts with previous name\")\n                        .span_help(field_b, \"declared in this field\")\n                        .span_note(field_a, \"previous field with conflicting name\"));\n                }\n\n                Ok(())\n            })\n        )\n        .outer_mapper(MapperBuild::new()\n            .try_input_map(|mapper, input|  {\n                let vis = input.vis();\n                let (ctxt_ty, gen) = context_type(input)?;\n                let (impl_gen, _, where_clause)  = gen.split_for_impl();\n                let output = mapper::input_default(mapper, input)?;\n                Ok(quote_spanned! { mixed(input.span())=>\n                    /// Rocket generated FormForm context.\n                    #[doc(hidden)]\n                    #[allow(private_bounds)]\n                    #vis struct #ctxt_ty #impl_gen #where_clause {\n                        __opts: #_form::Options,\n                        __errors: #_form::Errors<'r>,\n                        __parent: #_Option<&'r #_form::Name>,\n                        #output\n                    }\n                })\n            })\n            .try_fields_map(|m, f| mapper::fields_null(m, f))\n            .field_map(|_, field| {\n                let ident = field.context_ident();\n                let mut ty = field.stripped_ty();\n                ty.replace_lifetimes(syn::parse_quote!('r));\n                let field_ty = quote_respanned!(ty.span() =>\n                    #_Option<<#ty as #_form::FromForm<'r>>::Context>\n                );\n\n                quote_spanned!(ty.span() => #ident: #field_ty,)\n            })\n        )\n        .outer_mapper(quote! {\n            #[allow(unused_imports)]\n            use #_http::uncased::AsUncased;\n        })\n        .outer_mapper(quote!(#[allow(clippy::all, clippy::pedantic, clippy::nursery)]))\n        .outer_mapper(quote!(#[allow(renamed_and_removed_lints)]))\n        .outer_mapper(quote!(#[allow(private_in_public)]))\n        .outer_mapper(quote!(#[rocket::async_trait]))\n        .inner_mapper(MapperBuild::new()\n            .try_input_map(|mapper, input| {\n                let (ctxt_ty, gen) = context_type(input)?;\n                let (_, ty_gen, _) = gen.split_for_impl();\n                let output = mapper::input_default(mapper, input)?;\n                Ok(quote! {\n                    type Context = #ctxt_ty #ty_gen;\n\n                    fn init(__opts: #_form::Options) -> Self::Context {\n                        Self::Context {\n                            __opts,\n                            __errors: #_form::Errors::new(),\n                            __parent: #_None,\n                            #output\n                        }\n                    }\n                })\n            })\n            .try_fields_map(|m, f| mapper::fields_null(m, f))\n            .field_map(|_, field| {\n                let ident = field.context_ident();\n                let ty = field.ty.with_stripped_lifetimes();\n                quote_spanned!(ty.span() => #ident: #_None,)\n            })\n        )\n        .inner_mapper(MapperBuild::new()\n            .with_output(|_, output| quote! {\n                fn push_value(__c: &mut Self::Context, __f: #_form::ValueField<'r>) {\n                    #output\n                }\n            })\n            .try_fields_map(|_, f| fields_map(f, |ty, ctxt| quote_spanned!(ty.span() => {\n                <#ty as #_form::FromForm<'r>>::push_value(#ctxt, __f.shift());\n            })))\n        )\n        .inner_mapper(MapperBuild::new()\n            .try_input_map(|mapper, input| {\n                let (ctxt_ty, gen) = context_type(input)?;\n                let (_, ty_gen, _) = gen.split_for_impl();\n                let output = mapper::input_default(mapper, input)?;\n                Ok(quote_spanned! { ctxt_ty.span() =>\n                    async fn push_data(\n                        __c: &mut #ctxt_ty #ty_gen,\n                        __f: #_form::DataField<'r, '_>\n                    ) {\n                        #output\n                    }\n                })\n            })\n            // Without the `let _fut`, we get a wild lifetime error. It don't\n            // make no sense, Rust async/await: it don't make no sense.\n            .try_fields_map(|_, f| fields_map(f, |ty, ctxt| quote_spanned!(ty.span() => {\n                let __fut = <#ty as #_form::FromForm<'r>>::push_data(#ctxt, __f.shift());\n                __fut.await;\n            })))\n        )\n        .inner_mapper(MapperBuild::new()\n            .with_output(|_, _| quote! {\n                fn push_error(__c: &mut Self::Context, __e: #_form::Error<'r>) {\n                    __c.__errors.push(__e);\n                }\n            }))\n        .inner_mapper(MapperBuild::new()\n            .with_output(|_, output| quote! {\n                fn finalize(mut __c: Self::Context) -> #_Result<Self, #_form::Errors<'r>> {\n                    #[allow(unused_imports)]\n                    use #_form::validate::*;\n\n                    #output\n                }\n            })\n            .try_fields_map(|mapper, fields| {\n                // This validates the attributes so we can `unwrap()` later.\n                let finalize_field = fields.iter()\n                    .map(|f| mapper.map_field(f))\n                    .collect::<Result<Vec<TokenStream>>>()?;\n\n                let (_ok, _some, _err, _none) = (_Ok, _Some, _Err, _None);\n                let validator = fields.iter().flat_map(|f| validators(f).unwrap());\n                let ident = fields.iter().map(|f| f.context_ident());\n                let builder = fields.builder(|f| {\n                    let ident = f.context_ident();\n                    quote_spanned!(ident.span() => #ident.unwrap())\n                });\n\n                Ok(quote_spanned!(fields.span() =>\n                    #(\n                        let #ident = match #finalize_field {\n                            #_ok(#ident) => #_some(#ident),\n                            #_err(__e) => { __c.__errors.extend(__e); #_none }\n                        };\n                    )*\n\n                    #(\n                        if let #_err(__e) = #validator {\n                            __c.__errors.extend(__e);\n                        }\n                    )*\n\n                    if !__c.__errors.is_empty() {\n                        return #_Err(__c.__errors);\n                    }\n\n                    Ok(#builder)\n                ))\n            })\n            .try_field_map(|_, f| {\n                let (ident, ty) = (f.context_ident(), f.stripped_ty());\n                let name_buf_opt = f.name_buf_opt()?;\n                let default = default(f)?\n                    .unwrap_or_else(|| quote_spanned!(ty.span() => {\n                        <#ty as #_form::FromForm<'r>>::default(__opts)\n                    }));\n\n                Ok(quote_spanned! { ty.span() => {\n                    let __opts = __c.__opts;\n                    let __name = #name_buf_opt;\n                    __c.#ident\n                        .map_or_else(\n                            || #default.ok_or_else(|| #_form::ErrorKind::Missing.into()),\n                            <#ty as #_form::FromForm<'r>>::finalize\n                        )\n                        .map_err(|__e| match __name {\n                            #_Some(__name) => __e.with_name(__name),\n                            #_None => __e,\n                        })\n                        .map_err(|__e| __e.is_empty()\n                            .then(|| #_form::ErrorKind::Unknown.into())\n                            .unwrap_or(__e))\n                }})\n            })\n        )\n        .to_tokens()\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "9e61340b0c167663a81f46b2b855ee52b52851d9",
    "func": "// Copyright 2019-2024 Tauri Programme within The Commons Conservancy\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n\nuse crate::{\n  helpers::updater_signature::{generate_key, save_keypair},\n  Result,\n};\nuse clap::Parser;\nuse std::path::PathBuf;\nuse tauri_utils::display_path;\n\n#[derive(Debug, Parser)]\n#[clap(about = \"Generate a new signing key to sign files\")]\npub struct Options {\n  /// Set private key password when signing\n  #[clap(short, long)]\n  password: Option<String>,\n  /// Write private key to a file\n  #[clap(short, long)]\n  write_keys: Option<PathBuf>,\n  /// Overwrite private key even if it exists on the specified path\n  #[clap(short, long)]\n  force: bool,\n  /// Skip prompting for values\n  #[clap(long, env = \"CI\")]\n  ci: bool,\n}\n\npub fn command(mut options: Options) -> Result<()> {\n  if options.ci && options.password.is_none() {\n    log::warn!(\"Generating new private key without password. For security reasons, we recommend setting a password instead.\");\n    options.password.replace(\"\".into());\n  }\n  let keypair = generate_key(options.password).expect(\"Failed to generate key\");\n\n  if let Some(output_path) = options.write_keys {\n    let (secret_path, public_path) =\n      save_keypair(options.force, output_path, &keypair.sk, &keypair.pk)\n        .expect(\"Unable to write keypair\");\n\n    println!(\n        \"\\nYour keypair was generated successfully\\nPrivate: {} (Keep it secret!)\\nPublic: {}\\n---------------------------\",\n        display_path(secret_path),\n        display_path(public_path)\n        )\n  } else {\n    println!(\n      \"\\nYour secret key was generated successfully - Keep it secret!\\n{}\\n\\n\",\n      keypair.sk\n    );\n    println!(\n          \"Your public key was generated successfully:\\n{}\\n\\nAdd the public key in your tauri.conf.json\\n---------------------------\\n\",\n          keypair.pk\n        );\n  }\n\n  println!(\"\\nEnvironment variables used to sign:\");\n  println!(\"`TAURI_SIGNING_PRIVATE_KEY`  Path or String of your private key\");\n  println!(\"`TAURI_SIGNING_PRIVATE_KEY_PASSWORD`  Your private key password (optional)\");\n  println!(\"\\nATTENTION: If you lose your private key OR password, you'll not be able to sign your update package and updates will not work.\\n---------------------------\\n\");\n\n  Ok(())\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "8b79ef21bf007edfc2e72388a729fb52241fad55",
    "func": "use bevy_color::Color;\nuse bevy_ecs::{\n    prelude::*,\n    system::{Query, SystemParam},\n};\nuse bevy_hierarchy::Children;\n\nuse crate::{TextColor, TextFont, TextSpan};\n\n/// Helper trait for using the [`TextReader`] and [`TextWriter`] system params.\npub trait TextSpanAccess: Component {\n    /// Gets the text span's string.\n    fn read_span(&self) -> &str;\n    /// Gets mutable reference to the text span's string.\n    fn write_span(&mut self) -> &mut String;\n}\n\n/// Helper trait for the root text component in a text block.\npub trait TextRoot: TextSpanAccess + From<String> {}\n\n/// Helper trait for the text span components in a text block.\npub trait TextSpanComponent: TextSpanAccess + From<String> {}\n\n#[derive(Resource, Default)]\npub(crate) struct TextIterScratch {\n    stack: Vec<(&'static Children, usize)>,\n}\n\nimpl TextIterScratch {\n    fn take<'a>(&mut self) -> Vec<(&'a Children, usize)> {\n        core::mem::take(&mut self.stack)\n            .into_iter()\n            .map(|_| -> (&Children, usize) { unreachable!() })\n            .collect()\n    }\n\n    fn recover(&mut self, mut stack: Vec<(&Children, usize)>) {\n        stack.clear();\n        self.stack = stack\n            .into_iter()\n            .map(|_| -> (&'static Children, usize) { unreachable!() })\n            .collect();\n    }\n}\n\n/// System parameter for reading text spans in a text block.\n///\n/// `R` is the root text component.\n#[derive(SystemParam)]\npub struct TextReader<'w, 's, R: TextRoot> {\n    // This is a local to avoid system ambiguities when TextReaders run in parallel.\n    scratch: Local<'s, TextIterScratch>,\n    roots: Query<\n        'w,\n        's,\n        (\n            &'static R,\n            &'static TextFont,\n            &'static TextColor,\n            Option<&'static Children>,\n        ),\n    >,\n    spans: Query<\n        'w,\n        's,\n        (\n            &'static TextSpan,\n            &'static TextFont,\n            &'static TextColor,\n            Option<&'static Children>,\n        ),\n    >,\n}\n\nimpl<'w, 's, R: TextRoot> TextReader<'w, 's, R> {\n    /// Returns an iterator over text spans in a text block, starting with the root entity.\n    pub fn iter(&mut self, root_entity: Entity) -> TextSpanIter<R> {\n        let stack = self.scratch.take();\n\n        TextSpanIter {\n            scratch: &mut self.scratch,\n            root_entity: Some(root_entity),\n            stack,\n            roots: &self.roots,\n            spans: &self.spans,\n        }\n    }\n\n    /// Gets a text span within a text block at a specific index in the flattened span list.\n    pub fn get(\n        &mut self,\n        root_entity: Entity,\n        index: usize,\n    ) -> Option<(Entity, usize, &str, &TextFont, Color)> {\n        self.iter(root_entity).nth(index)\n    }\n\n    /// Gets the text value of a text span within a text block at a specific index in the flattened span list.\n    pub fn get_text(&mut self, root_entity: Entity, index: usize) -> Option<&str> {\n        self.get(root_entity, index).map(|(_, _, text, _, _)| text)\n    }\n\n    /// Gets the [`TextFont`] of a text span within a text block at a specific index in the flattened span list.\n    pub fn get_font(&mut self, root_entity: Entity, index: usize) -> Option<&TextFont> {\n        self.get(root_entity, index).map(|(_, _, _, font, _)| font)\n    }\n\n    /// Gets the [`TextColor`] of a text span within a text block at a specific index in the flattened span list.\n    pub fn get_color(&mut self, root_entity: Entity, index: usize) -> Option<Color> {\n        self.get(root_entity, index)\n            .map(|(_, _, _, _, color)| color)\n    }\n\n    /// Gets the text value of a text span within a text block at a specific index in the flattened span list.\n    ///\n    /// Panics if there is no span at the requested index.\n    pub fn text(&mut self, root_entity: Entity, index: usize) -> &str {\n        self.get_text(root_entity, index).unwrap()\n    }\n\n    /// Gets the [`TextFont`] of a text span within a text block at a specific index in the flattened span list.\n    ///\n    /// Panics if there is no span at the requested index.\n    pub fn font(&mut self, root_entity: Entity, index: usize) -> &TextFont {\n        self.get_font(root_entity, index).unwrap()\n    }\n\n    /// Gets the [`TextColor`] of a text span within a text block at a specific index in the flattened span list.\n    ///\n    /// Panics if there is no span at the requested index.\n    pub fn color(&mut self, root_entity: Entity, index: usize) -> Color {\n        self.get_color(root_entity, index).unwrap()\n    }\n}\n\n/// Iterator returned by [`TextReader::iter`].\n///\n/// Iterates all spans in a text block according to hierarchy traversal order.\n/// Does *not* flatten interspersed ghost nodes. Only contiguous spans are traversed.\n// TODO: Use this iterator design in UiChildrenIter to reduce allocations.\npub struct TextSpanIter<'a, R: TextRoot> {\n    scratch: &'a mut TextIterScratch,\n    root_entity: Option<Entity>,\n    /// Stack of (children, next index into children).\n    stack: Vec<(&'a Children, usize)>,\n    roots: &'a Query<\n        'a,\n        'a,\n        (\n            &'static R,\n            &'static TextFont,\n            &'static TextColor,\n            Option<&'static Children>,\n        ),\n    >,\n    spans: &'a Query<\n        'a,\n        'a,\n        (\n            &'static TextSpan,\n            &'static TextFont,\n            &'static TextColor,\n            Option<&'static Children>,\n        ),\n    >,\n}\n\nimpl<'a, R: TextRoot> Iterator for TextSpanIter<'a, R> {\n    /// Item = (entity in text block, hierarchy depth in the block, span text, span style).\n    type Item = (Entity, usize, &'a str, &'a TextFont, Color);\n    fn next(&mut self) -> Option<Self::Item> {\n        // Root\n        if let Some(root_entity) = self.root_entity.take() {\n            if let Ok((text, text_font, color, maybe_children)) = self.roots.get(root_entity) {\n                if let Some(children) = maybe_children {\n                    self.stack.push((children, 0));\n                }\n                return Some((root_entity, 0, text.read_span(), text_font, color.0));\n            }\n            return None;\n        }\n\n        // Span\n        loop {\n            let (children, idx) = self.stack.last_mut()?;\n\n            loop {\n                let Some(child) = children.get(*idx) else {\n                    break;\n                };\n\n                // Increment to prep the next entity in this stack level.\n                *idx += 1;\n\n                let entity = *child;\n                let Ok((span, text_font, color, maybe_children)) = self.spans.get(entity) else {\n                    continue;\n                };\n\n                let depth = self.stack.len();\n                if let Some(children) = maybe_children {\n                    self.stack.push((children, 0));\n                }\n                return Some((entity, depth, span.read_span(), text_font, color.0));\n            }\n\n            // All children at this stack entry have been iterated.\n            self.stack.pop();\n        }\n    }\n}\n\nimpl<'a, R: TextRoot> Drop for TextSpanIter<'a, R> {\n    fn drop(&mut self) {\n        // Return the internal stack.\n        let stack = core::mem::take(&mut self.stack);\n        self.scratch.recover(stack);\n    }\n}\n\n/// System parameter for reading and writing text spans in a text block.\n///\n/// `R` is the root text component, and `S` is the text span component on children.\n#[derive(SystemParam)]\npub struct TextWriter<'w, 's, R: TextRoot> {\n    // This is a resource because two TextWriters can't run in parallel.\n    scratch: ResMut<'w, TextIterScratch>,\n    roots: Query<\n        'w,\n        's,\n        (\n            &'static mut R,\n            &'static mut TextFont,\n            &'static mut TextColor,\n        ),\n        Without<TextSpan>,\n    >,\n    spans: Query<\n        'w,\n        's,\n        (\n            &'static mut TextSpan,\n            &'static mut TextFont,\n            &'static mut TextColor,\n        ),\n        Without<R>,\n    >,\n    children: Query<'w, 's, &'static Children>,\n}\n\nimpl<'w, 's, R: TextRoot> TextWriter<'w, 's, R> {\n    /// Gets a mutable reference to a text span within a text block at a specific index in the flattened span list.\n    pub fn get(\n        &mut self,\n        root_entity: Entity,\n        index: usize,\n    ) -> Option<(Entity, usize, Mut<String>, Mut<TextFont>, Mut<TextColor>)> {\n        // Root\n        if index == 0 {\n            let (text, font, color) = self.roots.get_mut(root_entity).ok()?;\n            return Some((\n                root_entity,\n                0,\n                text.map_unchanged(|t| t.write_span()),\n                font,\n                color,\n            ));\n        }\n\n        // Prep stack.\n        let mut stack: Vec<(&Children, usize)> = self.scratch.take();\n        if let Ok(children) = self.children.get(root_entity) {\n            stack.push((children, 0));\n        }\n\n        // Span\n        let mut count = 1;\n        let (depth, entity) = 'l: loop {\n            let Some((children, idx)) = stack.last_mut() else {\n                self.scratch.recover(stack);\n                return None;\n            };\n\n            loop {\n                let Some(child) = children.get(*idx) else {\n                    // All children at this stack entry have been iterated.\n                    stack.pop();\n                    break;\n                };\n\n                // Increment to prep the next entity in this stack level.\n                *idx += 1;\n\n                if !self.spans.contains(*child) {\n                    continue;\n                };\n                count += 1;\n\n                if count - 1 == index {\n                    let depth = stack.len();\n                    self.scratch.recover(stack);\n                    break 'l (depth, *child);\n                }\n\n                if let Ok(children) = self.children.get(*child) {\n                    stack.push((children, 0));\n                    break;\n                }\n            }\n        };\n\n        // Note: We do this outside the loop due to borrow checker limitations.\n        let (text, font, color) = self.spans.get_mut(entity).unwrap();\n        Some((\n            entity,\n            depth,\n            text.map_unchanged(|t| t.write_span()),\n            font,\n            color,\n        ))\n    }\n\n    /// Gets the text value of a text span within a text block at a specific index in the flattened span list.\n    pub fn get_text(&mut self, root_entity: Entity, index: usize) -> Option<Mut<String>> {\n        self.get(root_entity, index).map(|(_, _, text, ..)| text)\n    }\n\n    /// Gets the [`TextFont`] of a text span within a text block at a specific index in the flattened span list.\n    pub fn get_font(&mut self, root_entity: Entity, index: usize) -> Option<Mut<TextFont>> {\n        self.get(root_entity, index).map(|(_, _, _, font, _)| font)\n    }\n\n    /// Gets the [`TextColor`] of a text span within a text block at a specific index in the flattened span list.\n    pub fn get_color(&mut self, root_entity: Entity, index: usize) -> Option<Mut<TextColor>> {\n        self.get(root_entity, index)\n            .map(|(_, _, _, _, color)| color)\n    }\n\n    /// Gets the text value of a text span within a text block at a specific index in the flattened span list.\n    ///\n    /// Panics if there is no span at the requested index.\n    pub fn text(&mut self, root_entity: Entity, index: usize) -> Mut<String> {\n        self.get_text(root_entity, index).unwrap()\n    }\n\n    /// Gets the [`TextFont`] of a text span within a text block at a specific index in the flattened span list.\n    ///\n    /// Panics if there is no span at the requested index.\n    pub fn font(&mut self, root_entity: Entity, index: usize) -> Mut<TextFont> {\n        self.get_font(root_entity, index).unwrap()\n    }\n\n    /// Gets the [`TextColor`] of a text span within a text block at a specific index in the flattened span list.\n    ///\n    /// Panics if there is no span at the requested index.\n    pub fn color(&mut self, root_entity: Entity, index: usize) -> Mut<TextColor> {\n        self.get_color(root_entity, index).unwrap()\n    }\n\n    /// Invokes a callback on each span in a text block, starting with the root entity.\n    pub fn for_each(\n        &mut self,\n        root_entity: Entity,\n        mut callback: impl FnMut(Entity, usize, Mut<String>, Mut<TextFont>, Mut<TextColor>),\n    ) {\n        self.for_each_until(root_entity, |a, b, c, d, e| {\n            (callback)(a, b, c, d, e);\n            true\n        });\n    }\n\n    /// Invokes a callback on each span's string value in a text block, starting with the root entity.\n    pub fn for_each_text(&mut self, root_entity: Entity, mut callback: impl FnMut(Mut<String>)) {\n        self.for_each(root_entity, |_, _, text, _, _| {\n            (callback)(text);\n        });\n    }\n\n    /// Invokes a callback on each span's [`TextFont`] in a text block, starting with the root entity.\n    pub fn for_each_font(&mut self, root_entity: Entity, mut callback: impl FnMut(Mut<TextFont>)) {\n        self.for_each(root_entity, |_, _, _, font, _| {\n            (callback)(font);\n        });\n    }\n\n    /// Invokes a callback on each span's [`TextColor`] in a text block, starting with the root entity.\n    pub fn for_each_color(\n        &mut self,\n        root_entity: Entity,\n        mut callback: impl FnMut(Mut<TextColor>),\n    ) {\n        self.for_each(root_entity, |_, _, _, _, color| {\n            (callback)(color);\n        });\n    }\n\n    /// Invokes a callback on each span in a text block, starting with the root entity.\n    ///\n    /// Traversal will stop when the callback returns `false`.\n    // TODO: find a way to consolidate get and for_each_until, or provide a real iterator. Lifetime issues are challenging here.\n    pub fn for_each_until(\n        &mut self,\n        root_entity: Entity,\n        mut callback: impl FnMut(Entity, usize, Mut<String>, Mut<TextFont>, Mut<TextColor>) -> bool,\n    ) {\n        // Root\n        let Ok((text, font, color)) = self.roots.get_mut(root_entity) else {\n            return;\n        };\n        if !(callback)(\n            root_entity,\n            0,\n            text.map_unchanged(|t| t.write_span()),\n            font,\n            color,\n        ) {\n            return;\n        }\n\n        // Prep stack.\n        let mut stack: Vec<(&Children, usize)> = self.scratch.take();\n        if let Ok(children) = self.children.get(root_entity) {\n            stack.push((children, 0));\n        }\n\n        // Span\n        loop {\n            let depth = stack.len();\n            let Some((children, idx)) = stack.last_mut() else {\n                self.scratch.recover(stack);\n                return;\n            };\n\n            loop {\n                let Some(child) = children.get(*idx) else {\n                    // All children at this stack entry have been iterated.\n                    stack.pop();\n                    break;\n                };\n\n                // Increment to prep the next entity in this stack level.\n                *idx += 1;\n\n                let entity = *child;\n                let Ok((text, font, color)) = self.spans.get_mut(entity) else {\n                    continue;\n                };\n\n                if !(callback)(\n                    entity,\n                    depth,\n                    text.map_unchanged(|t| t.write_span()),\n                    font,\n                    color,\n                ) {\n                    self.scratch.recover(stack);\n                    return;\n                }\n\n                if let Ok(children) = self.children.get(entity) {\n                    stack.push((children, 0));\n                    break;\n                }\n            }\n        }\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "3496c58be238ba0fb8a5909b76ba01b5a9e0aea4",
    "func": "use bevy_derive::Deref;\n\n#[derive(Deref)]\n//~^ ERROR: cannot be derived on field-less structs\nstruct UnitStruct;\n\n#[derive(Deref)]\n//~^ ERROR: can only be derived on structs\nenum Enum {}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "528ecc7c3387e55813b625bb5253ad03c5f37fe4",
    "func": "// Copyright 2019-2024 Tauri Programme within The Commons Conservancy\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n\nuse std::path::{Component, Path, PathBuf, MAIN_SEPARATOR};\n\nuse serialize_to_javascript::{default_template, DefaultTemplate, Template};\n\nuse super::{BaseDirectory, Error, PathResolver, Result};\nuse crate::{\n  command,\n  plugin::{Builder, TauriPlugin},\n  AppHandle, Manager, Runtime, State,\n};\n\n/// Normalize a path, removing things like `.` and `..`, this snippet is taken from cargo's paths util.\n/// <https://github.com/rust-lang/cargo/blob/46fa867ff7043e3a0545bf3def7be904e1497afd/crates/cargo-util/src/paths.rs#L73-L106>\nfn normalize_path(path: &Path) -> PathBuf {\n  let mut components = path.components().peekable();\n  let mut ret = if let Some(c @ Component::Prefix(..)) = components.peek().cloned() {\n    components.next();\n    PathBuf::from(c.as_os_str())\n  } else {\n    PathBuf::new()\n  };\n\n  for component in components {\n    match component {\n      Component::Prefix(..) => unreachable!(),\n      Component::RootDir => {\n        ret.push(component.as_os_str());\n      }\n      Component::CurDir => {}\n      Component::ParentDir => {\n        ret.pop();\n      }\n      Component::Normal(c) => {\n        ret.push(c);\n      }\n    }\n  }\n  ret\n}\n\n/// Normalize a path, removing things like `.` and `..`, this snippet is taken from cargo's paths util but\n/// slightly modified to not resolve absolute paths.\n/// <https://github.com/rust-lang/cargo/blob/46fa867ff7043e3a0545bf3def7be904e1497afd/crates/cargo-util/src/paths.rs#L73-L106>\nfn normalize_path_no_absolute(path: &Path) -> PathBuf {\n  let mut components = path.components().peekable();\n  let mut ret = if let Some(c @ Component::Prefix(..)) = components.peek().cloned() {\n    components.next();\n    PathBuf::from(c.as_os_str())\n  } else {\n    PathBuf::new()\n  };\n\n  for component in components {\n    match component {\n      Component::Prefix(..) => unreachable!(),\n      Component::RootDir => {\n        ret.push(component.as_os_str());\n      }\n      Component::CurDir => {}\n      Component::ParentDir => {\n        ret.pop();\n      }\n      Component::Normal(c) => {\n        // Using PathBuf::push here will replace the whole path if an absolute path is encountered\n        // which is not the intended behavior, so instead of that, convert the current resolved path\n        // to a string and do simple string concatenation with the current component then convert it\n        // back to a PathBuf\n        let mut p = ret.to_string_lossy().to_string();\n        // Only add a separator if it doesn't have one already or if current normalized path is empty,\n        // this ensures it won't have an unwanted leading separator\n        if !p.is_empty() && !p.ends_with('/') && !p.ends_with('\\\\') {\n          p.push(MAIN_SEPARATOR);\n        }\n        if let Some(c) = c.to_str() {\n          p.push_str(c);\n        }\n        ret = PathBuf::from(p);\n      }\n    }\n  }\n  ret\n}\n\n#[command(root = \"crate\")]\npub fn resolve_directory<R: Runtime>(\n  _app: AppHandle<R>,\n  resolver: State<'_, PathResolver<R>>,\n  directory: BaseDirectory,\n  path: Option<PathBuf>,\n) -> Result<PathBuf> {\n  super::resolve_path(&resolver, directory, path).map(|p| dunce::simplified(&p).to_path_buf())\n}\n\n#[command(root = \"crate\")]\npub fn resolve(paths: Vec<String>) -> Result<PathBuf> {\n  // Start with current directory then start adding paths from the vector one by one using `PathBuf.push()` which\n  // will ensure that if an absolute path is encountered in the iteration, it will be used as the current full path.\n  //\n  // examples:\n  // 1. `vec![\".\"]` or `vec![]` will be equal to `std::env::current_dir()`\n  // 2. `vec![\"/foo/bar\", \"/tmp/file\", \"baz\"]` will be equal to `PathBuf::from(\"/tmp/file/baz\")`\n  let mut path = std::env::current_dir().map_err(Error::CurrentDir)?;\n  for p in paths {\n    path.push(p);\n  }\n  Ok(dunce::simplified(&normalize_path(&path)).to_path_buf())\n}\n\n#[command(root = \"crate\")]\npub fn normalize(path: String) -> String {\n  let mut p = dunce::simplified(&normalize_path_no_absolute(Path::new(&path)))\n    .to_string_lossy()\n    .to_string();\n\n  // Node.js behavior is to return `\"..\"` for `normalize(\"..\")`\n  // and `\".\"` for `normalize(\"\")` or `normalize(\".\")`\n  if p.is_empty() && path == \"..\" {\n    \"..\".into()\n  } else if p.is_empty() && path == \".\" {\n    \".\".into()\n  } else {\n    // Add a trailing separator if the path passed to this functions had a trailing separator. That's how Node.js behaves.\n    if (path.ends_with('/') || path.ends_with('\\\\')) && (!p.ends_with('/') || !p.ends_with('\\\\')) {\n      p.push(MAIN_SEPARATOR);\n    }\n    p\n  }\n}\n\n#[command(root = \"crate\")]\npub fn join(mut paths: Vec<String>) -> String {\n  let path = PathBuf::from(\n    paths\n      .iter_mut()\n      .map(|p| {\n        // Add a `MAIN_SEPARATOR` if it doesn't already have one.\n        // Doing this to ensure that the vector elements are separated in\n        // the resulting string so path.components() can work correctly when called\n        // in `normalize_path_no_absolute()` later on.\n        if !p.ends_with('/') && !p.ends_with('\\\\') {\n          p.push(MAIN_SEPARATOR);\n        }\n        p.to_string()\n      })\n      .collect::<String>(),\n  );\n\n  let p = dunce::simplified(&normalize_path_no_absolute(&path))\n    .to_string_lossy()\n    .to_string();\n\n  if p.is_empty() {\n    \".\".into()\n  } else {\n    p\n  }\n}\n\n#[command(root = \"crate\")]\npub fn dirname(path: String) -> Result<PathBuf> {\n  match Path::new(&path).parent() {\n    Some(p) => Ok(dunce::simplified(p).to_path_buf()),\n    None => Err(Error::NoParent),\n  }\n}\n\n#[command(root = \"crate\")]\npub fn extname(path: String) -> Result<String> {\n  match Path::new(&path)\n    .extension()\n    .and_then(std::ffi::OsStr::to_str)\n  {\n    Some(p) => Ok(p.to_string()),\n    None => Err(Error::NoExtension),\n  }\n}\n\n#[command(root = \"crate\")]\npub fn basename(path: &str, ext: Option<&str>) -> Result<String> {\n  let file_name = Path::new(path).file_name().map(|f| f.to_string_lossy());\n  match file_name {\n    Some(p) => {\n      let maybe_stripped = if let Some(ext) = ext {\n        p.strip_suffix(ext).unwrap_or(&p).to_string()\n      } else {\n        p.to_string()\n      };\n      Ok(maybe_stripped)\n    }\n    None => Err(Error::NoBasename),\n  }\n}\n\n#[command(root = \"crate\")]\npub fn is_absolute(path: String) -> bool {\n  Path::new(&path).is_absolute()\n}\n\n#[derive(Template)]\n#[default_template(\"./init.js\")]\nstruct InitJavascript {\n  sep: &'static str,\n  delimiter: &'static str,\n}\n\n/// Initializes the plugin.\npub(crate) fn init<R: Runtime>() -> TauriPlugin<R> {\n  #[cfg(windows)]\n  let (sep, delimiter) = (\"\\\\\", \";\");\n  #[cfg(not(windows))]\n  let (sep, delimiter) = (\"/\", \":\");\n\n  let init_js = InitJavascript { sep, delimiter }\n    .render_default(&Default::default())\n    // this will never fail with the above sep and delimiter values\n    .unwrap();\n\n  Builder::new(\"path\")\n    .invoke_handler(crate::generate_handler![\n      resolve_directory,\n      resolve,\n      normalize,\n      join,\n      dirname,\n      extname,\n      basename,\n      is_absolute\n    ])\n    .js_init_script(init_js.to_string())\n    .setup(|app, _api| {\n      #[cfg(target_os = \"android\")]\n      {\n        let handle = _api.register_android_plugin(\"app.tauri\", \"PathPlugin\")?;\n        app.manage(PathResolver(handle));\n      }\n\n      #[cfg(not(target_os = \"android\"))]\n      {\n        app.manage(PathResolver(app.clone()));\n      }\n\n      Ok(())\n    })\n    .build()\n}\n\n#[cfg(test)]\nmod tests {\n\n  #[test]\n  fn basename() {\n    let path = \"/path/to/some-json-file.json\";\n    assert_eq!(\n      super::basename(path, Some(\".json\")).unwrap(),\n      \"some-json-file\"\n    );\n\n    let path = \"/path/to/some-json-file.json\";\n    assert_eq!(\n      super::basename(path, Some(\"json\")).unwrap(),\n      \"some-json-file.\"\n    );\n\n    let path = \"/path/to/some-json-file.html.json\";\n    assert_eq!(\n      super::basename(path, Some(\".json\")).unwrap(),\n      \"some-json-file.html\"\n    );\n\n    let path = \"/path/to/some-json-file.json.json\";\n    assert_eq!(\n      super::basename(path, Some(\".json\")).unwrap(),\n      \"some-json-file.json\"\n    );\n\n    let path = \"/path/to/some-json-file.json.html\";\n    assert_eq!(\n      super::basename(path, Some(\".json\")).unwrap(),\n      \"some-json-file.json.html\"\n    );\n  }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "5a608d61bf5abd2ac218951def0ce5bbeabcc6c6",
    "func": "use crate::schema::*;\nuse diesel::*;\n\nmacro_rules! assert_sets_eq {\n    ($set1:expr, $set2:expr) => {\n        let set1 = { $set1 };\n        let set2 = { $set2 };\n        let s1r: Vec<_> = set1.iter().filter(|&si| !set2.contains(si)).collect();\n        assert!(\n            s1r.len() == 0,\n            \"left set contains items not found in right set: {:?}\",\n            s1r\n        );\n        let s2r: Vec<_> = set2.iter().filter(|&si| !set1.contains(si)).collect();\n        assert!(\n            s2r.len() == 0,\n            \"right set contains items not found in left set: {:?}\",\n            s2r\n        );\n    };\n}\n\n#[test]\nfn filter_by_int_equality() {\n    use crate::schema::users::dsl::*;\n\n    let connection = &mut connection_with_sean_and_tess_in_users_table();\n    let sean_id = find_user_by_name(\"Sean\", connection).id;\n    let tess_id = find_user_by_name(\"Tess\", connection).id;\n    let unused_id = sean_id + tess_id;\n\n    let sean = User::new(sean_id, \"Sean\");\n    let tess = User::new(tess_id, \"Tess\");\n    assert_eq!(Ok(sean), users.filter(id.eq(sean_id)).first(connection));\n    assert_eq!(Ok(tess), users.filter(id.eq(tess_id)).first(connection));\n    assert_eq!(\n        Err(NotFound),\n        users.filter(id.eq(unused_id)).first::<User>(connection)\n    );\n}\n\n#[test]\nfn filter_by_string_equality() {\n    use crate::schema::users::dsl::*;\n\n    let connection = &mut connection_with_sean_and_tess_in_users_table();\n\n    let sean = User::new(1, \"Sean\");\n    let tess = User::new(2, \"Tess\");\n    assert_eq!(Ok(sean), users.filter(name.eq(\"Sean\")).first(connection));\n    assert_eq!(Ok(tess), users.filter(name.eq(\"Tess\")).first(connection));\n    assert_eq!(\n        Err(NotFound),\n        users.filter(name.eq(\"Jim\")).first::<User>(connection)\n    );\n}\n\n#[test]\nfn filter_by_equality_on_nullable_columns() {\n    use crate::schema::users::dsl::*;\n\n    let connection = &mut connection();\n    let data = vec![\n        NewUser::new(\"Sean\", Some(\"black\")),\n        NewUser::new(\"Tess\", Some(\"brown\")),\n        NewUser::new(\"Jim\", Some(\"black\")),\n    ];\n    insert_into(users)\n        .values(&data)\n        .execute(connection)\n        .unwrap();\n\n    let data = users.order(id).load::<User>(connection).unwrap();\n    let sean = data[0].clone();\n    let tess = data[1].clone();\n    let jim = data[2].clone();\n\n    let source = users.filter(hair_color.eq(\"black\"));\n    assert_sets_eq!(vec![sean, jim], source.load(connection).unwrap());\n\n    let source = users.filter(hair_color.eq(\"brown\"));\n    assert_eq!(vec![tess], source.load(connection).unwrap());\n}\n\n#[test]\nfn filter_by_is_not_null_on_nullable_columns() {\n    use crate::schema::users::dsl::*;\n\n    let connection = &mut connection();\n    let data = vec![\n        NewUser::new(\"Derek\", Some(\"red\")),\n        NewUser::new(\"Gordon\", None),\n    ];\n    insert_into(users)\n        .values(&data)\n        .execute(connection)\n        .unwrap();\n    let data = users.order(id).load::<User>(connection).unwrap();\n    let derek = data[0].clone();\n\n    let source = users.filter(hair_color.is_not_null());\n    assert_eq!(vec![derek], source.load(connection).unwrap());\n}\n\n#[test]\nfn filter_by_is_null_on_nullable_columns() {\n    use crate::schema::users::dsl::*;\n\n    let connection = &mut connection();\n    let data = vec![\n        NewUser::new(\"Derek\", Some(\"red\")),\n        NewUser::new(\"Gordon\", None),\n    ];\n    insert_into(users)\n        .values(&data)\n        .execute(connection)\n        .unwrap();\n    let data = users.order(id).load::<User>(connection).unwrap();\n    let gordon = data[1].clone();\n\n    let source = users.filter(hair_color.is_null());\n    assert_eq!(vec![gordon], source.load(connection).unwrap());\n}\n\n#[test]\nfn filter_after_joining() {\n    use crate::schema::users::name;\n\n    let connection = &mut connection_with_sean_and_tess_in_users_table();\n    diesel::sql_query(\n        \"INSERT INTO posts (id, title, user_id) VALUES\n                       (1, 'Hello', 1), (2, 'World', 2)\",\n    )\n    .execute(connection)\n    .unwrap();\n\n    let sean = User::new(1, \"Sean\");\n    let tess = User::new(2, \"Tess\");\n    let seans_post = Post::new(1, 1, \"Hello\", None);\n    let tess_post = Post::new(2, 2, \"World\", None);\n    let source = users::table.inner_join(posts::table);\n    assert_eq!(\n        Ok((sean, seans_post)),\n        source.filter(name.eq(\"Sean\")).first(connection)\n    );\n    assert_eq!(\n        Ok((tess, tess_post)),\n        source.filter(name.eq(\"Tess\")).first(connection)\n    );\n    assert_eq!(\n        Err(NotFound),\n        source\n            .filter(name.eq(\"Jim\"))\n            .first::<(User, Post)>(connection)\n    );\n}\n\n#[test]\nfn select_then_filter() {\n    use crate::schema::users::dsl::*;\n\n    let connection = &mut connection_with_sean_and_tess_in_users_table();\n\n    let source = users.select(name);\n    assert_eq!(\n        Ok(\"Sean\".to_string()),\n        source.filter(name.eq(\"Sean\")).first(connection)\n    );\n    assert_eq!(\n        Ok(\"Tess\".to_string()),\n        source.filter(name.eq(\"Tess\")).first(connection)\n    );\n    assert_eq!(\n        Err(NotFound),\n        source.filter(name.eq(\"Jim\")).first::<String>(connection)\n    );\n}\n\n#[test]\nfn filter_then_select() {\n    use crate::schema::users::dsl::*;\n\n    let connection = &mut connection();\n    let data = vec![NewUser::new(\"Sean\", None), NewUser::new(\"Tess\", None)];\n    insert_into(users)\n        .values(&data)\n        .execute(connection)\n        .unwrap();\n\n    assert_eq!(\n        Ok(\"Sean\".to_string()),\n        users.filter(name.eq(\"Sean\")).select(name).first(connection)\n    );\n    assert_eq!(\n        Ok(\"Tess\".to_string()),\n        users.filter(name.eq(\"Tess\")).select(name).first(connection)\n    );\n    assert_eq!(\n        Err(NotFound),\n        users\n            .filter(name.eq(\"Jim\"))\n            .select(name)\n            .first::<String>(connection)\n    );\n}\n\n#[test]\nfn select_by_then_filter() {\n    use crate::schema::users::dsl::*;\n\n    let connection = &mut connection_with_sean_and_tess_in_users_table();\n\n    let source = users.select(UserName::as_select());\n    assert_eq!(\n        Ok(UserName::new(\"Sean\")),\n        source.filter(name.eq(\"Sean\")).first(connection)\n    );\n    assert_eq!(\n        Ok(UserName::new(\"Tess\")),\n        source.filter(name.eq(\"Tess\")).first(connection)\n    );\n    assert_eq!(\n        Err(NotFound),\n        source.filter(name.eq(\"Jim\")).first::<UserName>(connection)\n    );\n}\n\n#[test]\nfn filter_then_select_by() {\n    use crate::schema::users::dsl::*;\n\n    let connection = &mut connection_with_sean_and_tess_in_users_table();\n\n    assert_eq!(\n        Ok(UserName::new(\"Sean\")),\n        users\n            .filter(name.eq(\"Sean\"))\n            .select(UserName::as_select())\n            .first(connection)\n    );\n    assert_eq!(\n        Ok(UserName::new(\"Tess\")),\n        users\n            .filter(name.eq(\"Tess\"))\n            .select(UserName::as_select())\n            .first(connection)\n    );\n    assert_eq!(\n        Err(NotFound),\n        users\n            .filter(name.eq(\"Jim\"))\n            .select(UserName::as_select())\n            .first::<UserName>(connection)\n    );\n}\n\n#[test]\nfn filter_on_multiple_columns() {\n    use crate::schema::users::dsl::*;\n\n    let connection = &mut connection();\n    let data: &[_] = &[\n        NewUser::new(\"Sean\", Some(\"black\")),\n        NewUser::new(\"Sean\", Some(\"brown\")),\n        NewUser::new(\"Sean\", None),\n        NewUser::new(\"Tess\", Some(\"black\")),\n        NewUser::new(\"Tess\", Some(\"brown\")),\n    ];\n    insert_into(users).values(data).execute(connection).unwrap();\n    let data = users.order(id).load::<User>(connection).unwrap();\n    let black_haired_sean = data[0].clone();\n    let brown_haired_sean = data[1].clone();\n    let black_haired_tess = data[3].clone();\n    let brown_haired_tess = data[4].clone();\n\n    let source = users.filter(name.eq(\"Sean\").and(hair_color.eq(\"black\")));\n    assert_eq!(vec![black_haired_sean], source.load(connection).unwrap());\n\n    let source = users.filter(name.eq(\"Sean\").and(hair_color.eq(\"brown\")));\n    assert_eq!(vec![brown_haired_sean], source.load(connection).unwrap());\n\n    let source = users.filter(name.eq(\"Tess\").and(hair_color.eq(\"black\")));\n    assert_eq!(vec![black_haired_tess], source.load(connection).unwrap());\n\n    let source = users.filter(name.eq(\"Tess\").and(hair_color.eq(\"brown\")));\n    assert_eq!(vec![brown_haired_tess], source.load(connection).unwrap());\n}\n\n#[test]\nfn filter_called_twice_means_same_thing_as_and() {\n    use crate::schema::users::dsl::*;\n\n    let connection = &mut connection();\n    let data: &[_] = &[\n        NewUser::new(\"Sean\", Some(\"black\")),\n        NewUser::new(\"Sean\", Some(\"brown\")),\n        NewUser::new(\"Sean\", None),\n        NewUser::new(\"Tess\", Some(\"black\")),\n        NewUser::new(\"Tess\", Some(\"brown\")),\n    ];\n    insert_into(users).values(data).execute(connection).unwrap();\n    let data = users.order(id).load::<User>(connection).unwrap();\n    let black_haired_sean = data[0].clone();\n    let brown_haired_sean = data[1].clone();\n    let black_haired_tess = data[3].clone();\n    let brown_haired_tess = data[4].clone();\n\n    let source = users.filter(name.eq(\"Sean\")).filter(hair_color.eq(\"black\"));\n    assert_eq!(vec![black_haired_sean], source.load(connection).unwrap());\n\n    let source = users.filter(name.eq(\"Sean\")).filter(hair_color.eq(\"brown\"));\n    assert_eq!(vec![brown_haired_sean], source.load(connection).unwrap());\n\n    let source = users.filter(name.eq(\"Tess\")).filter(hair_color.eq(\"black\"));\n    assert_eq!(vec![black_haired_tess], source.load(connection).unwrap());\n\n    let source = users.filter(name.eq(\"Tess\")).filter(hair_color.eq(\"brown\"));\n    assert_eq!(vec![brown_haired_tess], source.load(connection).unwrap());\n}\n\ntable! {\n    points (x) {\n        x -> Integer,\n        y -> Integer,\n    }\n}\n\n#[test]\nfn filter_on_column_equality() {\n    use self::points::dsl::*;\n\n    let connection = &mut connection();\n    diesel::sql_query(\"INSERT INTO points (x, y) VALUES (1, 1), (1, 2), (2, 2)\")\n        .execute(connection)\n        .unwrap();\n\n    let expected_data = vec![(1, 1), (2, 2)];\n    let query = points.order(x).filter(x.eq(y));\n    let data: Vec<_> = query.load(connection).unwrap();\n    assert_sets_eq!(expected_data, data);\n}\n\n#[test]\nfn filter_with_or() {\n    use crate::schema::users::dsl::*;\n\n    let connection = &mut connection_with_sean_and_tess_in_users_table();\n    insert_into(users)\n        .values(&NewUser::new(\"Jim\", None))\n        .execute(connection)\n        .unwrap();\n\n    let expected_users = vec![User::new(1, \"Sean\"), User::new(2, \"Tess\")];\n    let data: Vec<_> = users\n        .order(id)\n        .filter(name.eq(\"Sean\").or(name.eq(\"Tess\")))\n        .load(connection)\n        .unwrap();\n\n    assert_sets_eq!(expected_users, data);\n}\n\n#[test]\nfn or_doesnt_mess_with_precedence_of_previous_statements() {\n    use crate::schema::users::dsl::*;\n\n    let connection = &mut connection_with_sean_and_tess_in_users_table();\n    let f = false.into_sql::<sql_types::Bool>();\n    let count = users\n        .filter(f)\n        .filter(f.or(true.into_sql::<sql_types::Bool>()))\n        .count()\n        .first(connection);\n\n    assert_eq!(Ok(0), count);\n\n    let count = users\n        .filter(f.or(f).and(f.or(true.into_sql::<sql_types::Bool>())))\n        .count()\n        .first(connection);\n\n    assert_eq!(Ok(0), count);\n}\n\n#[test]\nfn not_does_not_affect_expressions_other_than_those_passed_to_it() {\n    use crate::schema::users::dsl::*;\n    use diesel::dsl::not;\n\n    let connection = &mut connection_with_sean_and_tess_in_users_table();\n    let count = users\n        .filter(not(name.eq(\"Tess\")))\n        .filter(id.eq(1))\n        .count()\n        .get_result(connection);\n\n    assert_eq!(Ok(1), count);\n}\n\n#[test]\nfn not_affects_arguments_passed_when_they_contain_higher_operator_precedence() {\n    use crate::schema::users::dsl::*;\n    use diesel::dsl::not;\n\n    let connection = &mut connection_with_sean_and_tess_in_users_table();\n    let count = users\n        .filter(not(name.eq(\"Tess\").and(id.eq(1))))\n        .count()\n        .get_result(connection);\n\n    assert_eq!(Ok(2), count);\n}\n\nuse diesel::sql_types::VarChar;\ndefine_sql_function!(fn lower(x: VarChar) -> VarChar);\n\n#[test]\nfn filter_by_boxed_predicate() {\n    fn by_name(\n        name: &str,\n    ) -> Box<dyn BoxableExpression<users::table, TestBackend, SqlType = sql_types::Bool>> {\n        Box::new(lower(users::name).eq(name.to_string()))\n    }\n\n    let connection = &mut connection_with_sean_and_tess_in_users_table();\n    let sean = User::new(1, \"Sean\");\n    let tess = User::new(2, \"Tess\");\n    let queried_sean = users::table.filter(by_name(\"sean\")).first(connection);\n    let queried_tess = users::table.filter(by_name(\"tess\")).first(connection);\n\n    assert_eq!(Ok(sean), queried_sean);\n    assert_eq!(Ok(tess), queried_tess);\n}\n\n#[test]\nfn filter_like_nullable_column() {\n    use crate::schema::users::dsl::*;\n\n    let conn = &mut connection_with_gilbert_and_jonathan_in_users_table();\n    let jonathan = find_user_by_name(\"Jonathan\", conn);\n\n    let data = users.filter(hair_color.like(\"%blue%\")).load(conn);\n\n    let expected = Ok(vec![jonathan]);\n    assert_eq!(expected, data);\n}\n\n#[test]\nfn filter_subselect_referencing_outer_table() {\n    use diesel::dsl::exists;\n\n    let conn = &mut connection_with_sean_and_tess_in_users_table();\n    let sean = find_user_by_name(\"Sean\", conn);\n\n    insert_into(posts::table)\n        .values(&vec![\n            sean.new_post(\"Hello\", None),\n            sean.new_post(\"Hello 2\", None),\n        ])\n        .execute(conn)\n        .unwrap();\n\n    let expected = Ok(vec![sean]);\n    let users_with_published_posts = users::table\n        .filter(exists(posts::table.filter(posts::user_id.eq(users::id))))\n        .load(conn);\n    assert_eq!(expected, users_with_published_posts);\n\n    let users_with_published_posts = users::table\n        .filter(\n            users::id.eq_any(\n                posts::table\n                    .select(posts::user_id)\n                    .filter(posts::user_id.eq(users::id)),\n            ),\n        )\n        .load(conn);\n    assert_eq!(expected, users_with_published_posts);\n}\n\n#[test]\nfn filter_subselect_with_boxed_query() {\n    use crate::schema::users::dsl::*;\n\n    let conn = &mut connection_with_sean_and_tess_in_users_table();\n    let sean = find_user_by_name(\"Sean\", conn);\n\n    let subselect = users.filter(name.eq(\"Sean\")).select(id).into_boxed();\n\n    let expected = Ok(vec![sean]);\n    let data = users.filter(id.eq_any(subselect)).load(conn);\n    assert_eq!(expected, data);\n}\n\n#[test]\n// FIXME: this test shouldn't need to modify schema each run\n#[cfg(not(feature = \"mysql\"))]\n// https://github.com/rust-lang/rust/issues/124396\n#[allow(unknown_lints, non_local_definitions)]\nfn filter_subselect_with_nullable_column() {\n    use crate::schema_dsl::*;\n    table! {\n        heroes {\n            id -> Integer,\n            name -> Text,\n            home_world -> Nullable<Integer>,\n        }\n    }\n    table! {\n        home_worlds {\n            id -> Integer,\n            name -> Text,\n        }\n    }\n\n    allow_tables_to_appear_in_same_query!(heroes, home_worlds);\n\n    #[derive(Debug, Queryable, PartialEq)]\n    struct Hero {\n        id: i32,\n        name: String,\n        home_world: Option<i32>,\n    }\n    let connection = &mut connection();\n\n    create_table(\n        \"home_worlds\",\n        (\n            integer(\"id\").primary_key().auto_increment(),\n            string(\"name\").not_null(),\n        ),\n    )\n    .execute(connection)\n    .unwrap();\n\n    create_table(\n        \"heroes\",\n        (\n            integer(\"id\").primary_key().auto_increment(),\n            string(\"name\").not_null(),\n            integer(\"home_world\"),\n        ),\n    )\n    .execute(connection)\n    .unwrap();\n\n    ::diesel::insert_into(home_worlds::table)\n        .values(home_worlds::name.eq(\"Tatooine\"))\n        .execute(connection)\n        .unwrap();\n    ::diesel::insert_into(heroes::table)\n        .values((\n            heroes::name.eq(\"Luke Skywalker\"),\n            heroes::home_world.eq(Some(1)),\n        ))\n        .execute(connection)\n        .unwrap();\n    ::diesel::insert_into(heroes::table)\n        .values((\n            heroes::name.eq(\"R2D2\"),\n            heroes::home_world.eq::<Option<i32>>(None),\n        ))\n        .execute(connection)\n        .unwrap();\n\n    let expected = vec![Hero {\n        id: 1,\n        name: String::from(\"Luke Skywalker\"),\n        home_world: Some(1),\n    }];\n\n    let query = heroes::table\n        .filter(heroes::home_world.eq_any(home_worlds::table.select(home_worlds::id).nullable()))\n        .load::<Hero>(connection)\n        .unwrap();\n\n    assert_eq!(query, expected);\n\n    let query = heroes::table\n        .filter(\n            heroes::home_world.eq_any(\n                home_worlds::table\n                    .select(home_worlds::id)\n                    .into_boxed()\n                    .nullable(),\n            ),\n        )\n        .load::<Hero>(connection)\n        .unwrap();\n\n    assert_eq!(query, expected);\n\n    let query = heroes::table\n        .filter(\n            heroes::home_world.eq_any(\n                home_worlds::table\n                    .select(home_worlds::id)\n                    .nullable()\n                    .into_boxed(),\n            ),\n        )\n        .load::<Hero>(connection)\n        .unwrap();\n\n    assert_eq!(query, expected);\n}\n\n#[test]\n#[cfg(feature = \"postgres\")]\nfn filter_subselect_with_pg_any() {\n    let conn = &mut connection_with_sean_and_tess_in_users_table();\n    let sean = find_user_by_name(\"Sean\", conn);\n\n    insert_into(posts::table)\n        .values(&vec![\n            sean.new_post(\"Hello\", None),\n            sean.new_post(\"Hello 2\", None),\n        ])\n        .execute(conn)\n        .unwrap();\n\n    let users_with_published_posts = users::table\n        .filter(\n            users::id.eq_any(\n                posts::table\n                    .select(posts::user_id)\n                    .filter(posts::user_id.eq(users::id)),\n            ),\n        )\n        .load(conn);\n    assert_eq!(Ok(vec![sean]), users_with_published_posts);\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "259d86bd05727668787b5eb5985dce63d6d06b72",
    "func": "use sea_orm::entity::prelude::*;\n\n#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq)]\n#[sea_orm(table_name = \"bills\")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    pub user_id: Option<i32> ,\n}\n\n#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]\npub enum Relation {\n    #[sea_orm(\n        belongs_to = \"super::users::Entity\",\n        from = \"Column::UserId\",\n        to = \"super::users::Column::Id\",\n        on_update = \"NoAction\",\n        on_delete = \"NoAction\",\n    )]\n    Users,\n    #[sea_orm(has_many = \"super::users_saved_bills::Entity\")]\n    UsersSavedBills,\n    #[sea_orm(has_many = \"super::users_votes::Entity\")]\n    UsersVotes,\n}\n\nimpl Related<super::users::Entity> for Entity {\n    fn to() -> RelationDef {\n        Relation::Users.def()\n    }\n}\n\nimpl Related<super::users_saved_bills::Entity> for Entity {\n    fn to() -> RelationDef {\n        Relation::UsersSavedBills.def()\n    }\n}\n\nimpl Related<super::users_votes::Entity> for Entity {\n    fn to() -> RelationDef {\n        Relation::UsersVotes.def()\n    }\n}\n\nimpl ActiveModelBehavior for ActiveModel {}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "043cf78add9ce0030308591f78e6e6de522b629a",
    "func": "use itertools::Itertools;\n\n#[allow(unused_imports)] // `Cell` is used in the doc comment but not the code\nuse crate::widgets::table::Cell;\nuse crate::{\n    buffer::Buffer,\n    layout::{Constraint, Flex, Layout, Rect},\n    style::{Style, Styled},\n    text::Text,\n    widgets::{\n        block::BlockExt,\n        table::{HighlightSpacing, Row, TableState},\n        Block, StatefulWidget, StatefulWidgetRef, Widget, WidgetRef,\n    },\n};\n\n/// A widget to display data in formatted columns.\n///\n/// A `Table` is a collection of [`Row`]s, each composed of [`Cell`]s:\n///\n/// You can construct a [`Table`] using either [`Table::new`] or [`Table::default`] and then chain\n/// builder style methods to set the desired properties.\n///\n/// Table cells can be aligned, for more details see [`Cell`].\n///\n/// Make sure to call the [`Table::widths`] method, otherwise the columns will all have a width of 0\n/// and thus not be visible.\n///\n/// [`Table`] implements [`Widget`] and so it can be drawn using [`Frame::render_widget`].\n///\n/// [`Table`] is also a [`StatefulWidget`], which means you can use it with [`TableState`] to allow\n/// the user to scroll through the rows and select one of them. When rendering a [`Table`] with a\n/// [`TableState`], the selected row, column and cell will be highlighted. If the selected row is\n/// not visible (based on the offset), the table will be scrolled to make the selected row visible.\n///\n/// Note: if the `widths` field is empty, the table will be rendered with equal widths.\n/// Note: Highlight styles are applied in the following order: Row, Column, Cell.\n///\n/// See the table example and the recipe and traceroute tabs in the demo2 example in the [Examples]\n/// directory for a more in depth example of the various configuration options and for how to handle\n/// state.\n///\n/// [Examples]: https://github.com/ratatui/ratatui/blob/master/examples/README.md\n///\n/// # Constructor methods\n///\n/// - [`Table::new`] creates a new [`Table`] with the given rows.\n/// - [`Table::default`] creates an empty [`Table`]. You can then add rows using [`Table::rows`].\n///\n/// # Setter methods\n///\n/// These methods are fluent setters. They return a new `Table` with the specified property set.\n///\n/// - [`Table::rows`] sets the rows of the [`Table`].\n/// - [`Table::header`] sets the header row of the [`Table`].\n/// - [`Table::footer`] sets the footer row of the [`Table`].\n/// - [`Table::widths`] sets the width constraints of each column.\n/// - [`Table::column_spacing`] sets the spacing between each column.\n/// - [`Table::block`] wraps the table in a [`Block`] widget.\n/// - [`Table::style`] sets the base style of the widget.\n/// - [`Table::row_highlight_style`] sets the style of the selected row.\n/// - [`Table::column_highlight_style`] sets the style of the selected column.\n/// - [`Table::cell_highlight_style`] sets the style of the selected cell.\n/// - [`Table::highlight_symbol`] sets the symbol to be displayed in front of the selected row.\n/// - [`Table::highlight_spacing`] sets when to show the highlight spacing.\n///\n/// # Example\n///\n/// ```rust\n/// use ratatui::{\n///     layout::Constraint,\n///     style::{Style, Stylize},\n///     widgets::{Block, Row, Table},\n/// };\n///\n/// let rows = [Row::new(vec![\"Cell1\", \"Cell2\", \"Cell3\"])];\n/// // Columns widths are constrained in the same way as Layout...\n/// let widths = [\n///     Constraint::Length(5),\n///     Constraint::Length(5),\n///     Constraint::Length(10),\n/// ];\n/// let table = Table::new(rows, widths)\n///     // ...and they can be separated by a fixed spacing.\n///     .column_spacing(1)\n///     // You can set the style of the entire Table.\n///     .style(Style::new().blue())\n///     // It has an optional header, which is simply a Row always visible at the top.\n///     .header(\n///         Row::new(vec![\"Col1\", \"Col2\", \"Col3\"])\n///             .style(Style::new().bold())\n///             // To add space between the header and the rest of the rows, specify the margin\n///             .bottom_margin(1),\n///     )\n///     // It has an optional footer, which is simply a Row always visible at the bottom.\n///     .footer(Row::new(vec![\"Updated on Dec 28\"]))\n///     // As any other widget, a Table can be wrapped in a Block.\n///     .block(Block::new().title(\"Table\"))\n///     // The selected row, column, cell and its content can also be styled.\n///     .row_highlight_style(Style::new().reversed())\n///     .column_highlight_style(Style::new().red())\n///     .cell_highlight_style(Style::new().blue())\n///     // ...and potentially show a symbol in front of the selection.\n///     .highlight_symbol(\">>\");\n/// ```\n///\n/// Rows can be created from an iterator of [`Cell`]s. Each row can have an associated height,\n/// bottom margin, and style. See [`Row`] for more details.\n///\n/// ```rust\n/// use ratatui::{\n///     style::{Style, Stylize},\n///     text::{Line, Span},\n///     widgets::{Cell, Row, Table},\n/// };\n///\n/// // a Row can be created from simple strings.\n/// let row = Row::new(vec![\"Row11\", \"Row12\", \"Row13\"]);\n///\n/// // You can style the entire row.\n/// let row = Row::new(vec![\"Row21\", \"Row22\", \"Row23\"]).style(Style::new().red());\n///\n/// // If you need more control over the styling, create Cells directly\n/// let row = Row::new(vec![\n///     Cell::from(\"Row31\"),\n///     Cell::from(\"Row32\").style(Style::new().yellow()),\n///     Cell::from(Line::from(vec![Span::raw(\"Row\"), Span::from(\"33\").green()])),\n/// ]);\n///\n/// // If a Row need to display some content over multiple lines, specify the height.\n/// let row = Row::new(vec![\n///     Cell::from(\"Row\\n41\"),\n///     Cell::from(\"Row\\n42\"),\n///     Cell::from(\"Row\\n43\"),\n/// ])\n/// .height(2);\n/// ```\n///\n/// Cells can be created from anything that can be converted to [`Text`]. See [`Cell`] for more\n/// details.\n///\n/// ```rust\n/// use ratatui::{\n///     style::{Style, Stylize},\n///     text::{Line, Span, Text},\n///     widgets::Cell,\n/// };\n///\n/// Cell::from(\"simple string\");\n/// Cell::from(\"simple styled span\".red());\n/// Cell::from(Span::raw(\"raw span\"));\n/// Cell::from(Span::styled(\"styled span\", Style::new().red()));\n/// Cell::from(Line::from(vec![\n///     Span::raw(\"a vec of \"),\n///     Span::from(\"spans\").bold(),\n/// ]));\n/// Cell::from(Text::from(\"text\"));\n/// ```\n///\n/// Just as rows can be collected from iterators of `Cell`s, tables can be collected from iterators\n/// of `Row`s.  This will create a table with column widths evenly dividing the space available.\n/// These default columns widths can be overridden using the `Table::widths` method.\n///\n/// ```rust\n/// use ratatui::{\n///     layout::Constraint,\n///     widgets::{Row, Table},\n/// };\n///\n/// let text = \"Mary had a\\nlittle lamb.\";\n///\n/// let table = text\n///     .split(\"\\n\")\n///     .map(|line: &str| -> Row { line.split_ascii_whitespace().collect() })\n///     .collect::<Table>()\n///     .widths([Constraint::Length(10); 3]);\n/// ```\n///\n/// `Table` also implements the [`Styled`] trait, which means you can use style shorthands from\n/// the [`Stylize`] trait to set the style of the widget more concisely.\n///\n/// ```rust\n/// use ratatui::{\n///     layout::Constraint,\n///     style::Stylize,\n///     widgets::{Row, Table},\n/// };\n///\n/// let rows = [Row::new(vec![\"Cell1\", \"Cell2\", \"Cell3\"])];\n/// let widths = [\n///     Constraint::Length(5),\n///     Constraint::Length(5),\n///     Constraint::Length(10),\n/// ];\n/// let table = Table::new(rows, widths).red().italic();\n/// ```\n///\n/// # Stateful example\n///\n/// `Table` is a [`StatefulWidget`], which means you can use it with [`TableState`] to allow the\n/// user to scroll through the rows and select one of them.\n///\n/// ```rust\n/// use ratatui::{\n///     layout::{Constraint, Rect},\n///     style::{Style, Stylize},\n///     widgets::{Block, Row, Table, TableState},\n///     Frame,\n/// };\n///\n/// # fn ui(frame: &mut Frame) {\n/// # let area = Rect::default();\n/// // Note: TableState should be stored in your application state (not constructed in your render\n/// // method) so that the selected row is preserved across renders\n/// let mut table_state = TableState::default();\n/// let rows = [\n///     Row::new(vec![\"Row11\", \"Row12\", \"Row13\"]),\n///     Row::new(vec![\"Row21\", \"Row22\", \"Row23\"]),\n///     Row::new(vec![\"Row31\", \"Row32\", \"Row33\"]),\n/// ];\n/// let widths = [\n///     Constraint::Length(5),\n///     Constraint::Length(5),\n///     Constraint::Length(10),\n/// ];\n/// let table = Table::new(rows, widths)\n///     .block(Block::new().title(\"Table\"))\n///     .row_highlight_style(Style::new().reversed())\n///     .highlight_symbol(\">>\");\n///\n/// frame.render_stateful_widget(table, area, &mut table_state);\n/// # }\n/// ```\n///\n/// [`Frame::render_widget`]: crate::Frame::render_widget\n/// [`Stylize`]: crate::style::Stylize\n#[derive(Debug, Clone, Eq, PartialEq, Hash)]\npub struct Table<'a> {\n    /// Data to display in each row\n    rows: Vec<Row<'a>>,\n\n    /// Optional header\n    header: Option<Row<'a>>,\n\n    /// Optional footer\n    footer: Option<Row<'a>>,\n\n    /// Width constraints for each column\n    widths: Vec<Constraint>,\n\n    /// Space between each column\n    column_spacing: u16,\n\n    /// A block to wrap the widget in\n    block: Option<Block<'a>>,\n\n    /// Base style for the widget\n    style: Style,\n\n    /// Style used to render the selected row\n    row_highlight_style: Style,\n\n    /// Style used to render the selected column\n    column_highlight_style: Style,\n\n    /// Style used to render the selected cell\n    cell_highlight_style: Style,\n\n    /// Symbol in front of the selected row\n    highlight_symbol: Text<'a>,\n\n    /// Decides when to allocate spacing for the row selection\n    highlight_spacing: HighlightSpacing,\n\n    /// Controls how to distribute extra space among the columns\n    flex: Flex,\n}\n\nimpl<'a> Default for Table<'a> {\n    fn default() -> Self {\n        Self {\n            rows: Vec::new(),\n            header: None,\n            footer: None,\n            widths: Vec::new(),\n            column_spacing: 1,\n            block: None,\n            style: Style::new(),\n            row_highlight_style: Style::new(),\n            column_highlight_style: Style::new(),\n            cell_highlight_style: Style::new(),\n            highlight_symbol: Text::default(),\n            highlight_spacing: HighlightSpacing::default(),\n            flex: Flex::Start,\n        }\n    }\n}\n\nimpl<'a> Table<'a> {\n    /// Creates a new [`Table`] widget with the given rows.\n    ///\n    /// The `rows` parameter accepts any value that can be converted into an iterator of [`Row`]s.\n    /// This includes arrays, slices, and [`Vec`]s.\n    ///\n    /// The `widths` parameter accepts any type that implements `IntoIterator<Item =\n    /// Into<Constraint>>`. This includes arrays, slices, vectors, iterators. `Into<Constraint>` is\n    /// implemented on u16, so you can pass an array, vec, etc. of u16 to this function to create a\n    /// table with fixed width columns.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use ratatui::{\n    ///     layout::Constraint,\n    ///     widgets::{Row, Table},\n    /// };\n    ///\n    /// let rows = [\n    ///     Row::new(vec![\"Cell1\", \"Cell2\"]),\n    ///     Row::new(vec![\"Cell3\", \"Cell4\"]),\n    /// ];\n    /// let widths = [Constraint::Length(5), Constraint::Length(5)];\n    /// let table = Table::new(rows, widths);\n    /// ```\n    pub fn new<R, C>(rows: R, widths: C) -> Self\n    where\n        R: IntoIterator,\n        R::Item: Into<Row<'a>>,\n        C: IntoIterator,\n        C::Item: Into<Constraint>,\n    {\n        let widths = widths.into_iter().map(Into::into).collect_vec();\n        ensure_percentages_less_than_100(&widths);\n\n        let rows = rows.into_iter().map(Into::into).collect();\n        Self {\n            rows,\n            widths,\n            ..Default::default()\n        }\n    }\n\n    /// Set the rows\n    ///\n    /// The `rows` parameter accepts any value that can be converted into an iterator of [`Row`]s.\n    /// This includes arrays, slices, and [`Vec`]s.\n    ///\n    /// # Warning\n    ///\n    /// This method does not currently set the column widths. You will need to set them manually by\n    /// calling [`Table::widths`].\n    ///\n    /// This is a fluent setter method which must be chained or used as it consumes self\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use ratatui::widgets::{Row, Table};\n    ///\n    /// let rows = [\n    ///     Row::new(vec![\"Cell1\", \"Cell2\"]),\n    ///     Row::new(vec![\"Cell3\", \"Cell4\"]),\n    /// ];\n    /// let table = Table::default().rows(rows);\n    /// ```\n    #[must_use = \"method moves the value of self and returns the modified value\"]\n    pub fn rows<T>(mut self, rows: T) -> Self\n    where\n        T: IntoIterator<Item = Row<'a>>,\n    {\n        self.rows = rows.into_iter().collect();\n        self\n    }\n\n    /// Sets the header row\n    ///\n    /// The `header` parameter is a [`Row`] which will be displayed at the top of the [`Table`]\n    ///\n    /// This is a fluent setter method which must be chained or used as it consumes self\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use ratatui::widgets::{Cell, Row, Table};\n    ///\n    /// let header = Row::new(vec![\n    ///     Cell::from(\"Header Cell 1\"),\n    ///     Cell::from(\"Header Cell 2\"),\n    /// ]);\n    /// let table = Table::default().header(header);\n    /// ```\n    #[must_use = \"method moves the value of self and returns the modified value\"]\n    pub fn header(mut self, header: Row<'a>) -> Self {\n        self.header = Some(header);\n        self\n    }\n\n    /// Sets the footer row\n    ///\n    /// The `footer` parameter is a [`Row`] which will be displayed at the bottom of the [`Table`]\n    ///\n    /// This is a fluent setter method which must be chained or used as it consumes self\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use ratatui::widgets::{Cell, Row, Table};\n    ///\n    /// let footer = Row::new(vec![\n    ///     Cell::from(\"Footer Cell 1\"),\n    ///     Cell::from(\"Footer Cell 2\"),\n    /// ]);\n    /// let table = Table::default().footer(footer);\n    /// ```\n    #[must_use = \"method moves the value of self and returns the modified value\"]\n    pub fn footer(mut self, footer: Row<'a>) -> Self {\n        self.footer = Some(footer);\n        self\n    }\n\n    /// Set the widths of the columns.\n    ///\n    /// The `widths` parameter accepts any type that implements `IntoIterator<Item =\n    /// Into<Constraint>>`. This includes arrays, slices, vectors, iterators. `Into<Constraint>` is\n    /// implemented on u16, so you can pass an array, vec, etc. of u16 to this function to create a\n    /// table with fixed width columns.\n    ///\n    /// If the widths are empty, the table will be rendered with equal widths.\n    ///\n    /// This is a fluent setter method which must be chained or used as it consumes self\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use ratatui::{\n    ///     layout::Constraint,\n    ///     widgets::{Cell, Row, Table},\n    /// };\n    ///\n    /// let table = Table::default().widths([Constraint::Length(5), Constraint::Length(5)]);\n    /// let table = Table::default().widths(vec![Constraint::Length(5); 2]);\n    ///\n    /// // widths could also be computed at runtime\n    /// let widths = [10, 10, 20].into_iter().map(|c| Constraint::Length(c));\n    /// let table = Table::default().widths(widths);\n    /// ```\n    #[must_use = \"method moves the value of self and returns the modified value\"]\n    pub fn widths<I>(mut self, widths: I) -> Self\n    where\n        I: IntoIterator,\n        I::Item: Into<Constraint>,\n    {\n        let widths = widths.into_iter().map(Into::into).collect_vec();\n        ensure_percentages_less_than_100(&widths);\n        self.widths = widths;\n        self\n    }\n\n    /// Set the spacing between columns\n    ///\n    /// This is a fluent setter method which must be chained or used as it consumes self\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use ratatui::{\n    ///     layout::Constraint,\n    ///     widgets::{Row, Table},\n    /// };\n    ///\n    /// let rows = [Row::new(vec![\"Cell1\", \"Cell2\"])];\n    /// let widths = [Constraint::Length(5), Constraint::Length(5)];\n    /// let table = Table::new(rows, widths).column_spacing(1);\n    /// ```\n    #[must_use = \"method moves the value of self and returns the modified value\"]\n    pub const fn column_spacing(mut self, spacing: u16) -> Self {\n        self.column_spacing = spacing;\n        self\n    }\n\n    /// Wraps the table with a custom [`Block`] widget.\n    ///\n    /// The `block` parameter is of type [`Block`]. This holds the specified block to be\n    /// created around the [`Table`]\n    ///\n    /// This is a fluent setter method which must be chained or used as it consumes self\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use ratatui::{\n    ///     layout::Constraint,\n    ///     widgets::{Block, Cell, Row, Table},\n    /// };\n    ///\n    /// let rows = [Row::new(vec![\"Cell1\", \"Cell2\"])];\n    /// let widths = [Constraint::Length(5), Constraint::Length(5)];\n    /// let block = Block::bordered().title(\"Table\");\n    /// let table = Table::new(rows, widths).block(block);\n    /// ```\n    #[must_use = \"method moves the value of self and returns the modified value\"]\n    pub fn block(mut self, block: Block<'a>) -> Self {\n        self.block = Some(block);\n        self\n    }\n\n    /// Sets the base style of the widget\n    ///\n    /// `style` accepts any type that is convertible to [`Style`] (e.g. [`Style`], [`Color`], or\n    /// your own type that implements [`Into<Style>`]).\n    ///\n    /// All text rendered by the widget will use this style, unless overridden by [`Block::style`],\n    /// [`Row::style`], [`Cell::style`], or the styles of cell's content.\n    ///\n    /// This is a fluent setter method which must be chained or used as it consumes self\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use ratatui::{\n    ///     layout::Constraint,\n    ///     style::{Style, Stylize},\n    ///     widgets::{Row, Table},\n    /// };\n    ///\n    /// # let rows = [Row::new(vec![\"Cell1\", \"Cell2\"])];\n    /// # let widths = [Constraint::Length(5), Constraint::Length(5)];\n    /// let table = Table::new(rows, widths).style(Style::new().red().italic());\n    /// ```\n    ///\n    /// `Table` also implements the [`Styled`] trait, which means you can use style shorthands from\n    /// the [`Stylize`] trait to set the style of the widget more concisely.\n    ///\n    /// ```rust\n    /// use ratatui::{\n    ///     layout::Constraint,\n    ///     style::Stylize,\n    ///     widgets::{Cell, Row, Table},\n    /// };\n    ///\n    /// # let rows = [Row::new(vec![\"Cell1\", \"Cell2\"])];\n    /// # let widths = vec![Constraint::Length(5), Constraint::Length(5)];\n    /// let table = Table::new(rows, widths).red().italic();\n    /// ```\n    ///\n    /// [`Color`]: crate::style::Color\n    /// [`Stylize`]: crate::style::Stylize\n    #[must_use = \"method moves the value of self and returns the modified value\"]\n    pub fn style<S: Into<Style>>(mut self, style: S) -> Self {\n        self.style = style.into();\n        self\n    }\n\n    /// Set the style of the selected row\n    ///\n    /// `style` accepts any type that is convertible to [`Style`] (e.g. [`Style`], [`Color`], or\n    /// your own type that implements [`Into<Style>`]).\n    ///\n    /// This style will be applied to the entire row, including the selection symbol if it is\n    /// displayed, and will override any style set on the row or on the individual cells.\n    ///\n    /// This is a fluent setter method which must be chained or used as it consumes self\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use ratatui::{\n    ///     layout::Constraint,\n    ///     style::{Style, Stylize},\n    ///     widgets::{Cell, Row, Table},\n    /// };\n    ///\n    /// let rows = [Row::new(vec![\"Cell1\", \"Cell2\"])];\n    /// let widths = [Constraint::Length(5), Constraint::Length(5)];\n    /// let table = Table::new(rows, widths).highlight_style(Style::new().red().italic());\n    /// ```\n    ///\n    /// [`Color`]: crate::style::Color\n    #[must_use = \"method moves the value of self and returns the modified value\"]\n    #[deprecated(note = \"use `Table::row_highlight_style` instead\")]\n    pub fn highlight_style<S: Into<Style>>(self, highlight_style: S) -> Self {\n        self.row_highlight_style(highlight_style)\n    }\n\n    /// Set the style of the selected row\n    ///\n    /// `style` accepts any type that is convertible to [`Style`] (e.g. [`Style`], [`Color`], or\n    /// your own type that implements [`Into<Style>`]).\n    ///\n    /// This style will be applied to the entire row, including the selection symbol if it is\n    /// displayed, and will override any style set on the row or on the individual cells.\n    ///\n    /// This is a fluent setter method which must be chained or used as it consumes self\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use ratatui::{layout::Constraint, style::{Style, Stylize}, widgets::{Row, Table}};\n    /// # let rows = [Row::new(vec![\"Cell1\", \"Cell2\"])];\n    /// # let widths = [Constraint::Length(5), Constraint::Length(5)];\n    /// let table = Table::new(rows, widths).row_highlight_style(Style::new().red().italic());\n    /// ```\n    /// [`Color`]: crate::style::Color\n    #[must_use = \"method moves the value of self and returns the modified value\"]\n    pub fn row_highlight_style<S: Into<Style>>(mut self, highlight_style: S) -> Self {\n        self.row_highlight_style = highlight_style.into();\n        self\n    }\n\n    /// Set the style of the selected column\n    ///\n    /// `style` accepts any type that is convertible to [`Style`] (e.g. [`Style`], [`Color`], or\n    /// your own type that implements [`Into<Style>`]).\n    ///\n    /// This style will be applied to the entire column, and will override any style set on the\n    /// row or on the individual cells.\n    ///\n    /// This is a fluent setter method which must be chained or used as it consumes self\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use ratatui::{layout::Constraint, style::{Style, Stylize}, widgets::{Row, Table}};\n    /// # let rows = [Row::new(vec![\"Cell1\", \"Cell2\"])];\n    /// # let widths = [Constraint::Length(5), Constraint::Length(5)];\n    /// let table = Table::new(rows, widths).column_highlight_style(Style::new().red().italic());\n    /// ```\n    /// [`Color`]: crate::style::Color\n    #[must_use = \"method moves the value of self and returns the modified value\"]\n    pub fn column_highlight_style<S: Into<Style>>(mut self, highlight_style: S) -> Self {\n        self.column_highlight_style = highlight_style.into();\n        self\n    }\n\n    /// Set the style of the selected cell\n    ///\n    /// `style` accepts any type that is convertible to [`Style`] (e.g. [`Style`], [`Color`], or\n    /// your own type that implements [`Into<Style>`]).\n    ///\n    /// This style will be applied to the selected cell, and will override any style set on the\n    /// row or on the individual cells.\n    ///\n    /// This is a fluent setter method which must be chained or used as it consumes self\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// # use ratatui::{layout::Constraint, style::{Style, Stylize}, widgets::{Row, Table}};\n    /// # let rows = [Row::new(vec![\"Cell1\", \"Cell2\"])];\n    /// # let widths = [Constraint::Length(5), Constraint::Length(5)];\n    /// let table = Table::new(rows, widths).cell_highlight_style(Style::new().red().italic());\n    /// ```\n    /// [`Color`]: crate::style::Color\n    #[must_use = \"method moves the value of self and returns the modified value\"]\n    pub fn cell_highlight_style<S: Into<Style>>(mut self, highlight_style: S) -> Self {\n        self.cell_highlight_style = highlight_style.into();\n        self\n    }\n\n    /// Set the symbol to be displayed in front of the selected row\n    ///\n    /// This is a fluent setter method which must be chained or used as it consumes self\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use ratatui::{\n    ///     layout::Constraint,\n    ///     widgets::{Cell, Row, Table},\n    /// };\n    ///\n    /// # let rows = [Row::new(vec![\"Cell1\", \"Cell2\"])];\n    /// # let widths = [Constraint::Length(5), Constraint::Length(5)];\n    /// let table = Table::new(rows, widths).highlight_symbol(\">>\");\n    /// ```\n    #[must_use = \"method moves the value of self and returns the modified value\"]\n    pub fn highlight_symbol<T: Into<Text<'a>>>(mut self, highlight_symbol: T) -> Self {\n        self.highlight_symbol = highlight_symbol.into();\n        self\n    }\n\n    /// Set when to show the highlight spacing\n    ///\n    /// The highlight spacing is the spacing that is allocated for the selection symbol column (if\n    /// enabled) and is used to shift the table when a row is selected. This method allows you to\n    /// configure when this spacing is allocated.\n    ///\n    /// - [`HighlightSpacing::Always`] will always allocate the spacing, regardless of whether a row\n    ///   is selected or not. This means that the table will never change size, regardless of if a\n    ///   row is selected or not.\n    /// - [`HighlightSpacing::WhenSelected`] will only allocate the spacing if a row is selected.\n    ///   This means that the table will shift when a row is selected. This is the default setting\n    ///   for backwards compatibility, but it is recommended to use `HighlightSpacing::Always` for a\n    ///   better user experience.\n    /// - [`HighlightSpacing::Never`] will never allocate the spacing, regardless of whether a row\n    ///   is selected or not. This means that the highlight symbol will never be drawn.\n    ///\n    /// This is a fluent setter method which must be chained or used as it consumes self\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use ratatui::{\n    ///     layout::Constraint,\n    ///     widgets::{HighlightSpacing, Row, Table},\n    /// };\n    ///\n    /// let rows = [Row::new(vec![\"Cell1\", \"Cell2\"])];\n    /// let widths = [Constraint::Length(5), Constraint::Length(5)];\n    /// let table = Table::new(rows, widths).highlight_spacing(HighlightSpacing::Always);\n    /// ```\n    #[must_use = \"method moves the value of self and returns the modified value\"]\n    pub const fn highlight_spacing(mut self, value: HighlightSpacing) -> Self {\n        self.highlight_spacing = value;\n        self\n    }\n\n    /// Set how extra space is distributed amongst columns.\n    ///\n    /// This determines how the space is distributed when the constraints are satisfied. By default,\n    /// the extra space is not distributed at all.  But this can be changed to distribute all extra\n    /// space to the last column or to distribute it equally.\n    ///\n    /// This is a fluent setter method which must be chained or used as it consumes self\n    ///\n    /// # Examples\n    ///\n    /// Create a table that needs at least 30 columns to display.  Any extra space will be assigned\n    /// to the last column.\n    /// ```\n    /// use ratatui::{\n    ///     layout::{Constraint, Flex},\n    ///     widgets::{Row, Table},\n    /// };\n    ///\n    /// let widths = [\n    ///     Constraint::Min(10),\n    ///     Constraint::Min(10),\n    ///     Constraint::Min(10),\n    /// ];\n    /// let table = Table::new(Vec::<Row>::new(), widths).flex(Flex::Legacy);\n    /// ```\n    #[must_use = \"method moves the value of self and returns the modified value\"]\n    pub const fn flex(mut self, flex: Flex) -> Self {\n        self.flex = flex;\n        self\n    }\n}\n\nimpl Widget for Table<'_> {\n    fn render(self, area: Rect, buf: &mut Buffer) {\n        WidgetRef::render_ref(&self, area, buf);\n    }\n}\n\nimpl WidgetRef for Table<'_> {\n    fn render_ref(&self, area: Rect, buf: &mut Buffer) {\n        let mut state = TableState::default();\n        StatefulWidget::render(self, area, buf, &mut state);\n    }\n}\n\nimpl StatefulWidget for Table<'_> {\n    type State = TableState;\n\n    fn render(self, area: Rect, buf: &mut Buffer, state: &mut Self::State) {\n        StatefulWidget::render(&self, area, buf, state);\n    }\n}\n\n// Note: remove this when StatefulWidgetRef is stabilized and replace with the blanket impl\nimpl StatefulWidget for &Table<'_> {\n    type State = TableState;\n    fn render(self, area: Rect, buf: &mut Buffer, state: &mut Self::State) {\n        StatefulWidgetRef::render_ref(self, area, buf, state);\n    }\n}\n\nimpl StatefulWidgetRef for Table<'_> {\n    type State = TableState;\n\n    fn render_ref(&self, area: Rect, buf: &mut Buffer, state: &mut Self::State) {\n        buf.set_style(area, self.style);\n        self.block.render_ref(area, buf);\n        let table_area = self.block.inner_if_some(area);\n        if table_area.is_empty() {\n            return;\n        }\n\n        if state.selected.is_some_and(|s| s >= self.rows.len()) {\n            state.select(Some(self.rows.len().saturating_sub(1)));\n        }\n\n        if self.rows.is_empty() {\n            state.select(None);\n        }\n\n        let column_count = self.column_count();\n        if state.selected_column.is_some_and(|s| s >= column_count) {\n            state.select_column(Some(column_count.saturating_sub(1)));\n        }\n        if column_count == 0 {\n            state.select_column(None);\n        }\n\n        let selection_width = self.selection_width(state);\n        let columns_widths =\n            self.get_columns_widths(table_area.width, selection_width, column_count);\n        let (header_area, rows_area, footer_area) = self.layout(table_area);\n\n        self.render_header(header_area, buf, &columns_widths);\n\n        self.render_rows(\n            rows_area,\n            buf,\n            state,\n            selection_width,\n            &self.highlight_symbol,\n            &columns_widths,\n        );\n\n        self.render_footer(footer_area, buf, &columns_widths);\n    }\n}\n\n// private methods for rendering\nimpl Table<'_> {\n    /// Splits the table area into a header, rows area and a footer\n    fn layout(&self, area: Rect) -> (Rect, Rect, Rect) {\n        let header_top_margin = self.header.as_ref().map_or(0, |h| h.top_margin);\n        let header_height = self.header.as_ref().map_or(0, |h| h.height);\n        let header_bottom_margin = self.header.as_ref().map_or(0, |h| h.bottom_margin);\n        let footer_top_margin = self.footer.as_ref().map_or(0, |h| h.top_margin);\n        let footer_height = self.footer.as_ref().map_or(0, |f| f.height);\n        let footer_bottom_margin = self.footer.as_ref().map_or(0, |h| h.bottom_margin);\n        let layout = Layout::vertical([\n            Constraint::Length(header_top_margin),\n            Constraint::Length(header_height),\n            Constraint::Length(header_bottom_margin),\n            Constraint::Min(0),\n            Constraint::Length(footer_top_margin),\n            Constraint::Length(footer_height),\n            Constraint::Length(footer_bottom_margin),\n        ])\n        .split(area);\n        let (header_area, rows_area, footer_area) = (layout[1], layout[3], layout[5]);\n        (header_area, rows_area, footer_area)\n    }\n\n    fn render_header(&self, area: Rect, buf: &mut Buffer, column_widths: &[(u16, u16)]) {\n        if let Some(ref header) = self.header {\n            buf.set_style(area, header.style);\n            for ((x, width), cell) in column_widths.iter().zip(header.cells.iter()) {\n                cell.render(Rect::new(area.x + x, area.y, *width, area.height), buf);\n            }\n        }\n    }\n\n    fn render_footer(&self, area: Rect, buf: &mut Buffer, column_widths: &[(u16, u16)]) {\n        if let Some(ref footer) = self.footer {\n            buf.set_style(area, footer.style);\n            for ((x, width), cell) in column_widths.iter().zip(footer.cells.iter()) {\n                cell.render(Rect::new(area.x + x, area.y, *width, area.height), buf);\n            }\n        }\n    }\n\n    fn render_rows(\n        &self,\n        area: Rect,\n        buf: &mut Buffer,\n        state: &mut TableState,\n        selection_width: u16,\n        highlight_symbol: &Text<'_>,\n        columns_widths: &[(u16, u16)],\n    ) {\n        if self.rows.is_empty() {\n            return;\n        }\n\n        let (start_index, end_index) =\n            self.get_row_bounds(state.selected, state.offset, area.height);\n        state.offset = start_index;\n\n        let mut y_offset = 0;\n\n        let mut selected_row_area = None;\n        for (i, row) in self\n            .rows\n            .iter()\n            .enumerate()\n            .skip(state.offset)\n            .take(end_index - start_index)\n        {\n            let row_area = Rect::new(\n                area.x,\n                area.y + y_offset + row.top_margin,\n                area.width,\n                row.height_with_margin() - row.top_margin,\n            );\n            buf.set_style(row_area, row.style);\n\n            let is_selected = state.selected.is_some_and(|index| index == i);\n            if selection_width > 0 && is_selected {\n                let selection_area = Rect {\n                    width: selection_width,\n                    ..row_area\n                };\n                buf.set_style(selection_area, row.style);\n                highlight_symbol.render_ref(selection_area, buf);\n            };\n            for ((x, width), cell) in columns_widths.iter().zip(row.cells.iter()) {\n                cell.render(\n                    Rect::new(row_area.x + x, row_area.y, *width, row_area.height),\n                    buf,\n                );\n            }\n            if is_selected {\n                selected_row_area = Some(row_area);\n            }\n            y_offset += row.height_with_margin();\n        }\n\n        let selected_column_area = state.selected_column.and_then(|s| {\n            // The selection is clamped by the column count. Since a user can manually specify an\n            // incorrect number of widths, we should use panic free methods.\n            columns_widths.get(s).map(|(x, width)| Rect {\n                x: x + area.x,\n                width: *width,\n                ..area\n            })\n        });\n\n        match (selected_row_area, selected_column_area) {\n            (Some(row_area), Some(col_area)) => {\n                buf.set_style(row_area, self.row_highlight_style);\n                buf.set_style(col_area, self.column_highlight_style);\n                let cell_area = row_area.intersection(col_area);\n                buf.set_style(cell_area, self.cell_highlight_style);\n            }\n            (Some(row_area), None) => {\n                buf.set_style(row_area, self.row_highlight_style);\n            }\n            (None, Some(col_area)) => {\n                buf.set_style(col_area, self.column_highlight_style);\n            }\n            (None, None) => (),\n        }\n    }\n\n    /// Get all offsets and widths of all user specified columns.\n    ///\n    /// Returns (x, width). When self.widths is empty, it is assumed `.widths()` has not been called\n    /// and a default of equal widths is returned.\n    fn get_columns_widths(\n        &self,\n        max_width: u16,\n        selection_width: u16,\n        col_count: usize,\n    ) -> Vec<(u16, u16)> {\n        let widths = if self.widths.is_empty() {\n            // Divide the space between each column equally\n            vec![Constraint::Length(max_width / col_count.max(1) as u16); col_count]\n        } else {\n            self.widths.clone()\n        };\n        // this will always allocate a selection area\n        let [_selection_area, columns_area] =\n            Layout::horizontal([Constraint::Length(selection_width), Constraint::Fill(0)])\n                .areas(Rect::new(0, 0, max_width, 1));\n        let rects = Layout::horizontal(widths)\n            .flex(self.flex)\n            .spacing(self.column_spacing)\n            .split(columns_area);\n        rects.iter().map(|c| (c.x, c.width)).collect()\n    }\n\n    fn get_row_bounds(\n        &self,\n        selected: Option<usize>,\n        offset: usize,\n        max_height: u16,\n    ) -> (usize, usize) {\n        let offset = offset.min(self.rows.len().saturating_sub(1));\n        let mut start = offset;\n        let mut end = offset;\n        let mut height = 0;\n        for item in self.rows.iter().skip(offset) {\n            if height + item.height > max_height {\n                break;\n            }\n            height += item.height_with_margin();\n            end += 1;\n        }\n\n        let Some(selected) = selected else {\n            return (start, end);\n        };\n\n        // clamp the selected row to the last row\n        let selected = selected.min(self.rows.len() - 1);\n\n        // scroll down until the selected row is visible\n        while selected >= end {\n            height = height.saturating_add(self.rows[end].height_with_margin());\n            end += 1;\n            while height > max_height {\n                height = height.saturating_sub(self.rows[start].height_with_margin());\n                start += 1;\n            }\n        }\n\n        // scroll up until the selected row is visible\n        while selected < start {\n            start -= 1;\n            height = height.saturating_add(self.rows[start].height_with_margin());\n            while height > max_height {\n                end -= 1;\n                height = height.saturating_sub(self.rows[end].height_with_margin());\n            }\n        }\n        (start, end)\n    }\n\n    fn column_count(&self) -> usize {\n        self.rows\n            .iter()\n            .chain(self.footer.iter())\n            .chain(self.header.iter())\n            .map(|r| r.cells.len())\n            .max()\n            .unwrap_or_default()\n    }\n\n    /// Returns the width of the selection column if a row is selected, or the `highlight_spacing`\n    /// is set to show the column always, otherwise 0.\n    fn selection_width(&self, state: &TableState) -> u16 {\n        let has_selection = state.selected.is_some();\n        if self.highlight_spacing.should_add(has_selection) {\n            self.highlight_symbol.width() as u16\n        } else {\n            0\n        }\n    }\n}\n\nfn ensure_percentages_less_than_100(widths: &[Constraint]) {\n    for w in widths {\n        if let Constraint::Percentage(p) = w {\n            assert!(\n                *p <= 100,\n                \"Percentages should be between 0 and 100 inclusively.\"\n            );\n        }\n    }\n}\n\nimpl<'a> Styled for Table<'a> {\n    type Item = Self;\n\n    fn style(&self) -> Style {\n        self.style\n    }\n\n    fn set_style<S: Into<Style>>(self, style: S) -> Self::Item {\n        self.style(style)\n    }\n}\n\nimpl<'a, Item> FromIterator<Item> for Table<'a>\nwhere\n    Item: Into<Row<'a>>,\n{\n    /// Collects an iterator of rows into a table.\n    ///\n    /// When collecting from an iterator into a table, the user must provide the widths using\n    /// `Table::widths` after construction.\n    fn from_iter<Iter: IntoIterator<Item = Item>>(rows: Iter) -> Self {\n        let widths: [Constraint; 0] = [];\n        Self::new(rows, widths)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use std::vec;\n\n    use rstest::{fixture, rstest};\n\n    use super::*;\n    use crate::{\n        layout::Constraint::*,\n        style::{Color, Modifier, Style, Stylize},\n        text::Line,\n        widgets::Cell,\n    };\n\n    #[test]\n    fn new() {\n        let rows = [Row::new(vec![Cell::from(\"\")])];\n        let widths = [Constraint::Percentage(100)];\n        let table = Table::new(rows.clone(), widths);\n        assert_eq!(table.rows, rows);\n        assert_eq!(table.header, None);\n        assert_eq!(table.footer, None);\n        assert_eq!(table.widths, widths);\n        assert_eq!(table.column_spacing, 1);\n        assert_eq!(table.block, None);\n        assert_eq!(table.style, Style::default());\n        assert_eq!(table.row_highlight_style, Style::default());\n        assert_eq!(table.highlight_symbol, Text::default());\n        assert_eq!(table.highlight_spacing, HighlightSpacing::WhenSelected);\n        assert_eq!(table.flex, Flex::Start);\n    }\n\n    #[test]\n    fn default() {\n        let table = Table::default();\n        assert_eq!(table.rows, []);\n        assert_eq!(table.header, None);\n        assert_eq!(table.footer, None);\n        assert_eq!(table.widths, []);\n        assert_eq!(table.column_spacing, 1);\n        assert_eq!(table.block, None);\n        assert_eq!(table.style, Style::default());\n        assert_eq!(table.row_highlight_style, Style::default());\n        assert_eq!(table.highlight_symbol, Text::default());\n        assert_eq!(table.highlight_spacing, HighlightSpacing::WhenSelected);\n        assert_eq!(table.flex, Flex::Start);\n    }\n\n    #[test]\n    fn collect() {\n        let table = (0..4)\n            .map(|i| -> Row { (0..4).map(|j| format!(\"{i}*{j} = {}\", i * j)).collect() })\n            .collect::<Table>()\n            .widths([Constraint::Percentage(25); 4]);\n\n        let expected_rows: Vec<Row> = vec![\n            Row::new([\"0*0 = 0\", \"0*1 = 0\", \"0*2 = 0\", \"0*3 = 0\"]),\n            Row::new([\"1*0 = 0\", \"1*1 = 1\", \"1*2 = 2\", \"1*3 = 3\"]),\n            Row::new([\"2*0 = 0\", \"2*1 = 2\", \"2*2 = 4\", \"2*3 = 6\"]),\n            Row::new([\"3*0 = 0\", \"3*1 = 3\", \"3*2 = 6\", \"3*3 = 9\"]),\n        ];\n\n        assert_eq!(table.rows, expected_rows);\n        assert_eq!(table.widths, [Constraint::Percentage(25); 4]);\n    }\n\n    #[test]\n    fn widths() {\n        let table = Table::default().widths([Constraint::Length(100)]);\n        assert_eq!(table.widths, [Constraint::Length(100)]);\n\n        // ensure that code that uses &[] continues to work as there is a large amount of code that\n        // uses this pattern\n        #[allow(clippy::needless_borrows_for_generic_args)]\n        let table = Table::default().widths(&[Constraint::Length(100)]);\n        assert_eq!(table.widths, [Constraint::Length(100)]);\n\n        let table = Table::default().widths(vec![Constraint::Length(100)]);\n        assert_eq!(table.widths, [Constraint::Length(100)]);\n\n        // ensure that code that uses &some_vec continues to work as there is a large amount of code\n        // that uses this pattern\n        #[allow(clippy::needless_borrows_for_generic_args)]\n        let table = Table::default().widths(&vec![Constraint::Length(100)]);\n        assert_eq!(table.widths, [Constraint::Length(100)]);\n\n        let table = Table::default().widths([100].into_iter().map(Constraint::Length));\n        assert_eq!(table.widths, [Constraint::Length(100)]);\n    }\n\n    #[test]\n    fn rows() {\n        let rows = [Row::new(vec![Cell::from(\"\")])];\n        let table = Table::default().rows(rows.clone());\n        assert_eq!(table.rows, rows);\n    }\n\n    #[test]\n    fn column_spacing() {\n        let table = Table::default().column_spacing(2);\n        assert_eq!(table.column_spacing, 2);\n    }\n\n    #[test]\n    fn block() {\n        let block = Block::bordered().title(\"Table\");\n        let table = Table::default().block(block.clone());\n        assert_eq!(table.block, Some(block));\n    }\n\n    #[test]\n    fn header() {\n        let header = Row::new(vec![Cell::from(\"\")]);\n        let table = Table::default().header(header.clone());\n        assert_eq!(table.header, Some(header));\n    }\n\n    #[test]\n    fn footer() {\n        let footer = Row::new(vec![Cell::from(\"\")]);\n        let table = Table::default().footer(footer.clone());\n        assert_eq!(table.footer, Some(footer));\n    }\n\n    #[test]\n    #[allow(deprecated)]\n    fn highlight_style() {\n        let style = Style::default().red().italic();\n        let table = Table::default().highlight_style(style);\n        assert_eq!(table.row_highlight_style, style);\n    }\n\n    #[test]\n    fn row_highlight_style() {\n        let style = Style::default().red().italic();\n        let table = Table::default().row_highlight_style(style);\n        assert_eq!(table.row_highlight_style, style);\n    }\n\n    #[test]\n    fn column_highlight_style() {\n        let style = Style::default().red().italic();\n        let table = Table::default().column_highlight_style(style);\n        assert_eq!(table.column_highlight_style, style);\n    }\n\n    #[test]\n    fn cell_highlight_style() {\n        let style = Style::default().red().italic();\n        let table = Table::default().cell_highlight_style(style);\n        assert_eq!(table.cell_highlight_style, style);\n    }\n\n    #[test]\n    fn highlight_symbol() {\n        let table = Table::default().highlight_symbol(\">>\");\n        assert_eq!(table.highlight_symbol, Text::from(\">>\"));\n    }\n\n    #[test]\n    fn highlight_spacing() {\n        let table = Table::default().highlight_spacing(HighlightSpacing::Always);\n        assert_eq!(table.highlight_spacing, HighlightSpacing::Always);\n    }\n\n    #[test]\n    #[should_panic = \"Percentages should be between 0 and 100 inclusively\"]\n    fn table_invalid_percentages() {\n        let _ = Table::default().widths([Constraint::Percentage(110)]);\n    }\n\n    #[test]\n    fn widths_conversions() {\n        let array = [Constraint::Percentage(100)];\n        let table = Table::new(Vec::<Row>::new(), array);\n        assert_eq!(table.widths, [Constraint::Percentage(100)], \"array\");\n\n        let array_ref = &[Constraint::Percentage(100)];\n        let table = Table::new(Vec::<Row>::new(), array_ref);\n        assert_eq!(table.widths, [Constraint::Percentage(100)], \"array ref\");\n\n        let vec = vec![Constraint::Percentage(100)];\n        let slice = vec.as_slice();\n        let table = Table::new(Vec::<Row>::new(), slice);\n        assert_eq!(table.widths, [Constraint::Percentage(100)], \"slice\");\n\n        let vec = vec![Constraint::Percentage(100)];\n        let table = Table::new(Vec::<Row>::new(), vec);\n        assert_eq!(table.widths, [Constraint::Percentage(100)], \"vec\");\n\n        let vec_ref = &vec![Constraint::Percentage(100)];\n        let table = Table::new(Vec::<Row>::new(), vec_ref);\n        assert_eq!(table.widths, [Constraint::Percentage(100)], \"vec ref\");\n    }\n\n    #[cfg(test)]\n    mod state {\n\n        use super::*;\n        use crate::{\n            buffer::Buffer,\n            layout::{Constraint, Rect},\n            widgets::{Row, StatefulWidget, Table, TableState},\n        };\n\n        #[fixture]\n        fn table_buf() -> Buffer {\n            Buffer::empty(Rect::new(0, 0, 10, 10))\n        }\n\n        #[rstest]\n        fn test_list_state_empty_list(mut table_buf: Buffer) {\n            let mut state = TableState::default();\n\n            let rows: Vec<Row> = Vec::new();\n            let widths = vec![Constraint::Percentage(100)];\n            let table = Table::new(rows, widths);\n            state.select_first();\n            StatefulWidget::render(table, table_buf.area, &mut table_buf, &mut state);\n            assert_eq!(state.selected, None);\n            assert_eq!(state.selected_column, None);\n        }\n\n        #[rstest]\n        fn test_list_state_single_item(mut table_buf: Buffer) {\n            let mut state = TableState::default();\n\n            let widths = vec![Constraint::Percentage(100)];\n\n            let items = vec![Row::new(vec![\"Item 1\"])];\n            let table = Table::new(items, widths);\n            state.select_first();\n            StatefulWidget::render(&table, table_buf.area, &mut table_buf, &mut state);\n            assert_eq!(state.selected, Some(0));\n            assert_eq!(state.selected_column, None);\n\n            state.select_last();\n            StatefulWidget::render(&table, table_buf.area, &mut table_buf, &mut state);\n            assert_eq!(state.selected, Some(0));\n            assert_eq!(state.selected_column, None);\n\n            state.select_previous();\n            StatefulWidget::render(&table, table_buf.area, &mut table_buf, &mut state);\n            assert_eq!(state.selected, Some(0));\n            assert_eq!(state.selected_column, None);\n\n            state.select_next();\n            StatefulWidget::render(&table, table_buf.area, &mut table_buf, &mut state);\n            assert_eq!(state.selected, Some(0));\n            assert_eq!(state.selected_column, None);\n\n            let mut state = TableState::default();\n\n            state.select_first_column();\n            StatefulWidget::render(&table, table_buf.area, &mut table_buf, &mut state);\n            assert_eq!(state.selected_column, Some(0));\n            assert_eq!(state.selected, None);\n\n            state.select_last_column();\n            StatefulWidget::render(&table, table_buf.area, &mut table_buf, &mut state);\n            assert_eq!(state.selected_column, Some(0));\n            assert_eq!(state.selected, None);\n\n            state.select_previous_column();\n            StatefulWidget::render(&table, table_buf.area, &mut table_buf, &mut state);\n            assert_eq!(state.selected_column, Some(0));\n            assert_eq!(state.selected, None);\n\n            state.select_next_column();\n            StatefulWidget::render(&table, table_buf.area, &mut table_buf, &mut state);\n            assert_eq!(state.selected_column, Some(0));\n            assert_eq!(state.selected, None);\n        }\n    }\n\n    #[cfg(test)]\n    mod render {\n        use super::*;\n        use crate::layout::Alignment;\n\n        #[test]\n        fn render_empty_area() {\n            let mut buf = Buffer::empty(Rect::new(0, 0, 15, 3));\n            let rows = vec![Row::new(vec![\"Cell1\", \"Cell2\"])];\n            let table = Table::new(rows, vec![Constraint::Length(5); 2]);\n            Widget::render(table, Rect::new(0, 0, 0, 0), &mut buf);\n            assert_eq!(buf, Buffer::empty(Rect::new(0, 0, 15, 3)));\n        }\n\n        #[test]\n        fn render_default() {\n            let mut buf = Buffer::empty(Rect::new(0, 0, 15, 3));\n            let table = Table::default();\n            Widget::render(table, Rect::new(0, 0, 15, 3), &mut buf);\n            assert_eq!(buf, Buffer::empty(Rect::new(0, 0, 15, 3)));\n        }\n\n        #[test]\n        fn render_with_block() {\n            let mut buf = Buffer::empty(Rect::new(0, 0, 15, 3));\n            let rows = vec![\n                Row::new(vec![\"Cell1\", \"Cell2\"]),\n                Row::new(vec![\"Cell3\", \"Cell4\"]),\n            ];\n            let block = Block::bordered().title(\"Block\");\n            let table = Table::new(rows, vec![Constraint::Length(5); 2]).block(block);\n            Widget::render(table, Rect::new(0, 0, 15, 3), &mut buf);\n            #[rustfmt::skip]\n            let expected = Buffer::with_lines([\n                \"\u250cBlock\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\",\n                \"\u2502Cell1 Cell2  \u2502\",\n                \"\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\",\n            ]);\n            assert_eq!(buf, expected);\n        }\n\n        #[test]\n        fn render_with_header() {\n            let mut buf = Buffer::empty(Rect::new(0, 0, 15, 3));\n            let header = Row::new(vec![\"Head1\", \"Head2\"]);\n            let rows = vec![\n                Row::new(vec![\"Cell1\", \"Cell2\"]),\n                Row::new(vec![\"Cell3\", \"Cell4\"]),\n            ];\n            let table = Table::new(rows, [Constraint::Length(5); 2]).header(header);\n            Widget::render(table, Rect::new(0, 0, 15, 3), &mut buf);\n            #[rustfmt::skip]\n            let expected = Buffer::with_lines([\n                \"Head1 Head2    \",\n                \"Cell1 Cell2    \",\n                \"Cell3 Cell4    \",\n            ]);\n            assert_eq!(buf, expected);\n        }\n\n        #[test]\n        fn render_with_footer() {\n            let mut buf = Buffer::empty(Rect::new(0, 0, 15, 3));\n            let footer = Row::new(vec![\"Foot1\", \"Foot2\"]);\n            let rows = vec![\n                Row::new(vec![\"Cell1\", \"Cell2\"]),\n                Row::new(vec![\"Cell3\", \"Cell4\"]),\n            ];\n            let table = Table::new(rows, [Constraint::Length(5); 2]).footer(footer);\n            Widget::render(table, Rect::new(0, 0, 15, 3), &mut buf);\n            #[rustfmt::skip]\n            let expected = Buffer::with_lines([\n                \"Cell1 Cell2    \",\n                \"Cell3 Cell4    \",\n                \"Foot1 Foot2    \",\n            ]);\n            assert_eq!(buf, expected);\n        }\n\n        #[test]\n        fn render_with_header_and_footer() {\n            let mut buf = Buffer::empty(Rect::new(0, 0, 15, 3));\n            let header = Row::new(vec![\"Head1\", \"Head2\"]);\n            let footer = Row::new(vec![\"Foot1\", \"Foot2\"]);\n            let rows = vec![Row::new(vec![\"Cell1\", \"Cell2\"])];\n            let table = Table::new(rows, [Constraint::Length(5); 2])\n                .header(header)\n                .footer(footer);\n            Widget::render(table, Rect::new(0, 0, 15, 3), &mut buf);\n            #[rustfmt::skip]\n            let expected = Buffer::with_lines([\n                \"Head1 Head2    \",\n                \"Cell1 Cell2    \",\n                \"Foot1 Foot2    \",\n            ]);\n            assert_eq!(buf, expected);\n        }\n\n        #[test]\n        fn render_with_header_margin() {\n            let mut buf = Buffer::empty(Rect::new(0, 0, 15, 3));\n            let header = Row::new(vec![\"Head1\", \"Head2\"]).bottom_margin(1);\n            let rows = vec![\n                Row::new(vec![\"Cell1\", \"Cell2\"]),\n                Row::new(vec![\"Cell3\", \"Cell4\"]),\n            ];\n            let table = Table::new(rows, [Constraint::Length(5); 2]).header(header);\n            Widget::render(table, Rect::new(0, 0, 15, 3), &mut buf);\n            #[rustfmt::skip]\n            let expected = Buffer::with_lines([\n                \"Head1 Head2    \",\n                \"               \",\n                \"Cell1 Cell2    \",\n            ]);\n            assert_eq!(buf, expected);\n        }\n\n        #[test]\n        fn render_with_footer_margin() {\n            let mut buf = Buffer::empty(Rect::new(0, 0, 15, 3));\n            let footer = Row::new(vec![\"Foot1\", \"Foot2\"]).top_margin(1);\n            let rows = vec![Row::new(vec![\"Cell1\", \"Cell2\"])];\n            let table = Table::new(rows, [Constraint::Length(5); 2]).footer(footer);\n            Widget::render(table, Rect::new(0, 0, 15, 3), &mut buf);\n            #[rustfmt::skip]\n            let expected = Buffer::with_lines([\n                \"Cell1 Cell2    \",\n                \"               \",\n                \"Foot1 Foot2    \",\n            ]);\n            assert_eq!(buf, expected);\n        }\n\n        #[test]\n        fn render_with_row_margin() {\n            let mut buf = Buffer::empty(Rect::new(0, 0, 15, 3));\n            let rows = vec![\n                Row::new(vec![\"Cell1\", \"Cell2\"]).bottom_margin(1),\n                Row::new(vec![\"Cell3\", \"Cell4\"]),\n            ];\n            let table = Table::new(rows, [Constraint::Length(5); 2]);\n            Widget::render(table, Rect::new(0, 0, 15, 3), &mut buf);\n            #[rustfmt::skip]\n            let expected = Buffer::with_lines([\n                \"Cell1 Cell2    \",\n                \"               \",\n                \"Cell3 Cell4    \",\n            ]);\n            assert_eq!(buf, expected);\n        }\n\n        #[test]\n        fn render_with_alignment() {\n            let mut buf = Buffer::empty(Rect::new(0, 0, 10, 3));\n            let rows = vec![\n                Row::new(vec![Line::from(\"Left\").alignment(Alignment::Left)]),\n                Row::new(vec![Line::from(\"Center\").alignment(Alignment::Center)]),\n                Row::new(vec![Line::from(\"Right\").alignment(Alignment::Right)]),\n            ];\n            let table = Table::new(rows, [Percentage(100)]);\n            Widget::render(table, Rect::new(0, 0, 10, 3), &mut buf);\n            let expected = Buffer::with_lines([\"Left      \", \"  Center  \", \"     Right\"]);\n            assert_eq!(buf, expected);\n        }\n\n        #[test]\n        fn render_with_overflow_does_not_panic() {\n            let mut buf = Buffer::empty(Rect::new(0, 0, 20, 3));\n            let table = Table::new(Vec::<Row>::new(), [Constraint::Min(20); 1])\n                .header(Row::new([Line::from(\"\").alignment(Alignment::Right)]))\n                .footer(Row::new([Line::from(\"\").alignment(Alignment::Right)]));\n            Widget::render(table, Rect::new(0, 0, 20, 3), &mut buf);\n        }\n\n        #[test]\n        fn render_with_selected_column_and_incorrect_width_count_does_not_panic() {\n            let mut buf = Buffer::empty(Rect::new(0, 0, 20, 3));\n            let table = Table::new(\n                vec![Row::new(vec![\"Row1\", \"Row2\", \"Row3\"])],\n                [Constraint::Length(10); 1],\n            );\n            let mut state = TableState::new().with_selected_column(2);\n            StatefulWidget::render(table, Rect::new(0, 0, 20, 3), &mut buf, &mut state);\n        }\n\n        #[test]\n        fn render_with_selected() {\n            let mut buf = Buffer::empty(Rect::new(0, 0, 15, 3));\n            let rows = vec![\n                Row::new(vec![\"Cell1\", \"Cell2\"]),\n                Row::new(vec![\"Cell3\", \"Cell4\"]),\n            ];\n            let table = Table::new(rows, [Constraint::Length(5); 2])\n                .row_highlight_style(Style::new().red())\n                .highlight_symbol(\">>\");\n            let mut state = TableState::new().with_selected(Some(0));\n            StatefulWidget::render(table, Rect::new(0, 0, 15, 3), &mut buf, &mut state);\n            let expected = Buffer::with_lines([\n                \">>Cell1 Cell2  \".red(),\n                \"  Cell3 Cell4  \".into(),\n                \"               \".into(),\n            ]);\n            assert_eq!(buf, expected);\n        }\n\n        #[test]\n        fn render_with_selected_column() {\n            let mut buf = Buffer::empty(Rect::new(0, 0, 15, 3));\n            let rows = vec![\n                Row::new(vec![\"Cell1\", \"Cell2\"]),\n                Row::new(vec![\"Cell3\", \"Cell4\"]),\n            ];\n            let table = Table::new(rows, [Constraint::Length(5); 2])\n                .column_highlight_style(Style::new().blue())\n                .highlight_symbol(\">>\");\n            let mut state = TableState::new().with_selected_column(Some(1));\n            StatefulWidget::render(table, Rect::new(0, 0, 15, 3), &mut buf, &mut state);\n            let expected = Buffer::with_lines::<[Line; 3]>([\n                Line::from(vec![\n                    \"Cell1\".into(),\n                    \" \".into(),\n                    \"Cell2\".blue(),\n                    \"    \".into(),\n                ]),\n                Line::from(vec![\n                    \"Cell3\".into(),\n                    \" \".into(),\n                    \"Cell4\".blue(),\n                    \"    \".into(),\n                ]),\n                Line::from(vec![\"      \".into(), \"     \".blue(), \"    \".into()]),\n            ]);\n            assert_eq!(buf, expected);\n        }\n\n        #[test]\n        fn render_with_selected_cell() {\n            let mut buf = Buffer::empty(Rect::new(0, 0, 20, 4));\n            let rows = vec![\n                Row::new(vec![\"Cell1\", \"Cell2\", \"Cell3\"]),\n                Row::new(vec![\"Cell4\", \"Cell5\", \"Cell6\"]),\n                Row::new(vec![\"Cell7\", \"Cell8\", \"Cell9\"]),\n            ];\n            let table = Table::new(rows, [Constraint::Length(5); 3])\n                .highlight_symbol(\">>\")\n                .cell_highlight_style(Style::new().green());\n            let mut state = TableState::new().with_selected_cell((1, 2));\n            StatefulWidget::render(table, Rect::new(0, 0, 20, 4), &mut buf, &mut state);\n            let expected = Buffer::with_lines::<[Line; 4]>([\n                Line::from(vec![\"  Cell1 \".into(), \"Cell2 \".into(), \"Cell3\".into()]),\n                Line::from(vec![\">>Cell4 Cell5 \".into(), \"Cell6\".green(), \" \".into()]),\n                Line::from(vec![\"  Cell7 \".into(), \"Cell8 \".into(), \"Cell9\".into()]),\n                Line::from(vec![\"                    \".into()]),\n            ]);\n            assert_eq!(buf, expected);\n        }\n\n        #[test]\n        fn render_with_selected_row_and_column() {\n            let mut buf = Buffer::empty(Rect::new(0, 0, 20, 4));\n            let rows = vec![\n                Row::new(vec![\"Cell1\", \"Cell2\", \"Cell3\"]),\n                Row::new(vec![\"Cell4\", \"Cell5\", \"Cell6\"]),\n                Row::new(vec![\"Cell7\", \"Cell8\", \"Cell9\"]),\n            ];\n            let table = Table::new(rows, [Constraint::Length(5); 3])\n                .highlight_symbol(\">>\")\n                .row_highlight_style(Style::new().red())\n                .column_highlight_style(Style::new().blue());\n            let mut state = TableState::new().with_selected(1).with_selected_column(2);\n            StatefulWidget::render(table, Rect::new(0, 0, 20, 4), &mut buf, &mut state);\n            let expected = Buffer::with_lines::<[Line; 4]>([\n                Line::from(vec![\"  Cell1 \".into(), \"Cell2 \".into(), \"Cell3\".blue()]),\n                Line::from(vec![\">>Cell4 Cell5 \".red(), \"Cell6\".blue(), \" \".red()]),\n                Line::from(vec![\"  Cell7 \".into(), \"Cell8 \".into(), \"Cell9\".blue()]),\n                Line::from(vec![\"              \".into(), \"     \".blue(), \" \".into()]),\n            ]);\n            assert_eq!(buf, expected);\n        }\n\n        #[test]\n        fn render_with_selected_row_and_column_and_cell() {\n            let mut buf = Buffer::empty(Rect::new(0, 0, 20, 4));\n            let rows = vec![\n                Row::new(vec![\"Cell1\", \"Cell2\", \"Cell3\"]),\n                Row::new(vec![\"Cell4\", \"Cell5\", \"Cell6\"]),\n                Row::new(vec![\"Cell7\", \"Cell8\", \"Cell9\"]),\n            ];\n            let table = Table::new(rows, [Constraint::Length(5); 3])\n                .highlight_symbol(\">>\")\n                .row_highlight_style(Style::new().red())\n                .column_highlight_style(Style::new().blue())\n                .cell_highlight_style(Style::new().green());\n            let mut state = TableState::new().with_selected(1).with_selected_column(2);\n            StatefulWidget::render(table, Rect::new(0, 0, 20, 4), &mut buf, &mut state);\n            let expected = Buffer::with_lines::<[Line; 4]>([\n                Line::from(vec![\"  Cell1 \".into(), \"Cell2 \".into(), \"Cell3\".blue()]),\n                Line::from(vec![\">>Cell4 Cell5 \".red(), \"Cell6\".green(), \" \".red()]),\n                Line::from(vec![\"  Cell7 \".into(), \"Cell8 \".into(), \"Cell9\".blue()]),\n                Line::from(vec![\"              \".into(), \"     \".blue(), \" \".into()]),\n            ]);\n            assert_eq!(buf, expected);\n        }\n\n        /// Note that this includes a regression test for a bug where the table would not render the\n        /// correct rows when there is no selection.\n        /// <https://github.com/ratatui/ratatui/issues/1179>\n        #[rstest]\n        #[case::no_selection(None, 50, [\"50\", \"51\", \"52\", \"53\", \"54\"])]\n        #[case::selection_before_offset(20, 20, [\"20\", \"21\", \"22\", \"23\", \"24\"])]\n        #[case::selection_immediately_before_offset(49, 49, [\"49\", \"50\", \"51\", \"52\", \"53\"])]\n        #[case::selection_at_start_of_offset(50, 50, [\"50\", \"51\", \"52\", \"53\", \"54\"])]\n        #[case::selection_at_end_of_offset(54, 50, [\"50\", \"51\", \"52\", \"53\", \"54\"])]\n        #[case::selection_immediately_after_offset(55, 51, [\"51\", \"52\", \"53\", \"54\", \"55\"])]\n        #[case::selection_after_offset(80, 76, [\"76\", \"77\", \"78\", \"79\", \"80\"])]\n        fn render_with_selection_and_offset<T: Into<Option<usize>>>(\n            #[case] selected_row: T,\n            #[case] expected_offset: usize,\n            #[case] expected_items: [&str; 5],\n        ) {\n            // render 100 rows offset at 50, with a selected row\n            let rows = (0..100).map(|i| Row::new([i.to_string()]));\n            let table = Table::new(rows, [Constraint::Length(2)]);\n            let mut buf = Buffer::empty(Rect::new(0, 0, 2, 5));\n            let mut state = TableState::new()\n                .with_offset(50)\n                .with_selected(selected_row.into());\n\n            StatefulWidget::render(table.clone(), Rect::new(0, 0, 5, 5), &mut buf, &mut state);\n\n            assert_eq!(buf, Buffer::with_lines(expected_items));\n            assert_eq!(state.offset, expected_offset);\n        }\n    }\n\n    // test how constraints interact with table column width allocation\n    mod column_widths {\n        use super::*;\n\n        #[test]\n        fn length_constraint() {\n            // without selection, more than needed width\n            let table = Table::default().widths([Length(4), Length(4)]);\n            assert_eq!(table.get_columns_widths(20, 0, 0), [(0, 4), (5, 4)]);\n\n            // with selection, more than needed width\n            let table = Table::default().widths([Length(4), Length(4)]);\n            assert_eq!(table.get_columns_widths(20, 3, 0), [(3, 4), (8, 4)]);\n\n            // without selection, less than needed width\n            let table = Table::default().widths([Length(4), Length(4)]);\n            assert_eq!(table.get_columns_widths(7, 0, 0), [(0, 3), (4, 3)]);\n\n            // with selection, less than needed width\n            // <--------7px-------->\n            // \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510x\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            // \u2502 (3, 2) \u2502x\u2502 (6, 1) \u2502\n            // \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518x\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            // column spacing (i.e. `x`) is always prioritized\n            let table = Table::default().widths([Length(4), Length(4)]);\n            assert_eq!(table.get_columns_widths(7, 3, 0), [(3, 2), (6, 1)]);\n        }\n\n        #[test]\n        fn max_constraint() {\n            // without selection, more than needed width\n            let table = Table::default().widths([Max(4), Max(4)]);\n            assert_eq!(table.get_columns_widths(20, 0, 0), [(0, 4), (5, 4)]);\n\n            // with selection, more than needed width\n            let table = Table::default().widths([Max(4), Max(4)]);\n            assert_eq!(table.get_columns_widths(20, 3, 0), [(3, 4), (8, 4)]);\n\n            // without selection, less than needed width\n            let table = Table::default().widths([Max(4), Max(4)]);\n            assert_eq!(table.get_columns_widths(7, 0, 0), [(0, 3), (4, 3)]);\n\n            // with selection, less than needed width\n            let table = Table::default().widths([Max(4), Max(4)]);\n            assert_eq!(table.get_columns_widths(7, 3, 0), [(3, 2), (6, 1)]);\n        }\n\n        #[test]\n        fn min_constraint() {\n            // in its currently stage, the \"Min\" constraint does not grow to use the possible\n            // available length and enabling \"expand_to_fill\" will just stretch the last\n            // constraint and not split it with all available constraints\n\n            // without selection, more than needed width\n            let table = Table::default().widths([Min(4), Min(4)]);\n            assert_eq!(table.get_columns_widths(20, 0, 0), [(0, 10), (11, 9)]);\n\n            // with selection, more than needed width\n            let table = Table::default().widths([Min(4), Min(4)]);\n            assert_eq!(table.get_columns_widths(20, 3, 0), [(3, 8), (12, 8)]);\n\n            // without selection, less than needed width\n            // allocates spacer\n            let table = Table::default().widths([Min(4), Min(4)]);\n            assert_eq!(table.get_columns_widths(7, 0, 0), [(0, 3), (4, 3)]);\n\n            // with selection, less than needed width\n            // always allocates selection and spacer\n            let table = Table::default().widths([Min(4), Min(4)]);\n            assert_eq!(table.get_columns_widths(7, 3, 0), [(3, 2), (6, 1)]);\n        }\n\n        #[test]\n        fn percentage_constraint() {\n            // without selection, more than needed width\n            let table = Table::default().widths([Percentage(30), Percentage(30)]);\n            assert_eq!(table.get_columns_widths(20, 0, 0), [(0, 6), (7, 6)]);\n\n            // with selection, more than needed width\n            let table = Table::default().widths([Percentage(30), Percentage(30)]);\n            assert_eq!(table.get_columns_widths(20, 3, 0), [(3, 5), (9, 5)]);\n\n            // without selection, less than needed width\n            // rounds from positions: [0.0, 0.0, 2.1, 3.1, 5.2, 7.0]\n            let table = Table::default().widths([Percentage(30), Percentage(30)]);\n            assert_eq!(table.get_columns_widths(7, 0, 0), [(0, 2), (3, 2)]);\n\n            // with selection, less than needed width\n            // rounds from positions: [0.0, 3.0, 5.1, 6.1, 7.0, 7.0]\n            let table = Table::default().widths([Percentage(30), Percentage(30)]);\n            assert_eq!(table.get_columns_widths(7, 3, 0), [(3, 1), (5, 1)]);\n        }\n\n        #[test]\n        fn ratio_constraint() {\n            // without selection, more than needed width\n            // rounds from positions: [0.00, 0.00, 6.67, 7.67, 14.33]\n            let table = Table::default().widths([Ratio(1, 3), Ratio(1, 3)]);\n            assert_eq!(table.get_columns_widths(20, 0, 0), [(0, 7), (8, 6)]);\n\n            // with selection, more than needed width\n            // rounds from positions: [0.00, 3.00, 10.67, 17.33, 20.00]\n            let table = Table::default().widths([Ratio(1, 3), Ratio(1, 3)]);\n            assert_eq!(table.get_columns_widths(20, 3, 0), [(3, 6), (10, 5)]);\n\n            // without selection, less than needed width\n            // rounds from positions: [0.00, 2.33, 3.33, 5.66, 7.00]\n            let table = Table::default().widths([Ratio(1, 3), Ratio(1, 3)]);\n            assert_eq!(table.get_columns_widths(7, 0, 0), [(0, 2), (3, 3)]);\n\n            // with selection, less than needed width\n            // rounds from positions: [0.00, 3.00, 5.33, 6.33, 7.00, 7.00]\n            let table = Table::default().widths([Ratio(1, 3), Ratio(1, 3)]);\n            assert_eq!(table.get_columns_widths(7, 3, 0), [(3, 1), (5, 2)]);\n        }\n\n        /// When more width is available than requested, the behavior is controlled by flex\n        #[test]\n        fn underconstrained_flex() {\n            let table = Table::default().widths([Min(10), Min(10), Min(1)]);\n            assert_eq!(\n                table.get_columns_widths(62, 0, 0),\n                &[(0, 20), (21, 20), (42, 20)]\n            );\n\n            let table = Table::default()\n                .widths([Min(10), Min(10), Min(1)])\n                .flex(Flex::Legacy);\n            assert_eq!(\n                table.get_columns_widths(62, 0, 0),\n                &[(0, 10), (11, 10), (22, 40)]\n            );\n\n            let table = Table::default()\n                .widths([Min(10), Min(10), Min(1)])\n                .flex(Flex::SpaceBetween);\n            assert_eq!(\n                table.get_columns_widths(62, 0, 0),\n                &[(0, 20), (21, 20), (42, 20)]\n            );\n        }\n\n        /// NOTE: `segment_size` is deprecated use flex instead!\n        #[allow(deprecated)]\n        #[test]\n        fn underconstrained_segment_size() {\n            let table = Table::default().widths([Min(10), Min(10), Min(1)]);\n            assert_eq!(\n                table.get_columns_widths(62, 0, 0),\n                &[(0, 20), (21, 20), (42, 20)]\n            );\n\n            let table = Table::default()\n                .widths([Min(10), Min(10), Min(1)])\n                .flex(Flex::Legacy);\n            assert_eq!(\n                table.get_columns_widths(62, 0, 0),\n                &[(0, 10), (11, 10), (22, 40)]\n            );\n        }\n\n        #[test]\n        fn no_constraint_with_rows() {\n            let table = Table::default()\n                .rows(vec![\n                    Row::new(vec![\"a\", \"b\"]),\n                    Row::new(vec![\"c\", \"d\", \"e\"]),\n                ])\n                // rows should get precedence over header\n                .header(Row::new(vec![\"f\", \"g\"]))\n                .footer(Row::new(vec![\"h\", \"i\"]))\n                .column_spacing(0);\n            assert_eq!(\n                table.get_columns_widths(30, 0, 3),\n                &[(0, 10), (10, 10), (20, 10)]\n            );\n        }\n\n        #[test]\n        fn no_constraint_with_header() {\n            let table = Table::default()\n                .rows(vec![])\n                .header(Row::new(vec![\"f\", \"g\"]))\n                .column_spacing(0);\n            assert_eq!(table.get_columns_widths(10, 0, 2), [(0, 5), (5, 5)]);\n        }\n\n        #[test]\n        fn no_constraint_with_footer() {\n            let table = Table::default()\n                .rows(vec![])\n                .footer(Row::new(vec![\"h\", \"i\"]))\n                .column_spacing(0);\n            assert_eq!(table.get_columns_widths(10, 0, 2), [(0, 5), (5, 5)]);\n        }\n\n        #[track_caller]\n        fn test_table_with_selection<'line, Lines>(\n            highlight_spacing: HighlightSpacing,\n            columns: u16,\n            spacing: u16,\n            selection: Option<usize>,\n            expected: Lines,\n        ) where\n            Lines: IntoIterator,\n            Lines::Item: Into<Line<'line>>,\n        {\n            let table = Table::default()\n                .rows(vec![Row::new(vec![\"ABCDE\", \"12345\"])])\n                .highlight_spacing(highlight_spacing)\n                .highlight_symbol(\">>>\")\n                .column_spacing(spacing);\n            let area = Rect::new(0, 0, columns, 3);\n            let mut buf = Buffer::empty(area);\n            let mut state = TableState::default().with_selected(selection);\n            StatefulWidget::render(table, area, &mut buf, &mut state);\n            assert_eq!(buf, Buffer::with_lines(expected));\n        }\n\n        #[test]\n        fn excess_area_highlight_symbol_and_column_spacing_allocation() {\n            // no highlight_symbol rendered ever\n            test_table_with_selection(\n                HighlightSpacing::Never,\n                15,   // width\n                0,    // spacing\n                None, // selection\n                [\n                    \"ABCDE  12345   \", /* default layout is Flex::Start but columns length\n                                        * constraints are calculated as `max_area / n_columns`,\n                                        * i.e. they are distributed amongst available space */\n                    \"               \", // row 2\n                    \"               \", // row 3\n                ],\n            );\n\n            let table = Table::default()\n                .rows(vec![Row::new(vec![\"ABCDE\", \"12345\"])])\n                .widths([5, 5])\n                .column_spacing(0);\n            let area = Rect::new(0, 0, 15, 3);\n            let mut buf = Buffer::empty(area);\n            Widget::render(table, area, &mut buf);\n            let expected = Buffer::with_lines([\n                \"ABCDE12345     \", /* As reference, this is what happens when you manually\n                                    * specify widths */\n                \"               \", // row 2\n                \"               \", // row 3\n            ]);\n            assert_eq!(buf, expected);\n\n            // no highlight_symbol rendered ever\n            test_table_with_selection(\n                HighlightSpacing::Never,\n                15,      // width\n                0,       // spacing\n                Some(0), // selection\n                [\n                    \"ABCDE  12345   \", // row 1\n                    \"               \", // row 2\n                    \"               \", // row 3\n                ],\n            );\n\n            // no highlight_symbol rendered because no selection is made\n            test_table_with_selection(\n                HighlightSpacing::WhenSelected,\n                15,   // width\n                0,    // spacing\n                None, // selection\n                [\n                    \"ABCDE  12345   \", // row 1\n                    \"               \", // row 2\n                    \"               \", // row 3\n                ],\n            );\n            // highlight_symbol rendered because selection is made\n            test_table_with_selection(\n                HighlightSpacing::WhenSelected,\n                15,      // width\n                0,       // spacing\n                Some(0), // selection\n                [\n                    \">>>ABCDE 12345 \", // row 1\n                    \"               \", // row 2\n                    \"               \", // row 3\n                ],\n            );\n\n            // highlight_symbol always rendered even no selection is made\n            test_table_with_selection(\n                HighlightSpacing::Always,\n                15,   // width\n                0,    // spacing\n                None, // selection\n                [\n                    \"   ABCDE 12345 \", // row 1\n                    \"               \", // row 2\n                    \"               \", // row 3\n                ],\n            );\n\n            // no highlight_symbol rendered because no selection is made\n            test_table_with_selection(\n                HighlightSpacing::Always,\n                15,      // width\n                0,       // spacing\n                Some(0), // selection\n                [\n                    \">>>ABCDE 12345 \", // row 1\n                    \"               \", // row 2\n                    \"               \", // row 3\n                ],\n            );\n        }\n\n        #[allow(clippy::too_many_lines)]\n        #[test]\n        fn insufficient_area_highlight_symbol_and_column_spacing_allocation() {\n            // column spacing is prioritized over every other constraint\n            test_table_with_selection(\n                HighlightSpacing::Never,\n                10,   // width\n                1,    // spacing\n                None, // selection\n                [\n                    \"ABCDE 1234\", // spacing is prioritized and column is cut\n                    \"          \", // row 2\n                    \"          \", // row 3\n                ],\n            );\n            test_table_with_selection(\n                HighlightSpacing::WhenSelected,\n                10,   // width\n                1,    // spacing\n                None, // selection\n                [\n                    \"ABCDE 1234\", // spacing is prioritized and column is cut\n                    \"          \", // row 2\n                    \"          \", // row 3\n                ],\n            );\n\n            // this test checks that space for highlight_symbol space is always allocated.\n            // this test also checks that space for column is allocated.\n            //\n            // Space for highlight_symbol is allocated first by splitting horizontal space\n            // into highlight_symbol area and column area.\n            // Then in a separate step, column widths are calculated.\n            // column spacing is prioritized when column widths are calculated and last column here\n            // ends up with just 1 wide\n            test_table_with_selection(\n                HighlightSpacing::Always,\n                10,   // width\n                1,    // spacing\n                None, // selection\n                [\n                    \"   ABC 123\", // highlight_symbol and spacing are prioritized\n                    \"          \", // row 2\n                    \"          \", // row 3\n                ],\n            );\n\n            // the following are specification tests\n            test_table_with_selection(\n                HighlightSpacing::Always,\n                9,    // width\n                1,    // spacing\n                None, // selection\n                [\n                    \"   ABC 12\", // highlight_symbol and spacing are prioritized\n                    \"         \", // row 2\n                    \"         \", // row 3\n                ],\n            );\n            test_table_with_selection(\n                HighlightSpacing::Always,\n                8,    // width\n                1,    // spacing\n                None, // selection\n                [\n                    \"   AB 12\", // highlight_symbol and spacing are prioritized\n                    \"        \", // row 2\n                    \"        \", // row 3\n                ],\n            );\n            test_table_with_selection(\n                HighlightSpacing::Always,\n                7,    // width\n                1,    // spacing\n                None, // selection\n                [\n                    \"   AB 1\", // highlight_symbol and spacing are prioritized\n                    \"       \", // row 2\n                    \"       \", // row 3\n                ],\n            );\n\n            let table = Table::default()\n                .rows(vec![Row::new(vec![\"ABCDE\", \"12345\"])])\n                .highlight_spacing(HighlightSpacing::Always)\n                .flex(Flex::Legacy)\n                .highlight_symbol(\">>>\")\n                .column_spacing(1);\n            let area = Rect::new(0, 0, 10, 3);\n            let mut buf = Buffer::empty(area);\n            Widget::render(table, area, &mut buf);\n            // highlight_symbol and spacing are prioritized but columns are evenly distributed\n            #[rustfmt::skip]\n            let expected = Buffer::with_lines([\n                \"   ABCDE 1\",\n                \"          \",\n                \"          \",\n            ]);\n            assert_eq!(buf, expected);\n\n            let table = Table::default()\n                .rows(vec![Row::new(vec![\"ABCDE\", \"12345\"])])\n                .highlight_spacing(HighlightSpacing::Always)\n                .flex(Flex::Start)\n                .highlight_symbol(\">>>\")\n                .column_spacing(1);\n            let area = Rect::new(0, 0, 10, 3);\n            let mut buf = Buffer::empty(area);\n            Widget::render(table, area, &mut buf);\n            // highlight_symbol and spacing are prioritized but columns are evenly distributed\n            #[rustfmt::skip]\n            let expected = Buffer::with_lines([\n                \"   ABC 123\",\n                \"          \",\n                \"          \",\n            ]);\n            assert_eq!(buf, expected);\n\n            test_table_with_selection(\n                HighlightSpacing::Never,\n                10,      // width\n                1,       // spacing\n                Some(0), // selection\n                [\n                    \"ABCDE 1234\", // spacing is prioritized\n                    \"          \",\n                    \"          \",\n                ],\n            );\n\n            test_table_with_selection(\n                HighlightSpacing::WhenSelected,\n                10,      // width\n                1,       // spacing\n                Some(0), // selection\n                [\n                    \">>>ABC 123\", // row 1\n                    \"          \", // row 2\n                    \"          \", // row 3\n                ],\n            );\n\n            test_table_with_selection(\n                HighlightSpacing::Always,\n                10,      // width\n                1,       // spacing\n                Some(0), // selection\n                [\n                    \">>>ABC 123\", // highlight column and spacing are prioritized\n                    \"          \", // row 2\n                    \"          \", // row 3\n                ],\n            );\n        }\n\n        #[test]\n        fn insufficient_area_highlight_symbol_allocation_with_no_column_spacing() {\n            test_table_with_selection(\n                HighlightSpacing::Never,\n                10,   // width\n                0,    // spacing\n                None, // selection\n                [\n                    \"ABCDE12345\", // row 1\n                    \"          \", // row 2\n                    \"          \", // row 3\n                ],\n            );\n            test_table_with_selection(\n                HighlightSpacing::WhenSelected,\n                10,   // width\n                0,    // spacing\n                None, // selection\n                [\n                    \"ABCDE12345\", // row 1\n                    \"          \", // row 2\n                    \"          \", // row 3\n                ],\n            );\n            // highlight symbol spacing is prioritized over all constraints\n            // even if the constraints are fixed length\n            // this is because highlight_symbol column is separated _before_ any of the constraint\n            // widths are calculated\n            test_table_with_selection(\n                HighlightSpacing::Always,\n                10,   // width\n                0,    // spacing\n                None, // selection\n                [\n                    \"   ABCD123\", // highlight column and spacing are prioritized\n                    \"          \", // row 2\n                    \"          \", // row 3\n                ],\n            );\n            test_table_with_selection(\n                HighlightSpacing::Never,\n                10,      // width\n                0,       // spacing\n                Some(0), // selection\n                [\n                    \"ABCDE12345\", // row 1\n                    \"          \", // row 2\n                    \"          \", // row 3\n                ],\n            );\n            test_table_with_selection(\n                HighlightSpacing::WhenSelected,\n                10,      // width\n                0,       // spacing\n                Some(0), // selection\n                [\n                    \">>>ABCD123\", // highlight column and spacing are prioritized\n                    \"          \", // row 2\n                    \"          \", // row 3\n                ],\n            );\n            test_table_with_selection(\n                HighlightSpacing::Always,\n                10,      // width\n                0,       // spacing\n                Some(0), // selection\n                [\n                    \">>>ABCD123\", // highlight column and spacing are prioritized\n                    \"          \", // row 2\n                    \"          \", // row 3\n                ],\n            );\n        }\n    }\n\n    #[test]\n    fn stylize() {\n        assert_eq!(\n            Table::new(vec![Row::new(vec![Cell::from(\"\")])], [Percentage(100)])\n                .black()\n                .on_white()\n                .bold()\n                .not_crossed_out()\n                .style,\n            Style::default()\n                .fg(Color::Black)\n                .bg(Color::White)\n                .add_modifier(Modifier::BOLD)\n                .remove_modifier(Modifier::CROSSED_OUT)\n        );\n    }\n\n    #[rstest]\n    #[case::no_columns(vec![], vec![], vec![], 0)]\n    #[case::only_header(vec![\"H1\", \"H2\"], vec![], vec![], 2)]\n    #[case::only_rows(\n        vec![],\n        vec![vec![\"C1\", \"C2\"], vec![\"C1\", \"C2\", \"C3\"]],\n        vec![],\n        3\n    )]\n    #[case::only_footer(vec![], vec![], vec![\"F1\", \"F2\", \"F3\", \"F4\"], 4)]\n    #[case::rows_longer(\n        vec![\"H1\", \"H2\", \"H3\", \"H4\"],\n        vec![vec![\"C1\", \"C2\"],vec![\"C1\", \"C2\", \"C3\"]],\n        vec![\"F1\", \"F2\"],\n        4\n    )]\n    #[case::rows_longer(\n        vec![\"H1\", \"H2\"],\n        vec![vec![\"C1\", \"C2\"], vec![\"C1\", \"C2\", \"C3\", \"C4\"]],\n        vec![\"F1\", \"F2\"],\n        4\n    )]\n    #[case::footer_longer(\n        vec![\"H1\", \"H2\"],\n        vec![vec![\"C1\", \"C2\"], vec![\"C1\", \"C2\", \"C3\"]],\n        vec![\"F1\", \"F2\", \"F3\", \"F4\"],\n        4\n    )]\n\n    fn column_count(\n        #[case] header: Vec<&str>,\n        #[case] rows: Vec<Vec<&str>>,\n        #[case] footer: Vec<&str>,\n        #[case] expected: usize,\n    ) {\n        let header = Row::new(header);\n        let footer = Row::new(footer);\n        let rows: Vec<Row> = rows.into_iter().map(Row::new).collect();\n        let table = Table::new(rows, Vec::<Constraint>::new())\n            .header(header)\n            .footer(footer);\n        let column_count = table.column_count();\n        assert_eq!(column_count, expected);\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "788b29b448f3b121a66a4619ef1a4faca9192bd5",
    "func": "#![allow(non_upper_case_globals)]\n#![allow(deprecated)]\n\nuse dioxus_core::prelude::IntoAttributeValue;\nuse dioxus_core::HasAttributes;\nuse dioxus_html_internal_macro::impl_extension_attributes;\n\nuse crate::AttributeDescription;\n\n#[cfg(feature = \"hot-reload-context\")]\nmacro_rules! mod_method_mapping {\n    (\n        $matching:ident;\n        $(#[$attr:meta])*\n        $name:ident;\n    ) => {\n        if $matching == stringify!($name) {\n            return Some((stringify!($name), None));\n        }\n    };\n    (\n        $matching:ident;\n        $(#[$attr:meta])*\n        $name:ident: $lit:literal;\n    ) => {\n        if $matching == stringify!($name) {\n            return Some(($lit, None));\n        }\n    };\n    (\n        $matching:ident;\n        $(#[$attr:meta])*\n        $name:ident: $lit:literal in $ns:literal;\n    ) => {\n        if $matching == stringify!($name) {\n            return Some(($lit, Some($ns)));\n        }\n    };\n    (\n        $matching:ident;\n        $(#[$attr:meta])*\n        $name:ident in $ns:literal;\n    ) => {\n        if $matching == stringify!($name) {\n            return Some((stringify!($name), Some($ns)));\n        }\n    };\n}\n\n#[cfg(feature = \"html-to-rsx\")]\nmacro_rules! html_to_rsx_attribute_mapping {\n    (\n        $matching:ident;\n        $(#[$attr:meta])*\n        $name:ident;\n    ) => {\n        if $matching == stringify!($name) {\n            return Some(stringify!($name));\n        }\n    };\n    (\n        $matching:ident;\n        $(#[$attr:meta])*\n        $name:ident: $lit:literal;\n    ) => {\n        if $matching == stringify!($lit) {\n            return Some(stringify!($name));\n        }\n    };\n    (\n        $matching:ident;\n        $(#[$attr:meta])*\n        $name:ident: $lit:literal in $ns:literal;\n    ) => {\n        if $matching == stringify!($lit) {\n            return Some(stringify!($name));\n        }\n    };\n    (\n        $matching:ident;\n        $(#[$attr:meta])*\n        $name:ident in $ns:literal;\n    ) => {\n        if $matching == stringify!($name) {\n            return Some(stringify!($name));\n        }\n    };\n}\n\nmacro_rules! mod_methods {\n    (\n        @base\n        $(#[$mod_attr:meta])*\n        $mod:ident;\n        $fn:ident;\n        $fn_html_to_rsx:ident;\n        $(\n            $(#[$attr:meta])*\n            $name:ident $(: $(no-$alias:ident)? $js_name:literal)? $(in $ns:literal)?;\n        )+\n    ) => {\n        $(#[$mod_attr])*\n        pub mod $mod {\n            use super::*;\n            $(\n                mod_methods! {\n                    @attr\n                    $(#[$attr])*\n                    $name $(: $(no-$alias)? $js_name)? $(in $ns)?;\n                }\n            )+\n        }\n\n        #[cfg(feature = \"hot-reload-context\")]\n        pub(crate) fn $fn(attr: &str) -> Option<(&'static str, Option<&'static str>)> {\n            $(\n                mod_method_mapping! {\n                    attr;\n                    $name $(: $js_name)? $(in $ns)?;\n                }\n            )*\n            None\n        }\n\n        #[cfg(feature = \"html-to-rsx\")]\n        #[doc = \"Converts an HTML attribute to an RSX attribute\"]\n        pub(crate) fn $fn_html_to_rsx(html: &str) -> Option<&'static str> {\n            $(\n                html_to_rsx_attribute_mapping! {\n                    html;\n                    $name $(: $js_name)? $(in $ns)?;\n                }\n            )*\n            None\n        }\n\n        impl_extension_attributes![$mod { $($name,)* }];\n    };\n\n    (\n        @attr\n        $(#[$attr:meta])*\n        $name:ident $(: no-alias $js_name:literal)? $(in $ns:literal)?;\n    ) => {\n        $(#[$attr])*\n        ///\n        /// ## Usage in rsx\n        ///\n        /// ```rust, ignore\n        /// # use dioxus::prelude::*;\n        #[doc = concat!(\"let \", stringify!($name), \" = \\\"value\\\";\")]\n        ///\n        /// rsx! {\n        ///     // Attributes need to be under the element they modify\n        ///     div {\n        ///         // Attributes are followed by a colon and then the value of the attribute\n        #[doc = concat!(\"        \", stringify!($name), \": \\\"value\\\"\")]\n        ///     }\n        ///     div {\n        ///         // Or you can use the shorthand syntax if you have a variable in scope that has the same name as the attribute\n        #[doc = concat!(\"        \", stringify!($name), \",\")]\n        ///     }\n        /// };\n        /// ```\n        pub const $name: AttributeDescription = mod_methods! { $name $(: $js_name)? $(in $ns)?; };\n    };\n\n    (\n        @attr\n        $(#[$attr:meta])*\n        $name:ident $(: $js_name:literal)? $(in $ns:literal)?;\n    ) => {\n        $(#[$attr])*\n        ///\n        /// ## Usage in rsx\n        ///\n        /// ```rust, ignore\n        /// # use dioxus::prelude::*;\n        #[doc = concat!(\"let \", stringify!($name), \" = \\\"value\\\";\")]\n        ///\n        /// rsx! {\n        ///     // Attributes need to be under the element they modify\n        ///     div {\n        ///         // Attributes are followed by a colon and then the value of the attribute\n        #[doc = concat!(\"        \", stringify!($name), \": \\\"value\\\"\")]\n        ///     }\n        ///     div {\n        ///         // Or you can use the shorthand syntax if you have a variable in scope that has the same name as the attribute\n        #[doc = concat!(\"        \", stringify!($name), \",\")]\n        ///     }\n        /// };\n        /// ```\n        $(\n            #[doc(alias = $js_name)]\n        )?\n        pub const $name: AttributeDescription = mod_methods! { $name $(: $js_name)? $(in $ns)?; };\n    };\n\n    // Rename the incoming ident and apply a custom namespace\n    ( $name:ident: $lit:literal in $ns:literal; ) => { ($lit, Some($ns), false) };\n\n    // Custom namespace\n    ( $name:ident in $ns:literal; ) => { (stringify!($name), Some($ns), false) };\n\n    // Rename the incoming ident\n    ( $name:ident: $lit:literal; ) => { ($lit, None, false ) };\n\n    // Don't rename the incoming ident\n    ( $name:ident; ) => { (stringify!($name), None, false) };\n}\n\nmod_methods! {\n    @base\n\n    global_attributes;\n    map_global_attributes;\n    map_html_global_attributes_to_rsx;\n\n    #[deprecated(note = \"This attribute does nothing. For most renderers, you should prefer calling [`dioxus_core::Event::prevent_default`] on the event instead. For liveview, you can use `\\\"onclick\\\": (evt) => evt.prevent_default()` to prevent the default action for this element.\")]\n    /// This attribute has been deprecated in favor of [`dioxus_core::Event::prevent_default`]\n    prevent_default: \"dioxus-prevent-default\";\n\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/accesskey>\n    accesskey;\n\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/autocapitalize>\n    autocapitalize;\n\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/autofocus>\n    autofocus;\n\n    /// The HTML class attribute is used to specify a class for an HTML element.\n    ///\n    /// ## Details\n    /// Multiple HTML elements can share the same class.\n    ///\n    /// The class global attribute is a space-separated list of the case-sensitive classes of the element.\n    /// Classes allow CSS and Javascript to select and access specific elements via the class selectors or\n    /// functions like the DOM method document.getElementsByClassName.\n    ///\n    /// ## Multiple Classes\n    ///\n    /// If you include multiple classes in a single element dioxus will automatically join them with a space.\n    ///\n    /// ```rust\n    /// # use dioxus::prelude::*;\n    /// rsx! {\n    ///     div {\n    ///         class: \"my-class\",\n    ///         class: \"my-other-class\"\n    ///     }\n    /// };\n    /// ```\n    ///\n    /// ## Optional Classes\n    ///\n    /// You can include optional attributes with an unterminated if statement as the value of the attribute. This is very useful for conditionally applying css classes:\n    ///\n    /// ```rust\n    /// # use dioxus::prelude::*;\n    /// rsx! {\n    ///     div {\n    ///         class: if true {\n    ///             \"my-class\"\n    ///         },\n    ///         class: if false {\n    ///             \"my-other-class\"\n    ///         }\n    ///     }\n    /// };\n    /// ```\n    ///\n    /// <https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/class>\n    class;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/contenteditable>\n    contenteditable;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/data>\n    data;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/dir>\n    dir;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/draggable>\n    draggable;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/enterkeyhint>\n    enterkeyhint;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/exportparts>\n    exportparts;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/hidden>\n    hidden;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/id>\n    id;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/inputmode>\n    inputmode;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/is>\n    is;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/itemid>\n    itemid;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/itemprop>\n    itemprop;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/itemref>\n    itemref;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/itemscope>\n    itemscope;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/itemtype>\n    itemtype;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang>\n    lang;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/nonce>\n    nonce;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/part>\n    part;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/popover>\n    popover;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/role>\n    role;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/slot>\n    slot;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/spellcheck>\n    spellcheck;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/style>\n    style;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex>\n    tabindex;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/title>\n    title;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/translate>\n    translate;\n\n\n    /// dangerous_inner_html is Dioxus's replacement for using innerHTML in the browser DOM. In general, setting\n    /// HTML from code is risky because it\u2019s easy to inadvertently expose your users to a cross-site scripting (XSS)\n    /// attack. So, you can set HTML directly from Dioxus, but you have to type out dangerous_inner_html to remind\n    /// yourself that it\u2019s dangerous\n    dangerous_inner_html;\n\n    // This macro creates an explicit method call for each of the style attributes.\n    //\n    // The left token specifies the name of the attribute in the rsx! macro, and the right string literal specifies the\n    // actual name of the attribute generated.\n    //\n    // This roughly follows the html spec\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/align-content>\n    align_content: \"align-content\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/align-items>\n    align_items: \"align-items\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/align-self>\n    align_self: \"align-self\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/alignment-adjust>\n    alignment_adjust: \"alignment-adjust\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/alignment-baseline>\n    alignment_baseline: \"alignment-baseline\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/all>\n    all in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/alt>\n    alt in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/animation>\n    animation in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/animation-delay>\n    animation_delay: \"animation-delay\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/animation-direction>\n    animation_direction: \"animation-direction\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/animation-duration>\n    animation_duration: \"animation-duration\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/animation-fill-mode>\n    animation_fill_mode: \"animation-fill-mode\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/animation-iteration-count>\n    animation_iteration_count: \"animation-iteration-count\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/animation-name>\n    animation_name: \"animation-name\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/animation-play-state>\n    animation_play_state: \"animation-play-state\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/animation-timing-function>\n    animation_timing_function: \"animation-timing-function\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/aspect-ratio>\n    aspect_ratio: \"aspect-ratio\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/azimuth>\n    azimuth in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/backdrop-filter>\n    backdrop_filter: \"backdrop-filter\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/backface-visibility>\n    backface_visibility: \"backface-visibility\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/background>\n    background in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/background-attachment>\n    background_attachment: \"background-attachment\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/background-clip>\n    background_clip: \"background-clip\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/background-color>\n    background_color: \"background-color\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/background-image>\n    background_image: \"background-image\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/background-origin>\n    background_origin: \"background-origin\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/background-position>\n    background_position: \"background-position\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/background-repeat>\n    background_repeat: \"background-repeat\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/background-size>\n    background_size: \"background-size\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/background-blend-mode>\n    background_blend_mode: \"background-blend-mode\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/baseline-shift>\n    baseline_shift: \"baseline-shift\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/bleed>\n    bleed in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/bookmark-label>\n    bookmark_label: \"bookmark-label\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/bookmark-level>\n    bookmark_level: \"bookmark-level\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/bookmark-state>\n    bookmark_state: \"bookmark-state\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/border>\n    border in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/border-color>\n    border_color: \"border-color\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/border-style>\n    border_style: \"border-style\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/border-width>\n    border_width: \"border-width\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom>\n    border_bottom: \"border-bottom\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-color>\n    border_bottom_color: \"border-bottom-color\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-style>\n    border_bottom_style: \"border-bottom-style\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-width>\n    border_bottom_width: \"border-bottom-width\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/border-left>\n    border_left: \"border-left\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/border-left-color>\n    border_left_color: \"border-left-color\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/border-left-style>\n    border_left_style: \"border-left-style\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/border-left-width>\n    border_left_width: \"border-left-width\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/border-right>\n    border_right: \"border-right\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/border-right-color>\n    border_right_color: \"border-right-color\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/border-right-style>\n    border_right_style: \"border-right-style\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/border-right-width>\n    border_right_width: \"border-right-width\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/border-top>\n    border_top: \"border-top\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-color>\n    border_top_color: \"border-top-color\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-style>\n    border_top_style: \"border-top-style\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-width>\n    border_top_width: \"border-top-width\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/border-collapse>\n    border_collapse: \"border-collapse\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/border-image>\n    border_image: \"border-image\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/border-image-outset>\n    border_image_outset: \"border-image-outset\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/border-image-repeat>\n    border_image_repeat: \"border-image-repeat\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/border-image-slice>\n    border_image_slice: \"border-image-slice\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/border-image-source>\n    border_image_source: \"border-image-source\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/border-image-width>\n    border_image_width: \"border-image-width\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/border-radius>\n    border_radius: \"border-radius\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius>\n    border_bottom_left_radius: \"border-bottom-left-radius\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius>\n    border_bottom_right_radius: \"border-bottom-right-radius\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius>\n    border_top_left_radius: \"border-top-left-radius\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-right-radius>\n    border_top_right_radius: \"border-top-right-radius\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/border-spacing>\n    border_spacing: \"border-spacing\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/bottom>\n    bottom in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/box-decoration-break>\n    box_decoration_break: \"box-decoration-break\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/box-shadow>\n    box_shadow: \"box-shadow\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/box-sizing>\n    box_sizing: \"box-sizing\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/box-snap>\n    box_snap: \"box-snap\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/break-after>\n    break_after: \"break-after\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/break-before>\n    break_before: \"break-before\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/break-inside>\n    break_inside: \"break-inside\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/buffered-rendering>\n    buffered_rendering: \"buffered-rendering\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/caption-side>\n    caption_side: \"caption-side\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/clear>\n    clear in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/clear-side>\n    clear_side: \"clear-side\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/clip>\n    clip in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/clip-path>\n    clip_path: \"clip-path\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/clip-rule>\n    clip_rule: \"clip-rule\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/color>\n    color in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/color-adjust>\n    color_adjust: \"color-adjust\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/color-correction>\n    color_correction: \"color-correction\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/color-interpolation>\n    color_interpolation: \"color-interpolation\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/color-interpolation-filters>\n    color_interpolation_filters: \"color-interpolation-filters\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/color-profile>\n    color_profile: \"color-profile\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/color-rendering>\n    color_rendering: \"color-rendering\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/column-fill>\n    column_fill: \"column-fill\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/column-gap>\n    column_gap: \"column-gap\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/column-rule>\n    column_rule: \"column-rule\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/column-rule-color>\n    column_rule_color: \"column-rule-color\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/column-rule-style>\n    column_rule_style: \"column-rule-style\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/column-rule-width>\n    column_rule_width: \"column-rule-width\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/column-span>\n    column_span: \"column-span\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/columns>\n    columns in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/column-count>\n    column_count: \"column-count\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/column-width>\n    column_width: \"column-width\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/contain>\n    contain in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/content>\n    content in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/counter-increment>\n    counter_increment: \"counter-increment\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/counter-reset>\n    counter_reset: \"counter-reset\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/counter-set>\n    counter_set: \"counter-set\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/cue>\n    cue in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/cue-after>\n    cue_after: \"cue-after\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/cue-before>\n    cue_before: \"cue-before\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/cursor>\n    cursor in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/direction>\n    direction in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/display>\n    display in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/display-inside>\n    display_inside: \"display-inside\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/display-outside>\n    display_outside: \"display-outside\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/display-extras>\n    display_extras: \"display-extras\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/display-box>\n    display_box: \"display-box\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/dominant-baseline>\n    dominant_baseline: \"dominant-baseline\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/elevation>\n    elevation in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/empty-cells>\n    empty_cells: \"empty-cells\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/enable-background>\n    enable_background: \"enable-background\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/fill>\n    fill in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/fill-opacity>\n    fill_opacity: \"fill-opacity\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/fill-rule>\n    fill_rule: \"fill-rule\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/filter>\n    filter in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/float>\n    float in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/float-defer-column>\n    float_defer_column: \"float-defer-column\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/float-defer-page>\n    float_defer_page: \"float-defer-page\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/float-offset>\n    float_offset: \"float-offset\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/float-wrap>\n    float_wrap: \"float-wrap\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/flow-into>\n    flow_into: \"flow-into\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/flow-from>\n    flow_from: \"flow-from\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/flex>\n    flex in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/flex-basis>\n    flex_basis: \"flex-basis\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/flex-grow>\n    flex_grow: \"flex-grow\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/flex-shrink>\n    flex_shrink: \"flex-shrink\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/flex-flow>\n    flex_flow: \"flex-flow\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/flex-direction>\n    flex_direction: \"flex-direction\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/flex-wrap>\n    flex_wrap: \"flex-wrap\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/flood-color>\n    flood_color: \"flood-color\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/flood-opacity>\n    flood_opacity: \"flood-opacity\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/font>\n    font in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/font-family>\n    font_family: \"font-family\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/font-size>\n    font_size: \"font-size\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/font-stretch>\n    font_stretch: \"font-stretch\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/font-style>\n    font_style: \"font-style\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight>\n    font_weight: \"font-weight\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/font-feature-settings>\n    font_feature_settings: \"font-feature-settings\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/font-kerning>\n    font_kerning: \"font-kerning\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/font-language-override>\n    font_language_override: \"font-language-override\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/font-size-adjust>\n    font_size_adjust: \"font-size-adjust\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/font-synthesis>\n    font_synthesis: \"font-synthesis\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/font-variant>\n    font_variant: \"font-variant\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/font-variant-alternates>\n    font_variant_alternates: \"font-variant-alternates\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/font-variant-caps>\n    font_variant_caps: \"font-variant-caps\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/font-variant-east-asian>\n    font_variant_east_asian: \"font-variant-east-asian\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/font-variant-ligatures>\n    font_variant_ligatures: \"font-variant-ligatures\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/font-variant-numeric>\n    font_variant_numeric: \"font-variant-numeric\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/font-variant-position>\n    font_variant_position: \"font-variant-position\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/footnote-policy>\n    footnote_policy: \"footnote-policy\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/glyph-orientation-horizontal>\n    glyph_orientation_horizontal: \"glyph-orientation-horizontal\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/glyph-orientation-vertical>\n    glyph_orientation_vertical: \"glyph-orientation-vertical\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/grid>\n    grid in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/grid-auto-flow>\n    grid_auto_flow: \"grid-auto-flow\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/grid-auto-columns>\n    grid_auto_columns: \"grid-auto-columns\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/grid-auto-rows>\n    grid_auto_rows: \"grid-auto-rows\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/grid-template>\n    grid_template: \"grid-template\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/grid-template-areas>\n    grid_template_areas: \"grid-template-areas\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/grid-template-columns>\n    grid_template_columns: \"grid-template-columns\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/grid-template-rows>\n    grid_template_rows: \"grid-template-rows\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/grid-area>\n    grid_area: \"grid-area\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/grid-column>\n    grid_column: \"grid-column\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/grid-column-start>\n    grid_column_start: \"grid-column-start\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/grid-column-end>\n    grid_column_end: \"grid-column-end\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/grid-row>\n    grid_row: \"grid-row\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/grid-row-start>\n    grid_row_start: \"grid-row-start\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/grid-row-end>\n    grid_row_end: \"grid-row-end\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/hanging-punctuation>\n    hanging_punctuation: \"hanging-punctuation\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/height>\n    height in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/hyphenate-character>\n    hyphenate_character: \"hyphenate-character\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/hyphenate-limit-chars>\n    hyphenate_limit_chars: \"hyphenate-limit-chars\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/hyphenate-limit-last>\n    hyphenate_limit_last: \"hyphenate-limit-last\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/hyphenate-limit-lines>\n    hyphenate_limit_lines: \"hyphenate-limit-lines\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/hyphenate-limit-zone>\n    hyphenate_limit_zone: \"hyphenate-limit-zone\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/hyphens>\n    hyphens in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/icon>\n    icon in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/image-orientation>\n    image_orientation: \"image-orientation\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/image-resolution>\n    image_resolution: \"image-resolution\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/image-rendering>\n    image_rendering: \"image-rendering\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/ime>\n    ime in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/ime-align>\n    ime_align: \"ime-align\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/ime-mode>\n    ime_mode: \"ime-mode\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/ime-offset>\n    ime_offset: \"ime-offset\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/ime-width>\n    ime_width: \"ime-width\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/initial-letters>\n    initial_letters: \"initial-letters\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/inline-box-align>\n    inline_box_align: \"inline-box-align\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/isolation>\n    isolation in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/justify-content>\n    justify_content: \"justify-content\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/justify-items>\n    justify_items: \"justify-items\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/justify-self>\n    justify_self: \"justify-self\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/kerning>\n    kerning in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/left>\n    left in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/letter-spacing>\n    letter_spacing: \"letter-spacing\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/lighting-color>\n    lighting_color: \"lighting-color\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/line-box-contain>\n    line_box_contain: \"line-box-contain\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/line-break>\n    line_break: \"line-break\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/line-grid>\n    line_grid: \"line-grid\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/line-height>\n    line_height: \"line-height\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/line-slack>\n    line_slack: \"line-slack\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/line-snap>\n    line_snap: \"line-snap\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/list-style>\n    list_style: \"list-style\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/list-style-image>\n    list_style_image: \"list-style-image\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/list-style-position>\n    list_style_position: \"list-style-position\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/list-style-type>\n    list_style_type: \"list-style-type\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/margin>\n    margin in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/margin-bottom>\n    margin_bottom: \"margin-bottom\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/margin-left>\n    margin_left: \"margin-left\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/margin-right>\n    margin_right: \"margin-right\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/margin-top>\n    margin_top: \"margin-top\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/marker>\n    marker in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/marker-end>\n    marker_end: \"marker-end\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/marker-mid>\n    marker_mid: \"marker-mid\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/marker-pattern>\n    marker_pattern: \"marker-pattern\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/marker-segment>\n    marker_segment: \"marker-segment\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/marker-start>\n    marker_start: \"marker-start\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/marker-knockout-left>\n    marker_knockout_left: \"marker-knockout-left\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/marker-knockout-right>\n    marker_knockout_right: \"marker-knockout-right\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/marker-side>\n    marker_side: \"marker-side\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/marks>\n    marks in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/marquee-direction>\n    marquee_direction: \"marquee-direction\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/marquee-play-count>\n    marquee_play_count: \"marquee-play-count\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/marquee-speed>\n    marquee_speed: \"marquee-speed\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/marquee-style>\n    marquee_style: \"marquee-style\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/mask>\n    mask in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/mask-image>\n    mask_image: \"mask-image\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/mask-repeat>\n    mask_repeat: \"mask-repeat\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/mask-position>\n    mask_position: \"mask-position\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/mask-clip>\n    mask_clip: \"mask-clip\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/mask-origin>\n    mask_origin: \"mask-origin\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/mask-size>\n    mask_size: \"mask-size\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/mask-box>\n    mask_box: \"mask-box\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/mask-box-outset>\n    mask_box_outset: \"mask-box-outset\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/mask-box-repeat>\n    mask_box_repeat: \"mask-box-repeat\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/mask-box-slice>\n    mask_box_slice: \"mask-box-slice\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/mask-box-source>\n    mask_box_source: \"mask-box-source\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/mask-box-width>\n    mask_box_width: \"mask-box-width\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/mask-type>\n    mask_type: \"mask-type\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/max-height>\n    max_height: \"max-height\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/max-lines>\n    max_lines: \"max-lines\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/max-width>\n    max_width: \"max-width\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/min-height>\n    min_height: \"min-height\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/min-width>\n    min_width: \"min-width\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode>\n    mix_blend_mode: \"mix-blend-mode\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/nav-down>\n    nav_down: \"nav-down\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/nav-index>\n    nav_index: \"nav-index\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/nav-left>\n    nav_left: \"nav-left\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/nav-right>\n    nav_right: \"nav-right\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/nav-up>\n    nav_up: \"nav-up\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit>\n    object_fit: \"object-fit\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/object-position>\n    object_position: \"object-position\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/offset-after>\n    offset_after: \"offset-after\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/offset-before>\n    offset_before: \"offset-before\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/offset-end>\n    offset_end: \"offset-end\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/offset-start>\n    offset_start: \"offset-start\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/opacity>\n    opacity in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/order>\n    order in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/orphans>\n    orphans in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/outline>\n    outline in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/outline-color>\n    outline_color: \"outline-color\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/outline-style>\n    outline_style: \"outline-style\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/outline-width>\n    outline_width: \"outline-width\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/outline-offset>\n    outline_offset: \"outline-offset\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/overflow>\n    overflow in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-x>\n    overflow_x: \"overflow-x\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-y>\n    overflow_y: \"overflow-y\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-style>\n    overflow_style: \"overflow-style\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-wrap>\n    overflow_wrap: \"overflow-wrap\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/padding>\n    padding in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/padding-bottom>\n    padding_bottom: \"padding-bottom\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/padding-left>\n    padding_left: \"padding-left\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/padding-right>\n    padding_right: \"padding-right\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/padding-top>\n    padding_top: \"padding-top\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/page>\n    page in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/page-break-after>\n    page_break_after: \"page-break-after\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/page-break-before>\n    page_break_before: \"page-break-before\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/page-break-inside>\n    page_break_inside: \"page-break-inside\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/paint-order>\n    paint_order: \"paint-order\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/pause>\n    pause in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/pause-after>\n    pause_after: \"pause-after\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/pause-before>\n    pause_before: \"pause-before\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/perspective>\n    perspective in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/perspective-origin>\n    perspective_origin: \"perspective-origin\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/pitch>\n    pitch in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/pitch-range>\n    pitch_range: \"pitch-range\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/play-during>\n    play_during: \"play-during\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events>\n    pointer_events: \"pointer-events\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/position>\n    position in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/quotes>\n    quotes in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/region-fragment>\n    region_fragment: \"region-fragment\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/resize>\n    resize in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/rest>\n    rest in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/rest-after>\n    rest_after: \"rest-after\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/rest-before>\n    rest_before: \"rest-before\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/richness>\n    richness in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/right>\n    right in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/ruby-align>\n    ruby_align: \"ruby-align\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/ruby-merge>\n    ruby_merge: \"ruby-merge\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/ruby-position>\n    ruby_position: \"ruby-position\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior>\n    scroll_behavior: \"scroll-behavior\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-snap-coordinate>\n    scroll_snap_coordinate: \"scroll-snap-coordinate\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-snap-destination>\n    scroll_snap_destination: \"scroll-snap-destination\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-snap-points-x>\n    scroll_snap_points_x: \"scroll-snap-points-x\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-snap-points-y>\n    scroll_snap_points_y: \"scroll-snap-points-y\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-snap-type>\n    scroll_snap_type: \"scroll-snap-type\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/shape-image-threshold>\n    shape_image_threshold: \"shape-image-threshold\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/shape-inside>\n    shape_inside: \"shape-inside\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/shape-margin>\n    shape_margin: \"shape-margin\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/shape-outside>\n    shape_outside: \"shape-outside\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/shape-padding>\n    shape_padding: \"shape-padding\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/shape-rendering>\n    shape_rendering: \"shape-rendering\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/size>\n    size in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/speak>\n    speak in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/speak-as>\n    speak_as: \"speak-as\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/speak-header>\n    speak_header: \"speak-header\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/speak-numeral>\n    speak_numeral: \"speak-numeral\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/speak-punctuation>\n    speak_punctuation: \"speak-punctuation\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/speech-rate>\n    speech_rate: \"speech-rate\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/stop-color>\n    stop_color: \"stop-color\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/stop-opacity>\n    stop_opacity: \"stop-opacity\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/stress>\n    stress in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/string-set>\n    string_set: \"string-set\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/stroke>\n    stroke in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/stroke-dasharray>\n    stroke_dasharray: \"stroke-dasharray\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/stroke-dashoffset>\n    stroke_dashoffset: \"stroke-dashoffset\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/stroke-linecap>\n    stroke_linecap: \"stroke-linecap\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/stroke-linejoin>\n    stroke_linejoin: \"stroke-linejoin\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/stroke-miterlimit>\n    stroke_miterlimit: \"stroke-miterlimit\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/stroke-opacity>\n    stroke_opacity: \"stroke-opacity\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/stroke-width>\n    stroke_width: \"stroke-width\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/tab-size>\n    tab_size: \"tab-size\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/table-layout>\n    table_layout: \"table-layout\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/text-align>\n    text_align: \"text-align\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/text-align-all>\n    text_align_all: \"text-align-all\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/text-align-last>\n    text_align_last: \"text-align-last\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/text-anchor>\n    text_anchor: \"text-anchor\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/text-combine-upright>\n    text_combine_upright: \"text-combine-upright\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/text-decoration>\n    text_decoration: \"text-decoration\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/text-decoration-color>\n    text_decoration_color: \"text-decoration-color\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/text-decoration-line>\n    text_decoration_line: \"text-decoration-line\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/text-decoration-style>\n    text_decoration_style: \"text-decoration-style\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/text-decoration-skip>\n    text_decoration_skip: \"text-decoration-skip\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/text-emphasis>\n    text_emphasis: \"text-emphasis\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/text-emphasis-color>\n    text_emphasis_color: \"text-emphasis-color\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/text-emphasis-style>\n    text_emphasis_style: \"text-emphasis-style\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/text-emphasis-position>\n    text_emphasis_position: \"text-emphasis-position\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/text-emphasis-skip>\n    text_emphasis_skip: \"text-emphasis-skip\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/text-height>\n    text_height: \"text-height\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/text-indent>\n    text_indent: \"text-indent\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/text-justify>\n    text_justify: \"text-justify\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/text-orientation>\n    text_orientation: \"text-orientation\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/text-overflow>\n    text_overflow: \"text-overflow\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/text-rendering>\n    text_rendering: \"text-rendering\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow>\n    text_shadow: \"text-shadow\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/text-size-adjust>\n    text_size_adjust: \"text-size-adjust\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/text-space-collapse>\n    text_space_collapse: \"text-space-collapse\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/text-spacing>\n    text_spacing: \"text-spacing\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/text-transform>\n    text_transform: \"text-transform\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/text-underline-position>\n    text_underline_position: \"text-underline-position\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/text-wrap>\n    text_wrap: \"text-wrap\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/top>\n    top in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/touch-action>\n    touch_action: \"touch-action\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/transform>\n    transform in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/transform-box>\n    transform_box: \"transform-box\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/transform-origin>\n    transform_origin: \"transform-origin\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/transform-style>\n    transform_style: \"transform-style\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/transition>\n    transition in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/transition-delay>\n    transition_delay: \"transition-delay\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/transition-duration>\n    transition_duration: \"transition-duration\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/transition-property>\n    transition_property: \"transition-property\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi>\n    unicode_bidi: \"unicode-bidi\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/vector-effect>\n    vector_effect: \"vector-effect\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/vertical-align>\n    vertical_align: \"vertical-align\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/visibility>\n    visibility in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/voice-balance>\n    voice_balance: \"voice-balance\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/voice-duration>\n    voice_duration: \"voice-duration\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/voice-family>\n    voice_family: \"voice-family\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/voice-pitch>\n    voice_pitch: \"voice-pitch\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/voice-range>\n    voice_range: \"voice-range\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/voice-rate>\n    voice_rate: \"voice-rate\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/voice-stress>\n    voice_stress: \"voice-stress\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/voice-volume>\n    voice_volume: \"voice-volume\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/volume>\n    volume in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/white-space>\n    white_space: \"white-space\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/widows>\n    widows in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/width>\n    width in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/will-change>\n    will_change: \"will-change\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/word-break>\n    word_break: \"word-break\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/word-spacing>\n    word_spacing: \"word-spacing\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/word-wrap>\n    word_wrap: \"word-wrap\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/wrap-flow>\n    wrap_flow: \"wrap-flow\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/wrap-through>\n    wrap_through: \"wrap-through\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/writing-mode>\n    writing_mode: \"writing-mode\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/gap>\n    gap in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/list-style-type>\n    list_styler_type: \"list-style-type\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/row-gap>\n    row_gap: \"row-gap\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/transition-timing-function>\n    transition_timing_function: \"transition-timing-function\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/user-select>\n    user_select: \"user-select\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-user-select>\n    webkit_user_select: \"-webkit-user-select\" in \"style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/CSS/z-index>\n    z_index: \"z-index\" in \"style\";\n\n    // area attribute\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-current>\n    aria_current: \"aria-current\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-details>\n    aria_details: \"aria-details\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-disabled>\n    aria_disabled: \"aria-disabled\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-hidden>\n    aria_hidden: \"aria-hidden\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-invalid>\n    aria_invalid: \"aria-invalid\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-keyshortcuts>\n    aria_keyshortcuts: \"aria-keyshortcuts\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-label>\n    aria_label: \"aria-label\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-roledescription>\n    aria_roledescription: \"aria-roledescription\";\n\n// Widget Attributes\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-autocomplete>\n    aria_autocomplete: \"aria-autocomplete\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-checked>\n    aria_checked: \"aria-checked\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-expanded>\n    aria_expanded: \"aria-expanded\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-haspopup>\n    aria_haspopup: \"aria-haspopup\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-level>\n    aria_level: \"aria-level\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-modal>\n    aria_modal: \"aria-modal\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-multiline>\n    aria_multiline: \"aria-multiline\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-multiselectable>\n    aria_multiselectable: \"aria-multiselectable\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-orientation>\n    aria_orientation: \"aria-orientation\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-placeholder>\n    aria_placeholder: \"aria-placeholder\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-pressed>\n    aria_pressed: \"aria-pressed\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-readonly>\n    aria_readonly: \"aria-readonly\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-required>\n    aria_required: \"aria-required\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-selected>\n    aria_selected: \"aria-selected\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-sort>\n    aria_sort: \"aria-sort\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-valuemax>\n    aria_valuemax: \"aria-valuemax\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-valuemin>\n    aria_valuemin: \"aria-valuemin\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-valuenow>\n    aria_valuenow: \"aria-valuenow\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-valuetext>\n    aria_valuetext: \"aria-valuetext\";\n\n// Live Region Attributes\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-atomic>\n    aria_atomic: \"aria-atomic\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-busy>\n    aria_busy: \"aria-busy\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-live>\n    aria_live: \"aria-live\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-relevant>\n    aria_relevant: \"aria-relevant\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-dropeffect>\n    aria_dropeffect: \"aria-dropeffect\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-grabbed>\n    aria_grabbed: \"aria-grabbed\";\n\n// Relationship Attributes\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-activedescendant>\n    aria_activedescendant: \"aria-activedescendant\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-colcount>\n    aria_colcount: \"aria-colcount\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-colindex>\n    aria_colindex: \"aria-colindex\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-colspan>\n    aria_colspan: \"aria-colspan\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-controls>\n    aria_controls: \"aria-controls\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-describedby>\n    aria_describedby: \"aria-describedby\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-errormessage>\n    aria_errormessage: \"aria-errormessage\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-flowto>\n    aria_flowto: \"aria-flowto\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-labelledby>\n    aria_labelledby: \"aria-labelledby\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-owns>\n    aria_owns: \"aria-owns\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-posinset>\n    aria_posinset: \"aria-posinset\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-rowcount>\n    aria_rowcount: \"aria-rowcount\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-rowindex>\n    aria_rowindex: \"aria-rowindex\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-rowspan>\n    aria_rowspan: \"aria-rowspan\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-setsize>\n    aria_setsize: \"aria-setsize\";\n}\n\nmod_methods! {\n    @base\n    svg_attributes;\n    map_svg_attributes;\n    map_html_svg_attributes_to_rsx;\n\n    /// Prevent the default action for this element. This attribute is only recommended in the LiveView renderer\n    /// which does not support the prevent default method on events.\n    ///\n    ///\n    /// For most renderers, you should prefer calling [`dioxus_core::Event::prevent_default`] on the event instead.\n    ///\n    ///\n    /// For more information, see the MDN docs:\n    /// <https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault>\n    prevent_default: \"dioxus-prevent-default\";\n\n    /// dangerous_inner_html is Dioxus's replacement for using innerHTML in the browser DOM. In general, setting\n    /// HTML from code is risky because it\u2019s easy to inadvertently expose your users to a cross-site scripting (XSS)\n    /// attack. So, you can set HTML directly from Dioxus, but you have to type out dangerous_inner_html to remind\n    /// yourself that it\u2019s dangerous\n    dangerous_inner_html;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/accent-height>\n    accent_height: \"accent-height\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/accumulate>\n    accumulate;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/additive>\n    additive;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/alignment-baseline>\n    alignment_baseline: \"alignment-baseline\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/alphabetic>\n    alphabetic;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/amplitude>\n    amplitude;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/arabic-form>\n    arabic_form: \"arabic-form\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/ascent>\n    ascent;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/attributeName>\n    attribute_name: \"attributeName\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/attributeType>\n    attribute_type: \"attributeType\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/azimuth>\n    azimuth;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/baseFrequency>\n    base_frequency: \"baseFrequency\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/baseline-shift>\n    baseline_shift: \"baseline-shift\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/baseProfile>\n    base_profile: \"baseProfile\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/bbox>\n    bbox;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/begin>\n    begin;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/bias>\n    bias;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/by>\n    by;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/calcMode>\n    calc_mode: \"calcMode\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/cap-height>\n    cap_height: \"cap-height\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/class>\n    class;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/clip>\n    clip;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/clipPathUnits>\n    clip_path_units: \"clipPathUnits\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/clip-path>\n    clip_path: \"clip-path\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/clip-rule>\n    clip_rule: \"clip-rule\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/color>\n    color;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/color-interpolation>\n    color_interpolation: \"color-interpolation\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/color-interpolation-filters>\n    color_interpolation_filters: \"color-interpolation-filters\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/color-profile>\n    color_profile: \"color-profile\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/color-rendering>\n    color_rendering: \"color-rendering\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/contentScriptType>\n    content_script_type: \"contentScriptType\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/contentStyleType>\n    content_style_type: \"contentStyleType\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/crossorigin>\n    crossorigin;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/cursor>\n    cursor;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/cx>\n    cx;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/cy>\n    cy;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d>\n    d;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/decelerate>\n    decelerate;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/descent>\n    descent;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/diffuseConstant>\n    diffuse_constant: \"diffuseConstant\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/direction>\n    direction;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/display>\n    display;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/divisor>\n    divisor;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/dominant-baseline>\n    dominant_baseline: \"dominant-baseline\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/dur>\n    dur;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/dx>\n    dx;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/dy>\n    dy;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/edgeMode>\n    edge_mode: \"edgeMode\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/elevation>\n    elevation;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/enable-background>\n    enable_background: \"enable-background\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/end>\n    end;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/exponent>\n    exponent;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill>\n    fill;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-opacity>\n    fill_opacity: \"fill-opacity\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-rule>\n    fill_rule: \"fill-rule\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/filter>\n    filter;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/filterRes>\n    filterRes;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/filterUnits>\n    filterUnits;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/flood-color>\n    flood_color: \"flood-color\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/flood-opacity>\n    flood_opacity: \"flood-opacity\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/font-family>\n    font_family: \"font-family\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/font-size>\n    font_size: \"font-size\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/font-size-adjust>\n    font_size_adjust: \"font-size-adjust\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/font-stretch>\n    font_stretch: \"font-stretch\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/font-style>\n    font_style: \"font-style\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/font-variant>\n    font_variant: \"font-variant\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/font-weight>\n    font_weight: \"font-weight\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/format>\n    format;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/from>\n    from;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fr>\n    fr;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fx>\n    fx;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fy>\n    fy;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/g1>\n    g1;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/g2>\n    g2;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/glyph-name>\n    glyph_name: \"glyph-name\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/glyph-orientation-horizontal>\n    glyph_orientation_horizontal: \"glyph-orientation-horizontal\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/glyph-orientation-vertical>\n    glyph_orientation_vertical: \"glyph-orientation-vertical\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/glyphRef>\n    glyph_ref: \"glyphRef\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/gradientTransform>\n    gradient_transform: \"gradientTransform\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/gradientUnits>\n    gradient_units: \"gradientUnits\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/hanging>\n    hanging;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/height>\n    height;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/href>\n    href;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/hreflang>\n    hreflang;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/horiz-adv-x>\n    horiz_adv_x: \"horiz-adv-x\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/horiz-origin-x>\n    horiz_origin_x: \"horiz-origin-x\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/id>\n    id;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/ideographic>\n    ideographic;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/image-rendering>\n    image_rendering: \"image-rendering\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/_in>\n    _in;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/in2>\n    in2;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/intercept>\n    intercept;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/k>\n    k;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/k1>\n    k1;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/k2>\n    k2;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/k3>\n    k3;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/k4>\n    k4;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/kernelMatrix>\n    kernel_matrix: \"kernelMatrix\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/kernelUnitLength>\n    kernel_unit_length: \"kernelUnitLength\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/kerning>\n    kerning;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/keyPoints>\n    key_points: \"keyPoints\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/keySplines>\n    key_splines: \"keySplines\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/keyTimes>\n    key_times: \"keyTimes\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/lang>\n    lang;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/lengthAdjust>\n    length_adjust: \"lengthAdjust\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing>\n    letter_spacing: \"letter-spacing\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/lighting-color>\n    lighting_color: \"lighting-color\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/limitingConeAngle>\n    limiting_cone_angle: \"limitingConeAngle\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/local>\n    local;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/marker-end>\n    marker_end: \"marker-end\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/marker-mid>\n    marker_mid: \"marker-mid\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/marker-start>\n    marker_start: \"marker-start\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/markerHeight>\n    marker_height: \"markerHeight\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/markerUnits>\n    marker_units: \"markerUnits\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/markerWidth>\n    marker_width: \"markerWidth\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/mask>\n    mask;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/maskContentUnits>\n    mask_content_units: \"maskContentUnits\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/maskUnits>\n    mask_units: \"maskUnits\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/mathematical>\n    mathematical;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/max>\n    max;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/media>\n    media;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/method>\n    method;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/min>\n    min;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/mode>\n    mode;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/name>\n    name;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/numOctaves>\n    num_octaves: \"numOctaves\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/offset>\n    offset;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/opacity>\n    opacity;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/operator>\n    operator;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/order>\n    order;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/orient>\n    orient;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/orientation>\n    orientation;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/origin>\n    origin;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/overflow>\n    overflow;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/overline-position>\n    overline_position: \"overline-position\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/overline-thickness>\n    overline_thickness: \"overline-thickness\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/panose-1>\n    panose_1: \"panose-1\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/paint-order>\n    paint_order: \"paint-order\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/path>\n    path;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/pathLength>\n    path_length: \"pathLength\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/patternContentUnits>\n    pattern_content_units: \"patternContentUnits\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/patternTransform>\n    pattern_transform: \"patternTransform\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/patternUnits>\n    pattern_units: \"patternUnits\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/ping>\n    ping;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/pointer-events>\n    pointer_events: \"pointer-events\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/points>\n    points;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/pointsAtX>\n    points_at_x: \"pointsAtX\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/pointsAtY>\n    points_at_y: \"pointsAtY\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/pointsAtZ>\n    points_at_z: \"pointsAtZ\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/preserveAlpha>\n    preserve_alpha: \"preserveAlpha\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/preserveAspectRatio>\n    preserve_aspect_ratio: \"preserveAspectRatio\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/primitiveUnits>\n    primitive_units: \"primitiveUnits\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/r>\n    r;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/radius>\n    radius;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/referrerPolicy>\n    referrer_policy: \"referrerPolicy\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/refX>\n    ref_x: \"refX\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/refY>\n    ref_y: \"refY\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/rel>\n    rel;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/rendering-intent>\n    rendering_intent: \"rendering-intent\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/repeatCount>\n    repeat_count: \"repeatCount\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/repeatDur>\n    repeat_dur: \"repeatDur\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/requiredExtensions>\n    required_extensions: \"requiredExtensions\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/requiredFeatures>\n    required_features: \"requiredFeatures\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/restart>\n    restart;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/result>\n    result;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/role>\n    role;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/rotate>\n    rotate;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/rx>\n    rx;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/ry>\n    ry;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/scale>\n    scale;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/seed>\n    seed;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/shape-rendering>\n    shape_rendering: \"shape-rendering\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/slope>\n    slope;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/spacing>\n    spacing;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/specularConstant>\n    specular_constant: \"specularConstant\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/specularExponent>\n    specular_exponent: \"specularExponent\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/speed>\n    speed;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/spreadMethod>\n    spread_method: \"spreadMethod\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/startOffset>\n    start_offset: \"startOffset\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stdDeviation>\n    std_deviation: \"stdDeviation\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stemh>\n    stemh;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stemv>\n    stemv;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stitchTiles>\n    stitch_tiles: \"stitchTiles\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stop-color>\n    stop_color: \"stop-color\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stop-opacity>\n    stop_opacity: \"stop-opacity\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/strikethrough-position>\n    strikethrough_position: \"strikethrough-position\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/strikethrough-thickness>\n    strikethrough_thickness: \"strikethrough-thickness\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/string>\n    string;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke>\n    stroke;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray>\n    stroke_dasharray: \"stroke-dasharray\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dashoffset>\n    stroke_dashoffset: \"stroke-dashoffset\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-linecap>\n    stroke_linecap: \"stroke-linecap\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-linejoin>\n    stroke_linejoin: \"stroke-linejoin\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-miterlimit>\n    stroke_miterlimit: \"stroke-miterlimit\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-opacity>\n    stroke_opacity: \"stroke-opacity\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-width>\n    stroke_width: \"stroke-width\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/style>\n    style;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/surfaceScale>\n    surface_scale: \"surfaceScale\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/systemLanguage>\n    system_language: \"systemLanguage\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/tabindex>\n    tabindex;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/tableValues>\n    table_values: \"tableValues\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/target>\n    target;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/targetX>\n    target_x: \"targetX\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/targetY>\n    target_y: \"targetY\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/text-anchor>\n    text_anchor: \"text-anchor\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/text-decoration>\n    text_decoration: \"text-decoration\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/text-rendering>\n    text_rendering: \"text-rendering\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/textLength>\n    text_length: \"textLength\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/to>\n    to;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/transform>\n    transform;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/transform-origin>\n    transform_origin: \"transform-origin\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/type>\n    r#type: no-alias \"type\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/u1>\n    u1;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/u2>\n    u2;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/underline-position>\n    underline_position: \"underline-position\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/underline-thickness>\n    underline_thickness: \"underline-thickness\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/unicode>\n    unicode;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/unicode-bidi>\n    unicode_bidi: \"unicode-bidi\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/unicode-range>\n    unicode_range: \"unicode-range\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/units-per-em>\n    units_per_em: \"units-per-em\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/v-alphabetic>\n    v_alphabetic: \"v-alphabetic\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/v-hanging>\n    v_hanging: \"v-hanging\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/v-ideographic>\n    v_ideographic: \"v-ideographic\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/v-mathematical>\n    v_mathematical: \"v-mathematical\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/values>\n    values;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/vector-effect>\n    vector_effect: \"vector-effect\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/version>\n    version;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/vert-adv-y>\n    vert_adv_y: \"vert-adv-y\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/vert-origin-x>\n    vert_origin_x: \"vert-origin-x\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/vert-origin-y>\n    vert_origin_y: \"vert-origin-y\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/viewBox>\n    view_box: \"viewBox\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/viewTarget>\n    view_target: \"viewTarget\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/visibility>\n    visibility;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/width>\n    width;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/widths>\n    widths;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/word-spacing>\n    word_spacing: \"word-spacing\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/writing-mode>\n    writing_mode: \"writing-mode\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/x>\n    x;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/x-height>\n    x_height: \"x-height\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/x1>\n    x1;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/x2>\n    x2;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/xmlns>\n    xmlns;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/xChannelSelector>\n    x_channel_selector: \"xChannelSelector\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/y>\n    y;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/y1>\n    y1;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/y2>\n    y2;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/yChannelSelector>\n    y_channel_selector: \"yChannelSelector\";\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/z>\n    z;\n\n    /// <https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/zoomAndPan>\n    zoom_and_pan: \"zoomAndPan\";\n\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "6a6f66490187d381e64caf89d9c72bb2c16fdef0",
    "func": "#[macro_use] extern crate rocket;\n\n#[get(\"/<_>\")]\nfn i0() {}\n\n#[get(\"/c?<_>\")]\nfn i1() {}\n\n#[post(\"/d\", data = \"<_>\")]\nfn i2() {}\n\nfn main() {  }\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "76fd57788559a0d218c2d964e82066c24b19bc94",
    "func": "use crate::{IVec2, Rect, URect};\n\n#[cfg(feature = \"bevy_reflect\")]\nuse bevy_reflect::{std_traits::ReflectDefault, Reflect};\n#[cfg(all(feature = \"serialize\", feature = \"bevy_reflect\"))]\nuse bevy_reflect::{ReflectDeserialize, ReflectSerialize};\n\n/// A rectangle defined by two opposite corners.\n///\n/// The rectangle is axis aligned, and defined by its minimum and maximum coordinates,\n/// stored in `IRect::min` and `IRect::max`, respectively. The minimum/maximum invariant\n/// must be upheld by the user when directly assigning the fields, otherwise some methods\n/// produce invalid results. It is generally recommended to use one of the constructor\n/// methods instead, which will ensure this invariant is met, unless you already have\n/// the minimum and maximum corners.\n#[repr(C)]\n#[derive(Default, Clone, Copy, Debug, PartialEq, Eq, Hash)]\n#[cfg_attr(feature = \"serialize\", derive(serde::Serialize, serde::Deserialize))]\n#[cfg_attr(\n    feature = \"bevy_reflect\",\n    derive(Reflect),\n    reflect(Debug, PartialEq, Hash, Default)\n)]\n#[cfg_attr(\n    all(feature = \"serialize\", feature = \"bevy_reflect\"),\n    reflect(Serialize, Deserialize)\n)]\npub struct IRect {\n    /// The minimum corner point of the rect.\n    pub min: IVec2,\n    /// The maximum corner point of the rect.\n    pub max: IVec2,\n}\n\nimpl IRect {\n    /// An empty `IRect`, represented by maximum and minimum corner points\n    /// with `max == IVec2::MIN` and `min == IVec2::MAX`, so the\n    /// rect has an extremely large negative size.\n    /// This is useful, because when taking a union B of a non-empty `IRect` A and\n    /// this empty `IRect`, B will simply equal A.\n    pub const EMPTY: Self = Self {\n        max: IVec2::MIN,\n        min: IVec2::MAX,\n    };\n    /// Create a new rectangle from two corner points.\n    ///\n    /// The two points do not need to be the minimum and/or maximum corners.\n    /// They only need to be two opposite corners.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use bevy_math::IRect;\n    /// let r = IRect::new(0, 4, 10, 6); // w=10 h=2\n    /// let r = IRect::new(2, 3, 5, -1); // w=3 h=4\n    /// ```\n    #[inline]\n    pub fn new(x0: i32, y0: i32, x1: i32, y1: i32) -> Self {\n        Self::from_corners(IVec2::new(x0, y0), IVec2::new(x1, y1))\n    }\n\n    /// Create a new rectangle from two corner points.\n    ///\n    /// The two points do not need to be the minimum and/or maximum corners.\n    /// They only need to be two opposite corners.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use bevy_math::{IRect, IVec2};\n    /// // Unit rect from [0,0] to [1,1]\n    /// let r = IRect::from_corners(IVec2::ZERO, IVec2::ONE); // w=1 h=1\n    /// // Same; the points do not need to be ordered\n    /// let r = IRect::from_corners(IVec2::ONE, IVec2::ZERO); // w=1 h=1\n    /// ```\n    #[inline]\n    pub fn from_corners(p0: IVec2, p1: IVec2) -> Self {\n        Self {\n            min: p0.min(p1),\n            max: p0.max(p1),\n        }\n    }\n\n    /// Create a new rectangle from its center and size.\n    ///\n    /// # Rounding Behavior\n    ///\n    /// If the size contains odd numbers they will be rounded down to the nearest whole number.\n    ///\n    /// # Panics\n    ///\n    /// This method panics if any of the components of the size is negative.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use bevy_math::{IRect, IVec2};\n    /// let r = IRect::from_center_size(IVec2::ZERO, IVec2::new(3, 2)); // w=2 h=2\n    /// assert_eq!(r.min, IVec2::splat(-1));\n    /// assert_eq!(r.max, IVec2::splat(1));\n    /// ```\n    #[inline]\n    pub fn from_center_size(origin: IVec2, size: IVec2) -> Self {\n        debug_assert!(size.cmpge(IVec2::ZERO).all(), \"IRect size must be positive\");\n        let half_size = size / 2;\n        Self::from_center_half_size(origin, half_size)\n    }\n\n    /// Create a new rectangle from its center and half-size.\n    ///\n    /// # Panics\n    ///\n    /// This method panics if any of the components of the half-size is negative.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use bevy_math::{IRect, IVec2};\n    /// let r = IRect::from_center_half_size(IVec2::ZERO, IVec2::ONE); // w=2 h=2\n    /// assert_eq!(r.min, IVec2::splat(-1));\n    /// assert_eq!(r.max, IVec2::splat(1));\n    /// ```\n    #[inline]\n    pub fn from_center_half_size(origin: IVec2, half_size: IVec2) -> Self {\n        assert!(\n            half_size.cmpge(IVec2::ZERO).all(),\n            \"IRect half_size must be positive\"\n        );\n        Self {\n            min: origin - half_size,\n            max: origin + half_size,\n        }\n    }\n\n    /// Check if the rectangle is empty.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use bevy_math::{IRect, IVec2};\n    /// let r = IRect::from_corners(IVec2::ZERO, IVec2::new(0, 1)); // w=0 h=1\n    /// assert!(r.is_empty());\n    /// ```\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n        self.min.cmpge(self.max).any()\n    }\n\n    /// Rectangle width (max.x - min.x).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use bevy_math::IRect;\n    /// let r = IRect::new(0, 0, 5, 1); // w=5 h=1\n    /// assert_eq!(r.width(), 5);\n    /// ```\n    #[inline]\n    pub fn width(&self) -> i32 {\n        self.max.x - self.min.x\n    }\n\n    /// Rectangle height (max.y - min.y).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use bevy_math::IRect;\n    /// let r = IRect::new(0, 0, 5, 1); // w=5 h=1\n    /// assert_eq!(r.height(), 1);\n    /// ```\n    #[inline]\n    pub fn height(&self) -> i32 {\n        self.max.y - self.min.y\n    }\n\n    /// Rectangle size.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use bevy_math::{IRect, IVec2};\n    /// let r = IRect::new(0, 0, 5, 1); // w=5 h=1\n    /// assert_eq!(r.size(), IVec2::new(5, 1));\n    /// ```\n    #[inline]\n    pub fn size(&self) -> IVec2 {\n        self.max - self.min\n    }\n\n    /// Rectangle half-size.\n    ///\n    /// # Rounding Behavior\n    ///\n    /// If the full size contains odd numbers they will be rounded down to the nearest whole number when calculating the half size.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use bevy_math::{IRect, IVec2};\n    /// let r = IRect::new(0, 0, 4, 3); // w=4 h=3\n    /// assert_eq!(r.half_size(), IVec2::new(2, 1));\n    /// ```\n    #[inline]\n    pub fn half_size(&self) -> IVec2 {\n        self.size() / 2\n    }\n\n    /// The center point of the rectangle.\n    ///\n    /// # Rounding Behavior\n    ///\n    /// If the (min + max) contains odd numbers they will be rounded down to the nearest whole number when calculating the center.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use bevy_math::{IRect, IVec2};\n    /// let r = IRect::new(0, 0, 5, 2); // w=5 h=2\n    /// assert_eq!(r.center(), IVec2::new(2, 1));\n    /// ```\n    #[inline]\n    pub fn center(&self) -> IVec2 {\n        (self.min + self.max) / 2\n    }\n\n    /// Check if a point lies within this rectangle, inclusive of its edges.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use bevy_math::IRect;\n    /// let r = IRect::new(0, 0, 5, 1); // w=5 h=1\n    /// assert!(r.contains(r.center()));\n    /// assert!(r.contains(r.min));\n    /// assert!(r.contains(r.max));\n    /// ```\n    #[inline]\n    pub fn contains(&self, point: IVec2) -> bool {\n        (point.cmpge(self.min) & point.cmple(self.max)).all()\n    }\n\n    /// Build a new rectangle formed of the union of this rectangle and another rectangle.\n    ///\n    /// The union is the smallest rectangle enclosing both rectangles.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use bevy_math::{IRect, IVec2};\n    /// let r1 = IRect::new(0, 0, 5, 1); // w=5 h=1\n    /// let r2 = IRect::new(1, -1, 3, 3); // w=2 h=4\n    /// let r = r1.union(r2);\n    /// assert_eq!(r.min, IVec2::new(0, -1));\n    /// assert_eq!(r.max, IVec2::new(5, 3));\n    /// ```\n    #[inline]\n    pub fn union(&self, other: Self) -> Self {\n        Self {\n            min: self.min.min(other.min),\n            max: self.max.max(other.max),\n        }\n    }\n\n    /// Build a new rectangle formed of the union of this rectangle and a point.\n    ///\n    /// The union is the smallest rectangle enclosing both the rectangle and the point. If the\n    /// point is already inside the rectangle, this method returns a copy of the rectangle.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use bevy_math::{IRect, IVec2};\n    /// let r = IRect::new(0, 0, 5, 1); // w=5 h=1\n    /// let u = r.union_point(IVec2::new(3, 6));\n    /// assert_eq!(u.min, IVec2::ZERO);\n    /// assert_eq!(u.max, IVec2::new(5, 6));\n    /// ```\n    #[inline]\n    pub fn union_point(&self, other: IVec2) -> Self {\n        Self {\n            min: self.min.min(other),\n            max: self.max.max(other),\n        }\n    }\n\n    /// Build a new rectangle formed of the intersection of this rectangle and another rectangle.\n    ///\n    /// The intersection is the largest rectangle enclosed in both rectangles. If the intersection\n    /// is empty, this method returns an empty rectangle ([`IRect::is_empty()`] returns `true`), but\n    /// the actual values of [`IRect::min`] and [`IRect::max`] are implementation-dependent.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use bevy_math::{IRect, IVec2};\n    /// let r1 = IRect::new(0, 0, 5, 1); // w=5 h=1\n    /// let r2 = IRect::new(1, -1, 3, 3); // w=2 h=4\n    /// let r = r1.intersect(r2);\n    /// assert_eq!(r.min, IVec2::new(1, 0));\n    /// assert_eq!(r.max, IVec2::new(3, 1));\n    /// ```\n    #[inline]\n    pub fn intersect(&self, other: Self) -> Self {\n        let mut r = Self {\n            min: self.min.max(other.min),\n            max: self.max.min(other.max),\n        };\n        // Collapse min over max to enforce invariants and ensure e.g. width() or\n        // height() never return a negative value.\n        r.min = r.min.min(r.max);\n        r\n    }\n\n    /// Create a new rectangle by expanding it evenly on all sides.\n    ///\n    /// A positive expansion value produces a larger rectangle,\n    /// while a negative expansion value produces a smaller rectangle.\n    /// If this would result in zero or negative width or height, [`IRect::EMPTY`] is returned instead.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use bevy_math::{IRect, IVec2};\n    /// let r = IRect::new(0, 0, 5, 1); // w=5 h=1\n    /// let r2 = r.inflate(3); // w=11 h=7\n    /// assert_eq!(r2.min, IVec2::splat(-3));\n    /// assert_eq!(r2.max, IVec2::new(8, 4));\n    ///\n    /// let r = IRect::new(0, -1, 4, 3); // w=4 h=4\n    /// let r2 = r.inflate(-1); // w=2 h=2\n    /// assert_eq!(r2.min, IVec2::new(1, 0));\n    /// assert_eq!(r2.max, IVec2::new(3, 2));\n    /// ```\n    #[inline]\n    pub fn inflate(&self, expansion: i32) -> Self {\n        let mut r = Self {\n            min: self.min - expansion,\n            max: self.max + expansion,\n        };\n        // Collapse min over max to enforce invariants and ensure e.g. width() or\n        // height() never return a negative value.\n        r.min = r.min.min(r.max);\n        r\n    }\n\n    /// Returns self as [`Rect`] (f32)\n    #[inline]\n    pub fn as_rect(&self) -> Rect {\n        Rect::from_corners(self.min.as_vec2(), self.max.as_vec2())\n    }\n\n    /// Returns self as [`URect`] (u32)\n    #[inline]\n    pub fn as_urect(&self) -> URect {\n        URect::from_corners(self.min.as_uvec2(), self.max.as_uvec2())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn well_formed() {\n        let r = IRect::from_center_size(IVec2::new(3, -5), IVec2::new(8, 12));\n\n        assert_eq!(r.min, IVec2::new(-1, -11));\n        assert_eq!(r.max, IVec2::new(7, 1));\n\n        assert_eq!(r.center(), IVec2::new(3, -5));\n\n        assert_eq!(r.width().abs(), 8);\n        assert_eq!(r.height().abs(), 12);\n        assert_eq!(r.size(), IVec2::new(8, 12));\n        assert_eq!(r.half_size(), IVec2::new(4, 6));\n\n        assert!(r.contains(IVec2::new(3, -5)));\n        assert!(r.contains(IVec2::new(-1, -10)));\n        assert!(r.contains(IVec2::new(-1, 0)));\n        assert!(r.contains(IVec2::new(7, -10)));\n        assert!(r.contains(IVec2::new(7, 0)));\n        assert!(!r.contains(IVec2::new(50, -5)));\n    }\n\n    #[test]\n    fn rect_union() {\n        let r = IRect::from_center_size(IVec2::ZERO, IVec2::splat(4)); // [-2, -2] - [2, 2]\n\n        // overlapping\n        let r2 = IRect {\n            min: IVec2::new(1, 1),\n            max: IVec2::new(3, 3),\n        };\n        let u = r.union(r2);\n        assert_eq!(u.min, IVec2::new(-2, -2));\n        assert_eq!(u.max, IVec2::new(3, 3));\n\n        // disjoint\n        let r2 = IRect {\n            min: IVec2::new(1, 4),\n            max: IVec2::new(4, 6),\n        };\n        let u = r.union(r2);\n        assert_eq!(u.min, IVec2::new(-2, -2));\n        assert_eq!(u.max, IVec2::new(4, 6));\n\n        // included\n        let r2 = IRect::from_center_size(IVec2::ZERO, IVec2::splat(2));\n        let u = r.union(r2);\n        assert_eq!(u.min, r.min);\n        assert_eq!(u.max, r.max);\n\n        // including\n        let r2 = IRect::from_center_size(IVec2::ZERO, IVec2::splat(6));\n        let u = r.union(r2);\n        assert_eq!(u.min, r2.min);\n        assert_eq!(u.min, r2.min);\n    }\n\n    #[test]\n    fn rect_union_pt() {\n        let r = IRect::from_center_size(IVec2::ZERO, IVec2::splat(4)); // [-2,-2] - [2,2]\n\n        // inside\n        let v = IVec2::new(1, -1);\n        let u = r.union_point(v);\n        assert_eq!(u.min, r.min);\n        assert_eq!(u.max, r.max);\n\n        // outside\n        let v = IVec2::new(10, -3);\n        let u = r.union_point(v);\n        assert_eq!(u.min, IVec2::new(-2, -3));\n        assert_eq!(u.max, IVec2::new(10, 2));\n    }\n\n    #[test]\n    fn rect_intersect() {\n        let r = IRect::from_center_size(IVec2::ZERO, IVec2::splat(8)); // [-4,-4] - [4,4]\n\n        // overlapping\n        let r2 = IRect {\n            min: IVec2::new(2, 2),\n            max: IVec2::new(6, 6),\n        };\n        let u = r.intersect(r2);\n        assert_eq!(u.min, IVec2::new(2, 2));\n        assert_eq!(u.max, IVec2::new(4, 4));\n\n        // disjoint\n        let r2 = IRect {\n            min: IVec2::new(-8, -2),\n            max: IVec2::new(-6, 2),\n        };\n        let u = r.intersect(r2);\n        assert!(u.is_empty());\n        assert_eq!(u.width(), 0);\n\n        // included\n        let r2 = IRect::from_center_size(IVec2::ZERO, IVec2::splat(2));\n        let u = r.intersect(r2);\n        assert_eq!(u.min, r2.min);\n        assert_eq!(u.max, r2.max);\n\n        // including\n        let r2 = IRect::from_center_size(IVec2::ZERO, IVec2::splat(10));\n        let u = r.intersect(r2);\n        assert_eq!(u.min, r.min);\n        assert_eq!(u.max, r.max);\n    }\n\n    #[test]\n    fn rect_inflate() {\n        let r = IRect::from_center_size(IVec2::ZERO, IVec2::splat(4)); // [-2,-2] - [2,2]\n\n        let r2 = r.inflate(2);\n        assert_eq!(r2.min, IVec2::new(-4, -4));\n        assert_eq!(r2.max, IVec2::new(4, 4));\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "e789f51f633dc09431be6ffc3be721aa1e4cb35d",
    "func": "use getting_started_step_3_sqlite::*;\nuse std::io::{stdin, Read};\n\nfn main() {\n    let connection = &mut establish_connection();\n\n    println!(\"What would you like your title to be?\");\n    let mut title = String::new();\n    stdin().read_line(&mut title).unwrap();\n    let title = &title[..(title.len() - 1)]; // Drop the newline character\n    println!(\"\\nOk! Let's write {title} (Press {EOF} when finished)\\n\",);\n    let mut body = String::new();\n    stdin().read_to_string(&mut body).unwrap();\n\n    let _ = create_post(connection, title, &body);\n    println!(\"\\nSaved draft {title}\");\n}\n\n#[cfg(not(windows))]\nconst EOF: &str = \"CTRL+D\";\n\n#[cfg(windows)]\nconst EOF: &str = \"CTRL+Z\";\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "e109f24c554b3251b4625e1c3cb4a447ceb228fc",
    "func": "//! Dioxus SSR uses the design of templates to cache as much as possible about the HTML a block of rsx can render.\n//!\n//! The structure of templates can tell us what segments are rendered where and lets us cache segments in the output string.\n//!\n//! For example, in this code, we can cache the whole render:\n//! ```rust, no_run\n//! use dioxus::prelude::*;\n//! rsx! {\n//!     div {\n//!         \"Hello world\"\n//!     }\n//! };\n//! ```\n//! Because everything exists in the template, we can calculate the whole HTML for the template once and then reuse it.\n//! ```html\n//! <div>Hello world</div>\n//! ```\n//!\n//! If the template is more complex, we can only cache the parts that are static. In this case, we can cache `<div width=\"100px\">` and `</div>`, but not the child text.\n//!\n//! ```rust, no_run\n//! use dioxus::prelude::*;\n//! let dynamic = 123;\n//! rsx! {\n//!     div {\n//!         width: \"100px\",\n//!         \"{dynamic}\"\n//!     }\n//! };\n//!```\n\nuse dioxus_core::prelude::*;\nuse std::{fmt::Write, ops::AddAssign};\n\nuse crate::renderer::{str_truthy, BOOL_ATTRS};\n\n#[derive(Debug)]\npub(crate) struct StringCache {\n    pub segments: Vec<Segment>,\n}\n\n#[derive(Default)]\npub struct StringChain {\n    // If we should add new static text to the last segment\n    // This will be true if the last segment is a static text and the last text isn't part of a hydration only boundary\n    add_text_to_last_segment: bool,\n    segments: Vec<Segment>,\n}\n\nimpl StringChain {\n    /// Add segments but only when hydration is enabled\n    fn if_hydration_enabled<O>(\n        &mut self,\n        during_prerender: impl FnOnce(&mut StringChain) -> O,\n    ) -> O {\n        // Insert a placeholder jump to the end of the hydration only segments\n        let jump_index = self.segments.len();\n        *self += Segment::HydrationOnlySection(0);\n        let out = during_prerender(self);\n        // Go back and fill in where the placeholder jump should skip to\n        let after_hydration_only_section = self.segments.len();\n        // Don't add any text to static text in the hydration only section. This would cause the text to be skipped during non-hydration renders\n        self.add_text_to_last_segment = false;\n        self.segments[jump_index] = Segment::HydrationOnlySection(after_hydration_only_section);\n        out\n    }\n\n    /// Add a new segment\n    pub fn push(&mut self, segment: Segment) {\n        self.add_text_to_last_segment = matches!(segment, Segment::PreRendered(_));\n        self.segments.push(segment);\n    }\n}\n\nimpl AddAssign<Segment> for StringChain {\n    fn add_assign(&mut self, rhs: Segment) {\n        self.push(rhs)\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]\npub(crate) enum Segment {\n    /// A marker for where to insert an attribute with a given index\n    Attr(usize),\n    /// A marker for where to insert a node with a given index\n    Node(usize),\n    /// Text that we know is static in the template that is pre-rendered\n    PreRendered(String),\n    /// Anything between this and the segments at the index is only required for hydration. If you don't need to hydrate, you can safely skip to the section at the given index\n    HydrationOnlySection(usize),\n    /// A marker for where to insert a dynamic styles\n    StyleMarker {\n        // If the marker is inside a style tag or not\n        // This will be true if there are static styles\n        inside_style_tag: bool,\n    },\n    /// A marker for where to insert a dynamic inner html\n    InnerHtmlMarker,\n    /// A marker for where to insert a node id for an attribute\n    AttributeNodeMarker,\n    /// A marker for where to insert a node id for a root node\n    RootNodeMarker,\n}\n\nimpl std::fmt::Write for StringChain {\n    fn write_str(&mut self, s: &str) -> std::fmt::Result {\n        if self.add_text_to_last_segment {\n            match self.segments.last_mut() {\n                Some(Segment::PreRendered(s2)) => s2.push_str(s),\n                _ => unreachable!(),\n            }\n        } else {\n            self.segments.push(Segment::PreRendered(s.to_string()))\n        }\n\n        self.add_text_to_last_segment = true;\n\n        Ok(())\n    }\n}\n\nimpl StringCache {\n    /// Create a new string cache from a template. This intentionally does not include any settings about the render mode (hydration or not) so that we can reuse the cache for both hydration and non-hydration renders.\n    pub fn from_template(template: &VNode) -> Result<Self, std::fmt::Error> {\n        let mut chain = StringChain::default();\n\n        let mut cur_path = vec![];\n\n        for (root_idx, root) in template.template.roots.iter().enumerate() {\n            from_template_recursive(root, &mut cur_path, root_idx, true, &mut chain)?;\n        }\n\n        Ok(Self {\n            segments: chain.segments,\n        })\n    }\n}\n\nfn from_template_recursive(\n    root: &TemplateNode,\n    cur_path: &mut Vec<usize>,\n    root_idx: usize,\n    is_root: bool,\n    chain: &mut StringChain,\n) -> Result<(), std::fmt::Error> {\n    match root {\n        TemplateNode::Element {\n            tag,\n            attrs,\n            children,\n            ..\n        } => {\n            cur_path.push(root_idx);\n            write!(chain, \"<{tag}\")?;\n            // we need to collect the styles and write them at the end\n            let mut styles = Vec::new();\n            // we need to collect the inner html and write it at the end\n            let mut inner_html = None;\n            // we need to keep track of if we have dynamic attrs to know if we need to insert a style and inner_html marker\n            let mut has_dyn_attrs = false;\n            for attr in *attrs {\n                match attr {\n                    TemplateAttribute::Static {\n                        name,\n                        value,\n                        namespace,\n                    } => {\n                        if *name == \"dangerous_inner_html\" {\n                            inner_html = Some(value);\n                        } else if let Some(\"style\") = namespace {\n                            styles.push((name, value));\n                        } else if BOOL_ATTRS.contains(name) {\n                            if str_truthy(value) {\n                                write!(chain, \" {name}=\\\"{value}\\\"\",)?;\n                            }\n                        } else {\n                            write!(chain, \" {name}=\\\"{value}\\\"\")?;\n                        }\n                    }\n                    TemplateAttribute::Dynamic { id: index } => {\n                        let index = *index;\n                        *chain += Segment::Attr(index);\n                        has_dyn_attrs = true\n                    }\n                }\n            }\n\n            // write the styles\n            if !styles.is_empty() {\n                write!(chain, \" style=\\\"\")?;\n                for (name, value) in styles {\n                    write!(chain, \"{name}:{value};\")?;\n                }\n                *chain += Segment::StyleMarker {\n                    inside_style_tag: true,\n                };\n                write!(chain, \"\\\"\")?;\n            } else if has_dyn_attrs {\n                *chain += Segment::StyleMarker {\n                    inside_style_tag: false,\n                };\n            }\n\n            // write the id if we are prerendering and this is either a root node or a node with a dynamic attribute\n            if has_dyn_attrs || is_root {\n                chain.if_hydration_enabled(|chain| {\n                    write!(chain, \" data-node-hydration=\\\"\")?;\n                    if has_dyn_attrs {\n                        *chain += Segment::AttributeNodeMarker;\n                    } else if is_root {\n                        *chain += Segment::RootNodeMarker;\n                    }\n                    write!(chain, \"\\\"\")?;\n                    std::fmt::Result::Ok(())\n                })?;\n            }\n\n            if children.is_empty() && tag_is_self_closing(tag) {\n                write!(chain, \"/>\")?;\n            } else {\n                write!(chain, \">\")?;\n                // Write the static inner html, or insert a marker if dynamic inner html is possible\n                if let Some(inner_html) = inner_html {\n                    chain.write_str(inner_html)?;\n                } else if has_dyn_attrs {\n                    *chain += Segment::InnerHtmlMarker;\n                }\n\n                for child in *children {\n                    from_template_recursive(child, cur_path, root_idx, false, chain)?;\n                }\n                write!(chain, \"</{tag}>\")?;\n            }\n            cur_path.pop();\n        }\n        TemplateNode::Text { text } => {\n            // write the id if we are prerendering and this is a root node that may need to be removed in the future\n            if is_root {\n                chain.if_hydration_enabled(|chain| {\n                    write!(chain, \"<!--node-id\")?;\n                    *chain += Segment::RootNodeMarker;\n                    write!(chain, \"-->\")?;\n                    std::fmt::Result::Ok(())\n                })?;\n            }\n            write!(\n                chain,\n                \"{}\",\n                askama_escape::escape(text, askama_escape::Html)\n            )?;\n            if is_root {\n                chain.if_hydration_enabled(|chain| write!(chain, \"<!--#-->\"))?;\n            }\n        }\n        TemplateNode::Dynamic { id: idx } => *chain += Segment::Node(*idx),\n    }\n\n    Ok(())\n}\n\nfn tag_is_self_closing(tag: &str) -> bool {\n    matches!(\n        tag,\n        \"area\"\n            | \"base\"\n            | \"br\"\n            | \"col\"\n            | \"embed\"\n            | \"hr\"\n            | \"img\"\n            | \"input\"\n            | \"link\"\n            | \"meta\"\n            | \"param\"\n            | \"source\"\n            | \"track\"\n            | \"wbr\"\n    )\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "2a22d5a1f4b25c84e5262e3d1bcb273b1ff1c17c",
    "func": "use super::m20220118_000001_create_cake_table::Cake;\nuse sea_orm_migration::sea_orm::DbBackend;\nuse sea_orm_migration::{prelude::*, schema::*};\n\n#[derive(DeriveMigrationName)]\npub struct Migration;\n\n#[async_trait::async_trait]\nimpl MigrationTrait for Migration {\n    async fn up(&self, manager: &SchemaManager) -> Result<(), DbErr> {\n        manager\n            .create_table(\n                Table::create()\n                    .table(Fruit::Table)\n                    .col(pk_auto(Fruit::Id))\n                    .col(string(Fruit::Name))\n                    .col(integer(Fruit::CakeId))\n                    .foreign_key(\n                        ForeignKey::create()\n                            .name(\"fk-fruit-cake_id\")\n                            .from(Fruit::Table, Fruit::CakeId)\n                            .to(Cake::Table, Cake::Id),\n                    )\n                    .to_owned(),\n            )\n            .await\n    }\n\n    async fn down(&self, manager: &SchemaManager) -> Result<(), DbErr> {\n        if manager.get_database_backend() != DbBackend::Sqlite {\n            manager\n                .drop_foreign_key(\n                    ForeignKey::drop()\n                        .table(Fruit::Table)\n                        .name(\"fk-fruit-cake_id\")\n                        .to_owned(),\n                )\n                .await?;\n        }\n        manager\n            .drop_table(Table::drop().table(Fruit::Table).to_owned())\n            .await\n    }\n}\n\n#[derive(DeriveIden)]\npub enum Fruit {\n    Table,\n    Id,\n    Name,\n    CakeId,\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "6953a8e6717e674bb47d3ac1dd764946df9438cf",
    "func": "extern crate libsqlite3_sys as ffi;\n\nuse super::raw::RawConnection;\nuse super::row::PrivateSqliteRow;\nuse super::{Sqlite, SqliteAggregateFunction, SqliteBindValue};\nuse crate::backend::Backend;\nuse crate::deserialize::{FromSqlRow, StaticallySizedRow};\nuse crate::result::{DatabaseErrorKind, Error, QueryResult};\nuse crate::row::{Field, PartialRow, Row, RowIndex, RowSealed};\nuse crate::serialize::{IsNull, Output, ToSql};\nuse crate::sql_types::HasSqlType;\nuse crate::sqlite::connection::bind_collector::InternalSqliteBindValue;\nuse crate::sqlite::connection::sqlite_value::OwnedSqliteValue;\nuse crate::sqlite::SqliteValue;\nuse std::cell::{Ref, RefCell};\nuse std::marker::PhantomData;\nuse std::mem::ManuallyDrop;\nuse std::ops::DerefMut;\nuse std::rc::Rc;\n\npub(super) fn register<ArgsSqlType, RetSqlType, Args, Ret, F>(\n    conn: &RawConnection,\n    fn_name: &str,\n    deterministic: bool,\n    mut f: F,\n) -> QueryResult<()>\nwhere\n    F: FnMut(&RawConnection, Args) -> Ret + std::panic::UnwindSafe + Send + 'static,\n    Args: FromSqlRow<ArgsSqlType, Sqlite> + StaticallySizedRow<ArgsSqlType, Sqlite>,\n    Ret: ToSql<RetSqlType, Sqlite>,\n    Sqlite: HasSqlType<RetSqlType>,\n{\n    let fields_needed = Args::FIELD_COUNT;\n    if fields_needed > 127 {\n        return Err(Error::DatabaseError(\n            DatabaseErrorKind::UnableToSendCommand,\n            Box::new(\"SQLite functions cannot take more than 127 parameters\".to_string()),\n        ));\n    }\n\n    conn.register_sql_function(fn_name, fields_needed, deterministic, move |conn, args| {\n        let args = build_sql_function_args::<ArgsSqlType, Args>(args)?;\n\n        Ok(f(conn, args))\n    })?;\n    Ok(())\n}\n\npub(super) fn register_noargs<RetSqlType, Ret, F>(\n    conn: &RawConnection,\n    fn_name: &str,\n    deterministic: bool,\n    mut f: F,\n) -> QueryResult<()>\nwhere\n    F: FnMut() -> Ret + std::panic::UnwindSafe + Send + 'static,\n    Ret: ToSql<RetSqlType, Sqlite>,\n    Sqlite: HasSqlType<RetSqlType>,\n{\n    conn.register_sql_function(fn_name, 0, deterministic, move |_, _| Ok(f()))?;\n    Ok(())\n}\n\npub(super) fn register_aggregate<ArgsSqlType, RetSqlType, Args, Ret, A>(\n    conn: &RawConnection,\n    fn_name: &str,\n) -> QueryResult<()>\nwhere\n    A: SqliteAggregateFunction<Args, Output = Ret> + 'static + Send + std::panic::UnwindSafe,\n    Args: FromSqlRow<ArgsSqlType, Sqlite> + StaticallySizedRow<ArgsSqlType, Sqlite>,\n    Ret: ToSql<RetSqlType, Sqlite>,\n    Sqlite: HasSqlType<RetSqlType>,\n{\n    let fields_needed = Args::FIELD_COUNT;\n    if fields_needed > 127 {\n        return Err(Error::DatabaseError(\n            DatabaseErrorKind::UnableToSendCommand,\n            Box::new(\"SQLite functions cannot take more than 127 parameters\".to_string()),\n        ));\n    }\n\n    conn.register_aggregate_function::<ArgsSqlType, RetSqlType, Args, Ret, A>(\n        fn_name,\n        fields_needed,\n    )?;\n\n    Ok(())\n}\n\npub(super) fn build_sql_function_args<ArgsSqlType, Args>(\n    args: &mut [*mut ffi::sqlite3_value],\n) -> Result<Args, Error>\nwhere\n    Args: FromSqlRow<ArgsSqlType, Sqlite>,\n{\n    let row = FunctionRow::new(args);\n    Args::build_from_row(&row).map_err(Error::DeserializationError)\n}\n\n// clippy is wrong here, the let binding is required\n// for lifetime reasons\n#[allow(clippy::let_unit_value)]\npub(super) fn process_sql_function_result<RetSqlType, Ret>(\n    result: &'_ Ret,\n) -> QueryResult<InternalSqliteBindValue<'_>>\nwhere\n    Ret: ToSql<RetSqlType, Sqlite>,\n    Sqlite: HasSqlType<RetSqlType>,\n{\n    let mut metadata_lookup = ();\n    let value = SqliteBindValue {\n        inner: InternalSqliteBindValue::Null,\n    };\n    let mut buf = Output::new(value, &mut metadata_lookup);\n    let is_null = result.to_sql(&mut buf).map_err(Error::SerializationError)?;\n\n    if let IsNull::Yes = is_null {\n        Ok(InternalSqliteBindValue::Null)\n    } else {\n        Ok(buf.into_inner().inner)\n    }\n}\n\nstruct FunctionRow<'a> {\n    // we use `ManuallyDrop` to prevent dropping the content of the internal vector\n    // as this buffer is owned by sqlite not by diesel\n    args: Rc<RefCell<ManuallyDrop<PrivateSqliteRow<'a, 'static>>>>,\n    field_count: usize,\n    marker: PhantomData<&'a ffi::sqlite3_value>,\n}\n\nimpl<'a> Drop for FunctionRow<'a> {\n    #[allow(unsafe_code)] // manual drop calls\n    fn drop(&mut self) {\n        if let Some(args) = Rc::get_mut(&mut self.args) {\n            if let PrivateSqliteRow::Duplicated { column_names, .. } =\n                DerefMut::deref_mut(RefCell::get_mut(args))\n            {\n                if Rc::strong_count(column_names) == 1 {\n                    // According the https://doc.rust-lang.org/std/mem/struct.ManuallyDrop.html#method.drop\n                    // it's fine to just drop the values here\n                    unsafe { std::ptr::drop_in_place(column_names as *mut _) }\n                }\n            }\n        }\n    }\n}\n\nimpl<'a> FunctionRow<'a> {\n    #[allow(unsafe_code)] // complicated ptr cast\n    fn new(args: &mut [*mut ffi::sqlite3_value]) -> Self {\n        let lengths = args.len();\n        let args = unsafe {\n            Vec::from_raw_parts(\n                // This cast is safe because:\n                // * Casting from a pointer to an array to a pointer to the first array\n                // element is safe\n                // * Casting from a raw pointer to `NonNull<T>` is safe,\n                // because `NonNull` is #[repr(transparent)]\n                // * Casting from `NonNull<T>` to `OwnedSqliteValue` is safe,\n                // as the struct is `#[repr(transparent)]\n                // * Casting from `NonNull<T>` to `Option<NonNull<T>>` as the documentation\n                // states: \"This is so that enums may use this forbidden value as a discriminant \u2013\n                // Option<NonNull<T>> has the same size as *mut T\"\n                // * The last point remains true for `OwnedSqliteValue` as `#[repr(transparent)]\n                // guarantees the same layout as the inner type\n                // * It's unsafe to drop the vector (and the vector elements)\n                // because of this we wrap the vector (or better the Row)\n                // Into `ManualDrop` to prevent the dropping\n                args as *mut [*mut ffi::sqlite3_value] as *mut ffi::sqlite3_value\n                    as *mut Option<OwnedSqliteValue>,\n                lengths,\n                lengths,\n            )\n        };\n\n        Self {\n            field_count: lengths,\n            args: Rc::new(RefCell::new(ManuallyDrop::new(\n                PrivateSqliteRow::Duplicated {\n                    values: args,\n                    column_names: Rc::from(vec![None; lengths]),\n                },\n            ))),\n            marker: PhantomData,\n        }\n    }\n}\n\nimpl RowSealed for FunctionRow<'_> {}\n\nimpl<'a> Row<'a, Sqlite> for FunctionRow<'a> {\n    type Field<'f> = FunctionArgument<'f> where 'a: 'f, Self: 'f;\n    type InnerPartialRow = Self;\n\n    fn field_count(&self) -> usize {\n        self.field_count\n    }\n\n    fn get<'b, I>(&'b self, idx: I) -> Option<Self::Field<'b>>\n    where\n        'a: 'b,\n        Self: crate::row::RowIndex<I>,\n    {\n        let col_idx = self.idx(idx)?;\n        Some(FunctionArgument {\n            args: self.args.borrow(),\n            col_idx,\n        })\n    }\n\n    fn partial_row(&self, range: std::ops::Range<usize>) -> PartialRow<'_, Self::InnerPartialRow> {\n        PartialRow::new(self, range)\n    }\n}\n\nimpl<'a> RowIndex<usize> for FunctionRow<'a> {\n    fn idx(&self, idx: usize) -> Option<usize> {\n        if idx < self.field_count() {\n            Some(idx)\n        } else {\n            None\n        }\n    }\n}\n\nimpl<'a, 'b> RowIndex<&'a str> for FunctionRow<'b> {\n    fn idx(&self, _idx: &'a str) -> Option<usize> {\n        None\n    }\n}\n\nstruct FunctionArgument<'a> {\n    args: Ref<'a, ManuallyDrop<PrivateSqliteRow<'a, 'static>>>,\n    col_idx: usize,\n}\n\nimpl<'a> Field<'a, Sqlite> for FunctionArgument<'a> {\n    fn field_name(&self) -> Option<&str> {\n        None\n    }\n\n    fn is_null(&self) -> bool {\n        self.value().is_none()\n    }\n\n    fn value(&self) -> Option<<Sqlite as Backend>::RawValue<'_>> {\n        SqliteValue::new(\n            Ref::map(Ref::clone(&self.args), |drop| std::ops::Deref::deref(drop)),\n            self.col_idx,\n        )\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "883eff18c84839406210842dae93aa1acc8020f0",
    "func": "use crate::io::util::read_line::finish_string_read;\nuse crate::io::util::read_to_end::read_to_end_internal;\nuse crate::io::util::vec_with_initialized::VecWithInitialized;\nuse crate::io::AsyncRead;\n\nuse pin_project_lite::pin_project;\nuse std::future::Future;\nuse std::marker::PhantomPinned;\nuse std::pin::Pin;\nuse std::task::{ready, Context, Poll};\nuse std::{io, mem};\n\npin_project! {\n    /// Future for the [`read_to_string`](super::AsyncReadExt::read_to_string) method.\n    #[derive(Debug)]\n    #[must_use = \"futures do nothing unless you `.await` or poll them\"]\n    pub struct ReadToString<'a, R: ?Sized> {\n        reader: &'a mut R,\n        // This is the buffer we were provided. It will be replaced with an empty string\n        // while reading to postpone utf-8 handling until after reading.\n        output: &'a mut String,\n        // The actual allocation of the string is moved into this vector instead.\n        buf: VecWithInitialized<Vec<u8>>,\n        // The number of bytes appended to buf. This can be less than buf.len() if\n        // the buffer was not empty when the operation was started.\n        read: usize,\n        // Make this future `!Unpin` for compatibility with async trait methods.\n        #[pin]\n        _pin: PhantomPinned,\n    }\n}\n\npub(crate) fn read_to_string<'a, R>(\n    reader: &'a mut R,\n    string: &'a mut String,\n) -> ReadToString<'a, R>\nwhere\n    R: AsyncRead + ?Sized + Unpin,\n{\n    let buf = mem::take(string).into_bytes();\n    ReadToString {\n        reader,\n        buf: VecWithInitialized::new(buf),\n        output: string,\n        read: 0,\n        _pin: PhantomPinned,\n    }\n}\n\nfn read_to_string_internal<R: AsyncRead + ?Sized>(\n    reader: Pin<&mut R>,\n    output: &mut String,\n    buf: &mut VecWithInitialized<Vec<u8>>,\n    read: &mut usize,\n    cx: &mut Context<'_>,\n) -> Poll<io::Result<usize>> {\n    let io_res = ready!(read_to_end_internal(buf, reader, read, cx));\n    let utf8_res = String::from_utf8(buf.take());\n\n    // At this point both buf and output are empty. The allocation is in utf8_res.\n\n    debug_assert!(buf.is_empty());\n    debug_assert!(output.is_empty());\n    finish_string_read(io_res, utf8_res, *read, output, true)\n}\n\nimpl<A> Future for ReadToString<'_, A>\nwhere\n    A: AsyncRead + ?Sized + Unpin,\n{\n    type Output = io::Result<usize>;\n\n    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n        let me = self.project();\n\n        read_to_string_internal(Pin::new(*me.reader), me.output, me.buf, me.read, cx)\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "9fc7202cebc418f4b8e4f1f8bf9a542f6653103a",
    "func": "use crate::generics::impl_generic_info_methods;\nuse crate::{\n    attributes::{impl_custom_attribute_methods, CustomAttributes},\n    type_info::impl_type_methods,\n    DynamicEnum, Generics, PartialReflect, Type, TypePath, VariantInfo, VariantType,\n};\nuse alloc::sync::Arc;\nuse bevy_utils::HashMap;\nuse core::slice::Iter;\n\n/// A trait used to power [enum-like] operations via [reflection].\n///\n/// This allows enums to be processed and modified dynamically at runtime without\n/// necessarily knowing the actual type.\n/// Enums are much more complex than their struct counterparts.\n/// As a result, users will need to be mindful of conventions, considerations,\n/// and complications when working with this trait.\n///\n/// # Variants\n///\n/// An enum is a set of choices called _variants_.\n/// An instance of an enum can only exist as one of these choices at any given time.\n/// Consider Rust's [`Option<T>`]. It's an enum with two variants: [`None`] and [`Some`].\n/// If you're `None`, you can't be `Some` and vice versa.\n///\n/// > \u26a0\ufe0f __This is very important:__\n/// > The [`Enum`] trait represents an enum _as one of its variants_.\n/// > It does not represent the entire enum since that's not true to how enums work.\n///\n/// Variants come in a few [flavors](VariantType):\n///\n/// | Variant Type | Syntax                         |\n/// | ------------ | ------------------------------ |\n/// | Unit         | `MyEnum::Foo`                  |\n/// | Tuple        | `MyEnum::Foo( i32, i32 )`      |\n/// | Struct       | `MyEnum::Foo{ value: String }` |\n///\n/// As you can see, a unit variant contains no fields, while tuple and struct variants\n/// can contain one or more fields.\n/// The fields in a tuple variant is defined by their _order_ within the variant.\n/// Index `0` represents the first field in the variant and so on.\n/// Fields in struct variants (excluding tuple structs), on the other hand, are\n/// represented by a _name_.\n///\n/// # Implementation\n///\n/// > \ud83d\udca1 This trait can be automatically implemented using [`#[derive(Reflect)]`](derive@crate::Reflect)\n/// > on an enum definition.\n///\n/// Despite the fact that enums can represent multiple states, traits only exist in one state\n/// and must be applied to the entire enum rather than a particular variant.\n/// Because of this limitation, the [`Enum`] trait must not only _represent_ any of the\n/// three variant types, but also define the _methods_ for all three as well.\n///\n/// What does this mean? It means that even though a unit variant contains no fields, a\n/// representation of that variant using the [`Enum`] trait will still contain methods for\n/// accessing fields!\n/// Again, this is to account for _all three_ variant types.\n///\n/// We recommend using the built-in [`#[derive(Reflect)]`](derive@crate::Reflect) macro to automatically handle all the\n/// implementation details for you.\n/// However, if you _must_ implement this trait manually, there are a few things to keep in mind...\n///\n/// ## Field Order\n///\n/// While tuple variants identify their fields by the order in which they are defined, struct\n/// variants identify fields by their name.\n/// However, both should allow access to fields by their defined order.\n///\n/// The reason all fields, regardless of variant type, need to be accessible by their order is\n/// due to field iteration.\n/// We need a way to iterate through each field in a variant, and the easiest way of achieving\n/// that is through the use of field order.\n///\n/// The derive macro adds proper struct variant handling for [`Enum::index_of`], [`Enum::name_at`]\n/// and [`Enum::field_at[_mut]`](Enum::field_at) methods.\n/// The first two methods are __required__ for all struct variant types.\n/// By convention, implementors should also handle the last method as well, but this is not\n/// a strict requirement.\n///\n/// ## Field Names\n///\n/// Implementors may choose to handle [`Enum::index_of`], [`Enum::name_at`], and\n/// [`Enum::field[_mut]`](Enum::field) for tuple variants by considering stringified `usize`s to be\n/// valid names (such as `\"3\"`).\n/// This isn't wrong to do, but the convention set by the derive macro is that it isn't supported.\n/// It's preferred that these strings be converted to their proper `usize` representations and\n/// the [`Enum::field_at[_mut]`](Enum::field_at) methods be used instead.\n///\n/// [enum-like]: https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html\n/// [reflection]: crate\n/// [`None`]: Option<T>::None\n/// [`Some`]: Option<T>::Some\n/// [`Reflect`]: bevy_reflect_derive::Reflect\npub trait Enum: PartialReflect {\n    /// Returns a reference to the value of the field (in the current variant) with the given name.\n    ///\n    /// For non-[`VariantType::Struct`] variants, this should return `None`.\n    fn field(&self, name: &str) -> Option<&dyn PartialReflect>;\n    /// Returns a reference to the value of the field (in the current variant) at the given index.\n    fn field_at(&self, index: usize) -> Option<&dyn PartialReflect>;\n    /// Returns a mutable reference to the value of the field (in the current variant) with the given name.\n    ///\n    /// For non-[`VariantType::Struct`] variants, this should return `None`.\n    fn field_mut(&mut self, name: &str) -> Option<&mut dyn PartialReflect>;\n    /// Returns a mutable reference to the value of the field (in the current variant) at the given index.\n    fn field_at_mut(&mut self, index: usize) -> Option<&mut dyn PartialReflect>;\n    /// Returns the index of the field (in the current variant) with the given name.\n    ///\n    /// For non-[`VariantType::Struct`] variants, this should return `None`.\n    fn index_of(&self, name: &str) -> Option<usize>;\n    /// Returns the name of the field (in the current variant) with the given index.\n    ///\n    /// For non-[`VariantType::Struct`] variants, this should return `None`.\n    fn name_at(&self, index: usize) -> Option<&str>;\n    /// Returns an iterator over the values of the current variant's fields.\n    fn iter_fields(&self) -> VariantFieldIter;\n    /// Returns the number of fields in the current variant.\n    fn field_len(&self) -> usize;\n    /// The name of the current variant.\n    fn variant_name(&self) -> &str;\n    /// The index of the current variant.\n    fn variant_index(&self) -> usize;\n    /// The type of the current variant.\n    fn variant_type(&self) -> VariantType;\n    // Clones the enum into a [`DynamicEnum`].\n    fn clone_dynamic(&self) -> DynamicEnum;\n    /// Returns true if the current variant's type matches the given one.\n    fn is_variant(&self, variant_type: VariantType) -> bool {\n        self.variant_type() == variant_type\n    }\n    /// Returns the full path to the current variant.\n    fn variant_path(&self) -> String {\n        format!(\"{}::{}\", self.reflect_type_path(), self.variant_name())\n    }\n\n    /// Will return `None` if [`TypeInfo`] is not available.\n    ///\n    /// [`TypeInfo`]: crate::TypeInfo\n    fn get_represented_enum_info(&self) -> Option<&'static EnumInfo> {\n        self.get_represented_type_info()?.as_enum().ok()\n    }\n}\n\n/// A container for compile-time enum info, used by [`TypeInfo`](crate::TypeInfo).\n#[derive(Clone, Debug)]\npub struct EnumInfo {\n    ty: Type,\n    generics: Generics,\n    variants: Box<[VariantInfo]>,\n    variant_names: Box<[&'static str]>,\n    variant_indices: HashMap<&'static str, usize>,\n    custom_attributes: Arc<CustomAttributes>,\n    #[cfg(feature = \"documentation\")]\n    docs: Option<&'static str>,\n}\n\nimpl EnumInfo {\n    /// Create a new [`EnumInfo`].\n    ///\n    /// # Arguments\n    ///\n    /// * `variants`: The variants of this enum in the order they are defined\n    pub fn new<TEnum: Enum + TypePath>(variants: &[VariantInfo]) -> Self {\n        let variant_indices = variants\n            .iter()\n            .enumerate()\n            .map(|(index, variant)| (variant.name(), index))\n            .collect::<HashMap<_, _>>();\n\n        let variant_names = variants.iter().map(VariantInfo::name).collect();\n\n        Self {\n            ty: Type::of::<TEnum>(),\n            generics: Generics::new(),\n            variants: variants.to_vec().into_boxed_slice(),\n            variant_names,\n            variant_indices,\n            custom_attributes: Arc::new(CustomAttributes::default()),\n            #[cfg(feature = \"documentation\")]\n            docs: None,\n        }\n    }\n\n    /// Sets the docstring for this enum.\n    #[cfg(feature = \"documentation\")]\n    pub fn with_docs(self, docs: Option<&'static str>) -> Self {\n        Self { docs, ..self }\n    }\n\n    /// Sets the custom attributes for this enum.\n    pub fn with_custom_attributes(self, custom_attributes: CustomAttributes) -> Self {\n        Self {\n            custom_attributes: Arc::new(custom_attributes),\n            ..self\n        }\n    }\n\n    /// A slice containing the names of all variants in order.\n    pub fn variant_names(&self) -> &[&'static str] {\n        &self.variant_names\n    }\n\n    /// Get a variant with the given name.\n    pub fn variant(&self, name: &str) -> Option<&VariantInfo> {\n        self.variant_indices\n            .get(name)\n            .map(|index| &self.variants[*index])\n    }\n\n    /// Get a variant at the given index.\n    pub fn variant_at(&self, index: usize) -> Option<&VariantInfo> {\n        self.variants.get(index)\n    }\n\n    /// Get the index of the variant with the given name.\n    pub fn index_of(&self, name: &str) -> Option<usize> {\n        self.variant_indices.get(name).copied()\n    }\n\n    /// Returns the full path to the given variant.\n    ///\n    /// This does _not_ check if the given variant exists.\n    pub fn variant_path(&self, name: &str) -> String {\n        format!(\"{}::{name}\", self.type_path())\n    }\n\n    /// Checks if a variant with the given name exists within this enum.\n    pub fn contains_variant(&self, name: &str) -> bool {\n        self.variant_indices.contains_key(name)\n    }\n\n    /// Iterate over the variants of this enum.\n    pub fn iter(&self) -> Iter<'_, VariantInfo> {\n        self.variants.iter()\n    }\n\n    /// The number of variants in this enum.\n    pub fn variant_len(&self) -> usize {\n        self.variants.len()\n    }\n\n    impl_type_methods!(ty);\n\n    /// The docstring of this enum, if any.\n    #[cfg(feature = \"documentation\")]\n    pub fn docs(&self) -> Option<&'static str> {\n        self.docs\n    }\n\n    impl_custom_attribute_methods!(self.custom_attributes, \"enum\");\n\n    impl_generic_info_methods!(generics);\n}\n\n/// An iterator over the fields in the current enum variant.\npub struct VariantFieldIter<'a> {\n    container: &'a dyn Enum,\n    index: usize,\n}\n\nimpl<'a> VariantFieldIter<'a> {\n    pub fn new(container: &'a dyn Enum) -> Self {\n        Self {\n            container,\n            index: 0,\n        }\n    }\n}\n\nimpl<'a> Iterator for VariantFieldIter<'a> {\n    type Item = VariantField<'a>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let value = match self.container.variant_type() {\n            VariantType::Unit => None,\n            VariantType::Tuple => Some(VariantField::Tuple(self.container.field_at(self.index)?)),\n            VariantType::Struct => {\n                let name = self.container.name_at(self.index)?;\n                Some(VariantField::Struct(name, self.container.field(name)?))\n            }\n        };\n        self.index += value.is_some() as usize;\n        value\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let size = self.container.field_len();\n        (size, Some(size))\n    }\n}\n\nimpl<'a> ExactSizeIterator for VariantFieldIter<'a> {}\n\npub enum VariantField<'a> {\n    Struct(&'a str, &'a dyn PartialReflect),\n    Tuple(&'a dyn PartialReflect),\n}\n\nimpl<'a> VariantField<'a> {\n    pub fn name(&self) -> Option<&'a str> {\n        if let Self::Struct(name, ..) = self {\n            Some(*name)\n        } else {\n            None\n        }\n    }\n\n    pub fn value(&self) -> &'a dyn PartialReflect {\n        match *self {\n            Self::Struct(_, value) | Self::Tuple(value) => value,\n        }\n    }\n}\n\n// Tests that need access to internal fields have to go here rather than in mod.rs\n#[cfg(test)]\nmod tests {\n    use crate as bevy_reflect;\n    use crate::*;\n\n    #[derive(Reflect, Debug, PartialEq)]\n    enum MyEnum {\n        A,\n        B(usize, i32),\n        C { foo: f32, bar: bool },\n    }\n    #[test]\n    fn next_index_increment() {\n        // unit enums always return none, so index should stay at 0\n        let unit_enum = MyEnum::A;\n        let mut iter = unit_enum.iter_fields();\n        let size = iter.len();\n        for _ in 0..2 {\n            assert!(iter.next().is_none());\n            assert_eq!(size, iter.index);\n        }\n        // tuple enums we iter over each value (unnamed fields), stop after that\n        let tuple_enum = MyEnum::B(0, 1);\n        let mut iter = tuple_enum.iter_fields();\n        let size = iter.len();\n        for _ in 0..2 {\n            let prev_index = iter.index;\n            assert!(iter.next().is_some());\n            assert_eq!(prev_index, iter.index - 1);\n        }\n        for _ in 0..2 {\n            assert!(iter.next().is_none());\n            assert_eq!(size, iter.index);\n        }\n\n        // struct enums, we iterate over each field in the struct\n        let struct_enum = MyEnum::C {\n            foo: 0.,\n            bar: false,\n        };\n        let mut iter = struct_enum.iter_fields();\n        let size = iter.len();\n        for _ in 0..2 {\n            let prev_index = iter.index;\n            assert!(iter.next().is_some());\n            assert_eq!(prev_index, iter.index - 1);\n        }\n        for _ in 0..2 {\n            assert!(iter.next().is_none());\n            assert_eq!(size, iter.index);\n        }\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "35916201aaa7672d76588c22e3bbc29bd5e24fd2",
    "func": "use crate::ButtonInput;\nuse bevy_ecs::system::Res;\nuse core::hash::Hash;\n\n/// Stateful run condition that can be toggled via a input press using [`ButtonInput::just_pressed`].\n///\n/// ```no_run\n/// # use bevy_app::{App, NoopPluginGroup as DefaultPlugins, Update};\n/// # use bevy_ecs::prelude::IntoSystemConfigs;\n/// # use bevy_input::{common_conditions::input_toggle_active, prelude::KeyCode};\n///\n/// fn main() {\n///     App::new()\n///         .add_plugins(DefaultPlugins)\n///         .add_systems(Update, pause_menu.run_if(input_toggle_active(false, KeyCode::Escape)))\n///         .run();\n/// }\n///\n/// fn pause_menu() {\n///     println!(\"in pause menu\");\n/// }\n/// ```\n///\n/// If you want other systems to be able to access whether the toggled state is active,\n/// you should use a custom resource or a state for that:\n/// ```no_run\n/// # use bevy_app::{App, NoopPluginGroup as DefaultPlugins, Update};\n/// # use bevy_ecs::prelude::{IntoSystemConfigs, Res, ResMut, Resource};\n/// # use bevy_input::{common_conditions::input_just_pressed, prelude::KeyCode};\n///\n/// #[derive(Resource, Default)]\n/// struct Paused(bool);\n///\n/// fn main() {\n///     App::new()\n///         .add_plugins(DefaultPlugins)\n///         .init_resource::<Paused>()\n///         .add_systems(Update, toggle_pause_state.run_if(input_just_pressed(KeyCode::Escape)))\n///         .add_systems(Update, pause_menu.run_if(|paused: Res<Paused>| paused.0))\n///         .run();\n/// }\n///\n/// fn toggle_pause_state(mut paused: ResMut<Paused>) {\n///     paused.0 = !paused.0;\n/// }\n///\n/// fn pause_menu() {\n///     println!(\"in pause menu\");\n/// }\n/// ```\npub fn input_toggle_active<T>(\n    default: bool,\n    input: T,\n) -> impl FnMut(Res<ButtonInput<T>>) -> bool + Clone\nwhere\n    T: Copy + Eq + Hash + Send + Sync + 'static,\n{\n    let mut active = default;\n    move |inputs: Res<ButtonInput<T>>| {\n        active ^= inputs.just_pressed(input);\n        active\n    }\n}\n\n/// Run condition that is active if [`ButtonInput::pressed`] is true for the given input.\npub fn input_pressed<T>(input: T) -> impl FnMut(Res<ButtonInput<T>>) -> bool + Clone\nwhere\n    T: Copy + Eq + Hash + Send + Sync + 'static,\n{\n    move |inputs: Res<ButtonInput<T>>| inputs.pressed(input)\n}\n\n/// Run condition that is active if [`ButtonInput::just_pressed`] is true for the given input.\n///\n/// ```no_run\n/// # use bevy_app::{App, NoopPluginGroup as DefaultPlugins, Update};\n/// # use bevy_ecs::prelude::IntoSystemConfigs;\n/// # use bevy_input::{common_conditions::input_just_pressed, prelude::KeyCode};\n/// fn main() {\n///     App::new()\n///         .add_plugins(DefaultPlugins)\n///         .add_systems(Update, jump.run_if(input_just_pressed(KeyCode::Space)))\n///         .run();\n/// }\n///\n/// # fn jump() {}\n/// ```\npub fn input_just_pressed<T>(input: T) -> impl FnMut(Res<ButtonInput<T>>) -> bool + Clone\nwhere\n    T: Copy + Eq + Hash + Send + Sync + 'static,\n{\n    move |inputs: Res<ButtonInput<T>>| inputs.just_pressed(input)\n}\n\n/// Run condition that is active if [`ButtonInput::just_released`] is true for the given input.\npub fn input_just_released<T>(input: T) -> impl FnMut(Res<ButtonInput<T>>) -> bool + Clone\nwhere\n    T: Copy + Eq + Hash + Send + Sync + 'static,\n{\n    move |inputs: Res<ButtonInput<T>>| inputs.just_released(input)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::prelude::KeyCode;\n    use bevy_ecs::schedule::{IntoSystemConfigs, Schedule};\n\n    fn test_system() {}\n\n    // Ensure distributive_run_if compiles with the common conditions.\n    #[test]\n    fn distributive_run_if_compiles() {\n        Schedule::default().add_systems(\n            (test_system, test_system)\n                .distributive_run_if(input_toggle_active(false, KeyCode::Escape))\n                .distributive_run_if(input_pressed(KeyCode::Escape))\n                .distributive_run_if(input_just_pressed(KeyCode::Escape))\n                .distributive_run_if(input_just_released(KeyCode::Escape)),\n        );\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "b4699c53ff2899c5284a6aa76070c5a05b8349fa",
    "func": "use std::borrow::Cow;\nuse std::io::{self, Cursor};\nuse std::task::{Context, Poll};\nuse std::pin::Pin;\nuse std::cmp::min;\n\nuse tokio::io::{AsyncRead, AsyncReadExt, ReadBuf, Take};\n\n/// Low-level serialization of fields in text/event-stream format.\n///\n/// Based on https://html.spec.whatwg.org/multipage/server-sent-events.html,\n/// reproduced here for quick reference. Retrieved 2021-04-17.\n///\n/// ```text\n/// stream        = [ bom ] *event\n/// event         = *( comment / field ) end-of-line\n/// comment       = colon *any-char end-of-line\n/// field         = 1*name-char [ colon [ space ] *any-char ] end-of-line\n/// end-of-line   = ( cr lf / cr / lf )\n///\n/// ; characters\n/// lf            = %x000A ; U+000A LINE FEED (LF)\n/// cr            = %x000D ; U+000D CARRIAGE RETURN (CR)\n/// space         = %x0020 ; U+0020 SPACE\n/// colon         = %x003A ; U+003A COLON (:)\n/// bom           = %xFEFF ; U+FEFF BYTE ORDER MARK\n/// name-char     = %x0000-0009 / %x000B-000C / %x000E-0039 / %x003B-10FFFF\n///                 ; a scalar value other than:\n///                 ; U+000A LINE FEED (LF), U+000D CARRIAGE RETURN (CR), or U+003A COLON (:)\n/// any-char      = %x0000-0009 / %x000B-000C / %x000E-10FFFF\n///                 ; a scalar value other than:\n///                 ; U+000A LINE FEED (LF) or U+000D CARRIAGE RETURN (CR)/\n/// ```\n///\n/// Notice that Multiple encodings are possible for the same data, especially in\n/// the choice of newline. This implementation always uses only \"\\n\" (LF).\n///\n/// Serializes (via `AsyncRead`) as a series of \"${name}:${value}\\n\" events.\n/// Either or both `name` and `value` may be empty. When the name is empty, this\n/// is a comment. Otherwise, this is a field.\n#[derive(Debug)]\npub struct RawLinedEvent {\n    name: Cursor<Cow<'static, [u8]>>,\n    value: Take<Cursor<Cow<'static, [u8]>>>,\n    state: State,\n}\n\n/// Converts a `Cow<str>` to a `Cow<[u8]>`.\nfn farm(cow: Cow<'_, str>) -> Cow<'_, [u8]> {\n    match cow {\n        Cow::Borrowed(slice) => Cow::Borrowed(slice.as_bytes()),\n        Cow::Owned(vec) => Cow::Owned(vec.into_bytes())\n    }\n}\n\n/// Farms `cow`, replacing `\\r`, `\\n`, and `:` with ` ` in the process.\n///\n/// This converts any string into a valid event `name`.\nfn farm_name(cow: Cow<'_, str>) -> Cow<'_, [u8]> {\n    let mut i = 0;\n    let mut cow = farm(cow);\n    while i < cow.len() {\n        if let Some(k) = memchr::memchr3(b'\\r', b'\\n', b':', &cow[i..]) {\n            cow.to_mut()[i + k] = b' ';\n            // This can't overflow as i + k + 1 <= len, since we found a char.\n            i += k + 1;\n        } else {\n            break;\n        }\n    }\n\n    cow\n}\n\n/// Farms `cow`, replacing `\\r` and `\\n` with ` ` in the process.\n///\n/// This converts any string into a valid event `value`.\nfn farm_value(cow: Cow<'_, str>) -> Cow<'_, [u8]> {\n    let mut i = 0;\n    let mut cow = farm(cow);\n    while i < cow.len() {\n        if let Some(k) = memchr::memchr2(b'\\r', b'\\n', &cow[i..]) {\n            cow.to_mut()[i + k] = b' ';\n            // This can't overflow as i + k + 1 <= len, since we found a char.\n            i += k + 1;\n        } else {\n            break;\n        }\n    }\n\n    cow\n}\n\nimpl RawLinedEvent {\n    /// Create a `RawLinedEvent` from a valid, prefarmed `name` and `value`.\n    fn prefarmed(name: Cow<'static, [u8]>, value: Cow<'static, [u8]>) -> RawLinedEvent {\n        let name = Cursor::new(name);\n        let mut value = Cursor::new(value).take(0);\n        advance(&mut value);\n        RawLinedEvent { name, value, state: State::Name }\n    }\n\n    /// Create a `RawLinedEvent` from potentially invalid `name` and `value`\n    /// where `value` is not allowed to be multiple lines.\n    ///\n    /// Characters `\\n`, `\\r`, and ':' in `name` and characters `\\r` \\`n` in\n    /// `value` `are replaced with a space ` `.\n    pub fn one<N, V>(name: N, value: V) -> RawLinedEvent\n        where N: Into<Cow<'static, str>>, V: Into<Cow<'static, str>>\n    {\n        RawLinedEvent::prefarmed(farm_name(name.into()), farm_value(value.into()))\n    }\n\n    /// Create a `RawLinedEvent` from potentially invalid `name` and `value`\n    /// where `value` is allowed to be multiple lines.\n    ///\n    /// Characters `\\n`, `\\r`, and ':' in `name` are replaced with a space ` `.\n    /// `value` is allowed to contain any character. New lines (`\\r\\n` or `\\n`)\n    /// and carriage returns `\\r` result in a new event being emitted.\n    pub fn many<N, V>(name: N, value: V) -> RawLinedEvent\n        where N: Into<Cow<'static, str>>, V: Into<Cow<'static, str>>\n    {\n        RawLinedEvent::prefarmed(farm_name(name.into()), farm(value.into()))\n    }\n\n    /// Create a `RawLinedEvent` from known value `value`. The value is emitted\n    /// directly with _no_ name and suffixed with a `\\n`.\n    pub fn raw<V: Into<Cow<'static, str>>>(value: V) -> RawLinedEvent {\n        let value = value.into();\n        let len = value.len();\n        RawLinedEvent {\n            name: Cursor::new(Cow::Borrowed(&[])),\n            value: Cursor::new(farm(value)).take(len as u64),\n            state: State::Value\n        }\n    }\n}\n\n/// The `AsyncRead`er state.\n#[derive(Debug, PartialEq, Copy, Clone)]\nenum State {\n    Name,\n    Colon,\n    Value,\n    NewLine,\n    Done\n}\n\n/// Find the next new-line (`\\n` or `\\r`) character in `buf` beginning at the\n/// current cursor position and sets the limit to be at that position.\nfn advance<T: AsRef<[u8]> + Unpin>(buf: &mut Take<Cursor<T>>) {\n    // Technically, the position need not be <= len, so we right it.\n    let pos = min(buf.get_ref().get_ref().as_ref().len() as u64, buf.get_ref().position());\n    let inner = buf.get_ref().get_ref().as_ref();\n    let next = memchr::memchr2(b'\\n', b'\\r', &inner[(pos as usize)..])\n        .map(|i| pos + i as u64)\n        .unwrap_or_else(|| inner.len() as u64);\n\n    let limit = next - pos;\n    buf.set_limit(limit);\n}\n\n/// If the cursor in `buf` is currently at an `\\r`, `\\r\\n` or `\\n`, sets the\n/// cursor position to be _after_ the characters.\nfn skip<T: AsRef<[u8]> + Unpin>(buf: &mut Take<Cursor<T>>) {\n    let pos = min(buf.get_ref().get_ref().as_ref().len() as u64, buf.get_ref().position());\n    match buf.get_ref().get_ref().as_ref().get(pos as usize) {\n        // This cannot overflow as clearly `buf.len() >= pos + 1`.\n        Some(b'\\n') => buf.get_mut().set_position(pos + 1),\n        Some(b'\\r') => {\n            let next = (pos as usize).saturating_add(1);\n            if buf.get_ref().get_ref().as_ref().get(next) == Some(&b'\\n') {\n                // This cannot overflow as clearly `buf.len() >= pos + 2`.\n                buf.get_mut().set_position(pos + 2);\n            } else {\n                // This cannot overflow as clearly `buf.len() >= pos + 1`.\n                buf.get_mut().set_position(pos + 1);\n            }\n        }\n        _ => (),\n    }\n}\n\nmacro_rules! dbg_assert_ready {\n    ($e:expr) => ({\n        let poll = $e;\n        debug_assert!(poll.is_ready());\n        ::futures::ready!(poll)\n    })\n}\n\n// NOTE: The correctness of this implementation depends on the types of `name`\n// and `value` having `AsyncRead` implementations that always return `Ready`.\n// Otherwise, we may return `Pending` after having written data to `buf` which\n// violates the contract. This can happen because even after a successful\n// partial or full read of `name`, we loop back to a `ready!(name.poll())` if\n// `buf` was not completely filled. So, we return `Pending` if that poll does.\nimpl AsyncRead for RawLinedEvent {\n    fn poll_read(\n        mut self: Pin<&mut Self>,\n        cx: &mut Context<'_>,\n        buf: &mut ReadBuf<'_>,\n    ) -> Poll<io::Result<()>> {\n        use bytes::Buf;\n\n        loop {\n            if buf.remaining() == 0 {\n                return Poll::Ready(Ok(()));\n            }\n\n            match self.state {\n                State::Name => {\n                    dbg_assert_ready!(Pin::new(&mut self.name).poll_read(cx, buf))?;\n                    if !self.name.has_remaining() {\n                        self.name.set_position(0);\n                        self.state = State::Colon;\n                    }\n                }\n                State::Colon => {\n                    // Note that we've checked `buf.remaining() != 0`.\n                    buf.put_slice(&[b':']);\n                    self.state = State::Value;\n                }\n                State::Value => {\n                    dbg_assert_ready!(Pin::new(&mut self.value).poll_read(cx, buf))?;\n                    if self.value.limit() == 0 {\n                        self.state = State::NewLine;\n                    }\n                }\n                State::NewLine => {\n                    // Note that we've checked `buf.remaining() != 0`.\n                    buf.put_slice(&[b'\\n']);\n                    if self.value.get_ref().has_remaining() {\n                        skip(&mut self.value);\n                        advance(&mut self.value);\n                        self.state = State::Name;\n                    } else {\n                        self.state = State::Done;\n                    }\n                }\n                State::Done => return Poll::Ready(Ok(()))\n            }\n        }\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "fdc0ee6ce2caca81a68087beefde18d806dd019c",
    "func": "#![allow(unused_imports, dead_code)]\n\npub mod common;\n\npub use common::{features::*, setup::*, TestContext};\nuse pretty_assertions::assert_eq;\nuse sea_orm::{\n    entity::prelude::*, DatabaseConnection, Delete, IntoActiveModel, Iterable, QueryTrait, Set,\n    Update,\n};\nuse sea_query::{Expr, Query};\n\n#[sea_orm_macros::test]\nasync fn main() -> Result<(), DbErr> {\n    let ctx = TestContext::new(\"dyn_table_name_tests\").await;\n    create_tables(&ctx.db).await?;\n    dyn_table_name_lazy_static(&ctx.db).await?;\n    ctx.delete().await;\n\n    Ok(())\n}\n\npub async fn dyn_table_name_lazy_static(db: &DatabaseConnection) -> Result<(), DbErr> {\n    use dyn_table_name_lazy_static::*;\n\n    for i in 1..=2 {\n        let entity = Entity {\n            table_name: TableName::from_str_truncate(format!(\"dyn_table_name_lazy_static_{}\", i)),\n        };\n\n        let model = Model {\n            id: 1,\n            name: \"1st Row\".into(),\n        };\n        // Prepare insert statement\n        let mut insert = Entity::insert(model.clone().into_active_model());\n        // Reset the table name of insert statement\n        insert.query().into_table(entity.table_ref());\n        // Execute the insert statement\n        assert_eq!(insert.exec(db).await?.last_insert_id, 1);\n\n        // Prepare select statement\n        let mut select = Entity::find();\n        // Override the select statement\n        *QueryTrait::query(&mut select) = Query::select()\n            .exprs(Column::iter().map(|col| col.select_as(Expr::col(col))))\n            .from(entity.table_ref())\n            .to_owned();\n        // Execute the select statement\n        assert_eq!(select.clone().one(db).await?, Some(model.clone()));\n\n        // Prepare update statement\n        let update = Update::many(entity).set(ActiveModel {\n            name: Set(\"1st Row (edited)\".into()),\n            ..model.clone().into_active_model()\n        });\n        // Execute the update statement\n        assert_eq!(update.exec(db).await?.rows_affected, 1);\n\n        assert_eq!(\n            select.clone().one(db).await?,\n            Some(Model {\n                id: 1,\n                name: \"1st Row (edited)\".into(),\n            })\n        );\n\n        // Prepare delete statement\n        let delete = Delete::many(entity).filter(Expr::col(Column::Id).eq(1));\n        // Execute the delete statement\n        assert_eq!(delete.exec(db).await?.rows_affected, 1);\n        assert_eq!(select.one(db).await?, None);\n    }\n\n    Ok(())\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "14f28858a9ba0d30ed18b2c3299f8af9acb8f13e",
    "func": "use std::fmt;\n\nuse strum::EnumIs;\n\n/// A constraint that defines the size of a layout element.\n///\n/// Constraints can be used to specify a fixed size, a percentage of the available space, a ratio of\n/// the available space, a minimum or maximum size or a fill proportional value for a layout\n/// element.\n///\n/// Relative constraints (percentage, ratio) are calculated relative to the entire space being\n/// divided, rather than the space available after applying more fixed constraints (min, max,\n/// length).\n///\n/// Constraints are prioritized in the following order:\n///\n/// 1. [`Constraint::Min`]\n/// 2. [`Constraint::Max`]\n/// 3. [`Constraint::Length`]\n/// 4. [`Constraint::Percentage`]\n/// 5. [`Constraint::Ratio`]\n/// 6. [`Constraint::Fill`]\n///\n/// # Examples\n///\n/// `Constraint` provides helper methods to create lists of constraints from various input formats.\n///\n/// ```rust\n/// use ratatui::layout::Constraint;\n///\n/// // Create a layout with specified lengths for each element\n/// let constraints = Constraint::from_lengths([10, 20, 10]);\n///\n/// // Create a centered layout using ratio or percentage constraints\n/// let constraints = Constraint::from_ratios([(1, 4), (1, 2), (1, 4)]);\n/// let constraints = Constraint::from_percentages([25, 50, 25]);\n///\n/// // Create a centered layout with a minimum size constraint for specific elements\n/// let constraints = Constraint::from_mins([0, 100, 0]);\n///\n/// // Create a sidebar layout specifying maximum sizes for the columns\n/// let constraints = Constraint::from_maxes([30, 170]);\n///\n/// // Create a layout with fill proportional sizes for each element\n/// let constraints = Constraint::from_fills([1, 2, 1]);\n/// ```\n#[derive(Debug, Clone, Copy, Eq, PartialEq, Hash, EnumIs)]\npub enum Constraint {\n    /// Applies a minimum size constraint to the element\n    ///\n    /// The element size is set to at least the specified amount.\n    ///\n    /// # Examples\n    ///\n    /// `[Percentage(100), Min(20)]`\n    ///\n    /// ```plain\n    /// \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    /// \u2502            30 px           \u2502\u2502       20 px      \u2502\n    /// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    /// ```\n    ///\n    /// `[Percentage(100), Min(10)]`\n    ///\n    /// ```plain\n    /// \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    /// \u2502                 40 px                \u2502\u2502  10 px \u2502\n    /// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    /// ```\n    Min(u16),\n\n    /// Applies a maximum size constraint to the element\n    ///\n    /// The element size is set to at most the specified amount.\n    ///\n    /// # Examples\n    ///\n    /// `[Percentage(0), Max(20)]`\n    ///\n    /// ```plain\n    /// \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    /// \u2502            30 px           \u2502\u2502       20 px      \u2502\n    /// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    /// ```\n    ///\n    /// `[Percentage(0), Max(10)]`\n    ///\n    /// ```plain\n    /// \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    /// \u2502                 40 px                \u2502\u2502  10 px \u2502\n    /// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    /// ```\n    Max(u16),\n\n    /// Applies a length constraint to the element\n    ///\n    /// The element size is set to the specified amount.\n    ///\n    /// # Examples\n    ///\n    /// `[Length(20), Length(20)]`\n    ///\n    /// ```plain\n    /// \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    /// \u2502       20 px      \u2502\u2502       20 px      \u2502\n    /// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    /// ```\n    ///\n    /// `[Length(20), Length(30)]`\n    ///\n    /// ```plain\n    /// \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    /// \u2502       20 px      \u2502\u2502            30 px           \u2502\n    /// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    /// ```\n    Length(u16),\n\n    /// Applies a percentage of the available space to the element\n    ///\n    /// Converts the given percentage to a floating-point value and multiplies that with area. This\n    /// value is rounded back to a integer as part of the layout split calculation.\n    ///\n    /// **Note**: As this value only accepts a `u16`, certain percentages that cannot be\n    /// represented exactly (e.g. 1/3) are not possible. You might want to use\n    /// [`Constraint::Ratio`] or [`Constraint::Fill`] in such cases.\n    ///\n    /// # Examples\n    ///\n    /// `[Percentage(75), Fill(1)]`\n    ///\n    /// ```plain\n    /// \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    /// \u2502                38 px               \u2502\u2502   12 px  \u2502\n    /// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    /// ```\n    ///\n    /// `[Percentage(50), Fill(1)]`\n    ///\n    /// ```plain\n    /// \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    /// \u2502         25 px         \u2502\u2502         25 px         \u2502\n    /// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    /// ```\n    Percentage(u16),\n\n    /// Applies a ratio of the available space to the element\n    ///\n    /// Converts the given ratio to a floating-point value and multiplies that with area.\n    /// This value is rounded back to a integer as part of the layout split calculation.\n    ///\n    /// # Examples\n    ///\n    /// `[Ratio(1, 2) ; 2]`\n    ///\n    /// ```plain\n    /// \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    /// \u2502         25 px         \u2502\u2502         25 px         \u2502\n    /// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    /// ```\n    ///\n    /// `[Ratio(1, 4) ; 4]`\n    ///\n    /// ```plain\n    /// \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    /// \u2502   13 px   \u2502\u2502   12 px  \u2502\u2502   13 px   \u2502\u2502   12 px  \u2502\n    /// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    /// ```\n    Ratio(u32, u32),\n\n    /// Applies the scaling factor proportional to all other [`Constraint::Fill`] elements\n    /// to fill excess space\n    ///\n    /// The element will only expand or fill into excess available space, proportionally matching\n    /// other [`Constraint::Fill`] elements while satisfying all other constraints.\n    ///\n    /// # Examples\n    ///\n    ///\n    /// `[Fill(1), Fill(2), Fill(3)]`\n    ///\n    /// ```plain\n    /// \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    /// \u2502 8 px \u2502\u2502     17 px     \u2502\u2502         25 px         \u2502\n    /// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    /// ```\n    ///\n    /// `[Fill(1), Percentage(50), Fill(1)]`\n    ///\n    /// ```plain\n    /// \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    /// \u2502   13 px   \u2502\u2502         25 px         \u2502\u2502   12 px  \u2502\n    /// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    /// ```\n    Fill(u16),\n}\n\nimpl Constraint {\n    #[deprecated(\n        since = \"0.26.0\",\n        note = \"This field will be hidden in the next minor version.\"\n    )]\n    pub fn apply(&self, length: u16) -> u16 {\n        match *self {\n            Self::Percentage(p) => {\n                let p = f32::from(p) / 100.0;\n                let length = f32::from(length);\n                (p * length).min(length) as u16\n            }\n            Self::Ratio(numerator, denominator) => {\n                // avoid division by zero by using 1 when denominator is 0\n                // this results in 0/0 -> 0 and x/0 -> x for x != 0\n                let percentage = numerator as f32 / denominator.max(1) as f32;\n                let length = f32::from(length);\n                (percentage * length).min(length) as u16\n            }\n            Self::Length(l) | Self::Fill(l) => length.min(l),\n            Self::Max(m) => length.min(m),\n            Self::Min(m) => length.max(m),\n        }\n    }\n\n    /// Convert an iterator of lengths into a vector of constraints\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use ratatui::layout::{Constraint, Layout, Rect};\n    ///\n    /// # let area = Rect::default();\n    /// let constraints = Constraint::from_lengths([1, 2, 3]);\n    /// let layout = Layout::default().constraints(constraints).split(area);\n    /// ```\n    pub fn from_lengths<T>(lengths: T) -> Vec<Self>\n    where\n        T: IntoIterator<Item = u16>,\n    {\n        lengths.into_iter().map(Self::Length).collect()\n    }\n\n    /// Convert an iterator of ratios into a vector of constraints\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use ratatui::layout::{Constraint, Layout, Rect};\n    ///\n    /// # let area = Rect::default();\n    /// let constraints = Constraint::from_ratios([(1, 4), (1, 2), (1, 4)]);\n    /// let layout = Layout::default().constraints(constraints).split(area);\n    /// ```\n    pub fn from_ratios<T>(ratios: T) -> Vec<Self>\n    where\n        T: IntoIterator<Item = (u32, u32)>,\n    {\n        ratios.into_iter().map(|(n, d)| Self::Ratio(n, d)).collect()\n    }\n\n    /// Convert an iterator of percentages into a vector of constraints\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use ratatui::layout::{Constraint, Layout, Rect};\n    ///\n    /// # let area = Rect::default();\n    /// let constraints = Constraint::from_percentages([25, 50, 25]);\n    /// let layout = Layout::default().constraints(constraints).split(area);\n    /// ```\n    pub fn from_percentages<T>(percentages: T) -> Vec<Self>\n    where\n        T: IntoIterator<Item = u16>,\n    {\n        percentages.into_iter().map(Self::Percentage).collect()\n    }\n\n    /// Convert an iterator of maxes into a vector of constraints\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use ratatui::layout::{Constraint, Layout, Rect};\n    ///\n    /// # let area = Rect::default();\n    /// let constraints = Constraint::from_maxes([1, 2, 3]);\n    /// let layout = Layout::default().constraints(constraints).split(area);\n    /// ```\n    pub fn from_maxes<T>(maxes: T) -> Vec<Self>\n    where\n        T: IntoIterator<Item = u16>,\n    {\n        maxes.into_iter().map(Self::Max).collect()\n    }\n\n    /// Convert an iterator of mins into a vector of constraints\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use ratatui::layout::{Constraint, Layout, Rect};\n    ///\n    /// # let area = Rect::default();\n    /// let constraints = Constraint::from_mins([1, 2, 3]);\n    /// let layout = Layout::default().constraints(constraints).split(area);\n    /// ```\n    pub fn from_mins<T>(mins: T) -> Vec<Self>\n    where\n        T: IntoIterator<Item = u16>,\n    {\n        mins.into_iter().map(Self::Min).collect()\n    }\n\n    /// Convert an iterator of proportional factors into a vector of constraints\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use ratatui::layout::{Constraint, Layout, Rect};\n    ///\n    /// # let area = Rect::default();\n    /// let constraints = Constraint::from_fills([1, 2, 3]);\n    /// let layout = Layout::default().constraints(constraints).split(area);\n    /// ```\n    pub fn from_fills<T>(proportional_factors: T) -> Vec<Self>\n    where\n        T: IntoIterator<Item = u16>,\n    {\n        proportional_factors.into_iter().map(Self::Fill).collect()\n    }\n}\n\nimpl From<u16> for Constraint {\n    /// Convert a `u16` into a [`Constraint::Length`]\n    ///\n    /// This is useful when you want to specify a fixed size for a layout, but don't want to\n    /// explicitly create a [`Constraint::Length`] yourself.\n    ///\n    /// # Examples\n    ///\n    /// ```rust\n    /// use ratatui::layout::{Constraint, Direction, Layout, Rect};\n    ///\n    /// # let area = Rect::default();\n    /// let layout = Layout::new(Direction::Vertical, [1, 2, 3]).split(area);\n    /// let layout = Layout::horizontal([1, 2, 3]).split(area);\n    /// let layout = Layout::vertical([1, 2, 3]).split(area);\n    /// ````\n    fn from(length: u16) -> Self {\n        Self::Length(length)\n    }\n}\n\nimpl From<&Self> for Constraint {\n    fn from(constraint: &Self) -> Self {\n        *constraint\n    }\n}\n\nimpl AsRef<Self> for Constraint {\n    fn as_ref(&self) -> &Self {\n        self\n    }\n}\n\nimpl Default for Constraint {\n    fn default() -> Self {\n        Self::Percentage(100)\n    }\n}\n\nimpl fmt::Display for Constraint {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Self::Percentage(p) => write!(f, \"Percentage({p})\"),\n            Self::Ratio(n, d) => write!(f, \"Ratio({n}, {d})\"),\n            Self::Length(l) => write!(f, \"Length({l})\"),\n            Self::Fill(l) => write!(f, \"Fill({l})\"),\n            Self::Max(m) => write!(f, \"Max({m})\"),\n            Self::Min(m) => write!(f, \"Min({m})\"),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn default() {\n        assert_eq!(Constraint::default(), Constraint::Percentage(100));\n    }\n\n    #[test]\n    fn to_string() {\n        assert_eq!(Constraint::Percentage(50).to_string(), \"Percentage(50)\");\n        assert_eq!(Constraint::Ratio(1, 2).to_string(), \"Ratio(1, 2)\");\n        assert_eq!(Constraint::Length(10).to_string(), \"Length(10)\");\n        assert_eq!(Constraint::Max(10).to_string(), \"Max(10)\");\n        assert_eq!(Constraint::Min(10).to_string(), \"Min(10)\");\n    }\n\n    #[test]\n    fn from_lengths() {\n        let expected = [\n            Constraint::Length(1),\n            Constraint::Length(2),\n            Constraint::Length(3),\n        ];\n        assert_eq!(Constraint::from_lengths([1, 2, 3]), expected);\n        assert_eq!(Constraint::from_lengths(vec![1, 2, 3]), expected);\n    }\n\n    #[test]\n    fn from_ratios() {\n        let expected = [\n            Constraint::Ratio(1, 4),\n            Constraint::Ratio(1, 2),\n            Constraint::Ratio(1, 4),\n        ];\n        assert_eq!(Constraint::from_ratios([(1, 4), (1, 2), (1, 4)]), expected);\n        assert_eq!(\n            Constraint::from_ratios(vec![(1, 4), (1, 2), (1, 4)]),\n            expected\n        );\n    }\n\n    #[test]\n    fn from_percentages() {\n        let expected = [\n            Constraint::Percentage(25),\n            Constraint::Percentage(50),\n            Constraint::Percentage(25),\n        ];\n        assert_eq!(Constraint::from_percentages([25, 50, 25]), expected);\n        assert_eq!(Constraint::from_percentages(vec![25, 50, 25]), expected);\n    }\n\n    #[test]\n    fn from_maxes() {\n        let expected = [Constraint::Max(1), Constraint::Max(2), Constraint::Max(3)];\n        assert_eq!(Constraint::from_maxes([1, 2, 3]), expected);\n        assert_eq!(Constraint::from_maxes(vec![1, 2, 3]), expected);\n    }\n\n    #[test]\n    fn from_mins() {\n        let expected = [Constraint::Min(1), Constraint::Min(2), Constraint::Min(3)];\n        assert_eq!(Constraint::from_mins([1, 2, 3]), expected);\n        assert_eq!(Constraint::from_mins(vec![1, 2, 3]), expected);\n    }\n\n    #[test]\n    fn from_fills() {\n        let expected = [\n            Constraint::Fill(1),\n            Constraint::Fill(2),\n            Constraint::Fill(3),\n        ];\n        assert_eq!(Constraint::from_fills([1, 2, 3]), expected);\n        assert_eq!(Constraint::from_fills(vec![1, 2, 3]), expected);\n    }\n\n    #[test]\n    #[allow(deprecated)]\n    fn apply() {\n        assert_eq!(Constraint::Percentage(0).apply(100), 0);\n        assert_eq!(Constraint::Percentage(50).apply(100), 50);\n        assert_eq!(Constraint::Percentage(100).apply(100), 100);\n        assert_eq!(Constraint::Percentage(200).apply(100), 100);\n        assert_eq!(Constraint::Percentage(u16::MAX).apply(100), 100);\n\n        // 0/0 intentionally avoids a panic by returning 0.\n        assert_eq!(Constraint::Ratio(0, 0).apply(100), 0);\n        // 1/0 intentionally avoids a panic by returning 100% of the length.\n        assert_eq!(Constraint::Ratio(1, 0).apply(100), 100);\n        assert_eq!(Constraint::Ratio(0, 1).apply(100), 0);\n        assert_eq!(Constraint::Ratio(1, 2).apply(100), 50);\n        assert_eq!(Constraint::Ratio(2, 2).apply(100), 100);\n        assert_eq!(Constraint::Ratio(3, 2).apply(100), 100);\n        assert_eq!(Constraint::Ratio(u32::MAX, 2).apply(100), 100);\n\n        assert_eq!(Constraint::Length(0).apply(100), 0);\n        assert_eq!(Constraint::Length(50).apply(100), 50);\n        assert_eq!(Constraint::Length(100).apply(100), 100);\n        assert_eq!(Constraint::Length(200).apply(100), 100);\n        assert_eq!(Constraint::Length(u16::MAX).apply(100), 100);\n\n        assert_eq!(Constraint::Max(0).apply(100), 0);\n        assert_eq!(Constraint::Max(50).apply(100), 50);\n        assert_eq!(Constraint::Max(100).apply(100), 100);\n        assert_eq!(Constraint::Max(200).apply(100), 100);\n        assert_eq!(Constraint::Max(u16::MAX).apply(100), 100);\n\n        assert_eq!(Constraint::Min(0).apply(100), 100);\n        assert_eq!(Constraint::Min(50).apply(100), 100);\n        assert_eq!(Constraint::Min(100).apply(100), 100);\n        assert_eq!(Constraint::Min(200).apply(100), 200);\n        assert_eq!(Constraint::Min(u16::MAX).apply(100), u16::MAX);\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "19bb99228778f04248b45138c38c5958f8b8ba97",
    "func": "mod prepare;\n\nuse entity::post;\nuse prepare::prepare_mock_db;\nuse rocket_example_service::{Mutation, Query};\n\n#[tokio::test]\nasync fn main() {\n    let db = &prepare_mock_db();\n\n    {\n        let post = Query::find_post_by_id(db, 1).await.unwrap().unwrap();\n\n        assert_eq!(post.id, 1);\n    }\n\n    {\n        let post = Query::find_post_by_id(db, 5).await.unwrap().unwrap();\n\n        assert_eq!(post.id, 5);\n    }\n\n    {\n        let post = Mutation::create_post(\n            db,\n            post::Model {\n                id: 0,\n                title: \"Title D\".to_owned(),\n                text: \"Text D\".to_owned(),\n            },\n        )\n        .await\n        .unwrap();\n\n        assert_eq!(\n            post,\n            post::ActiveModel {\n                id: sea_orm::ActiveValue::Unchanged(6),\n                title: sea_orm::ActiveValue::Unchanged(\"Title D\".to_owned()),\n                text: sea_orm::ActiveValue::Unchanged(\"Text D\".to_owned())\n            }\n        );\n    }\n\n    {\n        let post = Mutation::update_post_by_id(\n            db,\n            1,\n            post::Model {\n                id: 1,\n                title: \"New Title A\".to_owned(),\n                text: \"New Text A\".to_owned(),\n            },\n        )\n        .await\n        .unwrap();\n\n        assert_eq!(\n            post,\n            post::Model {\n                id: 1,\n                title: \"New Title A\".to_owned(),\n                text: \"New Text A\".to_owned(),\n            }\n        );\n    }\n\n    {\n        let result = Mutation::delete_post(db, 5).await.unwrap();\n\n        assert_eq!(result.rows_affected, 1);\n    }\n\n    {\n        let result = Mutation::delete_all_posts(db).await.unwrap();\n\n        assert_eq!(result.rows_affected, 5);\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "490479861a4a1bede52b79f4971e8fe70d17124c",
    "func": "use crate::Stream;\nuse std::io;\nuse std::pin::Pin;\nuse std::task::{Context, Poll};\nuse tokio::net::{UnixListener, UnixStream};\n\n/// A wrapper around [`UnixListener`] that implements [`Stream`].\n///\n/// [`UnixListener`]: struct@tokio::net::UnixListener\n/// [`Stream`]: trait@crate::Stream\n#[derive(Debug)]\n#[cfg_attr(docsrs, doc(cfg(all(unix, feature = \"net\"))))]\npub struct UnixListenerStream {\n    inner: UnixListener,\n}\n\nimpl UnixListenerStream {\n    /// Create a new `UnixListenerStream`.\n    pub fn new(listener: UnixListener) -> Self {\n        Self { inner: listener }\n    }\n\n    /// Get back the inner `UnixListener`.\n    pub fn into_inner(self) -> UnixListener {\n        self.inner\n    }\n}\n\nimpl Stream for UnixListenerStream {\n    type Item = io::Result<UnixStream>;\n\n    fn poll_next(\n        self: Pin<&mut Self>,\n        cx: &mut Context<'_>,\n    ) -> Poll<Option<io::Result<UnixStream>>> {\n        match self.inner.poll_accept(cx) {\n            Poll::Ready(Ok((stream, _))) => Poll::Ready(Some(Ok(stream))),\n            Poll::Ready(Err(err)) => Poll::Ready(Some(Err(err))),\n            Poll::Pending => Poll::Pending,\n        }\n    }\n}\n\nimpl AsRef<UnixListener> for UnixListenerStream {\n    fn as_ref(&self) -> &UnixListener {\n        &self.inner\n    }\n}\n\nimpl AsMut<UnixListener> for UnixListenerStream {\n    fn as_mut(&mut self) -> &mut UnixListener {\n        &mut self.inner\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "007b069a26861537b3491995bab93640c5447989",
    "func": "use core::fmt;\n\n/// A static accessor to type paths and names.\n///\n/// The engine uses this trait over [`std::any::type_name`] for stability and flexibility.\n///\n/// This trait is automatically implemented by the `#[derive(Reflect)]` macro\n/// and allows type path information to be processed without an instance of that type.\n///\n/// Implementors may have difficulty in generating references with static\n/// lifetimes. Luckily, this crate comes with some [utility] structs, to make generating these\n/// statics much simpler.\n///\n/// # Stability\n///\n/// Certain parts of the engine, e.g. [(de)serialization], rely on type paths as identifiers\n/// for matching dynamic values to concrete types.\n///\n/// Using [`std::any::type_name`], a scene containing `my_crate::foo::MyComponent` would break,\n/// failing to deserialize if the component was moved from the `foo` module to the `bar` module,\n/// becoming `my_crate::bar::MyComponent`.\n/// This trait, through attributes when deriving itself or [`Reflect`], can ensure breaking changes are avoidable.\n///\n/// The only external factor we rely on for stability when deriving is the [`module_path!`] macro,\n/// only if the derive does not provide a `#[type_path = \"...\"]` attribute.\n///\n/// # Anonymity\n///\n/// Some methods on this trait return `Option<&'static str>` over `&'static str`\n/// because not all types define all parts of a type path, for example the array type `[T; N]`.\n///\n/// Such types are 'anonymous' in that they have only a defined [`type_path`] and [`short_type_path`]\n/// and the methods [`crate_name`], [`module_path`] and [`type_ident`] all return `None`.\n///\n/// Primitives are treated like anonymous types, except they also have a defined [`type_ident`].\n///\n/// # Example\n///\n/// ```\n/// use bevy_reflect::TypePath;\n///\n/// // This type path will not change with compiler versions or recompiles,\n/// // although it will not be the same if the definition is moved.\n/// #[derive(TypePath)]\n/// struct NonStableTypePath;\n///\n/// // This type path will never change, even if the definition is moved.\n/// #[derive(TypePath)]\n/// #[type_path = \"my_crate::foo\"]\n/// struct StableTypePath;\n///\n/// // Type paths can have any number of path segments.\n/// #[derive(TypePath)]\n/// #[type_path = \"my_crate::foo::bar::baz\"]\n/// struct DeeplyNestedStableTypePath;\n///\n/// // Including just a crate name!\n/// #[derive(TypePath)]\n/// #[type_path = \"my_crate\"]\n/// struct ShallowStableTypePath;\n///\n/// // We can also rename the identifier/name of types.\n/// #[derive(TypePath)]\n/// #[type_path = \"my_crate::foo\"]\n/// #[type_name = \"RenamedStableTypePath\"]\n/// struct NamedStableTypePath;\n///\n/// // Generics are also supported.\n/// #[derive(TypePath)]\n/// #[type_path = \"my_crate::foo\"]\n/// struct StableGenericTypePath<T, const N: usize>([T; N]);\n/// ```\n///\n/// [utility]: crate::utility\n/// [(de)serialization]: crate::serde::ReflectDeserializer\n/// [`Reflect`]: crate::Reflect\n/// [`type_path`]: TypePath::type_path\n/// [`short_type_path`]: TypePath::short_type_path\n/// [`crate_name`]: TypePath::crate_name\n/// [`module_path`]: TypePath::module_path\n/// [`type_ident`]: TypePath::type_ident\n#[diagnostic::on_unimplemented(\n    message = \"`{Self}` does not implement `TypePath` so cannot provide static type path information\",\n    note = \"consider annotating `{Self}` with `#[derive(Reflect)]` or `#[derive(TypePath)]`\"\n)]\npub trait TypePath: 'static {\n    /// Returns the fully qualified path of the underlying type.\n    ///\n    /// Generic parameter types are also fully expanded.\n    ///\n    /// For `Option<Vec<usize>>`, this is `\"std::option::Option<std::vec::Vec<usize>>\"`.\n    fn type_path() -> &'static str;\n\n    /// Returns a short, pretty-print enabled path to the type.\n    ///\n    /// Generic parameter types are also shortened.\n    ///\n    /// For `Option<Vec<usize>>`, this is `\"Option<Vec<usize>>\"`.\n    fn short_type_path() -> &'static str;\n\n    /// Returns the name of the type, or [`None`] if it is [anonymous].\n    ///\n    /// Primitive types will return [`Some`].\n    ///\n    /// For `Option<Vec<usize>>`, this is `\"Option\"`.\n    ///\n    /// [anonymous]: TypePath#anonymity\n    fn type_ident() -> Option<&'static str> {\n        None\n    }\n\n    /// Returns the name of the crate the type is in, or [`None`] if it is [anonymous].\n    ///\n    /// For `Option<Vec<usize>>`, this is `\"core\"`.\n    ///\n    /// [anonymous]: TypePath#anonymity\n    fn crate_name() -> Option<&'static str> {\n        None\n    }\n\n    /// Returns the path to the module the type is in, or [`None`] if it is [anonymous].\n    ///\n    /// For `Option<Vec<usize>>`, this is `\"std::option\"`.\n    ///\n    /// [anonymous]: TypePath#anonymity\n    fn module_path() -> Option<&'static str> {\n        None\n    }\n}\n\n/// Dynamic dispatch for [`TypePath`].\n///\n/// Since this is a supertrait of [`Reflect`] its methods can be called on a `dyn Reflect`.\n///\n/// [`Reflect`]: crate::Reflect\n#[diagnostic::on_unimplemented(\n    message = \"`{Self}` does not implement `TypePath` so cannot provide dynamic type path information\",\n    note = \"consider annotating `{Self}` with `#[derive(Reflect)]` or `#[derive(TypePath)]`\"\n)]\npub trait DynamicTypePath {\n    /// See [`TypePath::type_path`].\n    fn reflect_type_path(&self) -> &str;\n\n    /// See [`TypePath::short_type_path`].\n    fn reflect_short_type_path(&self) -> &str;\n\n    /// See [`TypePath::type_ident`].\n    fn reflect_type_ident(&self) -> Option<&str>;\n\n    /// See [`TypePath::crate_name`].\n    fn reflect_crate_name(&self) -> Option<&str>;\n\n    /// See [`TypePath::module_path`].\n    fn reflect_module_path(&self) -> Option<&str>;\n}\n\nimpl<T: TypePath> DynamicTypePath for T {\n    #[inline]\n    fn reflect_type_path(&self) -> &str {\n        Self::type_path()\n    }\n\n    #[inline]\n    fn reflect_short_type_path(&self) -> &str {\n        Self::short_type_path()\n    }\n\n    #[inline]\n    fn reflect_type_ident(&self) -> Option<&str> {\n        Self::type_ident()\n    }\n\n    #[inline]\n    fn reflect_crate_name(&self) -> Option<&str> {\n        Self::crate_name()\n    }\n\n    #[inline]\n    fn reflect_module_path(&self) -> Option<&str> {\n        Self::module_path()\n    }\n}\n\n/// Provides dynamic access to all methods on [`TypePath`].\n#[derive(Clone, Copy)]\npub struct TypePathTable {\n    // Cache the type path as it is likely the only one that will be used.\n    type_path: &'static str,\n    short_type_path: fn() -> &'static str,\n    type_ident: fn() -> Option<&'static str>,\n    crate_name: fn() -> Option<&'static str>,\n    module_path: fn() -> Option<&'static str>,\n}\n\nimpl fmt::Debug for TypePathTable {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"TypePathVtable\")\n            .field(\"type_path\", &self.type_path)\n            .field(\"short_type_path\", &(self.short_type_path)())\n            .field(\"type_ident\", &(self.type_ident)())\n            .field(\"crate_name\", &(self.crate_name)())\n            .field(\"module_path\", &(self.module_path)())\n            .finish()\n    }\n}\n\nimpl TypePathTable {\n    /// Creates a new table from a type.\n    pub fn of<T: TypePath + ?Sized>() -> Self {\n        Self {\n            type_path: T::type_path(),\n            short_type_path: T::short_type_path,\n            type_ident: T::type_ident,\n            crate_name: T::crate_name,\n            module_path: T::module_path,\n        }\n    }\n\n    /// See [`TypePath::type_path`].\n    pub fn path(&self) -> &'static str {\n        self.type_path\n    }\n\n    /// See [`TypePath::short_type_path`].\n    pub fn short_path(&self) -> &'static str {\n        (self.short_type_path)()\n    }\n\n    /// See [`TypePath::type_ident`].\n    pub fn ident(&self) -> Option<&'static str> {\n        (self.type_ident)()\n    }\n\n    /// See [`TypePath::crate_name`].\n    pub fn crate_name(&self) -> Option<&'static str> {\n        (self.crate_name)()\n    }\n\n    /// See [`TypePath::module_path`].\n    pub fn module_path(&self) -> Option<&'static str> {\n        (self.module_path)()\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "4322a7058479b3d652dce28575fc939d6765e722",
    "func": "//! A simple command line client that allows issuing queries to a remote Bevy\n//! app via the BRP.\n\nuse anyhow::Result as AnyhowResult;\nuse argh::FromArgs;\nuse bevy::remote::{\n    builtin_methods::{BrpQuery, BrpQueryFilter, BrpQueryParams, BRP_QUERY_METHOD},\n    http::DEFAULT_ADDR,\n    http::DEFAULT_PORT,\n    BrpRequest,\n};\n\n/// Struct containing the command-line arguments that can be passed to this example.\n///\n/// The components are passed by their full type names positionally, while `host`\n/// and `port` are optional arguments which should correspond to those used on\n/// the server.\n///\n/// When running this example in conjunction with the `server` example, the `host`\n/// and `port` can be left as their defaults.\n///\n/// For example, to connect to port 1337 on the default IP address and query for entities\n/// with `Transform` components:\n/// ```text\n/// cargo run --example client -- --port 1337 bevy_transform::components::transform::Transform\n/// ```\n#[derive(FromArgs)]\nstruct Args {\n    /// the host IP address to connect to\n    #[argh(option, default = \"DEFAULT_ADDR.to_string()\")]\n    host: String,\n    /// the port to connect to\n    #[argh(option, default = \"DEFAULT_PORT\")]\n    port: u16,\n    /// the full type names of the components to query for\n    #[argh(positional, greedy)]\n    components: Vec<String>,\n}\n\n/// The application entry point.\nfn main() -> AnyhowResult<()> {\n    // Parse the arguments.\n    let args: Args = argh::from_env();\n\n    // Create the URL. We're going to need it to issue the HTTP request.\n    let host_part = format!(\"{}:{}\", args.host, args.port);\n    let url = format!(\"http://{}/\", host_part);\n\n    let req = BrpRequest {\n        jsonrpc: String::from(\"2.0\"),\n        method: String::from(BRP_QUERY_METHOD),\n        id: Some(ureq::json!(1)),\n        params: Some(\n            serde_json::to_value(BrpQueryParams {\n                data: BrpQuery {\n                    components: args.components,\n                    option: Vec::default(),\n                    has: Vec::default(),\n                },\n                filter: BrpQueryFilter::default(),\n            })\n            .expect(\"Unable to convert query parameters to a valid JSON value\"),\n        ),\n    };\n\n    let res = ureq::post(&url)\n        .send_json(req)?\n        .into_json::<serde_json::Value>()?;\n\n    println!(\"{:#}\", res);\n\n    Ok(())\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "bec8f5f3032f16708b80b29553c4cdda2d364c35",
    "func": "#![doc = include_str!(\"../README.md\")]\n#![no_std]\n#![cfg_attr(docsrs, feature(doc_auto_cfg))]\n#![expect(unsafe_code, reason = \"Raw pointers are inherently unsafe.\")]\n#![doc(\n    html_logo_url = \"https://bevyengine.org/assets/icon.png\",\n    html_favicon_url = \"https://bevyengine.org/assets/icon.png\"\n)]\n\nuse core::{\n    cell::UnsafeCell,\n    fmt::{self, Formatter, Pointer},\n    marker::PhantomData,\n    mem::ManuallyDrop,\n    num::NonZeroUsize,\n    ptr::{self, NonNull},\n};\n\n/// Used as a type argument to [`Ptr`], [`PtrMut`] and [`OwningPtr`] to specify that the pointer is aligned.\n#[derive(Copy, Clone)]\npub struct Aligned;\n\n/// Used as a type argument to [`Ptr`], [`PtrMut`] and [`OwningPtr`] to specify that the pointer is not aligned.\n#[derive(Copy, Clone)]\npub struct Unaligned;\n\n/// Trait that is only implemented for [`Aligned`] and [`Unaligned`] to work around the lack of ability\n/// to have const generics of an enum.\npub trait IsAligned: sealed::Sealed {}\nimpl IsAligned for Aligned {}\nimpl IsAligned for Unaligned {}\n\nmod sealed {\n    pub trait Sealed {}\n    impl Sealed for super::Aligned {}\n    impl Sealed for super::Unaligned {}\n}\n\n/// A newtype around [`NonNull`] that only allows conversion to read-only borrows or pointers.\n///\n/// This type can be thought of as the `*const T` to [`NonNull<T>`]'s `*mut T`.\n#[repr(transparent)]\npub struct ConstNonNull<T: ?Sized>(NonNull<T>);\n\nimpl<T: ?Sized> ConstNonNull<T> {\n    /// Creates a new `ConstNonNull` if `ptr` is non-null.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use bevy_ptr::ConstNonNull;\n    ///\n    /// let x = 0u32;\n    /// let ptr = ConstNonNull::<u32>::new(&x as *const _).expect(\"ptr is null!\");\n    ///\n    /// if let Some(ptr) = ConstNonNull::<u32>::new(core::ptr::null()) {\n    ///     unreachable!();\n    /// }\n    /// ```\n    pub fn new(ptr: *const T) -> Option<Self> {\n        NonNull::new(ptr.cast_mut()).map(Self)\n    }\n\n    /// Creates a new `ConstNonNull`.\n    ///\n    /// # Safety\n    ///\n    /// `ptr` must be non-null.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use bevy_ptr::ConstNonNull;\n    ///\n    /// let x = 0u32;\n    /// let ptr = unsafe { ConstNonNull::new_unchecked(&x as *const _) };\n    /// ```\n    ///\n    /// *Incorrect* usage of this function:\n    ///\n    /// ```rust,no_run\n    /// use bevy_ptr::ConstNonNull;\n    ///\n    /// // NEVER DO THAT!!! This is undefined behavior. \u26a0\ufe0f\n    /// let ptr = unsafe { ConstNonNull::<u32>::new_unchecked(core::ptr::null()) };\n    /// ```\n    pub const unsafe fn new_unchecked(ptr: *const T) -> Self {\n        // SAFETY: This function's safety invariants are identical to `NonNull::new_unchecked`\n        // The caller must satisfy all of them.\n        unsafe { Self(NonNull::new_unchecked(ptr.cast_mut())) }\n    }\n\n    /// Returns a shared reference to the value.\n    ///\n    /// # Safety\n    ///\n    /// When calling this method, you have to ensure that all of the following is true:\n    ///\n    /// * The pointer must be properly aligned.\n    ///\n    /// * It must be \"dereferenceable\" in the sense defined in [the module documentation].\n    ///\n    /// * The pointer must point to an initialized instance of `T`.\n    ///\n    /// * You must enforce Rust's aliasing rules, since the returned lifetime `'a` is\n    ///   arbitrarily chosen and does not necessarily reflect the actual lifetime of the data.\n    ///   In particular, while this reference exists, the memory the pointer points to must\n    ///   not get mutated (except inside `UnsafeCell`).\n    ///\n    /// This applies even if the result of this method is unused!\n    /// (The part about being initialized is not yet fully decided, but until\n    /// it is, the only safe approach is to ensure that they are indeed initialized.)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use bevy_ptr::ConstNonNull;\n    ///\n    /// let mut x = 0u32;\n    /// let ptr = ConstNonNull::new(&mut x as *mut _).expect(\"ptr is null!\");\n    ///\n    /// let ref_x = unsafe { ptr.as_ref() };\n    /// println!(\"{ref_x}\");\n    /// ```\n    ///\n    /// [the module documentation]: core::ptr#safety\n    #[inline]\n    pub unsafe fn as_ref<'a>(&self) -> &'a T {\n        // SAFETY: This function's safety invariants are identical to `NonNull::as_ref`\n        // The caller must satisfy all of them.\n        unsafe { self.0.as_ref() }\n    }\n}\n\nimpl<T: ?Sized> From<NonNull<T>> for ConstNonNull<T> {\n    fn from(value: NonNull<T>) -> ConstNonNull<T> {\n        ConstNonNull(value)\n    }\n}\n\nimpl<'a, T: ?Sized> From<&'a T> for ConstNonNull<T> {\n    fn from(value: &'a T) -> ConstNonNull<T> {\n        ConstNonNull(NonNull::from(value))\n    }\n}\n\nimpl<'a, T: ?Sized> From<&'a mut T> for ConstNonNull<T> {\n    fn from(value: &'a mut T) -> ConstNonNull<T> {\n        ConstNonNull(NonNull::from(value))\n    }\n}\n/// Type-erased borrow of some unknown type chosen when constructing this type.\n///\n/// This type tries to act \"borrow-like\" which means that:\n/// - It should be considered immutable: its target must not be changed while this pointer is alive.\n/// - It must always points to a valid value of whatever the pointee type is.\n/// - The lifetime `'a` accurately represents how long the pointer is valid for.\n/// - Must be sufficiently aligned for the unknown pointee type.\n///\n/// It may be helpful to think of this type as similar to `&'a dyn Any` but without\n/// the metadata and able to point to data that does not correspond to a Rust type.\n#[derive(Copy, Clone, Debug)]\n#[repr(transparent)]\npub struct Ptr<'a, A: IsAligned = Aligned>(NonNull<u8>, PhantomData<(&'a u8, A)>);\n\n/// Type-erased mutable borrow of some unknown type chosen when constructing this type.\n///\n/// This type tries to act \"borrow-like\" which means that:\n/// - Pointer is considered exclusive and mutable. It cannot be cloned as this would lead to\n///   aliased mutability.\n/// - It must always points to a valid value of whatever the pointee type is.\n/// - The lifetime `'a` accurately represents how long the pointer is valid for.\n/// - Must be sufficiently aligned for the unknown pointee type.\n///\n/// It may be helpful to think of this type as similar to `&'a mut dyn Any` but without\n/// the metadata and able to point to data that does not correspond to a Rust type.\n#[derive(Debug)]\n#[repr(transparent)]\npub struct PtrMut<'a, A: IsAligned = Aligned>(NonNull<u8>, PhantomData<(&'a mut u8, A)>);\n\n/// Type-erased Box-like pointer to some unknown type chosen when constructing this type.\n///\n/// Conceptually represents ownership of whatever data is being pointed to and so is\n/// responsible for calling its `Drop` impl. This pointer is _not_ responsible for freeing\n/// the memory pointed to by this pointer as it may be pointing to an element in a `Vec` or\n/// to a local in a function etc.\n///\n/// This type tries to act \"borrow-like\" like which means that:\n/// - Pointer should be considered exclusive and mutable. It cannot be cloned as this would lead\n///   to aliased mutability and potentially use after free bugs.\n/// - It must always points to a valid value of whatever the pointee type is.\n/// - The lifetime `'a` accurately represents how long the pointer is valid for.\n/// - Must be sufficiently aligned for the unknown pointee type.\n///\n/// It may be helpful to think of this type as similar to `&'a mut ManuallyDrop<dyn Any>` but\n/// without the metadata and able to point to data that does not correspond to a Rust type.\n#[derive(Debug)]\n#[repr(transparent)]\npub struct OwningPtr<'a, A: IsAligned = Aligned>(NonNull<u8>, PhantomData<(&'a mut u8, A)>);\n\nmacro_rules! impl_ptr {\n    ($ptr:ident) => {\n        impl<'a> $ptr<'a, Aligned> {\n            /// Removes the alignment requirement of this pointer\n            pub fn to_unaligned(self) -> $ptr<'a, Unaligned> {\n                $ptr(self.0, PhantomData)\n            }\n        }\n\n        impl<'a, A: IsAligned> From<$ptr<'a, A>> for NonNull<u8> {\n            fn from(ptr: $ptr<'a, A>) -> Self {\n                ptr.0\n            }\n        }\n\n        impl<A: IsAligned> $ptr<'_, A> {\n            /// Calculates the offset from a pointer.\n            /// As the pointer is type-erased, there is no size information available. The provided\n            /// `count` parameter is in raw bytes.\n            ///\n            /// *See also: [`ptr::offset`][ptr_offset]*\n            ///\n            /// # Safety\n            /// - The offset cannot make the existing ptr null, or take it out of bounds for its allocation.\n            /// - If the `A` type parameter is [`Aligned`] then the offset must not make the resulting pointer\n            ///   be unaligned for the pointee type.\n            /// - The value pointed by the resulting pointer must outlive the lifetime of this pointer.\n            ///\n            /// [ptr_offset]: https://doc.rust-lang.org/std/primitive.pointer.html#method.offset\n            #[inline]\n            pub unsafe fn byte_offset(self, count: isize) -> Self {\n                Self(\n                    // SAFETY: The caller upholds safety for `offset` and ensures the result is not null.\n                    unsafe { NonNull::new_unchecked(self.as_ptr().offset(count)) },\n                    PhantomData,\n                )\n            }\n\n            /// Calculates the offset from a pointer (convenience for `.offset(count as isize)`).\n            /// As the pointer is type-erased, there is no size information available. The provided\n            /// `count` parameter is in raw bytes.\n            ///\n            /// *See also: [`ptr::add`][ptr_add]*\n            ///\n            /// # Safety\n            /// - The offset cannot make the existing ptr null, or take it out of bounds for its allocation.\n            /// - If the `A` type parameter is [`Aligned`] then the offset must not make the resulting pointer\n            ///   be unaligned for the pointee type.\n            /// - The value pointed by the resulting pointer must outlive the lifetime of this pointer.\n            ///\n            /// [ptr_add]: https://doc.rust-lang.org/std/primitive.pointer.html#method.add\n            #[inline]\n            pub unsafe fn byte_add(self, count: usize) -> Self {\n                Self(\n                    // SAFETY: The caller upholds safety for `add` and ensures the result is not null.\n                    unsafe { NonNull::new_unchecked(self.as_ptr().add(count)) },\n                    PhantomData,\n                )\n            }\n        }\n\n        impl<A: IsAligned> Pointer for $ptr<'_, A> {\n            #[inline]\n            fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n                Pointer::fmt(&self.0, f)\n            }\n        }\n    };\n}\n\nimpl_ptr!(Ptr);\nimpl_ptr!(PtrMut);\nimpl_ptr!(OwningPtr);\n\nimpl<'a, A: IsAligned> Ptr<'a, A> {\n    /// Creates a new instance from a raw pointer.\n    ///\n    /// # Safety\n    /// - `inner` must point to valid value of whatever the pointee type is.\n    /// - If the `A` type parameter is [`Aligned`] then `inner` must be sufficiently aligned for the pointee type.\n    /// - `inner` must have correct provenance to allow reads of the pointee type.\n    /// - The lifetime `'a` must be constrained such that this [`Ptr`] will stay valid and nothing\n    ///   can mutate the pointee while this [`Ptr`] is live except through an [`UnsafeCell`].\n    #[inline]\n    pub unsafe fn new(inner: NonNull<u8>) -> Self {\n        Self(inner, PhantomData)\n    }\n\n    /// Transforms this [`Ptr`] into an [`PtrMut`]\n    ///\n    /// # Safety\n    /// Another [`PtrMut`] for the same [`Ptr`] must not be created until the first is dropped.\n    #[inline]\n    pub unsafe fn assert_unique(self) -> PtrMut<'a, A> {\n        PtrMut(self.0, PhantomData)\n    }\n\n    /// Transforms this [`Ptr<T>`] into a `&T` with the same lifetime\n    ///\n    /// # Safety\n    /// - `T` must be the erased pointee type for this [`Ptr`].\n    /// - If the type parameter `A` is [`Unaligned`] then this pointer must be sufficiently aligned\n    ///   for the pointee type `T`.\n    #[inline]\n    pub unsafe fn deref<T>(self) -> &'a T {\n        let ptr = self.as_ptr().cast::<T>().debug_ensure_aligned();\n        // SAFETY: The caller ensures the pointee is of type `T` and the pointer can be dereferenced.\n        unsafe { &*ptr }\n    }\n\n    /// Gets the underlying pointer, erasing the associated lifetime.\n    ///\n    /// If possible, it is strongly encouraged to use [`deref`](Self::deref) over this function,\n    /// as it retains the lifetime.\n    #[inline]\n    pub fn as_ptr(self) -> *mut u8 {\n        self.0.as_ptr()\n    }\n}\n\nimpl<'a, T: ?Sized> From<&'a T> for Ptr<'a> {\n    #[inline]\n    fn from(val: &'a T) -> Self {\n        // SAFETY: The returned pointer has the same lifetime as the passed reference.\n        // Access is immutable.\n        unsafe { Self::new(NonNull::from(val).cast()) }\n    }\n}\n\nimpl<'a, A: IsAligned> PtrMut<'a, A> {\n    /// Creates a new instance from a raw pointer.\n    ///\n    /// # Safety\n    /// - `inner` must point to valid value of whatever the pointee type is.\n    /// - If the `A` type parameter is [`Aligned`] then `inner` must be sufficiently aligned for the pointee type.\n    /// - `inner` must have correct provenance to allow read and writes of the pointee type.\n    /// - The lifetime `'a` must be constrained such that this [`PtrMut`] will stay valid and nothing\n    ///   else can read or mutate the pointee while this [`PtrMut`] is live.\n    #[inline]\n    pub unsafe fn new(inner: NonNull<u8>) -> Self {\n        Self(inner, PhantomData)\n    }\n\n    /// Transforms this [`PtrMut`] into an [`OwningPtr`]\n    ///\n    /// # Safety\n    /// Must have right to drop or move out of [`PtrMut`].\n    #[inline]\n    pub unsafe fn promote(self) -> OwningPtr<'a, A> {\n        OwningPtr(self.0, PhantomData)\n    }\n\n    /// Transforms this [`PtrMut<T>`] into a `&mut T` with the same lifetime\n    ///\n    /// # Safety\n    /// - `T` must be the erased pointee type for this [`PtrMut`].\n    /// - If the type parameter `A` is [`Unaligned`] then this pointer must be sufficiently aligned\n    ///   for the pointee type `T`.\n    #[inline]\n    pub unsafe fn deref_mut<T>(self) -> &'a mut T {\n        let ptr = self.as_ptr().cast::<T>().debug_ensure_aligned();\n        // SAFETY: The caller ensures the pointee is of type `T` and the pointer can be dereferenced.\n        unsafe { &mut *ptr }\n    }\n\n    /// Gets the underlying pointer, erasing the associated lifetime.\n    ///\n    /// If possible, it is strongly encouraged to use [`deref_mut`](Self::deref_mut) over\n    /// this function, as it retains the lifetime.\n    #[inline]\n    pub fn as_ptr(&self) -> *mut u8 {\n        self.0.as_ptr()\n    }\n\n    /// Gets a [`PtrMut`] from this with a smaller lifetime.\n    #[inline]\n    pub fn reborrow(&mut self) -> PtrMut<'_, A> {\n        // SAFETY: the ptrmut we're borrowing from is assumed to be valid\n        unsafe { PtrMut::new(self.0) }\n    }\n\n    /// Gets an immutable reference from this mutable reference\n    #[inline]\n    pub fn as_ref(&self) -> Ptr<'_, A> {\n        // SAFETY: The `PtrMut` type's guarantees about the validity of this pointer are a superset of `Ptr` s guarantees\n        unsafe { Ptr::new(self.0) }\n    }\n}\n\nimpl<'a, T: ?Sized> From<&'a mut T> for PtrMut<'a> {\n    #[inline]\n    fn from(val: &'a mut T) -> Self {\n        // SAFETY: The returned pointer has the same lifetime as the passed reference.\n        // The reference is mutable, and thus will not alias.\n        unsafe { Self::new(NonNull::from(val).cast()) }\n    }\n}\n\nimpl<'a> OwningPtr<'a> {\n    /// Consumes a value and creates an [`OwningPtr`] to it while ensuring a double drop does not happen.\n    #[inline]\n    pub fn make<T, F: FnOnce(OwningPtr<'_>) -> R, R>(val: T, f: F) -> R {\n        let mut temp = ManuallyDrop::new(val);\n        // SAFETY: The value behind the pointer will not get dropped or observed later,\n        // so it's safe to promote it to an owning pointer.\n        f(unsafe { PtrMut::from(&mut *temp).promote() })\n    }\n}\n\nimpl<'a, A: IsAligned> OwningPtr<'a, A> {\n    /// Creates a new instance from a raw pointer.\n    ///\n    /// # Safety\n    /// - `inner` must point to valid value of whatever the pointee type is.\n    /// - If the `A` type parameter is [`Aligned`] then `inner` must be sufficiently aligned for the pointee type.\n    /// - `inner` must have correct provenance to allow read and writes of the pointee type.\n    /// - The lifetime `'a` must be constrained such that this [`OwningPtr`] will stay valid and nothing\n    ///   else can read or mutate the pointee while this [`OwningPtr`] is live.\n    #[inline]\n    pub unsafe fn new(inner: NonNull<u8>) -> Self {\n        Self(inner, PhantomData)\n    }\n\n    /// Consumes the [`OwningPtr`] to obtain ownership of the underlying data of type `T`.\n    ///\n    /// # Safety\n    /// - `T` must be the erased pointee type for this [`OwningPtr`].\n    /// - If the type parameter `A` is [`Unaligned`] then this pointer must be sufficiently aligned\n    ///   for the pointee type `T`.\n    #[inline]\n    pub unsafe fn read<T>(self) -> T {\n        let ptr = self.as_ptr().cast::<T>().debug_ensure_aligned();\n        // SAFETY: The caller ensure the pointee is of type `T` and uphold safety for `read`.\n        unsafe { ptr.read() }\n    }\n\n    /// Consumes the [`OwningPtr`] to drop the underlying data of type `T`.\n    ///\n    /// # Safety\n    /// - `T` must be the erased pointee type for this [`OwningPtr`].\n    /// - If the type parameter `A` is [`Unaligned`] then this pointer must be sufficiently aligned\n    ///   for the pointee type `T`.\n    #[inline]\n    pub unsafe fn drop_as<T>(self) {\n        let ptr = self.as_ptr().cast::<T>().debug_ensure_aligned();\n        // SAFETY: The caller ensure the pointee is of type `T` and uphold safety for `drop_in_place`.\n        unsafe {\n            ptr.drop_in_place();\n        }\n    }\n\n    /// Gets the underlying pointer, erasing the associated lifetime.\n    ///\n    /// If possible, it is strongly encouraged to use the other more type-safe functions\n    /// over this function.\n    #[inline]\n    pub fn as_ptr(&self) -> *mut u8 {\n        self.0.as_ptr()\n    }\n\n    /// Gets an immutable pointer from this owned pointer.\n    #[inline]\n    pub fn as_ref(&self) -> Ptr<'_, A> {\n        // SAFETY: The `Owning` type's guarantees about the validity of this pointer are a superset of `Ptr` s guarantees\n        unsafe { Ptr::new(self.0) }\n    }\n\n    /// Gets a mutable pointer from this owned pointer.\n    #[inline]\n    pub fn as_mut(&mut self) -> PtrMut<'_, A> {\n        // SAFETY: The `Owning` type's guarantees about the validity of this pointer are a superset of `Ptr` s guarantees\n        unsafe { PtrMut::new(self.0) }\n    }\n}\n\nimpl<'a> OwningPtr<'a, Unaligned> {\n    /// Consumes the [`OwningPtr`] to obtain ownership of the underlying data of type `T`.\n    ///\n    /// # Safety\n    /// - `T` must be the erased pointee type for this [`OwningPtr`].\n    pub unsafe fn read_unaligned<T>(self) -> T {\n        let ptr = self.as_ptr().cast::<T>();\n        // SAFETY: The caller ensure the pointee is of type `T` and uphold safety for `read_unaligned`.\n        unsafe { ptr.read_unaligned() }\n    }\n}\n\n/// Conceptually equivalent to `&'a [T]` but with length information cut out for performance reasons\npub struct ThinSlicePtr<'a, T> {\n    ptr: NonNull<T>,\n    #[cfg(debug_assertions)]\n    len: usize,\n    _marker: PhantomData<&'a [T]>,\n}\n\nimpl<'a, T> ThinSlicePtr<'a, T> {\n    #[inline]\n    /// Indexes the slice without doing bounds checks\n    ///\n    /// # Safety\n    /// `index` must be in-bounds.\n    pub unsafe fn get(self, index: usize) -> &'a T {\n        #[cfg(debug_assertions)]\n        debug_assert!(index < self.len);\n\n        let ptr = self.ptr.as_ptr();\n        // SAFETY: `index` is in-bounds so the resulting pointer is valid to dereference.\n        unsafe { &*ptr.add(index) }\n    }\n}\n\nimpl<'a, T> Clone for ThinSlicePtr<'a, T> {\n    fn clone(&self) -> Self {\n        *self\n    }\n}\n\nimpl<'a, T> Copy for ThinSlicePtr<'a, T> {}\n\nimpl<'a, T> From<&'a [T]> for ThinSlicePtr<'a, T> {\n    #[inline]\n    fn from(slice: &'a [T]) -> Self {\n        let ptr = slice.as_ptr().cast_mut();\n        Self {\n            // SAFETY: a reference can never be null\n            ptr: unsafe { NonNull::new_unchecked(ptr.debug_ensure_aligned()) },\n            #[cfg(debug_assertions)]\n            len: slice.len(),\n            _marker: PhantomData,\n        }\n    }\n}\n\n/// Creates a dangling pointer with specified alignment.\n/// See [`NonNull::dangling`].\npub const fn dangling_with_align(align: NonZeroUsize) -> NonNull<u8> {\n    debug_assert!(align.is_power_of_two(), \"Alignment must be power of two.\");\n    // SAFETY: The pointer will not be null, since it was created\n    // from the address of a `NonZero<usize>`.\n    // TODO: use https://doc.rust-lang.org/std/ptr/struct.NonNull.html#method.with_addr once stabilized\n    unsafe { NonNull::new_unchecked(ptr::null_mut::<u8>().wrapping_add(align.get())) }\n}\n\nmod private {\n    use core::cell::UnsafeCell;\n\n    pub trait SealedUnsafeCell {}\n    impl<'a, T> SealedUnsafeCell for &'a UnsafeCell<T> {}\n}\n\n/// Extension trait for helper methods on [`UnsafeCell`]\npub trait UnsafeCellDeref<'a, T>: private::SealedUnsafeCell {\n    /// # Safety\n    /// - The returned value must be unique and not alias any mutable or immutable references to the contents of the [`UnsafeCell`].\n    /// - At all times, you must avoid data races. If multiple threads have access to the same [`UnsafeCell`], then any writes must have a proper happens-before relation to all other accesses or use atomics ([`UnsafeCell`] docs for reference).\n    unsafe fn deref_mut(self) -> &'a mut T;\n\n    /// # Safety\n    /// - For the lifetime `'a` of the returned value you must not construct a mutable reference to the contents of the [`UnsafeCell`].\n    /// - At all times, you must avoid data races. If multiple threads have access to the same [`UnsafeCell`], then any writes must have a proper happens-before relation to all other accesses or use atomics ([`UnsafeCell`] docs for reference).\n    unsafe fn deref(self) -> &'a T;\n\n    /// Returns a copy of the contained value.\n    ///\n    /// # Safety\n    /// - The [`UnsafeCell`] must not currently have a mutable reference to its content.\n    /// - At all times, you must avoid data races. If multiple threads have access to the same [`UnsafeCell`], then any writes must have a proper happens-before relation to all other accesses or use atomics ([`UnsafeCell`] docs for reference).\n    unsafe fn read(self) -> T\n    where\n        T: Copy;\n}\n\nimpl<'a, T> UnsafeCellDeref<'a, T> for &'a UnsafeCell<T> {\n    #[inline]\n    unsafe fn deref_mut(self) -> &'a mut T {\n        // SAFETY: The caller upholds the alias rules.\n        unsafe { &mut *self.get() }\n    }\n    #[inline]\n    unsafe fn deref(self) -> &'a T {\n        // SAFETY: The caller upholds the alias rules.\n        unsafe { &*self.get() }\n    }\n\n    #[inline]\n    unsafe fn read(self) -> T\n    where\n        T: Copy,\n    {\n        // SAFETY: The caller upholds the alias rules.\n        unsafe { self.get().read() }\n    }\n}\n\ntrait DebugEnsureAligned {\n    fn debug_ensure_aligned(self) -> Self;\n}\n\n// Disable this for miri runs as it already checks if pointer to reference\n// casts are properly aligned.\n#[cfg(all(debug_assertions, not(miri)))]\nimpl<T: Sized> DebugEnsureAligned for *mut T {\n    #[track_caller]\n    fn debug_ensure_aligned(self) -> Self {\n        let align = align_of::<T>();\n        // Implementation shamelessly borrowed from the currently unstable\n        // ptr.is_aligned_to.\n        //\n        // Replace once https://github.com/rust-lang/rust/issues/96284 is stable.\n        assert_eq!(\n            self as usize & (align - 1),\n            0,\n            \"pointer is not aligned. Address {:p} does not have alignment {} for type {}\",\n            self,\n            align,\n            core::any::type_name::<T>()\n        );\n        self\n    }\n}\n\n#[cfg(any(not(debug_assertions), miri))]\nimpl<T: Sized> DebugEnsureAligned for *mut T {\n    #[inline(always)]\n    fn debug_ensure_aligned(self) -> Self {\n        self\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "77d55f67c5fe84a667243afaf8d4ed7bc35412c3",
    "func": "use diesel::backend::Backend;\nuse diesel::query_builder::*;\nuse diesel::result::QueryResult;\nuse diesel::RunQueryDsl;\n\n#[derive(Debug, Clone)]\npub struct DropDatabaseStatement {\n    db_name: String,\n    if_exists: bool,\n}\n\nimpl DropDatabaseStatement {\n    pub fn new(db_name: &str) -> Self {\n        DropDatabaseStatement {\n            db_name: db_name.to_owned(),\n            if_exists: false,\n        }\n    }\n\n    pub fn if_exists(self) -> Self {\n        DropDatabaseStatement {\n            if_exists: true,\n            ..self\n        }\n    }\n}\n\nimpl<DB: Backend> QueryFragment<DB> for DropDatabaseStatement {\n    fn walk_ast<'b>(&'b self, mut out: AstPass<'_, 'b, DB>) -> QueryResult<()> {\n        out.push_sql(\"DROP DATABASE \");\n        if self.if_exists {\n            out.push_sql(\"IF EXISTS \");\n        }\n        out.push_identifier(&self.db_name)?;\n        Ok(())\n    }\n}\n\nimpl<Conn> RunQueryDsl<Conn> for DropDatabaseStatement {}\n\nimpl QueryId for DropDatabaseStatement {\n    type QueryId = ();\n\n    const HAS_STATIC_QUERY_ID: bool = false;\n}\n\n#[derive(Debug, Clone)]\npub struct CreateDatabaseStatement {\n    db_name: String,\n}\n\nimpl CreateDatabaseStatement {\n    pub fn new(db_name: &str) -> Self {\n        CreateDatabaseStatement {\n            db_name: db_name.to_owned(),\n        }\n    }\n}\n\nimpl<DB: Backend> QueryFragment<DB> for CreateDatabaseStatement {\n    fn walk_ast<'b>(&'b self, mut out: AstPass<'_, 'b, DB>) -> QueryResult<()> {\n        out.push_sql(\"CREATE DATABASE \");\n        out.push_identifier(&self.db_name)?;\n        Ok(())\n    }\n}\n\nimpl<Conn> RunQueryDsl<Conn> for CreateDatabaseStatement {}\n\nimpl QueryId for CreateDatabaseStatement {\n    type QueryId = ();\n\n    const HAS_STATIC_QUERY_ID: bool = false;\n}\n\npub fn drop_database(db_name: &str) -> DropDatabaseStatement {\n    DropDatabaseStatement::new(db_name)\n}\n\npub fn create_database(db_name: &str) -> CreateDatabaseStatement {\n    CreateDatabaseStatement::new(db_name)\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "f52efa6e7f5ba562439607eeaa3bd4c0dbbc0b96",
    "func": "use criterion::{criterion_group, BatchSize, Bencher, BenchmarkId, Criterion};\nuse ratatui::{\n    buffer::Buffer,\n    layout::{Constraint, Rect},\n    widgets::{Row, StatefulWidget, Table, TableState, Widget},\n};\n\n/// Benchmark for rendering a table.\n/// It only benchmarks the render with a different number of rows, and columns.\nfn table(c: &mut Criterion) {\n    let mut group = c.benchmark_group(\"table\");\n\n    for row_count in [64, 2048, 16384] {\n        for col_count in [2, 4, 8] {\n            let bench_sizes = format!(\"{row_count}x{col_count}\");\n            let rows: Vec<Row> = (0..row_count)\n                .map(|_| Row::new((0..col_count).map(|_| fakeit::words::quote())))\n                .collect();\n\n            // Render default table\n            group.bench_with_input(\n                BenchmarkId::new(\"render\", &bench_sizes),\n                &Table::new(rows.clone(), [] as [Constraint; 0]),\n                render,\n            );\n\n            // Render with an offset to the middle of the table and a selected row\n            group.bench_with_input(\n                BenchmarkId::new(\"render_scroll_half\", &bench_sizes),\n                &Table::new(rows, [] as [Constraint; 0]).highlight_symbol(\">>\"),\n                |b, table| {\n                    render_stateful(\n                        b,\n                        table,\n                        TableState::default()\n                            .with_offset(row_count / 2)\n                            .with_selected(Some(row_count / 2)),\n                    );\n                },\n            );\n        }\n    }\n\n    group.finish();\n}\n\nfn render(bencher: &mut Bencher, table: &Table) {\n    let mut buffer = Buffer::empty(Rect::new(0, 0, 200, 50));\n    bencher.iter_batched(\n        || table.to_owned(),\n        |bench_table| {\n            Widget::render(bench_table, buffer.area, &mut buffer);\n        },\n        BatchSize::LargeInput,\n    );\n}\n\nfn render_stateful(bencher: &mut Bencher, table: &Table, mut state: TableState) {\n    let mut buffer = Buffer::empty(Rect::new(0, 0, 200, 50));\n    bencher.iter_batched(\n        || table.to_owned(),\n        |bench_table| {\n            StatefulWidget::render(bench_table, buffer.area, &mut buffer, &mut state);\n        },\n        BatchSize::LargeInput,\n    );\n}\n\ncriterion_group!(benches, table);\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "3ec7ea2d16dfc7386daab4228a79422250b2d68d",
    "func": "//! Windows-specific types for signal handling.\n//!\n//! This module is only defined on Windows and allows receiving \"ctrl-c\",\n//! \"ctrl-break\", \"ctrl-logoff\", \"ctrl-shutdown\", and \"ctrl-close\"\n//! notifications. These events are listened for via the `SetConsoleCtrlHandler`\n//! function which receives the corresponding `windows_sys` event type.\n\n#![cfg(any(windows, docsrs))]\n#![cfg_attr(docsrs, doc(cfg(all(windows, feature = \"signal\"))))]\n\nuse crate::signal::RxFuture;\nuse std::io;\nuse std::task::{Context, Poll};\n\n#[cfg(not(docsrs))]\n#[path = \"windows/sys.rs\"]\nmod imp;\n#[cfg(not(docsrs))]\npub(crate) use self::imp::{OsExtraData, OsStorage};\n\n#[cfg(docsrs)]\n#[path = \"windows/stub.rs\"]\nmod imp;\n\n/// Creates a new listener which receives \"ctrl-c\" notifications sent to the\n/// process.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// use tokio::signal::windows::ctrl_c;\n///\n/// #[tokio::main]\n/// async fn main() -> Result<(), Box<dyn std::error::Error>> {\n///     // A listener of CTRL-C events.\n///     let mut signal = ctrl_c()?;\n///\n///     // Print whenever a CTRL-C event is received.\n///     for countdown in (0..3).rev() {\n///         signal.recv().await;\n///         println!(\"got CTRL-C. {} more to exit\", countdown);\n///     }\n///\n///     Ok(())\n/// }\n/// ```\npub fn ctrl_c() -> io::Result<CtrlC> {\n    Ok(CtrlC {\n        inner: self::imp::ctrl_c()?,\n    })\n}\n\n/// Represents a listener which receives \"ctrl-c\" notifications sent to the process\n/// via `SetConsoleCtrlHandler`.\n///\n/// This event can be turned into a `Stream` using [`CtrlCStream`].\n///\n/// [`CtrlCStream`]: https://docs.rs/tokio-stream/latest/tokio_stream/wrappers/struct.CtrlCStream.html\n///\n/// A notification to this process notifies *all* receivers for\n/// this event. Moreover, the notifications **are coalesced** if they aren't processed\n/// quickly enough. This means that if two notifications are received back-to-back,\n/// then the listener may only receive one item about the two notifications.\n#[must_use = \"listeners do nothing unless polled\"]\n#[derive(Debug)]\npub struct CtrlC {\n    inner: RxFuture,\n}\n\nimpl CtrlC {\n    /// Receives the next signal notification event.\n    ///\n    /// `None` is returned if no more events can be received by the listener.\n    ///\n    /// # Examples\n    ///\n    /// ```rust,no_run\n    /// use tokio::signal::windows::ctrl_c;\n    ///\n    /// #[tokio::main]\n    /// async fn main() -> Result<(), Box<dyn std::error::Error>> {\n    ///     let mut signal = ctrl_c()?;\n    ///\n    ///     // Print whenever a CTRL-C event is received.\n    ///     for countdown in (0..3).rev() {\n    ///         signal.recv().await;\n    ///         println!(\"got CTRL-C. {} more to exit\", countdown);\n    ///     }\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    pub async fn recv(&mut self) -> Option<()> {\n        self.inner.recv().await\n    }\n\n    /// Polls to receive the next signal notification event, outside of an\n    /// `async` context.\n    ///\n    /// `None` is returned if no more events can be received.\n    ///\n    /// # Examples\n    ///\n    /// Polling from a manually implemented future\n    ///\n    /// ```rust,no_run\n    /// use std::pin::Pin;\n    /// use std::future::Future;\n    /// use std::task::{Context, Poll};\n    /// use tokio::signal::windows::CtrlC;\n    ///\n    /// struct MyFuture {\n    ///     ctrl_c: CtrlC,\n    /// }\n    ///\n    /// impl Future for MyFuture {\n    ///     type Output = Option<()>;\n    ///\n    ///     fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n    ///         println!(\"polling MyFuture\");\n    ///         self.ctrl_c.poll_recv(cx)\n    ///     }\n    /// }\n    /// ```\n    pub fn poll_recv(&mut self, cx: &mut Context<'_>) -> Poll<Option<()>> {\n        self.inner.poll_recv(cx)\n    }\n}\n\n/// Represents a listener which receives \"ctrl-break\" notifications sent to the process\n/// via `SetConsoleCtrlHandler`.\n///\n/// This listener can be turned into a `Stream` using [`CtrlBreakStream`].\n///\n/// [`CtrlBreakStream`]: https://docs.rs/tokio-stream/latest/tokio_stream/wrappers/struct.CtrlBreakStream.html\n///\n/// A notification to this process notifies *all* receivers for\n/// this event. Moreover, the notifications **are coalesced** if they aren't processed\n/// quickly enough. This means that if two notifications are received back-to-back,\n/// then the listener may only receive one item about the two notifications.\n#[must_use = \"listeners do nothing unless polled\"]\n#[derive(Debug)]\npub struct CtrlBreak {\n    inner: RxFuture,\n}\n\nimpl CtrlBreak {\n    /// Receives the next signal notification event.\n    ///\n    /// `None` is returned if no more events can be received by this listener.\n    ///\n    /// # Examples\n    ///\n    /// ```rust,no_run\n    /// use tokio::signal::windows::ctrl_break;\n    ///\n    /// #[tokio::main]\n    /// async fn main() -> Result<(), Box<dyn std::error::Error>> {\n    ///     // A listener of CTRL-BREAK events.\n    ///     let mut signal = ctrl_break()?;\n    ///\n    ///     // Print whenever a CTRL-BREAK event is received.\n    ///     loop {\n    ///         signal.recv().await;\n    ///         println!(\"got signal CTRL-BREAK\");\n    ///     }\n    /// }\n    /// ```\n    pub async fn recv(&mut self) -> Option<()> {\n        self.inner.recv().await\n    }\n\n    /// Polls to receive the next signal notification event, outside of an\n    /// `async` context.\n    ///\n    /// `None` is returned if no more events can be received by this listener.\n    ///\n    /// # Examples\n    ///\n    /// Polling from a manually implemented future\n    ///\n    /// ```rust,no_run\n    /// use std::pin::Pin;\n    /// use std::future::Future;\n    /// use std::task::{Context, Poll};\n    /// use tokio::signal::windows::CtrlBreak;\n    ///\n    /// struct MyFuture {\n    ///     ctrl_break: CtrlBreak,\n    /// }\n    ///\n    /// impl Future for MyFuture {\n    ///     type Output = Option<()>;\n    ///\n    ///     fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n    ///         println!(\"polling MyFuture\");\n    ///         self.ctrl_break.poll_recv(cx)\n    ///     }\n    /// }\n    /// ```\n    pub fn poll_recv(&mut self, cx: &mut Context<'_>) -> Poll<Option<()>> {\n        self.inner.poll_recv(cx)\n    }\n}\n\n/// Creates a new listener which receives \"ctrl-break\" notifications sent to the\n/// process.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// use tokio::signal::windows::ctrl_break;\n///\n/// #[tokio::main]\n/// async fn main() -> Result<(), Box<dyn std::error::Error>> {\n///     // A listener of CTRL-BREAK events.\n///     let mut signal = ctrl_break()?;\n///\n///     // Print whenever a CTRL-BREAK event is received.\n///     loop {\n///         signal.recv().await;\n///         println!(\"got signal CTRL-BREAK\");\n///     }\n/// }\n/// ```\npub fn ctrl_break() -> io::Result<CtrlBreak> {\n    Ok(CtrlBreak {\n        inner: self::imp::ctrl_break()?,\n    })\n}\n\n/// Creates a new listener which receives \"ctrl-close\" notifications sent to the\n/// process.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// use tokio::signal::windows::ctrl_close;\n///\n/// #[tokio::main]\n/// async fn main() -> Result<(), Box<dyn std::error::Error>> {\n///     // A listener of CTRL-CLOSE events.\n///     let mut signal = ctrl_close()?;\n///\n///     // Print whenever a CTRL-CLOSE event is received.\n///     for countdown in (0..3).rev() {\n///         signal.recv().await;\n///         println!(\"got CTRL-CLOSE. {} more to exit\", countdown);\n///     }\n///\n///     Ok(())\n/// }\n/// ```\npub fn ctrl_close() -> io::Result<CtrlClose> {\n    Ok(CtrlClose {\n        inner: self::imp::ctrl_close()?,\n    })\n}\n\n/// Represents a listener which receives \"ctrl-close\" notifications sent to the process\n/// via `SetConsoleCtrlHandler`.\n///\n/// A notification to this process notifies *all* listeners listening for\n/// this event. Moreover, the notifications **are coalesced** if they aren't processed\n/// quickly enough. This means that if two notifications are received back-to-back,\n/// then the listener may only receive one item about the two notifications.\n#[must_use = \"listeners do nothing unless polled\"]\n#[derive(Debug)]\npub struct CtrlClose {\n    inner: RxFuture,\n}\n\nimpl CtrlClose {\n    /// Receives the next signal notification event.\n    ///\n    /// `None` is returned if no more events can be received by this listener.\n    ///\n    /// # Examples\n    ///\n    /// ```rust,no_run\n    /// use tokio::signal::windows::ctrl_close;\n    ///\n    /// #[tokio::main]\n    /// async fn main() -> Result<(), Box<dyn std::error::Error>> {\n    ///     // A listener of CTRL-CLOSE events.\n    ///     let mut signal = ctrl_close()?;\n    ///\n    ///     // Print whenever a CTRL-CLOSE event is received.\n    ///     signal.recv().await;\n    ///     println!(\"got CTRL-CLOSE. Cleaning up before exiting\");\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    pub async fn recv(&mut self) -> Option<()> {\n        self.inner.recv().await\n    }\n\n    /// Polls to receive the next signal notification event, outside of an\n    /// `async` context.\n    ///\n    /// `None` is returned if no more events can be received by this listener.\n    ///\n    /// # Examples\n    ///\n    /// Polling from a manually implemented future\n    ///\n    /// ```rust,no_run\n    /// use std::pin::Pin;\n    /// use std::future::Future;\n    /// use std::task::{Context, Poll};\n    /// use tokio::signal::windows::CtrlClose;\n    ///\n    /// struct MyFuture {\n    ///     ctrl_close: CtrlClose,\n    /// }\n    ///\n    /// impl Future for MyFuture {\n    ///     type Output = Option<()>;\n    ///\n    ///     fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n    ///         println!(\"polling MyFuture\");\n    ///         self.ctrl_close.poll_recv(cx)\n    ///     }\n    /// }\n    /// ```\n    pub fn poll_recv(&mut self, cx: &mut Context<'_>) -> Poll<Option<()>> {\n        self.inner.poll_recv(cx)\n    }\n}\n\n/// Creates a new listener which receives \"ctrl-shutdown\" notifications sent to the\n/// process.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// use tokio::signal::windows::ctrl_shutdown;\n///\n/// #[tokio::main]\n/// async fn main() -> Result<(), Box<dyn std::error::Error>> {\n///     // A listener of CTRL-SHUTDOWN events.\n///     let mut signal = ctrl_shutdown()?;\n///\n///     signal.recv().await;\n///     println!(\"got CTRL-SHUTDOWN. Cleaning up before exiting\");\n///\n///     Ok(())\n/// }\n/// ```\npub fn ctrl_shutdown() -> io::Result<CtrlShutdown> {\n    Ok(CtrlShutdown {\n        inner: self::imp::ctrl_shutdown()?,\n    })\n}\n\n/// Represents a listener which receives \"ctrl-shutdown\" notifications sent to the process\n/// via `SetConsoleCtrlHandler`.\n///\n/// A notification to this process notifies *all* listeners listening for\n/// this event. Moreover, the notifications **are coalesced** if they aren't processed\n/// quickly enough. This means that if two notifications are received back-to-back,\n/// then the listener may only receive one item about the two notifications.\n#[must_use = \"listeners do nothing unless polled\"]\n#[derive(Debug)]\npub struct CtrlShutdown {\n    inner: RxFuture,\n}\n\nimpl CtrlShutdown {\n    /// Receives the next signal notification event.\n    ///\n    /// `None` is returned if no more events can be received by this listener.\n    ///\n    /// # Examples\n    ///\n    /// ```rust,no_run\n    /// use tokio::signal::windows::ctrl_shutdown;\n    ///\n    /// #[tokio::main]\n    /// async fn main() -> Result<(), Box<dyn std::error::Error>> {\n    ///     // A listener of CTRL-SHUTDOWN events.\n    ///     let mut signal = ctrl_shutdown()?;\n    ///\n    ///     // Print whenever a CTRL-SHUTDOWN event is received.\n    ///     signal.recv().await;\n    ///     println!(\"got CTRL-SHUTDOWN. Cleaning up before exiting\");\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    pub async fn recv(&mut self) -> Option<()> {\n        self.inner.recv().await\n    }\n\n    /// Polls to receive the next signal notification event, outside of an\n    /// `async` context.\n    ///\n    /// `None` is returned if no more events can be received by this listener.\n    ///\n    /// # Examples\n    ///\n    /// Polling from a manually implemented future\n    ///\n    /// ```rust,no_run\n    /// use std::pin::Pin;\n    /// use std::future::Future;\n    /// use std::task::{Context, Poll};\n    /// use tokio::signal::windows::CtrlShutdown;\n    ///\n    /// struct MyFuture {\n    ///     ctrl_shutdown: CtrlShutdown,\n    /// }\n    ///\n    /// impl Future for MyFuture {\n    ///     type Output = Option<()>;\n    ///\n    ///     fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n    ///         println!(\"polling MyFuture\");\n    ///         self.ctrl_shutdown.poll_recv(cx)\n    ///     }\n    /// }\n    /// ```\n    pub fn poll_recv(&mut self, cx: &mut Context<'_>) -> Poll<Option<()>> {\n        self.inner.poll_recv(cx)\n    }\n}\n\n/// Creates a new listener which receives \"ctrl-logoff\" notifications sent to the\n/// process.\n///\n/// # Examples\n///\n/// ```rust,no_run\n/// use tokio::signal::windows::ctrl_logoff;\n///\n/// #[tokio::main]\n/// async fn main() -> Result<(), Box<dyn std::error::Error>> {\n///     // A listener of CTRL-LOGOFF events.\n///     let mut signal = ctrl_logoff()?;\n///\n///     signal.recv().await;\n///     println!(\"got CTRL-LOGOFF. Cleaning up before exiting\");\n///\n///     Ok(())\n/// }\n/// ```\npub fn ctrl_logoff() -> io::Result<CtrlLogoff> {\n    Ok(CtrlLogoff {\n        inner: self::imp::ctrl_logoff()?,\n    })\n}\n\n/// Represents a listener which receives \"ctrl-logoff\" notifications sent to the process\n/// via `SetConsoleCtrlHandler`.\n///\n/// A notification to this process notifies *all* listeners listening for\n/// this event. Moreover, the notifications **are coalesced** if they aren't processed\n/// quickly enough. This means that if two notifications are received back-to-back,\n/// then the listener may only receive one item about the two notifications.\n#[must_use = \"listeners do nothing unless polled\"]\n#[derive(Debug)]\npub struct CtrlLogoff {\n    inner: RxFuture,\n}\n\nimpl CtrlLogoff {\n    /// Receives the next signal notification event.\n    ///\n    /// `None` is returned if no more events can be received by this listener.\n    ///\n    /// # Examples\n    ///\n    /// ```rust,no_run\n    /// use tokio::signal::windows::ctrl_logoff;\n    ///\n    /// #[tokio::main]\n    /// async fn main() -> Result<(), Box<dyn std::error::Error>> {\n    ///     // An listener of CTRL-LOGOFF events.\n    ///     let mut signal = ctrl_logoff()?;\n    ///\n    ///     // Print whenever a CTRL-LOGOFF event is received.\n    ///     signal.recv().await;\n    ///     println!(\"got CTRL-LOGOFF. Cleaning up before exiting\");\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    pub async fn recv(&mut self) -> Option<()> {\n        self.inner.recv().await\n    }\n\n    /// Polls to receive the next signal notification event, outside of an\n    /// `async` context.\n    ///\n    /// `None` is returned if no more events can be received by this listener.\n    ///\n    /// # Examples\n    ///\n    /// Polling from a manually implemented future\n    ///\n    /// ```rust,no_run\n    /// use std::pin::Pin;\n    /// use std::future::Future;\n    /// use std::task::{Context, Poll};\n    /// use tokio::signal::windows::CtrlLogoff;\n    ///\n    /// struct MyFuture {\n    ///     ctrl_logoff: CtrlLogoff,\n    /// }\n    ///\n    /// impl Future for MyFuture {\n    ///     type Output = Option<()>;\n    ///\n    ///     fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n    ///         println!(\"polling MyFuture\");\n    ///         self.ctrl_logoff.poll_recv(cx)\n    ///     }\n    /// }\n    /// ```\n    pub fn poll_recv(&mut self, cx: &mut Context<'_>) -> Poll<Option<()>> {\n        self.inner.poll_recv(cx)\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "1d77d3609ab45d4560238076bea309f43cdfdf4f",
    "func": "use super::{HttpDate, IF_MODIFIED_SINCE};\n\ncrate::http::header::common_header! {\n    /// `If-Modified-Since` header, defined\n    /// in [RFC 7232 \u00a73.3](https://datatracker.ietf.org/doc/html/rfc7232#section-3.3)\n    ///\n    /// The `If-Modified-Since` header field makes a GET or HEAD request\n    /// method conditional on the selected representation's modification date\n    /// being more recent than the date provided in the field-value.\n    /// Transfer of the selected representation's data is avoided if that\n    /// data has not changed.\n    ///\n    /// # ABNF\n    /// ```plain\n    /// If-Unmodified-Since = HTTP-date\n    /// ```\n    ///\n    /// # Example Values\n    /// * `Sat, 29 Oct 1994 19:43:31 GMT`\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use std::time::{SystemTime, Duration};\n    /// use actix_web::HttpResponse;\n    /// use actix_web::http::header::IfModifiedSince;\n    ///\n    /// let mut builder = HttpResponse::Ok();\n    /// let modified = SystemTime::now() - Duration::from_secs(60 * 60 * 24);\n    /// builder.insert_header(\n    ///     IfModifiedSince(modified.into())\n    /// );\n    /// ```\n    (IfModifiedSince, IF_MODIFIED_SINCE) => [HttpDate]\n\n    test_parse_and_format {\n        // Test case from RFC\n        crate::http::header::common_header_test!(test1, [b\"Sat, 29 Oct 1994 19:43:31 GMT\"]);\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "842cbe4b8e538697e86825c2d0eaaeb0d336f11c",
    "func": "use core::fmt::Debug;\n\nuse core::hash::Hash;\n\n/// Types that can define world-wide states in a finite-state machine.\n///\n/// The [`Default`] trait defines the starting state.\n/// Multiple states can be defined for the same world,\n/// allowing you to classify the state of the world across orthogonal dimensions.\n/// You can access the current state of type `T` with the [`State<T>`](crate::state::State) resource,\n/// and the queued state with the [`NextState<T>`](crate::state::NextState) resource.\n///\n/// State transitions typically occur in the [`OnEnter<T::Variant>`](crate::state::OnEnter) and [`OnExit<T::Variant>`](crate::state::OnExit) schedules,\n/// which can be run by triggering the [`StateTransition`](crate::state::StateTransition) schedule.\n///\n/// Types used as [`ComputedStates`](crate::state::ComputedStates) do not need to and should not derive [`States`].\n/// [`ComputedStates`](crate::state::ComputedStates) should not be manually mutated: functionality provided\n/// by the [`States`] derive and the associated [`FreelyMutableState`](crate::state::FreelyMutableState) trait.\n///\n/// # Example\n///\n/// ```\n/// use bevy_state::prelude::*;\n/// use bevy_ecs::prelude::IntoSystemConfigs;\n/// use bevy_ecs::system::ResMut;\n///\n///\n/// #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, Default, States)]\n/// enum GameState {\n///     #[default]\n///     MainMenu,\n///     SettingsMenu,\n///     InGame,\n/// }\n///\n/// fn handle_escape_pressed(mut next_state: ResMut<NextState<GameState>>) {\n/// #   let escape_pressed = true;\n///     if escape_pressed {\n///         next_state.set(GameState::SettingsMenu);\n///     }\n/// }\n///\n/// fn open_settings_menu() {\n///     // Show the settings menu...\n/// }\n///\n/// # struct AppMock;\n/// # impl AppMock {\n/// #     fn add_systems<S, M>(&mut self, schedule: S, systems: impl IntoSystemConfigs<M>) {}\n/// # }\n/// # struct Update;\n/// # let mut app = AppMock;\n///\n/// app.add_systems(Update, handle_escape_pressed.run_if(in_state(GameState::MainMenu)));\n/// app.add_systems(OnEnter(GameState::SettingsMenu), open_settings_menu);\n/// ```\n#[diagnostic::on_unimplemented(\n    message = \"`{Self}` can not be used as a state\",\n    label = \"invalid state\",\n    note = \"consider annotating `{Self}` with `#[derive(States)]`\"\n)]\npub trait States: 'static + Send + Sync + Clone + PartialEq + Eq + Hash + Debug {\n    /// How many other states this state depends on.\n    /// Used to help order transitions and de-duplicate [`ComputedStates`](crate::state::ComputedStates), as well as prevent cyclical\n    /// `ComputedState` dependencies.\n    const DEPENDENCY_DEPTH: usize = 1;\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "00c5ae9f3f87b5b4410a60c3ed10f5161bb92e6e",
    "func": "use std::cmp::min;\n\nuse strum::{Display, EnumString};\n\nuse crate::{\n    buffer::Buffer,\n    layout::Rect,\n    style::{Style, Styled},\n    symbols::{self},\n    widgets::{block::BlockExt, Block, Widget, WidgetRef},\n};\n\n/// Widget to render a sparkline over one or more lines.\n///\n/// Each bar in a `Sparkline` represents a value from the provided dataset. The height of the bar\n/// is determined by the value in the dataset.\n///\n/// You can create a `Sparkline` using [`Sparkline::default`].\n///\n/// The data is set using [`Sparkline::data`]. The data can be a slice of `u64`, `Option<u64>`, or a\n/// [`SparklineBar`].  For the `Option<u64>` and [`SparklineBar`] cases, a data point with a value\n/// of `None` is interpreted an as the _absence_ of a value.\n///\n/// `Sparkline` can be styled either using [`Sparkline::style`] or preferably using the methods\n/// provided by the [`Stylize`](crate::style::Stylize) trait.  The style may be set for the entire\n/// widget or for individual bars by setting individual [`SparklineBar::style`].\n///\n/// The bars are rendered using a set of symbols. The default set is [`symbols::bar::NINE_LEVELS`].\n/// You can change the set using [`Sparkline::bar_set`].\n///\n/// If the data provided is a slice of `u64` or `Option<u64>`, the bars will be styled with the\n/// style of the sparkline. If the data is a slice of [`SparklineBar`], the bars will be\n/// styled with the style of the sparkline combined with the style provided in the [`SparklineBar`]\n/// if it is set, otherwise the sparkline style will be used.\n///\n/// Absent values and will be rendered with the style set by [`Sparkline::absent_value_style`] and\n/// the symbol set by [`Sparkline::absent_value_symbol`].\n///\n/// # Setter methods\n///\n/// - [`Sparkline::block`] wraps the sparkline in a [`Block`]\n/// - [`Sparkline::data`] defines the dataset, you'll almost always want to use it\n/// - [`Sparkline::max`] sets the maximum value of bars\n/// - [`Sparkline::direction`] sets the render direction\n///\n/// # Examples\n///\n/// ```\n/// use ratatui::{\n///     style::{Color, Style, Stylize},\n///     symbols,\n///     widgets::{Block, RenderDirection, Sparkline},\n/// };\n///\n/// Sparkline::default()\n///     .block(Block::bordered().title(\"Sparkline\"))\n///     .data(&[0, 2, 3, 4, 1, 4, 10])\n///     .max(5)\n///     .direction(RenderDirection::RightToLeft)\n///     .style(Style::default().red().on_white())\n///     .absent_value_style(Style::default().fg(Color::Red))\n///     .absent_value_symbol(symbols::shade::FULL);\n/// ```\n#[derive(Debug, Default, Clone, Eq, PartialEq)]\npub struct Sparkline<'a> {\n    /// A block to wrap the widget in\n    block: Option<Block<'a>>,\n    /// Widget style\n    style: Style,\n    /// Style of absent values\n    absent_value_style: Style,\n    /// The symbol to use for absent values\n    absent_value_symbol: AbsentValueSymbol,\n    /// A slice of the data to display\n    data: Vec<SparklineBar>,\n    /// The maximum value to take to compute the maximum bar height (if nothing is specified, the\n    /// widget uses the max of the dataset)\n    max: Option<u64>,\n    /// A set of bar symbols used to represent the give data\n    bar_set: symbols::bar::Set,\n    /// The direction to render the sparkline, either from left to right, or from right to left\n    direction: RenderDirection,\n}\n\n/// Defines the direction in which sparkline will be rendered.\n///\n/// See [`Sparkline::direction`].\n#[derive(Debug, Default, Display, EnumString, Clone, Copy, Eq, PartialEq, Hash)]\npub enum RenderDirection {\n    /// The first value is on the left, going to the right\n    #[default]\n    LeftToRight,\n    /// The first value is on the right, going to the left\n    RightToLeft,\n}\n\nimpl<'a> Sparkline<'a> {\n    /// Wraps the sparkline with the given `block`.\n    #[must_use = \"method moves the value of self and returns the modified value\"]\n    pub fn block(mut self, block: Block<'a>) -> Self {\n        self.block = Some(block);\n        self\n    }\n\n    /// Sets the style of the entire widget.\n    ///\n    /// `style` accepts any type that is convertible to [`Style`] (e.g. [`Style`], [`Color`], or\n    /// your own type that implements [`Into<Style>`]).\n    ///\n    /// The foreground corresponds to the bars while the background is everything else.\n    ///\n    /// [`Color`]: crate::style::Color\n    #[must_use = \"method moves the value of self and returns the modified value\"]\n    pub fn style<S: Into<Style>>(mut self, style: S) -> Self {\n        self.style = style.into();\n        self\n    }\n\n    /// Sets the style to use for absent values.\n    ///\n    /// Absent values are values in the dataset that are `None`.\n    ///\n    /// `style` accepts any type that is convertible to [`Style`] (e.g. [`Style`], [`Color`], or\n    /// your own type that implements [`Into<Style>`]).\n    ///\n    /// The foreground corresponds to the bars while the background is everything else.\n    ///\n    /// [`Color`]: crate::style::Color\n    #[must_use = \"method moves the value of self and returns the modified value\"]\n    pub fn absent_value_style<S: Into<Style>>(mut self, style: S) -> Self {\n        self.absent_value_style = style.into();\n        self\n    }\n\n    /// Sets the symbol to use for absent values.\n    ///\n    /// Absent values are values in the dataset that are `None`.\n    ///\n    /// The default is [`symbols::shade::EMPTY`].\n    #[must_use = \"method moves the value of self and returns the modified value\"]\n    pub fn absent_value_symbol(mut self, symbol: impl Into<String>) -> Self {\n        self.absent_value_symbol = AbsentValueSymbol(symbol.into());\n        self\n    }\n\n    /// Sets the dataset for the sparkline.\n    ///\n    /// Each item in the dataset is a bar in the sparkline. The height of the bar is determined by\n    /// the value in the dataset.\n    ///\n    /// The data can be a slice of `u64`, `Option<u64>`, or a [`SparklineBar`].  For the\n    /// `Option<u64>` and [`SparklineBar`] cases, a data point with a value of `None` is\n    /// interpreted an as the _absence_ of a value.\n    ///\n    /// If the data provided is a slice of `u64` or `Option<u64>`, the bars will be styled with the\n    /// style of the sparkline. If the data is a slice of [`SparklineBar`], the bars will be\n    /// styled with the style of the sparkline combined with the style provided in the\n    /// [`SparklineBar`] if it is set, otherwise the sparkline style will be used.\n    ///\n    /// Absent values and will be rendered with the style set by [`Sparkline::absent_value_style`]\n    /// and the symbol set by [`Sparkline::absent_value_symbol`].\n    ///\n    /// # Examples\n    ///\n    /// Create a `Sparkline` from a slice of `u64`:\n    ///\n    /// ```\n    /// use ratatui::{layout::Rect, widgets::Sparkline, Frame};\n    ///\n    /// # fn ui(frame: &mut Frame) {\n    /// # let area = Rect::default();\n    /// let sparkline = Sparkline::default().data(&[1, 2, 3]);\n    /// frame.render_widget(sparkline, area);\n    /// # }\n    /// ```\n    ///\n    /// Create a `Sparkline` from a slice of `Option<u64>` such that some bars are absent:\n    ///\n    /// ```\n    /// # use ratatui::{prelude::*, widgets::*};\n    /// # fn ui(frame: &mut Frame) {\n    /// # let area = Rect::default();\n    /// let data = vec![Some(1), None, Some(3)];\n    /// let sparkline = Sparkline::default().data(data);\n    /// frame.render_widget(sparkline, area);\n    /// # }\n    /// ```\n    ///\n    /// Create a [`Sparkline`] from a a Vec of [`SparklineBar`] such that some bars are styled:\n    ///\n    /// ```\n    /// # use ratatui::{prelude::*, widgets::*};\n    /// # fn ui(frame: &mut Frame) {\n    /// # let area = Rect::default();\n    /// let data = vec![\n    ///     SparklineBar::from(1).style(Some(Style::default().fg(Color::Red))),\n    ///     SparklineBar::from(2),\n    ///     SparklineBar::from(3).style(Some(Style::default().fg(Color::Blue))),\n    /// ];\n    /// let sparkline = Sparkline::default().data(data);\n    /// frame.render_widget(sparkline, area);\n    /// # }\n    /// ```\n    #[must_use = \"method moves the value of self and returns the modified value\"]\n    pub fn data<T>(mut self, data: T) -> Self\n    where\n        T: IntoIterator,\n        T::Item: Into<SparklineBar>,\n    {\n        self.data = data.into_iter().map(Into::into).collect();\n        self\n    }\n\n    /// Sets the maximum value of bars.\n    ///\n    /// Every bar will be scaled accordingly. If no max is given, this will be the max in the\n    /// dataset.\n    #[must_use = \"method moves the value of self and returns the modified value\"]\n    pub const fn max(mut self, max: u64) -> Self {\n        self.max = Some(max);\n        self\n    }\n\n    /// Sets the characters used to display the bars.\n    ///\n    /// Can be [`symbols::bar::THREE_LEVELS`], [`symbols::bar::NINE_LEVELS`] (default) or a custom\n    /// [`Set`](symbols::bar::Set).\n    #[must_use = \"method moves the value of self and returns the modified value\"]\n    pub const fn bar_set(mut self, bar_set: symbols::bar::Set) -> Self {\n        self.bar_set = bar_set;\n        self\n    }\n\n    /// Sets the direction of the sparkline.\n    ///\n    /// [`RenderDirection::LeftToRight`] by default.\n    #[must_use = \"method moves the value of self and returns the modified value\"]\n    pub const fn direction(mut self, direction: RenderDirection) -> Self {\n        self.direction = direction;\n        self\n    }\n}\n\n/// An bar in a `Sparkline`.\n///\n/// The height of the bar is determined by the value and a value of `None` is interpreted as the\n/// _absence_ of a value, as distinct from a value of `Some(0)`.\n#[derive(Debug, Default, Copy, Clone, Eq, PartialEq)]\npub struct SparklineBar {\n    /// The value of the bar.\n    ///\n    /// If `None`, the bar is absent.\n    value: Option<u64>,\n    /// The style of the bar.\n    ///\n    /// If `None`, the bar will use the style of the sparkline.\n    style: Option<Style>,\n}\n\nimpl SparklineBar {\n    /// Sets the style of the bar.\n    ///\n    /// `style` accepts any type that is convertible to [`Style`] (e.g. [`Style`], [`Color`], or\n    /// your own type that implements [`Into<Style>`]).\n    ///\n    /// If not set, the default style of the sparkline will be used.\n    ///\n    /// As well as the style of the sparkline, each [`SparklineBar`] may optionally set its own\n    /// style.  If set, the style of the bar will be the style of the sparkline combined with\n    /// the style of the bar.\n    ///\n    /// [`Color`]: crate::style::Color\n    #[must_use = \"method moves the value of self and returns the modified value\"]\n    pub fn style<S: Into<Option<Style>>>(mut self, style: S) -> Self {\n        self.style = style.into();\n        self\n    }\n}\n\nimpl From<Option<u64>> for SparklineBar {\n    fn from(value: Option<u64>) -> Self {\n        Self { value, style: None }\n    }\n}\n\nimpl From<u64> for SparklineBar {\n    fn from(value: u64) -> Self {\n        Self {\n            value: Some(value),\n            style: None,\n        }\n    }\n}\n\nimpl From<&u64> for SparklineBar {\n    fn from(value: &u64) -> Self {\n        Self {\n            value: Some(*value),\n            style: None,\n        }\n    }\n}\n\nimpl From<&Option<u64>> for SparklineBar {\n    fn from(value: &Option<u64>) -> Self {\n        Self {\n            value: *value,\n            style: None,\n        }\n    }\n}\n\nimpl<'a> Styled for Sparkline<'a> {\n    type Item = Self;\n\n    fn style(&self) -> Style {\n        self.style\n    }\n\n    fn set_style<S: Into<Style>>(self, style: S) -> Self::Item {\n        self.style(style)\n    }\n}\n\nimpl Widget for Sparkline<'_> {\n    fn render(self, area: Rect, buf: &mut Buffer) {\n        self.render_ref(area, buf);\n    }\n}\n\nimpl WidgetRef for Sparkline<'_> {\n    fn render_ref(&self, area: Rect, buf: &mut Buffer) {\n        self.block.render_ref(area, buf);\n        let inner = self.block.inner_if_some(area);\n        self.render_sparkline(inner, buf);\n    }\n}\n\n/// A newtype wrapper for the symbol to use for absent values.\n#[derive(Debug, Clone, Eq, PartialEq)]\nstruct AbsentValueSymbol(String);\n\nimpl Default for AbsentValueSymbol {\n    fn default() -> Self {\n        Self(symbols::shade::EMPTY.to_string())\n    }\n}\n\nimpl Sparkline<'_> {\n    fn render_sparkline(&self, spark_area: Rect, buf: &mut Buffer) {\n        if spark_area.is_empty() {\n            return;\n        }\n        // determine the maximum height across all bars\n        let max_height = self\n            .max\n            .unwrap_or_else(|| self.data.iter().filter_map(|s| s.value).max().unwrap_or(1));\n\n        // determine the maximum index to render\n        let max_index = min(spark_area.width as usize, self.data.len());\n\n        // render each item in the data\n        for (i, item) in self.data.iter().take(max_index).enumerate() {\n            let x = match self.direction {\n                RenderDirection::LeftToRight => spark_area.left() + i as u16,\n                RenderDirection::RightToLeft => spark_area.right() - i as u16 - 1,\n            };\n\n            // determine the height, symbol and style to use for the item\n            //\n            // if the item is not absent:\n            // - the height is the value of the item scaled to the height of the spark area\n            // - the symbol is determined by the scaled height\n            // - the style is the style of the item, if one is set\n            //\n            // otherwise:\n            // - the height is the total height of the spark area\n            // - the symbol is the absent value symbol\n            // - the style is the absent value style\n            let (mut height, symbol, style) = match item {\n                SparklineBar {\n                    value: Some(value),\n                    style,\n                } => {\n                    let height = if max_height == 0 {\n                        0\n                    } else {\n                        *value * u64::from(spark_area.height) * 8 / max_height\n                    };\n                    (height, None, *style)\n                }\n                _ => (\n                    u64::from(spark_area.height) * 8,\n                    Some(self.absent_value_symbol.0.as_str()),\n                    Some(self.absent_value_style),\n                ),\n            };\n\n            // render the item from top to bottom\n            //\n            // if the symbol is set it will be used for the entire height of the bar, otherwise the\n            // symbol will be determined by the _remaining_ height.\n            //\n            // if the style is set it will be used for the entire height of the bar, otherwise the\n            // sparkline style will be used.\n            for j in (0..spark_area.height).rev() {\n                let symbol = symbol.unwrap_or_else(|| self.symbol_for_height(height));\n                if height > 8 {\n                    height -= 8;\n                } else {\n                    height = 0;\n                }\n                buf[(x, spark_area.top() + j)]\n                    .set_symbol(symbol)\n                    .set_style(self.style.patch(style.unwrap_or_default()));\n            }\n        }\n    }\n\n    const fn symbol_for_height(&self, height: u64) -> &str {\n        match height {\n            0 => self.bar_set.empty,\n            1 => self.bar_set.one_eighth,\n            2 => self.bar_set.one_quarter,\n            3 => self.bar_set.three_eighths,\n            4 => self.bar_set.half,\n            5 => self.bar_set.five_eighths,\n            6 => self.bar_set.three_quarters,\n            7 => self.bar_set.seven_eighths,\n            _ => self.bar_set.full,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use strum::ParseError;\n\n    use super::*;\n    use crate::{\n        buffer::Cell,\n        style::{Color, Modifier, Stylize},\n    };\n\n    #[test]\n    fn render_direction_to_string() {\n        assert_eq!(RenderDirection::LeftToRight.to_string(), \"LeftToRight\");\n        assert_eq!(RenderDirection::RightToLeft.to_string(), \"RightToLeft\");\n    }\n\n    #[test]\n    fn render_direction_from_str() {\n        assert_eq!(\n            \"LeftToRight\".parse::<RenderDirection>(),\n            Ok(RenderDirection::LeftToRight)\n        );\n        assert_eq!(\n            \"RightToLeft\".parse::<RenderDirection>(),\n            Ok(RenderDirection::RightToLeft)\n        );\n        assert_eq!(\n            \"\".parse::<RenderDirection>(),\n            Err(ParseError::VariantNotFound)\n        );\n    }\n\n    #[test]\n    fn it_can_be_created_from_vec_of_u64() {\n        let data = vec![1_u64, 2, 3];\n        let spark_data = Sparkline::default().data(data).data;\n        let expected = vec![\n            SparklineBar::from(1),\n            SparklineBar::from(2),\n            SparklineBar::from(3),\n        ];\n        assert_eq!(spark_data, expected);\n    }\n\n    #[test]\n    fn it_can_be_created_from_vec_of_option_u64() {\n        let data = vec![Some(1_u64), None, Some(3)];\n        let spark_data = Sparkline::default().data(data).data;\n        let expected = vec![\n            SparklineBar::from(1),\n            SparklineBar::from(None),\n            SparklineBar::from(3),\n        ];\n        assert_eq!(spark_data, expected);\n    }\n\n    #[test]\n    fn it_can_be_created_from_array_of_u64() {\n        let data = [1_u64, 2, 3];\n        let spark_data = Sparkline::default().data(data).data;\n        let expected = vec![\n            SparklineBar::from(1),\n            SparklineBar::from(2),\n            SparklineBar::from(3),\n        ];\n        assert_eq!(spark_data, expected);\n    }\n\n    #[test]\n    fn it_can_be_created_from_array_of_option_u64() {\n        let data = [Some(1_u64), None, Some(3)];\n        let spark_data = Sparkline::default().data(data).data;\n        let expected = vec![\n            SparklineBar::from(1),\n            SparklineBar::from(None),\n            SparklineBar::from(3),\n        ];\n        assert_eq!(spark_data, expected);\n    }\n\n    #[test]\n    fn it_can_be_created_from_slice_of_u64() {\n        let data = vec![1_u64, 2, 3];\n        let spark_data = Sparkline::default().data(&data).data;\n        let expected = vec![\n            SparklineBar::from(1),\n            SparklineBar::from(2),\n            SparklineBar::from(3),\n        ];\n        assert_eq!(spark_data, expected);\n    }\n\n    #[test]\n    fn it_can_be_created_from_slice_of_option_u64() {\n        let data = vec![Some(1_u64), None, Some(3)];\n        let spark_data = Sparkline::default().data(&data).data;\n        let expected = vec![\n            SparklineBar::from(1),\n            SparklineBar::from(None),\n            SparklineBar::from(3),\n        ];\n        assert_eq!(spark_data, expected);\n    }\n\n    // Helper function to render a sparkline to a buffer with a given width\n    // filled with x symbols to make it easier to assert on the result\n    fn render(widget: Sparkline<'_>, width: u16) -> Buffer {\n        let area = Rect::new(0, 0, width, 1);\n        let mut buffer = Buffer::filled(area, Cell::new(\"x\"));\n        widget.render(area, &mut buffer);\n        buffer\n    }\n\n    #[test]\n    fn it_does_not_panic_if_max_is_zero() {\n        let widget = Sparkline::default().data([0, 0, 0]);\n        let buffer = render(widget, 6);\n        assert_eq!(buffer, Buffer::with_lines([\"   xxx\"]));\n    }\n\n    #[test]\n    fn it_does_not_panic_if_max_is_set_to_zero() {\n        // see https://github.com/rust-lang/rust-clippy/issues/13191\n        #[allow(clippy::unnecessary_min_or_max)]\n        let widget = Sparkline::default().data([0, 1, 2]).max(0);\n        let buffer = render(widget, 6);\n        assert_eq!(buffer, Buffer::with_lines([\"   xxx\"]));\n    }\n\n    #[test]\n    fn it_draws() {\n        let widget = Sparkline::default().data([0, 1, 2, 3, 4, 5, 6, 7, 8]);\n        let buffer = render(widget, 12);\n        assert_eq!(buffer, Buffer::with_lines([\" \u2581\u2582\u2583\u2584\u2585\u2586\u2587\u2588xxx\"]));\n    }\n\n    #[test]\n    fn it_draws_double_height() {\n        let widget = Sparkline::default().data([0, 1, 2, 3, 4, 5, 6, 7, 8]);\n        let area = Rect::new(0, 0, 12, 2);\n        let mut buffer = Buffer::filled(area, Cell::new(\"x\"));\n        widget.render(area, &mut buffer);\n        assert_eq!(buffer, Buffer::with_lines([\"     \u2582\u2584\u2586\u2588xxx\", \" \u2582\u2584\u2586\u2588\u2588\u2588\u2588\u2588xxx\"]));\n    }\n\n    #[test]\n    fn it_renders_left_to_right() {\n        let widget = Sparkline::default()\n            .data([0, 1, 2, 3, 4, 5, 6, 7, 8])\n            .direction(RenderDirection::LeftToRight);\n        let buffer = render(widget, 12);\n        assert_eq!(buffer, Buffer::with_lines([\" \u2581\u2582\u2583\u2584\u2585\u2586\u2587\u2588xxx\"]));\n    }\n\n    #[test]\n    fn it_renders_right_to_left() {\n        let widget = Sparkline::default()\n            .data([0, 1, 2, 3, 4, 5, 6, 7, 8])\n            .direction(RenderDirection::RightToLeft);\n        let buffer = render(widget, 12);\n        assert_eq!(buffer, Buffer::with_lines([\"xxx\u2588\u2587\u2586\u2585\u2584\u2583\u2582\u2581 \"]));\n    }\n\n    #[test]\n    fn it_renders_with_absent_value_style() {\n        let widget = Sparkline::default()\n            .absent_value_style(Style::default().fg(Color::Red))\n            .absent_value_symbol(symbols::shade::FULL)\n            .data([\n                None,\n                Some(1),\n                Some(2),\n                Some(3),\n                Some(4),\n                Some(5),\n                Some(6),\n                Some(7),\n                Some(8),\n            ]);\n        let buffer = render(widget, 12);\n        let mut expected = Buffer::with_lines([\"\u2588\u2581\u2582\u2583\u2584\u2585\u2586\u2587\u2588xxx\"]);\n        expected.set_style(Rect::new(0, 0, 1, 1), Style::default().fg(Color::Red));\n        assert_eq!(buffer, expected);\n    }\n\n    #[test]\n    fn it_renders_with_absent_value_style_double_height() {\n        let widget = Sparkline::default()\n            .absent_value_style(Style::default().fg(Color::Red))\n            .absent_value_symbol(symbols::shade::FULL)\n            .data([\n                None,\n                Some(1),\n                Some(2),\n                Some(3),\n                Some(4),\n                Some(5),\n                Some(6),\n                Some(7),\n                Some(8),\n            ]);\n        let area = Rect::new(0, 0, 12, 2);\n        let mut buffer = Buffer::filled(area, Cell::new(\"x\"));\n        widget.render(area, &mut buffer);\n        let mut expected = Buffer::with_lines([\"\u2588    \u2582\u2584\u2586\u2588xxx\", \"\u2588\u2582\u2584\u2586\u2588\u2588\u2588\u2588\u2588xxx\"]);\n        expected.set_style(Rect::new(0, 0, 1, 2), Style::default().fg(Color::Red));\n        assert_eq!(buffer, expected);\n    }\n\n    #[test]\n    fn it_renders_with_custom_absent_value_style() {\n        let widget = Sparkline::default().absent_value_symbol('*').data([\n            None,\n            Some(1),\n            Some(2),\n            Some(3),\n            Some(4),\n            Some(5),\n            Some(6),\n            Some(7),\n            Some(8),\n        ]);\n        let buffer = render(widget, 12);\n        let expected = Buffer::with_lines([\"*\u2581\u2582\u2583\u2584\u2585\u2586\u2587\u2588xxx\"]);\n        assert_eq!(buffer, expected);\n    }\n\n    #[test]\n    fn it_renders_with_custom_bar_styles() {\n        let widget = Sparkline::default().data(vec![\n            SparklineBar::from(Some(0)).style(Some(Style::default().fg(Color::Red))),\n            SparklineBar::from(Some(1)).style(Some(Style::default().fg(Color::Red))),\n            SparklineBar::from(Some(2)).style(Some(Style::default().fg(Color::Red))),\n            SparklineBar::from(Some(3)).style(Some(Style::default().fg(Color::Green))),\n            SparklineBar::from(Some(4)).style(Some(Style::default().fg(Color::Green))),\n            SparklineBar::from(Some(5)).style(Some(Style::default().fg(Color::Green))),\n            SparklineBar::from(Some(6)).style(Some(Style::default().fg(Color::Blue))),\n            SparklineBar::from(Some(7)).style(Some(Style::default().fg(Color::Blue))),\n            SparklineBar::from(Some(8)).style(Some(Style::default().fg(Color::Blue))),\n        ]);\n        let buffer = render(widget, 12);\n        let mut expected = Buffer::with_lines([\" \u2581\u2582\u2583\u2584\u2585\u2586\u2587\u2588xxx\"]);\n        expected.set_style(Rect::new(0, 0, 3, 1), Style::default().fg(Color::Red));\n        expected.set_style(Rect::new(3, 0, 3, 1), Style::default().fg(Color::Green));\n        expected.set_style(Rect::new(6, 0, 3, 1), Style::default().fg(Color::Blue));\n        assert_eq!(buffer, expected);\n    }\n\n    #[test]\n    fn can_be_stylized() {\n        assert_eq!(\n            Sparkline::default()\n                .black()\n                .on_white()\n                .bold()\n                .not_dim()\n                .style,\n            Style::default()\n                .fg(Color::Black)\n                .bg(Color::White)\n                .add_modifier(Modifier::BOLD)\n                .remove_modifier(Modifier::DIM)\n        );\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "9b42f5237be15e7accd453e1cb007bfaff16d683",
    "func": "//! Run with\n//!\n//! ```not_rust\n//! cargo run -p example-tokio-postgres\n//! ```\n\nuse axum::{\n    extract::{FromRef, FromRequestParts, State},\n    http::{request::Parts, StatusCode},\n    routing::get,\n    Router,\n};\nuse bb8::{Pool, PooledConnection};\nuse bb8_postgres::PostgresConnectionManager;\nuse tokio_postgres::NoTls;\nuse tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};\n\n#[tokio::main]\nasync fn main() {\n    tracing_subscriber::registry()\n        .with(\n            tracing_subscriber::EnvFilter::try_from_default_env()\n                .unwrap_or_else(|_| format!(\"{}=debug\", env!(\"CARGO_CRATE_NAME\")).into()),\n        )\n        .with(tracing_subscriber::fmt::layer())\n        .init();\n\n    // set up connection pool\n    let manager =\n        PostgresConnectionManager::new_from_stringlike(\"host=localhost user=postgres\", NoTls)\n            .unwrap();\n    let pool = Pool::builder().build(manager).await.unwrap();\n\n    // build our application with some routes\n    let app = Router::new()\n        .route(\n            \"/\",\n            get(using_connection_pool_extractor).post(using_connection_extractor),\n        )\n        .with_state(pool);\n\n    // run it\n    let listener = tokio::net::TcpListener::bind(\"127.0.0.1:3000\")\n        .await\n        .unwrap();\n    tracing::debug!(\"listening on {}\", listener.local_addr().unwrap());\n    axum::serve(listener, app).await.unwrap();\n}\n\ntype ConnectionPool = Pool<PostgresConnectionManager<NoTls>>;\n\nasync fn using_connection_pool_extractor(\n    State(pool): State<ConnectionPool>,\n) -> Result<String, (StatusCode, String)> {\n    let conn = pool.get().await.map_err(internal_error)?;\n\n    let row = conn\n        .query_one(\"select 1 + 1\", &[])\n        .await\n        .map_err(internal_error)?;\n    let two: i32 = row.try_get(0).map_err(internal_error)?;\n\n    Ok(two.to_string())\n}\n\n// we can also write a custom extractor that grabs a connection from the pool\n// which setup is appropriate depends on your application\nstruct DatabaseConnection(PooledConnection<'static, PostgresConnectionManager<NoTls>>);\n\nimpl<S> FromRequestParts<S> for DatabaseConnection\nwhere\n    ConnectionPool: FromRef<S>,\n    S: Send + Sync,\n{\n    type Rejection = (StatusCode, String);\n\n    async fn from_request_parts(_parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {\n        let pool = ConnectionPool::from_ref(state);\n\n        let conn = pool.get_owned().await.map_err(internal_error)?;\n\n        Ok(Self(conn))\n    }\n}\n\nasync fn using_connection_extractor(\n    DatabaseConnection(conn): DatabaseConnection,\n) -> Result<String, (StatusCode, String)> {\n    let row = conn\n        .query_one(\"select 1 + 1\", &[])\n        .await\n        .map_err(internal_error)?;\n    let two: i32 = row.try_get(0).map_err(internal_error)?;\n\n    Ok(two.to_string())\n}\n\n/// Utility function for mapping any error into a `500 Internal Server Error`\n/// response.\nfn internal_error<E>(err: E) -> (StatusCode, String)\nwhere\n    E: std::error::Error,\n{\n    (StatusCode::INTERNAL_SERVER_ERROR, err.to_string())\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "28dcfa087de769ee1bd5b67abf7aafbaab611fcf",
    "func": "//! Helpers for mapping window entities to accessibility types\n\nuse alloc::{collections::VecDeque, sync::Arc};\nuse std::sync::Mutex;\n\nuse accesskit_winit::Adapter;\nuse bevy_a11y::{\n    accesskit::{\n        ActionHandler, ActionRequest, ActivationHandler, DeactivationHandler, Node, NodeBuilder,\n        NodeId, Role, Tree, TreeUpdate,\n    },\n    AccessibilityNode, AccessibilityRequested, AccessibilitySystem,\n    ActionRequest as ActionRequestWrapper, Focus, ManageAccessibilityUpdates,\n};\nuse bevy_app::{App, Plugin, PostUpdate};\nuse bevy_derive::{Deref, DerefMut};\nuse bevy_ecs::{\n    entity::EntityHashMap,\n    prelude::{DetectChanges, Entity, EventReader, EventWriter},\n    query::With,\n    schedule::IntoSystemConfigs,\n    system::{NonSendMut, Query, Res, ResMut, Resource},\n};\nuse bevy_hierarchy::{Children, Parent};\nuse bevy_window::{PrimaryWindow, Window, WindowClosed};\n\n/// Maps window entities to their `AccessKit` [`Adapter`]s.\n#[derive(Default, Deref, DerefMut)]\npub struct AccessKitAdapters(pub EntityHashMap<Adapter>);\n\n/// Maps window entities to their respective [`ActionRequest`]s.\n#[derive(Resource, Default, Deref, DerefMut)]\npub struct WinitActionRequestHandlers(pub EntityHashMap<Arc<Mutex<WinitActionRequestHandler>>>);\n\n/// Forwards `AccessKit` [`ActionRequest`]s from winit to an event channel.\n#[derive(Clone, Default, Deref, DerefMut)]\npub struct WinitActionRequestHandler(pub VecDeque<ActionRequest>);\n\nimpl WinitActionRequestHandler {\n    fn new() -> Arc<Mutex<Self>> {\n        Arc::new(Mutex::new(Self(VecDeque::new())))\n    }\n}\n\nstruct AccessKitState {\n    name: String,\n    entity: Entity,\n    requested: AccessibilityRequested,\n}\n\nimpl AccessKitState {\n    fn new(\n        name: impl Into<String>,\n        entity: Entity,\n        requested: AccessibilityRequested,\n    ) -> Arc<Mutex<Self>> {\n        let name = name.into();\n\n        Arc::new(Mutex::new(Self {\n            name,\n            entity,\n            requested,\n        }))\n    }\n\n    fn build_root(&mut self) -> Node {\n        let mut builder = NodeBuilder::new(Role::Window);\n        builder.set_name(self.name.clone());\n        builder.build()\n    }\n\n    fn build_initial_tree(&mut self) -> TreeUpdate {\n        let root = self.build_root();\n        let accesskit_window_id = NodeId(self.entity.to_bits());\n        let mut tree = Tree::new(accesskit_window_id);\n        tree.app_name = Some(self.name.clone());\n        self.requested.set(true);\n\n        TreeUpdate {\n            nodes: vec![(accesskit_window_id, root)],\n            tree: Some(tree),\n            focus: accesskit_window_id,\n        }\n    }\n}\n\nstruct WinitActivationHandler(Arc<Mutex<AccessKitState>>);\n\nimpl ActivationHandler for WinitActivationHandler {\n    fn request_initial_tree(&mut self) -> Option<TreeUpdate> {\n        Some(self.0.lock().unwrap().build_initial_tree())\n    }\n}\n\nimpl WinitActivationHandler {\n    pub fn new(state: Arc<Mutex<AccessKitState>>) -> Self {\n        Self(state)\n    }\n}\n\n#[derive(Clone, Default)]\nstruct WinitActionHandler(Arc<Mutex<WinitActionRequestHandler>>);\n\nimpl ActionHandler for WinitActionHandler {\n    fn do_action(&mut self, request: ActionRequest) {\n        let mut requests = self.0.lock().unwrap();\n        requests.push_back(request);\n    }\n}\n\nimpl WinitActionHandler {\n    pub fn new(handler: Arc<Mutex<WinitActionRequestHandler>>) -> Self {\n        Self(handler)\n    }\n}\n\nstruct WinitDeactivationHandler;\n\nimpl DeactivationHandler for WinitDeactivationHandler {\n    fn deactivate_accessibility(&mut self) {}\n}\n\n/// Prepares accessibility for a winit window.\npub(crate) fn prepare_accessibility_for_window(\n    winit_window: &winit::window::Window,\n    entity: Entity,\n    name: String,\n    accessibility_requested: AccessibilityRequested,\n    adapters: &mut AccessKitAdapters,\n    handlers: &mut WinitActionRequestHandlers,\n) {\n    let state = AccessKitState::new(name, entity, accessibility_requested);\n    let activation_handler = WinitActivationHandler::new(Arc::clone(&state));\n\n    let action_request_handler = WinitActionRequestHandler::new();\n    let action_handler = WinitActionHandler::new(Arc::clone(&action_request_handler));\n    let deactivation_handler = WinitDeactivationHandler;\n\n    let adapter = Adapter::with_direct_handlers(\n        winit_window,\n        activation_handler,\n        action_handler,\n        deactivation_handler,\n    );\n\n    adapters.insert(entity, adapter);\n    handlers.insert(entity, action_request_handler);\n}\n\nfn window_closed(\n    mut adapters: NonSendMut<AccessKitAdapters>,\n    mut handlers: ResMut<WinitActionRequestHandlers>,\n    mut events: EventReader<WindowClosed>,\n) {\n    for WindowClosed { window, .. } in events.read() {\n        adapters.remove(window);\n        handlers.remove(window);\n    }\n}\n\nfn poll_receivers(\n    handlers: Res<WinitActionRequestHandlers>,\n    mut actions: EventWriter<ActionRequestWrapper>,\n) {\n    for (_id, handler) in handlers.iter() {\n        let mut handler = handler.lock().unwrap();\n        while let Some(event) = handler.pop_front() {\n            actions.send(ActionRequestWrapper(event));\n        }\n    }\n}\n\nfn should_update_accessibility_nodes(\n    accessibility_requested: Res<AccessibilityRequested>,\n    manage_accessibility_updates: Res<ManageAccessibilityUpdates>,\n) -> bool {\n    accessibility_requested.get() && manage_accessibility_updates.get()\n}\n\nfn update_accessibility_nodes(\n    mut adapters: NonSendMut<AccessKitAdapters>,\n    focus: Res<Focus>,\n    primary_window: Query<(Entity, &Window), With<PrimaryWindow>>,\n    nodes: Query<(\n        Entity,\n        &AccessibilityNode,\n        Option<&Children>,\n        Option<&Parent>,\n    )>,\n    node_entities: Query<Entity, With<AccessibilityNode>>,\n) {\n    let Ok((primary_window_id, primary_window)) = primary_window.get_single() else {\n        return;\n    };\n    let Some(adapter) = adapters.get_mut(&primary_window_id) else {\n        return;\n    };\n    if focus.is_changed() || !nodes.is_empty() {\n        adapter.update_if_active(|| {\n            update_adapter(\n                nodes,\n                node_entities,\n                primary_window,\n                primary_window_id,\n                focus,\n            )\n        });\n    }\n}\n\nfn update_adapter(\n    nodes: Query<(\n        Entity,\n        &AccessibilityNode,\n        Option<&Children>,\n        Option<&Parent>,\n    )>,\n    node_entities: Query<Entity, With<AccessibilityNode>>,\n    primary_window: &Window,\n    primary_window_id: Entity,\n    focus: Res<Focus>,\n) -> TreeUpdate {\n    let mut to_update = vec![];\n    let mut window_children = vec![];\n    for (entity, node, children, parent) in &nodes {\n        let mut node = (**node).clone();\n        queue_node_for_update(entity, parent, &node_entities, &mut window_children);\n        add_children_nodes(children, &node_entities, &mut node);\n        let node_id = NodeId(entity.to_bits());\n        let node = node.build();\n        to_update.push((node_id, node));\n    }\n    let mut window_node = NodeBuilder::new(Role::Window);\n    if primary_window.focused {\n        let title = primary_window.title.clone();\n        window_node.set_name(title.into_boxed_str());\n    }\n    window_node.set_children(window_children);\n    let window_node = window_node.build();\n    let node_id = NodeId(primary_window_id.to_bits());\n    let window_update = (node_id, window_node);\n    to_update.insert(0, window_update);\n    TreeUpdate {\n        nodes: to_update,\n        tree: None,\n        focus: NodeId(focus.unwrap_or(primary_window_id).to_bits()),\n    }\n}\n\n#[inline]\nfn queue_node_for_update(\n    node_entity: Entity,\n    parent: Option<&Parent>,\n    node_entities: &Query<Entity, With<AccessibilityNode>>,\n    window_children: &mut Vec<NodeId>,\n) {\n    let should_push = if let Some(parent) = parent {\n        !node_entities.contains(parent.get())\n    } else {\n        true\n    };\n    if should_push {\n        window_children.push(NodeId(node_entity.to_bits()));\n    }\n}\n\n#[inline]\nfn add_children_nodes(\n    children: Option<&Children>,\n    node_entities: &Query<Entity, With<AccessibilityNode>>,\n    node: &mut NodeBuilder,\n) {\n    let Some(children) = children else {\n        return;\n    };\n    for child in children {\n        if node_entities.contains(*child) {\n            node.push_child(NodeId(child.to_bits()));\n        }\n    }\n}\n\n/// Implements winit-specific `AccessKit` functionality.\npub struct AccessKitPlugin;\n\nimpl Plugin for AccessKitPlugin {\n    fn build(&self, app: &mut App) {\n        app.init_non_send_resource::<AccessKitAdapters>()\n            .init_resource::<WinitActionRequestHandlers>()\n            .add_event::<ActionRequestWrapper>()\n            .add_systems(\n                PostUpdate,\n                (\n                    poll_receivers,\n                    update_accessibility_nodes.run_if(should_update_accessibility_nodes),\n                    window_closed\n                        .before(poll_receivers)\n                        .before(update_accessibility_nodes),\n                )\n                    .in_set(AccessibilitySystem::Update),\n            );\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "fd2df5af2ce73381e0ea9e2de3fabd7faf517b3c",
    "func": "//! A collection of tasks spawned on a Tokio runtime.\n//!\n//! This module provides the [`JoinSet`] type, a collection which stores a set\n//! of spawned tasks and allows asynchronously awaiting the output of those\n//! tasks as they complete. See the documentation for the [`JoinSet`] type for\n//! details.\nuse std::future::Future;\nuse std::pin::Pin;\nuse std::task::{Context, Poll};\nuse std::{fmt, panic};\n\nuse crate::runtime::Handle;\nuse crate::task::Id;\nuse crate::task::{unconstrained, AbortHandle, JoinError, JoinHandle, LocalSet};\nuse crate::util::IdleNotifiedSet;\n\n/// A collection of tasks spawned on a Tokio runtime.\n///\n/// A `JoinSet` can be used to await the completion of some or all of the tasks\n/// in the set. The set is not ordered, and the tasks will be returned in the\n/// order they complete.\n///\n/// All of the tasks must have the same return type `T`.\n///\n/// When the `JoinSet` is dropped, all tasks in the `JoinSet` are immediately aborted.\n///\n/// # Examples\n///\n/// Spawn multiple tasks and wait for them.\n///\n/// ```\n/// use tokio::task::JoinSet;\n///\n/// #[tokio::main]\n/// async fn main() {\n///     let mut set = JoinSet::new();\n///\n///     for i in 0..10 {\n///         set.spawn(async move { i });\n///     }\n///\n///     let mut seen = [false; 10];\n///     while let Some(res) = set.join_next().await {\n///         let idx = res.unwrap();\n///         seen[idx] = true;\n///     }\n///\n///     for i in 0..10 {\n///         assert!(seen[i]);\n///     }\n/// }\n/// ```\n#[cfg_attr(docsrs, doc(cfg(feature = \"rt\")))]\npub struct JoinSet<T> {\n    inner: IdleNotifiedSet<JoinHandle<T>>,\n}\n\n/// A variant of [`task::Builder`] that spawns tasks on a [`JoinSet`] rather\n/// than on the current default runtime.\n///\n/// [`task::Builder`]: crate::task::Builder\n#[cfg(all(tokio_unstable, feature = \"tracing\"))]\n#[cfg_attr(docsrs, doc(cfg(all(tokio_unstable, feature = \"tracing\"))))]\n#[must_use = \"builders do nothing unless used to spawn a task\"]\npub struct Builder<'a, T> {\n    joinset: &'a mut JoinSet<T>,\n    builder: super::Builder<'a>,\n}\n\nimpl<T> JoinSet<T> {\n    /// Create a new `JoinSet`.\n    pub fn new() -> Self {\n        Self {\n            inner: IdleNotifiedSet::new(),\n        }\n    }\n\n    /// Returns the number of tasks currently in the `JoinSet`.\n    pub fn len(&self) -> usize {\n        self.inner.len()\n    }\n\n    /// Returns whether the `JoinSet` is empty.\n    pub fn is_empty(&self) -> bool {\n        self.inner.is_empty()\n    }\n}\n\nimpl<T: 'static> JoinSet<T> {\n    /// Returns a [`Builder`] that can be used to configure a task prior to\n    /// spawning it on this `JoinSet`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use tokio::task::JoinSet;\n    ///\n    /// #[tokio::main]\n    /// async fn main() -> std::io::Result<()> {\n    ///     let mut set = JoinSet::new();\n    ///\n    ///     // Use the builder to configure a task's name before spawning it.\n    ///     set.build_task()\n    ///         .name(\"my_task\")\n    ///         .spawn(async { /* ... */ })?;\n    ///\n    ///     Ok(())\n    /// }\n    /// ```\n    #[cfg(all(tokio_unstable, feature = \"tracing\"))]\n    #[cfg_attr(docsrs, doc(cfg(all(tokio_unstable, feature = \"tracing\"))))]\n    pub fn build_task(&mut self) -> Builder<'_, T> {\n        Builder {\n            builder: super::Builder::new(),\n            joinset: self,\n        }\n    }\n\n    /// Spawn the provided task on the `JoinSet`, returning an [`AbortHandle`]\n    /// that can be used to remotely cancel the task.\n    ///\n    /// The provided future will start running in the background immediately\n    /// when this method is called, even if you don't await anything on this\n    /// `JoinSet`.\n    ///\n    /// # Panics\n    ///\n    /// This method panics if called outside of a Tokio runtime.\n    ///\n    /// [`AbortHandle`]: crate::task::AbortHandle\n    #[track_caller]\n    pub fn spawn<F>(&mut self, task: F) -> AbortHandle\n    where\n        F: Future<Output = T>,\n        F: Send + 'static,\n        T: Send,\n    {\n        self.insert(crate::spawn(task))\n    }\n\n    /// Spawn the provided task on the provided runtime and store it in this\n    /// `JoinSet` returning an [`AbortHandle`] that can be used to remotely\n    /// cancel the task.\n    ///\n    /// The provided future will start running in the background immediately\n    /// when this method is called, even if you don't await anything on this\n    /// `JoinSet`.\n    ///\n    /// [`AbortHandle`]: crate::task::AbortHandle\n    #[track_caller]\n    pub fn spawn_on<F>(&mut self, task: F, handle: &Handle) -> AbortHandle\n    where\n        F: Future<Output = T>,\n        F: Send + 'static,\n        T: Send,\n    {\n        self.insert(handle.spawn(task))\n    }\n\n    /// Spawn the provided task on the current [`LocalSet`] and store it in this\n    /// `JoinSet`, returning an [`AbortHandle`] that can be used to remotely\n    /// cancel the task.\n    ///\n    /// The provided future will start running in the background immediately\n    /// when this method is called, even if you don't await anything on this\n    /// `JoinSet`.\n    ///\n    /// # Panics\n    ///\n    /// This method panics if it is called outside of a `LocalSet`.\n    ///\n    /// [`LocalSet`]: crate::task::LocalSet\n    /// [`AbortHandle`]: crate::task::AbortHandle\n    #[track_caller]\n    pub fn spawn_local<F>(&mut self, task: F) -> AbortHandle\n    where\n        F: Future<Output = T>,\n        F: 'static,\n    {\n        self.insert(crate::task::spawn_local(task))\n    }\n\n    /// Spawn the provided task on the provided [`LocalSet`] and store it in\n    /// this `JoinSet`, returning an [`AbortHandle`] that can be used to\n    /// remotely cancel the task.\n    ///\n    /// Unlike the [`spawn_local`] method, this method may be used to spawn local\n    /// tasks on a `LocalSet` that is _not_ currently running. The provided\n    /// future will start running whenever the `LocalSet` is next started.\n    ///\n    /// [`LocalSet`]: crate::task::LocalSet\n    /// [`AbortHandle`]: crate::task::AbortHandle\n    /// [`spawn_local`]: Self::spawn_local\n    #[track_caller]\n    pub fn spawn_local_on<F>(&mut self, task: F, local_set: &LocalSet) -> AbortHandle\n    where\n        F: Future<Output = T>,\n        F: 'static,\n    {\n        self.insert(local_set.spawn_local(task))\n    }\n\n    /// Spawn the blocking code on the blocking threadpool and store\n    /// it in this `JoinSet`, returning an [`AbortHandle`] that can be\n    /// used to remotely cancel the task.\n    ///\n    /// # Examples\n    ///\n    /// Spawn multiple blocking tasks and wait for them.\n    ///\n    /// ```\n    /// use tokio::task::JoinSet;\n    ///\n    /// #[tokio::main]\n    /// async fn main() {\n    ///     let mut set = JoinSet::new();\n    ///\n    ///     for i in 0..10 {\n    ///         set.spawn_blocking(move || { i });\n    ///     }\n    ///\n    ///     let mut seen = [false; 10];\n    ///     while let Some(res) = set.join_next().await {\n    ///         let idx = res.unwrap();\n    ///         seen[idx] = true;\n    ///     }\n    ///\n    ///     for i in 0..10 {\n    ///         assert!(seen[i]);\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// # Panics\n    ///\n    /// This method panics if called outside of a Tokio runtime.\n    ///\n    /// [`AbortHandle`]: crate::task::AbortHandle\n    #[track_caller]\n    pub fn spawn_blocking<F>(&mut self, f: F) -> AbortHandle\n    where\n        F: FnOnce() -> T,\n        F: Send + 'static,\n        T: Send,\n    {\n        self.insert(crate::runtime::spawn_blocking(f))\n    }\n\n    /// Spawn the blocking code on the blocking threadpool of the\n    /// provided runtime and store it in this `JoinSet`, returning an\n    /// [`AbortHandle`] that can be used to remotely cancel the task.\n    ///\n    /// [`AbortHandle`]: crate::task::AbortHandle\n    #[track_caller]\n    pub fn spawn_blocking_on<F>(&mut self, f: F, handle: &Handle) -> AbortHandle\n    where\n        F: FnOnce() -> T,\n        F: Send + 'static,\n        T: Send,\n    {\n        self.insert(handle.spawn_blocking(f))\n    }\n\n    fn insert(&mut self, jh: JoinHandle<T>) -> AbortHandle {\n        let abort = jh.abort_handle();\n        let mut entry = self.inner.insert_idle(jh);\n\n        // Set the waker that is notified when the task completes.\n        entry.with_value_and_context(|jh, ctx| jh.set_join_waker(ctx.waker()));\n        abort\n    }\n\n    /// Waits until one of the tasks in the set completes and returns its output.\n    ///\n    /// Returns `None` if the set is empty.\n    ///\n    /// # Cancel Safety\n    ///\n    /// This method is cancel safe. If `join_next` is used as the event in a `tokio::select!`\n    /// statement and some other branch completes first, it is guaranteed that no tasks were\n    /// removed from this `JoinSet`.\n    pub async fn join_next(&mut self) -> Option<Result<T, JoinError>> {\n        std::future::poll_fn(|cx| self.poll_join_next(cx)).await\n    }\n\n    /// Waits until one of the tasks in the set completes and returns its\n    /// output, along with the [task ID] of the completed task.\n    ///\n    /// Returns `None` if the set is empty.\n    ///\n    /// When this method returns an error, then the id of the task that failed can be accessed\n    /// using the [`JoinError::id`] method.\n    ///\n    /// # Cancel Safety\n    ///\n    /// This method is cancel safe. If `join_next_with_id` is used as the event in a `tokio::select!`\n    /// statement and some other branch completes first, it is guaranteed that no tasks were\n    /// removed from this `JoinSet`.\n    ///\n    /// [task ID]: crate::task::Id\n    /// [`JoinError::id`]: fn@crate::task::JoinError::id\n    pub async fn join_next_with_id(&mut self) -> Option<Result<(Id, T), JoinError>> {\n        std::future::poll_fn(|cx| self.poll_join_next_with_id(cx)).await\n    }\n\n    /// Tries to join one of the tasks in the set that has completed and return its output.\n    ///\n    /// Returns `None` if there are no completed tasks, or if the set is empty.\n    pub fn try_join_next(&mut self) -> Option<Result<T, JoinError>> {\n        // Loop over all notified `JoinHandle`s to find one that's ready, or until none are left.\n        loop {\n            let mut entry = self.inner.try_pop_notified()?;\n\n            let res = entry.with_value_and_context(|jh, ctx| {\n                // Since this function is not async and cannot be forced to yield, we should\n                // disable budgeting when we want to check for the `JoinHandle` readiness.\n                Pin::new(&mut unconstrained(jh)).poll(ctx)\n            });\n\n            if let Poll::Ready(res) = res {\n                let _entry = entry.remove();\n\n                return Some(res);\n            }\n        }\n    }\n\n    /// Tries to join one of the tasks in the set that has completed and return its output,\n    /// along with the [task ID] of the completed task.\n    ///\n    /// Returns `None` if there are no completed tasks, or if the set is empty.\n    ///\n    /// When this method returns an error, then the id of the task that failed can be accessed\n    /// using the [`JoinError::id`] method.\n    ///\n    /// [task ID]: crate::task::Id\n    /// [`JoinError::id`]: fn@crate::task::JoinError::id\n    pub fn try_join_next_with_id(&mut self) -> Option<Result<(Id, T), JoinError>> {\n        // Loop over all notified `JoinHandle`s to find one that's ready, or until none are left.\n        loop {\n            let mut entry = self.inner.try_pop_notified()?;\n\n            let res = entry.with_value_and_context(|jh, ctx| {\n                // Since this function is not async and cannot be forced to yield, we should\n                // disable budgeting when we want to check for the `JoinHandle` readiness.\n                Pin::new(&mut unconstrained(jh)).poll(ctx)\n            });\n\n            if let Poll::Ready(res) = res {\n                let entry = entry.remove();\n\n                return Some(res.map(|output| (entry.id(), output)));\n            }\n        }\n    }\n\n    /// Aborts all tasks and waits for them to finish shutting down.\n    ///\n    /// Calling this method is equivalent to calling [`abort_all`] and then calling [`join_next`] in\n    /// a loop until it returns `None`.\n    ///\n    /// This method ignores any panics in the tasks shutting down. When this call returns, the\n    /// `JoinSet` will be empty.\n    ///\n    /// [`abort_all`]: fn@Self::abort_all\n    /// [`join_next`]: fn@Self::join_next\n    pub async fn shutdown(&mut self) {\n        self.abort_all();\n        while self.join_next().await.is_some() {}\n    }\n\n    /// Awaits the completion of all tasks in this `JoinSet`, returning a vector of their results.\n    ///\n    /// The results will be stored in the order they completed not the order they were spawned.\n    /// This is a convenience method that is equivalent to calling [`join_next`] in\n    /// a loop. If any tasks on the `JoinSet` fail with an [`JoinError`], then this call\n    /// to `join_all` will panic and all remaining tasks on the `JoinSet` are\n    /// cancelled. To handle errors in any other way, manually call [`join_next`]\n    /// in a loop.\n    ///\n    /// # Examples\n    ///\n    /// Spawn multiple tasks and `join_all` them.\n    ///\n    /// ```\n    /// use tokio::task::JoinSet;\n    /// use std::time::Duration;\n    ///\n    /// #[tokio::main]\n    /// async fn main() {\n    ///     let mut set = JoinSet::new();\n    ///\n    ///     for i in 0..3 {\n    ///        set.spawn(async move {\n    ///            tokio::time::sleep(Duration::from_secs(3 - i)).await;\n    ///            i\n    ///        });\n    ///     }   \n    ///\n    ///     let output = set.join_all().await;  \n    ///     assert_eq!(output, vec![2, 1, 0]);\n    /// }\n    /// ```\n    ///\n    /// Equivalent implementation of `join_all`, using [`join_next`] and loop.\n    ///\n    /// ```\n    /// use tokio::task::JoinSet;\n    /// use std::panic;\n    ///\n    /// #[tokio::main]\n    /// async fn main() {\n    ///     let mut set = JoinSet::new();\n    ///\n    ///     for i in 0..3 {\n    ///        set.spawn(async move {i});\n    ///     }   \n    ///     \n    ///     let mut output = Vec::new();\n    ///     while let Some(res) = set.join_next().await{\n    ///         match res {\n    ///             Ok(t) => output.push(t),\n    ///             Err(err) if err.is_panic() => panic::resume_unwind(err.into_panic()),\n    ///             Err(err) => panic!(\"{err}\"),\n    ///         }\n    ///     }\n    ///     assert_eq!(output.len(),3);\n    /// }\n    /// ```\n    /// [`join_next`]: fn@Self::join_next\n    /// [`JoinError::id`]: fn@crate::task::JoinError::id\n    pub async fn join_all(mut self) -> Vec<T> {\n        let mut output = Vec::with_capacity(self.len());\n\n        while let Some(res) = self.join_next().await {\n            match res {\n                Ok(t) => output.push(t),\n                Err(err) if err.is_panic() => panic::resume_unwind(err.into_panic()),\n                Err(err) => panic!(\"{err}\"),\n            }\n        }\n        output\n    }\n\n    /// Aborts all tasks on this `JoinSet`.\n    ///\n    /// This does not remove the tasks from the `JoinSet`. To wait for the tasks to complete\n    /// cancellation, you should call `join_next` in a loop until the `JoinSet` is empty.\n    pub fn abort_all(&mut self) {\n        self.inner.for_each(|jh| jh.abort());\n    }\n\n    /// Removes all tasks from this `JoinSet` without aborting them.\n    ///\n    /// The tasks removed by this call will continue to run in the background even if the `JoinSet`\n    /// is dropped.\n    pub fn detach_all(&mut self) {\n        self.inner.drain(drop);\n    }\n\n    /// Polls for one of the tasks in the set to complete.\n    ///\n    /// If this returns `Poll::Ready(Some(_))`, then the task that completed is removed from the set.\n    ///\n    /// When the method returns `Poll::Pending`, the `Waker` in the provided `Context` is scheduled\n    /// to receive a wakeup when a task in the `JoinSet` completes. Note that on multiple calls to\n    /// `poll_join_next`, only the `Waker` from the `Context` passed to the most recent call is\n    /// scheduled to receive a wakeup.\n    ///\n    /// # Returns\n    ///\n    /// This function returns:\n    ///\n    ///  * `Poll::Pending` if the `JoinSet` is not empty but there is no task whose output is\n    ///     available right now.\n    ///  * `Poll::Ready(Some(Ok(value)))` if one of the tasks in this `JoinSet` has completed.\n    ///     The `value` is the return value of one of the tasks that completed.\n    ///  * `Poll::Ready(Some(Err(err)))` if one of the tasks in this `JoinSet` has panicked or been\n    ///     aborted. The `err` is the `JoinError` from the panicked/aborted task.\n    ///  * `Poll::Ready(None)` if the `JoinSet` is empty.\n    ///\n    /// Note that this method may return `Poll::Pending` even if one of the tasks has completed.\n    /// This can happen if the [coop budget] is reached.\n    ///\n    /// [coop budget]: crate::task#cooperative-scheduling\n    pub fn poll_join_next(&mut self, cx: &mut Context<'_>) -> Poll<Option<Result<T, JoinError>>> {\n        // The call to `pop_notified` moves the entry to the `idle` list. It is moved back to\n        // the `notified` list if the waker is notified in the `poll` call below.\n        let mut entry = match self.inner.pop_notified(cx.waker()) {\n            Some(entry) => entry,\n            None => {\n                if self.is_empty() {\n                    return Poll::Ready(None);\n                } else {\n                    // The waker was set by `pop_notified`.\n                    return Poll::Pending;\n                }\n            }\n        };\n\n        let res = entry.with_value_and_context(|jh, ctx| Pin::new(jh).poll(ctx));\n\n        if let Poll::Ready(res) = res {\n            let _entry = entry.remove();\n            Poll::Ready(Some(res))\n        } else {\n            // A JoinHandle generally won't emit a wakeup without being ready unless\n            // the coop limit has been reached. We yield to the executor in this\n            // case.\n            cx.waker().wake_by_ref();\n            Poll::Pending\n        }\n    }\n\n    /// Polls for one of the tasks in the set to complete.\n    ///\n    /// If this returns `Poll::Ready(Some(_))`, then the task that completed is removed from the set.\n    ///\n    /// When the method returns `Poll::Pending`, the `Waker` in the provided `Context` is scheduled\n    /// to receive a wakeup when a task in the `JoinSet` completes. Note that on multiple calls to\n    /// `poll_join_next`, only the `Waker` from the `Context` passed to the most recent call is\n    /// scheduled to receive a wakeup.\n    ///\n    /// # Returns\n    ///\n    /// This function returns:\n    ///\n    ///  * `Poll::Pending` if the `JoinSet` is not empty but there is no task whose output is\n    ///     available right now.\n    ///  * `Poll::Ready(Some(Ok((id, value))))` if one of the tasks in this `JoinSet` has completed.\n    ///     The `value` is the return value of one of the tasks that completed, and\n    ///    `id` is the [task ID] of that task.\n    ///  * `Poll::Ready(Some(Err(err)))` if one of the tasks in this `JoinSet` has panicked or been\n    ///     aborted. The `err` is the `JoinError` from the panicked/aborted task.\n    ///  * `Poll::Ready(None)` if the `JoinSet` is empty.\n    ///\n    /// Note that this method may return `Poll::Pending` even if one of the tasks has completed.\n    /// This can happen if the [coop budget] is reached.\n    ///\n    /// [coop budget]: crate::task#cooperative-scheduling\n    /// [task ID]: crate::task::Id\n    pub fn poll_join_next_with_id(\n        &mut self,\n        cx: &mut Context<'_>,\n    ) -> Poll<Option<Result<(Id, T), JoinError>>> {\n        // The call to `pop_notified` moves the entry to the `idle` list. It is moved back to\n        // the `notified` list if the waker is notified in the `poll` call below.\n        let mut entry = match self.inner.pop_notified(cx.waker()) {\n            Some(entry) => entry,\n            None => {\n                if self.is_empty() {\n                    return Poll::Ready(None);\n                } else {\n                    // The waker was set by `pop_notified`.\n                    return Poll::Pending;\n                }\n            }\n        };\n\n        let res = entry.with_value_and_context(|jh, ctx| Pin::new(jh).poll(ctx));\n\n        if let Poll::Ready(res) = res {\n            let entry = entry.remove();\n            // If the task succeeded, add the task ID to the output. Otherwise, the\n            // `JoinError` will already have the task's ID.\n            Poll::Ready(Some(res.map(|output| (entry.id(), output))))\n        } else {\n            // A JoinHandle generally won't emit a wakeup without being ready unless\n            // the coop limit has been reached. We yield to the executor in this\n            // case.\n            cx.waker().wake_by_ref();\n            Poll::Pending\n        }\n    }\n}\n\nimpl<T> Drop for JoinSet<T> {\n    fn drop(&mut self) {\n        self.inner.drain(|join_handle| join_handle.abort());\n    }\n}\n\nimpl<T> fmt::Debug for JoinSet<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"JoinSet\").field(\"len\", &self.len()).finish()\n    }\n}\n\nimpl<T> Default for JoinSet<T> {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n/// Collect an iterator of futures into a [`JoinSet`].\n///\n/// This is equivalent to calling [`JoinSet::spawn`] on each element of the iterator.\n///\n/// # Examples\n///\n/// The main example from [`JoinSet`]'s documentation can also be written using [`collect`]:\n///\n/// ```\n/// use tokio::task::JoinSet;\n///\n/// #[tokio::main]\n/// async fn main() {\n///     let mut set: JoinSet<_> = (0..10).map(|i| async move { i }).collect();\n///\n///     let mut seen = [false; 10];\n///     while let Some(res) = set.join_next().await {\n///         let idx = res.unwrap();\n///         seen[idx] = true;\n///     }\n///\n///     for i in 0..10 {\n///         assert!(seen[i]);\n///     }\n/// }\n/// ```\n///\n/// [`collect`]: std::iter::Iterator::collect\nimpl<T, F> std::iter::FromIterator<F> for JoinSet<T>\nwhere\n    F: Future<Output = T>,\n    F: Send + 'static,\n    T: Send + 'static,\n{\n    fn from_iter<I: IntoIterator<Item = F>>(iter: I) -> Self {\n        let mut set = Self::new();\n        iter.into_iter().for_each(|task| {\n            set.spawn(task);\n        });\n        set\n    }\n}\n\n// === impl Builder ===\n\n#[cfg(all(tokio_unstable, feature = \"tracing\"))]\n#[cfg_attr(docsrs, doc(cfg(all(tokio_unstable, feature = \"tracing\"))))]\nimpl<'a, T: 'static> Builder<'a, T> {\n    /// Assigns a name to the task which will be spawned.\n    pub fn name(self, name: &'a str) -> Self {\n        let builder = self.builder.name(name);\n        Self { builder, ..self }\n    }\n\n    /// Spawn the provided task with this builder's settings and store it in the\n    /// [`JoinSet`], returning an [`AbortHandle`] that can be used to remotely\n    /// cancel the task.\n    ///\n    /// # Returns\n    ///\n    /// An [`AbortHandle`] that can be used to remotely cancel the task.\n    ///\n    /// # Panics\n    ///\n    /// This method panics if called outside of a Tokio runtime.\n    ///\n    /// [`AbortHandle`]: crate::task::AbortHandle\n    #[track_caller]\n    pub fn spawn<F>(self, future: F) -> std::io::Result<AbortHandle>\n    where\n        F: Future<Output = T>,\n        F: Send + 'static,\n        T: Send,\n    {\n        Ok(self.joinset.insert(self.builder.spawn(future)?))\n    }\n\n    /// Spawn the provided task on the provided [runtime handle] with this\n    /// builder's settings, and store it in the [`JoinSet`].\n    ///\n    /// # Returns\n    ///\n    /// An [`AbortHandle`] that can be used to remotely cancel the task.\n    ///\n    ///\n    /// [`AbortHandle`]: crate::task::AbortHandle\n    /// [runtime handle]: crate::runtime::Handle\n    #[track_caller]\n    pub fn spawn_on<F>(self, future: F, handle: &Handle) -> std::io::Result<AbortHandle>\n    where\n        F: Future<Output = T>,\n        F: Send + 'static,\n        T: Send,\n    {\n        Ok(self.joinset.insert(self.builder.spawn_on(future, handle)?))\n    }\n\n    /// Spawn the blocking code on the blocking threadpool with this builder's\n    /// settings, and store it in the [`JoinSet`].\n    ///\n    /// # Returns\n    ///\n    /// An [`AbortHandle`] that can be used to remotely cancel the task.\n    ///\n    /// # Panics\n    ///\n    /// This method panics if called outside of a Tokio runtime.\n    ///\n    /// [`JoinSet`]: crate::task::JoinSet\n    /// [`AbortHandle`]: crate::task::AbortHandle\n    #[track_caller]\n    pub fn spawn_blocking<F>(self, f: F) -> std::io::Result<AbortHandle>\n    where\n        F: FnOnce() -> T,\n        F: Send + 'static,\n        T: Send,\n    {\n        Ok(self.joinset.insert(self.builder.spawn_blocking(f)?))\n    }\n\n    /// Spawn the blocking code on the blocking threadpool of the provided\n    /// runtime handle with this builder's settings, and store it in the\n    /// [`JoinSet`].\n    ///\n    /// # Returns\n    ///\n    /// An [`AbortHandle`] that can be used to remotely cancel the task.\n    ///\n    /// [`JoinSet`]: crate::task::JoinSet\n    /// [`AbortHandle`]: crate::task::AbortHandle\n    #[track_caller]\n    pub fn spawn_blocking_on<F>(self, f: F, handle: &Handle) -> std::io::Result<AbortHandle>\n    where\n        F: FnOnce() -> T,\n        F: Send + 'static,\n        T: Send,\n    {\n        Ok(self\n            .joinset\n            .insert(self.builder.spawn_blocking_on(f, handle)?))\n    }\n\n    /// Spawn the provided task on the current [`LocalSet`] with this builder's\n    /// settings, and store it in the [`JoinSet`].\n    ///\n    /// # Returns\n    ///\n    /// An [`AbortHandle`] that can be used to remotely cancel the task.\n    ///\n    /// # Panics\n    ///\n    /// This method panics if it is called outside of a `LocalSet`.\n    ///\n    /// [`LocalSet`]: crate::task::LocalSet\n    /// [`AbortHandle`]: crate::task::AbortHandle\n    #[track_caller]\n    pub fn spawn_local<F>(self, future: F) -> std::io::Result<AbortHandle>\n    where\n        F: Future<Output = T>,\n        F: 'static,\n    {\n        Ok(self.joinset.insert(self.builder.spawn_local(future)?))\n    }\n\n    /// Spawn the provided task on the provided [`LocalSet`] with this builder's\n    /// settings, and store it in the [`JoinSet`].\n    ///\n    /// # Returns\n    ///\n    /// An [`AbortHandle`] that can be used to remotely cancel the task.\n    ///\n    /// [`LocalSet`]: crate::task::LocalSet\n    /// [`AbortHandle`]: crate::task::AbortHandle\n    #[track_caller]\n    pub fn spawn_local_on<F>(self, future: F, local_set: &LocalSet) -> std::io::Result<AbortHandle>\n    where\n        F: Future<Output = T>,\n        F: 'static,\n    {\n        Ok(self\n            .joinset\n            .insert(self.builder.spawn_local_on(future, local_set)?))\n    }\n}\n\n// Manual `Debug` impl so that `Builder` is `Debug` regardless of whether `T` is\n// `Debug`.\n#[cfg(all(tokio_unstable, feature = \"tracing\"))]\n#[cfg_attr(docsrs, doc(cfg(all(tokio_unstable, feature = \"tracing\"))))]\nimpl<'a, T> fmt::Debug for Builder<'a, T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"join_set::Builder\")\n            .field(\"joinset\", &self.joinset)\n            .field(\"builder\", &self.builder)\n            .finish()\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "175ac84ff0d5a414d5fd1bffaf2164838a5f0612",
    "func": "use crate::{\n    ActiveModelBehavior, ActiveModelTrait, ConnectionTrait, DbErr, DeleteResult, EntityTrait,\n    IntoActiveModel, Linked, QueryFilter, QueryResult, Related, Select, SelectModel, SelectorRaw,\n    Statement,\n};\nuse async_trait::async_trait;\npub use sea_query::Value;\nuse std::fmt::Debug;\n\n/// A Trait for a Model\n#[async_trait]\npub trait ModelTrait: Clone + Send + Debug {\n    #[allow(missing_docs)]\n    type Entity: EntityTrait;\n\n    /// Get the [Value] of a column from an Entity\n    fn get(&self, c: <Self::Entity as EntityTrait>::Column) -> Value;\n\n    /// Set the [Value] of a column in an Entity\n    fn set(&mut self, c: <Self::Entity as EntityTrait>::Column, v: Value);\n\n    /// Find related Models\n    fn find_related<R>(&self, _: R) -> Select<R>\n    where\n        R: EntityTrait,\n        Self::Entity: Related<R>,\n    {\n        <Self::Entity as Related<R>>::find_related().belongs_to(self)\n    }\n\n    /// Find linked Models\n    fn find_linked<L>(&self, l: L) -> Select<L::ToEntity>\n    where\n        L: Linked<FromEntity = Self::Entity>,\n    {\n        let tbl_alias = &format!(\"r{}\", l.link().len() - 1);\n        l.find_linked().belongs_to_tbl_alias(self, tbl_alias)\n    }\n\n    /// Delete a model\n    async fn delete<'a, A, C>(self, db: &'a C) -> Result<DeleteResult, DbErr>\n    where\n        Self: IntoActiveModel<A>,\n        C: ConnectionTrait,\n        A: ActiveModelTrait<Entity = Self::Entity> + ActiveModelBehavior + Send + 'a,\n    {\n        self.into_active_model().delete(db).await\n    }\n}\n\n/// A Trait for implementing a [QueryResult]\npub trait FromQueryResult: Sized {\n    /// Instantiate a Model from a [QueryResult]\n    fn from_query_result(res: &QueryResult, pre: &str) -> Result<Self, DbErr>;\n\n    /// Transform the error from instantiating a Model from a [QueryResult]\n    /// and converting it to an [Option]\n    fn from_query_result_optional(res: &QueryResult, pre: &str) -> Result<Option<Self>, DbErr> {\n        Ok(Self::from_query_result(res, pre).ok())\n    }\n\n    /// ```\n    /// # use sea_orm::{error::*, tests_cfg::*, *};\n    /// #\n    /// # #[smol_potat::main]\n    /// # #[cfg(feature = \"mock\")]\n    /// # pub async fn main() -> Result<(), DbErr> {\n    /// #\n    /// # let db = MockDatabase::new(DbBackend::Postgres)\n    /// #     .append_query_results([[\n    /// #         maplit::btreemap! {\n    /// #             \"name\" => Into::<Value>::into(\"Chocolate Forest\"),\n    /// #             \"num_of_cakes\" => Into::<Value>::into(2),\n    /// #         },\n    /// #     ]])\n    /// #     .into_connection();\n    /// #\n    /// use sea_orm::{query::*, FromQueryResult};\n    ///\n    /// #[derive(Debug, PartialEq, FromQueryResult)]\n    /// struct SelectResult {\n    ///     name: String,\n    ///     num_of_cakes: i32,\n    /// }\n    ///\n    /// let res: Vec<SelectResult> = SelectResult::find_by_statement(Statement::from_sql_and_values(\n    ///     DbBackend::Postgres,\n    ///     r#\"SELECT \"name\", COUNT(*) AS \"num_of_cakes\" FROM \"cake\" GROUP BY(\"name\")\"#,\n    ///     [],\n    /// ))\n    /// .all(&db)\n    /// .await?;\n    ///\n    /// assert_eq!(\n    ///     res,\n    ///     [SelectResult {\n    ///         name: \"Chocolate Forest\".to_owned(),\n    ///         num_of_cakes: 2,\n    ///     },]\n    /// );\n    /// #\n    /// # assert_eq!(\n    /// #     db.into_transaction_log(),\n    /// #     [Transaction::from_sql_and_values(\n    /// #         DbBackend::Postgres,\n    /// #         r#\"SELECT \"name\", COUNT(*) AS \"num_of_cakes\" FROM \"cake\" GROUP BY(\"name\")\"#,\n    /// #         []\n    /// #     ),]\n    /// # );\n    /// #\n    /// # Ok(())\n    /// # }\n    /// ```\n    fn find_by_statement(stmt: Statement) -> SelectorRaw<SelectModel<Self>> {\n        SelectorRaw::<SelectModel<Self>>::from_statement(stmt)\n    }\n}\n\n/// A Trait for any type that can be converted into an Model\npub trait TryIntoModel<M>\nwhere\n    M: ModelTrait,\n{\n    /// Method to call to perform the conversion\n    fn try_into_model(self) -> Result<M, DbErr>;\n}\n\nimpl<M> TryIntoModel<M> for M\nwhere\n    M: ModelTrait,\n{\n    fn try_into_model(self) -> Result<M, DbErr> {\n        Ok(self)\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "fa87f57243d5d20a4b395e9cb7c10870d234c25f",
    "func": "// Copyright 2019-2024 Tauri Programme within The Commons Conservancy\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n\nuse crate::{\n  helpers::{\n    app_paths::{app_dir, tauri_dir},\n    command_env,\n    config::{\n      get as get_config, reload as reload_config, BeforeDevCommand, ConfigHandle, FrontendDist,\n    },\n  },\n  interface::{AppInterface, DevProcess, ExitReason, Interface},\n  CommandExt, ConfigValue, Result,\n};\n\nuse anyhow::{bail, Context};\nuse clap::{ArgAction, Parser};\nuse shared_child::SharedChild;\nuse tauri_utils::platform::Target;\n\nuse std::{\n  env::set_current_dir,\n  net::{IpAddr, Ipv4Addr},\n  process::{exit, Command, Stdio},\n  sync::{\n    atomic::{AtomicBool, Ordering},\n    Arc, Mutex, OnceLock,\n  },\n};\n\nmod builtin_dev_server;\n\nstatic BEFORE_DEV: OnceLock<Mutex<Arc<SharedChild>>> = OnceLock::new();\nstatic KILL_BEFORE_DEV_FLAG: OnceLock<AtomicBool> = OnceLock::new();\n\n#[cfg(unix)]\nconst KILL_CHILDREN_SCRIPT: &[u8] = include_bytes!(\"../scripts/kill-children.sh\");\n\npub const TAURI_CLI_BUILTIN_WATCHER_IGNORE_FILE: &[u8] =\n  include_bytes!(\"../tauri-dev-watcher.gitignore\");\n\n#[derive(Debug, Clone, Parser)]\n#[clap(\n  about = \"Run your app in development mode\",\n  long_about = \"Run your app in development mode with hot-reloading for the Rust code. It makes use of the `build.devUrl` property from your `tauri.conf.json` file. It also runs your `build.beforeDevCommand` which usually starts your frontend devServer.\",\n  trailing_var_arg(true)\n)]\npub struct Options {\n  /// Binary to use to run the application\n  #[clap(short, long)]\n  pub runner: Option<String>,\n  /// Target triple to build against\n  #[clap(short, long)]\n  pub target: Option<String>,\n  /// List of cargo features to activate\n  #[clap(short, long, action = ArgAction::Append, num_args(0..))]\n  pub features: Option<Vec<String>>,\n  /// Exit on panic\n  #[clap(short, long)]\n  pub exit_on_panic: bool,\n  /// JSON string or path to JSON file to merge with tauri.conf.json\n  #[clap(short, long)]\n  pub config: Option<ConfigValue>,\n  /// Run the code in release mode\n  #[clap(long = \"release\")]\n  pub release_mode: bool,\n  /// Command line arguments passed to the runner.\n  /// Use `--` to explicitly mark the start of the arguments. Arguments after a second `--` are passed to the application\n  /// e.g. `tauri dev -- [runnerArgs] -- [appArgs]`.\n  pub args: Vec<String>,\n  /// Skip waiting for the frontend dev server to start before building the tauri application.\n  #[clap(long, env = \"TAURI_CLI_NO_DEV_SERVER_WAIT\")]\n  pub no_dev_server_wait: bool,\n  /// Disable the file watcher.\n  #[clap(long)]\n  pub no_watch: bool,\n\n  /// Disable the built-in dev server for static files.\n  #[clap(long)]\n  pub no_dev_server: bool,\n  /// Specify port for the built-in dev server for static files. Defaults to 1430.\n  #[clap(long, env = \"TAURI_CLI_PORT\")]\n  pub port: Option<u16>,\n\n  #[clap(skip)]\n  pub host: Option<IpAddr>,\n}\n\npub fn command(options: Options) -> Result<()> {\n  crate::helpers::app_paths::resolve();\n\n  let r = command_internal(options);\n  if r.is_err() {\n    kill_before_dev_process();\n  }\n  r\n}\n\nfn command_internal(mut options: Options) -> Result<()> {\n  let target = options\n    .target\n    .as_deref()\n    .map(Target::from_triple)\n    .unwrap_or_else(Target::current);\n\n  let config = get_config(target, options.config.as_ref().map(|c| &c.0))?;\n\n  let mut interface = AppInterface::new(\n    config.lock().unwrap().as_ref().unwrap(),\n    options.target.clone(),\n  )?;\n\n  setup(&interface, &mut options, config)?;\n\n  let exit_on_panic = options.exit_on_panic;\n  let no_watch = options.no_watch;\n  interface.dev(options.into(), move |status, reason| {\n    on_app_exit(status, reason, exit_on_panic, no_watch)\n  })\n}\n\npub fn setup(interface: &AppInterface, options: &mut Options, config: ConfigHandle) -> Result<()> {\n  let tauri_path = tauri_dir();\n  set_current_dir(tauri_path).with_context(|| \"failed to change current working directory\")?;\n\n  if let Some(before_dev) = config\n    .lock()\n    .unwrap()\n    .as_ref()\n    .unwrap()\n    .build\n    .before_dev_command\n    .clone()\n  {\n    let (script, script_cwd, wait) = match before_dev {\n      BeforeDevCommand::Script(s) if s.is_empty() => (None, None, false),\n      BeforeDevCommand::Script(s) => (Some(s), None, false),\n      BeforeDevCommand::ScriptWithOptions { script, cwd, wait } => {\n        (Some(script), cwd.map(Into::into), wait)\n      }\n    };\n    let cwd = script_cwd.unwrap_or_else(|| app_dir().clone());\n    if let Some(before_dev) = script {\n      log::info!(action = \"Running\"; \"BeforeDevCommand (`{}`)\", before_dev);\n      let mut env = command_env(true);\n      env.extend(interface.env());\n\n      #[cfg(windows)]\n      let mut command = {\n        let mut command = Command::new(\"cmd\");\n        command\n          .arg(\"/S\")\n          .arg(\"/C\")\n          .arg(&before_dev)\n          .current_dir(cwd)\n          .envs(env);\n        command\n      };\n      #[cfg(not(windows))]\n      let mut command = {\n        let mut command = Command::new(\"sh\");\n        command\n          .arg(\"-c\")\n          .arg(&before_dev)\n          .current_dir(cwd)\n          .envs(env);\n        command\n      };\n\n      if wait {\n        let status = command.piped().with_context(|| {\n          format!(\n            \"failed to run `{}` with `{}`\",\n            before_dev,\n            if cfg!(windows) { \"cmd /S /C\" } else { \"sh -c\" }\n          )\n        })?;\n        if !status.success() {\n          bail!(\n            \"beforeDevCommand `{}` failed with exit code {}\",\n            before_dev,\n            status.code().unwrap_or_default()\n          );\n        }\n      } else {\n        command.stdin(Stdio::piped());\n        command.stdout(os_pipe::dup_stdout()?);\n        command.stderr(os_pipe::dup_stderr()?);\n\n        let child = SharedChild::spawn(&mut command)\n          .unwrap_or_else(|_| panic!(\"failed to run `{before_dev}`\"));\n        let child = Arc::new(child);\n        let child_ = child.clone();\n\n        std::thread::spawn(move || {\n          let status = child_\n            .wait()\n            .expect(\"failed to wait on \\\"beforeDevCommand\\\"\");\n          if !(status.success() || KILL_BEFORE_DEV_FLAG.get().unwrap().load(Ordering::Relaxed)) {\n            log::error!(\"The \\\"beforeDevCommand\\\" terminated with a non-zero status code.\");\n            exit(status.code().unwrap_or(1));\n          }\n        });\n\n        BEFORE_DEV.set(Mutex::new(child)).unwrap();\n        KILL_BEFORE_DEV_FLAG.set(AtomicBool::default()).unwrap();\n\n        let _ = ctrlc::set_handler(move || {\n          kill_before_dev_process();\n          exit(130);\n        });\n      }\n    }\n  }\n\n  if options.runner.is_none() {\n    options\n      .runner\n      .clone_from(&config.lock().unwrap().as_ref().unwrap().build.runner);\n  }\n\n  let mut cargo_features = config\n    .lock()\n    .unwrap()\n    .as_ref()\n    .unwrap()\n    .build\n    .features\n    .clone()\n    .unwrap_or_default();\n  if let Some(features) = &options.features {\n    cargo_features.extend(features.clone());\n  }\n\n  let mut dev_url = config\n    .lock()\n    .unwrap()\n    .as_ref()\n    .unwrap()\n    .build\n    .dev_url\n    .clone();\n  let frontend_dist = config\n    .lock()\n    .unwrap()\n    .as_ref()\n    .unwrap()\n    .build\n    .frontend_dist\n    .clone();\n  if !options.no_dev_server && dev_url.is_none() {\n    if let Some(FrontendDist::Directory(path)) = &frontend_dist {\n      if path.exists() {\n        let path = path.canonicalize()?;\n\n        let ip = options\n          .host\n          .unwrap_or_else(|| Ipv4Addr::new(127, 0, 0, 1).into());\n\n        let server_url = builtin_dev_server::start(path, ip, options.port)?;\n        let server_url = format!(\"http://{server_url}\");\n        dev_url = Some(server_url.parse().unwrap());\n\n        if let Some(c) = &mut options.config {\n          if let Some(build) = c\n            .0\n            .as_object_mut()\n            .and_then(|root| root.get_mut(\"build\"))\n            .and_then(|build| build.as_object_mut())\n          {\n            build.insert(\"devUrl\".into(), server_url.into());\n          }\n        } else {\n          options\n            .config\n            .replace(crate::ConfigValue(serde_json::json!({\n              \"build\": {\n                \"devUrl\": server_url\n              }\n            })));\n        }\n\n        reload_config(options.config.as_ref().map(|c| &c.0))?;\n      }\n    }\n  }\n\n  if !options.no_dev_server_wait {\n    if let Some(url) = dev_url {\n      let host = url\n        .host()\n        .unwrap_or_else(|| panic!(\"No host name in the URL\"));\n      let port = url\n        .port_or_known_default()\n        .unwrap_or_else(|| panic!(\"No port number in the URL\"));\n      let addrs;\n      let addr;\n      let addrs = match host {\n        url::Host::Domain(domain) => {\n          use std::net::ToSocketAddrs;\n          addrs = (domain, port).to_socket_addrs()?;\n          addrs.as_slice()\n        }\n        url::Host::Ipv4(ip) => {\n          addr = (ip, port).into();\n          std::slice::from_ref(&addr)\n        }\n        url::Host::Ipv6(ip) => {\n          addr = (ip, port).into();\n          std::slice::from_ref(&addr)\n        }\n      };\n      let mut i = 0;\n      let sleep_interval = std::time::Duration::from_secs(2);\n      let timeout_duration = std::time::Duration::from_secs(1);\n      let max_attempts = 90;\n      'waiting: loop {\n        for addr in addrs.iter() {\n          if std::net::TcpStream::connect_timeout(addr, timeout_duration).is_ok() {\n            break 'waiting;\n          }\n        }\n\n        if i % 3 == 1 {\n          log::warn!(\"Waiting for your frontend dev server to start on {url}...\",);\n        }\n        i += 1;\n        if i == max_attempts {\n          log::error!(\"Could not connect to `{url}` after {}s. Please make sure that is the URL to your dev server.\", i * sleep_interval.as_secs());\n          exit(1);\n        }\n        std::thread::sleep(sleep_interval);\n      }\n    }\n  }\n\n  Ok(())\n}\n\npub fn wait_dev_process<\n  C: DevProcess + Send + 'static,\n  F: Fn(Option<i32>, ExitReason) + Send + Sync + 'static,\n>(\n  child: C,\n  on_exit: F,\n) {\n  std::thread::spawn(move || {\n    let code = child\n      .wait()\n      .ok()\n      .and_then(|status| status.code())\n      .or(Some(1));\n    on_exit(\n      code,\n      if child.manually_killed_process() {\n        ExitReason::TriggeredKill\n      } else {\n        ExitReason::NormalExit\n      },\n    );\n  });\n}\n\npub fn on_app_exit(code: Option<i32>, reason: ExitReason, exit_on_panic: bool, no_watch: bool) {\n  if no_watch\n    || (!matches!(reason, ExitReason::TriggeredKill)\n      && (exit_on_panic || matches!(reason, ExitReason::NormalExit)))\n  {\n    kill_before_dev_process();\n    exit(code.unwrap_or(0));\n  }\n}\n\npub fn kill_before_dev_process() {\n  if let Some(child) = BEFORE_DEV.get() {\n    let child = child.lock().unwrap();\n    let kill_before_dev_flag = KILL_BEFORE_DEV_FLAG.get().unwrap();\n    if kill_before_dev_flag.load(Ordering::Relaxed) {\n      return;\n    }\n    kill_before_dev_flag.store(true, Ordering::Relaxed);\n    #[cfg(windows)]\n    {\n      let powershell_path = std::env::var(\"SYSTEMROOT\").map_or_else(\n        |_| \"powershell.exe\".to_string(),\n        |p| format!(\"{p}\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe\"),\n      );\n      let _ = Command::new(powershell_path)\n      .arg(\"-NoProfile\")\n      .arg(\"-Command\")\n      .arg(format!(\"function Kill-Tree {{ Param([int]$ppid); Get-CimInstance Win32_Process | Where-Object {{ $_.ParentProcessId -eq $ppid }} | ForEach-Object {{ Kill-Tree $_.ProcessId }}; Stop-Process -Id $ppid -ErrorAction SilentlyContinue }}; Kill-Tree {}\", child.id()))\n      .status();\n    }\n    #[cfg(unix)]\n    {\n      use std::io::Write;\n      let mut kill_children_script_path = std::env::temp_dir();\n      kill_children_script_path.push(\"tauri-stop-dev-processes.sh\");\n\n      if !kill_children_script_path.exists() {\n        if let Ok(mut file) = std::fs::File::create(&kill_children_script_path) {\n          use std::os::unix::fs::PermissionsExt;\n          let _ = file.write_all(KILL_CHILDREN_SCRIPT);\n          let mut permissions = file.metadata().unwrap().permissions();\n          permissions.set_mode(0o770);\n          let _ = file.set_permissions(permissions);\n        }\n      }\n      let _ = Command::new(&kill_children_script_path)\n        .arg(child.id().to_string())\n        .output();\n    }\n    let _ = child.kill();\n  }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "b84db865d50a915366ecb30e02d5ca21362c4c85",
    "func": "#![cfg_attr(not(feature = \"postgres\"), allow(dead_code))]\n\nmod functions;\nmod structures;\n\npub use self::functions::*;\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "cad3b6fe127c4f13e87bcae2ea1bf130c9ed9de1",
    "func": "use serde_derive::Serialize;\n\n#[derive(Serialize)]\nstruct S {\n    #[serde(rename = 3.14)]\n    float: (),\n}\n\nfn main() {}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "95d54ae2289c1e4b90d2978c360f59d0deafe8c9",
    "func": "use std::io::{self, IoSlice};\nuse std::ops::DerefMut;\nuse std::pin::Pin;\nuse std::task::{Context, Poll};\n\n/// Writes bytes asynchronously.\n///\n/// The trait inherits from [`std::io::Write`] and indicates that an I/O object is\n/// **nonblocking**. All non-blocking I/O objects must return an error when\n/// bytes cannot be written instead of blocking the current thread.\n///\n/// Specifically, this means that the [`poll_write`] function will return one of\n/// the following:\n///\n/// * `Poll::Ready(Ok(n))` means that `n` bytes of data was immediately\n///   written.\n///\n/// * `Poll::Pending` means that no data was written from the buffer\n///   provided. The I/O object is not currently writable but may become writable\n///   in the future. Most importantly, **the current future's task is scheduled\n///   to get unparked when the object is writable**. This means that like\n///   `Future::poll` you'll receive a notification when the I/O object is\n///   writable again.\n///\n/// * `Poll::Ready(Err(e))` for other errors are standard I/O errors coming from the\n///   underlying object.\n///\n/// This trait importantly means that the [`write`][stdwrite] method only works in\n/// the context of a future's task. The object may panic if used outside of a task.\n///\n/// Note that this trait also represents that the  [`Write::flush`][stdflush] method\n/// works very similarly to the `write` method, notably that `Ok(())` means that the\n/// writer has successfully been flushed, a \"would block\" error means that the\n/// current task is ready to receive a notification when flushing can make more\n/// progress, and otherwise normal errors can happen as well.\n///\n/// Utilities for working with `AsyncWrite` values are provided by\n/// [`AsyncWriteExt`].\n///\n/// [`std::io::Write`]: std::io::Write\n/// [`poll_write`]: AsyncWrite::poll_write()\n/// [stdwrite]: std::io::Write::write()\n/// [stdflush]: std::io::Write::flush()\n/// [`AsyncWriteExt`]: crate::io::AsyncWriteExt\npub trait AsyncWrite {\n    /// Attempt to write bytes from `buf` into the object.\n    ///\n    /// On success, returns `Poll::Ready(Ok(num_bytes_written))`. If successful,\n    /// then it must be guaranteed that `n <= buf.len()`. A return value of `0`\n    /// typically means that the underlying object is no longer able to accept\n    /// bytes and will likely not be able to in the future as well, or that the\n    /// buffer provided is empty.\n    ///\n    /// If the object is not ready for writing, the method returns\n    /// `Poll::Pending` and arranges for the current task (via\n    /// `cx.waker()`) to receive a notification when the object becomes\n    /// writable or is closed.\n    fn poll_write(\n        self: Pin<&mut Self>,\n        cx: &mut Context<'_>,\n        buf: &[u8],\n    ) -> Poll<Result<usize, io::Error>>;\n\n    /// Attempts to flush the object, ensuring that any buffered data reach\n    /// their destination.\n    ///\n    /// On success, returns `Poll::Ready(Ok(()))`.\n    ///\n    /// If flushing cannot immediately complete, this method returns\n    /// `Poll::Pending` and arranges for the current task (via\n    /// `cx.waker()`) to receive a notification when the object can make\n    /// progress towards flushing.\n    fn poll_flush(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Result<(), io::Error>>;\n\n    /// Initiates or attempts to shut down this writer, returning success when\n    /// the I/O connection has completely shut down.\n    ///\n    /// This method is intended to be used for asynchronous shutdown of I/O\n    /// connections. For example this is suitable for implementing shutdown of a\n    /// TLS connection or calling `TcpStream::shutdown` on a proxied connection.\n    /// Protocols sometimes need to flush out final pieces of data or otherwise\n    /// perform a graceful shutdown handshake, reading/writing more data as\n    /// appropriate. This method is the hook for such protocols to implement the\n    /// graceful shutdown logic.\n    ///\n    /// This `shutdown` method is required by implementers of the\n    /// `AsyncWrite` trait. Wrappers typically just want to proxy this call\n    /// through to the wrapped type, and base types will typically implement\n    /// shutdown logic here or just return `Ok(().into())`. Note that if you're\n    /// wrapping an underlying `AsyncWrite` a call to `shutdown` implies that\n    /// transitively the entire stream has been shut down. After your wrapper's\n    /// shutdown logic has been executed you should shut down the underlying\n    /// stream.\n    ///\n    /// Invocation of a `shutdown` implies an invocation of `flush`. Once this\n    /// method returns `Ready` it implies that a flush successfully happened\n    /// before the shutdown happened. That is, callers don't need to call\n    /// `flush` before calling `shutdown`. They can rely that by calling\n    /// `shutdown` any pending buffered data will be written out.\n    ///\n    /// # Return value\n    ///\n    /// This function returns a `Poll<io::Result<()>>` classified as such:\n    ///\n    /// * `Poll::Ready(Ok(()))` - indicates that the connection was\n    ///   successfully shut down and is now safe to deallocate/drop/close\n    ///   resources associated with it. This method means that the current task\n    ///   will no longer receive any notifications due to this method and the\n    ///   I/O object itself is likely no longer usable.\n    ///\n    /// * `Poll::Pending` - indicates that shutdown is initiated but could\n    ///   not complete just yet. This may mean that more I/O needs to happen to\n    ///   continue this shutdown operation. The current task is scheduled to\n    ///   receive a notification when it's otherwise ready to continue the\n    ///   shutdown operation. When woken up this method should be called again.\n    ///\n    /// * `Poll::Ready(Err(e))` - indicates a fatal error has happened with shutdown,\n    ///   indicating that the shutdown operation did not complete successfully.\n    ///   This typically means that the I/O object is no longer usable.\n    ///\n    /// # Errors\n    ///\n    /// This function can return normal I/O errors through `Err`, described\n    /// above. Additionally this method may also render the underlying\n    /// `Write::write` method no longer usable (e.g. will return errors in the\n    /// future). It's recommended that once `shutdown` is called the\n    /// `write` method is no longer called.\n    ///\n    /// # Panics\n    ///\n    /// This function will panic if not called within the context of a future's\n    /// task.\n    fn poll_shutdown(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Result<(), io::Error>>;\n\n    /// Like [`poll_write`], except that it writes from a slice of buffers.\n    ///\n    /// Data is copied from each buffer in order, with the final buffer\n    /// read from possibly being only partially consumed. This method must\n    /// behave as a call to [`write`] with the buffers concatenated would.\n    ///\n    /// The default implementation calls [`poll_write`] with either the first nonempty\n    /// buffer provided, or an empty one if none exists.\n    ///\n    /// On success, returns `Poll::Ready(Ok(num_bytes_written))`.\n    ///\n    /// If the object is not ready for writing, the method returns\n    /// `Poll::Pending` and arranges for the current task (via\n    /// `cx.waker()`) to receive a notification when the object becomes\n    /// writable or is closed.\n    ///\n    /// # Note\n    ///\n    /// This should be implemented as a single \"atomic\" write action. If any\n    /// data has been partially written, it is wrong to return an error or\n    /// pending.\n    ///\n    /// [`poll_write`]: AsyncWrite::poll_write\n    fn poll_write_vectored(\n        self: Pin<&mut Self>,\n        cx: &mut Context<'_>,\n        bufs: &[IoSlice<'_>],\n    ) -> Poll<Result<usize, io::Error>> {\n        let buf = bufs\n            .iter()\n            .find(|b| !b.is_empty())\n            .map_or(&[][..], |b| &**b);\n        self.poll_write(cx, buf)\n    }\n\n    /// Determines if this writer has an efficient [`poll_write_vectored`]\n    /// implementation.\n    ///\n    /// If a writer does not override the default [`poll_write_vectored`]\n    /// implementation, code using it may want to avoid the method all together\n    /// and coalesce writes into a single buffer for higher performance.\n    ///\n    /// The default implementation returns `false`.\n    ///\n    /// [`poll_write_vectored`]: AsyncWrite::poll_write_vectored\n    fn is_write_vectored(&self) -> bool {\n        false\n    }\n}\n\nmacro_rules! deref_async_write {\n    () => {\n        fn poll_write(\n            mut self: Pin<&mut Self>,\n            cx: &mut Context<'_>,\n            buf: &[u8],\n        ) -> Poll<io::Result<usize>> {\n            Pin::new(&mut **self).poll_write(cx, buf)\n        }\n\n        fn poll_write_vectored(\n            mut self: Pin<&mut Self>,\n            cx: &mut Context<'_>,\n            bufs: &[IoSlice<'_>],\n        ) -> Poll<io::Result<usize>> {\n            Pin::new(&mut **self).poll_write_vectored(cx, bufs)\n        }\n\n        fn is_write_vectored(&self) -> bool {\n            (**self).is_write_vectored()\n        }\n\n        fn poll_flush(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<io::Result<()>> {\n            Pin::new(&mut **self).poll_flush(cx)\n        }\n\n        fn poll_shutdown(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<io::Result<()>> {\n            Pin::new(&mut **self).poll_shutdown(cx)\n        }\n    };\n}\n\nimpl<T: ?Sized + AsyncWrite + Unpin> AsyncWrite for Box<T> {\n    deref_async_write!();\n}\n\nimpl<T: ?Sized + AsyncWrite + Unpin> AsyncWrite for &mut T {\n    deref_async_write!();\n}\n\nimpl<P> AsyncWrite for Pin<P>\nwhere\n    P: DerefMut + Unpin,\n    P::Target: AsyncWrite,\n{\n    fn poll_write(\n        self: Pin<&mut Self>,\n        cx: &mut Context<'_>,\n        buf: &[u8],\n    ) -> Poll<io::Result<usize>> {\n        self.get_mut().as_mut().poll_write(cx, buf)\n    }\n\n    fn poll_write_vectored(\n        self: Pin<&mut Self>,\n        cx: &mut Context<'_>,\n        bufs: &[IoSlice<'_>],\n    ) -> Poll<io::Result<usize>> {\n        self.get_mut().as_mut().poll_write_vectored(cx, bufs)\n    }\n\n    fn is_write_vectored(&self) -> bool {\n        (**self).is_write_vectored()\n    }\n\n    fn poll_flush(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<io::Result<()>> {\n        self.get_mut().as_mut().poll_flush(cx)\n    }\n\n    fn poll_shutdown(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<io::Result<()>> {\n        self.get_mut().as_mut().poll_shutdown(cx)\n    }\n}\n\nimpl AsyncWrite for Vec<u8> {\n    fn poll_write(\n        self: Pin<&mut Self>,\n        _cx: &mut Context<'_>,\n        buf: &[u8],\n    ) -> Poll<io::Result<usize>> {\n        self.get_mut().extend_from_slice(buf);\n        Poll::Ready(Ok(buf.len()))\n    }\n\n    fn poll_write_vectored(\n        mut self: Pin<&mut Self>,\n        _: &mut Context<'_>,\n        bufs: &[IoSlice<'_>],\n    ) -> Poll<io::Result<usize>> {\n        Poll::Ready(io::Write::write_vectored(&mut *self, bufs))\n    }\n\n    fn is_write_vectored(&self) -> bool {\n        true\n    }\n\n    fn poll_flush(self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<io::Result<()>> {\n        Poll::Ready(Ok(()))\n    }\n\n    fn poll_shutdown(self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<io::Result<()>> {\n        Poll::Ready(Ok(()))\n    }\n}\n\nimpl AsyncWrite for io::Cursor<&mut [u8]> {\n    fn poll_write(\n        mut self: Pin<&mut Self>,\n        _: &mut Context<'_>,\n        buf: &[u8],\n    ) -> Poll<io::Result<usize>> {\n        Poll::Ready(io::Write::write(&mut *self, buf))\n    }\n\n    fn poll_write_vectored(\n        mut self: Pin<&mut Self>,\n        _: &mut Context<'_>,\n        bufs: &[IoSlice<'_>],\n    ) -> Poll<io::Result<usize>> {\n        Poll::Ready(io::Write::write_vectored(&mut *self, bufs))\n    }\n\n    fn is_write_vectored(&self) -> bool {\n        true\n    }\n\n    fn poll_flush(mut self: Pin<&mut Self>, _: &mut Context<'_>) -> Poll<io::Result<()>> {\n        Poll::Ready(io::Write::flush(&mut *self))\n    }\n\n    fn poll_shutdown(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<io::Result<()>> {\n        self.poll_flush(cx)\n    }\n}\n\nimpl AsyncWrite for io::Cursor<&mut Vec<u8>> {\n    fn poll_write(\n        mut self: Pin<&mut Self>,\n        _: &mut Context<'_>,\n        buf: &[u8],\n    ) -> Poll<io::Result<usize>> {\n        Poll::Ready(io::Write::write(&mut *self, buf))\n    }\n\n    fn poll_write_vectored(\n        mut self: Pin<&mut Self>,\n        _: &mut Context<'_>,\n        bufs: &[IoSlice<'_>],\n    ) -> Poll<io::Result<usize>> {\n        Poll::Ready(io::Write::write_vectored(&mut *self, bufs))\n    }\n\n    fn is_write_vectored(&self) -> bool {\n        true\n    }\n\n    fn poll_flush(mut self: Pin<&mut Self>, _: &mut Context<'_>) -> Poll<io::Result<()>> {\n        Poll::Ready(io::Write::flush(&mut *self))\n    }\n\n    fn poll_shutdown(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<io::Result<()>> {\n        self.poll_flush(cx)\n    }\n}\n\nimpl AsyncWrite for io::Cursor<Vec<u8>> {\n    fn poll_write(\n        mut self: Pin<&mut Self>,\n        _: &mut Context<'_>,\n        buf: &[u8],\n    ) -> Poll<io::Result<usize>> {\n        Poll::Ready(io::Write::write(&mut *self, buf))\n    }\n\n    fn poll_write_vectored(\n        mut self: Pin<&mut Self>,\n        _: &mut Context<'_>,\n        bufs: &[IoSlice<'_>],\n    ) -> Poll<io::Result<usize>> {\n        Poll::Ready(io::Write::write_vectored(&mut *self, bufs))\n    }\n\n    fn is_write_vectored(&self) -> bool {\n        true\n    }\n\n    fn poll_flush(mut self: Pin<&mut Self>, _: &mut Context<'_>) -> Poll<io::Result<()>> {\n        Poll::Ready(io::Write::flush(&mut *self))\n    }\n\n    fn poll_shutdown(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<io::Result<()>> {\n        self.poll_flush(cx)\n    }\n}\n\nimpl AsyncWrite for io::Cursor<Box<[u8]>> {\n    fn poll_write(\n        mut self: Pin<&mut Self>,\n        _: &mut Context<'_>,\n        buf: &[u8],\n    ) -> Poll<io::Result<usize>> {\n        Poll::Ready(io::Write::write(&mut *self, buf))\n    }\n\n    fn poll_write_vectored(\n        mut self: Pin<&mut Self>,\n        _: &mut Context<'_>,\n        bufs: &[IoSlice<'_>],\n    ) -> Poll<io::Result<usize>> {\n        Poll::Ready(io::Write::write_vectored(&mut *self, bufs))\n    }\n\n    fn is_write_vectored(&self) -> bool {\n        true\n    }\n\n    fn poll_flush(mut self: Pin<&mut Self>, _: &mut Context<'_>) -> Poll<io::Result<()>> {\n        Poll::Ready(io::Write::flush(&mut *self))\n    }\n\n    fn poll_shutdown(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<io::Result<()>> {\n        self.poll_flush(cx)\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "8866128a559a5ad1594585eb6ae82c10f48504f9",
    "func": "use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(transparent)]\nstruct S {\n    a: u8,\n    b: u8,\n}\n\nfn main() {}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "dcfed03132fdbe7c803578c66113e0b35fa2e37c",
    "func": "use chrono::{DateTime, FixedOffset, NaiveDate, NaiveDateTime};\n\nuse postgres::{Client, NoTls, Row};\nuse rust_decimal::Decimal;\nuse sea_query::{ColumnDef, ColumnType, Iden, Order, PostgresQueryBuilder, Query, Table};\nuse sea_query_postgres::PostgresBinder;\nuse time::{\n    macros::{date, offset, time},\n    OffsetDateTime, PrimitiveDateTime,\n};\nuse uuid::Uuid;\n\nfn main() {\n    let mut client = Client::connect(\"postgresql://sea:sea@localhost/query\", NoTls).unwrap();\n\n    // Schema\n\n    let sql = [\n        Table::drop()\n            .table(Document::Table)\n            .if_exists()\n            .build(PostgresQueryBuilder),\n        Table::create()\n            .table(Document::Table)\n            .if_not_exists()\n            .col(\n                ColumnDef::new(Document::Id)\n                    .integer()\n                    .not_null()\n                    .auto_increment()\n                    .primary_key(),\n            )\n            .col(ColumnDef::new(Document::Uuid).uuid())\n            .col(ColumnDef::new(Document::JsonField).json_binary())\n            .col(ColumnDef::new(Document::Timestamp).timestamp())\n            .col(ColumnDef::new(Document::TimestampWithTimeZone).timestamp_with_time_zone())\n            .col(ColumnDef::new(Document::Decimal).decimal())\n            .col(ColumnDef::new(Document::Array).array(ColumnType::Integer))\n            .build(PostgresQueryBuilder),\n    ]\n    .join(\"; \");\n\n    println!(\"{sql}\");\n    let result = client.batch_execute(&sql);\n    println!(\"Create table document: {result:?}\\n\");\n\n    // Create\n    let document_chrono = DocumentStructChrono {\n        id: 1,\n        uuid: Uuid::new_v4(),\n        json_field: serde_json::json! {{\n            \"a\": 25.0,\n            \"b\": \"whatever\",\n            \"c\": {\n                \"another\": \"object\",\n                \"bla\": 1\n            }\n        }},\n        timestamp: NaiveDate::from_ymd_opt(2020, 1, 1)\n            .unwrap()\n            .and_hms_opt(2, 2, 2)\n            .unwrap(),\n        timestamp_with_time_zone: DateTime::parse_from_rfc3339(\"2020-01-01T02:02:02+08:00\")\n            .unwrap(),\n        decimal: Decimal::from_i128_with_scale(3141i128, 3),\n        array: vec![3, 4, 5, 6],\n    };\n    let document_time = DocumentStructTime {\n        id: 2,\n        uuid: Uuid::new_v4(),\n        json_field: serde_json::json! {{\n            \"a\": 25.0,\n            \"b\": \"whatever\",\n            \"c\": {\n                \"another\": \"object\",\n                \"bla\": 1\n            }\n        }},\n        timestamp: date!(2020 - 1 - 1).with_time(time!(2:2:2)),\n        timestamp_with_time_zone: date!(2020 - 01 - 01)\n            .with_time(time!(02:02:02))\n            .assume_utc()\n            .to_offset(offset!(+8)),\n        decimal: Decimal::from_i128_with_scale(3141i128, 3),\n        array: vec![3, 4, 5, 6],\n    };\n\n    let (sql, values) = Query::insert()\n        .into_table(Document::Table)\n        .columns([\n            Document::Uuid,\n            Document::JsonField,\n            Document::Timestamp,\n            Document::TimestampWithTimeZone,\n            Document::Decimal,\n            Document::Array,\n        ])\n        .values_panic([\n            document_chrono.uuid.into(),\n            serde_json::to_value(document_chrono.json_field)\n                .unwrap()\n                .into(),\n            document_chrono.timestamp.into(),\n            document_chrono.timestamp_with_time_zone.into(),\n            document_chrono.decimal.into(),\n            document_chrono.array.into(),\n        ])\n        .values_panic([\n            document_time.uuid.into(),\n            serde_json::to_value(document_time.json_field)\n                .unwrap()\n                .into(),\n            document_time.timestamp.into(),\n            document_time.timestamp_with_time_zone.into(),\n            document_time.decimal.into(),\n            document_time.array.into(),\n        ])\n        .build_postgres(PostgresQueryBuilder);\n\n    let result = client.execute(sql.as_str(), &values.as_params());\n    println!(\"Insert into document: {result:?}\\n\");\n\n    // Read\n\n    let (sql, values) = Query::select()\n        .columns([\n            Document::Id,\n            Document::Uuid,\n            Document::JsonField,\n            Document::Timestamp,\n            Document::TimestampWithTimeZone,\n            Document::Decimal,\n            Document::Array,\n        ])\n        .from(Document::Table)\n        .order_by(Document::Id, Order::Desc)\n        .limit(1)\n        .build_postgres(PostgresQueryBuilder);\n\n    let rows = client.query(sql.as_str(), &values.as_params()).unwrap();\n    println!(\"Select one from document:\");\n    for row in rows.iter() {\n        let item = DocumentStructChrono::from(row);\n        println!(\"{item:?}\");\n\n        let item = DocumentStructTime::from(row);\n        println!(\"{item:?}\");\n    }\n    println!();\n}\n\n#[derive(Iden)]\nenum Document {\n    Table,\n    Id,\n    Uuid,\n    JsonField,\n    Timestamp,\n    TimestampWithTimeZone,\n    Decimal,\n    Array,\n}\n\n#[derive(Debug)]\n#[allow(dead_code)]\nstruct DocumentStructChrono {\n    id: i32,\n    uuid: Uuid,\n    json_field: serde_json::Value,\n    timestamp: NaiveDateTime,\n    timestamp_with_time_zone: DateTime<FixedOffset>,\n    decimal: Decimal,\n    array: Vec<i32>,\n}\n\n#[derive(Debug)]\n#[allow(dead_code)]\nstruct DocumentStructTime {\n    id: i32,\n    uuid: Uuid,\n    json_field: serde_json::Value,\n    timestamp: PrimitiveDateTime,\n    timestamp_with_time_zone: OffsetDateTime,\n    decimal: Decimal,\n    array: Vec<i32>,\n}\n\nimpl From<&Row> for DocumentStructChrono {\n    fn from(row: &Row) -> Self {\n        Self {\n            id: row.get(\"id\"),\n            uuid: row.get(\"uuid\"),\n            json_field: row.get(\"json_field\"),\n            timestamp: row.get(\"timestamp\"),\n            timestamp_with_time_zone: row.get(\"timestamp_with_time_zone\"),\n            decimal: row.get(\"decimal\"),\n            array: row.get(\"array\"),\n        }\n    }\n}\nimpl From<&Row> for DocumentStructTime {\n    fn from(row: &Row) -> Self {\n        Self {\n            id: row.get(\"id\"),\n            uuid: row.get(\"uuid\"),\n            json_field: row.get(\"json_field\"),\n            timestamp: row.get(\"timestamp\"),\n            timestamp_with_time_zone: row.get(\"timestamp_with_time_zone\"),\n            decimal: row.get(\"decimal\"),\n            array: row.get(\"array\"),\n        }\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "3672f4d75658f56108f3f8f862ff8c762c2e5222",
    "func": "use sea_orm_migration::{prelude::*, schema::*};\n\n#[derive(DeriveMigrationName)]\npub struct Migration;\n\n#[async_trait::async_trait]\nimpl MigrationTrait for Migration {\n    async fn up(&self, manager: &SchemaManager) -> Result<(), DbErr> {\n        let table = table_auto(Users::Table)\n            .col(pk_auto(Users::Id))\n            .col(uuid(Users::Pid))\n            .col(string_uniq(Users::Email))\n            .col(string(Users::Password))\n            .col(string(Users::ApiKey).unique_key())\n            .col(string(Users::Name))\n            .col(string_null(Users::ResetToken))\n            .col(timestamp_null(Users::ResetSentAt))\n            .col(string_null(Users::EmailVerificationToken))\n            .col(timestamp_null(Users::EmailVerificationSentAt))\n            .col(timestamp_null(Users::EmailVerifiedAt))\n            .to_owned();\n        manager.create_table(table).await?;\n        Ok(())\n    }\n\n    async fn down(&self, manager: &SchemaManager) -> Result<(), DbErr> {\n        manager\n            .drop_table(Table::drop().table(Users::Table).to_owned())\n            .await\n    }\n}\n\n#[derive(Iden)]\npub enum Users {\n    Table,\n    Id,\n    Pid,\n    Email,\n    Name,\n    Password,\n    ApiKey,\n    ResetToken,\n    ResetSentAt,\n    EmailVerificationToken,\n    EmailVerificationSentAt,\n    EmailVerifiedAt,\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "d16fefe4e60e878e74694719445da93572bafd80",
    "func": "use super::*;\n\nimpl IndexBuilder for MysqlQueryBuilder {\n    fn prepare_table_index_expression(\n        &self,\n        create: &IndexCreateStatement,\n        sql: &mut dyn SqlWriter,\n    ) {\n        self.prepare_index_prefix(create, sql);\n        write!(sql, \"KEY \").unwrap();\n\n        if let Some(name) = &create.index.name {\n            write!(\n                sql,\n                \"{}{}{} \",\n                self.quote().left(),\n                name,\n                self.quote().right()\n            )\n            .unwrap();\n        }\n\n        self.prepare_index_type(&create.index_type, sql);\n        if matches!(create.index_type, Some(IndexType::FullText)) {\n            write!(sql, \" \").unwrap();\n        }\n\n        self.prepare_index_columns(&create.index.columns, sql);\n    }\n\n    fn prepare_index_create_statement(\n        &self,\n        create: &IndexCreateStatement,\n        sql: &mut dyn SqlWriter,\n    ) {\n        write!(sql, \"CREATE \").unwrap();\n        self.prepare_index_prefix(create, sql);\n        write!(sql, \"INDEX \").unwrap();\n\n        if let Some(name) = &create.index.name {\n            write!(\n                sql,\n                \"{}{}{}\",\n                self.quote().left(),\n                name,\n                self.quote().right()\n            )\n            .unwrap();\n        }\n\n        write!(sql, \" ON \").unwrap();\n        if let Some(table) = &create.table {\n            self.prepare_table_ref_index_stmt(table, sql);\n        }\n        write!(sql, \" \").unwrap();\n        self.prepare_index_columns(&create.index.columns, sql);\n\n        self.prepare_index_type(&create.index_type, sql);\n    }\n\n    fn prepare_table_ref_index_stmt(&self, table_ref: &TableRef, sql: &mut dyn SqlWriter) {\n        match table_ref {\n            TableRef::Table(_) => self.prepare_table_ref_iden(table_ref, sql),\n            _ => panic!(\"Not supported\"),\n        }\n    }\n    fn prepare_index_drop_statement(&self, drop: &IndexDropStatement, sql: &mut dyn SqlWriter) {\n        write!(sql, \"DROP INDEX \").unwrap();\n\n        if drop.if_exists {\n            panic!(\"Mysql does not support IF EXISTS for DROP INDEX\")\n        }\n\n        if let Some(name) = &drop.index.name {\n            write!(\n                sql,\n                \"{}{}{}\",\n                self.quote().left(),\n                name,\n                self.quote().right()\n            )\n            .unwrap();\n        }\n\n        write!(sql, \" ON \").unwrap();\n        if let Some(table) = &drop.table {\n            self.prepare_table_ref_index_stmt(table, sql);\n        }\n    }\n\n    fn prepare_index_type(&self, col_index_type: &Option<IndexType>, sql: &mut dyn SqlWriter) {\n        if let Some(index_type) = col_index_type {\n            if !matches!(index_type, IndexType::FullText) {\n                write!(\n                    sql,\n                    \" USING {}\",\n                    match index_type {\n                        IndexType::BTree => \"BTREE\".to_owned(),\n                        IndexType::FullText => unreachable!(),\n                        IndexType::Hash => \"HASH\".to_owned(),\n                        IndexType::Custom(custom) => custom.to_string(),\n                    }\n                )\n                .unwrap();\n            }\n        }\n    }\n\n    fn prepare_index_prefix(&self, create: &IndexCreateStatement, sql: &mut dyn SqlWriter) {\n        if create.primary {\n            write!(sql, \"PRIMARY \").unwrap();\n        }\n        if create.unique {\n            write!(sql, \"UNIQUE \").unwrap();\n        }\n        if matches!(create.index_type, Some(IndexType::FullText)) {\n            write!(sql, \"FULLTEXT \").unwrap();\n        }\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "9cccbd85da9ae3136638ccb779c5f9b59ef8083b",
    "func": "use proc_macro::TokenStream;\nuse quote::{format_ident, quote};\nuse syn::{parse_macro_input, spanned::Spanned, DeriveInput, Pat, Path, Result};\n\nuse crate::bevy_ecs_path;\n\npub fn derive_states(input: TokenStream) -> TokenStream {\n    let ast = parse_macro_input!(input as DeriveInput);\n\n    let generics = ast.generics;\n    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();\n\n    let mut base_trait_path = bevy_ecs_path();\n    base_trait_path\n        .segments\n        .push(format_ident!(\"schedule\").into());\n\n    let mut trait_path = base_trait_path.clone();\n    trait_path.segments.push(format_ident!(\"States\").into());\n\n    let mut state_mutation_trait_path = base_trait_path.clone();\n    state_mutation_trait_path\n        .segments\n        .push(format_ident!(\"FreelyMutableState\").into());\n\n    let struct_name = &ast.ident;\n\n    quote! {\n        impl #impl_generics #trait_path for #struct_name #ty_generics #where_clause {}\n\n        impl #impl_generics #state_mutation_trait_path for #struct_name #ty_generics #where_clause {\n        }\n    }\n    .into()\n}\n\nstruct Source {\n    source_type: Path,\n    source_value: Pat,\n}\n\nfn parse_sources_attr(ast: &DeriveInput) -> Result<Source> {\n    let mut result = ast\n        .attrs\n        .iter()\n        .filter(|a| a.path().is_ident(\"source\"))\n        .map(|meta| {\n            let mut source = None;\n            let value = meta.parse_nested_meta(|nested| {\n                let source_type = nested.path.clone();\n                let source_value = Pat::parse_multi(nested.value()?)?;\n                source = Some(Source {\n                    source_type,\n                    source_value,\n                });\n                Ok(())\n            });\n            match source {\n                Some(value) => Ok(value),\n                None => match value {\n                    Ok(_) => Err(syn::Error::new(\n                        ast.span(),\n                        \"Couldn't parse SubStates source\",\n                    )),\n                    Err(e) => Err(e),\n                },\n            }\n        })\n        .collect::<Result<Vec<_>>>()?;\n\n    if result.len() > 1 {\n        return Err(syn::Error::new(\n            ast.span(),\n            \"Only one source is allowed for SubStates\",\n        ));\n    }\n\n    let Some(result) = result.pop() else {\n        return Err(syn::Error::new(ast.span(), \"SubStates require a source\"));\n    };\n\n    Ok(result)\n}\n\npub fn derive_substates(input: TokenStream) -> TokenStream {\n    let ast = parse_macro_input!(input as DeriveInput);\n    let sources = parse_sources_attr(&ast).expect(\"Failed to parse substate sources\");\n\n    let generics = ast.generics;\n    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();\n\n    let mut base_trait_path = bevy_ecs_path();\n    base_trait_path\n        .segments\n        .push(format_ident!(\"schedule\").into());\n\n    let mut trait_path = base_trait_path.clone();\n    trait_path.segments.push(format_ident!(\"SubStates\").into());\n\n    let mut state_set_trait_path = base_trait_path.clone();\n    state_set_trait_path\n        .segments\n        .push(format_ident!(\"StateSet\").into());\n\n    let mut state_trait_path = base_trait_path.clone();\n    state_trait_path\n        .segments\n        .push(format_ident!(\"States\").into());\n\n    let mut state_mutation_trait_path = base_trait_path.clone();\n    state_mutation_trait_path\n        .segments\n        .push(format_ident!(\"FreelyMutableState\").into());\n\n    let struct_name = &ast.ident;\n\n    let source_state_type = sources.source_type;\n    let source_state_value = sources.source_value;\n\n    let result = quote! {\n        impl #impl_generics #trait_path for #struct_name #ty_generics #where_clause {\n            type SourceStates = #source_state_type;\n\n            fn should_exist(sources: #source_state_type) -> Option<Self> {\n                if matches!(sources, #source_state_value) {\n                    Some(Self::default())\n                } else {\n                    None\n                }\n            }\n        }\n\n        impl #impl_generics #state_trait_path for #struct_name #ty_generics #where_clause {\n            const DEPENDENCY_DEPTH : usize = <Self as #trait_path>::SourceStates::SET_DEPENDENCY_DEPTH + 1;\n        }\n\n        impl #impl_generics #state_mutation_trait_path for #struct_name #ty_generics #where_clause {\n        }\n    };\n\n    // panic!(\"Got Result\\n{}\", result.to_string());\n\n    result.into()\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "d73f3668abbc1a6e289884f11e6dda199f6895fd",
    "func": "use proc_macro2::{Span, TokenStream};\nuse quote::{quote, quote_spanned, ToTokens, TokenStreamExt};\nuse std::collections::HashMap;\nuse syn::{\n    parse::{Parse, ParseStream},\n    *,\n};\n\n/// A hot-reloadable formatted string, boolean, number or other literal\n///\n/// This wraps LitStr with some extra goodies like inline expressions and hot-reloading.\n/// Originally this was intended to provide named inline string interpolation but eventually Rust\n/// actually shipped this!\n#[derive(Debug, PartialEq, Eq, Clone, Hash)]\npub struct IfmtInput {\n    pub source: LitStr,\n    pub segments: Vec<Segment>,\n}\n\nimpl IfmtInput {\n    pub fn new(span: Span) -> Self {\n        Self {\n            source: LitStr::new(\"\", span),\n            segments: Vec::new(),\n        }\n    }\n\n    pub fn new_litstr(source: LitStr) -> Result<Self> {\n        let segments = IfmtInput::from_raw(&source.value())?;\n        Ok(Self { segments, source })\n    }\n\n    pub fn span(&self) -> Span {\n        self.source.span()\n    }\n\n    pub fn push_raw_str(&mut self, other: String) {\n        self.segments.push(Segment::Literal(other.to_string()))\n    }\n\n    pub fn push_ifmt(&mut self, other: IfmtInput) {\n        self.segments.extend(other.segments);\n    }\n\n    pub fn push_expr(&mut self, expr: Expr) {\n        self.segments.push(Segment::Formatted(FormattedSegment {\n            format_args: String::new(),\n            segment: FormattedSegmentType::Expr(Box::new(expr)),\n        }));\n    }\n\n    pub fn is_static(&self) -> bool {\n        self.segments\n            .iter()\n            .all(|seg| matches!(seg, Segment::Literal(_)))\n    }\n\n    pub fn to_static(&self) -> Option<String> {\n        self.segments\n            .iter()\n            .try_fold(String::new(), |acc, segment| {\n                if let Segment::Literal(seg) = segment {\n                    Some(acc + seg)\n                } else {\n                    None\n                }\n            })\n    }\n\n    pub fn dynamic_segments(&self) -> Vec<&FormattedSegment> {\n        self.segments\n            .iter()\n            .filter_map(|seg| match seg {\n                Segment::Formatted(seg) => Some(seg),\n                _ => None,\n            })\n            .collect::<Vec<_>>()\n    }\n\n    pub fn dynamic_seg_frequency_map(&self) -> HashMap<&FormattedSegment, usize> {\n        let mut map = HashMap::new();\n        for seg in self.dynamic_segments() {\n            *map.entry(seg).or_insert(0) += 1;\n        }\n        map\n    }\n\n    fn is_simple_expr(&self) -> bool {\n        self.segments.iter().all(|seg| match seg {\n            Segment::Literal(_) => true,\n            Segment::Formatted(FormattedSegment { segment, .. }) => {\n                matches!(segment, FormattedSegmentType::Ident(_))\n            }\n        })\n    }\n\n    /// Try to convert this into a single _.to_string() call if possible\n    ///\n    /// Using \"{single_expression}\" is pretty common, but you don't need to go through the whole format! machinery for that, so we optimize it here.\n    fn try_to_string(&self) -> Option<TokenStream> {\n        let mut single_dynamic = None;\n        for segment in &self.segments {\n            match segment {\n                Segment::Literal(literal) => {\n                    if !literal.is_empty() {\n                        return None;\n                    }\n                }\n                Segment::Formatted(FormattedSegment {\n                    segment,\n                    format_args,\n                }) => {\n                    if format_args.is_empty() {\n                        match single_dynamic {\n                            Some(current_string) => {\n                                single_dynamic =\n                                    Some(quote!(#current_string + &(#segment).to_string()));\n                            }\n                            None => {\n                                single_dynamic = Some(quote!((#segment).to_string()));\n                            }\n                        }\n                    } else {\n                        return None;\n                    }\n                }\n            }\n        }\n        single_dynamic\n    }\n\n    /// print the original source string - this handles escapes and stuff for us\n    pub fn to_string_with_quotes(&self) -> String {\n        self.source.to_token_stream().to_string()\n    }\n\n    /// Parse the source into segments\n    fn from_raw(input: &str) -> Result<Vec<Segment>> {\n        let mut chars = input.chars().peekable();\n        let mut segments = Vec::new();\n        let mut current_literal = String::new();\n        while let Some(c) = chars.next() {\n            if c == '{' {\n                if let Some(c) = chars.next_if(|c| *c == '{') {\n                    current_literal.push(c);\n                    continue;\n                }\n                if !current_literal.is_empty() {\n                    segments.push(Segment::Literal(current_literal));\n                }\n                current_literal = String::new();\n                let mut current_captured = String::new();\n                while let Some(c) = chars.next() {\n                    if c == ':' {\n                        // two :s in a row is a path, not a format arg\n                        if chars.next_if(|c| *c == ':').is_some() {\n                            current_captured.push_str(\"::\");\n                            continue;\n                        }\n                        let mut current_format_args = String::new();\n                        for c in chars.by_ref() {\n                            if c == '}' {\n                                segments.push(Segment::Formatted(FormattedSegment {\n                                    format_args: current_format_args,\n                                    segment: FormattedSegmentType::parse(&current_captured)?,\n                                }));\n                                break;\n                            }\n                            current_format_args.push(c);\n                        }\n                        break;\n                    }\n                    if c == '}' {\n                        segments.push(Segment::Formatted(FormattedSegment {\n                            format_args: String::new(),\n                            segment: FormattedSegmentType::parse(&current_captured)?,\n                        }));\n                        break;\n                    }\n                    current_captured.push(c);\n                }\n            } else {\n                if '}' == c {\n                    if let Some(c) = chars.next_if(|c| *c == '}') {\n                        current_literal.push(c);\n                        continue;\n                    } else {\n                        return Err(Error::new(\n                            Span::call_site(),\n                            \"unmatched closing '}' in format string\",\n                        ));\n                    }\n                }\n                current_literal.push(c);\n            }\n        }\n\n        if !current_literal.is_empty() {\n            segments.push(Segment::Literal(current_literal));\n        }\n\n        Ok(segments)\n    }\n}\n\nimpl ToTokens for IfmtInput {\n    fn to_tokens(&self, tokens: &mut TokenStream) {\n        // If the input is a string literal, we can just return it\n        if let Some(static_str) = self.to_static() {\n            return quote_spanned! { self.span() => #static_str }.to_tokens(tokens);\n        }\n\n        // Try to turn it into a single _.to_string() call\n        if !cfg!(debug_assertions) {\n            if let Some(single_dynamic) = self.try_to_string() {\n                tokens.extend(single_dynamic);\n                return;\n            }\n        }\n\n        // If the segments are not complex exprs, we can just use format! directly to take advantage of RA rename/expansion\n        if self.is_simple_expr() {\n            let raw = &self.source;\n            tokens.extend(quote! {\n                ::std::format!(#raw)\n            });\n            return;\n        }\n\n        // build format_literal\n        let mut format_literal = String::new();\n        let mut expr_counter = 0;\n        for segment in self.segments.iter() {\n            match segment {\n                Segment::Literal(s) => format_literal += &s.replace('{', \"{{\").replace('}', \"}}\"),\n                Segment::Formatted(FormattedSegment { format_args, .. }) => {\n                    format_literal += \"{\";\n                    format_literal += &expr_counter.to_string();\n                    expr_counter += 1;\n                    format_literal += \":\";\n                    format_literal += format_args;\n                    format_literal += \"}\";\n                }\n            }\n        }\n\n        let span = self.span();\n\n        let positional_args = self.segments.iter().filter_map(|seg| {\n            if let Segment::Formatted(FormattedSegment { segment, .. }) = seg {\n                let mut segment = segment.clone();\n                // We set the span of the ident here, so that we can use it in diagnostics\n                if let FormattedSegmentType::Ident(ident) = &mut segment {\n                    ident.set_span(span);\n                }\n                Some(segment)\n            } else {\n                None\n            }\n        });\n\n        quote_spanned! {\n            span =>\n            ::std::format!(\n                #format_literal\n                #(, #positional_args)*\n            )\n        }\n        .to_tokens(tokens)\n    }\n}\n\n#[derive(Debug, PartialEq, Eq, Clone, Hash)]\npub enum Segment {\n    Literal(String),\n    Formatted(FormattedSegment),\n}\n\nimpl Segment {\n    pub fn is_literal(&self) -> bool {\n        matches!(self, Segment::Literal(_))\n    }\n\n    pub fn is_formatted(&self) -> bool {\n        matches!(self, Segment::Formatted(_))\n    }\n}\n\n#[derive(Debug, PartialEq, Eq, Clone, Hash)]\npub struct FormattedSegment {\n    pub format_args: String,\n    pub segment: FormattedSegmentType,\n}\n\nimpl ToTokens for FormattedSegment {\n    fn to_tokens(&self, tokens: &mut TokenStream) {\n        let (fmt, seg) = (&self.format_args, &self.segment);\n        let fmt = format!(\"{{0:{fmt}}}\");\n        tokens.append_all(quote! {\n            format!(#fmt, #seg)\n        });\n    }\n}\n\n#[derive(Debug, PartialEq, Eq, Clone, Hash)]\npub enum FormattedSegmentType {\n    Expr(Box<Expr>),\n    Ident(Ident),\n}\n\nimpl FormattedSegmentType {\n    fn parse(input: &str) -> Result<Self> {\n        if let Ok(ident) = parse_str::<Ident>(input) {\n            if ident == input {\n                return Ok(Self::Ident(ident));\n            }\n        }\n        if let Ok(expr) = parse_str(input) {\n            Ok(Self::Expr(Box::new(expr)))\n        } else {\n            Err(Error::new(\n                Span::call_site(),\n                \"Expected Ident or Expression\",\n            ))\n        }\n    }\n}\n\nimpl ToTokens for FormattedSegmentType {\n    fn to_tokens(&self, tokens: &mut TokenStream) {\n        match self {\n            Self::Expr(expr) => expr.to_tokens(tokens),\n            Self::Ident(ident) => ident.to_tokens(tokens),\n        }\n    }\n}\n\nimpl Parse for IfmtInput {\n    fn parse(input: ParseStream) -> Result<Self> {\n        let source: LitStr = input.parse()?;\n        Self::new_litstr(source)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use prettier_please::PrettyUnparse;\n\n    #[test]\n    fn raw_tokens() {\n        let input = syn::parse2::<IfmtInput>(quote! { r#\"hello world\"# }).unwrap();\n        println!(\"{}\", input.to_token_stream().pretty_unparse());\n        assert_eq!(input.source.value(), \"hello world\");\n        assert_eq!(input.to_string_with_quotes(), \"r#\\\"hello world\\\"#\");\n    }\n\n    #[test]\n    fn segments_parse() {\n        let input: IfmtInput = parse_quote! { \"blah {abc} {def}\" };\n        assert_eq!(\n            input.segments,\n            vec![\n                Segment::Literal(\"blah \".to_string()),\n                Segment::Formatted(FormattedSegment {\n                    format_args: String::new(),\n                    segment: FormattedSegmentType::Ident(Ident::new(\"abc\", Span::call_site()))\n                }),\n                Segment::Literal(\" \".to_string()),\n                Segment::Formatted(FormattedSegment {\n                    format_args: String::new(),\n                    segment: FormattedSegmentType::Ident(Ident::new(\"def\", Span::call_site()))\n                }),\n            ]\n        );\n    }\n\n    #[test]\n    fn printing_raw() {\n        let input = syn::parse2::<IfmtInput>(quote! { \"hello {world}\" }).unwrap();\n        println!(\"{}\", input.to_string_with_quotes());\n\n        let input = syn::parse2::<IfmtInput>(quote! { \"hello {world} {world} {world}\" }).unwrap();\n        println!(\"{}\", input.to_string_with_quotes());\n\n        let input = syn::parse2::<IfmtInput>(quote! { \"hello {world} {world} {world()}\" }).unwrap();\n        println!(\"{}\", input.to_string_with_quotes());\n\n        let input =\n            syn::parse2::<IfmtInput>(quote! { r#\"hello {world} {world} {world()}\"# }).unwrap();\n        println!(\"{}\", input.to_string_with_quotes());\n        assert!(!input.is_static());\n\n        let input = syn::parse2::<IfmtInput>(quote! { r#\"hello\"# }).unwrap();\n        println!(\"{}\", input.to_string_with_quotes());\n        assert!(input.is_static());\n    }\n\n    #[test]\n    fn to_static() {\n        let input = syn::parse2::<IfmtInput>(quote! { \"body {{ background: red; }}\" }).unwrap();\n        assert_eq!(\n            input.to_static(),\n            Some(\"body { background: red; }\".to_string())\n        );\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "8ec824c0903f4ab0c52ea5d8898abc8331a66e9a",
    "func": "// Copyright 2019-2024 Tauri Programme within The Commons Conservancy\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n\n// taken from https://github.com/oxc-project/oxc/blob/main/crates/oxc_linter/src/partial_loader/mod.rs\n\nmod svelte;\nmod vue;\n\nuse oxc_span::SourceType;\n\npub use self::{svelte::SveltePartialLoader, vue::VuePartialLoader};\n\nconst SCRIPT_START: &str = \"<script\";\nconst SCRIPT_END: &str = \"</script>\";\n\n#[derive(Debug, Clone, Copy)]\npub struct JavaScriptSource<'a> {\n  pub source_text: &'a str,\n  pub source_type: SourceType,\n  /// The javascript source could be embedded in some file,\n  /// use `start` to record start offset of js block in the original file.\n  pub start: usize,\n}\n\nimpl<'a> JavaScriptSource<'a> {\n  pub fn new(source_text: &'a str, source_type: SourceType, start: usize) -> Self {\n    Self {\n      source_text,\n      source_type,\n      start,\n    }\n  }\n}\n\npub struct PartialLoader;\n\nimpl PartialLoader {\n  /// Extract js section of specifial files.\n  /// Returns `None` if the specifial file does not have a js section.\n  pub fn parse<'a>(ext: &str, source_text: &'a str) -> Option<Vec<JavaScriptSource<'a>>> {\n    match ext {\n      \"vue\" => Some(VuePartialLoader::new(source_text).parse()),\n      \"svelte\" => Some(SveltePartialLoader::new(source_text).parse()),\n      _ => None,\n    }\n  }\n}\n\n/// Find closing angle for situations where there is another `>` in between.\n/// e.g. `<script generic=\"T extends Record<string, string>\">`\nfn find_script_closing_angle(source_text: &str, pointer: usize) -> Option<usize> {\n  let mut numbers_of_open_angle = 0;\n  for (offset, c) in source_text[pointer..].char_indices() {\n    match c {\n      '>' => {\n        if numbers_of_open_angle == 0 {\n          return Some(offset);\n        }\n        numbers_of_open_angle -= 1;\n      }\n      '<' => {\n        numbers_of_open_angle += 1;\n      }\n      _ => {}\n    }\n  }\n  None\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "1ae5fed9c9f9da5c70cb44ced473cb839b99d34b",
    "func": "//! Reflection-based dynamic functions.\n//!\n//! This module provides a way to pass around and call functions dynamically\n//! using the [`DynamicFunction`] and [`DynamicFunctionMut`] types.\n//!\n//! Many simple functions and closures can be automatically converted to these types\n//! using the [`IntoFunction`] and [`IntoFunctionMut`] traits, respectively.\n//!\n//! Once this dynamic representation is created, it can be called with a set of arguments provided\n//! via an [`ArgList`].\n//!\n//! This returns a [`FunctionResult`] containing the [`Return`] value,\n//! which can be used to extract a [`PartialReflect`] trait object.\n//!\n//! # Example\n//!\n//! ```\n//! # use bevy_reflect::PartialReflect;\n//! # use bevy_reflect::func::args::ArgList;\n//! # use bevy_reflect::func::{DynamicFunction, FunctionResult, IntoFunction, Return};\n//! fn add(a: i32, b: i32) -> i32 {\n//!   a + b\n//! }\n//!\n//! let mut func: DynamicFunction = add.into_function();\n//! let args: ArgList = ArgList::default()\n//!   // Pushing a known type with owned ownership\n//!   .push_owned(25_i32)\n//!   // Pushing a reflected type with owned ownership\n//!   .push_boxed(Box::new(75_i32) as Box<dyn PartialReflect>);\n//! let result: FunctionResult = func.call(args);\n//! let value: Return = result.unwrap();\n//! assert_eq!(value.unwrap_owned().try_downcast_ref::<i32>(), Some(&100));\n//! ```\n//!\n//! # Types of Functions\n//!\n//! For simplicity, this module uses the umbrella term \"function\" to refer to any Rust callable:\n//! code that can be invoked with a set of arguments to perform some action.\n//!\n//! In Rust, there are two main categories of callables: functions and closures.\n//!\n//! A \"function\" is a callable that does not capture its environment.\n//! These are typically defined with the `fn` keyword, which are referred to as _named_ functions.\n//! But they are also _anonymous_ functions, which are unnamed and defined with anonymous function syntax.\n//!\n//! ```rust\n//! // This is a named function:\n//! fn add(a: i32, b: i32) -> i32 {\n//!   a + b\n//! }\n//!\n//! // This is an anonymous function:\n//! let add = |a: i32, b: i32| a + b;\n//! ```\n//!\n//! Closures, on the other hand, are special functions that do capture their environment.\n//! These are always defined with anonymous function syntax.\n//!\n//! ```\n//! // A closure that captures an immutable reference to a variable\n//! let c = 123;\n//! let add = |a: i32, b: i32| a + b + c;\n//!\n//! // A closure that captures a mutable reference to a variable\n//! let mut total = 0;\n//! let add = |a: i32, b: i32| total += a + b;\n//!\n//! // A closure that takes ownership of its captured variables by moving them\n//! let c = 123;\n//! let add = move |a: i32, b: i32| a + b + c;\n//! ```\n//!\n//! # Valid Signatures\n//!\n//! Many of the traits in this module have default blanket implementations over a specific set of function signatures.\n//!\n//! These signatures are:\n//! - `(...) -> R`\n//! - `for<'a> (&'a arg, ...) -> &'a R`\n//! - `for<'a> (&'a mut arg, ...) -> &'a R`\n//! - `for<'a> (&'a mut arg, ...) -> &'a mut R`\n//!\n//! Where `...` represents 0 to 15 arguments (inclusive) of the form `T`, `&T`, or `&mut T`.\n//! The lifetime of any reference to the return type `R`, must be tied to a \"receiver\" argument\n//! (i.e. the first argument in the signature, normally `self`).\n//!\n//! Each trait will also have its own requirements for what traits are required for both arguments and return types,\n//! but a good rule-of-thumb is that all types should derive [`Reflect`].\n//!\n//! The reason for such a small subset of valid signatures is due to limitations in Rust\u2014\n//! namely the [lack of variadic generics] and certain [coherence issues].\n//!\n//! For other functions that don't conform to one of the above signatures,\n//! [`DynamicFunction`] and [`DynamicFunctionMut`] can instead be created manually.\n//!\n//! # Function Registration\n//!\n//! This module also provides a [`FunctionRegistry`] that can be used to register functions and closures\n//! by name so that they may be retrieved and called dynamically.\n//!\n//! ```\n//! # use bevy_reflect::func::{ArgList, FunctionRegistry};\n//! fn add(a: i32, b: i32) -> i32 {\n//!     a + b\n//! }\n//!\n//! let mut registry = FunctionRegistry::default();\n//!\n//! // You can register functions and methods by their `core::any::type_name`:\n//! registry.register(add).unwrap();\n//!\n//! // Or you can register them by a custom name:\n//! registry.register_with_name(\"mul\", |a: i32, b: i32| a * b).unwrap();\n//!\n//! // You can then retrieve and call these functions by name:\n//! let reflect_add = registry.get(core::any::type_name_of_val(&add)).unwrap();\n//! let value = reflect_add.call(ArgList::default().push_owned(10_i32).push_owned(5_i32)).unwrap();\n//! assert_eq!(value.unwrap_owned().try_downcast_ref::<i32>(), Some(&15));\n//!\n//! let reflect_mul = registry.get(\"mul\").unwrap();\n//! let value = reflect_mul.call(ArgList::default().push_owned(10_i32).push_owned(5_i32)).unwrap();\n//! assert_eq!(value.unwrap_owned().try_downcast_ref::<i32>(), Some(&50));\n//! ```\n//!\n//! [`PartialReflect`]: crate::PartialReflect\n//! [`Reflect`]: crate::Reflect\n//! [lack of variadic generics]: https://poignardazur.github.io/2024/05/25/report-on-rustnl-variadics/\n//! [coherence issues]: https://doc.rust-lang.org/rustc/lints/listing/warn-by-default.html#coherence-leak-check\n\npub use args::{ArgError, ArgList, ArgValue};\npub use dynamic_function::*;\npub use dynamic_function_mut::*;\npub use error::*;\npub use function::*;\npub use info::*;\npub use into_function::*;\npub use into_function_mut::*;\npub use reflect_fn::*;\npub use reflect_fn_mut::*;\npub use registry::*;\npub use return_type::*;\n\npub mod args;\nmod dynamic_function;\nmod dynamic_function_mut;\nmod error;\nmod function;\nmod info;\nmod into_function;\nmod into_function_mut;\npub(crate) mod macros;\nmod reflect_fn;\nmod reflect_fn_mut;\nmod registry;\nmod return_type;\n\n#[cfg(test)]\nmod tests {\n    use alloc::borrow::Cow;\n\n    use crate::{\n        func::args::{ArgError, ArgList, Ownership},\n        TypePath,\n    };\n\n    use super::*;\n\n    #[test]\n    fn should_error_on_missing_args() {\n        fn foo(_: i32) {}\n\n        let func = foo.into_function();\n        let args = ArgList::new();\n        let result = func.call(args);\n        assert_eq!(\n            result.unwrap_err(),\n            FunctionError::ArgCountMismatch {\n                expected: 1,\n                received: 0\n            }\n        );\n    }\n\n    #[test]\n    fn should_error_on_too_many_args() {\n        fn foo() {}\n\n        let func = foo.into_function();\n        let args = ArgList::new().push_owned(123_i32);\n        let result = func.call(args);\n        assert_eq!(\n            result.unwrap_err(),\n            FunctionError::ArgCountMismatch {\n                expected: 0,\n                received: 1\n            }\n        );\n    }\n\n    #[test]\n    fn should_error_on_invalid_arg_type() {\n        fn foo(_: i32) {}\n\n        let func = foo.into_function();\n        let args = ArgList::new().push_owned(123_u32);\n        let result = func.call(args);\n        assert_eq!(\n            result.unwrap_err(),\n            FunctionError::ArgError(ArgError::UnexpectedType {\n                index: 0,\n                expected: Cow::Borrowed(i32::type_path()),\n                received: Cow::Borrowed(u32::type_path())\n            })\n        );\n    }\n\n    #[test]\n    fn should_error_on_invalid_arg_ownership() {\n        fn foo(_: &i32) {}\n\n        let func = foo.into_function();\n        let args = ArgList::new().push_owned(123_i32);\n        let result = func.call(args);\n        assert_eq!(\n            result.unwrap_err(),\n            FunctionError::ArgError(ArgError::InvalidOwnership {\n                index: 0,\n                expected: Ownership::Ref,\n                received: Ownership::Owned\n            })\n        );\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "ea8df73810733beea3ed36352241836716bd916d",
    "func": "use sea_query_attr::enum_def;\n\n#[enum_def(prefix = \"\", suffix = \"Def\")]\npub struct Hello {\n    pub name: String\n}\n\nfn main() {\n    println!(\"{:?}\", HelloDef::Name);\n}"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "e3f63fc5b1a2f21c451865588d6bb65c40998c23",
    "func": "//! Named colors from the CSS1 specification, also known as\n//! [basic colors](https://en.wikipedia.org/wiki/Web_colors#Basic_colors).\n//! This is the same set of colors used in the\n//! [VGA graphics standard](https://en.wikipedia.org/wiki/Video_Graphics_Array).\n\nuse crate::Srgba;\n\n/// <div style=\"background-color: #00FFFF; width: 10px; padding: 10px; border: 1px solid;\"></div>\npub const AQUA: Srgba = Srgba::rgb(0.0, 1.0, 1.0);\n/// <div style=\"background-color: #000000; width: 10px; padding: 10px; border: 1px solid;\"></div>\npub const BLACK: Srgba = Srgba::rgb(0.0, 0.0, 0.0);\n/// <div style=\"background-color: #0000FF; width: 10px; padding: 10px; border: 1px solid;\"></div>\npub const BLUE: Srgba = Srgba::rgb(0.0, 0.0, 1.0);\n/// <div style=\"background-color: #FF00FF; width: 10px; padding: 10px; border: 1px solid;\"></div>\npub const FUCHSIA: Srgba = Srgba::rgb(1.0, 0.0, 1.0);\n/// <div style=\"background-color: #808080; width: 10px; padding: 10px; border: 1px solid;\"></div>\npub const GRAY: Srgba = Srgba::rgb(0.5019608, 0.5019608, 0.5019608);\n/// <div style=\"background-color: #008000; width: 10px; padding: 10px; border: 1px solid;\"></div>\npub const GREEN: Srgba = Srgba::rgb(0.0, 0.5019608, 0.0);\n/// <div style=\"background-color: #00FF00; width: 10px; padding: 10px; border: 1px solid;\"></div>\npub const LIME: Srgba = Srgba::rgb(0.0, 1.0, 0.0);\n/// <div style=\"background-color: #800000; width: 10px; padding: 10px; border: 1px solid;\"></div>\npub const MAROON: Srgba = Srgba::rgb(0.5019608, 0.0, 0.0);\n/// <div style=\"background-color: #000080; width: 10px; padding: 10px; border: 1px solid;\"></div>\npub const NAVY: Srgba = Srgba::rgb(0.0, 0.0, 0.5019608);\n/// <div style=\"background-color: #808000; width: 10px; padding: 10px; border: 1px solid;\"></div>\npub const OLIVE: Srgba = Srgba::rgb(0.5019608, 0.5019608, 0.0);\n/// <div style=\"background-color: #800080; width: 10px; padding: 10px; border: 1px solid;\"></div>\npub const PURPLE: Srgba = Srgba::rgb(0.5019608, 0.0, 0.5019608);\n/// <div style=\"background-color: #FF0000; width: 10px; padding: 10px; border: 1px solid;\"></div>\npub const RED: Srgba = Srgba::rgb(1.0, 0.0, 0.0);\n/// <div style=\"background-color: #C0C0C0; width: 10px; padding: 10px; border: 1px solid;\"></div>\npub const SILVER: Srgba = Srgba::rgb(0.7529412, 0.7529412, 0.7529412);\n/// <div style=\"background-color: #008080; width: 10px; padding: 10px; border: 1px solid;\"></div>\npub const TEAL: Srgba = Srgba::rgb(0.0, 0.5019608, 0.5019608);\n/// <div style=\"background-color: #FFFFFF; width: 10px; padding: 10px; border: 1px solid;\"></div>\npub const WHITE: Srgba = Srgba::rgb(1.0, 1.0, 1.0);\n/// <div style=\"background-color: #FFFF00; width: 10px; padding: 10px; border: 1px solid;\"></div>\npub const YELLOW: Srgba = Srgba::rgb(1.0, 1.0, 0.0);\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "eadc10e8ba3fc20300de98aa2c2d732ba26b4631",
    "func": "#![allow(clippy::needless_lifetimes)]\n\nmod regression {\n    automod::dir!(\"tests/regression\");\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "3d3148b199dc4566c9b1fb887aaeb5c0b1414a84",
    "func": "use super::Value;\nuse alloc::string::String;\n\nfn eq_i64(value: &Value, other: i64) -> bool {\n    value.as_i64().map_or(false, |i| i == other)\n}\n\nfn eq_u64(value: &Value, other: u64) -> bool {\n    value.as_u64().map_or(false, |i| i == other)\n}\n\nfn eq_f32(value: &Value, other: f32) -> bool {\n    match value {\n        Value::Number(n) => n.as_f32().map_or(false, |i| i == other),\n        _ => false,\n    }\n}\n\nfn eq_f64(value: &Value, other: f64) -> bool {\n    value.as_f64().map_or(false, |i| i == other)\n}\n\nfn eq_bool(value: &Value, other: bool) -> bool {\n    value.as_bool().map_or(false, |i| i == other)\n}\n\nfn eq_str(value: &Value, other: &str) -> bool {\n    value.as_str().map_or(false, |i| i == other)\n}\n\nimpl PartialEq<str> for Value {\n    fn eq(&self, other: &str) -> bool {\n        eq_str(self, other)\n    }\n}\n\nimpl PartialEq<&str> for Value {\n    fn eq(&self, other: &&str) -> bool {\n        eq_str(self, *other)\n    }\n}\n\nimpl PartialEq<Value> for str {\n    fn eq(&self, other: &Value) -> bool {\n        eq_str(other, self)\n    }\n}\n\nimpl PartialEq<Value> for &str {\n    fn eq(&self, other: &Value) -> bool {\n        eq_str(other, *self)\n    }\n}\n\nimpl PartialEq<String> for Value {\n    fn eq(&self, other: &String) -> bool {\n        eq_str(self, other.as_str())\n    }\n}\n\nimpl PartialEq<Value> for String {\n    fn eq(&self, other: &Value) -> bool {\n        eq_str(other, self.as_str())\n    }\n}\n\nmacro_rules! partialeq_numeric {\n    ($($eq:ident [$($ty:ty)*])*) => {\n        $($(\n            impl PartialEq<$ty> for Value {\n                fn eq(&self, other: &$ty) -> bool {\n                    $eq(self, *other as _)\n                }\n            }\n\n            impl PartialEq<Value> for $ty {\n                fn eq(&self, other: &Value) -> bool {\n                    $eq(other, *self as _)\n                }\n            }\n\n            impl<'a> PartialEq<$ty> for &'a Value {\n                fn eq(&self, other: &$ty) -> bool {\n                    $eq(*self, *other as _)\n                }\n            }\n\n            impl<'a> PartialEq<$ty> for &'a mut Value {\n                fn eq(&self, other: &$ty) -> bool {\n                    $eq(*self, *other as _)\n                }\n            }\n        )*)*\n    }\n}\n\npartialeq_numeric! {\n    eq_i64[i8 i16 i32 i64 isize]\n    eq_u64[u8 u16 u32 u64 usize]\n    eq_f32[f32]\n    eq_f64[f64]\n    eq_bool[bool]\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "455f4ecc6879f22aebe8b090f5cc0b9d3236cdd2",
    "func": "use crate::{\n    config::{GizmoLineJoint, GizmoLineStyle, GizmoMeshConfig},\n    line_gizmo_vertex_buffer_layouts, line_joint_gizmo_vertex_buffer_layouts, DrawLineGizmo,\n    DrawLineJointGizmo, GizmoRenderSystem, GpuLineGizmo, LineGizmoUniformBindgroupLayout,\n    SetLineGizmoBindGroup, LINE_JOINT_SHADER_HANDLE, LINE_SHADER_HANDLE,\n};\nuse bevy_app::{App, Plugin};\nuse bevy_core_pipeline::{\n    core_3d::{Transparent3d, CORE_3D_DEPTH_FORMAT},\n    prepass::{DeferredPrepass, DepthPrepass, MotionVectorPrepass, NormalPrepass},\n};\n\nuse bevy_ecs::{\n    prelude::Entity,\n    query::Has,\n    schedule::{IntoSystemConfigs, IntoSystemSetConfigs},\n    system::{Query, Res, ResMut, Resource},\n    world::{FromWorld, World},\n};\nuse bevy_pbr::{MeshPipeline, MeshPipelineKey, SetMeshViewBindGroup};\nuse bevy_render::sync_world::MainEntity;\nuse bevy_render::{\n    render_asset::{prepare_assets, RenderAssets},\n    render_phase::{\n        AddRenderCommand, DrawFunctions, PhaseItemExtraIndex, SetItemPipeline,\n        ViewSortedRenderPhases,\n    },\n    render_resource::*,\n    texture::BevyDefault,\n    view::{ExtractedView, Msaa, RenderLayers, ViewTarget},\n    Render, RenderApp, RenderSet,\n};\nuse bevy_utils::tracing::error;\n\npub struct LineGizmo3dPlugin;\nimpl Plugin for LineGizmo3dPlugin {\n    fn build(&self, app: &mut App) {\n        let Some(render_app) = app.get_sub_app_mut(RenderApp) else {\n            return;\n        };\n\n        render_app\n            .add_render_command::<Transparent3d, DrawLineGizmo3d>()\n            .add_render_command::<Transparent3d, DrawLineJointGizmo3d>()\n            .init_resource::<SpecializedRenderPipelines<LineGizmoPipeline>>()\n            .init_resource::<SpecializedRenderPipelines<LineJointGizmoPipeline>>()\n            .configure_sets(\n                Render,\n                GizmoRenderSystem::QueueLineGizmos3d\n                    .in_set(RenderSet::Queue)\n                    .ambiguous_with(bevy_pbr::queue_material_meshes::<bevy_pbr::StandardMaterial>),\n            )\n            .add_systems(\n                Render,\n                (queue_line_gizmos_3d, queue_line_joint_gizmos_3d)\n                    .in_set(GizmoRenderSystem::QueueLineGizmos3d)\n                    .after(prepare_assets::<GpuLineGizmo>),\n            );\n    }\n\n    fn finish(&self, app: &mut App) {\n        let Some(render_app) = app.get_sub_app_mut(RenderApp) else {\n            return;\n        };\n\n        render_app.init_resource::<LineGizmoPipeline>();\n        render_app.init_resource::<LineJointGizmoPipeline>();\n    }\n}\n\n#[derive(Clone, Resource)]\nstruct LineGizmoPipeline {\n    mesh_pipeline: MeshPipeline,\n    uniform_layout: BindGroupLayout,\n}\n\nimpl FromWorld for LineGizmoPipeline {\n    fn from_world(render_world: &mut World) -> Self {\n        LineGizmoPipeline {\n            mesh_pipeline: render_world.resource::<MeshPipeline>().clone(),\n            uniform_layout: render_world\n                .resource::<LineGizmoUniformBindgroupLayout>()\n                .layout\n                .clone(),\n        }\n    }\n}\n\n#[derive(PartialEq, Eq, Hash, Clone)]\nstruct LineGizmoPipelineKey {\n    view_key: MeshPipelineKey,\n    strip: bool,\n    perspective: bool,\n    line_style: GizmoLineStyle,\n}\n\nimpl SpecializedRenderPipeline for LineGizmoPipeline {\n    type Key = LineGizmoPipelineKey;\n\n    fn specialize(&self, key: Self::Key) -> RenderPipelineDescriptor {\n        let mut shader_defs = vec![\n            #[cfg(feature = \"webgl\")]\n            \"SIXTEEN_BYTE_ALIGNMENT\".into(),\n        ];\n\n        if key.perspective {\n            shader_defs.push(\"PERSPECTIVE\".into());\n        }\n\n        let format = if key.view_key.contains(MeshPipelineKey::HDR) {\n            ViewTarget::TEXTURE_FORMAT_HDR\n        } else {\n            TextureFormat::bevy_default()\n        };\n\n        let view_layout = self\n            .mesh_pipeline\n            .get_view_layout(key.view_key.into())\n            .clone();\n\n        let layout = vec![view_layout, self.uniform_layout.clone()];\n\n        let fragment_entry_point = match key.line_style {\n            GizmoLineStyle::Solid => \"fragment_solid\",\n            GizmoLineStyle::Dotted => \"fragment_dotted\",\n        };\n\n        RenderPipelineDescriptor {\n            vertex: VertexState {\n                shader: LINE_SHADER_HANDLE,\n                entry_point: \"vertex\".into(),\n                shader_defs: shader_defs.clone(),\n                buffers: line_gizmo_vertex_buffer_layouts(key.strip),\n            },\n            fragment: Some(FragmentState {\n                shader: LINE_SHADER_HANDLE,\n                shader_defs,\n                entry_point: fragment_entry_point.into(),\n                targets: vec![Some(ColorTargetState {\n                    format,\n                    blend: Some(BlendState::ALPHA_BLENDING),\n                    write_mask: ColorWrites::ALL,\n                })],\n            }),\n            layout,\n            primitive: PrimitiveState::default(),\n            depth_stencil: Some(DepthStencilState {\n                format: CORE_3D_DEPTH_FORMAT,\n                depth_write_enabled: true,\n                depth_compare: CompareFunction::Greater,\n                stencil: StencilState::default(),\n                bias: DepthBiasState::default(),\n            }),\n            multisample: MultisampleState {\n                count: key.view_key.msaa_samples(),\n                mask: !0,\n                alpha_to_coverage_enabled: false,\n            },\n            label: Some(\"LineGizmo Pipeline\".into()),\n            push_constant_ranges: vec![],\n        }\n    }\n}\n\n#[derive(Clone, Resource)]\nstruct LineJointGizmoPipeline {\n    mesh_pipeline: MeshPipeline,\n    uniform_layout: BindGroupLayout,\n}\n\nimpl FromWorld for LineJointGizmoPipeline {\n    fn from_world(render_world: &mut World) -> Self {\n        LineJointGizmoPipeline {\n            mesh_pipeline: render_world.resource::<MeshPipeline>().clone(),\n            uniform_layout: render_world\n                .resource::<LineGizmoUniformBindgroupLayout>()\n                .layout\n                .clone(),\n        }\n    }\n}\n\n#[derive(PartialEq, Eq, Hash, Clone)]\nstruct LineJointGizmoPipelineKey {\n    view_key: MeshPipelineKey,\n    perspective: bool,\n    joints: GizmoLineJoint,\n}\n\nimpl SpecializedRenderPipeline for LineJointGizmoPipeline {\n    type Key = LineJointGizmoPipelineKey;\n\n    fn specialize(&self, key: Self::Key) -> RenderPipelineDescriptor {\n        let mut shader_defs = vec![\n            #[cfg(feature = \"webgl\")]\n            \"SIXTEEN_BYTE_ALIGNMENT\".into(),\n        ];\n\n        if key.perspective {\n            shader_defs.push(\"PERSPECTIVE\".into());\n        }\n\n        let format = if key.view_key.contains(MeshPipelineKey::HDR) {\n            ViewTarget::TEXTURE_FORMAT_HDR\n        } else {\n            TextureFormat::bevy_default()\n        };\n\n        let view_layout = self\n            .mesh_pipeline\n            .get_view_layout(key.view_key.into())\n            .clone();\n\n        let layout = vec![view_layout, self.uniform_layout.clone()];\n\n        if key.joints == GizmoLineJoint::None {\n            error!(\"There is no entry point for line joints with GizmoLineJoints::None. Please consider aborting the drawing process before reaching this stage.\");\n        };\n\n        let entry_point = match key.joints {\n            GizmoLineJoint::Miter => \"vertex_miter\",\n            GizmoLineJoint::Round(_) => \"vertex_round\",\n            GizmoLineJoint::None | GizmoLineJoint::Bevel => \"vertex_bevel\",\n        };\n\n        RenderPipelineDescriptor {\n            vertex: VertexState {\n                shader: LINE_JOINT_SHADER_HANDLE,\n                entry_point: entry_point.into(),\n                shader_defs: shader_defs.clone(),\n                buffers: line_joint_gizmo_vertex_buffer_layouts(),\n            },\n            fragment: Some(FragmentState {\n                shader: LINE_JOINT_SHADER_HANDLE,\n                shader_defs,\n                entry_point: \"fragment\".into(),\n                targets: vec![Some(ColorTargetState {\n                    format,\n                    blend: Some(BlendState::ALPHA_BLENDING),\n                    write_mask: ColorWrites::ALL,\n                })],\n            }),\n            layout,\n            primitive: PrimitiveState::default(),\n            depth_stencil: Some(DepthStencilState {\n                format: CORE_3D_DEPTH_FORMAT,\n                depth_write_enabled: true,\n                depth_compare: CompareFunction::Greater,\n                stencil: StencilState::default(),\n                bias: DepthBiasState::default(),\n            }),\n            multisample: MultisampleState {\n                count: key.view_key.msaa_samples(),\n                mask: !0,\n                alpha_to_coverage_enabled: false,\n            },\n            label: Some(\"LineJointGizmo Pipeline\".into()),\n            push_constant_ranges: vec![],\n        }\n    }\n}\n\ntype DrawLineGizmo3d = (\n    SetItemPipeline,\n    SetMeshViewBindGroup<0>,\n    SetLineGizmoBindGroup<1>,\n    DrawLineGizmo,\n);\ntype DrawLineJointGizmo3d = (\n    SetItemPipeline,\n    SetMeshViewBindGroup<0>,\n    SetLineGizmoBindGroup<1>,\n    DrawLineJointGizmo,\n);\n\n#[allow(clippy::too_many_arguments)]\nfn queue_line_gizmos_3d(\n    draw_functions: Res<DrawFunctions<Transparent3d>>,\n    pipeline: Res<LineGizmoPipeline>,\n    mut pipelines: ResMut<SpecializedRenderPipelines<LineGizmoPipeline>>,\n    pipeline_cache: Res<PipelineCache>,\n    line_gizmos: Query<(Entity, &MainEntity, &GizmoMeshConfig)>,\n    line_gizmo_assets: Res<RenderAssets<GpuLineGizmo>>,\n    mut transparent_render_phases: ResMut<ViewSortedRenderPhases<Transparent3d>>,\n    mut views: Query<(\n        Entity,\n        &ExtractedView,\n        &Msaa,\n        Option<&RenderLayers>,\n        (\n            Has<NormalPrepass>,\n            Has<DepthPrepass>,\n            Has<MotionVectorPrepass>,\n            Has<DeferredPrepass>,\n        ),\n    )>,\n) {\n    let draw_function = draw_functions.read().get_id::<DrawLineGizmo3d>().unwrap();\n\n    for (\n        view_entity,\n        view,\n        msaa,\n        render_layers,\n        (normal_prepass, depth_prepass, motion_vector_prepass, deferred_prepass),\n    ) in &mut views\n    {\n        let Some(transparent_phase) = transparent_render_phases.get_mut(&view_entity) else {\n            continue;\n        };\n\n        let render_layers = render_layers.unwrap_or_default();\n\n        let mut view_key = MeshPipelineKey::from_msaa_samples(msaa.samples())\n            | MeshPipelineKey::from_hdr(view.hdr);\n\n        if normal_prepass {\n            view_key |= MeshPipelineKey::NORMAL_PREPASS;\n        }\n\n        if depth_prepass {\n            view_key |= MeshPipelineKey::DEPTH_PREPASS;\n        }\n\n        if motion_vector_prepass {\n            view_key |= MeshPipelineKey::MOTION_VECTOR_PREPASS;\n        }\n\n        if deferred_prepass {\n            view_key |= MeshPipelineKey::DEFERRED_PREPASS;\n        }\n\n        for (entity, main_entity, config) in &line_gizmos {\n            if !config.render_layers.intersects(render_layers) {\n                continue;\n            }\n\n            let Some(line_gizmo) = line_gizmo_assets.get(&config.handle) else {\n                continue;\n            };\n\n            let pipeline = pipelines.specialize(\n                &pipeline_cache,\n                &pipeline,\n                LineGizmoPipelineKey {\n                    view_key,\n                    strip: line_gizmo.strip,\n                    perspective: config.line_perspective,\n                    line_style: config.line_style,\n                },\n            );\n\n            transparent_phase.add(Transparent3d {\n                entity: (entity, *main_entity),\n                draw_function,\n                pipeline,\n                distance: 0.,\n                batch_range: 0..1,\n                extra_index: PhaseItemExtraIndex::NONE,\n            });\n        }\n    }\n}\n\n#[allow(clippy::too_many_arguments)]\nfn queue_line_joint_gizmos_3d(\n    draw_functions: Res<DrawFunctions<Transparent3d>>,\n    pipeline: Res<LineJointGizmoPipeline>,\n    mut pipelines: ResMut<SpecializedRenderPipelines<LineJointGizmoPipeline>>,\n    pipeline_cache: Res<PipelineCache>,\n    line_gizmos: Query<(Entity, &MainEntity, &GizmoMeshConfig)>,\n    line_gizmo_assets: Res<RenderAssets<GpuLineGizmo>>,\n    mut transparent_render_phases: ResMut<ViewSortedRenderPhases<Transparent3d>>,\n    mut views: Query<(\n        Entity,\n        &ExtractedView,\n        &Msaa,\n        Option<&RenderLayers>,\n        (\n            Has<NormalPrepass>,\n            Has<DepthPrepass>,\n            Has<MotionVectorPrepass>,\n            Has<DeferredPrepass>,\n        ),\n    )>,\n) {\n    let draw_function = draw_functions\n        .read()\n        .get_id::<DrawLineJointGizmo3d>()\n        .unwrap();\n\n    for (\n        view_entity,\n        view,\n        msaa,\n        render_layers,\n        (normal_prepass, depth_prepass, motion_vector_prepass, deferred_prepass),\n    ) in &mut views\n    {\n        let Some(transparent_phase) = transparent_render_phases.get_mut(&view_entity) else {\n            continue;\n        };\n\n        let render_layers = render_layers.unwrap_or_default();\n\n        let mut view_key = MeshPipelineKey::from_msaa_samples(msaa.samples())\n            | MeshPipelineKey::from_hdr(view.hdr);\n\n        if normal_prepass {\n            view_key |= MeshPipelineKey::NORMAL_PREPASS;\n        }\n\n        if depth_prepass {\n            view_key |= MeshPipelineKey::DEPTH_PREPASS;\n        }\n\n        if motion_vector_prepass {\n            view_key |= MeshPipelineKey::MOTION_VECTOR_PREPASS;\n        }\n\n        if deferred_prepass {\n            view_key |= MeshPipelineKey::DEFERRED_PREPASS;\n        }\n\n        for (entity, main_entity, config) in &line_gizmos {\n            if !config.render_layers.intersects(render_layers) {\n                continue;\n            }\n\n            let Some(line_gizmo) = line_gizmo_assets.get(&config.handle) else {\n                continue;\n            };\n\n            if !line_gizmo.strip || line_gizmo.joints == GizmoLineJoint::None {\n                continue;\n            }\n\n            let pipeline = pipelines.specialize(\n                &pipeline_cache,\n                &pipeline,\n                LineJointGizmoPipelineKey {\n                    view_key,\n                    perspective: config.line_perspective,\n                    joints: line_gizmo.joints,\n                },\n            );\n\n            transparent_phase.add(Transparent3d {\n                entity: (entity, *main_entity),\n                draw_function,\n                pipeline,\n                distance: 0.,\n                batch_range: 0..1,\n                extra_index: PhaseItemExtraIndex::NONE,\n            });\n        }\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "e76d71c8d7006578fec76a0a82247b8aad0ecaec",
    "func": "#![warn(rust_2018_idioms)]\n#![cfg(feature = \"full\")]\n\nuse tokio::io::{AsyncWrite, AsyncWriteExt};\nuse tokio_test::assert_ok;\n\nuse bytes::BytesMut;\nuse std::cmp;\nuse std::io;\nuse std::pin::Pin;\nuse std::task::{Context, Poll};\n\n#[tokio::test]\nasync fn write_all() {\n    struct Wr {\n        buf: BytesMut,\n        cnt: usize,\n    }\n\n    impl AsyncWrite for Wr {\n        fn poll_write(\n            mut self: Pin<&mut Self>,\n            _cx: &mut Context<'_>,\n            buf: &[u8],\n        ) -> Poll<io::Result<usize>> {\n            let n = cmp::min(4, buf.len());\n            let buf = &buf[0..n];\n\n            self.cnt += 1;\n            self.buf.extend(buf);\n            Ok(buf.len()).into()\n        }\n\n        fn poll_flush(self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<io::Result<()>> {\n            Ok(()).into()\n        }\n\n        fn poll_shutdown(self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<io::Result<()>> {\n            Ok(()).into()\n        }\n    }\n\n    let mut wr = Wr {\n        buf: BytesMut::with_capacity(64),\n        cnt: 0,\n    };\n\n    assert_ok!(wr.write_all(b\"hello world\").await);\n    assert_eq!(wr.buf, b\"hello world\"[..]);\n    assert_eq!(wr.cnt, 3);\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "3c761a07cb18215e3889435d886a9d9cddfa3136",
    "func": "use crate::{Image, TextureFormatPixelInfo};\nuse bevy_asset::{io::Reader, AssetLoader, LoadContext, RenderAssetUsages};\nuse derive_more::derive::{Display, Error, From};\nuse image::ImageDecoder;\nuse serde::{Deserialize, Serialize};\nuse wgpu::{Extent3d, TextureDimension, TextureFormat};\n\n/// Loads EXR textures as Texture assets\n#[derive(Clone, Default)]\n#[cfg(feature = \"exr\")]\npub struct ExrTextureLoader;\n\n#[derive(Serialize, Deserialize, Default, Debug)]\n#[cfg(feature = \"exr\")]\npub struct ExrTextureLoaderSettings {\n    pub asset_usage: RenderAssetUsages,\n}\n\n/// Possible errors that can be produced by [`ExrTextureLoader`]\n#[non_exhaustive]\n#[derive(Debug, Error, Display, From)]\n#[cfg(feature = \"exr\")]\npub enum ExrTextureLoaderError {\n    Io(std::io::Error),\n    ImageError(image::ImageError),\n}\n\nimpl AssetLoader for ExrTextureLoader {\n    type Asset = Image;\n    type Settings = ExrTextureLoaderSettings;\n    type Error = ExrTextureLoaderError;\n\n    async fn load(\n        &self,\n        reader: &mut dyn Reader,\n        settings: &Self::Settings,\n        _load_context: &mut LoadContext<'_>,\n    ) -> Result<Image, Self::Error> {\n        let format = TextureFormat::Rgba32Float;\n        debug_assert_eq!(\n            format.pixel_size(),\n            4 * 4,\n            \"Format should have 32bit x 4 size\"\n        );\n\n        let mut bytes = Vec::new();\n        reader.read_to_end(&mut bytes).await?;\n        let decoder = image::codecs::openexr::OpenExrDecoder::with_alpha_preference(\n            std::io::Cursor::new(bytes),\n            Some(true),\n        )?;\n        let (width, height) = decoder.dimensions();\n\n        let total_bytes = decoder.total_bytes() as usize;\n\n        let mut buf = vec![0u8; total_bytes];\n        decoder.read_image(buf.as_mut_slice())?;\n\n        Ok(Image::new(\n            Extent3d {\n                width,\n                height,\n                depth_or_array_layers: 1,\n            },\n            TextureDimension::D2,\n            buf,\n            format,\n            settings.asset_usage,\n        ))\n    }\n\n    fn extensions(&self) -> &[&str] {\n        &[\"exr\"]\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "b71b4e34421b72f03cefe36e01d68266f6185f7e",
    "func": "use actix_files::Files;\nuse actix_web::{get, guard, middleware, App, HttpServer, Responder};\n\nconst EXAMPLES_DIR: &str = concat![env!(\"CARGO_MANIFEST_DIR\"), \"/examples\"];\n\n#[get(\"/\")]\nasync fn index() -> impl Responder {\n    \"Hello world!\"\n}\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    env_logger::init_from_env(env_logger::Env::new().default_filter_or(\"info\"));\n\n    log::info!(\"starting HTTP server at http://localhost:8080\");\n\n    HttpServer::new(|| {\n        App::new()\n            .service(index)\n            .service(\n                Files::new(\"/assets\", EXAMPLES_DIR)\n                    .show_files_listing()\n                    .guard(guard::Header(\"show-listing\", \"?1\")),\n            )\n            .service(Files::new(\"/assets\", EXAMPLES_DIR))\n            .wrap(middleware::Compress::default())\n            .wrap(middleware::Logger::default())\n    })\n    .bind((\"127.0.0.1\", 8080))?\n    .workers(2)\n    .run()\n    .await\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "0f926e4cac4a17e689ac9b2620310ac408586a31",
    "func": "// compiling some tests will trigger unused function warnings even though other tests use them\n#![allow(dead_code)]\n\nuse std::io::{Read as _, Write as _};\n\npub mod gzip {\n    use flate2::{read::GzDecoder, write::GzEncoder, Compression};\n\n    use super::*;\n\n    pub fn encode(bytes: impl AsRef<[u8]>) -> Vec<u8> {\n        let mut encoder = GzEncoder::new(Vec::new(), Compression::fast());\n        encoder.write_all(bytes.as_ref()).unwrap();\n        encoder.finish().unwrap()\n    }\n\n    pub fn decode(bytes: impl AsRef<[u8]>) -> Vec<u8> {\n        let mut decoder = GzDecoder::new(bytes.as_ref());\n        let mut buf = Vec::new();\n        decoder.read_to_end(&mut buf).unwrap();\n        buf\n    }\n}\n\npub mod deflate {\n    use flate2::{read::ZlibDecoder, write::ZlibEncoder, Compression};\n\n    use super::*;\n\n    pub fn encode(bytes: impl AsRef<[u8]>) -> Vec<u8> {\n        let mut encoder = ZlibEncoder::new(Vec::new(), Compression::fast());\n        encoder.write_all(bytes.as_ref()).unwrap();\n        encoder.finish().unwrap()\n    }\n\n    pub fn decode(bytes: impl AsRef<[u8]>) -> Vec<u8> {\n        let mut decoder = ZlibDecoder::new(bytes.as_ref());\n        let mut buf = Vec::new();\n        decoder.read_to_end(&mut buf).unwrap();\n        buf\n    }\n}\n\npub mod brotli {\n    use ::brotli::{reader::Decompressor as BrotliDecoder, CompressorWriter as BrotliEncoder};\n\n    use super::*;\n\n    pub fn encode(bytes: impl AsRef<[u8]>) -> Vec<u8> {\n        let mut encoder = BrotliEncoder::new(\n            Vec::new(),\n            8 * 1024, // 32 KiB buffer\n            3,        // BROTLI_PARAM_QUALITY\n            22,       // BROTLI_PARAM_LGWIN\n        );\n        encoder.write_all(bytes.as_ref()).unwrap();\n        encoder.flush().unwrap();\n        encoder.into_inner()\n    }\n\n    pub fn decode(bytes: impl AsRef<[u8]>) -> Vec<u8> {\n        let mut decoder = BrotliDecoder::new(bytes.as_ref(), 8_096);\n        let mut buf = Vec::new();\n        decoder.read_to_end(&mut buf).unwrap();\n        buf\n    }\n}\n\npub mod zstd {\n    use ::zstd::stream::{read::Decoder, write::Encoder};\n\n    use super::*;\n\n    pub fn encode(bytes: impl AsRef<[u8]>) -> Vec<u8> {\n        let mut encoder = Encoder::new(Vec::new(), 3).unwrap();\n        encoder.write_all(bytes.as_ref()).unwrap();\n        encoder.finish().unwrap()\n    }\n\n    pub fn decode(bytes: impl AsRef<[u8]>) -> Vec<u8> {\n        let mut decoder = Decoder::new(bytes.as_ref()).unwrap();\n        let mut buf = Vec::new();\n        decoder.read_to_end(&mut buf).unwrap();\n        buf\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "afe10c5726ed24223c4eb80df81c0c78c9041430",
    "func": "use crate::{\n    blit::{BlitPipeline, BlitPipelineKey},\n    core_2d::graph::{Core2d, Node2d},\n    core_3d::graph::{Core3d, Node3d},\n};\nuse bevy_app::{App, Plugin};\nuse bevy_color::LinearRgba;\nuse bevy_ecs::{prelude::*, query::QueryItem};\nuse bevy_render::{\n    camera::ExtractedCamera,\n    render_graph::{NodeRunError, RenderGraphApp, RenderGraphContext, ViewNode, ViewNodeRunner},\n    render_resource::*,\n    renderer::RenderContext,\n    view::{Msaa, ViewTarget},\n    Render, RenderApp, RenderSet,\n};\n\n/// This enables \"msaa writeback\" support for the `core_2d` and `core_3d` pipelines, which can be enabled on cameras\n/// using [`bevy_render::camera::Camera::msaa_writeback`]. See the docs on that field for more information.\npub struct MsaaWritebackPlugin;\n\nimpl Plugin for MsaaWritebackPlugin {\n    fn build(&self, app: &mut App) {\n        let Some(render_app) = app.get_sub_app_mut(RenderApp) else {\n            return;\n        };\n        render_app.add_systems(\n            Render,\n            prepare_msaa_writeback_pipelines.in_set(RenderSet::Prepare),\n        );\n        {\n            render_app\n                .add_render_graph_node::<ViewNodeRunner<MsaaWritebackNode>>(\n                    Core2d,\n                    Node2d::MsaaWriteback,\n                )\n                .add_render_graph_edge(Core2d, Node2d::MsaaWriteback, Node2d::StartMainPass);\n        }\n        {\n            render_app\n                .add_render_graph_node::<ViewNodeRunner<MsaaWritebackNode>>(\n                    Core3d,\n                    Node3d::MsaaWriteback,\n                )\n                .add_render_graph_edge(Core3d, Node3d::MsaaWriteback, Node3d::StartMainPass);\n        }\n    }\n}\n\n#[derive(Default)]\npub struct MsaaWritebackNode;\n\nimpl ViewNode for MsaaWritebackNode {\n    type ViewQuery = (\n        &'static ViewTarget,\n        &'static MsaaWritebackBlitPipeline,\n        &'static Msaa,\n    );\n\n    fn run<'w>(\n        &self,\n        _graph: &mut RenderGraphContext,\n        render_context: &mut RenderContext<'w>,\n        (target, blit_pipeline_id, msaa): QueryItem<'w, Self::ViewQuery>,\n        world: &'w World,\n    ) -> Result<(), NodeRunError> {\n        if *msaa == Msaa::Off {\n            return Ok(());\n        }\n\n        let blit_pipeline = world.resource::<BlitPipeline>();\n        let pipeline_cache = world.resource::<PipelineCache>();\n        let Some(pipeline) = pipeline_cache.get_render_pipeline(blit_pipeline_id.0) else {\n            return Ok(());\n        };\n\n        // The current \"main texture\" needs to be bound as an input resource, and we need the \"other\"\n        // unused target to be the \"resolve target\" for the MSAA write. Therefore this is the same\n        // as a post process write!\n        let post_process = target.post_process_write();\n\n        let pass_descriptor = RenderPassDescriptor {\n            label: Some(\"msaa_writeback\"),\n            // The target's \"resolve target\" is the \"destination\" in post_process.\n            // We will indirectly write the results to the \"destination\" using\n            // the MSAA resolve step.\n            color_attachments: &[Some(RenderPassColorAttachment {\n                // If MSAA is enabled, then the sampled texture will always exist\n                view: target.sampled_main_texture_view().unwrap(),\n                resolve_target: Some(post_process.destination),\n                ops: Operations {\n                    load: LoadOp::Clear(LinearRgba::BLACK.into()),\n                    store: StoreOp::Store,\n                },\n            })],\n            depth_stencil_attachment: None,\n            timestamp_writes: None,\n            occlusion_query_set: None,\n        };\n\n        let bind_group = render_context.render_device().create_bind_group(\n            None,\n            &blit_pipeline.texture_bind_group,\n            &BindGroupEntries::sequential((post_process.source, &blit_pipeline.sampler)),\n        );\n\n        let mut render_pass = render_context\n            .command_encoder()\n            .begin_render_pass(&pass_descriptor);\n\n        render_pass.set_pipeline(pipeline);\n        render_pass.set_bind_group(0, &bind_group, &[]);\n        render_pass.draw(0..3, 0..1);\n\n        Ok(())\n    }\n}\n\n#[derive(Component)]\npub struct MsaaWritebackBlitPipeline(CachedRenderPipelineId);\n\nfn prepare_msaa_writeback_pipelines(\n    mut commands: Commands,\n    pipeline_cache: Res<PipelineCache>,\n    mut pipelines: ResMut<SpecializedRenderPipelines<BlitPipeline>>,\n    blit_pipeline: Res<BlitPipeline>,\n    view_targets: Query<(Entity, &ViewTarget, &ExtractedCamera, &Msaa)>,\n) {\n    for (entity, view_target, camera, msaa) in view_targets.iter() {\n        // only do writeback if writeback is enabled for the camera and this isn't the first camera in the target,\n        // as there is nothing to write back for the first camera.\n        if msaa.samples() > 1 && camera.msaa_writeback && camera.sorted_camera_index_for_target > 0\n        {\n            let key = BlitPipelineKey {\n                texture_format: view_target.main_texture_format(),\n                samples: msaa.samples(),\n                blend_state: None,\n            };\n\n            let pipeline = pipelines.specialize(&pipeline_cache, &blit_pipeline, key);\n            commands\n                .entity(entity)\n                .insert(MsaaWritebackBlitPipeline(pipeline));\n        } else {\n            // This isn't strictly necessary now, but if we move to retained render entity state I don't\n            // want this to silently break\n            commands\n                .entity(entity)\n                .remove::<MsaaWritebackBlitPipeline>();\n        }\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "0b2ec01ef502c7dc33997ae6d081144c2cb9fc87",
    "func": "use serde_derive::Serialize;\n\nmod remote {\n    pub enum E {\n        A { a: u8 },\n    }\n}\n\n#[derive(Serialize)]\n#[serde(remote = \"remote::E\")]\npub enum E {\n    A {\n        #[serde(getter = \"get_a\")]\n        a: u8,\n    },\n}\n\nfn main() {}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "c5f0c2ed803231bbd472314a3d72dadf9a35fc25",
    "func": "use std::{net, rc::Rc};\n\nuse crate::{\n    header::{self, HeaderMap},\n    message::{Flags, Head, MessagePool},\n    ConnectionType, Method, Uri, Version,\n};\n\nthread_local! {\n    static REQUEST_POOL: MessagePool<RequestHead> = MessagePool::<RequestHead>::create()\n}\n\n#[derive(Debug, Clone)]\npub struct RequestHead {\n    pub method: Method,\n    pub uri: Uri,\n    pub version: Version,\n    pub headers: HeaderMap,\n\n    /// Will only be None when called in unit tests unless set manually.\n    pub peer_addr: Option<net::SocketAddr>,\n\n    flags: Flags,\n}\n\nimpl Default for RequestHead {\n    fn default() -> RequestHead {\n        RequestHead {\n            method: Method::default(),\n            uri: Uri::default(),\n            version: Version::HTTP_11,\n            headers: HeaderMap::with_capacity(16),\n            peer_addr: None,\n            flags: Flags::empty(),\n        }\n    }\n}\n\nimpl Head for RequestHead {\n    fn clear(&mut self) {\n        self.flags = Flags::empty();\n        self.headers.clear();\n    }\n\n    fn with_pool<F, R>(f: F) -> R\n    where\n        F: FnOnce(&MessagePool<Self>) -> R,\n    {\n        REQUEST_POOL.with(|p| f(p))\n    }\n}\n\nimpl RequestHead {\n    /// Read the message headers.\n    pub fn headers(&self) -> &HeaderMap {\n        &self.headers\n    }\n\n    /// Mutable reference to the message headers.\n    pub fn headers_mut(&mut self) -> &mut HeaderMap {\n        &mut self.headers\n    }\n\n    /// Is to uppercase headers with Camel-Case.\n    /// Default is `false`\n    #[inline]\n    pub fn camel_case_headers(&self) -> bool {\n        self.flags.contains(Flags::CAMEL_CASE)\n    }\n\n    /// Set `true` to send headers which are formatted as Camel-Case.\n    #[inline]\n    pub fn set_camel_case_headers(&mut self, val: bool) {\n        if val {\n            self.flags.insert(Flags::CAMEL_CASE);\n        } else {\n            self.flags.remove(Flags::CAMEL_CASE);\n        }\n    }\n\n    #[inline]\n    /// Set connection type of the message\n    pub fn set_connection_type(&mut self, ctype: ConnectionType) {\n        match ctype {\n            ConnectionType::Close => self.flags.insert(Flags::CLOSE),\n            ConnectionType::KeepAlive => self.flags.insert(Flags::KEEP_ALIVE),\n            ConnectionType::Upgrade => self.flags.insert(Flags::UPGRADE),\n        }\n    }\n\n    #[inline]\n    /// Connection type\n    pub fn connection_type(&self) -> ConnectionType {\n        if self.flags.contains(Flags::CLOSE) {\n            ConnectionType::Close\n        } else if self.flags.contains(Flags::KEEP_ALIVE) {\n            ConnectionType::KeepAlive\n        } else if self.flags.contains(Flags::UPGRADE) {\n            ConnectionType::Upgrade\n        } else if self.version < Version::HTTP_11 {\n            ConnectionType::Close\n        } else {\n            ConnectionType::KeepAlive\n        }\n    }\n\n    /// Connection upgrade status\n    pub fn upgrade(&self) -> bool {\n        self.headers()\n            .get(header::CONNECTION)\n            .map(|hdr| {\n                if let Ok(s) = hdr.to_str() {\n                    s.to_ascii_lowercase().contains(\"upgrade\")\n                } else {\n                    false\n                }\n            })\n            .unwrap_or(false)\n    }\n\n    #[inline]\n    /// Get response body chunking state\n    pub fn chunked(&self) -> bool {\n        !self.flags.contains(Flags::NO_CHUNKING)\n    }\n\n    #[inline]\n    pub fn no_chunking(&mut self, val: bool) {\n        if val {\n            self.flags.insert(Flags::NO_CHUNKING);\n        } else {\n            self.flags.remove(Flags::NO_CHUNKING);\n        }\n    }\n\n    /// Request contains `EXPECT` header.\n    #[inline]\n    pub fn expect(&self) -> bool {\n        self.flags.contains(Flags::EXPECT)\n    }\n\n    #[inline]\n    pub(crate) fn set_expect(&mut self) {\n        self.flags.insert(Flags::EXPECT);\n    }\n}\n\n#[allow(clippy::large_enum_variant)]\n#[derive(Debug)]\npub enum RequestHeadType {\n    Owned(RequestHead),\n    Rc(Rc<RequestHead>, Option<HeaderMap>),\n}\n\nimpl RequestHeadType {\n    pub fn extra_headers(&self) -> Option<&HeaderMap> {\n        match self {\n            RequestHeadType::Owned(_) => None,\n            RequestHeadType::Rc(_, headers) => headers.as_ref(),\n        }\n    }\n}\n\nimpl AsRef<RequestHead> for RequestHeadType {\n    fn as_ref(&self) -> &RequestHead {\n        match self {\n            RequestHeadType::Owned(head) => head,\n            RequestHeadType::Rc(head, _) => head.as_ref(),\n        }\n    }\n}\n\nimpl From<RequestHead> for RequestHeadType {\n    fn from(head: RequestHead) -> Self {\n        RequestHeadType::Owned(head)\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "ef742fa6624a5ce1d019152dce221f2eae4fde40",
    "func": "#![allow(unknown_lints, unexpected_cfgs)]\n#![allow(\n    clippy::cognitive_complexity,\n    clippy::large_enum_variant,\n    clippy::needless_doctest_main\n)]\n#![warn(\n    missing_debug_implementations,\n    missing_docs,\n    rust_2018_idioms,\n    unreachable_pub\n)]\n#![cfg_attr(docsrs, feature(doc_cfg))]\n#![doc(test(\n    no_crate_inject,\n    attr(deny(warnings, rust_2018_idioms), allow(dead_code, unused_variables))\n))]\n\n//! Stream utilities for Tokio.\n//!\n//! A `Stream` is an asynchronous sequence of values. It can be thought of as\n//! an asynchronous version of the standard library's `Iterator` trait.\n//!\n//! This crate provides helpers to work with them. For examples of usage and a more in-depth\n//! description of streams you can also refer to the [streams\n//! tutorial](https://tokio.rs/tokio/tutorial/streams) on the tokio website.\n//!\n//! # Iterating over a Stream\n//!\n//! Due to similarities with the standard library's `Iterator` trait, some new\n//! users may assume that they can use `for in` syntax to iterate over a\n//! `Stream`, but this is unfortunately not possible. Instead, you can use a\n//! `while let` loop as follows:\n//!\n//! ```rust\n//! use tokio_stream::{self as stream, StreamExt};\n//!\n//! #[tokio::main]\n//! async fn main() {\n//!     let mut stream = stream::iter(vec![0, 1, 2]);\n//!\n//!     while let Some(value) = stream.next().await {\n//!         println!(\"Got {}\", value);\n//!     }\n//! }\n//! ```\n//!\n//! # Returning a Stream from a function\n//!\n//! A common way to stream values from a function is to pass in the sender\n//! half of a channel and use the receiver as the stream. This requires awaiting\n//! both futures to ensure progress is made. Another alternative is the\n//! [async-stream] crate, which contains macros that provide a `yield` keyword\n//! and allow you to return an `impl Stream`.\n//!\n//! [async-stream]: https://docs.rs/async-stream\n//!\n//! # Conversion to and from `AsyncRead`/`AsyncWrite`\n//!\n//! It is often desirable to convert a `Stream` into an [`AsyncRead`],\n//! especially when dealing with plaintext formats streamed over the network.\n//! The opposite conversion from an [`AsyncRead`] into a `Stream` is also\n//! another commonly required feature. To enable these conversions,\n//! [`tokio-util`] provides the [`StreamReader`] and [`ReaderStream`]\n//! types when the io feature is enabled.\n//!\n//! [`tokio-util`]: https://docs.rs/tokio-util/latest/tokio_util/codec/index.html\n//! [`tokio::io`]: https://docs.rs/tokio/latest/tokio/io/index.html\n//! [`AsyncRead`]: https://docs.rs/tokio/latest/tokio/io/trait.AsyncRead.html\n//! [`AsyncWrite`]: https://docs.rs/tokio/latest/tokio/io/trait.AsyncWrite.html\n//! [`ReaderStream`]: https://docs.rs/tokio-util/latest/tokio_util/io/struct.ReaderStream.html\n//! [`StreamReader`]: https://docs.rs/tokio-util/latest/tokio_util/io/struct.StreamReader.html\n\n#[macro_use]\nmod macros;\n\npub mod wrappers;\n\nmod stream_ext;\npub use stream_ext::{collect::FromStream, StreamExt};\n/// Adapters for [`Stream`]s created by methods in [`StreamExt`].\npub mod adapters {\n    pub use crate::stream_ext::{\n        Chain, Filter, FilterMap, Fuse, Map, MapWhile, Merge, Peekable, Skip, SkipWhile, Take,\n        TakeWhile, Then,\n    };\n    cfg_time! {\n        pub use crate::stream_ext::{ChunksTimeout, Timeout, TimeoutRepeating};\n    }\n}\n\ncfg_time! {\n    #[deprecated = \"Import those symbols from adapters instead\"]\n    #[doc(hidden)]\n    pub use stream_ext::timeout::Timeout;\n    pub use stream_ext::timeout::Elapsed;\n}\n\nmod empty;\npub use empty::{empty, Empty};\n\nmod iter;\npub use iter::{iter, Iter};\n\nmod once;\npub use once::{once, Once};\n\nmod pending;\npub use pending::{pending, Pending};\n\nmod stream_map;\npub use stream_map::StreamMap;\n\nmod stream_close;\npub use stream_close::StreamNotifyClose;\n\n#[doc(no_inline)]\npub use futures_core::Stream;\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "6038fa4e785f580faf43f19c94406b82d670af6d",
    "func": "// # Implementation Note:\n//\n// This example is also used to demonstrate SSR hydration.\n// It is important to follow the following rules when updating this example:\n//\n// - Do not use usize for randomised contents.\n//\n//   usize differs in memory size in 32-bit and 64-bit targets (wasm32 is a 32-bit target family.)\n//   and would lead to a different value even if the Rng at the same state.\n//\n// - Do not swap StdRng for SmallRng.\n//\n//   SmallRng uses different algorithms depending on the platform.\n//   Hence, it may not yield the same value on the client and server side.\n\nmod app;\nmod components;\nmod content;\nmod generator;\nmod pages;\n\npub use app::*;\npub use content::*;\npub use generator::*;\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "75c742111f0c34bd548c1dabc5b6d5735a6d35e5",
    "func": "//! `SeaORM` Entity. Generated by sea-orm-codegen 0.12.1\n\nuse sea_orm::entity::prelude::*;\n\n#[derive(Clone, Debug, PartialEq, DeriveEntityModel)]\n#[sea_orm(table_name = \"bakery\")]\npub struct Model {\n    #[sea_orm(primary_key)]\n    pub id: i32,\n    pub name: String,\n    #[sea_orm(column_type = \"Double\")]\n    pub profit_margin: f64,\n}\n\n#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]\npub enum Relation {\n    #[sea_orm(has_many = \"super::baker::Entity\")]\n    Baker,\n    #[sea_orm(has_many = \"super::cake::Entity\")]\n    Cake,\n}\n\nimpl Related<super::baker::Entity> for Entity {\n    fn to() -> RelationDef {\n        Relation::Baker.def()\n    }\n}\n\nimpl Related<super::cake::Entity> for Entity {\n    fn to() -> RelationDef {\n        Relation::Cake.def()\n    }\n}\n\nimpl ActiveModelBehavior for ActiveModel {}\n\n#[derive(Copy, Clone, Debug, EnumIter, DeriveRelatedEntity)]\npub enum RelatedEntity {\n    #[sea_orm(entity = \"super::baker::Entity\")]\n    Baker,\n    #[sea_orm(entity = \"super::cake::Entity\")]\n    Cake,\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "993f787c21e98e4a14f767939921a3634ccdc227",
    "func": "use crate::{error::*, ExecResult, ExecResultHolder, QueryResult, QueryResultRow, Statement};\n\nuse sea_query::{Value, ValueType};\nuse std::{collections::BTreeMap, fmt::Debug};\n\n/// Defines the [ProxyDatabaseTrait] to save the functions\n#[async_trait::async_trait]\npub trait ProxyDatabaseTrait: Send + Sync + std::fmt::Debug {\n    /// Execute a query in the [ProxyDatabase], and return the query results\n    async fn query(&self, statement: Statement) -> Result<Vec<ProxyRow>, DbErr>;\n\n    /// Execute a command in the [ProxyDatabase], and report the number of rows affected\n    async fn execute(&self, statement: Statement) -> Result<ProxyExecResult, DbErr>;\n\n    /// Begin a transaction in the [ProxyDatabase]\n    async fn begin(&self) {}\n\n    /// Commit a transaction in the [ProxyDatabase]\n    async fn commit(&self) {}\n\n    /// Rollback a transaction in the [ProxyDatabase]\n    async fn rollback(&self) {}\n\n    /// Ping the [ProxyDatabase], it should return an error if the database is not available\n    async fn ping(&self) -> Result<(), DbErr> {\n        Ok(())\n    }\n}\n\n/// Defines the results obtained from a [ProxyDatabase]\n#[derive(Clone, Debug, Default, serde::Serialize, serde::Deserialize)]\npub struct ProxyExecResult {\n    /// The last inserted id on auto-increment\n    pub last_insert_id: u64,\n    /// The number of rows affected by the database operation\n    pub rows_affected: u64,\n}\n\nimpl ProxyExecResult {\n    /// Create a new [ProxyExecResult] from the last inserted id and the number of rows affected\n    pub fn new(last_insert_id: u64, rows_affected: u64) -> Self {\n        Self {\n            last_insert_id,\n            rows_affected,\n        }\n    }\n}\n\nimpl Default for ExecResultHolder {\n    fn default() -> Self {\n        Self::Proxy(ProxyExecResult::default())\n    }\n}\n\nimpl From<ProxyExecResult> for ExecResult {\n    fn from(result: ProxyExecResult) -> Self {\n        Self {\n            result: ExecResultHolder::Proxy(result),\n        }\n    }\n}\n\nimpl From<ExecResult> for ProxyExecResult {\n    fn from(result: ExecResult) -> Self {\n        match result.result {\n            #[cfg(feature = \"sqlx-mysql\")]\n            ExecResultHolder::SqlxMySql(result) => Self {\n                last_insert_id: result.last_insert_id() as u64,\n                rows_affected: result.rows_affected(),\n            },\n            #[cfg(feature = \"sqlx-postgres\")]\n            ExecResultHolder::SqlxPostgres(result) => Self {\n                last_insert_id: 0,\n                rows_affected: result.rows_affected(),\n            },\n            #[cfg(feature = \"sqlx-sqlite\")]\n            ExecResultHolder::SqlxSqlite(result) => Self {\n                last_insert_id: result.last_insert_rowid() as u64,\n                rows_affected: result.rows_affected(),\n            },\n            #[cfg(feature = \"mock\")]\n            ExecResultHolder::Mock(result) => Self {\n                last_insert_id: result.last_insert_id,\n                rows_affected: result.rows_affected,\n            },\n            ExecResultHolder::Proxy(result) => result,\n        }\n    }\n}\n\n/// Defines the structure of a Row for the [ProxyDatabase]\n/// which is just a [BTreeMap]<[String], [Value]>\n#[derive(Clone, Debug)]\npub struct ProxyRow {\n    /// The values of the single row\n    pub values: BTreeMap<String, Value>,\n}\n\nimpl ProxyRow {\n    /// Create a new [ProxyRow] from a [BTreeMap]<[String], [Value]>\n    pub fn new(values: BTreeMap<String, Value>) -> Self {\n        Self { values }\n    }\n}\n\nimpl Default for ProxyRow {\n    fn default() -> Self {\n        Self {\n            values: BTreeMap::new(),\n        }\n    }\n}\n\nimpl From<BTreeMap<String, Value>> for ProxyRow {\n    fn from(values: BTreeMap<String, Value>) -> Self {\n        Self { values }\n    }\n}\n\nimpl From<ProxyRow> for BTreeMap<String, Value> {\n    fn from(row: ProxyRow) -> Self {\n        row.values\n    }\n}\n\nimpl From<ProxyRow> for Vec<(String, Value)> {\n    fn from(row: ProxyRow) -> Self {\n        row.values.into_iter().collect()\n    }\n}\n\nimpl From<ProxyRow> for QueryResult {\n    fn from(row: ProxyRow) -> Self {\n        QueryResult {\n            row: QueryResultRow::Proxy(row),\n        }\n    }\n}\n\n#[cfg(feature = \"with-json\")]\nimpl Into<serde_json::Value> for ProxyRow {\n    fn into(self) -> serde_json::Value {\n        self.values\n            .into_iter()\n            .map(|(k, v)| (k, sea_query::sea_value_to_json_value(&v)))\n            .collect()\n    }\n}\n\n/// Convert [QueryResult] to [ProxyRow]\npub fn from_query_result_to_proxy_row(result: &QueryResult) -> ProxyRow {\n    match &result.row {\n        #[cfg(feature = \"sqlx-mysql\")]\n        QueryResultRow::SqlxMySql(row) => crate::from_sqlx_mysql_row_to_proxy_row(&row),\n        #[cfg(feature = \"sqlx-postgres\")]\n        QueryResultRow::SqlxPostgres(row) => crate::from_sqlx_postgres_row_to_proxy_row(&row),\n        #[cfg(feature = \"sqlx-sqlite\")]\n        QueryResultRow::SqlxSqlite(row) => crate::from_sqlx_sqlite_row_to_proxy_row(&row),\n        #[cfg(feature = \"mock\")]\n        QueryResultRow::Mock(row) => ProxyRow {\n            values: row.values.clone(),\n        },\n        QueryResultRow::Proxy(row) => row.to_owned(),\n    }\n}\n\nimpl ProxyRow {\n    /// Get a value from the [ProxyRow]\n    pub fn try_get<T, I: crate::ColIdx>(&self, index: I) -> Result<T, DbErr>\n    where\n        T: ValueType,\n    {\n        if let Some(index) = index.as_str() {\n            T::try_from(\n                self.values\n                    .get(index)\n                    .ok_or_else(|| query_err(format!(\"No column for ColIdx {index:?}\")))?\n                    .clone(),\n            )\n            .map_err(type_err)\n        } else if let Some(index) = index.as_usize() {\n            let (_, value) = self\n                .values\n                .iter()\n                .nth(*index)\n                .ok_or_else(|| query_err(format!(\"Column at index {index} not found\")))?;\n            T::try_from(value.clone()).map_err(type_err)\n        } else {\n            unreachable!(\"Missing ColIdx implementation for ProxyRow\");\n        }\n    }\n\n    /// An iterator over the keys and values of a proxy row\n    pub fn into_column_value_tuples(self) -> impl Iterator<Item = (String, Value)> {\n        self.values.into_iter()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::{\n        entity::*, tests_cfg::*, Database, DbBackend, DbErr, ProxyDatabaseTrait, ProxyExecResult,\n        ProxyRow, Statement,\n    };\n    use std::sync::{Arc, Mutex};\n\n    #[derive(Debug)]\n    struct ProxyDb {}\n\n    impl ProxyDatabaseTrait for ProxyDb {\n        async fn query(&self, statement: Statement) -> Result<Vec<ProxyRow>, DbErr> {\n            println!(\"SQL query: {}\", statement.sql);\n            Ok(vec![].into())\n        }\n\n        async fn execute(&self, statement: Statement) -> Result<ProxyExecResult, DbErr> {\n            println!(\"SQL execute: {}\", statement.sql);\n            Ok(ProxyExecResult {\n                last_insert_id: 1,\n                rows_affected: 1,\n            })\n        }\n    }\n\n    #[smol_potat::test]\n    async fn create_proxy_conn() {\n        let _db = Database::connect_proxy(DbBackend::MySql, Arc::new(Box::new(ProxyDb {})))\n            .await\n            .unwrap();\n    }\n\n    #[smol_potat::test]\n    async fn select_rows() {\n        let db = Database::connect_proxy(DbBackend::MySql, Arc::new(Box::new(ProxyDb {})))\n            .await\n            .unwrap();\n\n        let _ = cake::Entity::find().all(&db).await;\n    }\n\n    #[smol_potat::test]\n    async fn insert_one_row() {\n        let db = Database::connect_proxy(DbBackend::MySql, Arc::new(Box::new(ProxyDb {})))\n            .await\n            .unwrap();\n\n        let item = cake::ActiveModel {\n            id: NotSet,\n            name: Set(\"Alice\".to_string()),\n        };\n\n        cake::Entity::insert(item).exec(&db).await.unwrap();\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "26802176a488d9cdf383163579fe81e2f7b69d44",
    "func": "// must-compile-successfully\n\n#[macro_use] extern crate rocket;\n\n// Check for unknown media types.\n\n#[get(\"/\", format = \"application/x-custom\")]\nfn f0() {}\n\n#[get(\"/\", format = \"x-custom/plain\")]\nfn f1() {}\n\n#[get(\"/\", format = \"x-custom/x-custom\")]\nfn f2() {}\n\n#[suppress(unknown_format)]\n#[get(\"/\", format = \"x-custom/x-custom\")]\nfn f3() {}\n\n// Check if a data argument is used with a usually non-payload bearing method.\n\n#[get(\"/\", data = \"<_foo>\")]\nfn g0(_foo: rocket::Data<'_>) {}\n\n#[head(\"/\", data = \"<_foo>\")]\nfn g1(_foo: rocket::Data<'_>) {}\n\n#[suppress(dubious_payload)]\n#[head(\"/\", data = \"<_foo>\")]\nfn g2(_foo: rocket::Data<'_>) {}\n\nfn main() {\n    compile_error!(\"checking for warnings!\")\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "ca63c58484c9f6f25ad03108079f84cb36d15a48",
    "func": "extern crate percent_encoding;\nextern crate url;\n\nuse self::percent_encoding::percent_decode;\nuse self::url::{Host, Url};\nuse std::collections::HashMap;\nuse std::ffi::{CStr, CString};\n\nuse crate::result::{ConnectionError, ConnectionResult};\n\nuse mysqlclient_sys::mysql_ssl_mode;\n\nbitflags::bitflags! {\n    #[derive(Clone, Copy)]\n    pub struct CapabilityFlags: u32 {\n        const CLIENT_LONG_PASSWORD = 0x00000001;\n        const CLIENT_FOUND_ROWS = 0x00000002;\n        const CLIENT_LONG_FLAG = 0x00000004;\n        const CLIENT_CONNECT_WITH_DB = 0x00000008;\n        const CLIENT_NO_SCHEMA = 0x00000010;\n        const CLIENT_COMPRESS = 0x00000020;\n        const CLIENT_ODBC = 0x00000040;\n        const CLIENT_LOCAL_FILES = 0x00000080;\n        const CLIENT_IGNORE_SPACE = 0x00000100;\n        const CLIENT_PROTOCOL_41 = 0x00000200;\n        const CLIENT_INTERACTIVE = 0x00000400;\n        const CLIENT_SSL = 0x00000800;\n        const CLIENT_IGNORE_SIGPIPE = 0x00001000;\n        const CLIENT_TRANSACTIONS = 0x00002000;\n        const CLIENT_RESERVED = 0x00004000;\n        const CLIENT_SECURE_CONNECTION = 0x00008000;\n        const CLIENT_MULTI_STATEMENTS = 0x00010000;\n        const CLIENT_MULTI_RESULTS = 0x00020000;\n        const CLIENT_PS_MULTI_RESULTS = 0x00040000;\n        const CLIENT_PLUGIN_AUTH = 0x00080000;\n        const CLIENT_CONNECT_ATTRS = 0x00100000;\n        const CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA = 0x00200000;\n        const CLIENT_CAN_HANDLE_EXPIRED_PASSWORDS = 0x00400000;\n        const CLIENT_SESSION_TRACK = 0x00800000;\n        const CLIENT_DEPRECATE_EOF = 0x01000000;\n    }\n}\n\npub(super) struct ConnectionOptions {\n    host: Option<CString>,\n    user: CString,\n    password: Option<CString>,\n    database: Option<CString>,\n    port: Option<u16>,\n    unix_socket: Option<CString>,\n    client_flags: CapabilityFlags,\n    ssl_mode: Option<mysql_ssl_mode>,\n    ssl_ca: Option<CString>,\n    ssl_cert: Option<CString>,\n    ssl_key: Option<CString>,\n}\n\nimpl ConnectionOptions {\n    pub(super) fn parse(database_url: &str) -> ConnectionResult<Self> {\n        let url = match Url::parse(database_url) {\n            Ok(url) => url,\n            Err(_) => return Err(connection_url_error()),\n        };\n\n        if url.scheme() != \"mysql\" {\n            return Err(connection_url_error());\n        }\n\n        if url.path_segments().map(Iterator::count).unwrap_or(0) > 1 {\n            return Err(connection_url_error());\n        }\n\n        let query_pairs = url.query_pairs().into_owned().collect::<HashMap<_, _>>();\n        if query_pairs.contains_key(\"database\") {\n            return Err(connection_url_error());\n        }\n\n        let unix_socket = match query_pairs.get(\"unix_socket\") {\n            Some(v) => Some(CString::new(v.as_bytes())?),\n            _ => None,\n        };\n\n        let ssl_ca = match query_pairs.get(\"ssl_ca\") {\n            Some(v) => Some(CString::new(v.as_bytes())?),\n            _ => None,\n        };\n\n        let ssl_cert = match query_pairs.get(\"ssl_cert\") {\n            Some(v) => Some(CString::new(v.as_bytes())?),\n            _ => None,\n        };\n\n        let ssl_key = match query_pairs.get(\"ssl_key\") {\n            Some(v) => Some(CString::new(v.as_bytes())?),\n            _ => None,\n        };\n\n        let ssl_mode = match query_pairs.get(\"ssl_mode\") {\n            Some(v) => {\n                let ssl_mode = match v.to_lowercase().as_str() {\n                    \"disabled\" => mysql_ssl_mode::SSL_MODE_DISABLED,\n                    \"preferred\" => mysql_ssl_mode::SSL_MODE_PREFERRED,\n                    \"required\" => mysql_ssl_mode::SSL_MODE_REQUIRED,\n                    \"verify_ca\" => mysql_ssl_mode::SSL_MODE_VERIFY_CA,\n                    \"verify_identity\" => mysql_ssl_mode::SSL_MODE_VERIFY_IDENTITY,\n                    _ => {\n                        let msg = \"unknown ssl_mode\";\n                        return Err(ConnectionError::InvalidConnectionUrl(msg.into()));\n                    }\n                };\n                Some(ssl_mode)\n            }\n            _ => None,\n        };\n\n        let host = match url.host() {\n            Some(Host::Ipv6(host)) => Some(CString::new(host.to_string())?),\n            Some(host) if host.to_string() == \"localhost\" && unix_socket.is_some() => None,\n            Some(host) => Some(CString::new(host.to_string())?),\n            None => None,\n        };\n        let user = decode_into_cstring(url.username())?;\n        let password = match url.password() {\n            Some(password) => Some(decode_into_cstring(password)?),\n            None => None,\n        };\n\n        let database = match url.path_segments().and_then(|mut iter| iter.next()) {\n            Some(\"\") | None => None,\n            Some(segment) => Some(CString::new(segment.as_bytes())?),\n        };\n\n        // this is not present in the database_url, using a default value\n        let client_flags = CapabilityFlags::CLIENT_FOUND_ROWS;\n\n        Ok(ConnectionOptions {\n            host,\n            user,\n            password,\n            database,\n            port: url.port(),\n            client_flags,\n            ssl_mode,\n            unix_socket,\n            ssl_ca,\n            ssl_cert,\n            ssl_key,\n        })\n    }\n\n    pub(super) fn host(&self) -> Option<&CStr> {\n        self.host.as_deref()\n    }\n\n    pub(super) fn user(&self) -> &CStr {\n        &self.user\n    }\n\n    pub(super) fn password(&self) -> Option<&CStr> {\n        self.password.as_deref()\n    }\n\n    pub(super) fn database(&self) -> Option<&CStr> {\n        self.database.as_deref()\n    }\n\n    pub(super) fn port(&self) -> Option<u16> {\n        self.port\n    }\n\n    pub(super) fn unix_socket(&self) -> Option<&CStr> {\n        self.unix_socket.as_deref()\n    }\n\n    pub(super) fn ssl_ca(&self) -> Option<&CStr> {\n        self.ssl_ca.as_deref()\n    }\n\n    pub(super) fn ssl_cert(&self) -> Option<&CStr> {\n        self.ssl_cert.as_deref()\n    }\n\n    pub(super) fn ssl_key(&self) -> Option<&CStr> {\n        self.ssl_key.as_deref()\n    }\n\n    pub(super) fn client_flags(&self) -> CapabilityFlags {\n        self.client_flags\n    }\n\n    pub(super) fn ssl_mode(&self) -> Option<mysql_ssl_mode> {\n        self.ssl_mode\n    }\n}\n\nfn decode_into_cstring(s: &str) -> ConnectionResult<CString> {\n    let decoded = percent_decode(s.as_bytes())\n        .decode_utf8()\n        .map_err(|_| connection_url_error())?;\n    CString::new(decoded.as_bytes()).map_err(Into::into)\n}\n\nfn connection_url_error() -> ConnectionError {\n    let msg = \"MySQL connection URLs must be in the form \\\n               `mysql://[[user]:[password]@]host[:port][/database][?unix_socket=socket-path]`\";\n    ConnectionError::InvalidConnectionUrl(msg.into())\n}\n\n#[test]\nfn urls_with_schemes_other_than_mysql_are_errors() {\n    assert!(ConnectionOptions::parse(\"postgres://localhost\").is_err());\n    assert!(ConnectionOptions::parse(\"http://localhost\").is_err());\n    assert!(ConnectionOptions::parse(\"file:///tmp/mysql.sock\").is_err());\n    assert!(ConnectionOptions::parse(\"socket:///tmp/mysql.sock\").is_err());\n    assert!(ConnectionOptions::parse(\"mysql://localhost?database=somedb\").is_err());\n    assert!(ConnectionOptions::parse(\"mysql://localhost\").is_ok());\n}\n\n#[test]\nfn urls_must_have_zero_or_one_path_segments() {\n    assert!(ConnectionOptions::parse(\"mysql://localhost/foo/bar\").is_err());\n    assert!(ConnectionOptions::parse(\"mysql://localhost/foo\").is_ok());\n}\n\n#[test]\nfn first_path_segment_is_treated_as_database() {\n    let foo_cstr = CString::new(\"foo\").unwrap();\n    let bar_cstr = CString::new(\"bar\").unwrap();\n    assert_eq!(\n        Some(&*foo_cstr),\n        ConnectionOptions::parse(\"mysql://localhost/foo\")\n            .unwrap()\n            .database()\n    );\n    assert_eq!(\n        Some(&*bar_cstr),\n        ConnectionOptions::parse(\"mysql://localhost/bar\")\n            .unwrap()\n            .database()\n    );\n    assert_eq!(\n        None,\n        ConnectionOptions::parse(\"mysql://localhost\")\n            .unwrap()\n            .database()\n    );\n}\n\n#[test]\nfn userinfo_should_be_percent_decode() {\n    use self::percent_encoding::{utf8_percent_encode, AsciiSet, CONTROLS};\n    const USERINFO_ENCODE_SET: &AsciiSet = &CONTROLS\n        .add(b' ')\n        .add(b'\"')\n        .add(b'<')\n        .add(b'>')\n        .add(b'`')\n        .add(b'#')\n        .add(b'?')\n        .add(b'{')\n        .add(b'}')\n        .add(b'/')\n        .add(b':')\n        .add(b';')\n        .add(b'=')\n        .add(b'@')\n        .add(b'[')\n        .add(b'\\\\')\n        .add(b']')\n        .add(b'^')\n        .add(b'|');\n\n    let username = \"x#gfuL?4Zuj{n73m}eeJt0\";\n    let encoded_username = utf8_percent_encode(username, USERINFO_ENCODE_SET);\n\n    let password = \"x/gfuL?4Zuj{n73m}eeJt1\";\n    let encoded_password = utf8_percent_encode(password, USERINFO_ENCODE_SET);\n\n    let db_url = format!(\"mysql://{encoded_username}:{encoded_password}@localhost/bar\",);\n    let db_url = Url::parse(&db_url).unwrap();\n\n    let conn_opts = ConnectionOptions::parse(db_url.as_str()).unwrap();\n    let username = CString::new(username.as_bytes()).unwrap();\n    let password = CString::new(password.as_bytes()).unwrap();\n    assert_eq!(username, conn_opts.user);\n    assert_eq!(password, conn_opts.password.unwrap());\n}\n\n#[test]\nfn ipv6_host_not_wrapped_in_brackets() {\n    let host1 = CString::new(\"::1\").unwrap();\n    let host2 = CString::new(\"2001:db8:85a3::8a2e:370:7334\").unwrap();\n\n    assert_eq!(\n        Some(&*host1),\n        ConnectionOptions::parse(\"mysql://[::1]\").unwrap().host()\n    );\n    assert_eq!(\n        Some(&*host2),\n        ConnectionOptions::parse(\"mysql://[2001:db8:85a3::8a2e:370:7334]\")\n            .unwrap()\n            .host()\n    );\n}\n\n#[test]\nfn unix_socket_tests() {\n    let unix_socket = \"/var/run/mysqld.sock\";\n    let username = \"foo\";\n    let password = \"bar\";\n    let db_url = format!(\"mysql://{username}:{password}@localhost?unix_socket={unix_socket}\",);\n    let conn_opts = ConnectionOptions::parse(db_url.as_str()).unwrap();\n    let cstring = |s| CString::new(s).unwrap();\n    assert_eq!(None, conn_opts.host);\n    assert_eq!(None, conn_opts.port);\n    assert_eq!(cstring(username), conn_opts.user);\n    assert_eq!(cstring(password), conn_opts.password.unwrap());\n    assert_eq!(\n        CString::new(unix_socket).unwrap(),\n        conn_opts.unix_socket.unwrap()\n    );\n}\n\n#[test]\nfn ssl_ca_tests() {\n    let ssl_ca = \"/etc/ssl/certs/ca-certificates.crt\";\n    let username = \"foo\";\n    let password = \"bar\";\n    let db_url = format!(\"mysql://{username}:{password}@localhost?ssl_ca={ssl_ca}\",);\n    let conn_opts = ConnectionOptions::parse(db_url.as_str()).unwrap();\n    let cstring = |s| CString::new(s).unwrap();\n    assert_eq!(Some(cstring(\"localhost\")), conn_opts.host);\n    assert_eq!(None, conn_opts.port);\n    assert_eq!(cstring(username), conn_opts.user);\n    assert_eq!(cstring(password), conn_opts.password.unwrap());\n    assert_eq!(CString::new(ssl_ca).unwrap(), conn_opts.ssl_ca.unwrap());\n\n    let url_with_unix_str_and_ssl_ca = format!(\n        \"mysql://{username}:{password}@localhost?unix_socket=/var/run/mysqld.sock&ssl_ca={ssl_ca}\"\n    );\n\n    let conn_opts2 = ConnectionOptions::parse(url_with_unix_str_and_ssl_ca.as_str()).unwrap();\n    assert_eq!(None, conn_opts2.host);\n    assert_eq!(None, conn_opts2.port);\n    assert_eq!(CString::new(ssl_ca).unwrap(), conn_opts2.ssl_ca.unwrap());\n}\n\n#[test]\nfn ssl_cert_tests() {\n    let ssl_cert = \"/etc/ssl/certs/client-cert.crt\";\n    let username = \"foo\";\n    let password = \"bar\";\n    let db_url = format!(\"mysql://{username}:{password}@localhost?ssl_cert={ssl_cert}\");\n    let conn_opts = ConnectionOptions::parse(db_url.as_str()).unwrap();\n    let cstring = |s| CString::new(s).unwrap();\n    assert_eq!(Some(cstring(\"localhost\")), conn_opts.host);\n    assert_eq!(None, conn_opts.port);\n    assert_eq!(cstring(username), conn_opts.user);\n    assert_eq!(cstring(password), conn_opts.password.unwrap());\n    assert_eq!(CString::new(ssl_cert).unwrap(), conn_opts.ssl_cert.unwrap());\n\n    let url_with_unix_str_and_ssl_cert = format!(\n        \"mysql://{username}:{password}@localhost?unix_socket=/var/run/mysqld.sock&ssl_cert={ssl_cert}\"\n    );\n\n    let conn_opts2 = ConnectionOptions::parse(url_with_unix_str_and_ssl_cert.as_str()).unwrap();\n    assert_eq!(None, conn_opts2.host);\n    assert_eq!(None, conn_opts2.port);\n    assert_eq!(\n        CString::new(ssl_cert).unwrap(),\n        conn_opts2.ssl_cert.unwrap()\n    );\n}\n\n#[test]\nfn ssl_key_tests() {\n    let ssl_key = \"/etc/ssl/certs/client-key.crt\";\n    let username = \"foo\";\n    let password = \"bar\";\n    let db_url = format!(\"mysql://{username}:{password}@localhost?ssl_key={ssl_key}\");\n    let conn_opts = ConnectionOptions::parse(db_url.as_str()).unwrap();\n    let cstring = |s| CString::new(s).unwrap();\n    assert_eq!(Some(cstring(\"localhost\")), conn_opts.host);\n    assert_eq!(None, conn_opts.port);\n    assert_eq!(cstring(username), conn_opts.user);\n    assert_eq!(cstring(password), conn_opts.password.unwrap());\n    assert_eq!(CString::new(ssl_key).unwrap(), conn_opts.ssl_key.unwrap());\n\n    let url_with_unix_str_and_ssl_key = format!(\n        \"mysql://{username}:{password}@localhost?unix_socket=/var/run/mysqld.sock&ssl_key={ssl_key}\"\n    );\n\n    let conn_opts2 = ConnectionOptions::parse(url_with_unix_str_and_ssl_key.as_str()).unwrap();\n    assert_eq!(None, conn_opts2.host);\n    assert_eq!(None, conn_opts2.port);\n    assert_eq!(CString::new(ssl_key).unwrap(), conn_opts2.ssl_key.unwrap());\n}\n\n#[test]\nfn ssl_mode() {\n    let ssl_mode = |url| ConnectionOptions::parse(url).unwrap().ssl_mode();\n    assert_eq!(ssl_mode(\"mysql://localhost\"), None);\n    assert_eq!(\n        ssl_mode(\"mysql://localhost?ssl_mode=disabled\"),\n        Some(mysql_ssl_mode::SSL_MODE_DISABLED)\n    );\n    assert_eq!(\n        ssl_mode(\"mysql://localhost?ssl_mode=PREFERRED\"),\n        Some(mysql_ssl_mode::SSL_MODE_PREFERRED)\n    );\n    assert_eq!(\n        ssl_mode(\"mysql://localhost?ssl_mode=required\"),\n        Some(mysql_ssl_mode::SSL_MODE_REQUIRED)\n    );\n    assert_eq!(\n        ssl_mode(\"mysql://localhost?ssl_mode=VERIFY_CA\"),\n        Some(mysql_ssl_mode::SSL_MODE_VERIFY_CA)\n    );\n    assert_eq!(\n        ssl_mode(\"mysql://localhost?ssl_mode=verify_identity\"),\n        Some(mysql_ssl_mode::SSL_MODE_VERIFY_IDENTITY)\n    );\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "3f003bb6dce7f007a554e0503096ced249adcbcb",
    "func": "//! Additional types for generating responses.\n\n#[cfg(feature = \"erased-json\")]\nmod erased_json;\n\n#[cfg(feature = \"attachment\")]\nmod attachment;\n\n#[cfg(feature = \"multipart\")]\npub mod multiple;\n\n#[cfg(feature = \"erased-json\")]\npub use erased_json::ErasedJson;\n\n/// _not_ public API\n#[cfg(feature = \"erased-json\")]\n#[doc(hidden)]\npub use erased_json::private as __private_erased_json;\n\n#[cfg(feature = \"json-lines\")]\n#[doc(no_inline)]\npub use crate::json_lines::JsonLines;\n\n#[cfg(feature = \"attachment\")]\npub use attachment::Attachment;\n\nmacro_rules! mime_response {\n    (\n        $(#[$m:meta])*\n        $ident:ident,\n        $mime:ident,\n    ) => {\n        mime_response! {\n            $(#[$m])*\n            $ident,\n            mime::$mime.as_ref(),\n        }\n    };\n\n    (\n        $(#[$m:meta])*\n        $ident:ident,\n        $mime:expr,\n    ) => {\n        $(#[$m])*\n        #[derive(Clone, Copy, Debug)]\n        #[must_use]\n        pub struct $ident<T>(pub T);\n\n        impl<T> axum::response::IntoResponse for $ident<T>\n        where\n            T: axum::response::IntoResponse,\n        {\n            fn into_response(self) -> axum::response::Response {\n                (\n                    [(\n                        http::header::CONTENT_TYPE,\n                        http::HeaderValue::from_static($mime),\n                    )],\n                    self.0,\n                )\n                    .into_response()\n            }\n        }\n\n        impl<T> From<T> for $ident<T> {\n            fn from(inner: T) -> Self {\n                Self(inner)\n            }\n        }\n    };\n}\n\nmime_response! {\n    /// A JavaScript response.\n    ///\n    /// Will automatically get `Content-Type: application/javascript; charset=utf-8`.\n    JavaScript,\n    APPLICATION_JAVASCRIPT_UTF_8,\n}\n\nmime_response! {\n    /// A CSS response.\n    ///\n    /// Will automatically get `Content-Type: text/css; charset=utf-8`.\n    Css,\n    TEXT_CSS_UTF_8,\n}\n\nmime_response! {\n    /// A WASM response.\n    ///\n    /// Will automatically get `Content-Type: application/wasm`.\n    Wasm,\n    \"application/wasm\",\n}\n\n#[cfg(feature = \"typed-header\")]\n#[doc(no_inline)]\npub use crate::typed_header::TypedHeader;\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "c21474079bb60fceb80e2643853713933ad7f652",
    "func": "use bevy_ecs::{component::Component, prelude::ReflectComponent};\nuse bevy_math::{IVec2, UVec2};\nuse bevy_reflect::Reflect;\n\n#[cfg(feature = \"serialize\")]\nuse bevy_reflect::{ReflectDeserialize, ReflectSerialize};\n\n/// Represents an available monitor as reported by the user's operating system, which can be used\n/// to query information about the display, such as its size, position, and video modes.\n///\n/// Each monitor corresponds to an entity and can be used to position a monitor using\n/// [`crate::window::MonitorSelection::Entity`].\n///\n/// # Warning\n///\n/// This component is synchronized with `winit` through `bevy_winit`, but is effectively\n/// read-only as `winit` does not support changing monitor properties.\n#[derive(Component, Debug, Clone, Reflect)]\n#[cfg_attr(\n    feature = \"serialize\",\n    derive(serde::Serialize, serde::Deserialize),\n    reflect(Serialize, Deserialize)\n)]\n#[reflect(Component, Debug)]\npub struct Monitor {\n    /// The name of the monitor\n    pub name: Option<String>,\n    /// The height of the monitor in physical pixels\n    pub physical_height: u32,\n    /// The width of the monitor in physical pixels\n    pub physical_width: u32,\n    /// The position of the monitor in physical pixels\n    pub physical_position: IVec2,\n    /// The refresh rate of the monitor in millihertz\n    pub refresh_rate_millihertz: Option<u32>,\n    /// The scale factor of the monitor\n    pub scale_factor: f64,\n    /// The video modes that the monitor supports\n    pub video_modes: Vec<VideoMode>,\n}\n\n/// A marker component for the primary monitor\n#[derive(Component, Debug, Clone, Reflect)]\n#[reflect(Component, Debug)]\npub struct PrimaryMonitor;\n\nimpl Monitor {\n    /// Returns the physical size of the monitor in pixels\n    pub fn physical_size(&self) -> UVec2 {\n        UVec2::new(self.physical_width, self.physical_height)\n    }\n}\n\n/// Represents a video mode that a monitor supports\n#[derive(Debug, Clone, Reflect)]\n#[cfg_attr(\n    feature = \"serialize\",\n    derive(serde::Serialize, serde::Deserialize),\n    reflect(Serialize, Deserialize)\n)]\npub struct VideoMode {\n    /// The resolution of the video mode\n    pub physical_size: UVec2,\n    /// The bit depth of the video mode\n    pub bit_depth: u16,\n    /// The refresh rate in millihertz\n    pub refresh_rate_millihertz: u32,\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "a0da0eb7c3c650c599d93b5d22b9cdbd86f56843",
    "func": "use std::fmt::Display;\n\n#[cfg(feature = \"codegen\")]\npub mod generate;\npub mod migrate;\n\n#[cfg(feature = \"codegen\")]\npub use generate::*;\npub use migrate::*;\n\npub fn handle_error<E>(error: E)\nwhere\n    E: Display,\n{\n    eprintln!(\"{error}\");\n    ::std::process::exit(1);\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "681b6f0358fc06e71941d4f54bfc2e5877403fd9",
    "func": "//! Automatic MessagePack (de)serialization support.\n//!\n//! See [`MsgPack`] for further details.\n//!\n//! # Enabling\n//!\n//! This module is only available when the `msgpack` feature is enabled. Enable\n//! it in `Cargo.toml` as follows:\n//!\n//! ```toml\n//! [dependencies.rocket]\n//! version = \"0.6.0-dev\"\n//! features = [\"msgpack\"]\n//! ```\n//!\n//! # Testing\n//!\n//! The [`LocalRequest`] and [`LocalResponse`] types provide [`msgpack()`] and\n//! [`into_msgpack()`] methods to create a request with serialized MessagePack\n//! and deserialize a response as MessagePack, respectively.\n//!\n//! [`LocalRequest`]: crate::local::blocking::LocalRequest\n//! [`LocalResponse`]: crate::local::blocking::LocalResponse\n//! [`msgpack()`]: crate::local::blocking::LocalRequest::msgpack()\n//! [`into_msgpack()`]: crate::local::blocking::LocalResponse::into_msgpack()\n\nuse std::io;\nuse std::ops::{Deref, DerefMut};\n\nuse crate::request::{Request, local_cache};\nuse crate::data::{Limits, Data, FromData, Outcome};\nuse crate::response::{self, Responder, content};\nuse crate::http::Status;\nuse crate::form::prelude as form;\n// use crate::http::uri::fmt;\n\nuse serde::{Serialize, Deserialize};\n\n#[doc(inline)]\npub use rmp_serde::decode::Error;\n\n/// The MessagePack guard: easily consume and return MessagePack.\n///\n/// ## Sending MessagePack\n///\n/// To respond with serialized MessagePack data, return either [`MsgPack<T>`] or\n/// [`Compact<T>`] from your handler. `T` must implement [`serde::Serialize`].\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// # type User = usize;\n/// use rocket::serde::msgpack::MsgPack;\n///\n/// #[get(\"/users/<id>\")]\n/// fn user(id: usize) -> MsgPack<User> {\n///     let user_from_id = User::from(id);\n///     /* ... */\n///     MsgPack(user_from_id)\n/// }\n/// ```\n///\n/// The differences between [`MsgPack<T>`] and [`Compact<T>`] are documented on\n/// [`Compact<T>`]. In most cases, [`MsgPack<T>`] is preferable, although compact\n/// was the default prior to Rocket version 0.6.\n///\n/// ## Receiving MessagePack\n///\n/// `MsgPack` is both a data guard and a form guard.\n///\n/// ### Data Guard\n///\n/// To deserialize request body data as MessagePack, add a `data` route\n/// argument with a target type of `MsgPack<T>`, where `T` is some type you'd\n/// like to parse from JSON. `T` must implement [`serde::Deserialize`].\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// # type User = usize;\n/// use rocket::serde::msgpack::MsgPack;\n///\n/// #[post(\"/users\", format = \"msgpack\", data = \"<user>\")]\n/// fn new_user(user: MsgPack<User>) {\n///     /* ... */\n/// }\n/// ```\n///\n/// You don't _need_ to use `format = \"msgpack\"`, but it _may_ be what you want.\n/// Using `format = msgpack` means that any request that doesn't specify\n/// \"application/msgpack\" as its first `Content-Type:` header parameter will not\n/// be routed to this handler.\n///\n/// ### Form Guard\n///\n/// `MsgPack<T>`, as a form guard, accepts value and data fields and parses the\n/// data as a `T`. Simple use `MsgPack<T>`:\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// # type Metadata = usize;\n/// use rocket::form::{Form, FromForm};\n/// use rocket::serde::msgpack::MsgPack;\n///\n/// #[derive(FromForm)]\n/// struct User<'r> {\n///     name: &'r str,\n///     metadata: MsgPack<Metadata>\n/// }\n///\n/// #[post(\"/users\", data = \"<form>\")]\n/// fn new_user(form: Form<User<'_>>) {\n///     /* ... */\n/// }\n/// ```\n///\n/// ### Incoming Data Limits\n///\n/// The default size limit for incoming MessagePack data is 1MiB. Setting a\n/// limit protects your application from denial of service (DOS) attacks and\n/// from resource exhaustion through high memory consumption. The limit can be\n/// increased by setting the `limits.msgpack` configuration parameter. For\n/// instance, to increase the MessagePack limit to 5MiB for all environments,\n/// you may add the following to your `Rocket.toml`:\n///\n/// ```toml\n/// [global.limits]\n/// msgpack = 5242880\n/// ```\n#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\npub struct MsgPack<T, const COMPACT: bool = false>(pub T);\n\n/// Serializes responses in a compact MesagePack format, where structs are\n/// serialized as arrays of their field values.\n///\n/// To respond with compact MessagePack data, return a `Compact<T>` type,\n/// where `T` implements [`Serialize`] from [`serde`]. The content type of the\n/// response is set to `application/msgpack` automatically.\n///\n/// ```rust\n/// # #[macro_use] extern crate rocket;\n/// # type User = usize;\n/// use rocket::serde::msgpack;\n///\n/// #[get(\"/users/<id>\")]\n/// fn user(id: usize) -> msgpack::Compact<User> {\n///     let user_from_id = User::from(id);\n///     /* ... */\n///     msgpack::MsgPack(user_from_id)\n/// }\n/// ```\n///\n/// Prefer using [`MsgPack<T>`] for request guards, as the named/compact\n/// distinction is not relevant for request data - the correct option is\n/// implemented automatically. Using [`Compact<T>`] as a request guard will\n/// NOT prevent named requests from being accepted.\npub type Compact<T> = MsgPack<T, true>;\n\nimpl<T, const COMPACT: bool> MsgPack<T, COMPACT> {\n    /// Consumes the `MsgPack` wrapper and returns the wrapped item.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # use rocket::serde::msgpack::MsgPack;\n    /// let string = \"Hello\".to_string();\n    /// let my_msgpack: MsgPack<_> = MsgPack(string);\n    /// assert_eq!(my_msgpack.into_inner(), \"Hello\".to_string());\n    /// ```\n    #[inline(always)]\n    pub fn into_inner(self) -> T {\n        self.0\n    }\n}\n\nimpl<'r, T: Deserialize<'r>> MsgPack<T> {\n    fn from_bytes(buf: &'r [u8]) -> Result<Self, Error> {\n        rmp_serde::from_slice(buf).map(MsgPack)\n    }\n\n    async fn from_data(req: &'r Request<'_>, data: Data<'r>) -> Result<Self, Error> {\n        let limit = req.limits().get(\"msgpack\").unwrap_or(Limits::MESSAGE_PACK);\n        let bytes = match data.open(limit).into_bytes().await {\n            Ok(buf) if buf.is_complete() => buf.into_inner(),\n            Ok(_) => {\n                let eof = io::ErrorKind::UnexpectedEof;\n                return Err(Error::InvalidDataRead(io::Error::new(eof, \"data limit exceeded\")));\n            },\n            Err(e) => return Err(Error::InvalidDataRead(e)),\n        };\n\n        Self::from_bytes(local_cache!(req, bytes))\n    }\n}\n\n#[crate::async_trait]\nimpl<'r, T: Deserialize<'r>> FromData<'r> for MsgPack<T> {\n    type Error = Error;\n\n    async fn from_data(req: &'r Request<'_>, data: Data<'r>) -> Outcome<'r, Self> {\n        match Self::from_data(req, data).await {\n            Ok(value) => Outcome::Success(value),\n            Err(Error::InvalidDataRead(e)) if e.kind() == io::ErrorKind::UnexpectedEof => {\n                Outcome::Error((Status::PayloadTooLarge, Error::InvalidDataRead(e)))\n            },\n            | Err(e@Error::TypeMismatch(_))\n            | Err(e@Error::OutOfRange)\n            | Err(e@Error::LengthMismatch(_))\n            => {\n                Outcome::Error((Status::UnprocessableEntity, e))\n            },\n            Err(e) => Outcome::Error((Status::BadRequest, e)),\n        }\n    }\n}\n\n/// Serializes the wrapped value into MessagePack. Returns a response with\n/// Content-Type `MsgPack` and a fixed-size body with the serialization. If\n/// serialization fails, an `Err` of `Status::InternalServerError` is returned.\nimpl<'r, T: Serialize, const COMPACT: bool> Responder<'r, 'static> for MsgPack<T, COMPACT> {\n    fn respond_to(self, req: &'r Request<'_>) -> response::Result<'static> {\n        let maybe_buf = if COMPACT {\n            rmp_serde::to_vec(&self.0)\n        } else {\n            rmp_serde::to_vec_named(&self.0)\n        };\n        let buf = maybe_buf\n            .map_err(|e| {\n                error!(\"MsgPack serialize failure: {}\", e);\n                Status::InternalServerError\n            })?;\n\n        content::RawMsgPack(buf).respond_to(req)\n    }\n}\n\n#[crate::async_trait]\nimpl<'v, T: Deserialize<'v> + Send> form::FromFormField<'v> for MsgPack<T> {\n    // TODO: To implement `from_value`, we need to the raw string so we can\n    // decode it into bytes as opposed to a string as it won't be UTF-8.\n\n    async fn from_data(f: form::DataField<'v, '_>) -> Result<Self, form::Errors<'v>> {\n        Self::from_data(f.request, f.data).await.map_err(|e| {\n            match e {\n                Error::InvalidMarkerRead(e) | Error::InvalidDataRead(e) => e.into(),\n                Error::Utf8Error(e) => e.into(),\n                _ => form::Error::custom(e).into(),\n            }\n        })\n    }\n}\n\n// impl<T: Serialize> fmt::UriDisplay<fmt::Query> for MsgPack<T> {\n//     fn fmt(&self, f: &mut fmt::Formatter<'_, fmt::Query>) -> std::fmt::Result {\n//         let bytes = to_vec(&self.0).map_err(|_| std::fmt::Error)?;\n//         let encoded = crate::http::RawStr::percent_encode_bytes(&bytes);\n//         f.write_value(encoded.as_str())\n//     }\n// }\n\nimpl<T, const COMPACT: bool> From<T> for MsgPack<T, COMPACT> {\n    fn from(value: T) -> Self {\n        MsgPack(value)\n    }\n}\n\nimpl<T, const COMPACT: bool> Deref for MsgPack<T, COMPACT> {\n    type Target = T;\n\n    #[inline(always)]\n    fn deref(&self) -> &T {\n        &self.0\n    }\n}\n\nimpl<T, const COMPACT: bool> DerefMut for MsgPack<T, COMPACT> {\n    #[inline(always)]\n    fn deref_mut(&mut self) -> &mut T {\n        &mut self.0\n    }\n}\n\n/// Deserialize an instance of type `T` from MessagePack encoded bytes.\n///\n/// Deserialization is performed in a zero-copy manner whenever possible.\n///\n/// **_Always_ use [`MsgPack`] to deserialize MessagePack request data.**\n///\n/// # Example\n///\n/// ```\n/// use rocket::serde::{Deserialize, msgpack};\n///\n/// #[derive(Debug, PartialEq, Deserialize)]\n/// #[serde(crate = \"rocket::serde\")]\n/// struct Data<'r> {\n///     framework: &'r str,\n///     stars: usize,\n/// }\n///\n/// let bytes = &[\n///     130, 169, 102, 114, 97, 109, 101, 119, 111, 114, 107, 166, 82, 111,\n///     99, 107, 101, 116, 165, 115, 116, 97, 114, 115, 5\n/// ];\n///\n/// let data: Data = msgpack::from_slice(bytes).unwrap();\n/// assert_eq!(data, Data { framework: \"Rocket\", stars: 5, });\n/// ```\n///\n/// # Errors\n///\n/// Deserialization fails if `v` does not represent a valid MessagePack encoding\n/// of any instance of `T` or if `T`'s `Deserialize` implementation fails\n/// otherwise.\n#[inline(always)]\npub fn from_slice<'a, T>(v: &'a [u8]) -> Result<T, Error>\n    where T: Deserialize<'a>,\n{\n    rmp_serde::from_slice(v)\n}\n\n/// Serialize a `T` into a MessagePack byte vector with compact representation.\n///\n/// The compact representation represents structs as arrays.\n///\n/// **_Always_ use [`Compact`] to serialize MessagePack response data in a\n/// compact format.**\n///\n/// # Example\n///\n/// ```\n/// use rocket::serde::{Deserialize, Serialize, msgpack};\n///\n/// #[derive(Deserialize, Serialize)]\n/// #[serde(crate = \"rocket::serde\")]\n/// struct Data<'r> {\n///     framework: &'r str,\n///     stars: usize,\n/// }\n///\n/// let bytes = &[146, 166, 82, 111, 99, 107, 101, 116, 5];\n/// let data: Data = msgpack::from_slice(bytes).unwrap();\n/// let byte_vec = msgpack::to_compact_vec(&data).unwrap();\n/// assert_eq!(bytes, &byte_vec[..]);\n/// ```\n///\n/// # Errors\n///\n/// Serialization fails if `T`'s `Serialize` implementation fails.\n#[inline(always)]\npub fn to_compact_vec<T>(value: &T) -> Result<Vec<u8>, rmp_serde::encode::Error>\n    where T: Serialize + ?Sized\n{\n    rmp_serde::to_vec(value)\n}\n\n/// Serialize a `T` into a MessagePack byte vector with named representation.\n///\n/// The named representation represents structs as maps with field names.\n///\n/// **_Always_ use [`MsgPack`] to serialize MessagePack response data.**\n///\n/// # Example\n///\n/// ```\n/// use rocket::serde::{Deserialize, Serialize, msgpack};\n///\n/// #[derive(Deserialize, Serialize)]\n/// #[serde(crate = \"rocket::serde\")]\n/// struct Data<'r> {\n///     framework: &'r str,\n///     stars: usize,\n/// }\n///\n/// let bytes = &[\n///     130, 169, 102, 114, 97, 109, 101, 119, 111, 114, 107, 166, 82, 111,\n///     99, 107, 101, 116, 165, 115, 116, 97, 114, 115, 5\n/// ];\n///\n/// let data: Data = msgpack::from_slice(bytes).unwrap();\n/// let byte_vec = msgpack::to_vec(&data).unwrap();\n/// assert_eq!(bytes, &byte_vec[..]);\n/// ```\n///\n/// # Errors\n///\n/// Serialization fails if `T`'s `Serialize` implementation fails.\n#[inline(always)]\npub fn to_vec<T>(value: &T) -> Result<Vec<u8>, rmp_serde::encode::Error>\n    where T: Serialize + ?Sized\n{\n    rmp_serde::to_vec_named(value)\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "9b5398c37db286a44f112ddbd50d89008e43da26",
    "func": "// Copyright 2019-2024 Tauri Programme within The Commons Conservancy\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n\nuse serde::{Deserialize, Serialize};\nuse tauri::{command, ipc::CommandScope};\n\n#[derive(Debug, Deserialize)]\n#[allow(unused)]\npub struct RequestBody {\n  id: i32,\n  name: String,\n}\n\n#[derive(Debug, Deserialize)]\npub struct LogScope {\n  event: String,\n}\n\n#[command]\npub fn log_operation(\n  event: String,\n  payload: Option<String>,\n  command_scope: CommandScope<LogScope>,\n) -> Result<(), &'static str> {\n  if command_scope.denies().iter().any(|s| s.event == event) {\n    Err(\"denied\")\n  } else if !command_scope.allows().iter().any(|s| s.event == event) {\n    Err(\"not allowed\")\n  } else {\n    log::info!(\"{} {:?}\", event, payload);\n    Ok(())\n  }\n}\n\n#[derive(Serialize)]\npub struct ApiResponse {\n  message: String,\n}\n\n#[command]\npub fn perform_request(endpoint: String, body: RequestBody) -> ApiResponse {\n  println!(\"{} {:?}\", endpoint, body);\n  ApiResponse {\n    message: \"message response\".into(),\n  }\n}\n\n#[command]\npub fn echo(request: tauri::ipc::Request<'_>) -> tauri::ipc::Response {\n  tauri::ipc::Response::new(request.body().clone())\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "e301e6090e3801202cb9376f54196ac4eb974898",
    "func": "#[macro_use] extern crate rocket;\n\nuse rocket::local::blocking::Client;\n\n// Test that manual/auto ranking works as expected.\n\n#[get(\"/<_number>\")]\nfn get0(_number: u8) -> &'static str { \"0\" }\n\n#[get(\"/<_number>\", rank = 1)]\nfn get1(_number: u16) -> &'static str { \"1\" }\n\n#[get(\"/<_number>\", rank = 2)]\nfn get2(_number: u32) -> &'static str { \"2\" }\n\n#[get(\"/<_number>\", rank = 3)]\nfn get3(_number: u64) -> &'static str { \"3\" }\n\n#[test]\nfn test_ranking() {\n    let rocket = rocket::build().mount(\"/\", routes![get0, get1, get2, get3]);\n    let client = Client::debug(rocket).unwrap();\n\n    let response = client.get(\"/0\").dispatch();\n    assert_eq!(response.into_string().unwrap(), \"0\");\n\n    let response = client.get(format!(\"/{}\", 1 << 8)).dispatch();\n    assert_eq!(response.into_string().unwrap(), \"1\");\n\n    let response = client.get(format!(\"/{}\", 1 << 16)).dispatch();\n    assert_eq!(response.into_string().unwrap(), \"2\");\n\n    let response = client.get(format!(\"/{}\", 1u64 << 32)).dispatch();\n    assert_eq!(response.into_string().unwrap(), \"3\");\n}\n\n// Test a collision due to same auto rank.\n\n#[get(\"/<_n>\")]\nfn get0b(_n: u8) {  }\n\n#[test]\nfn test_rank_collision() {\n    use rocket::error::ErrorKind;\n\n    let rocket = rocket::build().mount(\"/\", routes![get0, get0b]);\n    let client_result = Client::debug(rocket);\n    match client_result.as_ref().map_err(|e| e.kind()) {\n        Err(ErrorKind::Collisions { .. }) => { /* o.k. */ },\n        Ok(_) => panic!(\"client succeeded unexpectedly\"),\n        Err(e) => panic!(\"expected collision, got {}\", e)\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "a30f7da0fbf9140084e4f57c8d7cf529c8759bcf",
    "func": "//! This example illustrates the usage of the [`QueryData`] derive macro, which allows\n//! defining custom query and filter types.\n//!\n//! While regular tuple queries work great in most of simple scenarios, using custom queries\n//! declared as named structs can bring the following advantages:\n//! - They help to avoid destructuring or using `q.0, q.1, ...` access pattern.\n//! - Adding, removing components or changing items order with structs greatly reduces maintenance\n//!   burden, as you don't need to update statements that destructure tuples, care about order\n//!   of elements, etc. Instead, you can just add or remove places where a certain element is used.\n//! - Named structs enable the composition pattern, that makes query types easier to re-use.\n//! - You can bypass the limit of 15 components that exists for query tuples.\n//!\n//! For more details on the [`QueryData`] derive macro, see the trait documentation.\n\nuse bevy::{\n    ecs::query::{QueryData, QueryFilter},\n    prelude::*,\n};\nuse std::fmt::Debug;\n\nfn main() {\n    App::new()\n        .add_systems(Startup, spawn)\n        .add_systems(\n            Update,\n            (\n                print_components_read_only,\n                print_components_iter_mut,\n                print_components_iter,\n                print_components_tuple,\n            )\n                .chain(),\n        )\n        .run();\n}\n\n#[derive(Component, Debug)]\nstruct ComponentA;\n#[derive(Component, Debug)]\nstruct ComponentB;\n#[derive(Component, Debug)]\nstruct ComponentC;\n#[derive(Component, Debug)]\nstruct ComponentD;\n#[derive(Component, Debug)]\nstruct ComponentZ;\n\n#[derive(QueryData)]\n#[query_data(derive(Debug))]\nstruct ReadOnlyCustomQuery<T: Component + Debug, P: Component + Debug> {\n    entity: Entity,\n    a: &'static ComponentA,\n    b: Option<&'static ComponentB>,\n    nested: NestedQuery,\n    optional_nested: Option<NestedQuery>,\n    optional_tuple: Option<(&'static ComponentB, &'static ComponentZ)>,\n    generic: GenericQuery<T, P>,\n    empty: EmptyQuery,\n}\n\nfn print_components_read_only(\n    query: Query<\n        ReadOnlyCustomQuery<ComponentC, ComponentD>,\n        CustomQueryFilter<ComponentC, ComponentD>,\n    >,\n) {\n    println!(\"Print components (read_only):\");\n    for e in &query {\n        println!(\"Entity: {:?}\", e.entity);\n        println!(\"A: {:?}\", e.a);\n        println!(\"B: {:?}\", e.b);\n        println!(\"Nested: {:?}\", e.nested);\n        println!(\"Optional nested: {:?}\", e.optional_nested);\n        println!(\"Optional tuple: {:?}\", e.optional_tuple);\n        println!(\"Generic: {:?}\", e.generic);\n    }\n    println!();\n}\n\n/// If you are going to mutate the data in a query, you must mark it with the `mutable` attribute.\n///\n/// The [`QueryData`] derive macro will still create a read-only version, which will be have `ReadOnly`\n/// suffix.\n/// Note: if you want to use derive macros with read-only query variants, you need to pass them with\n/// using the `derive` attribute.\n#[derive(QueryData)]\n#[query_data(mutable, derive(Debug))]\nstruct CustomQuery<T: Component + Debug, P: Component + Debug> {\n    entity: Entity,\n    a: &'static mut ComponentA,\n    b: Option<&'static mut ComponentB>,\n    nested: NestedQuery,\n    optional_nested: Option<NestedQuery>,\n    optional_tuple: Option<(NestedQuery, &'static mut ComponentZ)>,\n    generic: GenericQuery<T, P>,\n    empty: EmptyQuery,\n}\n\n// This is a valid query as well, which would iterate over every entity.\n#[derive(QueryData)]\n#[query_data(derive(Debug))]\nstruct EmptyQuery {\n    empty: (),\n}\n\n#[derive(QueryData)]\n#[query_data(derive(Debug))]\nstruct NestedQuery {\n    c: &'static ComponentC,\n    d: Option<&'static ComponentD>,\n}\n\n#[derive(QueryData)]\n#[query_data(derive(Debug))]\nstruct GenericQuery<T: Component, P: Component> {\n    generic: (&'static T, &'static P),\n}\n\n#[derive(QueryFilter)]\nstruct CustomQueryFilter<T: Component, P: Component> {\n    _c: With<ComponentC>,\n    _d: With<ComponentD>,\n    _or: Or<(Added<ComponentC>, Changed<ComponentD>, Without<ComponentZ>)>,\n    _generic_tuple: (With<T>, With<P>),\n}\n\nfn spawn(mut commands: Commands) {\n    commands.spawn((ComponentA, ComponentB, ComponentC, ComponentD));\n}\n\nfn print_components_iter_mut(\n    mut query: Query<\n        CustomQuery<ComponentC, ComponentD>,\n        CustomQueryFilter<ComponentC, ComponentD>,\n    >,\n) {\n    println!(\"Print components (iter_mut):\");\n    for e in &mut query {\n        // Re-declaring the variable to illustrate the type of the actual iterator item.\n        let e: CustomQueryItem<'_, _, _> = e;\n        println!(\"Entity: {:?}\", e.entity);\n        println!(\"A: {:?}\", e.a);\n        println!(\"B: {:?}\", e.b);\n        println!(\"Optional nested: {:?}\", e.optional_nested);\n        println!(\"Optional tuple: {:?}\", e.optional_tuple);\n        println!(\"Nested: {:?}\", e.nested);\n        println!(\"Generic: {:?}\", e.generic);\n    }\n    println!();\n}\n\nfn print_components_iter(\n    query: Query<CustomQuery<ComponentC, ComponentD>, CustomQueryFilter<ComponentC, ComponentD>>,\n) {\n    println!(\"Print components (iter):\");\n    for e in &query {\n        // Re-declaring the variable to illustrate the type of the actual iterator item.\n        let e: CustomQueryReadOnlyItem<'_, _, _> = e;\n        println!(\"Entity: {:?}\", e.entity);\n        println!(\"A: {:?}\", e.a);\n        println!(\"B: {:?}\", e.b);\n        println!(\"Nested: {:?}\", e.nested);\n        println!(\"Generic: {:?}\", e.generic);\n    }\n    println!();\n}\n\ntype NestedTupleQuery<'w> = (&'w ComponentC, &'w ComponentD);\ntype GenericTupleQuery<'w, T, P> = (&'w T, &'w P);\n\nfn print_components_tuple(\n    query: Query<\n        (\n            Entity,\n            &ComponentA,\n            &ComponentB,\n            NestedTupleQuery,\n            GenericTupleQuery<ComponentC, ComponentD>,\n        ),\n        (\n            With<ComponentC>,\n            With<ComponentD>,\n            Or<(Added<ComponentC>, Changed<ComponentD>, Without<ComponentZ>)>,\n        ),\n    >,\n) {\n    println!(\"Print components (tuple):\");\n    for (entity, a, b, nested, (generic_c, generic_d)) in &query {\n        println!(\"Entity: {entity:?}\");\n        println!(\"A: {a:?}\");\n        println!(\"B: {b:?}\");\n        println!(\"Nested: {:?} {:?}\", nested.0, nested.1);\n        println!(\"Generic: {generic_c:?} {generic_d:?}\");\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "7acc8c56031305d6f46f8675d78f2590119865ae",
    "func": "use self::models::*;\nuse diesel::prelude::*;\nuse getting_started_step_1_mysql::*;\n\nfn main() {\n    use self::schema::posts::dsl::*;\n\n    let connection = &mut establish_connection();\n    let results = posts\n        .filter(published.eq(true))\n        .limit(5)\n        .select(Post::as_select())\n        .load(connection)\n        .expect(\"Error loading posts\");\n\n    println!(\"Displaying {} posts\", results.len());\n    for post in results {\n        println!(\"{}\", post.title);\n        println!(\"-----------\\n\");\n        println!(\"{}\", post.body);\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "c01f49839783250fdc8706b0cde191324ea3b5e2",
    "func": "// Copyright 2019-2024 Tauri Programme within The Commons Conservancy\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n\n//! ACL items that are only useful inside of build script/codegen context.\n\nuse std::{\n  collections::{BTreeMap, HashMap},\n  env, fs,\n  path::{Path, PathBuf},\n};\n\nuse crate::{acl::Error, write_if_changed};\n\nuse super::{\n  capability::{Capability, CapabilityFile},\n  manifest::PermissionFile,\n  PERMISSION_SCHEMAS_FOLDER_NAME, PERMISSION_SCHEMA_FILE_NAME,\n};\n\n/// Known name of the folder containing autogenerated permissions.\npub const AUTOGENERATED_FOLDER_NAME: &str = \"autogenerated\";\n\n/// Cargo cfg key for permissions file paths\npub const PERMISSION_FILES_PATH_KEY: &str = \"PERMISSION_FILES_PATH\";\n\n/// Cargo cfg key for global scope schemas\npub const GLOBAL_SCOPE_SCHEMA_PATH_KEY: &str = \"GLOBAL_SCOPE_SCHEMA_PATH\";\n\n/// Allowed permission file extensions\npub const PERMISSION_FILE_EXTENSIONS: &[&str] = &[\"json\", \"toml\"];\n\n/// Known filename of the permission documentation file\npub const PERMISSION_DOCS_FILE_NAME: &str = \"reference.md\";\n\n/// Allowed capability file extensions\nconst CAPABILITY_FILE_EXTENSIONS: &[&str] = &[\"json\", \"toml\"];\n\n/// Known folder name of the capability schemas\nconst CAPABILITIES_SCHEMA_FOLDER_NAME: &str = \"schemas\";\n\nconst CORE_PLUGIN_PERMISSIONS_TOKEN: &str = \"__CORE_PLUGIN__\";\n\nfn parse_permissions(paths: Vec<PathBuf>) -> Result<Vec<PermissionFile>, Error> {\n  let mut permissions = Vec::new();\n  for path in paths {\n    let permission_file = fs::read_to_string(&path).map_err(Error::ReadFile)?;\n    let ext = path.extension().unwrap().to_string_lossy().to_string();\n    let permission: PermissionFile = match ext.as_str() {\n      \"toml\" => toml::from_str(&permission_file)?,\n      \"json\" => serde_json::from_str(&permission_file)?,\n      _ => return Err(Error::UnknownPermissionFormat(ext)),\n    };\n    permissions.push(permission);\n  }\n  Ok(permissions)\n}\n\n/// Write the permissions to a temporary directory and pass it to the immediate consuming crate.\npub fn define_permissions<F: Fn(&Path) -> bool>(\n  pattern: &str,\n  pkg_name: &str,\n  out_dir: &Path,\n  filter_fn: F,\n) -> Result<Vec<PermissionFile>, Error> {\n  let permission_files = glob::glob(pattern)?\n    .flatten()\n    .flat_map(|p| p.canonicalize())\n    // filter extension\n    .filter(|p| {\n      p.extension()\n        .and_then(|e| e.to_str())\n        .map(|e| PERMISSION_FILE_EXTENSIONS.contains(&e))\n        .unwrap_or_default()\n    })\n    .filter(|p| filter_fn(p))\n    // filter schemas\n    .filter(|p| p.parent().unwrap().file_name().unwrap() != PERMISSION_SCHEMAS_FOLDER_NAME)\n    .collect::<Vec<PathBuf>>();\n\n  let pkg_name_valid_path = pkg_name.replace(':', \"-\");\n  let permission_files_path = out_dir.join(format!(\"{}-permission-files\", pkg_name_valid_path));\n  let permission_files_json = serde_json::to_string(&permission_files)?;\n  fs::write(&permission_files_path, permission_files_json).map_err(Error::WriteFile)?;\n\n  if let Some(plugin_name) = pkg_name.strip_prefix(\"tauri:\") {\n    println!(\n      \"cargo:{plugin_name}{CORE_PLUGIN_PERMISSIONS_TOKEN}_{PERMISSION_FILES_PATH_KEY}={}\",\n      permission_files_path.display()\n    );\n  } else {\n    println!(\n      \"cargo:{PERMISSION_FILES_PATH_KEY}={}\",\n      permission_files_path.display()\n    );\n  }\n\n  parse_permissions(permission_files)\n}\n\n/// Read all permissions listed from the defined cargo cfg key value.\npub fn read_permissions() -> Result<HashMap<String, Vec<PermissionFile>>, Error> {\n  let mut permissions_map = HashMap::new();\n\n  for (key, value) in env::vars_os() {\n    let key = key.to_string_lossy();\n\n    if let Some(plugin_crate_name_var) = key\n      .strip_prefix(\"DEP_\")\n      .and_then(|v| v.strip_suffix(&format!(\"_{PERMISSION_FILES_PATH_KEY}\")))\n      .map(|v| {\n        v.strip_suffix(CORE_PLUGIN_PERMISSIONS_TOKEN)\n          .and_then(|v| v.strip_prefix(\"TAURI_\"))\n          .unwrap_or(v)\n      })\n    {\n      let permissions_path = PathBuf::from(value);\n      let permissions_str = fs::read_to_string(&permissions_path).map_err(Error::ReadFile)?;\n      let permissions: Vec<PathBuf> = serde_json::from_str(&permissions_str)?;\n      let permissions = parse_permissions(permissions)?;\n\n      let plugin_crate_name = plugin_crate_name_var.to_lowercase().replace('_', \"-\");\n      let plugin_crate_name = plugin_crate_name\n        .strip_prefix(\"tauri-plugin-\")\n        .map(ToString::to_string)\n        .unwrap_or(plugin_crate_name);\n\n      permissions_map.insert(plugin_crate_name, permissions);\n    }\n  }\n\n  Ok(permissions_map)\n}\n\n/// Define the global scope schema JSON file path if it exists and pass it to the immediate consuming crate.\npub fn define_global_scope_schema(\n  schema: schemars::schema::RootSchema,\n  pkg_name: &str,\n  out_dir: &Path,\n) -> Result<(), Error> {\n  let path = out_dir.join(\"global-scope.json\");\n  fs::write(&path, serde_json::to_vec(&schema)?).map_err(Error::WriteFile)?;\n\n  if let Some(plugin_name) = pkg_name.strip_prefix(\"tauri:\") {\n    println!(\n      \"cargo:{plugin_name}{CORE_PLUGIN_PERMISSIONS_TOKEN}_{GLOBAL_SCOPE_SCHEMA_PATH_KEY}={}\",\n      path.display()\n    );\n  } else {\n    println!(\"cargo:{GLOBAL_SCOPE_SCHEMA_PATH_KEY}={}\", path.display());\n  }\n\n  Ok(())\n}\n\n/// Read all global scope schemas listed from the defined cargo cfg key value.\npub fn read_global_scope_schemas() -> Result<HashMap<String, serde_json::Value>, Error> {\n  let mut schemas_map = HashMap::new();\n\n  for (key, value) in env::vars_os() {\n    let key = key.to_string_lossy();\n\n    if let Some(plugin_crate_name_var) = key\n      .strip_prefix(\"DEP_\")\n      .and_then(|v| v.strip_suffix(&format!(\"_{GLOBAL_SCOPE_SCHEMA_PATH_KEY}\")))\n      .map(|v| {\n        v.strip_suffix(CORE_PLUGIN_PERMISSIONS_TOKEN)\n          .and_then(|v| v.strip_prefix(\"TAURI_\"))\n          .unwrap_or(v)\n      })\n    {\n      let path = PathBuf::from(value);\n      let json = fs::read_to_string(&path).map_err(Error::ReadFile)?;\n      let schema: serde_json::Value = serde_json::from_str(&json)?;\n\n      let plugin_crate_name = plugin_crate_name_var.to_lowercase().replace('_', \"-\");\n      let plugin_crate_name = plugin_crate_name\n        .strip_prefix(\"tauri-plugin-\")\n        .map(ToString::to_string)\n        .unwrap_or(plugin_crate_name);\n\n      schemas_map.insert(plugin_crate_name, schema);\n    }\n  }\n\n  Ok(schemas_map)\n}\n\n/// Parses all capability files with the given glob pattern.\npub fn parse_capabilities(pattern: &str) -> Result<BTreeMap<String, Capability>, Error> {\n  let mut capabilities_map = BTreeMap::new();\n\n  for path in glob::glob(pattern)?\n    .flatten() // filter extension\n    .filter(|p| {\n      p.extension()\n        .and_then(|e| e.to_str())\n        .map(|e| CAPABILITY_FILE_EXTENSIONS.contains(&e))\n        .unwrap_or_default()\n    })\n    // filter schema files\n    // TODO: remove this before stable\n    .filter(|p| p.parent().unwrap().file_name().unwrap() != CAPABILITIES_SCHEMA_FOLDER_NAME)\n  {\n    match CapabilityFile::load(&path)? {\n      CapabilityFile::Capability(capability) => {\n        if capabilities_map.contains_key(&capability.identifier) {\n          return Err(Error::CapabilityAlreadyExists {\n            identifier: capability.identifier,\n          });\n        }\n\n        capabilities_map.insert(capability.identifier.clone(), capability);\n      }\n      CapabilityFile::List(capabilities) | CapabilityFile::NamedList { capabilities } => {\n        for capability in capabilities {\n          if capabilities_map.contains_key(&capability.identifier) {\n            return Err(Error::CapabilityAlreadyExists {\n              identifier: capability.identifier,\n            });\n          }\n\n          capabilities_map.insert(capability.identifier.clone(), capability);\n        }\n      }\n    }\n  }\n\n  Ok(capabilities_map)\n}\n\n/// Permissions that are generated from commands using [`autogenerate_command_permissions`].\npub struct AutogeneratedPermissions {\n  /// The allow permissions generated from commands.\n  pub allowed: Vec<String>,\n  /// The deny permissions generated from commands.\n  pub denied: Vec<String>,\n}\n\n/// Autogenerate permission files for a list of commands.\npub fn autogenerate_command_permissions(\n  path: &Path,\n  commands: &[&str],\n  license_header: &str,\n  schema_ref: bool,\n) -> AutogeneratedPermissions {\n  if !path.exists() {\n    fs::create_dir_all(path).expect(\"unable to create autogenerated commands dir\");\n  }\n\n  let schema_entry = if schema_ref {\n    let cwd = env::current_dir().unwrap();\n    let components_len = path.strip_prefix(&cwd).unwrap_or(path).components().count();\n    let schema_path = (1..components_len)\n      .map(|_| \"..\")\n      .collect::<PathBuf>()\n      .join(PERMISSION_SCHEMAS_FOLDER_NAME)\n      .join(PERMISSION_SCHEMA_FILE_NAME);\n    format!(\n      \"\\n\\\"$schema\\\" = \\\"{}\\\"\\n\",\n      dunce::simplified(&schema_path)\n        .display()\n        .to_string()\n        .replace('\\\\', \"/\")\n    )\n  } else {\n    \"\".to_string()\n  };\n\n  let mut autogenerated = AutogeneratedPermissions {\n    allowed: Vec::new(),\n    denied: Vec::new(),\n  };\n\n  for command in commands {\n    let slugified_command = command.replace('_', \"-\");\n\n    let toml = format!(\n      r###\"{license_header}# Automatically generated - DO NOT EDIT!\n{schema_entry}\n[[permission]]\nidentifier = \"allow-{slugified_command}\"\ndescription = \"Enables the {command} command without any pre-configured scope.\"\ncommands.allow = [\"{command}\"]\n\n[[permission]]\nidentifier = \"deny-{slugified_command}\"\ndescription = \"Denies the {command} command without any pre-configured scope.\"\ncommands.deny = [\"{command}\"]\n\"###,\n    );\n\n    let out_path = path.join(format!(\"{command}.toml\"));\n    write_if_changed(&out_path, toml)\n      .unwrap_or_else(|_| panic!(\"unable to autogenerate {out_path:?}\"));\n\n    autogenerated\n      .allowed\n      .push(format!(\"allow-{slugified_command}\"));\n    autogenerated\n      .denied\n      .push(format!(\"deny-{slugified_command}\"));\n  }\n\n  autogenerated\n}\n\nconst PERMISSION_TABLE_HEADER: &str =\n  \"## Permission Table\\n\\n<table>\\n<tr>\\n<th>Identifier</th>\\n<th>Description</th>\\n</tr>\\n\";\n\n/// Generate a markdown documentation page containing the list of permissions of the plugin.\npub fn generate_docs(\n  permissions: &[PermissionFile],\n  out_dir: &Path,\n  plugin_identifier: &str,\n) -> Result<(), Error> {\n  let mut permission_table = \"\".to_string();\n\n  let mut default_permission = \"## Default Permission\\n\\n\".to_string();\n  let mut contains_default = false;\n\n  fn docs_from(id: &str, description: Option<&str>, plugin_identifier: &str) -> String {\n    let mut docs = format!(\"\\n<tr>\\n<td>\\n\\n`{plugin_identifier}:{id}`\\n\\n</td>\\n\");\n    if let Some(d) = description {\n      docs.push_str(&format!(\"<td>\\n\\n{d}\\n\\n</td>\"));\n    }\n    docs.push_str(\"\\n</tr>\");\n    docs\n  }\n\n  for permission in permissions {\n    for set in &permission.set {\n      permission_table.push_str(&docs_from(\n        &set.identifier,\n        Some(&set.description),\n        plugin_identifier,\n      ));\n      permission_table.push('\\n');\n    }\n\n    if let Some(default) = &permission.default {\n      contains_default = true;\n\n      default_permission.push_str(default.description.as_deref().unwrap_or_default());\n      default_permission.push('\\n');\n      default_permission.push('\\n');\n      for permission in &default.permissions {\n        default_permission.push_str(&format!(\"- `{permission}`\"));\n        default_permission.push('\\n');\n      }\n    }\n\n    for permission in &permission.permission {\n      permission_table.push_str(&docs_from(\n        &permission.identifier,\n        permission.description.as_deref(),\n        plugin_identifier,\n      ));\n      permission_table.push('\\n');\n    }\n  }\n\n  if !contains_default {\n    default_permission = \"\".to_string();\n  }\n\n  let docs =\n    format!(\"{default_permission}\\n{PERMISSION_TABLE_HEADER}\\n{permission_table}</table>\\n\");\n\n  let reference_path = out_dir.join(PERMISSION_DOCS_FILE_NAME);\n  write_if_changed(reference_path, docs).map_err(Error::WriteFile)?;\n\n  Ok(())\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "49e2c7382892b6211f6c6e98ef08a353acd9e6f4",
    "func": "use super::{IntoResponseParts, Response, ResponseParts};\nuse crate::{body::Body, BoxError};\nuse bytes::{buf::Chain, Buf, Bytes, BytesMut};\nuse http::{\n    header::{self, HeaderMap, HeaderName, HeaderValue},\n    Extensions, StatusCode,\n};\nuse http_body::{Frame, SizeHint};\nuse std::{\n    borrow::Cow,\n    convert::Infallible,\n    fmt,\n    pin::Pin,\n    task::{Context, Poll},\n};\n\n/// Trait for generating responses.\n///\n/// Types that implement `IntoResponse` can be returned from handlers.\n///\n/// # Implementing `IntoResponse`\n///\n/// You generally shouldn't have to implement `IntoResponse` manually, as axum\n/// provides implementations for many common types.\n///\n/// However it might be necessary if you have a custom error type that you want\n/// to return from handlers:\n///\n/// ```rust\n/// use axum::{\n///     Router,\n///     body::{self, Bytes},\n///     routing::get,\n///     http::StatusCode,\n///     response::{IntoResponse, Response},\n/// };\n///\n/// enum MyError {\n///     SomethingWentWrong,\n///     SomethingElseWentWrong,\n/// }\n///\n/// impl IntoResponse for MyError {\n///     fn into_response(self) -> Response {\n///         let body = match self {\n///             MyError::SomethingWentWrong => \"something went wrong\",\n///             MyError::SomethingElseWentWrong => \"something else went wrong\",\n///         };\n///\n///         // it's often easiest to implement `IntoResponse` by calling other implementations\n///         (StatusCode::INTERNAL_SERVER_ERROR, body).into_response()\n///     }\n/// }\n///\n/// // `Result<impl IntoResponse, MyError>` can now be returned from handlers\n/// let app = Router::new().route(\"/\", get(handler));\n///\n/// async fn handler() -> Result<(), MyError> {\n///     Err(MyError::SomethingWentWrong)\n/// }\n/// # let _: Router = app;\n/// ```\n///\n/// Or if you have a custom body type you'll also need to implement\n/// `IntoResponse` for it:\n///\n/// ```rust\n/// use axum::{\n///     body,\n///     routing::get,\n///     response::{IntoResponse, Response},\n///     body::Body,\n///     Router,\n/// };\n/// use http::HeaderMap;\n/// use bytes::Bytes;\n/// use http_body::Frame;\n/// use std::{\n///     convert::Infallible,\n///     task::{Poll, Context},\n///     pin::Pin,\n/// };\n///\n/// struct MyBody;\n///\n/// // First implement `Body` for `MyBody`. This could for example use\n/// // some custom streaming protocol.\n/// impl http_body::Body for MyBody {\n///     type Data = Bytes;\n///     type Error = Infallible;\n///\n///     fn poll_frame(\n///         self: Pin<&mut Self>,\n///         cx: &mut Context<'_>,\n///     ) -> Poll<Option<Result<Frame<Self::Data>, Self::Error>>> {\n///         # unimplemented!()\n///         // ...\n///     }\n/// }\n///\n/// // Now we can implement `IntoResponse` directly for `MyBody`\n/// impl IntoResponse for MyBody {\n///     fn into_response(self) -> Response {\n///         Response::new(Body::new(self))\n///     }\n/// }\n///\n/// // `MyBody` can now be returned from handlers.\n/// let app = Router::new().route(\"/\", get(|| async { MyBody }));\n/// # let _: Router = app;\n/// ```\npub trait IntoResponse {\n    /// Create a response.\n    #[must_use]\n    fn into_response(self) -> Response;\n}\n\nimpl IntoResponse for StatusCode {\n    fn into_response(self) -> Response {\n        let mut res = ().into_response();\n        *res.status_mut() = self;\n        res\n    }\n}\n\nimpl IntoResponse for () {\n    fn into_response(self) -> Response {\n        Body::empty().into_response()\n    }\n}\n\nimpl IntoResponse for Infallible {\n    fn into_response(self) -> Response {\n        match self {}\n    }\n}\n\nimpl<T, E> IntoResponse for Result<T, E>\nwhere\n    T: IntoResponse,\n    E: IntoResponse,\n{\n    fn into_response(self) -> Response {\n        match self {\n            Ok(value) => value.into_response(),\n            Err(err) => err.into_response(),\n        }\n    }\n}\n\nimpl<B> IntoResponse for Response<B>\nwhere\n    B: http_body::Body<Data = Bytes> + Send + 'static,\n    B::Error: Into<BoxError>,\n{\n    fn into_response(self) -> Response {\n        self.map(Body::new)\n    }\n}\n\nimpl IntoResponse for http::response::Parts {\n    fn into_response(self) -> Response {\n        Response::from_parts(self, Body::empty())\n    }\n}\n\nimpl IntoResponse for Body {\n    fn into_response(self) -> Response {\n        Response::new(self)\n    }\n}\n\nimpl IntoResponse for &'static str {\n    fn into_response(self) -> Response {\n        Cow::Borrowed(self).into_response()\n    }\n}\n\nimpl IntoResponse for String {\n    fn into_response(self) -> Response {\n        Cow::<'static, str>::Owned(self).into_response()\n    }\n}\n\nimpl IntoResponse for Box<str> {\n    fn into_response(self) -> Response {\n        String::from(self).into_response()\n    }\n}\n\nimpl IntoResponse for Cow<'static, str> {\n    fn into_response(self) -> Response {\n        let mut res = Body::from(self).into_response();\n        res.headers_mut().insert(\n            header::CONTENT_TYPE,\n            HeaderValue::from_static(mime::TEXT_PLAIN_UTF_8.as_ref()),\n        );\n        res\n    }\n}\n\nimpl IntoResponse for Bytes {\n    fn into_response(self) -> Response {\n        let mut res = Body::from(self).into_response();\n        res.headers_mut().insert(\n            header::CONTENT_TYPE,\n            HeaderValue::from_static(mime::APPLICATION_OCTET_STREAM.as_ref()),\n        );\n        res\n    }\n}\n\nimpl IntoResponse for BytesMut {\n    fn into_response(self) -> Response {\n        self.freeze().into_response()\n    }\n}\n\nimpl<T, U> IntoResponse for Chain<T, U>\nwhere\n    T: Buf + Unpin + Send + 'static,\n    U: Buf + Unpin + Send + 'static,\n{\n    fn into_response(self) -> Response {\n        let (first, second) = self.into_inner();\n        let mut res = Response::new(Body::new(BytesChainBody {\n            first: Some(first),\n            second: Some(second),\n        }));\n        res.headers_mut().insert(\n            header::CONTENT_TYPE,\n            HeaderValue::from_static(mime::APPLICATION_OCTET_STREAM.as_ref()),\n        );\n        res\n    }\n}\n\nstruct BytesChainBody<T, U> {\n    first: Option<T>,\n    second: Option<U>,\n}\n\nimpl<T, U> http_body::Body for BytesChainBody<T, U>\nwhere\n    T: Buf + Unpin,\n    U: Buf + Unpin,\n{\n    type Data = Bytes;\n    type Error = Infallible;\n\n    fn poll_frame(\n        mut self: Pin<&mut Self>,\n        _cx: &mut Context<'_>,\n    ) -> Poll<Option<Result<Frame<Self::Data>, Self::Error>>> {\n        if let Some(mut buf) = self.first.take() {\n            let bytes = buf.copy_to_bytes(buf.remaining());\n            return Poll::Ready(Some(Ok(Frame::data(bytes))));\n        }\n\n        if let Some(mut buf) = self.second.take() {\n            let bytes = buf.copy_to_bytes(buf.remaining());\n            return Poll::Ready(Some(Ok(Frame::data(bytes))));\n        }\n\n        Poll::Ready(None)\n    }\n\n    fn is_end_stream(&self) -> bool {\n        self.first.is_none() && self.second.is_none()\n    }\n\n    fn size_hint(&self) -> SizeHint {\n        match (self.first.as_ref(), self.second.as_ref()) {\n            (Some(first), Some(second)) => {\n                let total_size = first.remaining() + second.remaining();\n                SizeHint::with_exact(total_size as u64)\n            }\n            (Some(buf), None) => SizeHint::with_exact(buf.remaining() as u64),\n            (None, Some(buf)) => SizeHint::with_exact(buf.remaining() as u64),\n            (None, None) => SizeHint::with_exact(0),\n        }\n    }\n}\n\nimpl IntoResponse for &'static [u8] {\n    fn into_response(self) -> Response {\n        Cow::Borrowed(self).into_response()\n    }\n}\n\nimpl<const N: usize> IntoResponse for &'static [u8; N] {\n    fn into_response(self) -> Response {\n        self.as_slice().into_response()\n    }\n}\n\nimpl<const N: usize> IntoResponse for [u8; N] {\n    fn into_response(self) -> Response {\n        self.to_vec().into_response()\n    }\n}\n\nimpl IntoResponse for Vec<u8> {\n    fn into_response(self) -> Response {\n        Cow::<'static, [u8]>::Owned(self).into_response()\n    }\n}\n\nimpl IntoResponse for Box<[u8]> {\n    fn into_response(self) -> Response {\n        Vec::from(self).into_response()\n    }\n}\n\nimpl IntoResponse for Cow<'static, [u8]> {\n    fn into_response(self) -> Response {\n        let mut res = Body::from(self).into_response();\n        res.headers_mut().insert(\n            header::CONTENT_TYPE,\n            HeaderValue::from_static(mime::APPLICATION_OCTET_STREAM.as_ref()),\n        );\n        res\n    }\n}\n\nimpl<R> IntoResponse for (StatusCode, R)\nwhere\n    R: IntoResponse,\n{\n    fn into_response(self) -> Response {\n        let mut res = self.1.into_response();\n        *res.status_mut() = self.0;\n        res\n    }\n}\n\nimpl IntoResponse for HeaderMap {\n    fn into_response(self) -> Response {\n        let mut res = ().into_response();\n        *res.headers_mut() = self;\n        res\n    }\n}\n\nimpl IntoResponse for Extensions {\n    fn into_response(self) -> Response {\n        let mut res = ().into_response();\n        *res.extensions_mut() = self;\n        res\n    }\n}\n\nimpl<K, V, const N: usize> IntoResponse for [(K, V); N]\nwhere\n    K: TryInto<HeaderName>,\n    K::Error: fmt::Display,\n    V: TryInto<HeaderValue>,\n    V::Error: fmt::Display,\n{\n    fn into_response(self) -> Response {\n        (self, ()).into_response()\n    }\n}\n\nimpl<R> IntoResponse for (http::response::Parts, R)\nwhere\n    R: IntoResponse,\n{\n    fn into_response(self) -> Response {\n        let (parts, res) = self;\n        (parts.status, parts.headers, parts.extensions, res).into_response()\n    }\n}\n\nimpl<R> IntoResponse for (http::response::Response<()>, R)\nwhere\n    R: IntoResponse,\n{\n    fn into_response(self) -> Response {\n        let (template, res) = self;\n        let (parts, ()) = template.into_parts();\n        (parts, res).into_response()\n    }\n}\n\nimpl<R> IntoResponse for (R,)\nwhere\n    R: IntoResponse,\n{\n    fn into_response(self) -> Response {\n        let (res,) = self;\n        res.into_response()\n    }\n}\n\nmacro_rules! impl_into_response {\n    ( $($ty:ident),* $(,)? ) => {\n        #[allow(non_snake_case)]\n        impl<R, $($ty,)*> IntoResponse for ($($ty),*, R)\n        where\n            $( $ty: IntoResponseParts, )*\n            R: IntoResponse,\n        {\n            fn into_response(self) -> Response {\n                let ($($ty),*, res) = self;\n\n                let res = res.into_response();\n                let parts = ResponseParts { res };\n\n                $(\n                    let parts = match $ty.into_response_parts(parts) {\n                        Ok(parts) => parts,\n                        Err(err) => {\n                            return err.into_response();\n                        }\n                    };\n                )*\n\n                parts.res\n            }\n        }\n\n        #[allow(non_snake_case)]\n        impl<R, $($ty,)*> IntoResponse for (StatusCode, $($ty),*, R)\n        where\n            $( $ty: IntoResponseParts, )*\n            R: IntoResponse,\n        {\n            fn into_response(self) -> Response {\n                let (status, $($ty),*, res) = self;\n\n                let res = res.into_response();\n                let parts = ResponseParts { res };\n\n                $(\n                    let parts = match $ty.into_response_parts(parts) {\n                        Ok(parts) => parts,\n                        Err(err) => {\n                            return err.into_response();\n                        }\n                    };\n                )*\n\n                (status, parts.res).into_response()\n            }\n        }\n\n        #[allow(non_snake_case)]\n        impl<R, $($ty,)*> IntoResponse for (http::response::Parts, $($ty),*, R)\n        where\n            $( $ty: IntoResponseParts, )*\n            R: IntoResponse,\n        {\n            fn into_response(self) -> Response {\n                let (outer_parts, $($ty),*, res) = self;\n\n                let res = res.into_response();\n                let parts = ResponseParts { res };\n                $(\n                    let parts = match $ty.into_response_parts(parts) {\n                        Ok(parts) => parts,\n                        Err(err) => {\n                            return err.into_response();\n                        }\n                    };\n                )*\n\n                (outer_parts, parts.res).into_response()\n            }\n        }\n\n        #[allow(non_snake_case)]\n        impl<R, $($ty,)*> IntoResponse for (http::response::Response<()>, $($ty),*, R)\n        where\n            $( $ty: IntoResponseParts, )*\n            R: IntoResponse,\n        {\n            fn into_response(self) -> Response {\n                let (template, $($ty),*, res) = self;\n                let (parts, ()) = template.into_parts();\n                (parts, $($ty),*, res).into_response()\n            }\n        }\n    }\n}\n\nall_the_tuples_no_last_special_case!(impl_into_response);\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "7ef4f990dfb283a86c837d6232c2a23d44dc6142",
    "func": "use alloc::borrow::Cow;\n\nuse super::{IntoSystem, ReadOnlySystem, System};\nuse crate::{\n    schedule::InternedSystemSet,\n    system::{input::SystemInput, SystemIn},\n    world::unsafe_world_cell::UnsafeWorldCell,\n};\n\n/// Customizes the behavior of an [`AdapterSystem`]\n///\n/// # Examples\n///\n/// ```\n/// # use bevy_ecs::prelude::*;\n/// use bevy_ecs::system::{Adapt, AdapterSystem};\n///\n/// // A system adapter that inverts the result of a system.\n/// // NOTE: Instead of manually implementing this, you can just use `bevy_ecs::schedule::common_conditions::not`.\n/// pub type NotSystem<S> = AdapterSystem<NotMarker, S>;\n///\n/// // This struct is used to customize the behavior of our adapter.\n/// pub struct NotMarker;\n///\n/// impl<S> Adapt<S> for NotMarker\n/// where\n///     S: System,\n///     S::Out: std::ops::Not,\n/// {\n///     type In = S::In;\n///     type Out = <S::Out as std::ops::Not>::Output;\n///\n///     fn adapt(\n///         &mut self,\n///         input: <Self::In as SystemInput>::Inner<'_>,\n///         run_system: impl FnOnce(SystemIn<'_, S>) -> S::Out,\n///     ) -> Self::Out {\n///         !run_system(input)\n///     }\n/// }\n/// # let mut world = World::new();\n/// # let mut system = NotSystem::new(NotMarker, IntoSystem::into_system(|| false), \"\".into());\n/// # system.initialize(&mut world);\n/// # assert!(system.run((), &mut world));\n/// ```\n#[diagnostic::on_unimplemented(\n    message = \"`{Self}` can not adapt a system of type `{S}`\",\n    label = \"invalid system adapter\"\n)]\npub trait Adapt<S: System>: Send + Sync + 'static {\n    /// The [input](System::In) type for an [`AdapterSystem`].\n    type In: SystemInput;\n    /// The [output](System::Out) type for an [`AdapterSystem`].\n    type Out;\n\n    /// When used in an [`AdapterSystem`], this function customizes how the system\n    /// is run and how its inputs/outputs are adapted.\n    fn adapt(\n        &mut self,\n        input: <Self::In as SystemInput>::Inner<'_>,\n        run_system: impl FnOnce(SystemIn<'_, S>) -> S::Out,\n    ) -> Self::Out;\n}\n\n/// An [`IntoSystem`] creating an instance of [`AdapterSystem`].\n#[derive(Clone)]\npub struct IntoAdapterSystem<Func, S> {\n    func: Func,\n    system: S,\n}\n\nimpl<Func, S> IntoAdapterSystem<Func, S> {\n    /// Creates a new [`IntoSystem`] that uses `func` to adapt `system`, via the [`Adapt`] trait.\n    pub const fn new(func: Func, system: S) -> Self {\n        Self { func, system }\n    }\n}\n\n#[doc(hidden)]\npub struct IsAdapterSystemMarker;\n\nimpl<Func, S, I, O, M> IntoSystem<Func::In, Func::Out, (IsAdapterSystemMarker, I, O, M)>\n    for IntoAdapterSystem<Func, S>\nwhere\n    Func: Adapt<S::System>,\n    I: SystemInput,\n    S: IntoSystem<I, O, M>,\n{\n    type System = AdapterSystem<Func, S::System>;\n\n    // Required method\n    fn into_system(this: Self) -> Self::System {\n        let system = IntoSystem::into_system(this.system);\n        let name = system.name();\n        AdapterSystem::new(this.func, system, name)\n    }\n}\n\n/// A [`System`] that takes the output of `S` and transforms it by applying `Func` to it.\n#[derive(Clone)]\npub struct AdapterSystem<Func, S> {\n    func: Func,\n    system: S,\n    name: Cow<'static, str>,\n}\n\nimpl<Func, S> AdapterSystem<Func, S>\nwhere\n    Func: Adapt<S>,\n    S: System,\n{\n    /// Creates a new [`System`] that uses `func` to adapt `system`, via the [`Adapt`] trait.\n    pub const fn new(func: Func, system: S, name: Cow<'static, str>) -> Self {\n        Self { func, system, name }\n    }\n}\n\nimpl<Func, S> System for AdapterSystem<Func, S>\nwhere\n    Func: Adapt<S>,\n    S: System,\n{\n    type In = Func::In;\n    type Out = Func::Out;\n\n    fn name(&self) -> Cow<'static, str> {\n        self.name.clone()\n    }\n\n    fn component_access(&self) -> &crate::query::Access<crate::component::ComponentId> {\n        self.system.component_access()\n    }\n\n    #[inline]\n    fn archetype_component_access(\n        &self,\n    ) -> &crate::query::Access<crate::archetype::ArchetypeComponentId> {\n        self.system.archetype_component_access()\n    }\n\n    fn is_send(&self) -> bool {\n        self.system.is_send()\n    }\n\n    fn is_exclusive(&self) -> bool {\n        self.system.is_exclusive()\n    }\n\n    fn has_deferred(&self) -> bool {\n        self.system.has_deferred()\n    }\n\n    #[inline]\n    unsafe fn run_unsafe(\n        &mut self,\n        input: SystemIn<'_, Self>,\n        world: UnsafeWorldCell,\n    ) -> Self::Out {\n        // SAFETY: `system.run_unsafe` has the same invariants as `self.run_unsafe`.\n        self.func.adapt(input, |input| unsafe {\n            self.system.run_unsafe(input, world)\n        })\n    }\n\n    #[inline]\n    fn run(&mut self, input: SystemIn<'_, Self>, world: &mut crate::prelude::World) -> Self::Out {\n        self.func\n            .adapt(input, |input| self.system.run(input, world))\n    }\n\n    #[inline]\n    fn apply_deferred(&mut self, world: &mut crate::prelude::World) {\n        self.system.apply_deferred(world);\n    }\n\n    #[inline]\n    fn queue_deferred(&mut self, world: crate::world::DeferredWorld) {\n        self.system.queue_deferred(world);\n    }\n\n    #[inline]\n    unsafe fn validate_param_unsafe(&mut self, world: UnsafeWorldCell) -> bool {\n        // SAFETY: Delegate to other `System` implementations.\n        unsafe { self.system.validate_param_unsafe(world) }\n    }\n\n    fn initialize(&mut self, world: &mut crate::prelude::World) {\n        self.system.initialize(world);\n    }\n\n    #[inline]\n    fn update_archetype_component_access(&mut self, world: UnsafeWorldCell) {\n        self.system.update_archetype_component_access(world);\n    }\n\n    fn check_change_tick(&mut self, change_tick: crate::component::Tick) {\n        self.system.check_change_tick(change_tick);\n    }\n\n    fn default_system_sets(&self) -> Vec<InternedSystemSet> {\n        self.system.default_system_sets()\n    }\n\n    fn get_last_run(&self) -> crate::component::Tick {\n        self.system.get_last_run()\n    }\n\n    fn set_last_run(&mut self, last_run: crate::component::Tick) {\n        self.system.set_last_run(last_run);\n    }\n}\n\n// SAFETY: The inner system is read-only.\nunsafe impl<Func, S> ReadOnlySystem for AdapterSystem<Func, S>\nwhere\n    Func: Adapt<S>,\n    S: ReadOnlySystem,\n{\n}\n\nimpl<F, S, Out> Adapt<S> for F\nwhere\n    F: Send + Sync + 'static + FnMut(S::Out) -> Out,\n    S: System,\n{\n    type In = S::In;\n    type Out = Out;\n\n    fn adapt(\n        &mut self,\n        input: <Self::In as SystemInput>::Inner<'_>,\n        run_system: impl FnOnce(SystemIn<'_, S>) -> S::Out,\n    ) -> Out {\n        self(run_system(input))\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "4033f88a84715d6383d917a6a8a73075738cf659",
    "func": "use std::{io::Write as _, path::PathBuf};\n\nfn check_gnu() {\n    // WARN about wry support on windows gnu targets. GNU windows targets don't work well in wry currently\n    if std::env::var(\"CARGO_CFG_WINDOWS\").is_ok()\n        && std::env::var(\"CARGO_CFG_TARGET_ENV\").unwrap() == \"gnu\"\n        && !cfg!(feature = \"gnu\")\n    {\n        println!(\"cargo:warning=GNU windows targets have some limitations within Wry. Using the MSVC windows toolchain is recommended. If you would like to use continue using GNU, you can read https://github.com/wravery/webview2-rs#cross-compilation and disable this warning by adding the gnu feature to dioxus-desktop in your Cargo.toml\")\n    }\n\n    // To prepare for a release, we add extra examples to desktop for doc scraping and copy assets from the workspace to make those examples compile\n    if option_env!(\"DIOXUS_RELEASE\").is_some() {\n        // Append EXAMPLES_TOML to the cargo.toml\n        let cargo_toml = std::fs::OpenOptions::new()\n            .append(true)\n            .open(\"Cargo.toml\")\n            .unwrap();\n        let mut write = std::io::BufWriter::new(cargo_toml);\n        write.write_all(EXAMPLES_TOML.as_bytes()).unwrap();\n\n        // Copy the assets from the workspace to the examples directory\n        let crate_dir = PathBuf::from(std::env::var(\"CARGO_MANIFEST_DIR\").unwrap());\n        let workspace_dir = crate_dir.parent().unwrap().parent().unwrap();\n        let workspace_assets_dir = workspace_dir.join(\"examples\").join(\"assets\");\n        let desktop_assets_dir = PathBuf::from(\"examples\").join(\"assets\");\n        std::fs::create_dir_all(&desktop_assets_dir).unwrap();\n        // move all files from the workspace assets dir to the desktop assets dir\n        for entry in std::fs::read_dir(workspace_assets_dir).unwrap() {\n            let entry = entry.unwrap();\n            let path = entry.path();\n            if path.is_file() {\n                std::fs::copy(&path, desktop_assets_dir.join(path.file_name().unwrap())).unwrap();\n            }\n        }\n    }\n}\n\nfn compile_ts() {\n    // If any TS files change, re-run the build script\n    lazy_js_bundle::LazyTypeScriptBindings::new()\n        .with_watching(\"./src/ts\")\n        .with_binding(\"./src/ts/native_eval.ts\", \"./src/js/native_eval.js\")\n        .run();\n}\n\nfn main() {\n    check_gnu();\n    compile_ts();\n}\n\nconst EXAMPLES_TOML: &str = r#\"\n# Most of the examples live in the workspace. We include some here so that docs.rs can scrape our examples for better inline docs\n[[example]]\nname = \"video_stream\"\npath = \"../../examples/video_stream.rs\"\ndoc-scrape-examples = true\n\n[[example]]\nname = \"suspense\"\npath = \"../../examples/suspense.rs\"\ndoc-scrape-examples = true\n\n[[example]]\nname = \"calculator_mutable\"\npath = \"../../examples/calculator_mutable.rs\"\ndoc-scrape-examples = true\n\n[[example]]\nname = \"custom_html\"\npath = \"../../examples/custom_html.rs\"\ndoc-scrape-examples = true\n\n[[example]]\nname = \"custom_menu\"\npath = \"../../examples/custom_menu.rs\"\ndoc-scrape-examples = true\n\n[[example]]\nname = \"errors\"\npath = \"../../examples/errors.rs\"\ndoc-scrape-examples = true\n\n[[example]]\nname = \"future\"\npath = \"../../examples/future.rs\"\ndoc-scrape-examples = true\n\n[[example]]\nname = \"hydration\"\npath = \"../../examples/hydration.rs\"\ndoc-scrape-examples = true\n\n[[example]]\nname = \"multiwindow\"\npath = \"../../examples/multiwindow.rs\"\ndoc-scrape-examples = true\n\n[[example]]\nname = \"overlay\"\npath = \"../../examples/overlay.rs\"\ndoc-scrape-examples = true\n\n[[example]]\nname = \"popup\"\npath = \"../../examples/popup.rs\"\ndoc-scrape-examples = true\n\n[[example]]\nname = \"read_size\"\npath = \"../../examples/read_size.rs\"\ndoc-scrape-examples = true\n\n[[example]]\nname = \"shortcut\"\npath = \"../../examples/shortcut.rs\"\ndoc-scrape-examples = true\n\n[[example]]\nname = \"streams\"\npath = \"../../examples/streams.rs\"\ndoc-scrape-examples = true\n\n[[example]]\nname = \"window_event\"\npath = \"../../examples/window_event.rs\"\ndoc-scrape-examples = true\n\n[[example]]\nname = \"window_focus\"\npath = \"../../examples/window_focus.rs\"\ndoc-scrape-examples = true\n\n[[example]]\nname = \"window_zoom\"\npath = \"../../examples/window_zoom.rs\"\ndoc-scrape-examples = true\"#;\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "c0211c2b362ec2b0c459fe557ea8764ef1f78437",
    "func": "//! SeaORM Entity. Generated by sea-orm-codegen 0.1.0\n\nuse sea_orm::entity::prelude:: * ;\nuse serde::{Deserialize,Serialize};\n\n#[derive(Copy, Clone, Default, Debug, DeriveEntity)]\npub struct Entity;\n\nimpl EntityName for Entity {\n    fn table_name(&self) -> &str {\n        \"cake\"\n    }\n}\n\n#[derive(Clone, Debug, PartialEq, DeriveModel, DeriveActiveModel, Eq, Serialize, Deserialize)]\npub struct Model {\n    #[serde(skip_deserializing)]\n    pub id: i32,\n    pub name: Option<String> ,\n}\n\n#[derive(Copy, Clone, Debug, EnumIter, DeriveColumn)]\npub enum Column {\n    Id,\n    Name,\n}\n\n#[derive(Copy, Clone, Debug, EnumIter, DerivePrimaryKey)]\npub enum PrimaryKey {\n    Id,\n}\n\nimpl PrimaryKeyTrait for PrimaryKey {\n    type ValueType = i32;\n\n    fn auto_increment() -> bool {\n        true\n    }\n}\n\n#[derive(Copy, Clone, Debug, EnumIter)]\npub enum Relation {\n    Fruit,\n}\n\nimpl ColumnTrait for Column {\n    type EntityName = Entity;\n    fn def(&self) -> ColumnDef {\n        match self {\n            Self::Id => ColumnType::Integer.def(),\n            Self::Name => ColumnType::Text.def().null(),\n        }\n    }\n}\n\nimpl RelationTrait for Relation {\n    fn def(&self) -> RelationDef {\n        match self {\n            Self::Fruit => Entity::has_many(super::fruit::Entity).into(),\n        }\n    }\n}\n\nimpl Related<super::fruit::Entity> for Entity {\n    fn to() -> RelationDef {\n        Relation::Fruit.def()\n    }\n}\n\nimpl Related<super::filling::Entity> for Entity {\n    fn to() -> RelationDef {\n        super::cake_filling::Relation::Filling.def()\n    }\n    fn via() -> Option<RelationDef> {\n        Some(super::cake_filling::Relation::Cake.def().rev())\n    }\n}\n\nimpl ActiveModelBehavior for ActiveModel {}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "0d245f6667548e696f5a7b8a841e70b4e022f6a5",
    "func": "//! A test to confirm that `bevy` doesn't regress its system ambiguities count when using [`DefaultPlugins`].\n//! This is run in CI.\n//!\n//! Note that because this test requires rendering, it isn't actually an integration test!\n//! Instead, it's secretly an example: you can run this test manually using `cargo run --example ambiguity_detection`.\n\nuse bevy::{\n    ecs::schedule::{InternedScheduleLabel, LogLevel, ScheduleBuildSettings},\n    prelude::*,\n    render::pipelined_rendering::RenderExtractApp,\n    utils::HashMap,\n};\n\nfn main() {\n    let mut app = App::new();\n    app.add_plugins(DefaultPlugins);\n\n    let main_app = app.main_mut();\n    configure_ambiguity_detection(main_app);\n    let render_extract_app = app.sub_app_mut(RenderExtractApp);\n    configure_ambiguity_detection(render_extract_app);\n\n    // Ambiguities in the RenderApp are currently allowed.\n    // Eventually, we should forbid these: see https://github.com/bevyengine/bevy/issues/7386\n    // Uncomment the lines below to show the current ambiguities in the RenderApp.\n    // let sub_app = app.sub_app_mut(bevy_render::RenderApp);\n    // configure_ambiguity_detection(sub_app);\n\n    app.finish();\n    app.cleanup();\n    app.update();\n\n    let main_app_ambiguities = count_ambiguities(app.main());\n    assert_eq!(\n        main_app_ambiguities.total(),\n        0,\n        \"Main app has unexpected ambiguities among the following schedules: \\n{main_app_ambiguities:#?}.\",\n    );\n\n    // RenderApp is not checked here, because it is not within the App at this point.\n    let render_extract_ambiguities = count_ambiguities(app.sub_app(RenderExtractApp));\n    assert_eq!(\n        render_extract_ambiguities.total(),\n        0,\n        \"RenderExtract app has unexpected ambiguities among the following schedules: \\n{render_extract_ambiguities:#?}\",\n    );\n}\n\n/// Contains the number of conflicting systems per schedule.\n#[derive(Debug, Deref, DerefMut)]\nstruct AmbiguitiesCount(pub HashMap<InternedScheduleLabel, usize>);\n\nimpl AmbiguitiesCount {\n    fn total(&self) -> usize {\n        self.values().sum()\n    }\n}\n\nfn configure_ambiguity_detection(sub_app: &mut SubApp) {\n    let mut schedules = sub_app.world_mut().resource_mut::<Schedules>();\n    for (_, schedule) in schedules.iter_mut() {\n        schedule.set_build_settings(ScheduleBuildSettings {\n            // NOTE: you can change this to `LogLevel::Ignore` to easily see the current number of ambiguities.\n            ambiguity_detection: LogLevel::Warn,\n            use_shortnames: false,\n            ..default()\n        });\n    }\n}\n\n/// Returns the number of conflicting systems per schedule.\nfn count_ambiguities(sub_app: &SubApp) -> AmbiguitiesCount {\n    let schedules = sub_app.world().resource::<Schedules>();\n    let mut ambiguities = HashMap::new();\n    for (_, schedule) in schedules.iter() {\n        let ambiguities_in_schedule = schedule.graph().conflicting_systems().len();\n        ambiguities.insert(schedule.label(), ambiguities_in_schedule);\n    }\n    AmbiguitiesCount(ambiguities)\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "259bdea6fefa3a8f3528a01f47592f4a34a622b0",
    "func": "use std::rc::Rc;\n\nuse yew::prelude::*;\nuse yew::virtual_dom::VChild;\n\nuse crate::header::ListHeader;\nuse crate::item::ListItem;\nuse crate::{Hovered, WeakComponentLink};\n\npub enum Msg {\n    HeaderClick,\n}\n\n#[derive(Clone, PartialEq, Properties)]\npub struct Props {\n    #[prop_or_default]\n    pub header: Vec<VChild<ListHeader>>,\n    #[prop_or_default]\n    pub children: Vec<VChild<ListItem>>,\n\n    pub on_hover: Callback<Hovered>,\n    pub weak_link: WeakComponentLink<List>,\n}\n\npub struct List {\n    inactive: bool,\n}\n\nimpl Component for List {\n    type Message = Msg;\n    type Properties = Props;\n\n    fn create(ctx: &Context<Self>) -> Self {\n        ctx.props()\n            .weak_link\n            .borrow_mut()\n            .replace(ctx.link().clone());\n        Self { inactive: false }\n    }\n\n    fn update(&mut self, _ctx: &Context<Self>, msg: Self::Message) -> bool {\n        match msg {\n            Msg::HeaderClick => {\n                self.inactive = !self.inactive;\n                true\n            }\n        }\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        let inactive = if self.inactive { \"inactive\" } else { \"\" };\n        let onmouseover = ctx.props().on_hover.reform(|e: MouseEvent| {\n            e.stop_propagation();\n            Hovered::List\n        });\n        html! {\n            <div class=\"list-container\" {onmouseover}>\n                <div class={classes!(\"list\", inactive)}>\n                    { ctx.props().header.clone() }\n                    <div class=\"items\">\n                        { Self::view_items(ctx.props().children.clone()) }\n                    </div>\n                </div>\n            </div>\n        }\n    }\n}\n\nimpl List {\n    fn view_items(children: Vec<VChild<ListItem>>) -> Html {\n        children\n            .into_iter()\n            .filter(|c| !c.props.hide)\n            .enumerate()\n            .map(|(i, mut c)| {\n                let props = Rc::make_mut(&mut c.props);\n                props.name = format!(\"#{} - {}\", i + 1, props.name).into();\n                c\n            })\n            .collect::<Html>()\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "98aaab5015338cb506f1b080111ee2600deb3ffc",
    "func": "use bevy_ecs::prelude::*;\nuse glam::*;\n\n#[derive(Component, Copy, Clone)]\nstruct Transform(Mat4);\n\n#[derive(Component, Copy, Clone)]\n#[component(storage = \"SparseSet\")]\nstruct Position<const X: usize>(Vec3);\n\n#[derive(Component, Copy, Clone)]\nstruct Rotation(Vec3);\n\n#[derive(Component, Copy, Clone)]\n#[component(storage = \"SparseSet\")]\nstruct Velocity<const X: usize>(Vec3);\n\npub struct Benchmark<'w>(\n    World,\n    QueryState<(\n        &'w Velocity<0>,\n        &'w mut Position<0>,\n        &'w Velocity<1>,\n        &'w mut Position<1>,\n        &'w Velocity<2>,\n        &'w mut Position<2>,\n        &'w Velocity<3>,\n        &'w mut Position<3>,\n        &'w Velocity<4>,\n        &'w mut Position<4>,\n    )>,\n);\n\nimpl<'w> Benchmark<'w> {\n    pub fn new() -> Self {\n        let mut world = World::new();\n\n        world.spawn_batch(\n            core::iter::repeat((\n                Transform(Mat4::from_scale(Vec3::ONE)),\n                Rotation(Vec3::X),\n                Position::<0>(Vec3::X),\n                Velocity::<0>(Vec3::X),\n                Position::<1>(Vec3::X),\n                Velocity::<1>(Vec3::X),\n                Position::<2>(Vec3::X),\n                Velocity::<2>(Vec3::X),\n                Position::<3>(Vec3::X),\n                Velocity::<3>(Vec3::X),\n                Position::<4>(Vec3::X),\n                Velocity::<4>(Vec3::X),\n            ))\n            .take(10_000),\n        );\n\n        let query = world.query();\n        Self(world, query)\n    }\n\n    #[inline(never)]\n    pub fn run(&mut self) {\n        self.1.iter_mut(&mut self.0).for_each(|mut item| {\n            item.1 .0 += item.0 .0;\n            item.3 .0 += item.2 .0;\n            item.5 .0 += item.4 .0;\n            item.7 .0 += item.6 .0;\n        });\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "a5cff498184e2f7c8ac7874fe9db3d20b5dfa6bd",
    "func": "use sea_orm::entity::prelude::*;\n\nuse super::_entities::files::ActiveModel;\n\nimpl ActiveModelBehavior for ActiveModel {\n    // extend activemodel below (keep comment for generators)\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "669bcd1fb6fc7b777aa27752e01b7e1c19804851",
    "func": "//! Extractor that will get captures from the URL and parse them using\n//! [`serde`].\n\nmod de;\n\nuse crate::{\n    extract::{rejection::*, FromRequestParts},\n    routing::url_params::UrlParams,\n    util::PercentDecodedStr,\n};\nuse axum_core::response::{IntoResponse, Response};\nuse http::{request::Parts, StatusCode};\nuse serde::de::DeserializeOwned;\nuse std::{fmt, sync::Arc};\n\n/// Extractor that will get captures from the URL and parse them using\n/// [`serde`].\n///\n/// Any percent encoded parameters will be automatically decoded. The decoded\n/// parameters must be valid UTF-8, otherwise `Path` will fail and return a `400\n/// Bad Request` response.\n///\n/// # Example\n///\n/// These examples assume the `serde` feature of the [`uuid`] crate is enabled.\n///\n/// One `Path` can extract multiple captures. It is not necessary (and does\n/// not work) to give a handler more than one `Path` argument.\n///\n/// [`uuid`]: https://crates.io/crates/uuid\n///\n/// ```rust,no_run\n/// use axum::{\n///     extract::Path,\n///     routing::get,\n///     Router,\n/// };\n/// use uuid::Uuid;\n///\n/// async fn users_teams_show(\n///     Path((user_id, team_id)): Path<(Uuid, Uuid)>,\n/// ) {\n///     // ...\n/// }\n///\n/// let app = Router::new().route(\"/users/{user_id}/team/{team_id}\", get(users_teams_show));\n/// # let _: Router = app;\n/// ```\n///\n/// If the path contains only one parameter, then you can omit the tuple.\n///\n/// ```rust,no_run\n/// use axum::{\n///     extract::Path,\n///     routing::get,\n///     Router,\n/// };\n/// use uuid::Uuid;\n///\n/// async fn user_info(Path(user_id): Path<Uuid>) {\n///     // ...\n/// }\n///\n/// let app = Router::new().route(\"/users/{user_id}\", get(user_info));\n/// # let _: Router = app;\n/// ```\n///\n/// Path segments also can be deserialized into any type that implements\n/// [`serde::Deserialize`]. This includes tuples and structs:\n///\n/// ```rust,no_run\n/// use axum::{\n///     extract::Path,\n///     routing::get,\n///     Router,\n/// };\n/// use serde::Deserialize;\n/// use uuid::Uuid;\n///\n/// // Path segment labels will be matched with struct field names\n/// #[derive(Deserialize)]\n/// struct Params {\n///     user_id: Uuid,\n///     team_id: Uuid,\n/// }\n///\n/// async fn users_teams_show(\n///     Path(Params { user_id, team_id }): Path<Params>,\n/// ) {\n///     // ...\n/// }\n///\n/// // When using tuples the path segments will be matched by their position in the route\n/// async fn users_teams_create(\n///     Path((user_id, team_id)): Path<(String, String)>,\n/// ) {\n///     // ...\n/// }\n///\n/// let app = Router::new().route(\n///     \"/users/{user_id}/team/{team_id}\",\n///     get(users_teams_show).post(users_teams_create),\n/// );\n/// # let _: Router = app;\n/// ```\n///\n/// If you wish to capture all path parameters you can use `HashMap` or `Vec`:\n///\n/// ```rust,no_run\n/// use axum::{\n///     extract::Path,\n///     routing::get,\n///     Router,\n/// };\n/// use std::collections::HashMap;\n///\n/// async fn params_map(\n///     Path(params): Path<HashMap<String, String>>,\n/// ) {\n///     // ...\n/// }\n///\n/// async fn params_vec(\n///     Path(params): Path<Vec<(String, String)>>,\n/// ) {\n///     // ...\n/// }\n///\n/// let app = Router::new()\n///     .route(\"/users/{user_id}/team/{team_id}\", get(params_map).post(params_vec));\n/// # let _: Router = app;\n/// ```\n///\n/// # Providing detailed rejection output\n///\n/// If the URI cannot be deserialized into the target type the request will be rejected and an\n/// error response will be returned. See [`customize-path-rejection`] for an example of how to customize that error.\n///\n/// [`serde`]: https://crates.io/crates/serde\n/// [`serde::Deserialize`]: https://docs.rs/serde/1.0.127/serde/trait.Deserialize.html\n/// [`customize-path-rejection`]: https://github.com/tokio-rs/axum/blob/main/examples/customize-path-rejection/src/main.rs\n#[derive(Debug)]\npub struct Path<T>(pub T);\n\naxum_core::__impl_deref!(Path);\n\nimpl<T, S> FromRequestParts<S> for Path<T>\nwhere\n    T: DeserializeOwned + Send,\n    S: Send + Sync,\n{\n    type Rejection = PathRejection;\n\n    async fn from_request_parts(parts: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {\n        let params = match parts.extensions.get::<UrlParams>() {\n            Some(UrlParams::Params(params)) => params,\n            Some(UrlParams::InvalidUtf8InPathParam { key }) => {\n                let err = PathDeserializationError {\n                    kind: ErrorKind::InvalidUtf8InPathParam {\n                        key: key.to_string(),\n                    },\n                };\n                let err = FailedToDeserializePathParams(err);\n                return Err(err.into());\n            }\n            None => {\n                return Err(MissingPathParams.into());\n            }\n        };\n\n        T::deserialize(de::PathDeserializer::new(params))\n            .map_err(|err| {\n                PathRejection::FailedToDeserializePathParams(FailedToDeserializePathParams(err))\n            })\n            .map(Path)\n    }\n}\n\n// this wrapper type is used as the deserializer error to hide the `serde::de::Error` impl which\n// would otherwise be public if we used `ErrorKind` as the error directly\n#[derive(Debug)]\npub(crate) struct PathDeserializationError {\n    pub(super) kind: ErrorKind,\n}\n\nimpl PathDeserializationError {\n    pub(super) fn new(kind: ErrorKind) -> Self {\n        Self { kind }\n    }\n\n    pub(super) fn wrong_number_of_parameters() -> WrongNumberOfParameters<()> {\n        WrongNumberOfParameters { got: () }\n    }\n\n    #[track_caller]\n    pub(super) fn unsupported_type(name: &'static str) -> Self {\n        Self::new(ErrorKind::UnsupportedType { name })\n    }\n}\n\npub(super) struct WrongNumberOfParameters<G> {\n    got: G,\n}\n\nimpl<G> WrongNumberOfParameters<G> {\n    #[allow(clippy::unused_self)]\n    pub(super) fn got<G2>(self, got: G2) -> WrongNumberOfParameters<G2> {\n        WrongNumberOfParameters { got }\n    }\n}\n\nimpl WrongNumberOfParameters<usize> {\n    pub(super) fn expected(self, expected: usize) -> PathDeserializationError {\n        PathDeserializationError::new(ErrorKind::WrongNumberOfParameters {\n            got: self.got,\n            expected,\n        })\n    }\n}\n\nimpl serde::de::Error for PathDeserializationError {\n    #[inline]\n    fn custom<T>(msg: T) -> Self\n    where\n        T: fmt::Display,\n    {\n        Self {\n            kind: ErrorKind::Message(msg.to_string()),\n        }\n    }\n}\n\nimpl fmt::Display for PathDeserializationError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.kind.fmt(f)\n    }\n}\n\nimpl std::error::Error for PathDeserializationError {}\n\n/// The kinds of errors that can happen we deserializing into a [`Path`].\n///\n/// This type is obtained through [`FailedToDeserializePathParams::kind`] or\n/// [`FailedToDeserializePathParams::into_kind`] and is useful for building\n/// more precise error messages.\n#[derive(Debug, PartialEq, Eq)]\n#[non_exhaustive]\npub enum ErrorKind {\n    /// The URI contained the wrong number of parameters.\n    WrongNumberOfParameters {\n        /// The number of actual parameters in the URI.\n        got: usize,\n        /// The number of expected parameters.\n        expected: usize,\n    },\n\n    /// Failed to parse the value at a specific key into the expected type.\n    ///\n    /// This variant is used when deserializing into types that have named fields, such as structs.\n    ParseErrorAtKey {\n        /// The key at which the value was located.\n        key: String,\n        /// The value from the URI.\n        value: String,\n        /// The expected type of the value.\n        expected_type: &'static str,\n    },\n\n    /// Failed to parse the value at a specific index into the expected type.\n    ///\n    /// This variant is used when deserializing into sequence types, such as tuples.\n    ParseErrorAtIndex {\n        /// The index at which the value was located.\n        index: usize,\n        /// The value from the URI.\n        value: String,\n        /// The expected type of the value.\n        expected_type: &'static str,\n    },\n\n    /// Failed to parse a value into the expected type.\n    ///\n    /// This variant is used when deserializing into a primitive type (such as `String` and `u32`).\n    ParseError {\n        /// The value from the URI.\n        value: String,\n        /// The expected type of the value.\n        expected_type: &'static str,\n    },\n\n    /// A parameter contained text that, once percent decoded, wasn't valid UTF-8.\n    InvalidUtf8InPathParam {\n        /// The key at which the invalid value was located.\n        key: String,\n    },\n\n    /// Tried to serialize into an unsupported type such as nested maps.\n    ///\n    /// This error kind is caused by programmer errors and thus gets converted into a `500 Internal\n    /// Server Error` response.\n    UnsupportedType {\n        /// The name of the unsupported type.\n        name: &'static str,\n    },\n\n    /// Catch-all variant for errors that don't fit any other variant.\n    Message(String),\n}\n\nimpl fmt::Display for ErrorKind {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            ErrorKind::Message(error) => error.fmt(f),\n            ErrorKind::InvalidUtf8InPathParam { key } => write!(f, \"Invalid UTF-8 in `{key}`\"),\n            ErrorKind::WrongNumberOfParameters { got, expected } => {\n                write!(\n                    f,\n                    \"Wrong number of path arguments for `Path`. Expected {expected} but got {got}\"\n                )?;\n\n                if *expected == 1 {\n                    write!(f, \". Note that multiple parameters must be extracted with a tuple `Path<(_, _)>` or a struct `Path<YourParams>`\")?;\n                }\n\n                Ok(())\n            }\n            ErrorKind::UnsupportedType { name } => write!(f, \"Unsupported type `{name}`\"),\n            ErrorKind::ParseErrorAtKey {\n                key,\n                value,\n                expected_type,\n            } => write!(\n                f,\n                \"Cannot parse `{key}` with value `{value:?}` to a `{expected_type}`\"\n            ),\n            ErrorKind::ParseError {\n                value,\n                expected_type,\n            } => write!(f, \"Cannot parse `{value:?}` to a `{expected_type}`\"),\n            ErrorKind::ParseErrorAtIndex {\n                index,\n                value,\n                expected_type,\n            } => write!(\n                f,\n                \"Cannot parse value at index {index} with value `{value:?}` to a `{expected_type}`\"\n            ),\n        }\n    }\n}\n\n/// Rejection type for [`Path`] if the captured routes params couldn't be deserialized\n/// into the expected type.\n#[derive(Debug)]\npub struct FailedToDeserializePathParams(PathDeserializationError);\n\nimpl FailedToDeserializePathParams {\n    /// Get a reference to the underlying error kind.\n    pub fn kind(&self) -> &ErrorKind {\n        &self.0.kind\n    }\n\n    /// Convert this error into the underlying error kind.\n    pub fn into_kind(self) -> ErrorKind {\n        self.0.kind\n    }\n\n    /// Get the response body text used for this rejection.\n    pub fn body_text(&self) -> String {\n        match self.0.kind {\n            ErrorKind::Message(_)\n            | ErrorKind::InvalidUtf8InPathParam { .. }\n            | ErrorKind::ParseError { .. }\n            | ErrorKind::ParseErrorAtIndex { .. }\n            | ErrorKind::ParseErrorAtKey { .. } => format!(\"Invalid URL: {}\", self.0.kind),\n            ErrorKind::WrongNumberOfParameters { .. } | ErrorKind::UnsupportedType { .. } => {\n                self.0.kind.to_string()\n            }\n        }\n    }\n\n    /// Get the status code used for this rejection.\n    pub fn status(&self) -> StatusCode {\n        match self.0.kind {\n            ErrorKind::Message(_)\n            | ErrorKind::InvalidUtf8InPathParam { .. }\n            | ErrorKind::ParseError { .. }\n            | ErrorKind::ParseErrorAtIndex { .. }\n            | ErrorKind::ParseErrorAtKey { .. } => StatusCode::BAD_REQUEST,\n            ErrorKind::WrongNumberOfParameters { .. } | ErrorKind::UnsupportedType { .. } => {\n                StatusCode::INTERNAL_SERVER_ERROR\n            }\n        }\n    }\n}\n\nimpl IntoResponse for FailedToDeserializePathParams {\n    fn into_response(self) -> Response {\n        let body = self.body_text();\n        axum_core::__log_rejection!(\n            rejection_type = Self,\n            body_text = body,\n            status = self.status(),\n        );\n        (self.status(), body).into_response()\n    }\n}\n\nimpl fmt::Display for FailedToDeserializePathParams {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        self.0.fmt(f)\n    }\n}\n\nimpl std::error::Error for FailedToDeserializePathParams {}\n\n/// Extractor that will get captures from the URL without deserializing them.\n///\n/// In general you should prefer to use [`Path`] as it is higher level, however `RawPathParams` is\n/// suitable if just want the raw params without deserializing them and thus saving some\n/// allocations.\n///\n/// Any percent encoded parameters will be automatically decoded. The decoded parameters must be\n/// valid UTF-8, otherwise `RawPathParams` will fail and return a `400 Bad Request` response.\n///\n/// # Example\n///\n/// ```rust,no_run\n/// use axum::{\n///     extract::RawPathParams,\n///     routing::get,\n///     Router,\n/// };\n///\n/// async fn users_teams_show(params: RawPathParams) {\n///     for (key, value) in &params {\n///         println!(\"{key:?} = {value:?}\");\n///     }\n/// }\n///\n/// let app = Router::new().route(\"/users/{user_id}/team/{team_id}\", get(users_teams_show));\n/// # let _: Router = app;\n/// ```\n#[derive(Debug)]\npub struct RawPathParams(Vec<(Arc<str>, PercentDecodedStr)>);\n\nimpl<S> FromRequestParts<S> for RawPathParams\nwhere\n    S: Send + Sync,\n{\n    type Rejection = RawPathParamsRejection;\n\n    async fn from_request_parts(parts: &mut Parts, _state: &S) -> Result<Self, Self::Rejection> {\n        let params = match parts.extensions.get::<UrlParams>() {\n            Some(UrlParams::Params(params)) => params,\n            Some(UrlParams::InvalidUtf8InPathParam { key }) => {\n                return Err(InvalidUtf8InPathParam {\n                    key: Arc::clone(key),\n                }\n                .into());\n            }\n            None => {\n                return Err(MissingPathParams.into());\n            }\n        };\n\n        Ok(Self(params.clone()))\n    }\n}\n\nimpl RawPathParams {\n    /// Get an iterator over the path parameters.\n    pub fn iter(&self) -> RawPathParamsIter<'_> {\n        self.into_iter()\n    }\n}\n\nimpl<'a> IntoIterator for &'a RawPathParams {\n    type Item = (&'a str, &'a str);\n    type IntoIter = RawPathParamsIter<'a>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        RawPathParamsIter(self.0.iter())\n    }\n}\n\n/// An iterator over raw path parameters.\n///\n/// Created with [`RawPathParams::iter`].\n#[derive(Debug)]\npub struct RawPathParamsIter<'a>(std::slice::Iter<'a, (Arc<str>, PercentDecodedStr)>);\n\nimpl<'a> Iterator for RawPathParamsIter<'a> {\n    type Item = (&'a str, &'a str);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let (key, value) = self.0.next()?;\n        Some((&**key, value.as_str()))\n    }\n}\n\n/// Rejection used by [`RawPathParams`] if a parameter contained text that, once percent decoded,\n/// wasn't valid UTF-8.\n#[derive(Debug)]\npub struct InvalidUtf8InPathParam {\n    key: Arc<str>,\n}\n\nimpl InvalidUtf8InPathParam {\n    /// Get the response body text used for this rejection.\n    pub fn body_text(&self) -> String {\n        self.to_string()\n    }\n\n    /// Get the status code used for this rejection.\n    pub fn status(&self) -> StatusCode {\n        StatusCode::BAD_REQUEST\n    }\n}\n\nimpl fmt::Display for InvalidUtf8InPathParam {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"Invalid UTF-8 in `{}`\", self.key)\n    }\n}\n\nimpl std::error::Error for InvalidUtf8InPathParam {}\n\nimpl IntoResponse for InvalidUtf8InPathParam {\n    fn into_response(self) -> Response {\n        let body = self.body_text();\n        axum_core::__log_rejection!(\n            rejection_type = Self,\n            body_text = body,\n            status = self.status(),\n        );\n        (self.status(), body).into_response()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{routing::get, test_helpers::*, Router};\n    use serde::Deserialize;\n    use std::collections::HashMap;\n\n    #[crate::test]\n    async fn extracting_url_params() {\n        let app = Router::new().route(\n            \"/users/{id}\",\n            get(|Path(id): Path<i32>| async move {\n                assert_eq!(id, 42);\n            })\n            .post(|Path(params_map): Path<HashMap<String, i32>>| async move {\n                assert_eq!(params_map.get(\"id\").unwrap(), &1337);\n            }),\n        );\n\n        let client = TestClient::new(app);\n\n        let res = client.get(\"/users/42\").await;\n        assert_eq!(res.status(), StatusCode::OK);\n\n        let res = client.post(\"/users/1337\").await;\n        assert_eq!(res.status(), StatusCode::OK);\n    }\n\n    #[crate::test]\n    async fn extracting_url_params_multiple_times() {\n        let app = Router::new().route(\"/users/{id}\", get(|_: Path<i32>, _: Path<String>| async {}));\n\n        let client = TestClient::new(app);\n\n        let res = client.get(\"/users/42\").await;\n        assert_eq!(res.status(), StatusCode::OK);\n    }\n\n    #[crate::test]\n    async fn percent_decoding() {\n        let app = Router::new().route(\n            \"/{key}\",\n            get(|Path(param): Path<String>| async move { param }),\n        );\n\n        let client = TestClient::new(app);\n\n        let res = client.get(\"/one%20two\").await;\n\n        assert_eq!(res.text().await, \"one two\");\n    }\n\n    #[crate::test]\n    async fn supports_128_bit_numbers() {\n        let app = Router::new()\n            .route(\n                \"/i/{key}\",\n                get(|Path(param): Path<i128>| async move { param.to_string() }),\n            )\n            .route(\n                \"/u/{key}\",\n                get(|Path(param): Path<u128>| async move { param.to_string() }),\n            );\n\n        let client = TestClient::new(app);\n\n        let res = client.get(\"/i/123\").await;\n        assert_eq!(res.text().await, \"123\");\n\n        let res = client.get(\"/u/123\").await;\n        assert_eq!(res.text().await, \"123\");\n    }\n\n    #[crate::test]\n    async fn wildcard() {\n        let app = Router::new()\n            .route(\n                \"/foo/{*rest}\",\n                get(|Path(param): Path<String>| async move { param }),\n            )\n            .route(\n                \"/bar/{*rest}\",\n                get(|Path(params): Path<HashMap<String, String>>| async move {\n                    params.get(\"rest\").unwrap().clone()\n                }),\n            );\n\n        let client = TestClient::new(app);\n\n        let res = client.get(\"/foo/bar/baz\").await;\n        assert_eq!(res.text().await, \"bar/baz\");\n\n        let res = client.get(\"/bar/baz/qux\").await;\n        assert_eq!(res.text().await, \"baz/qux\");\n    }\n\n    #[crate::test]\n    async fn captures_dont_match_empty_path() {\n        let app = Router::new().route(\"/{key}\", get(|| async {}));\n\n        let client = TestClient::new(app);\n\n        let res = client.get(\"/\").await;\n        assert_eq!(res.status(), StatusCode::NOT_FOUND);\n\n        let res = client.get(\"/foo\").await;\n        assert_eq!(res.status(), StatusCode::OK);\n    }\n\n    #[crate::test]\n    async fn captures_match_empty_inner_segments() {\n        let app = Router::new().route(\n            \"/{key}/method\",\n            get(|Path(param): Path<String>| async move { param.to_string() }),\n        );\n\n        let client = TestClient::new(app);\n\n        let res = client.get(\"/abc/method\").await;\n        assert_eq!(res.text().await, \"abc\");\n\n        let res = client.get(\"//method\").await;\n        assert_eq!(res.text().await, \"\");\n    }\n\n    #[crate::test]\n    async fn captures_match_empty_inner_segments_near_end() {\n        let app = Router::new().route(\n            \"/method/{key}/\",\n            get(|Path(param): Path<String>| async move { param.to_string() }),\n        );\n\n        let client = TestClient::new(app);\n\n        let res = client.get(\"/method/abc\").await;\n        assert_eq!(res.status(), StatusCode::NOT_FOUND);\n\n        let res = client.get(\"/method/abc/\").await;\n        assert_eq!(res.text().await, \"abc\");\n\n        let res = client.get(\"/method//\").await;\n        assert_eq!(res.text().await, \"\");\n    }\n\n    #[crate::test]\n    async fn captures_match_empty_trailing_segment() {\n        let app = Router::new().route(\n            \"/method/{key}\",\n            get(|Path(param): Path<String>| async move { param.to_string() }),\n        );\n\n        let client = TestClient::new(app);\n\n        let res = client.get(\"/method/abc/\").await;\n        assert_eq!(res.status(), StatusCode::NOT_FOUND);\n\n        let res = client.get(\"/method/abc\").await;\n        assert_eq!(res.text().await, \"abc\");\n\n        let res = client.get(\"/method/\").await;\n        assert_eq!(res.text().await, \"\");\n\n        let res = client.get(\"/method\").await;\n        assert_eq!(res.status(), StatusCode::NOT_FOUND);\n    }\n\n    #[crate::test]\n    async fn str_reference_deserialize() {\n        struct Param(String);\n        impl<'de> serde::Deserialize<'de> for Param {\n            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n            where\n                D: serde::Deserializer<'de>,\n            {\n                let s = <&str as serde::Deserialize>::deserialize(deserializer)?;\n                Ok(Param(s.to_owned()))\n            }\n        }\n\n        let app = Router::new().route(\n            \"/{key}\",\n            get(|param: Path<Param>| async move { param.0 .0 }),\n        );\n\n        let client = TestClient::new(app);\n\n        let res = client.get(\"/foo\").await;\n        assert_eq!(res.text().await, \"foo\");\n\n        // percent decoding should also work\n        let res = client.get(\"/foo%20bar\").await;\n        assert_eq!(res.text().await, \"foo bar\");\n    }\n\n    #[crate::test]\n    async fn two_path_extractors() {\n        let app = Router::new().route(\"/{a}/{b}\", get(|_: Path<String>, _: Path<String>| async {}));\n\n        let client = TestClient::new(app);\n\n        let res = client.get(\"/a/b\").await;\n        assert_eq!(res.status(), StatusCode::INTERNAL_SERVER_ERROR);\n        assert_eq!(\n            res.text().await,\n            \"Wrong number of path arguments for `Path`. Expected 1 but got 2. \\\n            Note that multiple parameters must be extracted with a tuple `Path<(_, _)>` or a struct `Path<YourParams>`\",\n        );\n    }\n\n    #[crate::test]\n    async fn tuple_param_matches_exactly() {\n        #[allow(dead_code)]\n        #[derive(Deserialize)]\n        struct Tuple(String, String);\n\n        let app = Router::new()\n            .route(\n                \"/foo/{a}/{b}/{c}\",\n                get(|_: Path<(String, String)>| async {}),\n            )\n            .route(\"/bar/{a}/{b}/{c}\", get(|_: Path<Tuple>| async {}));\n\n        let client = TestClient::new(app);\n\n        let res = client.get(\"/foo/a/b/c\").await;\n        assert_eq!(res.status(), StatusCode::INTERNAL_SERVER_ERROR);\n        assert_eq!(\n            res.text().await,\n            \"Wrong number of path arguments for `Path`. Expected 2 but got 3\",\n        );\n\n        let res = client.get(\"/bar/a/b/c\").await;\n        assert_eq!(res.status(), StatusCode::INTERNAL_SERVER_ERROR);\n        assert_eq!(\n            res.text().await,\n            \"Wrong number of path arguments for `Path`. Expected 2 but got 3\",\n        );\n    }\n\n    #[crate::test]\n    async fn deserialize_into_vec_of_tuples() {\n        let app = Router::new().route(\n            \"/{a}/{b}\",\n            get(|Path(params): Path<Vec<(String, String)>>| async move {\n                assert_eq!(\n                    params,\n                    vec![\n                        (\"a\".to_owned(), \"foo\".to_owned()),\n                        (\"b\".to_owned(), \"bar\".to_owned())\n                    ]\n                );\n            }),\n        );\n\n        let client = TestClient::new(app);\n\n        let res = client.get(\"/foo/bar\").await;\n        assert_eq!(res.status(), StatusCode::OK);\n    }\n\n    #[crate::test]\n    async fn type_that_uses_deserialize_any() {\n        use time::Date;\n\n        #[derive(Deserialize)]\n        struct Params {\n            a: Date,\n            b: Date,\n            c: Date,\n        }\n\n        let app = Router::new()\n            .route(\n                \"/single/{a}\",\n                get(|Path(a): Path<Date>| async move { format!(\"single: {a}\") }),\n            )\n            .route(\n                \"/tuple/{a}/{b}/{c}\",\n                get(|Path((a, b, c)): Path<(Date, Date, Date)>| async move {\n                    format!(\"tuple: {a} {b} {c}\")\n                }),\n            )\n            .route(\n                \"/vec/{a}/{b}/{c}\",\n                get(|Path(vec): Path<Vec<Date>>| async move {\n                    let [a, b, c]: [Date; 3] = vec.try_into().unwrap();\n                    format!(\"vec: {a} {b} {c}\")\n                }),\n            )\n            .route(\n                \"/vec_pairs/{a}/{b}/{c}\",\n                get(|Path(vec): Path<Vec<(String, Date)>>| async move {\n                    let [(_, a), (_, b), (_, c)]: [(String, Date); 3] = vec.try_into().unwrap();\n                    format!(\"vec_pairs: {a} {b} {c}\")\n                }),\n            )\n            .route(\n                \"/map/{a}/{b}/{c}\",\n                get(|Path(mut map): Path<HashMap<String, Date>>| async move {\n                    let a = map.remove(\"a\").unwrap();\n                    let b = map.remove(\"b\").unwrap();\n                    let c = map.remove(\"c\").unwrap();\n                    format!(\"map: {a} {b} {c}\")\n                }),\n            )\n            .route(\n                \"/struct/{a}/{b}/{c}\",\n                get(|Path(params): Path<Params>| async move {\n                    format!(\"struct: {} {} {}\", params.a, params.b, params.c)\n                }),\n            );\n\n        let client = TestClient::new(app);\n\n        let res = client.get(\"/single/2023-01-01\").await;\n        assert_eq!(res.text().await, \"single: 2023-01-01\");\n\n        let res = client.get(\"/tuple/2023-01-01/2023-01-02/2023-01-03\").await;\n        assert_eq!(res.text().await, \"tuple: 2023-01-01 2023-01-02 2023-01-03\");\n\n        let res = client.get(\"/vec/2023-01-01/2023-01-02/2023-01-03\").await;\n        assert_eq!(res.text().await, \"vec: 2023-01-01 2023-01-02 2023-01-03\");\n\n        let res = client\n            .get(\"/vec_pairs/2023-01-01/2023-01-02/2023-01-03\")\n            .await;\n        assert_eq!(\n            res.text().await,\n            \"vec_pairs: 2023-01-01 2023-01-02 2023-01-03\",\n        );\n\n        let res = client.get(\"/map/2023-01-01/2023-01-02/2023-01-03\").await;\n        assert_eq!(res.text().await, \"map: 2023-01-01 2023-01-02 2023-01-03\");\n\n        let res = client.get(\"/struct/2023-01-01/2023-01-02/2023-01-03\").await;\n        assert_eq!(res.text().await, \"struct: 2023-01-01 2023-01-02 2023-01-03\");\n    }\n\n    #[crate::test]\n    async fn wrong_number_of_parameters_json() {\n        use serde_json::Value;\n\n        let app = Router::new()\n            .route(\"/one/{a}\", get(|_: Path<(Value, Value)>| async {}))\n            .route(\"/two/{a}/{b}\", get(|_: Path<Value>| async {}));\n\n        let client = TestClient::new(app);\n\n        let res = client.get(\"/one/1\").await;\n        assert!(res\n            .text()\n            .await\n            .starts_with(\"Wrong number of path arguments for `Path`. Expected 2 but got 1\"));\n\n        let res = client.get(\"/two/1/2\").await;\n        assert!(res\n            .text()\n            .await\n            .starts_with(\"Wrong number of path arguments for `Path`. Expected 1 but got 2\"));\n    }\n\n    #[crate::test]\n    async fn raw_path_params() {\n        let app = Router::new().route(\n            \"/{a}/{b}/{c}\",\n            get(|params: RawPathParams| async move {\n                params\n                    .into_iter()\n                    .map(|(key, value)| format!(\"{key}={value}\"))\n                    .collect::<Vec<_>>()\n                    .join(\" \")\n            }),\n        );\n\n        let client = TestClient::new(app);\n        let res = client.get(\"/foo/bar/baz\").await;\n        let body = res.text().await;\n        assert_eq!(body, \"a=foo b=bar c=baz\");\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "18bc0629f29602c84e4d49420700c851c1d7ce1e",
    "func": "use crate::component::ComponentId;\nuse crate::storage::SparseSetIndex;\nuse crate::world::World;\nuse core::{fmt, fmt::Debug, marker::PhantomData};\nuse derive_more::derive::From;\nuse fixedbitset::FixedBitSet;\n\n/// A wrapper struct to make Debug representations of [`FixedBitSet`] easier\n/// to read, when used to store [`SparseSetIndex`].\n///\n/// Instead of the raw integer representation of the `FixedBitSet`, the list of\n/// `T` valid for [`SparseSetIndex`] is shown.\n///\n/// Normal `FixedBitSet` `Debug` output:\n/// ```text\n/// read_and_writes: FixedBitSet { data: [ 160 ], length: 8 }\n/// ```\n///\n/// Which, unless you are a computer, doesn't help much understand what's in\n/// the set. With `FormattedBitSet`, we convert the present set entries into\n/// what they stand for, it is much clearer what is going on:\n/// ```text\n/// read_and_writes: [ ComponentId(5), ComponentId(7) ]\n/// ```\nstruct FormattedBitSet<'a, T: SparseSetIndex> {\n    bit_set: &'a FixedBitSet,\n    _marker: PhantomData<T>,\n}\n\nimpl<'a, T: SparseSetIndex> FormattedBitSet<'a, T> {\n    fn new(bit_set: &'a FixedBitSet) -> Self {\n        Self {\n            bit_set,\n            _marker: PhantomData,\n        }\n    }\n}\n\nimpl<'a, T: SparseSetIndex + Debug> Debug for FormattedBitSet<'a, T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_list()\n            .entries(self.bit_set.ones().map(T::get_sparse_set_index))\n            .finish()\n    }\n}\n\n/// Tracks read and write access to specific elements in a collection.\n///\n/// Used internally to ensure soundness during system initialization and execution.\n/// See the [`is_compatible`](Access::is_compatible) and [`get_conflicts`](Access::get_conflicts) functions.\n#[derive(Eq, PartialEq)]\npub struct Access<T: SparseSetIndex> {\n    /// All accessed components, or forbidden components if\n    /// `Self::component_read_and_writes_inverted` is set.\n    component_read_and_writes: FixedBitSet,\n    /// All exclusively-accessed components, or components that may not be\n    /// exclusively accessed if `Self::component_writes_inverted` is set.\n    component_writes: FixedBitSet,\n    /// All accessed resources.\n    resource_read_and_writes: FixedBitSet,\n    /// The exclusively-accessed resources.\n    resource_writes: FixedBitSet,\n    /// Is `true` if this component can read all components *except* those\n    /// present in `Self::component_read_and_writes`.\n    component_read_and_writes_inverted: bool,\n    /// Is `true` if this component can write to all components *except* those\n    /// present in `Self::component_writes`.\n    component_writes_inverted: bool,\n    /// Is `true` if this has access to all resources.\n    /// This field is a performance optimization for `&World` (also harder to mess up for soundness).\n    reads_all_resources: bool,\n    /// Is `true` if this has mutable access to all resources.\n    /// If this is true, then `reads_all` must also be true.\n    writes_all_resources: bool,\n    // Components that are not accessed, but whose presence in an archetype affect query results.\n    archetypal: FixedBitSet,\n    marker: PhantomData<T>,\n}\n\n// This is needed since `#[derive(Clone)]` does not generate optimized `clone_from`.\nimpl<T: SparseSetIndex> Clone for Access<T> {\n    fn clone(&self) -> Self {\n        Self {\n            component_read_and_writes: self.component_read_and_writes.clone(),\n            component_writes: self.component_writes.clone(),\n            resource_read_and_writes: self.resource_read_and_writes.clone(),\n            resource_writes: self.resource_writes.clone(),\n            component_read_and_writes_inverted: self.component_read_and_writes_inverted,\n            component_writes_inverted: self.component_writes_inverted,\n            reads_all_resources: self.reads_all_resources,\n            writes_all_resources: self.writes_all_resources,\n            archetypal: self.archetypal.clone(),\n            marker: PhantomData,\n        }\n    }\n\n    fn clone_from(&mut self, source: &Self) {\n        self.component_read_and_writes\n            .clone_from(&source.component_read_and_writes);\n        self.component_writes.clone_from(&source.component_writes);\n        self.resource_read_and_writes\n            .clone_from(&source.resource_read_and_writes);\n        self.resource_writes.clone_from(&source.resource_writes);\n        self.component_read_and_writes_inverted = source.component_read_and_writes_inverted;\n        self.component_writes_inverted = source.component_writes_inverted;\n        self.reads_all_resources = source.reads_all_resources;\n        self.writes_all_resources = source.writes_all_resources;\n        self.archetypal.clone_from(&source.archetypal);\n    }\n}\n\nimpl<T: SparseSetIndex + Debug> Debug for Access<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"Access\")\n            .field(\n                \"component_read_and_writes\",\n                &FormattedBitSet::<T>::new(&self.component_read_and_writes),\n            )\n            .field(\n                \"component_writes\",\n                &FormattedBitSet::<T>::new(&self.component_writes),\n            )\n            .field(\n                \"resource_read_and_writes\",\n                &FormattedBitSet::<T>::new(&self.resource_read_and_writes),\n            )\n            .field(\n                \"resource_writes\",\n                &FormattedBitSet::<T>::new(&self.resource_writes),\n            )\n            .field(\n                \"component_read_and_writes_inverted\",\n                &self.component_read_and_writes_inverted,\n            )\n            .field(\"component_writes_inverted\", &self.component_writes_inverted)\n            .field(\"reads_all_resources\", &self.reads_all_resources)\n            .field(\"writes_all_resources\", &self.writes_all_resources)\n            .field(\"archetypal\", &FormattedBitSet::<T>::new(&self.archetypal))\n            .finish()\n    }\n}\n\nimpl<T: SparseSetIndex> Default for Access<T> {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl<T: SparseSetIndex> Access<T> {\n    /// Creates an empty [`Access`] collection.\n    pub const fn new() -> Self {\n        Self {\n            reads_all_resources: false,\n            writes_all_resources: false,\n            component_read_and_writes_inverted: false,\n            component_writes_inverted: false,\n            component_read_and_writes: FixedBitSet::new(),\n            component_writes: FixedBitSet::new(),\n            resource_read_and_writes: FixedBitSet::new(),\n            resource_writes: FixedBitSet::new(),\n            archetypal: FixedBitSet::new(),\n            marker: PhantomData,\n        }\n    }\n\n    fn add_component_sparse_set_index_read(&mut self, index: usize) {\n        if !self.component_read_and_writes_inverted {\n            self.component_read_and_writes.grow_and_insert(index);\n        } else if index < self.component_read_and_writes.len() {\n            self.component_read_and_writes.remove(index);\n        }\n    }\n\n    fn add_component_sparse_set_index_write(&mut self, index: usize) {\n        if !self.component_writes_inverted {\n            self.component_writes.grow_and_insert(index);\n        } else if index < self.component_writes.len() {\n            self.component_writes.remove(index);\n        }\n    }\n\n    /// Adds access to the component given by `index`.\n    pub fn add_component_read(&mut self, index: T) {\n        let sparse_set_index = index.sparse_set_index();\n        self.add_component_sparse_set_index_read(sparse_set_index);\n    }\n\n    /// Adds exclusive access to the component given by `index`.\n    pub fn add_component_write(&mut self, index: T) {\n        let sparse_set_index = index.sparse_set_index();\n        self.add_component_sparse_set_index_read(sparse_set_index);\n        self.add_component_sparse_set_index_write(sparse_set_index);\n    }\n\n    /// Adds access to the resource given by `index`.\n    pub fn add_resource_read(&mut self, index: T) {\n        self.resource_read_and_writes\n            .grow_and_insert(index.sparse_set_index());\n    }\n\n    /// Adds exclusive access to the resource given by `index`.\n    pub fn add_resource_write(&mut self, index: T) {\n        self.resource_read_and_writes\n            .grow_and_insert(index.sparse_set_index());\n        self.resource_writes\n            .grow_and_insert(index.sparse_set_index());\n    }\n\n    fn remove_component_sparse_set_index_read(&mut self, index: usize) {\n        if self.component_read_and_writes_inverted {\n            self.component_read_and_writes.grow_and_insert(index);\n        } else if index < self.component_read_and_writes.len() {\n            self.component_read_and_writes.remove(index);\n        }\n    }\n\n    fn remove_component_sparse_set_index_write(&mut self, index: usize) {\n        if self.component_writes_inverted {\n            self.component_writes.grow_and_insert(index);\n        } else if index < self.component_writes.len() {\n            self.component_writes.remove(index);\n        }\n    }\n\n    /// Removes both read and write access to the component given by `index`.\n    ///\n    /// Because this method corresponds to the set difference operator \u2216, it can\n    /// create complicated logical formulas that you should verify correctness\n    /// of. For example, A \u222a (B \u2216 A) isn't equivalent to (A \u222a B) \u2216 A, so you\n    /// can't replace a call to `remove_component_read` followed by a call to\n    /// `extend` with a call to `extend` followed by a call to\n    /// `remove_component_read`.\n    pub fn remove_component_read(&mut self, index: T) {\n        let sparse_set_index = index.sparse_set_index();\n        self.remove_component_sparse_set_index_write(sparse_set_index);\n        self.remove_component_sparse_set_index_read(sparse_set_index);\n    }\n\n    /// Removes write access to the component given by `index`.\n    ///\n    /// Because this method corresponds to the set difference operator \u2216, it can\n    /// create complicated logical formulas that you should verify correctness\n    /// of. For example, A \u222a (B \u2216 A) isn't equivalent to (A \u222a B) \u2216 A, so you\n    /// can't replace a call to `remove_component_write` followed by a call to\n    /// `extend` with a call to `extend` followed by a call to\n    /// `remove_component_write`.\n    pub fn remove_component_write(&mut self, index: T) {\n        let sparse_set_index = index.sparse_set_index();\n        self.remove_component_sparse_set_index_write(sparse_set_index);\n    }\n\n    /// Adds an archetypal (indirect) access to the component given by `index`.\n    ///\n    /// This is for components whose values are not accessed (and thus will never cause conflicts),\n    /// but whose presence in an archetype may affect query results.\n    ///\n    /// Currently, this is only used for [`Has<T>`].\n    ///\n    /// [`Has<T>`]: crate::query::Has\n    pub fn add_archetypal(&mut self, index: T) {\n        self.archetypal.grow_and_insert(index.sparse_set_index());\n    }\n\n    /// Returns `true` if this can access the component given by `index`.\n    pub fn has_component_read(&self, index: T) -> bool {\n        self.component_read_and_writes_inverted\n            ^ self\n                .component_read_and_writes\n                .contains(index.sparse_set_index())\n    }\n\n    /// Returns `true` if this can access any component.\n    pub fn has_any_component_read(&self) -> bool {\n        self.component_read_and_writes_inverted || !self.component_read_and_writes.is_clear()\n    }\n\n    /// Returns `true` if this can exclusively access the component given by `index`.\n    pub fn has_component_write(&self, index: T) -> bool {\n        self.component_writes_inverted ^ self.component_writes.contains(index.sparse_set_index())\n    }\n\n    /// Returns `true` if this accesses any component mutably.\n    pub fn has_any_component_write(&self) -> bool {\n        self.component_writes_inverted || !self.component_writes.is_clear()\n    }\n\n    /// Returns `true` if this can access the resource given by `index`.\n    pub fn has_resource_read(&self, index: T) -> bool {\n        self.reads_all_resources\n            || self\n                .resource_read_and_writes\n                .contains(index.sparse_set_index())\n    }\n\n    /// Returns `true` if this can access any resource.\n    pub fn has_any_resource_read(&self) -> bool {\n        self.reads_all_resources || !self.resource_read_and_writes.is_clear()\n    }\n\n    /// Returns `true` if this can exclusively access the resource given by `index`.\n    pub fn has_resource_write(&self, index: T) -> bool {\n        self.writes_all_resources || self.resource_writes.contains(index.sparse_set_index())\n    }\n\n    /// Returns `true` if this accesses any resource mutably.\n    pub fn has_any_resource_write(&self) -> bool {\n        self.writes_all_resources || !self.resource_writes.is_clear()\n    }\n\n    /// Returns true if this has an archetypal (indirect) access to the component given by `index`.\n    ///\n    /// This is a component whose value is not accessed (and thus will never cause conflicts),\n    /// but whose presence in an archetype may affect query results.\n    ///\n    /// Currently, this is only used for [`Has<T>`].\n    ///\n    /// [`Has<T>`]: crate::query::Has\n    pub fn has_archetypal(&self, index: T) -> bool {\n        self.archetypal.contains(index.sparse_set_index())\n    }\n\n    /// Sets this as having access to all components (i.e. `EntityRef`).\n    #[inline]\n    pub fn read_all_components(&mut self) {\n        self.component_read_and_writes_inverted = true;\n        self.component_read_and_writes.clear();\n    }\n\n    /// Sets this as having mutable access to all components (i.e. `EntityMut`).\n    #[inline]\n    pub fn write_all_components(&mut self) {\n        self.read_all_components();\n        self.component_writes_inverted = true;\n        self.component_writes.clear();\n    }\n\n    /// Sets this as having access to all resources (i.e. `&World`).\n    #[inline]\n    pub fn read_all_resources(&mut self) {\n        self.reads_all_resources = true;\n    }\n\n    /// Sets this as having mutable access to all resources (i.e. `&mut World`).\n    #[inline]\n    pub fn write_all_resources(&mut self) {\n        self.reads_all_resources = true;\n        self.writes_all_resources = true;\n    }\n\n    /// Sets this as having access to all indexed elements (i.e. `&World`).\n    #[inline]\n    pub fn read_all(&mut self) {\n        self.read_all_components();\n        self.read_all_resources();\n    }\n\n    /// Sets this as having mutable access to all indexed elements (i.e. `&mut World`).\n    #[inline]\n    pub fn write_all(&mut self) {\n        self.write_all_components();\n        self.write_all_resources();\n    }\n\n    /// Returns `true` if this has access to all components (i.e. `EntityRef`).\n    #[inline]\n    pub fn has_read_all_components(&self) -> bool {\n        self.component_read_and_writes_inverted && self.component_read_and_writes.is_clear()\n    }\n\n    /// Returns `true` if this has write access to all components (i.e. `EntityMut`).\n    #[inline]\n    pub fn has_write_all_components(&self) -> bool {\n        self.component_writes_inverted && self.component_writes.is_clear()\n    }\n\n    /// Returns `true` if this has access to all resources (i.e. `EntityRef`).\n    #[inline]\n    pub fn has_read_all_resources(&self) -> bool {\n        self.reads_all_resources\n    }\n\n    /// Returns `true` if this has write access to all resources (i.e. `EntityMut`).\n    #[inline]\n    pub fn has_write_all_resources(&self) -> bool {\n        self.writes_all_resources\n    }\n\n    /// Returns `true` if this has access to all indexed elements (i.e. `&World`).\n    pub fn has_read_all(&self) -> bool {\n        self.has_read_all_components() && self.has_read_all_resources()\n    }\n\n    /// Returns `true` if this has write access to all indexed elements (i.e. `&mut World`).\n    pub fn has_write_all(&self) -> bool {\n        self.has_write_all_components() && self.has_write_all_resources()\n    }\n\n    /// Removes all writes.\n    pub fn clear_writes(&mut self) {\n        self.writes_all_resources = false;\n        self.component_writes_inverted = false;\n        self.component_writes.clear();\n        self.resource_writes.clear();\n    }\n\n    /// Removes all accesses.\n    pub fn clear(&mut self) {\n        self.reads_all_resources = false;\n        self.writes_all_resources = false;\n        self.component_read_and_writes_inverted = false;\n        self.component_writes_inverted = false;\n        self.component_read_and_writes.clear();\n        self.component_writes.clear();\n        self.resource_read_and_writes.clear();\n        self.resource_writes.clear();\n    }\n\n    /// Adds all access from `other`.\n    pub fn extend(&mut self, other: &Access<T>) {\n        let component_read_and_writes_inverted =\n            self.component_read_and_writes_inverted || other.component_read_and_writes_inverted;\n        let component_writes_inverted =\n            self.component_writes_inverted || other.component_writes_inverted;\n\n        match (\n            self.component_read_and_writes_inverted,\n            other.component_read_and_writes_inverted,\n        ) {\n            (true, true) => {\n                self.component_read_and_writes\n                    .intersect_with(&other.component_read_and_writes);\n            }\n            (true, false) => {\n                self.component_read_and_writes\n                    .difference_with(&other.component_read_and_writes);\n            }\n            (false, true) => {\n                // We have to grow here because the new bits are going to get flipped to 1.\n                self.component_read_and_writes.grow(\n                    self.component_read_and_writes\n                        .len()\n                        .max(other.component_read_and_writes.len()),\n                );\n                self.component_read_and_writes.toggle_range(..);\n                self.component_read_and_writes\n                    .intersect_with(&other.component_read_and_writes);\n            }\n            (false, false) => {\n                self.component_read_and_writes\n                    .union_with(&other.component_read_and_writes);\n            }\n        }\n\n        match (\n            self.component_writes_inverted,\n            other.component_writes_inverted,\n        ) {\n            (true, true) => {\n                self.component_writes\n                    .intersect_with(&other.component_writes);\n            }\n            (true, false) => {\n                self.component_writes\n                    .difference_with(&other.component_writes);\n            }\n            (false, true) => {\n                // We have to grow here because the new bits are going to get flipped to 1.\n                self.component_writes.grow(\n                    self.component_writes\n                        .len()\n                        .max(other.component_writes.len()),\n                );\n                self.component_writes.toggle_range(..);\n                self.component_writes\n                    .intersect_with(&other.component_writes);\n            }\n            (false, false) => {\n                self.component_writes.union_with(&other.component_writes);\n            }\n        }\n\n        self.reads_all_resources = self.reads_all_resources || other.reads_all_resources;\n        self.writes_all_resources = self.writes_all_resources || other.writes_all_resources;\n        self.component_read_and_writes_inverted = component_read_and_writes_inverted;\n        self.component_writes_inverted = component_writes_inverted;\n        self.resource_read_and_writes\n            .union_with(&other.resource_read_and_writes);\n        self.resource_writes.union_with(&other.resource_writes);\n    }\n\n    /// Returns `true` if the access and `other` can be active at the same time,\n    /// only looking at their component access.\n    ///\n    /// [`Access`] instances are incompatible if one can write\n    /// an element that the other can read or write.\n    pub fn is_components_compatible(&self, other: &Access<T>) -> bool {\n        // We have a conflict if we write and they read or write, or if they\n        // write and we read or write.\n        for (\n            lhs_writes,\n            rhs_reads_and_writes,\n            lhs_writes_inverted,\n            rhs_reads_and_writes_inverted,\n        ) in [\n            (\n                &self.component_writes,\n                &other.component_read_and_writes,\n                self.component_writes_inverted,\n                other.component_read_and_writes_inverted,\n            ),\n            (\n                &other.component_writes,\n                &self.component_read_and_writes,\n                other.component_writes_inverted,\n                self.component_read_and_writes_inverted,\n            ),\n        ] {\n            match (lhs_writes_inverted, rhs_reads_and_writes_inverted) {\n                (true, true) => return false,\n                (false, true) => {\n                    if !lhs_writes.is_subset(rhs_reads_and_writes) {\n                        return false;\n                    }\n                }\n                (true, false) => {\n                    if !rhs_reads_and_writes.is_subset(lhs_writes) {\n                        return false;\n                    }\n                }\n                (false, false) => {\n                    if !lhs_writes.is_disjoint(rhs_reads_and_writes) {\n                        return false;\n                    }\n                }\n            }\n        }\n\n        true\n    }\n\n    /// Returns `true` if the access and `other` can be active at the same time,\n    /// only looking at their resource access.\n    ///\n    /// [`Access`] instances are incompatible if one can write\n    /// an element that the other can read or write.\n    pub fn is_resources_compatible(&self, other: &Access<T>) -> bool {\n        if self.writes_all_resources {\n            return !other.has_any_resource_read();\n        }\n\n        if other.writes_all_resources {\n            return !self.has_any_resource_read();\n        }\n\n        if self.reads_all_resources {\n            return !other.has_any_resource_write();\n        }\n\n        if other.reads_all_resources {\n            return !self.has_any_resource_write();\n        }\n\n        self.resource_writes\n            .is_disjoint(&other.resource_read_and_writes)\n            && other\n                .resource_writes\n                .is_disjoint(&self.resource_read_and_writes)\n    }\n\n    /// Returns `true` if the access and `other` can be active at the same time.\n    ///\n    /// [`Access`] instances are incompatible if one can write\n    /// an element that the other can read or write.\n    pub fn is_compatible(&self, other: &Access<T>) -> bool {\n        self.is_components_compatible(other) && self.is_resources_compatible(other)\n    }\n\n    /// Returns `true` if the set's component access is a subset of another, i.e. `other`'s component access\n    /// contains at least all the values in `self`.\n    pub fn is_subset_components(&self, other: &Access<T>) -> bool {\n        for (\n            our_components,\n            their_components,\n            our_components_inverted,\n            their_components_inverted,\n        ) in [\n            (\n                &self.component_read_and_writes,\n                &other.component_read_and_writes,\n                self.component_read_and_writes_inverted,\n                other.component_read_and_writes_inverted,\n            ),\n            (\n                &self.component_writes,\n                &other.component_writes,\n                self.component_writes_inverted,\n                other.component_writes_inverted,\n            ),\n        ] {\n            match (our_components_inverted, their_components_inverted) {\n                (true, true) => {\n                    if !their_components.is_subset(our_components) {\n                        return false;\n                    }\n                }\n                (true, false) => {\n                    return false;\n                }\n                (false, true) => {\n                    if !our_components.is_disjoint(their_components) {\n                        return false;\n                    }\n                }\n                (false, false) => {\n                    if !our_components.is_subset(their_components) {\n                        return false;\n                    }\n                }\n            }\n        }\n\n        true\n    }\n\n    /// Returns `true` if the set's resource access is a subset of another, i.e. `other`'s resource access\n    /// contains at least all the values in `self`.\n    pub fn is_subset_resources(&self, other: &Access<T>) -> bool {\n        if self.writes_all_resources {\n            return other.writes_all_resources;\n        }\n\n        if other.writes_all_resources {\n            return true;\n        }\n\n        if self.reads_all_resources {\n            return other.reads_all_resources;\n        }\n\n        if other.reads_all_resources {\n            return self.resource_writes.is_subset(&other.resource_writes);\n        }\n\n        self.resource_read_and_writes\n            .is_subset(&other.resource_read_and_writes)\n            && self.resource_writes.is_subset(&other.resource_writes)\n    }\n\n    /// Returns `true` if the set is a subset of another, i.e. `other` contains\n    /// at least all the values in `self`.\n    pub fn is_subset(&self, other: &Access<T>) -> bool {\n        self.is_subset_components(other) && self.is_subset_resources(other)\n    }\n\n    fn get_component_conflicts(&self, other: &Access<T>) -> AccessConflicts {\n        let mut conflicts = FixedBitSet::new();\n\n        // We have a conflict if we write and they read or write, or if they\n        // write and we read or write.\n        for (\n            lhs_writes,\n            rhs_reads_and_writes,\n            lhs_writes_inverted,\n            rhs_reads_and_writes_inverted,\n        ) in [\n            (\n                &self.component_writes,\n                &other.component_read_and_writes,\n                self.component_writes_inverted,\n                other.component_read_and_writes_inverted,\n            ),\n            (\n                &other.component_writes,\n                &self.component_read_and_writes,\n                other.component_writes_inverted,\n                self.component_read_and_writes_inverted,\n            ),\n        ] {\n            // There's no way that I can see to do this without a temporary.\n            // Neither CNF nor DNF allows us to avoid one.\n            let temp_conflicts: FixedBitSet =\n                match (lhs_writes_inverted, rhs_reads_and_writes_inverted) {\n                    (true, true) => return AccessConflicts::All,\n                    (false, true) => lhs_writes.difference(rhs_reads_and_writes).collect(),\n                    (true, false) => rhs_reads_and_writes.difference(lhs_writes).collect(),\n                    (false, false) => lhs_writes.intersection(rhs_reads_and_writes).collect(),\n                };\n            conflicts.union_with(&temp_conflicts);\n        }\n\n        AccessConflicts::Individual(conflicts)\n    }\n\n    /// Returns a vector of elements that the access and `other` cannot access at the same time.\n    pub fn get_conflicts(&self, other: &Access<T>) -> AccessConflicts {\n        let mut conflicts = match self.get_component_conflicts(other) {\n            AccessConflicts::All => return AccessConflicts::All,\n            AccessConflicts::Individual(conflicts) => conflicts,\n        };\n\n        if self.reads_all_resources {\n            if other.writes_all_resources {\n                return AccessConflicts::All;\n            }\n            conflicts.extend(other.resource_writes.ones());\n        }\n\n        if other.reads_all_resources {\n            if self.writes_all_resources {\n                return AccessConflicts::All;\n            }\n            conflicts.extend(self.resource_writes.ones());\n        }\n        if self.writes_all_resources {\n            conflicts.extend(other.resource_read_and_writes.ones());\n        }\n\n        if other.writes_all_resources {\n            conflicts.extend(self.resource_read_and_writes.ones());\n        }\n\n        conflicts.extend(\n            self.resource_writes\n                .intersection(&other.resource_read_and_writes),\n        );\n        conflicts.extend(\n            self.resource_read_and_writes\n                .intersection(&other.resource_writes),\n        );\n        AccessConflicts::Individual(conflicts)\n    }\n\n    /// Returns the indices of the resources this has access to.\n    pub fn resource_reads_and_writes(&self) -> impl Iterator<Item = T> + '_ {\n        self.resource_read_and_writes\n            .ones()\n            .map(T::get_sparse_set_index)\n    }\n\n    /// Returns the indices of the resources this has non-exclusive access to.\n    pub fn resource_reads(&self) -> impl Iterator<Item = T> + '_ {\n        self.resource_read_and_writes\n            .difference(&self.resource_writes)\n            .map(T::get_sparse_set_index)\n    }\n\n    /// Returns the indices of the resources this has exclusive access to.\n    pub fn resource_writes(&self) -> impl Iterator<Item = T> + '_ {\n        self.resource_writes.ones().map(T::get_sparse_set_index)\n    }\n\n    /// Returns the indices of the components that this has an archetypal access to.\n    ///\n    /// These are components whose values are not accessed (and thus will never cause conflicts),\n    /// but whose presence in an archetype may affect query results.\n    ///\n    /// Currently, this is only used for [`Has<T>`].\n    ///\n    /// [`Has<T>`]: crate::query::Has\n    pub fn archetypal(&self) -> impl Iterator<Item = T> + '_ {\n        self.archetypal.ones().map(T::get_sparse_set_index)\n    }\n\n    /// Returns an iterator over the component IDs that this `Access` either\n    /// reads and writes or can't read or write.\n    ///\n    /// The returned flag specifies whether the list consists of the components\n    /// that the access *can* read or write (false) or whether the list consists\n    /// of the components that the access *can't* read or write (true).\n    ///\n    /// Because this method depends on internal implementation details of\n    /// `Access`, it's not recommended. Prefer to manage your own lists of\n    /// accessible components if your application needs to do that.\n    #[doc(hidden)]\n    #[deprecated]\n    pub fn component_reads_and_writes(&self) -> (impl Iterator<Item = T> + '_, bool) {\n        (\n            self.component_read_and_writes\n                .ones()\n                .map(T::get_sparse_set_index),\n            self.component_read_and_writes_inverted,\n        )\n    }\n\n    /// Returns an iterator over the component IDs that this `Access` either\n    /// writes or can't write.\n    ///\n    /// The returned flag specifies whether the list consists of the components\n    /// that the access *can* write (false) or whether the list consists of the\n    /// components that the access *can't* write (true).\n    pub(crate) fn component_writes(&self) -> (impl Iterator<Item = T> + '_, bool) {\n        (\n            self.component_writes.ones().map(T::get_sparse_set_index),\n            self.component_writes_inverted,\n        )\n    }\n}\n\n/// An [`Access`] that has been filtered to include and exclude certain combinations of elements.\n///\n/// Used internally to statically check if queries are disjoint.\n///\n/// Subtle: a `read` or `write` in `access` should not be considered to imply a\n/// `with` access.\n///\n/// For example consider `Query<Option<&T>>` this only has a `read` of `T` as doing\n/// otherwise would allow for queries to be considered disjoint when they shouldn't:\n/// - `Query<(&mut T, Option<&U>)>` read/write `T`, read `U`, with `U`\n/// - `Query<&mut T, Without<U>>` read/write `T`, without `U`\n///     from this we could reasonably conclude that the queries are disjoint but they aren't.\n///\n/// In order to solve this the actual access that `Query<(&mut T, Option<&U>)>` has\n/// is read/write `T`, read `U`. It must still have a read `U` access otherwise the following\n/// queries would be incorrectly considered disjoint:\n/// - `Query<&mut T>`  read/write `T`\n/// - `Query<Option<&T>>` accesses nothing\n///\n/// See comments the [`WorldQuery`](super::WorldQuery) impls of [`AnyOf`](super::AnyOf)/`Option`/[`Or`](super::Or) for more information.\n#[derive(Debug, Eq, PartialEq)]\npub struct FilteredAccess<T: SparseSetIndex> {\n    pub(crate) access: Access<T>,\n    pub(crate) required: FixedBitSet,\n    // An array of filter sets to express `With` or `Without` clauses in disjunctive normal form, for example: `Or<(With<A>, With<B>)>`.\n    // Filters like `(With<A>, Or<(With<B>, Without<C>)>` are expanded into `Or<((With<A>, With<B>), (With<A>, Without<C>))>`.\n    pub(crate) filter_sets: Vec<AccessFilters<T>>,\n}\n\n// This is needed since `#[derive(Clone)]` does not generate optimized `clone_from`.\nimpl<T: SparseSetIndex> Clone for FilteredAccess<T> {\n    fn clone(&self) -> Self {\n        Self {\n            access: self.access.clone(),\n            required: self.required.clone(),\n            filter_sets: self.filter_sets.clone(),\n        }\n    }\n\n    fn clone_from(&mut self, source: &Self) {\n        self.access.clone_from(&source.access);\n        self.required.clone_from(&source.required);\n        self.filter_sets.clone_from(&source.filter_sets);\n    }\n}\n\nimpl<T: SparseSetIndex> Default for FilteredAccess<T> {\n    fn default() -> Self {\n        Self::matches_everything()\n    }\n}\n\nimpl<T: SparseSetIndex> From<FilteredAccess<T>> for FilteredAccessSet<T> {\n    fn from(filtered_access: FilteredAccess<T>) -> Self {\n        let mut base = FilteredAccessSet::<T>::default();\n        base.add(filtered_access);\n        base\n    }\n}\n\n/// Records how two accesses conflict with each other\n#[derive(Debug, PartialEq, From)]\npub enum AccessConflicts {\n    /// Conflict is for all indices\n    All,\n    /// There is a conflict for a subset of indices\n    Individual(FixedBitSet),\n}\n\nimpl AccessConflicts {\n    fn add(&mut self, other: &Self) {\n        match (self, other) {\n            (s, AccessConflicts::All) => {\n                *s = AccessConflicts::All;\n            }\n            (AccessConflicts::Individual(this), AccessConflicts::Individual(other)) => {\n                this.extend(other.ones());\n            }\n            _ => {}\n        }\n    }\n\n    pub(crate) fn is_empty(&self) -> bool {\n        match self {\n            Self::All => false,\n            Self::Individual(set) => set.is_empty(),\n        }\n    }\n\n    pub(crate) fn format_conflict_list(&self, world: &World) -> String {\n        match self {\n            AccessConflicts::All => String::new(),\n            AccessConflicts::Individual(indices) => format!(\n                \" {}\",\n                indices\n                    .ones()\n                    .map(|index| world\n                        .components\n                        .get_info(ComponentId::get_sparse_set_index(index))\n                        .unwrap()\n                        .name())\n                    .collect::<Vec<&str>>()\n                    .join(\", \")\n            ),\n        }\n    }\n\n    /// An [`AccessConflicts`] which represents the absence of any conflict\n    pub(crate) fn empty() -> Self {\n        Self::Individual(FixedBitSet::new())\n    }\n}\n\nimpl<T: SparseSetIndex> From<Vec<T>> for AccessConflicts {\n    fn from(value: Vec<T>) -> Self {\n        Self::Individual(value.iter().map(T::sparse_set_index).collect())\n    }\n}\n\nimpl<T: SparseSetIndex> FilteredAccess<T> {\n    /// Returns a `FilteredAccess` which has no access and matches everything.\n    /// This is the equivalent of a `TRUE` logic atom.\n    pub fn matches_everything() -> Self {\n        Self {\n            access: Access::default(),\n            required: FixedBitSet::default(),\n            filter_sets: vec![AccessFilters::default()],\n        }\n    }\n\n    /// Returns a `FilteredAccess` which has no access and matches nothing.\n    /// This is the equivalent of a `FALSE` logic atom.\n    pub fn matches_nothing() -> Self {\n        Self {\n            access: Access::default(),\n            required: FixedBitSet::default(),\n            filter_sets: Vec::new(),\n        }\n    }\n\n    /// Returns a reference to the underlying unfiltered access.\n    #[inline]\n    pub fn access(&self) -> &Access<T> {\n        &self.access\n    }\n\n    /// Returns a mutable reference to the underlying unfiltered access.\n    #[inline]\n    pub fn access_mut(&mut self) -> &mut Access<T> {\n        &mut self.access\n    }\n\n    /// Adds access to the component given by `index`.\n    pub fn add_component_read(&mut self, index: T) {\n        self.access.add_component_read(index.clone());\n        self.add_required(index.clone());\n        self.and_with(index);\n    }\n\n    /// Adds exclusive access to the component given by `index`.\n    pub fn add_component_write(&mut self, index: T) {\n        self.access.add_component_write(index.clone());\n        self.add_required(index.clone());\n        self.and_with(index);\n    }\n\n    /// Adds access to the resource given by `index`.\n    pub fn add_resource_read(&mut self, index: T) {\n        self.access.add_resource_read(index.clone());\n    }\n\n    /// Adds exclusive access to the resource given by `index`.\n    pub fn add_resource_write(&mut self, index: T) {\n        self.access.add_resource_write(index.clone());\n    }\n\n    fn add_required(&mut self, index: T) {\n        self.required.grow_and_insert(index.sparse_set_index());\n    }\n\n    /// Adds a `With` filter: corresponds to a conjunction (AND) operation.\n    ///\n    /// Suppose we begin with `Or<(With<A>, With<B>)>`, which is represented by an array of two `AccessFilter` instances.\n    /// Adding `AND With<C>` via this method transforms it into the equivalent of  `Or<((With<A>, With<C>), (With<B>, With<C>))>`.\n    pub fn and_with(&mut self, index: T) {\n        for filter in &mut self.filter_sets {\n            filter.with.grow_and_insert(index.sparse_set_index());\n        }\n    }\n\n    /// Adds a `Without` filter: corresponds to a conjunction (AND) operation.\n    ///\n    /// Suppose we begin with `Or<(With<A>, With<B>)>`, which is represented by an array of two `AccessFilter` instances.\n    /// Adding `AND Without<C>` via this method transforms it into the equivalent of  `Or<((With<A>, Without<C>), (With<B>, Without<C>))>`.\n    pub fn and_without(&mut self, index: T) {\n        for filter in &mut self.filter_sets {\n            filter.without.grow_and_insert(index.sparse_set_index());\n        }\n    }\n\n    /// Appends an array of filters: corresponds to a disjunction (OR) operation.\n    ///\n    /// As the underlying array of filters represents a disjunction,\n    /// where each element (`AccessFilters`) represents a conjunction,\n    /// we can simply append to the array.\n    pub fn append_or(&mut self, other: &FilteredAccess<T>) {\n        self.filter_sets.append(&mut other.filter_sets.clone());\n    }\n\n    /// Adds all of the accesses from `other` to `self`.\n    pub fn extend_access(&mut self, other: &FilteredAccess<T>) {\n        self.access.extend(&other.access);\n    }\n\n    /// Returns `true` if this and `other` can be active at the same time.\n    pub fn is_compatible(&self, other: &FilteredAccess<T>) -> bool {\n        if self.access.is_compatible(&other.access) {\n            return true;\n        }\n\n        // If the access instances are incompatible, we want to check that whether filters can\n        // guarantee that queries are disjoint.\n        // Since the `filter_sets` array represents a Disjunctive Normal Form formula (\"ORs of ANDs\"),\n        // we need to make sure that each filter set (ANDs) rule out every filter set from the `other` instance.\n        //\n        // For example, `Query<&mut C, Or<(With<A>, Without<B>)>>` is compatible `Query<&mut C, (With<B>, Without<A>)>`,\n        // but `Query<&mut C, Or<(Without<A>, Without<B>)>>` isn't compatible with `Query<&mut C, Or<(With<A>, With<B>)>>`.\n        self.filter_sets.iter().all(|filter| {\n            other\n                .filter_sets\n                .iter()\n                .all(|other_filter| filter.is_ruled_out_by(other_filter))\n        })\n    }\n\n    /// Returns a vector of elements that this and `other` cannot access at the same time.\n    pub fn get_conflicts(&self, other: &FilteredAccess<T>) -> AccessConflicts {\n        if !self.is_compatible(other) {\n            // filters are disjoint, so we can just look at the unfiltered intersection\n            return self.access.get_conflicts(&other.access);\n        }\n        AccessConflicts::empty()\n    }\n\n    /// Adds all access and filters from `other`.\n    ///\n    /// Corresponds to a conjunction operation (AND) for filters.\n    ///\n    /// Extending `Or<(With<A>, Without<B>)>` with `Or<(With<C>, Without<D>)>` will result in\n    /// `Or<((With<A>, With<C>), (With<A>, Without<D>), (Without<B>, With<C>), (Without<B>, Without<D>))>`.\n    pub fn extend(&mut self, other: &FilteredAccess<T>) {\n        self.access.extend(&other.access);\n        self.required.union_with(&other.required);\n\n        // We can avoid allocating a new array of bitsets if `other` contains just a single set of filters:\n        // in this case we can short-circuit by performing an in-place union for each bitset.\n        if other.filter_sets.len() == 1 {\n            for filter in &mut self.filter_sets {\n                filter.with.union_with(&other.filter_sets[0].with);\n                filter.without.union_with(&other.filter_sets[0].without);\n            }\n            return;\n        }\n\n        let mut new_filters = Vec::with_capacity(self.filter_sets.len() * other.filter_sets.len());\n        for filter in &self.filter_sets {\n            for other_filter in &other.filter_sets {\n                let mut new_filter = filter.clone();\n                new_filter.with.union_with(&other_filter.with);\n                new_filter.without.union_with(&other_filter.without);\n                new_filters.push(new_filter);\n            }\n        }\n        self.filter_sets = new_filters;\n    }\n\n    /// Sets the underlying unfiltered access as having access to all indexed elements.\n    pub fn read_all(&mut self) {\n        self.access.read_all();\n    }\n\n    /// Sets the underlying unfiltered access as having mutable access to all indexed elements.\n    pub fn write_all(&mut self) {\n        self.access.write_all();\n    }\n\n    /// Sets the underlying unfiltered access as having access to all components.\n    pub fn read_all_components(&mut self) {\n        self.access.read_all_components();\n    }\n\n    /// Sets the underlying unfiltered access as having mutable access to all components.\n    pub fn write_all_components(&mut self) {\n        self.access.write_all_components();\n    }\n\n    /// Returns `true` if the set is a subset of another, i.e. `other` contains\n    /// at least all the values in `self`.\n    pub fn is_subset(&self, other: &FilteredAccess<T>) -> bool {\n        self.required.is_subset(&other.required) && self.access().is_subset(other.access())\n    }\n\n    /// Returns the indices of the elements that this access filters for.\n    pub fn with_filters(&self) -> impl Iterator<Item = T> + '_ {\n        self.filter_sets\n            .iter()\n            .flat_map(|f| f.with.ones().map(T::get_sparse_set_index))\n    }\n\n    /// Returns the indices of the elements that this access filters out.\n    pub fn without_filters(&self) -> impl Iterator<Item = T> + '_ {\n        self.filter_sets\n            .iter()\n            .flat_map(|f| f.without.ones().map(T::get_sparse_set_index))\n    }\n}\n\n#[derive(Eq, PartialEq)]\npub(crate) struct AccessFilters<T> {\n    pub(crate) with: FixedBitSet,\n    pub(crate) without: FixedBitSet,\n    _index_type: PhantomData<T>,\n}\n\n// This is needed since `#[derive(Clone)]` does not generate optimized `clone_from`.\nimpl<T: SparseSetIndex> Clone for AccessFilters<T> {\n    fn clone(&self) -> Self {\n        Self {\n            with: self.with.clone(),\n            without: self.without.clone(),\n            _index_type: PhantomData,\n        }\n    }\n\n    fn clone_from(&mut self, source: &Self) {\n        self.with.clone_from(&source.with);\n        self.without.clone_from(&source.without);\n    }\n}\n\nimpl<T: SparseSetIndex + Debug> Debug for AccessFilters<T> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"AccessFilters\")\n            .field(\"with\", &FormattedBitSet::<T>::new(&self.with))\n            .field(\"without\", &FormattedBitSet::<T>::new(&self.without))\n            .finish()\n    }\n}\n\nimpl<T: SparseSetIndex> Default for AccessFilters<T> {\n    fn default() -> Self {\n        Self {\n            with: FixedBitSet::default(),\n            without: FixedBitSet::default(),\n            _index_type: PhantomData,\n        }\n    }\n}\n\nimpl<T: SparseSetIndex> AccessFilters<T> {\n    fn is_ruled_out_by(&self, other: &Self) -> bool {\n        // Although not technically complete, we don't consider the case when `AccessFilters`'s\n        // `without` bitset contradicts its own `with` bitset (e.g. `(With<A>, Without<A>)`).\n        // Such query would be considered compatible with any other query, but as it's almost\n        // always an error, we ignore this case instead of treating such query as compatible\n        // with others.\n        !self.with.is_disjoint(&other.without) || !self.without.is_disjoint(&other.with)\n    }\n}\n\n/// A collection of [`FilteredAccess`] instances.\n///\n/// Used internally to statically check if systems have conflicting access.\n///\n/// It stores multiple sets of accesses.\n/// - A \"combined\" set, which is the access of all filters in this set combined.\n/// - The set of access of each individual filters in this set.\n#[derive(Debug, PartialEq, Eq)]\npub struct FilteredAccessSet<T: SparseSetIndex> {\n    combined_access: Access<T>,\n    filtered_accesses: Vec<FilteredAccess<T>>,\n}\n\n// This is needed since `#[derive(Clone)]` does not generate optimized `clone_from`.\nimpl<T: SparseSetIndex> Clone for FilteredAccessSet<T> {\n    fn clone(&self) -> Self {\n        Self {\n            combined_access: self.combined_access.clone(),\n            filtered_accesses: self.filtered_accesses.clone(),\n        }\n    }\n\n    fn clone_from(&mut self, source: &Self) {\n        self.combined_access.clone_from(&source.combined_access);\n        self.filtered_accesses.clone_from(&source.filtered_accesses);\n    }\n}\n\nimpl<T: SparseSetIndex> FilteredAccessSet<T> {\n    /// Returns a reference to the unfiltered access of the entire set.\n    #[inline]\n    pub fn combined_access(&self) -> &Access<T> {\n        &self.combined_access\n    }\n\n    /// Returns `true` if this and `other` can be active at the same time.\n    ///\n    /// Access conflict resolution happen in two steps:\n    /// 1. A \"coarse\" check, if there is no mutual unfiltered conflict between\n    ///    `self` and `other`, we already know that the two access sets are\n    ///    compatible.\n    /// 2. A \"fine grained\" check, it kicks in when the \"coarse\" check fails.\n    ///    the two access sets might still be compatible if some of the accesses\n    ///    are restricted with the [`With`](super::With) or [`Without`](super::Without) filters so that access is\n    ///    mutually exclusive. The fine grained phase iterates over all filters in\n    ///    the `self` set and compares it to all the filters in the `other` set,\n    ///    making sure they are all mutually compatible.\n    pub fn is_compatible(&self, other: &FilteredAccessSet<T>) -> bool {\n        if self.combined_access.is_compatible(other.combined_access()) {\n            return true;\n        }\n        for filtered in &self.filtered_accesses {\n            for other_filtered in &other.filtered_accesses {\n                if !filtered.is_compatible(other_filtered) {\n                    return false;\n                }\n            }\n        }\n        true\n    }\n\n    /// Returns a vector of elements that this set and `other` cannot access at the same time.\n    pub fn get_conflicts(&self, other: &FilteredAccessSet<T>) -> AccessConflicts {\n        // if the unfiltered access is incompatible, must check each pair\n        let mut conflicts = AccessConflicts::empty();\n        if !self.combined_access.is_compatible(other.combined_access()) {\n            for filtered in &self.filtered_accesses {\n                for other_filtered in &other.filtered_accesses {\n                    conflicts.add(&filtered.get_conflicts(other_filtered));\n                }\n            }\n        }\n        conflicts\n    }\n\n    /// Returns a vector of elements that this set and `other` cannot access at the same time.\n    pub fn get_conflicts_single(&self, filtered_access: &FilteredAccess<T>) -> AccessConflicts {\n        // if the unfiltered access is incompatible, must check each pair\n        let mut conflicts = AccessConflicts::empty();\n        if !self.combined_access.is_compatible(filtered_access.access()) {\n            for filtered in &self.filtered_accesses {\n                conflicts.add(&filtered.get_conflicts(filtered_access));\n            }\n        }\n        conflicts\n    }\n\n    /// Adds the filtered access to the set.\n    pub fn add(&mut self, filtered_access: FilteredAccess<T>) {\n        self.combined_access.extend(&filtered_access.access);\n        self.filtered_accesses.push(filtered_access);\n    }\n\n    /// Adds a read access to a resource to the set.\n    pub(crate) fn add_unfiltered_resource_read(&mut self, index: T) {\n        let mut filter = FilteredAccess::default();\n        filter.add_resource_read(index);\n        self.add(filter);\n    }\n\n    /// Adds a write access to a resource to the set.\n    pub(crate) fn add_unfiltered_resource_write(&mut self, index: T) {\n        let mut filter = FilteredAccess::default();\n        filter.add_resource_write(index);\n        self.add(filter);\n    }\n\n    /// Adds read access to all resources to the set.\n    pub(crate) fn add_unfiltered_read_all_resources(&mut self) {\n        let mut filter = FilteredAccess::default();\n        filter.access.read_all_resources();\n        self.add(filter);\n    }\n\n    /// Adds write access to all resources to the set.\n    pub(crate) fn add_unfiltered_write_all_resources(&mut self) {\n        let mut filter = FilteredAccess::default();\n        filter.access.write_all_resources();\n        self.add(filter);\n    }\n\n    /// Adds all of the accesses from the passed set to `self`.\n    pub fn extend(&mut self, filtered_access_set: FilteredAccessSet<T>) {\n        self.combined_access\n            .extend(&filtered_access_set.combined_access);\n        self.filtered_accesses\n            .extend(filtered_access_set.filtered_accesses);\n    }\n\n    /// Marks the set as reading all possible indices of type T.\n    pub fn read_all(&mut self) {\n        self.combined_access.read_all();\n    }\n\n    /// Marks the set as writing all T.\n    pub fn write_all(&mut self) {\n        self.combined_access.write_all();\n    }\n\n    /// Removes all accesses stored in this set.\n    pub fn clear(&mut self) {\n        self.combined_access.clear();\n        self.filtered_accesses.clear();\n    }\n}\n\nimpl<T: SparseSetIndex> Default for FilteredAccessSet<T> {\n    fn default() -> Self {\n        Self {\n            combined_access: Default::default(),\n            filtered_accesses: Vec::new(),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::query::{\n        access::AccessFilters, Access, AccessConflicts, FilteredAccess, FilteredAccessSet,\n    };\n    use core::marker::PhantomData;\n    use fixedbitset::FixedBitSet;\n\n    fn create_sample_access() -> Access<usize> {\n        let mut access = Access::<usize>::default();\n\n        access.add_component_read(1);\n        access.add_component_read(2);\n        access.add_component_write(3);\n        access.add_archetypal(5);\n        access.read_all();\n\n        access\n    }\n\n    fn create_sample_filtered_access() -> FilteredAccess<usize> {\n        let mut filtered_access = FilteredAccess::<usize>::default();\n\n        filtered_access.add_component_write(1);\n        filtered_access.add_component_read(2);\n        filtered_access.add_required(3);\n        filtered_access.and_with(4);\n\n        filtered_access\n    }\n\n    fn create_sample_access_filters() -> AccessFilters<usize> {\n        let mut access_filters = AccessFilters::<usize>::default();\n\n        access_filters.with.grow_and_insert(3);\n        access_filters.without.grow_and_insert(5);\n\n        access_filters\n    }\n\n    fn create_sample_filtered_access_set() -> FilteredAccessSet<usize> {\n        let mut filtered_access_set = FilteredAccessSet::<usize>::default();\n\n        filtered_access_set.add_unfiltered_resource_read(2);\n        filtered_access_set.add_unfiltered_resource_write(4);\n        filtered_access_set.read_all();\n\n        filtered_access_set\n    }\n\n    #[test]\n    fn test_access_clone() {\n        let original: Access<usize> = create_sample_access();\n        let cloned = original.clone();\n\n        assert_eq!(original, cloned);\n    }\n\n    #[test]\n    fn test_access_clone_from() {\n        let original: Access<usize> = create_sample_access();\n        let mut cloned = Access::<usize>::default();\n\n        cloned.add_component_write(7);\n        cloned.add_component_read(4);\n        cloned.add_archetypal(8);\n        cloned.write_all();\n\n        cloned.clone_from(&original);\n\n        assert_eq!(original, cloned);\n    }\n\n    #[test]\n    fn test_filtered_access_clone() {\n        let original: FilteredAccess<usize> = create_sample_filtered_access();\n        let cloned = original.clone();\n\n        assert_eq!(original, cloned);\n    }\n\n    #[test]\n    fn test_filtered_access_clone_from() {\n        let original: FilteredAccess<usize> = create_sample_filtered_access();\n        let mut cloned = FilteredAccess::<usize>::default();\n\n        cloned.add_component_write(7);\n        cloned.add_component_read(4);\n        cloned.append_or(&FilteredAccess::default());\n\n        cloned.clone_from(&original);\n\n        assert_eq!(original, cloned);\n    }\n\n    #[test]\n    fn test_access_filters_clone() {\n        let original: AccessFilters<usize> = create_sample_access_filters();\n        let cloned = original.clone();\n\n        assert_eq!(original, cloned);\n    }\n\n    #[test]\n    fn test_access_filters_clone_from() {\n        let original: AccessFilters<usize> = create_sample_access_filters();\n        let mut cloned = AccessFilters::<usize>::default();\n\n        cloned.with.grow_and_insert(1);\n        cloned.without.grow_and_insert(2);\n\n        cloned.clone_from(&original);\n\n        assert_eq!(original, cloned);\n    }\n\n    #[test]\n    fn test_filtered_access_set_clone() {\n        let original: FilteredAccessSet<usize> = create_sample_filtered_access_set();\n        let cloned = original.clone();\n\n        assert_eq!(original, cloned);\n    }\n\n    #[test]\n    fn test_filtered_access_set_from() {\n        let original: FilteredAccessSet<usize> = create_sample_filtered_access_set();\n        let mut cloned = FilteredAccessSet::<usize>::default();\n\n        cloned.add_unfiltered_resource_read(7);\n        cloned.add_unfiltered_resource_write(9);\n        cloned.write_all();\n\n        cloned.clone_from(&original);\n\n        assert_eq!(original, cloned);\n    }\n\n    #[test]\n    fn read_all_access_conflicts() {\n        // read_all / single write\n        let mut access_a = Access::<usize>::default();\n        access_a.add_component_write(0);\n\n        let mut access_b = Access::<usize>::default();\n        access_b.read_all();\n\n        assert!(!access_b.is_compatible(&access_a));\n\n        // read_all / read_all\n        let mut access_a = Access::<usize>::default();\n        access_a.read_all();\n\n        let mut access_b = Access::<usize>::default();\n        access_b.read_all();\n\n        assert!(access_b.is_compatible(&access_a));\n    }\n\n    #[test]\n    fn access_get_conflicts() {\n        let mut access_a = Access::<usize>::default();\n        access_a.add_component_read(0);\n        access_a.add_component_read(1);\n\n        let mut access_b = Access::<usize>::default();\n        access_b.add_component_read(0);\n        access_b.add_component_write(1);\n\n        assert_eq!(access_a.get_conflicts(&access_b), vec![1_usize].into());\n\n        let mut access_c = Access::<usize>::default();\n        access_c.add_component_write(0);\n        access_c.add_component_write(1);\n\n        assert_eq!(\n            access_a.get_conflicts(&access_c),\n            vec![0_usize, 1_usize].into()\n        );\n        assert_eq!(\n            access_b.get_conflicts(&access_c),\n            vec![0_usize, 1_usize].into()\n        );\n\n        let mut access_d = Access::<usize>::default();\n        access_d.add_component_read(0);\n\n        assert_eq!(access_d.get_conflicts(&access_a), AccessConflicts::empty());\n        assert_eq!(access_d.get_conflicts(&access_b), AccessConflicts::empty());\n        assert_eq!(access_d.get_conflicts(&access_c), vec![0_usize].into());\n    }\n\n    #[test]\n    fn filtered_combined_access() {\n        let mut access_a = FilteredAccessSet::<usize>::default();\n        access_a.add_unfiltered_resource_read(1);\n\n        let mut filter_b = FilteredAccess::<usize>::default();\n        filter_b.add_resource_write(1);\n\n        let conflicts = access_a.get_conflicts_single(&filter_b);\n        assert_eq!(\n            &conflicts,\n            &AccessConflicts::from(vec![1_usize]),\n            \"access_a: {access_a:?}, filter_b: {filter_b:?}\"\n        );\n    }\n\n    #[test]\n    fn filtered_access_extend() {\n        let mut access_a = FilteredAccess::<usize>::default();\n        access_a.add_component_read(0);\n        access_a.add_component_read(1);\n        access_a.and_with(2);\n\n        let mut access_b = FilteredAccess::<usize>::default();\n        access_b.add_component_read(0);\n        access_b.add_component_write(3);\n        access_b.and_without(4);\n\n        access_a.extend(&access_b);\n\n        let mut expected = FilteredAccess::<usize>::default();\n        expected.add_component_read(0);\n        expected.add_component_read(1);\n        expected.and_with(2);\n        expected.add_component_write(3);\n        expected.and_without(4);\n\n        assert!(access_a.eq(&expected));\n    }\n\n    #[test]\n    fn filtered_access_extend_or() {\n        let mut access_a = FilteredAccess::<usize>::default();\n        // Exclusive access to `(&mut A, &mut B)`.\n        access_a.add_component_write(0);\n        access_a.add_component_write(1);\n\n        // Filter by `With<C>`.\n        let mut access_b = FilteredAccess::<usize>::default();\n        access_b.and_with(2);\n\n        // Filter by `(With<D>, Without<E>)`.\n        let mut access_c = FilteredAccess::<usize>::default();\n        access_c.and_with(3);\n        access_c.and_without(4);\n\n        // Turns `access_b` into `Or<(With<C>, (With<D>, Without<D>))>`.\n        access_b.append_or(&access_c);\n        // Applies the filters to the initial query, which corresponds to the FilteredAccess'\n        // representation of `Query<(&mut A, &mut B), Or<(With<C>, (With<D>, Without<E>))>>`.\n        access_a.extend(&access_b);\n\n        // Construct the expected `FilteredAccess` struct.\n        // The intention here is to test that exclusive access implied by `add_write`\n        // forms correct normalized access structs when extended with `Or` filters.\n        let mut expected = FilteredAccess::<usize>::default();\n        expected.add_component_write(0);\n        expected.add_component_write(1);\n        // The resulted access is expected to represent `Or<((With<A>, With<B>, With<C>), (With<A>, With<B>, With<D>, Without<E>))>`.\n        expected.filter_sets = vec![\n            AccessFilters {\n                with: FixedBitSet::with_capacity_and_blocks(3, [0b111]),\n                without: FixedBitSet::default(),\n                _index_type: PhantomData,\n            },\n            AccessFilters {\n                with: FixedBitSet::with_capacity_and_blocks(4, [0b1011]),\n                without: FixedBitSet::with_capacity_and_blocks(5, [0b10000]),\n                _index_type: PhantomData,\n            },\n        ];\n\n        assert_eq!(access_a, expected);\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "1a7b8f38e25e06db3761e218559d1e5492120e78",
    "func": "// Copyright 2016-2019 Cargo-Bundle developers <https://github.com/burtonageo/cargo-bundle>\n// Copyright 2019-2024 Tauri Programme within The Commons Conservancy\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n\n// An iOS package is laid out like:\n//\n// Foobar.app         # Actually a directory\n//     Foobar             # The main binary executable of the app\n//     Info.plist         # An XML file containing the app's metadata\n//     ...                # Icons and other resource files\n//\n// See https://developer.apple.com/go/?id=bundle-structure for a full\n// explanation.\n\nuse crate::{bundle::common, Settings};\n\nuse anyhow::Context;\nuse image::{codecs::png::PngDecoder, GenericImageView, ImageDecoder};\n\nuse std::{\n  collections::BTreeSet,\n  ffi::OsStr,\n  fs::{self, File},\n  io::{BufReader, Write},\n  path::{Path, PathBuf},\n};\n\n/// Bundles the project.\n/// Returns a vector of PathBuf that shows where the .app was created.\npub fn bundle_project(settings: &Settings) -> crate::Result<Vec<PathBuf>> {\n  log::warn!(\"iOS bundle support is still experimental.\");\n\n  let app_product_name = format!(\"{}.app\", settings.product_name());\n\n  let app_bundle_path = settings\n    .project_out_directory()\n    .join(\"bundle/ios\")\n    .join(&app_product_name);\n\n  log::info!(action = \"Bundling\"; \"{} ({})\", app_product_name, app_bundle_path.display());\n\n  if app_bundle_path.exists() {\n    fs::remove_dir_all(&app_bundle_path)\n      .with_context(|| format!(\"Failed to remove old {}\", app_product_name))?;\n  }\n  fs::create_dir_all(&app_bundle_path)\n    .with_context(|| format!(\"Failed to create bundle directory at {:?}\", app_bundle_path))?;\n\n  for src in settings.resource_files() {\n    let src = src?;\n    let dest = app_bundle_path.join(tauri_utils::resources::resource_relpath(&src));\n    common::copy_file(&src, &dest)\n      .with_context(|| format!(\"Failed to copy resource file {:?}\", src))?;\n  }\n\n  let icon_filenames = generate_icon_files(&app_bundle_path, settings)\n    .with_context(|| \"Failed to create app icons\")?;\n  generate_info_plist(&app_bundle_path, settings, &icon_filenames)\n    .with_context(|| \"Failed to create Info.plist\")?;\n\n  for bin in settings.binaries() {\n    let bin_path = settings.binary_path(bin);\n    common::copy_file(&bin_path, app_bundle_path.join(bin.name()))\n      .with_context(|| format!(\"Failed to copy binary from {:?}\", bin_path))?;\n  }\n\n  Ok(vec![app_bundle_path])\n}\n\n/// Generate the icon files and store them under the `bundle_dir`.\nfn generate_icon_files(bundle_dir: &Path, settings: &Settings) -> crate::Result<Vec<String>> {\n  let mut filenames = Vec::new();\n  {\n    let mut get_dest_path = |width: u32, height: u32, is_retina: bool| {\n      let filename = format!(\n        \"icon_{}x{}{}.png\",\n        width,\n        height,\n        if is_retina { \"@2x\" } else { \"\" }\n      );\n      let path = bundle_dir.join(&filename);\n      filenames.push(filename);\n      path\n    };\n    let mut sizes = BTreeSet::new();\n    // Prefer PNG files.\n    for icon_path in settings.icon_files() {\n      let icon_path = icon_path?;\n      if icon_path.extension() != Some(OsStr::new(\"png\")) {\n        continue;\n      }\n      let decoder = PngDecoder::new(BufReader::new(File::open(&icon_path)?))?;\n      let width = decoder.dimensions().0;\n      let height = decoder.dimensions().1;\n      let is_retina = common::is_retina(&icon_path);\n      if !sizes.contains(&(width, height, is_retina)) {\n        sizes.insert((width, height, is_retina));\n        let dest_path = get_dest_path(width, height, is_retina);\n        common::copy_file(&icon_path, &dest_path)?;\n      }\n    }\n    // Fall back to non-PNG files for any missing sizes.\n    for icon_path in settings.icon_files() {\n      let icon_path = icon_path?;\n      if icon_path.extension() == Some(OsStr::new(\"png\")) {\n        continue;\n      } else if icon_path.extension() == Some(OsStr::new(\"icns\")) {\n        let icon_family = icns::IconFamily::read(File::open(&icon_path)?)?;\n        for icon_type in icon_family.available_icons() {\n          let width = icon_type.screen_width();\n          let height = icon_type.screen_height();\n          let is_retina = icon_type.pixel_density() > 1;\n          if !sizes.contains(&(width, height, is_retina)) {\n            sizes.insert((width, height, is_retina));\n            let dest_path = get_dest_path(width, height, is_retina);\n            let icon = icon_family.get_icon_with_type(icon_type)?;\n            icon.write_png(File::create(dest_path)?)?;\n          }\n        }\n      } else {\n        let icon = image::open(&icon_path)?;\n        let (width, height) = icon.dimensions();\n        let is_retina = common::is_retina(&icon_path);\n        if !sizes.contains(&(width, height, is_retina)) {\n          sizes.insert((width, height, is_retina));\n          let dest_path = get_dest_path(width, height, is_retina);\n          icon.write_to(\n            &mut common::create_file(&dest_path)?,\n            image::ImageFormat::Png,\n          )?;\n        }\n      }\n    }\n  }\n  Ok(filenames)\n}\n\n/// Generates the Info.plist file\nfn generate_info_plist(\n  bundle_dir: &Path,\n  settings: &Settings,\n  icon_filenames: &[String],\n) -> crate::Result<()> {\n  let file = &mut common::create_file(&bundle_dir.join(\"Info.plist\"))?;\n  writeln!(\n    file,\n    \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\\\n          <!DOCTYPE plist PUBLIC \\\"-//Apple Computer//DTD PLIST 1.0//EN\\\" \\\n          \\\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\\\">\\n\\\n          <plist version=\\\"1.0\\\">\\n\\\n          <dict>\"\n  )?;\n\n  writeln!(\n    file,\n    \"  <key>CFBundleIdentifier</key>\\n  <string>{}</string>\",\n    settings.bundle_identifier()\n  )?;\n  writeln!(\n    file,\n    \"  <key>CFBundleDisplayName</key>\\n  <string>{}</string>\",\n    settings.product_name()\n  )?;\n  writeln!(\n    file,\n    \"  <key>CFBundleName</key>\\n  <string>{}</string>\",\n    settings.product_name()\n  )?;\n  writeln!(\n    file,\n    \"  <key>CFBundleExecutable</key>\\n  <string>{}</string>\",\n    settings.main_binary_name()?\n  )?;\n  writeln!(\n    file,\n    \"  <key>CFBundleVersion</key>\\n  <string>{}</string>\",\n    settings.version_string()\n  )?;\n  writeln!(\n    file,\n    \"  <key>CFBundleShortVersionString</key>\\n  <string>{}</string>\",\n    settings.version_string()\n  )?;\n  writeln!(\n    file,\n    \"  <key>CFBundleDevelopmentRegion</key>\\n  <string>en_US</string>\"\n  )?;\n\n  if !icon_filenames.is_empty() {\n    writeln!(file, \"  <key>CFBundleIconFiles</key>\\n  <array>\")?;\n    for filename in icon_filenames {\n      writeln!(file, \"    <string>{}</string>\", filename)?;\n    }\n    writeln!(file, \"  </array>\")?;\n  }\n  writeln!(file, \"  <key>LSRequiresIPhoneOS</key>\\n  <true/>\")?;\n  writeln!(file, \"</dict>\\n</plist>\")?;\n  file.flush()?;\n  Ok(())\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "d4730a166ee4c3938bb6fe41c0f802d6bc2421cd",
    "func": "use bevy_ecs::{prelude::Entity, world::World};\n#[cfg(feature = \"trace\")]\nuse bevy_utils::tracing::info_span;\nuse bevy_utils::HashMap;\n\nuse alloc::{borrow::Cow, collections::VecDeque};\nuse derive_more::derive::{Display, Error, From};\nuse smallvec::{smallvec, SmallVec};\n\nuse crate::{\n    diagnostic::internal::{DiagnosticsRecorder, RenderDiagnosticsMutex},\n    render_graph::{\n        Edge, InternedRenderLabel, InternedRenderSubGraph, NodeRunError, NodeState, RenderGraph,\n        RenderGraphContext, SlotLabel, SlotType, SlotValue,\n    },\n    renderer::{RenderContext, RenderDevice},\n};\n\n/// The [`RenderGraphRunner`] is responsible for executing a [`RenderGraph`].\n///\n/// It will run all nodes in the graph sequentially in the correct order (defined by the edges).\n/// Each [`Node`](crate::render_graph::Node) can run any arbitrary code, but will generally\n/// either send directly a [`CommandBuffer`] or a task that will asynchronously generate a [`CommandBuffer`]\n///\n/// After running the graph, the [`RenderGraphRunner`] will execute in parallel all the tasks to get\n/// an ordered list of [`CommandBuffer`]s to execute. These [`CommandBuffer`] will be submitted to the GPU\n/// sequentially in the order that the tasks were submitted. (which is the order of the [`RenderGraph`])\n///\n/// [`CommandBuffer`]: wgpu::CommandBuffer\npub(crate) struct RenderGraphRunner;\n\n#[derive(Error, Display, Debug, From)]\npub enum RenderGraphRunnerError {\n    NodeRunError(NodeRunError),\n    #[display(\"node output slot not set (index {slot_index}, name {slot_name})\")]\n    EmptyNodeOutputSlot {\n        type_name: &'static str,\n        slot_index: usize,\n        slot_name: Cow<'static, str>,\n    },\n    #[display(\"graph '{sub_graph:?}' could not be run because slot '{slot_name}' at index {slot_index} has no value\")]\n    MissingInput {\n        slot_index: usize,\n        slot_name: Cow<'static, str>,\n        sub_graph: Option<InternedRenderSubGraph>,\n    },\n    #[display(\"attempted to use the wrong type for input slot\")]\n    MismatchedInputSlotType {\n        slot_index: usize,\n        label: SlotLabel,\n        expected: SlotType,\n        actual: SlotType,\n    },\n    #[display(\n        \"node (name: '{node_name:?}') has {slot_count} input slots, but was provided {value_count} values\"\n    )]\n    MismatchedInputCount {\n        node_name: InternedRenderLabel,\n        slot_count: usize,\n        value_count: usize,\n    },\n}\n\nimpl RenderGraphRunner {\n    pub fn run(\n        graph: &RenderGraph,\n        render_device: RenderDevice,\n        mut diagnostics_recorder: Option<DiagnosticsRecorder>,\n        queue: &wgpu::Queue,\n        adapter: &wgpu::Adapter,\n        world: &World,\n        finalizer: impl FnOnce(&mut wgpu::CommandEncoder),\n    ) -> Result<Option<DiagnosticsRecorder>, RenderGraphRunnerError> {\n        if let Some(recorder) = &mut diagnostics_recorder {\n            recorder.begin_frame();\n        }\n\n        let mut render_context =\n            RenderContext::new(render_device, adapter.get_info(), diagnostics_recorder);\n        Self::run_graph(graph, None, &mut render_context, world, &[], None)?;\n        finalizer(render_context.command_encoder());\n\n        let (render_device, mut diagnostics_recorder) = {\n            #[cfg(feature = \"trace\")]\n            let _span = info_span!(\"submit_graph_commands\").entered();\n\n            let (commands, render_device, diagnostics_recorder) = render_context.finish();\n            queue.submit(commands);\n\n            (render_device, diagnostics_recorder)\n        };\n\n        if let Some(recorder) = &mut diagnostics_recorder {\n            let render_diagnostics_mutex = world.resource::<RenderDiagnosticsMutex>().0.clone();\n            recorder.finish_frame(&render_device, move |diagnostics| {\n                *render_diagnostics_mutex.lock().expect(\"lock poisoned\") = Some(diagnostics);\n            });\n        }\n\n        Ok(diagnostics_recorder)\n    }\n\n    /// Runs the [`RenderGraph`] and all its sub-graphs sequentially, making sure that all nodes are\n    /// run in the correct order. (a node only runs when all its dependencies have finished running)\n    fn run_graph<'w>(\n        graph: &RenderGraph,\n        sub_graph: Option<InternedRenderSubGraph>,\n        render_context: &mut RenderContext<'w>,\n        world: &'w World,\n        inputs: &[SlotValue],\n        view_entity: Option<Entity>,\n    ) -> Result<(), RenderGraphRunnerError> {\n        let mut node_outputs: HashMap<InternedRenderLabel, SmallVec<[SlotValue; 4]>> =\n            HashMap::default();\n        #[cfg(feature = \"trace\")]\n        let span = if let Some(label) = &sub_graph {\n            info_span!(\"run_graph\", name = format!(\"{label:?}\"))\n        } else {\n            info_span!(\"run_graph\", name = \"main_graph\")\n        };\n        #[cfg(feature = \"trace\")]\n        let _guard = span.enter();\n\n        // Queue up nodes without inputs, which can be run immediately\n        let mut node_queue: VecDeque<&NodeState> = graph\n            .iter_nodes()\n            .filter(|node| node.input_slots.is_empty())\n            .collect();\n\n        // pass inputs into the graph\n        if let Some(input_node) = graph.get_input_node() {\n            let mut input_values: SmallVec<[SlotValue; 4]> = SmallVec::new();\n            for (i, input_slot) in input_node.input_slots.iter().enumerate() {\n                if let Some(input_value) = inputs.get(i) {\n                    if input_slot.slot_type != input_value.slot_type() {\n                        return Err(RenderGraphRunnerError::MismatchedInputSlotType {\n                            slot_index: i,\n                            actual: input_value.slot_type(),\n                            expected: input_slot.slot_type,\n                            label: input_slot.name.clone().into(),\n                        });\n                    }\n                    input_values.push(input_value.clone());\n                } else {\n                    return Err(RenderGraphRunnerError::MissingInput {\n                        slot_index: i,\n                        slot_name: input_slot.name.clone(),\n                        sub_graph,\n                    });\n                }\n            }\n\n            node_outputs.insert(input_node.label, input_values);\n\n            for (_, node_state) in graph\n                .iter_node_outputs(input_node.label)\n                .expect(\"node exists\")\n            {\n                node_queue.push_front(node_state);\n            }\n        }\n\n        'handle_node: while let Some(node_state) = node_queue.pop_back() {\n            // skip nodes that are already processed\n            if node_outputs.contains_key(&node_state.label) {\n                continue;\n            }\n\n            let mut slot_indices_and_inputs: SmallVec<[(usize, SlotValue); 4]> = SmallVec::new();\n            // check if all dependencies have finished running\n            for (edge, input_node) in graph\n                .iter_node_inputs(node_state.label)\n                .expect(\"node is in graph\")\n            {\n                match edge {\n                    Edge::SlotEdge {\n                        output_index,\n                        input_index,\n                        ..\n                    } => {\n                        if let Some(outputs) = node_outputs.get(&input_node.label) {\n                            slot_indices_and_inputs\n                                .push((*input_index, outputs[*output_index].clone()));\n                        } else {\n                            node_queue.push_front(node_state);\n                            continue 'handle_node;\n                        }\n                    }\n                    Edge::NodeEdge { .. } => {\n                        if !node_outputs.contains_key(&input_node.label) {\n                            node_queue.push_front(node_state);\n                            continue 'handle_node;\n                        }\n                    }\n                }\n            }\n\n            // construct final sorted input list\n            slot_indices_and_inputs.sort_by_key(|(index, _)| *index);\n            let inputs: SmallVec<[SlotValue; 4]> = slot_indices_and_inputs\n                .into_iter()\n                .map(|(_, value)| value)\n                .collect();\n\n            if inputs.len() != node_state.input_slots.len() {\n                return Err(RenderGraphRunnerError::MismatchedInputCount {\n                    node_name: node_state.label,\n                    slot_count: node_state.input_slots.len(),\n                    value_count: inputs.len(),\n                });\n            }\n\n            let mut outputs: SmallVec<[Option<SlotValue>; 4]> =\n                smallvec![None; node_state.output_slots.len()];\n            {\n                let mut context = RenderGraphContext::new(graph, node_state, &inputs, &mut outputs);\n                if let Some(view_entity) = view_entity {\n                    context.set_view_entity(view_entity);\n                }\n\n                {\n                    #[cfg(feature = \"trace\")]\n                    let _span = info_span!(\"node\", name = node_state.type_name).entered();\n\n                    node_state.node.run(&mut context, render_context, world)?;\n                }\n\n                for run_sub_graph in context.finish() {\n                    let sub_graph = graph\n                        .get_sub_graph(run_sub_graph.sub_graph)\n                        .expect(\"sub graph exists because it was validated when queued.\");\n                    Self::run_graph(\n                        sub_graph,\n                        Some(run_sub_graph.sub_graph),\n                        render_context,\n                        world,\n                        &run_sub_graph.inputs,\n                        run_sub_graph.view_entity,\n                    )?;\n                }\n            }\n\n            let mut values: SmallVec<[SlotValue; 4]> = SmallVec::new();\n            for (i, output) in outputs.into_iter().enumerate() {\n                if let Some(value) = output {\n                    values.push(value);\n                } else {\n                    let empty_slot = node_state.output_slots.get_slot(i).unwrap();\n                    return Err(RenderGraphRunnerError::EmptyNodeOutputSlot {\n                        type_name: node_state.type_name,\n                        slot_index: i,\n                        slot_name: empty_slot.name.clone(),\n                    });\n                }\n            }\n            node_outputs.insert(node_state.label, values);\n\n            for (_, node_state) in graph\n                .iter_node_outputs(node_state.label)\n                .expect(\"node exists\")\n            {\n                node_queue.push_front(node_state);\n            }\n        }\n\n        Ok(())\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "8aa60573ad2f27dbb90e3da5ad06e6266882861f",
    "func": "use super::field_alias_mapper::FieldAliasMapper;\nuse super::{Alias, AliasSource};\n\nuse crate::dsl;\n#[cfg(feature = \"postgres_backend\")]\nuse crate::expression::SelectableExpression;\nuse crate::expression::{Expression, TypedExpressionType, ValidGrouping};\nuse crate::expression_methods::EqAll;\nuse crate::query_builder::{combination_clause, AsQuery, FromClause, Query, SelectStatement};\nuse crate::query_dsl::methods::*;\nuse crate::query_dsl::{CombineDsl, QueryDsl, RunQueryDsl};\nuse crate::query_source::{QuerySource, Table};\n\nimpl<S: AliasSource> QueryDsl for Alias<S> {}\n\nimpl<S, Predicate> FilterDsl<Predicate> for Alias<S>\nwhere\n    Self: AsQuery,\n    <Self as AsQuery>::Query: FilterDsl<Predicate>,\n{\n    type Output = dsl::Filter<<Self as AsQuery>::Query, Predicate>;\n\n    fn filter(self, predicate: Predicate) -> Self::Output {\n        self.as_query().filter(predicate)\n    }\n}\n\nimpl<S, Selection> SelectDsl<Selection> for Alias<S>\nwhere\n    Selection: Expression,\n    Self: AsQuery,\n    <Self as AsQuery>::Query: SelectDsl<Selection>,\n{\n    type Output = dsl::Select<<Self as AsQuery>::Query, Selection>;\n\n    fn select(self, selection: Selection) -> Self::Output {\n        self.as_query().select(selection)\n    }\n}\n\nimpl<S, PK> FindDsl<PK> for Alias<S>\nwhere\n    S: AliasSource,\n    S::Target: Table,\n    <S::Target as Table>::PrimaryKey: FieldAliasMapper<S>,\n    <<S::Target as Table>::PrimaryKey as FieldAliasMapper<S>>::Out: EqAll<PK>,\n    Self: FilterDsl<\n        <<<S::Target as Table>::PrimaryKey as FieldAliasMapper<S>>::Out as EqAll<PK>>::Output,\n    >,\n{\n    type Output = dsl::Filter<\n        Self,\n        <<<S::Target as Table>::PrimaryKey as FieldAliasMapper<S>>::Out as EqAll<PK>>::Output,\n    >;\n\n    fn find(self, id: PK) -> Self::Output {\n        let primary_key = self.source.target().primary_key();\n        let predicate = self.fields(primary_key).eq_all(id);\n        QueryDsl::filter(self, predicate)\n    }\n}\n\nimpl<'a, S, DB> BoxedDsl<'a, DB> for Alias<S>\nwhere\n    Alias<S>: QuerySource + AsQuery<Query = SelectStatement<FromClause<Alias<S>>>>,\n    SelectStatement<FromClause<Alias<S>>>: BoxedDsl<'a, DB>,\n    <Alias<S> as QuerySource>::DefaultSelection:\n        Expression<SqlType = <Alias<S> as AsQuery>::SqlType> + ValidGrouping<()>,\n    <Alias<S> as AsQuery>::SqlType: TypedExpressionType,\n{\n    type Output = dsl::IntoBoxed<'a, SelectStatement<FromClause<Alias<S>>>, DB>;\n\n    fn internal_into_boxed(self) -> Self::Output {\n        self.as_query().internal_into_boxed()\n    }\n}\n\nimpl<S> CombineDsl for Alias<S>\nwhere\n    S: AliasSource,\n    S::Target: Table,\n    Self: AsQuery,\n{\n    type Query = <Self as AsQuery>::Query;\n\n    fn union<Rhs>(self, rhs: Rhs) -> dsl::Union<Self, Rhs>\n    where\n        Rhs: AsQuery<SqlType = <<Self as AsQuery>::Query as Query>::SqlType>,\n    {\n        combination_clause::CombinationClause::new(\n            combination_clause::Union,\n            combination_clause::Distinct,\n            self.as_query(),\n            rhs.as_query(),\n        )\n    }\n\n    fn union_all<Rhs>(self, rhs: Rhs) -> dsl::UnionAll<Self, Rhs>\n    where\n        Rhs: AsQuery<SqlType = <<Self as AsQuery>::Query as Query>::SqlType>,\n    {\n        combination_clause::CombinationClause::new(\n            combination_clause::Union,\n            combination_clause::All,\n            self.as_query(),\n            rhs.as_query(),\n        )\n    }\n\n    fn intersect<Rhs>(self, rhs: Rhs) -> dsl::Intersect<Self, Rhs>\n    where\n        Rhs: AsQuery<SqlType = <<Self as AsQuery>::Query as Query>::SqlType>,\n    {\n        combination_clause::CombinationClause::new(\n            combination_clause::Intersect,\n            combination_clause::Distinct,\n            self.as_query(),\n            rhs.as_query(),\n        )\n    }\n\n    fn intersect_all<Rhs>(self, rhs: Rhs) -> dsl::IntersectAll<Self, Rhs>\n    where\n        Rhs: AsQuery<SqlType = <<Self as AsQuery>::Query as Query>::SqlType>,\n    {\n        combination_clause::CombinationClause::new(\n            combination_clause::Intersect,\n            combination_clause::All,\n            self.as_query(),\n            rhs.as_query(),\n        )\n    }\n\n    fn except<Rhs>(self, rhs: Rhs) -> dsl::Except<Self, Rhs>\n    where\n        Rhs: AsQuery<SqlType = <<Self as AsQuery>::Query as Query>::SqlType>,\n    {\n        combination_clause::CombinationClause::new(\n            combination_clause::Except,\n            combination_clause::Distinct,\n            self.as_query(),\n            rhs.as_query(),\n        )\n    }\n\n    fn except_all<Rhs>(self, rhs: Rhs) -> dsl::ExceptAll<Self, Rhs>\n    where\n        Rhs: AsQuery<SqlType = <<Self as AsQuery>::Query as Query>::SqlType>,\n    {\n        combination_clause::CombinationClause::new(\n            combination_clause::Except,\n            combination_clause::All,\n            self.as_query(),\n            rhs.as_query(),\n        )\n    }\n}\n\n#[cfg(feature = \"postgres_backend\")]\nimpl<S, Selection> DistinctOnDsl<Selection> for Alias<S>\nwhere\n    S: AliasSource,\n    Selection: SelectableExpression<Self>,\n    Self: QuerySource + AsQuery<Query = SelectStatement<FromClause<Self>>>,\n    SelectStatement<FromClause<Self>>: DistinctOnDsl<Selection>,\n    <Self as QuerySource>::DefaultSelection:\n        Expression<SqlType = <Self as AsQuery>::SqlType> + ValidGrouping<()>,\n    <Self as AsQuery>::SqlType: TypedExpressionType,\n{\n    type Output = dsl::DistinctOn<SelectStatement<FromClause<Self>>, Selection>;\n\n    fn distinct_on(self, selection: Selection) -> dsl::DistinctOn<Self, Selection> {\n        DistinctOnDsl::distinct_on(self.as_query(), selection)\n    }\n}\n\nimpl<S, Predicate> OrFilterDsl<Predicate> for Alias<S>\nwhere\n    Self: AsQuery,\n    <Self as AsQuery>::Query: OrFilterDsl<Predicate>,\n{\n    type Output = dsl::OrFilter<<Self as AsQuery>::Query, Predicate>;\n\n    fn or_filter(self, predicate: Predicate) -> Self::Output {\n        self.as_query().or_filter(predicate)\n    }\n}\n\nimpl<S, Expr> GroupByDsl<Expr> for Alias<S>\nwhere\n    Expr: Expression,\n    Self: QuerySource + AsQuery<Query = SelectStatement<FromClause<Self>>>,\n    <Self as QuerySource>::DefaultSelection:\n        Expression<SqlType = <Self as AsQuery>::SqlType> + ValidGrouping<()>,\n    <Self as AsQuery>::SqlType: TypedExpressionType,\n    <Self as AsQuery>::Query: GroupByDsl<Expr>,\n{\n    type Output = dsl::GroupBy<SelectStatement<FromClause<Self>>, Expr>;\n\n    fn group_by(self, expr: Expr) -> dsl::GroupBy<Self, Expr> {\n        GroupByDsl::group_by(self.as_query(), expr)\n    }\n}\n\nimpl<S> LimitDsl for Alias<S>\nwhere\n    Self: AsQuery,\n    <Self as AsQuery>::Query: LimitDsl,\n{\n    type Output = <<Self as AsQuery>::Query as LimitDsl>::Output;\n\n    fn limit(self, limit: i64) -> Self::Output {\n        self.as_query().limit(limit)\n    }\n}\n\nimpl<S, Lock> LockingDsl<Lock> for Alias<S>\nwhere\n    Self: QuerySource + AsQuery<Query = SelectStatement<FromClause<Self>>>,\n    <Self as QuerySource>::DefaultSelection:\n        Expression<SqlType = <Self as AsQuery>::SqlType> + ValidGrouping<()>,\n    <Self as AsQuery>::SqlType: TypedExpressionType,\n{\n    type Output = <SelectStatement<FromClause<Self>> as LockingDsl<Lock>>::Output;\n\n    fn with_lock(self, lock: Lock) -> Self::Output {\n        self.as_query().with_lock(lock)\n    }\n}\n\nimpl<S: AliasSource, Conn> RunQueryDsl<Conn> for Alias<S> {}\n\nimpl<S> OffsetDsl for Alias<S>\nwhere\n    Self: AsQuery,\n    <Self as AsQuery>::Query: OffsetDsl,\n{\n    type Output = <<Self as AsQuery>::Query as OffsetDsl>::Output;\n\n    fn offset(self, offset: i64) -> Self::Output {\n        self.as_query().offset(offset)\n    }\n}\n\nimpl<S, Expr> OrderDsl<Expr> for Alias<S>\nwhere\n    Expr: Expression,\n    Self: AsQuery,\n    <Self as AsQuery>::Query: OrderDsl<Expr>,\n{\n    type Output = <<Self as AsQuery>::Query as OrderDsl<Expr>>::Output;\n\n    fn order(self, expr: Expr) -> Self::Output {\n        self.as_query().order(expr)\n    }\n}\n\nimpl<S, Expr> ThenOrderDsl<Expr> for Alias<S>\nwhere\n    Expr: Expression,\n    Self: AsQuery,\n    <Self as AsQuery>::Query: ThenOrderDsl<Expr>,\n{\n    type Output = <<Self as AsQuery>::Query as ThenOrderDsl<Expr>>::Output;\n\n    fn then_order_by(self, expr: Expr) -> Self::Output {\n        self.as_query().then_order_by(expr)\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "066e35bf13cbaa0659c29a1beb381536ad479eed",
    "func": "use crate::{serde::TypedReflectSerializer, Tuple, TypeRegistry};\nuse serde::{ser::SerializeTuple, Serialize};\n\n/// A serializer for [`Tuple`] values.\npub(super) struct TupleSerializer<'a> {\n    tuple: &'a dyn Tuple,\n    registry: &'a TypeRegistry,\n}\n\nimpl<'a> TupleSerializer<'a> {\n    pub fn new(tuple: &'a dyn Tuple, registry: &'a TypeRegistry) -> Self {\n        Self { tuple, registry }\n    }\n}\n\nimpl<'a> Serialize for TupleSerializer<'a> {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: serde::Serializer,\n    {\n        let mut state = serializer.serialize_tuple(self.tuple.field_len())?;\n\n        for value in self.tuple.iter_fields() {\n            state.serialize_element(&TypedReflectSerializer::new_internal(value, self.registry))?;\n        }\n        state.end()\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "8f82b7ebb746cbded8358b6aace7a6399e4fe2ae",
    "func": "use dioxus_core::Event;\n\npub type TransitionEvent = Event<TransitionData>;\n\npub struct TransitionData {\n    inner: Box<dyn HasTransitionData>,\n}\n\nimpl<E: HasTransitionData> From<E> for TransitionData {\n    fn from(e: E) -> Self {\n        Self { inner: Box::new(e) }\n    }\n}\n\nimpl std::fmt::Debug for TransitionData {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        f.debug_struct(\"TransitionData\")\n            .field(\"property_name\", &self.inner.property_name())\n            .field(\"pseudo_element\", &self.inner.pseudo_element())\n            .field(\"elapsed_time\", &self.inner.elapsed_time())\n            .finish()\n    }\n}\n\nimpl PartialEq for TransitionData {\n    fn eq(&self, other: &Self) -> bool {\n        self.inner.property_name() == other.inner.property_name()\n            && self.inner.pseudo_element() == other.inner.pseudo_element()\n            && self.inner.elapsed_time() == other.inner.elapsed_time()\n    }\n}\n\nimpl TransitionData {\n    /// Create a new TransitionData\n    pub fn new(inner: impl HasTransitionData + 'static) -> Self {\n        Self {\n            inner: Box::new(inner),\n        }\n    }\n\n    /// Downcast this event to a concrete event type\n    #[inline(always)]\n    pub fn downcast<T: 'static>(&self) -> Option<&T> {\n        self.inner.as_any().downcast_ref::<T>()\n    }\n}\n\n#[cfg(feature = \"serialize\")]\n/// A serialized version of TransitionData\n#[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq, Clone)]\npub struct SerializedTransitionData {\n    property_name: String,\n    pseudo_element: String,\n    elapsed_time: f32,\n}\n\n#[cfg(feature = \"serialize\")]\nimpl From<&TransitionData> for SerializedTransitionData {\n    fn from(data: &TransitionData) -> Self {\n        Self {\n            property_name: data.inner.property_name(),\n            pseudo_element: data.inner.pseudo_element(),\n            elapsed_time: data.inner.elapsed_time(),\n        }\n    }\n}\n\n#[cfg(feature = \"serialize\")]\nimpl HasTransitionData for SerializedTransitionData {\n    fn property_name(&self) -> String {\n        self.property_name.clone()\n    }\n\n    fn pseudo_element(&self) -> String {\n        self.pseudo_element.clone()\n    }\n\n    fn elapsed_time(&self) -> f32 {\n        self.elapsed_time\n    }\n\n    fn as_any(&self) -> &dyn std::any::Any {\n        self\n    }\n}\n\n#[cfg(feature = \"serialize\")]\nimpl serde::Serialize for TransitionData {\n    fn serialize<S: serde::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {\n        SerializedTransitionData::from(self).serialize(serializer)\n    }\n}\n\n#[cfg(feature = \"serialize\")]\nimpl<'de> serde::Deserialize<'de> for TransitionData {\n    fn deserialize<D: serde::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {\n        let data = SerializedTransitionData::deserialize(deserializer)?;\n        Ok(Self {\n            inner: Box::new(data),\n        })\n    }\n}\n\npub trait HasTransitionData: std::any::Any {\n    fn property_name(&self) -> String;\n    fn pseudo_element(&self) -> String;\n    fn elapsed_time(&self) -> f32;\n    /// return self as Any\n    fn as_any(&self) -> &dyn std::any::Any;\n}\n\nimpl_event! {\n    TransitionData;\n\n    /// transitionend\n    ontransitionend\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "16a6fe24ddc7e27fe4ea7cec18ab8bd87496822c",
    "func": "mod parallel_scope;\n\nuse core::{marker::PhantomData, panic::Location};\n\nuse super::{\n    Deferred, IntoObserverSystem, IntoSystem, RegisterSystem, Resource, RunSystemCachedWith,\n};\nuse crate::{\n    self as bevy_ecs,\n    bundle::{Bundle, InsertMode},\n    change_detection::Mut,\n    component::{Component, ComponentId, ComponentInfo},\n    entity::{Entities, Entity},\n    event::{Event, SendEvent},\n    observer::{Observer, TriggerEvent, TriggerTargets},\n    system::{input::SystemInput, RunSystemWithInput, SystemId},\n    world::{\n        command_queue::RawCommandQueue, unsafe_world_cell::UnsafeWorldCell, Command, CommandQueue,\n        EntityWorldMut, FromWorld, SpawnBatchIter, World,\n    },\n};\nuse bevy_ptr::OwningPtr;\nuse bevy_utils::tracing::{error, info};\npub use parallel_scope::*;\n\n/// A [`Command`] queue to perform structural changes to the [`World`].\n///\n/// Since each command requires exclusive access to the `World`,\n/// all queued commands are automatically applied in sequence\n/// when the `apply_deferred` system runs (see [`apply_deferred`] documentation for more details).\n///\n/// Each command can be used to modify the [`World`] in arbitrary ways:\n/// * spawning or despawning entities\n/// * inserting components on new or existing entities\n/// * inserting resources\n/// * etc.\n///\n/// For a version of [`Commands`] that works in parallel contexts (such as\n/// within [`Query::par_iter`](crate::system::Query::par_iter)) see\n/// [`ParallelCommands`]\n///\n/// # Usage\n///\n/// Add `mut commands: Commands` as a function argument to your system to get a copy of this struct that will be applied the next time a copy of [`apply_deferred`] runs.\n/// Commands are almost always used as a [`SystemParam`](crate::system::SystemParam).\n///\n/// ```\n/// # use bevy_ecs::prelude::*;\n/// #\n/// fn my_system(mut commands: Commands) {\n///    // ...\n/// }\n/// # bevy_ecs::system::assert_is_system(my_system);\n/// ```\n///\n/// # Implementing\n///\n/// Each built-in command is implemented as a separate method, e.g. [`Commands::spawn`].\n/// In addition to the pre-defined command methods, you can add commands with any arbitrary\n/// behavior using [`Commands::queue`], which accepts any type implementing [`Command`].\n///\n/// Since closures and other functions implement this trait automatically, this allows one-shot,\n/// anonymous custom commands.\n///\n/// ```\n/// # use bevy_ecs::prelude::*;\n/// # fn foo(mut commands: Commands) {\n/// // NOTE: type inference fails here, so annotations are required on the closure.\n/// commands.queue(|w: &mut World| {\n///     // Mutate the world however you want...\n///     # todo!();\n/// });\n/// # }\n/// ```\n///\n/// [`apply_deferred`]: crate::schedule::apply_deferred\npub struct Commands<'w, 's> {\n    queue: InternalQueue<'s>,\n    entities: &'w Entities,\n}\n\n// SAFETY: All commands [`Command`] implement [`Send`]\nunsafe impl Send for Commands<'_, '_> {}\n\n// SAFETY: `Commands` never gives access to the inner commands.\nunsafe impl Sync for Commands<'_, '_> {}\n\nconst _: () = {\n    type __StructFieldsAlias<'w, 's> = (Deferred<'s, CommandQueue>, &'w Entities);\n    #[doc(hidden)]\n    pub struct FetchState {\n        state: <__StructFieldsAlias<'static, 'static> as bevy_ecs::system::SystemParam>::State,\n    }\n    // SAFETY: Only reads Entities\n    unsafe impl bevy_ecs::system::SystemParam for Commands<'_, '_> {\n        type State = FetchState;\n\n        type Item<'w, 's> = Commands<'w, 's>;\n\n        fn init_state(\n            world: &mut World,\n            system_meta: &mut bevy_ecs::system::SystemMeta,\n        ) -> Self::State {\n            FetchState {\n                state: <__StructFieldsAlias<'_, '_> as bevy_ecs::system::SystemParam>::init_state(\n                    world,\n                    system_meta,\n                ),\n            }\n        }\n\n        unsafe fn new_archetype(\n            state: &mut Self::State,\n            archetype: &bevy_ecs::archetype::Archetype,\n            system_meta: &mut bevy_ecs::system::SystemMeta,\n        ) {\n            // SAFETY: Caller guarantees the archetype is from the world used in `init_state`\n            unsafe {\n                <__StructFieldsAlias<'_, '_> as bevy_ecs::system::SystemParam>::new_archetype(\n                    &mut state.state,\n                    archetype,\n                    system_meta,\n                );\n            };\n        }\n\n        fn apply(\n            state: &mut Self::State,\n            system_meta: &bevy_ecs::system::SystemMeta,\n            world: &mut World,\n        ) {\n            <__StructFieldsAlias<'_, '_> as bevy_ecs::system::SystemParam>::apply(\n                &mut state.state,\n                system_meta,\n                world,\n            );\n        }\n\n        fn queue(\n            state: &mut Self::State,\n            system_meta: &bevy_ecs::system::SystemMeta,\n            world: bevy_ecs::world::DeferredWorld,\n        ) {\n            <__StructFieldsAlias<'_, '_> as bevy_ecs::system::SystemParam>::queue(\n                &mut state.state,\n                system_meta,\n                world,\n            );\n        }\n\n        #[inline]\n        unsafe fn validate_param(\n            state: &Self::State,\n            system_meta: &bevy_ecs::system::SystemMeta,\n            world: UnsafeWorldCell,\n        ) -> bool {\n            <(Deferred<CommandQueue>, &Entities) as bevy_ecs::system::SystemParam>::validate_param(\n                &state.state,\n                system_meta,\n                world,\n            )\n        }\n\n        #[inline]\n        unsafe fn get_param<'w, 's>(\n            state: &'s mut Self::State,\n            system_meta: &bevy_ecs::system::SystemMeta,\n            world: UnsafeWorldCell<'w>,\n            change_tick: bevy_ecs::component::Tick,\n        ) -> Self::Item<'w, 's> {\n            let(f0, f1) =  <(Deferred<'s, CommandQueue>, &'w Entities) as bevy_ecs::system::SystemParam>::get_param(&mut state.state, system_meta, world, change_tick);\n            Commands {\n                queue: InternalQueue::CommandQueue(f0),\n                entities: f1,\n            }\n        }\n    }\n    // SAFETY: Only reads Entities\n    unsafe impl<'w, 's> bevy_ecs::system::ReadOnlySystemParam for Commands<'w, 's>\n    where\n        Deferred<'s, CommandQueue>: bevy_ecs::system::ReadOnlySystemParam,\n        &'w Entities: bevy_ecs::system::ReadOnlySystemParam,\n    {\n    }\n};\n\nenum InternalQueue<'s> {\n    CommandQueue(Deferred<'s, CommandQueue>),\n    RawCommandQueue(RawCommandQueue),\n}\n\nimpl<'w, 's> Commands<'w, 's> {\n    /// Returns a new `Commands` instance from a [`CommandQueue`] and a [`World`].\n    ///\n    /// It is not required to call this constructor when using `Commands` as a [system parameter].\n    ///\n    /// [system parameter]: crate::system::SystemParam\n    pub fn new(queue: &'s mut CommandQueue, world: &'w World) -> Self {\n        Self::new_from_entities(queue, &world.entities)\n    }\n\n    /// Returns a new `Commands` instance from a [`CommandQueue`] and an [`Entities`] reference.\n    ///\n    /// It is not required to call this constructor when using `Commands` as a [system parameter].\n    ///\n    /// [system parameter]: crate::system::SystemParam\n    pub fn new_from_entities(queue: &'s mut CommandQueue, entities: &'w Entities) -> Self {\n        Self {\n            queue: InternalQueue::CommandQueue(Deferred(queue)),\n            entities,\n        }\n    }\n\n    /// Returns a new `Commands` instance from a [`RawCommandQueue`] and an [`Entities`] reference.\n    ///\n    /// This is used when constructing [`Commands`] from a [`DeferredWorld`](crate::world::DeferredWorld).\n    ///\n    /// # Safety\n    ///\n    /// * Caller ensures that `queue` must outlive 'w\n    pub(crate) unsafe fn new_raw_from_entities(\n        queue: RawCommandQueue,\n        entities: &'w Entities,\n    ) -> Self {\n        Self {\n            queue: InternalQueue::RawCommandQueue(queue),\n            entities,\n        }\n    }\n\n    /// Returns a [`Commands`] with a smaller lifetime.\n    /// This is useful if you have `&mut Commands` but need `Commands`.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use bevy_ecs::prelude::*;\n    /// fn my_system(mut commands: Commands) {\n    ///     // We do our initialization in a separate function,\n    ///     // which expects an owned `Commands`.\n    ///     do_initialization(commands.reborrow());\n    ///\n    ///     // Since we only reborrowed the commands instead of moving them, we can still use them.\n    ///     commands.spawn_empty();\n    /// }\n    /// #\n    /// # fn do_initialization(_: Commands) {}\n    /// ```\n    pub fn reborrow(&mut self) -> Commands<'w, '_> {\n        Commands {\n            queue: match &mut self.queue {\n                InternalQueue::CommandQueue(queue) => InternalQueue::CommandQueue(queue.reborrow()),\n                InternalQueue::RawCommandQueue(queue) => {\n                    InternalQueue::RawCommandQueue(queue.clone())\n                }\n            },\n            entities: self.entities,\n        }\n    }\n\n    /// Take all commands from `other` and append them to `self`, leaving `other` empty\n    pub fn append(&mut self, other: &mut CommandQueue) {\n        match &mut self.queue {\n            InternalQueue::CommandQueue(queue) => queue.bytes.append(&mut other.bytes),\n            InternalQueue::RawCommandQueue(queue) => {\n                // SAFETY: Pointers in `RawCommandQueue` are never null\n                unsafe { queue.bytes.as_mut() }.append(&mut other.bytes);\n            }\n        }\n    }\n\n    /// Reserves a new empty [`Entity`] to be spawned, and returns its corresponding [`EntityCommands`].\n    ///\n    /// See [`World::spawn_empty`] for more details.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use bevy_ecs::prelude::*;\n    ///\n    /// #[derive(Component)]\n    /// struct Label(&'static str);\n    /// #[derive(Component)]\n    /// struct Strength(u32);\n    /// #[derive(Component)]\n    /// struct Agility(u32);\n    ///\n    /// fn example_system(mut commands: Commands) {\n    ///     // Create a new empty entity and retrieve its id.\n    ///     let empty_entity = commands.spawn_empty().id();\n    ///\n    ///     // Create another empty entity, then add some component to it\n    ///     commands.spawn_empty()\n    ///         // adds a new component bundle to the entity\n    ///         .insert((Strength(1), Agility(2)))\n    ///         // adds a single component to the entity\n    ///         .insert(Label(\"hello world\"));\n    /// }\n    /// # bevy_ecs::system::assert_is_system(example_system);\n    /// ```\n    ///\n    /// # See also\n    ///\n    /// - [`spawn`](Self::spawn) to spawn an entity with a bundle.\n    /// - [`spawn_batch`](Self::spawn_batch) to spawn entities with a bundle each.\n    pub fn spawn_empty(&mut self) -> EntityCommands {\n        let entity = self.entities.reserve_entity();\n        EntityCommands {\n            entity,\n            commands: self.reborrow(),\n        }\n    }\n\n    /// Pushes a [`Command`] to the queue for creating a new [`Entity`] if the given one does not exists,\n    /// and returns its corresponding [`EntityCommands`].\n    ///\n    /// This method silently fails by returning [`EntityCommands`]\n    /// even if the given `Entity` cannot be spawned.\n    ///\n    /// See [`World::get_or_spawn`] for more details.\n    ///\n    /// # Note\n    ///\n    /// Spawning a specific `entity` value is rarely the right choice. Most apps should favor\n    /// [`Commands::spawn`]. This method should generally only be used for sharing entities across\n    /// apps, and only when they have a scheme worked out to share an ID space (which doesn't happen\n    /// by default).\n    #[deprecated(since = \"0.15.0\", note = \"use Commands::spawn instead\")]\n    pub fn get_or_spawn(&mut self, entity: Entity) -> EntityCommands {\n        self.queue(move |world: &mut World| {\n            #[allow(deprecated)]\n            world.get_or_spawn(entity);\n        });\n        EntityCommands {\n            entity,\n            commands: self.reborrow(),\n        }\n    }\n\n    /// Pushes a [`Command`] to the queue for creating a new entity with the given [`Bundle`]'s components,\n    /// and returns its corresponding [`EntityCommands`].\n    ///\n    /// In case multiple bundles of the same [`Bundle`] type need to be spawned,\n    /// [`spawn_batch`](Self::spawn_batch) should be used for better performance.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bevy_ecs::prelude::*;\n    ///\n    /// #[derive(Component)]\n    /// struct Component1;\n    /// #[derive(Component)]\n    /// struct Component2;\n    /// #[derive(Component)]\n    /// struct Label(&'static str);\n    /// #[derive(Component)]\n    /// struct Strength(u32);\n    /// #[derive(Component)]\n    /// struct Agility(u32);\n    ///\n    /// #[derive(Bundle)]\n    /// struct ExampleBundle {\n    ///     a: Component1,\n    ///     b: Component2,\n    /// }\n    ///\n    /// fn example_system(mut commands: Commands) {\n    ///     // Create a new entity with a single component.\n    ///     commands.spawn(Component1);\n    ///\n    ///     // Create a new entity with a component bundle.\n    ///     commands.spawn(ExampleBundle {\n    ///         a: Component1,\n    ///         b: Component2,\n    ///     });\n    ///\n    ///     commands\n    ///         // Create a new entity with two components using a \"tuple bundle\".\n    ///         .spawn((Component1, Component2))\n    ///         // `spawn returns a builder, so you can insert more bundles like this:\n    ///         .insert((Strength(1), Agility(2)))\n    ///         // or insert single components like this:\n    ///         .insert(Label(\"hello world\"));\n    /// }\n    /// # bevy_ecs::system::assert_is_system(example_system);\n    /// ```\n    ///\n    /// # See also\n    ///\n    /// - [`spawn_empty`](Self::spawn_empty) to spawn an entity without any components.\n    /// - [`spawn_batch`](Self::spawn_batch) to spawn entities with a bundle each.\n    #[track_caller]\n    pub fn spawn<T: Bundle>(&mut self, bundle: T) -> EntityCommands {\n        let mut entity = self.spawn_empty();\n        entity.insert(bundle);\n        entity\n    }\n\n    /// Returns the [`EntityCommands`] for the requested [`Entity`].\n    ///\n    /// # Panics\n    ///\n    /// This method panics if the requested entity does not exist.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bevy_ecs::prelude::*;\n    ///\n    /// #[derive(Component)]\n    /// struct Label(&'static str);\n    /// #[derive(Component)]\n    /// struct Strength(u32);\n    /// #[derive(Component)]\n    /// struct Agility(u32);\n    ///\n    /// fn example_system(mut commands: Commands) {\n    ///     // Create a new, empty entity\n    ///     let entity = commands.spawn_empty().id();\n    ///\n    ///     commands.entity(entity)\n    ///         // adds a new component bundle to the entity\n    ///         .insert((Strength(1), Agility(2)))\n    ///         // adds a single component to the entity\n    ///         .insert(Label(\"hello world\"));\n    /// }\n    /// # bevy_ecs::system::assert_is_system(example_system);\n    /// ```\n    ///\n    /// # See also\n    ///\n    /// - [`get_entity`](Self::get_entity) for the fallible version.\n    #[inline]\n    #[track_caller]\n    pub fn entity(&mut self, entity: Entity) -> EntityCommands {\n        #[inline(never)]\n        #[cold]\n        #[track_caller]\n        fn panic_no_entity(entity: Entity) -> ! {\n            panic!(\n                \"Attempting to create an EntityCommands for entity {entity:?}, which doesn't exist.\",\n            );\n        }\n\n        match self.get_entity(entity) {\n            Some(entity) => entity,\n            None => panic_no_entity(entity),\n        }\n    }\n\n    /// Returns the [`EntityCommands`] for the requested [`Entity`], if it exists.\n    ///\n    /// Returns `None` if the entity does not exist.\n    ///\n    /// This method does not guarantee that `EntityCommands` will be successfully applied,\n    /// since another command in the queue may delete the entity before them.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bevy_ecs::prelude::*;\n    ///\n    /// #[derive(Component)]\n    /// struct Label(&'static str);\n    /// fn example_system(mut commands: Commands) {\n    ///     // Create a new, empty entity\n    ///     let entity = commands.spawn_empty().id();\n    ///\n    ///     // Get the entity if it still exists, which it will in this case\n    ///     if let Some(mut entity_commands) = commands.get_entity(entity) {\n    ///         // adds a single component to the entity\n    ///         entity_commands.insert(Label(\"hello world\"));\n    ///     }\n    /// }\n    /// # bevy_ecs::system::assert_is_system(example_system);\n    /// ```\n    ///\n    /// # See also\n    ///\n    /// - [`entity`](Self::entity) for the panicking version.\n    #[inline]\n    #[track_caller]\n    pub fn get_entity(&mut self, entity: Entity) -> Option<EntityCommands> {\n        self.entities.contains(entity).then_some(EntityCommands {\n            entity,\n            commands: self.reborrow(),\n        })\n    }\n\n    /// Pushes a [`Command`] to the queue for creating entities with a particular [`Bundle`] type.\n    ///\n    /// `bundles_iter` is a type that can be converted into a [`Bundle`] iterator\n    /// (it can also be a collection).\n    ///\n    /// This method is equivalent to iterating `bundles_iter`\n    /// and calling [`spawn`](Self::spawn) on each bundle,\n    /// but it is faster due to memory pre-allocation.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use bevy_ecs::prelude::*;\n    /// #\n    /// # #[derive(Component)]\n    /// # struct Name(String);\n    /// # #[derive(Component)]\n    /// # struct Score(u32);\n    /// #\n    /// # fn system(mut commands: Commands) {\n    /// commands.spawn_batch(vec![\n    ///     (\n    ///         Name(\"Alice\".to_string()),\n    ///         Score(0),\n    ///     ),\n    ///     (\n    ///         Name(\"Bob\".to_string()),\n    ///         Score(0),\n    ///     ),\n    /// ]);\n    /// # }\n    /// # bevy_ecs::system::assert_is_system(system);\n    /// ```\n    ///\n    /// # See also\n    ///\n    /// - [`spawn`](Self::spawn) to spawn an entity with a bundle.\n    /// - [`spawn_empty`](Self::spawn_empty) to spawn an entity without any components.\n    #[track_caller]\n    pub fn spawn_batch<I>(&mut self, bundles_iter: I)\n    where\n        I: IntoIterator + Send + Sync + 'static,\n        I::Item: Bundle,\n    {\n        self.queue(spawn_batch(bundles_iter));\n    }\n\n    /// Pushes a generic [`Command`] to the command queue.\n    ///\n    /// `command` can be a built-in command, custom struct that implements [`Command`] or a closure\n    /// that takes [`&mut World`](World) as an argument.\n    /// # Example\n    ///\n    /// ```\n    /// # use bevy_ecs::{world::Command, prelude::*};\n    /// #[derive(Resource, Default)]\n    /// struct Counter(u64);\n    ///\n    /// struct AddToCounter(u64);\n    ///\n    /// impl Command for AddToCounter {\n    ///     fn apply(self, world: &mut World) {\n    ///         let mut counter = world.get_resource_or_insert_with(Counter::default);\n    ///         counter.0 += self.0;\n    ///     }\n    /// }\n    ///\n    /// fn add_three_to_counter_system(mut commands: Commands) {\n    ///     commands.queue(AddToCounter(3));\n    /// }\n    /// fn add_twenty_five_to_counter_system(mut commands: Commands) {\n    ///     commands.queue(|world: &mut World| {\n    ///         let mut counter = world.get_resource_or_insert_with(Counter::default);\n    ///         counter.0 += 25;\n    ///     });\n    /// }\n    /// # bevy_ecs::system::assert_is_system(add_three_to_counter_system);\n    /// # bevy_ecs::system::assert_is_system(add_twenty_five_to_counter_system);\n    /// ```\n    pub fn queue<C: Command>(&mut self, command: C) {\n        match &mut self.queue {\n            InternalQueue::CommandQueue(queue) => {\n                queue.push(command);\n            }\n            InternalQueue::RawCommandQueue(queue) => {\n                // SAFETY: `RawCommandQueue` is only every constructed in `Commands::new_raw_from_entities`\n                // where the caller of that has ensured that `queue` outlives `self`\n                unsafe {\n                    queue.push(command);\n                }\n            }\n        }\n    }\n\n    /// Pushes a [`Command`] to the queue for creating entities, if needed,\n    /// and for adding a bundle to each entity.\n    ///\n    /// `bundles_iter` is a type that can be converted into an ([`Entity`], [`Bundle`]) iterator\n    /// (it can also be a collection).\n    ///\n    /// When the command is applied,\n    /// for each (`Entity`, `Bundle`) pair in the given `bundles_iter`,\n    /// the `Entity` is spawned, if it does not exist already.\n    /// Then, the `Bundle` is added to the entity.\n    ///\n    /// This method is equivalent to iterating `bundles_iter`,\n    /// calling [`get_or_spawn`](Self::get_or_spawn) for each bundle,\n    /// and passing it to [`insert`](EntityCommands::insert),\n    /// but it is faster due to memory pre-allocation.\n    ///\n    /// # Note\n    ///\n    /// Spawning a specific `entity` value is rarely the right choice. Most apps should use [`Commands::spawn_batch`].\n    /// This method should generally only be used for sharing entities across apps, and only when they have a scheme\n    /// worked out to share an ID space (which doesn't happen by default).\n    #[track_caller]\n    pub fn insert_or_spawn_batch<I, B>(&mut self, bundles_iter: I)\n    where\n        I: IntoIterator<Item = (Entity, B)> + Send + Sync + 'static,\n        B: Bundle,\n    {\n        self.queue(insert_or_spawn_batch(bundles_iter));\n    }\n\n    /// Pushes a [`Command`] to the queue for adding a [`Bundle`] type to a batch of [`Entities`](Entity).\n    ///\n    /// A batch can be any type that implements [`IntoIterator`] containing `(Entity, Bundle)` tuples,\n    /// such as a [`Vec<(Entity, Bundle)>`] or an array `[(Entity, Bundle); N]`.\n    ///\n    /// When the command is applied, for each `(Entity, Bundle)` pair in the given batch,\n    /// the `Bundle` is added to the `Entity`, overwriting any existing components shared by the `Bundle`.\n    ///\n    /// This method is equivalent to iterating the batch,\n    /// calling [`entity`](Self::entity) for each pair,\n    /// and passing the bundle to [`insert`](EntityCommands::insert),\n    /// but it is faster due to memory pre-allocation.\n    ///\n    /// # Panics\n    ///\n    /// This command panics if any of the given entities do not exist.\n    ///\n    /// For the non-panicking version, see [`try_insert_batch`](Self::try_insert_batch).\n    #[track_caller]\n    pub fn insert_batch<I, B>(&mut self, batch: I)\n    where\n        I: IntoIterator<Item = (Entity, B)> + Send + Sync + 'static,\n        B: Bundle,\n    {\n        self.queue(insert_batch(batch));\n    }\n\n    /// Pushes a [`Command`] to the queue for adding a [`Bundle`] type to a batch of [`Entities`](Entity).\n    ///\n    /// A batch can be any type that implements [`IntoIterator`] containing `(Entity, Bundle)` tuples,\n    /// such as a [`Vec<(Entity, Bundle)>`] or an array `[(Entity, Bundle); N]`.\n    ///\n    /// When the command is applied, for each `(Entity, Bundle)` pair in the given batch,\n    /// the `Bundle` is added to the `Entity`, except for any components already present on the `Entity`.\n    ///\n    /// This method is equivalent to iterating the batch,\n    /// calling [`entity`](Self::entity) for each pair,\n    /// and passing the bundle to [`insert_if_new`](EntityCommands::insert_if_new),\n    /// but it is faster due to memory pre-allocation.\n    ///\n    /// # Panics\n    ///\n    /// This command panics if any of the given entities do not exist.\n    ///\n    /// For the non-panicking version, see [`try_insert_batch_if_new`](Self::try_insert_batch_if_new).\n    #[track_caller]\n    pub fn insert_batch_if_new<I, B>(&mut self, batch: I)\n    where\n        I: IntoIterator<Item = (Entity, B)> + Send + Sync + 'static,\n        B: Bundle,\n    {\n        self.queue(insert_batch_if_new(batch));\n    }\n\n    /// Pushes a [`Command`] to the queue for adding a [`Bundle`] type to a batch of [`Entities`](Entity).\n    ///\n    /// A batch can be any type that implements [`IntoIterator`] containing `(Entity, Bundle)` tuples,\n    /// such as a [`Vec<(Entity, Bundle)>`] or an array `[(Entity, Bundle); N]`.\n    ///\n    /// When the command is applied, for each `(Entity, Bundle)` pair in the given batch,\n    /// the `Bundle` is added to the `Entity`, overwriting any existing components shared by the `Bundle`.\n    ///\n    /// This method is equivalent to iterating the batch,\n    /// calling [`get_entity`](Self::get_entity) for each pair,\n    /// and passing the bundle to [`insert`](EntityCommands::insert),\n    /// but it is faster due to memory pre-allocation.\n    ///\n    /// This command silently fails by ignoring any entities that do not exist.\n    ///\n    /// For the panicking version, see [`insert_batch`](Self::insert_batch).\n    #[track_caller]\n    pub fn try_insert_batch<I, B>(&mut self, batch: I)\n    where\n        I: IntoIterator<Item = (Entity, B)> + Send + Sync + 'static,\n        B: Bundle,\n    {\n        self.queue(try_insert_batch(batch));\n    }\n\n    /// Pushes a [`Command`] to the queue for adding a [`Bundle`] type to a batch of [`Entities`](Entity).\n    ///\n    /// A batch can be any type that implements [`IntoIterator`] containing `(Entity, Bundle)` tuples,\n    /// such as a [`Vec<(Entity, Bundle)>`] or an array `[(Entity, Bundle); N]`.\n    ///\n    /// When the command is applied, for each `(Entity, Bundle)` pair in the given batch,\n    /// the `Bundle` is added to the `Entity`, except for any components already present on the `Entity`.\n    ///\n    /// This method is equivalent to iterating the batch,\n    /// calling [`get_entity`](Self::get_entity) for each pair,\n    /// and passing the bundle to [`insert_if_new`](EntityCommands::insert_if_new),\n    /// but it is faster due to memory pre-allocation.\n    ///\n    /// This command silently fails by ignoring any entities that do not exist.\n    ///\n    /// For the panicking version, see [`insert_batch_if_new`](Self::insert_batch_if_new).\n    #[track_caller]\n    pub fn try_insert_batch_if_new<I, B>(&mut self, batch: I)\n    where\n        I: IntoIterator<Item = (Entity, B)> + Send + Sync + 'static,\n        B: Bundle,\n    {\n        self.queue(try_insert_batch_if_new(batch));\n    }\n\n    /// Pushes a [`Command`] to the queue for inserting a [`Resource`] in the [`World`] with an inferred value.\n    ///\n    /// The inferred value is determined by the [`FromWorld`] trait of the resource.\n    /// When the command is applied,\n    /// if the resource already exists, nothing happens.\n    ///\n    /// See [`World::init_resource`] for more details.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use bevy_ecs::prelude::*;\n    /// #\n    /// # #[derive(Resource, Default)]\n    /// # struct Scoreboard {\n    /// #     current_score: u32,\n    /// #     high_score: u32,\n    /// # }\n    /// #\n    /// # fn initialize_scoreboard(mut commands: Commands) {\n    /// commands.init_resource::<Scoreboard>();\n    /// # }\n    /// # bevy_ecs::system::assert_is_system(initialize_scoreboard);\n    /// ```\n    #[track_caller]\n    pub fn init_resource<R: Resource + FromWorld>(&mut self) {\n        self.queue(init_resource::<R>);\n    }\n\n    /// Pushes a [`Command`] to the queue for inserting a [`Resource`] in the [`World`] with a specific value.\n    ///\n    /// This will overwrite any previous value of the same resource type.\n    ///\n    /// See [`World::insert_resource`] for more details.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use bevy_ecs::prelude::*;\n    /// #\n    /// # #[derive(Resource)]\n    /// # struct Scoreboard {\n    /// #     current_score: u32,\n    /// #     high_score: u32,\n    /// # }\n    /// #\n    /// # fn system(mut commands: Commands) {\n    /// commands.insert_resource(Scoreboard {\n    ///     current_score: 0,\n    ///     high_score: 0,\n    /// });\n    /// # }\n    /// # bevy_ecs::system::assert_is_system(system);\n    /// ```\n    #[track_caller]\n    pub fn insert_resource<R: Resource>(&mut self, resource: R) {\n        self.queue(insert_resource(resource));\n    }\n\n    /// Pushes a [`Command`] to the queue for removing a [`Resource`] from the [`World`].\n    ///\n    /// See [`World::remove_resource`] for more details.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use bevy_ecs::prelude::*;\n    /// #\n    /// # #[derive(Resource)]\n    /// # struct Scoreboard {\n    /// #     current_score: u32,\n    /// #     high_score: u32,\n    /// # }\n    /// #\n    /// # fn system(mut commands: Commands) {\n    /// commands.remove_resource::<Scoreboard>();\n    /// # }\n    /// # bevy_ecs::system::assert_is_system(system);\n    /// ```\n    pub fn remove_resource<R: Resource>(&mut self) {\n        self.queue(remove_resource::<R>);\n    }\n\n    /// Runs the system corresponding to the given [`SystemId`].\n    /// Systems are ran in an exclusive and single threaded way.\n    /// Running slow systems can become a bottleneck.\n    ///\n    /// Calls [`World::run_system`](World::run_system).\n    ///\n    /// There is no way to get the output of a system when run as a command, because the\n    /// execution of the system happens later. To get the output of a system, use\n    /// [`World::run_system`] or [`World::run_system_with_input`] instead of running the system as a command.\n    pub fn run_system(&mut self, id: SystemId) {\n        self.run_system_with_input(id, ());\n    }\n\n    /// Runs the system corresponding to the given [`SystemId`].\n    /// Systems are ran in an exclusive and single threaded way.\n    /// Running slow systems can become a bottleneck.\n    ///\n    /// Calls [`World::run_system_with_input`](World::run_system_with_input).\n    ///\n    /// There is no way to get the output of a system when run as a command, because the\n    /// execution of the system happens later. To get the output of a system, use\n    /// [`World::run_system`] or [`World::run_system_with_input`] instead of running the system as a command.\n    pub fn run_system_with_input<I>(&mut self, id: SystemId<I>, input: I::Inner<'static>)\n    where\n        I: SystemInput<Inner<'static>: Send> + 'static,\n    {\n        self.queue(RunSystemWithInput::new_with_input(id, input));\n    }\n\n    /// Registers a system and returns a [`SystemId`] so it can later be called by [`World::run_system`].\n    ///\n    /// It's possible to register the same systems more than once, they'll be stored separately.\n    ///\n    /// This is different from adding systems to a [`Schedule`](crate::schedule::Schedule),\n    /// because the [`SystemId`] that is returned can be used anywhere in the [`World`] to run the associated system.\n    /// This allows for running systems in a push-based fashion.\n    /// Using a [`Schedule`](crate::schedule::Schedule) is still preferred for most cases\n    /// due to its better performance and ability to run non-conflicting systems simultaneously.\n    ///\n    /// If you want to prevent Commands from registering the same system multiple times, consider using [`Local`](crate::system::Local)\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use bevy_ecs::{prelude::*, world::CommandQueue, system::SystemId};\n    ///\n    /// #[derive(Resource)]\n    /// struct Counter(i32);\n    ///\n    /// fn register_system(mut local_system: Local<Option<SystemId>>, mut commands: Commands) {\n    ///     if let Some(system) = *local_system {\n    ///         commands.run_system(system);\n    ///     } else {\n    ///         *local_system = Some(commands.register_system(increment_counter));\n    ///     }\n    /// }\n    ///\n    /// fn increment_counter(mut value: ResMut<Counter>) {\n    ///     value.0 += 1;\n    /// }\n    ///\n    /// # let mut world = World::default();\n    /// # world.insert_resource(Counter(0));\n    /// # let mut queue_1 = CommandQueue::default();\n    /// # let systemid = {\n    /// #   let mut commands = Commands::new(&mut queue_1, &world);\n    /// #   commands.register_system(increment_counter)\n    /// # };\n    /// # let mut queue_2 = CommandQueue::default();\n    /// # {\n    /// #   let mut commands = Commands::new(&mut queue_2, &world);\n    /// #   commands.run_system(systemid);\n    /// # }\n    /// # queue_1.append(&mut queue_2);\n    /// # queue_1.apply(&mut world);\n    /// # assert_eq!(1, world.resource::<Counter>().0);\n    /// # bevy_ecs::system::assert_is_system(register_system);\n    /// ```\n    pub fn register_system<I, O, M>(\n        &mut self,\n        system: impl IntoSystem<I, O, M> + 'static,\n    ) -> SystemId<I, O>\n    where\n        I: SystemInput + Send + 'static,\n        O: Send + 'static,\n    {\n        let entity = self.spawn_empty().id();\n        self.queue(RegisterSystem::new(system, entity));\n        SystemId::from_entity(entity)\n    }\n\n    /// Similar to [`Self::run_system`], but caching the [`SystemId`] in a\n    /// [`CachedSystemId`](crate::system::CachedSystemId) resource.\n    ///\n    /// See [`World::register_system_cached`] for more information.\n    pub fn run_system_cached<M: 'static, S: IntoSystem<(), (), M> + Send + 'static>(\n        &mut self,\n        system: S,\n    ) {\n        self.run_system_cached_with(system, ());\n    }\n\n    /// Similar to [`Self::run_system_with_input`], but caching the [`SystemId`] in a\n    /// [`CachedSystemId`](crate::system::CachedSystemId) resource.\n    ///\n    /// See [`World::register_system_cached`] for more information.\n    pub fn run_system_cached_with<I, M, S>(&mut self, system: S, input: I::Inner<'static>)\n    where\n        I: SystemInput<Inner<'static>: Send> + Send + 'static,\n        M: 'static,\n        S: IntoSystem<I, (), M> + Send + 'static,\n    {\n        self.queue(RunSystemCachedWith::new(system, input));\n    }\n\n    /// Sends a \"global\" [`Trigger`] without any targets. This will run any [`Observer`] of the `event` that\n    /// isn't scoped to specific targets.\n    ///\n    /// [`Trigger`]: crate::observer::Trigger\n    pub fn trigger(&mut self, event: impl Event) {\n        self.queue(TriggerEvent { event, targets: () });\n    }\n\n    /// Sends a [`Trigger`] for the given targets. This will run any [`Observer`] of the `event` that\n    /// watches those targets.\n    ///\n    /// [`Trigger`]: crate::observer::Trigger\n    pub fn trigger_targets(\n        &mut self,\n        event: impl Event,\n        targets: impl TriggerTargets + Send + Sync + 'static,\n    ) {\n        self.queue(TriggerEvent { event, targets });\n    }\n\n    /// Spawns an [`Observer`] and returns the [`EntityCommands`] associated\n    /// with the entity that stores the observer.\n    ///\n    /// **Calling [`observe`](EntityCommands::observe) on the returned\n    /// [`EntityCommands`] will observe the observer itself, which you very\n    /// likely do not want.**\n    pub fn add_observer<E: Event, B: Bundle, M>(\n        &mut self,\n        observer: impl IntoObserverSystem<E, B, M>,\n    ) -> EntityCommands {\n        self.spawn(Observer::new(observer))\n    }\n\n    /// Sends an arbitrary [`Event`].\n    ///\n    /// This is a convenience method for sending events without requiring an [`EventWriter`].\n    /// ## Performance\n    /// Since this is a command, exclusive world access is used, which means that it will not profit from\n    /// system-level parallelism on supported platforms.\n    /// If these events are performance-critical or very frequently\n    /// sent, consider using a typed [`EventWriter`] instead.\n    ///\n    /// [`EventWriter`]: crate::event::EventWriter\n    pub fn send_event<E: Event>(&mut self, event: E) -> &mut Self {\n        self.queue(SendEvent { event });\n        self\n    }\n}\n\n/// A [`Command`] which gets executed for a given [`Entity`].\n///\n/// # Examples\n///\n/// ```\n/// # use std::collections::HashSet;\n/// # use bevy_ecs::prelude::*;\n/// use bevy_ecs::system::EntityCommand;\n/// #\n/// # #[derive(Component, PartialEq)]\n/// # struct Name(String);\n/// # impl Name {\n/// #   fn new(s: String) -> Self { Name(s) }\n/// #   fn as_str(&self) -> &str { &self.0 }\n/// # }\n///\n/// #[derive(Resource, Default)]\n/// struct Counter(i64);\n///\n/// /// A `Command` which names an entity based on a global counter.\n/// fn count_name(entity: Entity, world: &mut World) {\n///     // Get the current value of the counter, and increment it for next time.\n///     let mut counter = world.resource_mut::<Counter>();\n///     let i = counter.0;\n///     counter.0 += 1;\n///\n///     // Name the entity after the value of the counter.\n///     world.entity_mut(entity).insert(Name::new(format!(\"Entity #{i}\")));\n/// }\n///\n/// // App creation boilerplate omitted...\n/// # let mut world = World::new();\n/// # world.init_resource::<Counter>();\n/// #\n/// # let mut setup_schedule = Schedule::default();\n/// # setup_schedule.add_systems(setup);\n/// # let mut assert_schedule = Schedule::default();\n/// # assert_schedule.add_systems(assert_names);\n/// #\n/// # setup_schedule.run(&mut world);\n/// # assert_schedule.run(&mut world);\n///\n/// fn setup(mut commands: Commands) {\n///     commands.spawn_empty().queue(count_name);\n///     commands.spawn_empty().queue(count_name);\n/// }\n///\n/// fn assert_names(named: Query<&Name>) {\n///     // We use a HashSet because we do not care about the order.\n///     let names: HashSet<_> = named.iter().map(Name::as_str).collect();\n///     assert_eq!(names, HashSet::from_iter([\"Entity #0\", \"Entity #1\"]));\n/// }\n/// ```\npub trait EntityCommand<Marker = ()>: Send + 'static {\n    /// Executes this command for the given [`Entity`].\n    fn apply(self, entity: Entity, world: &mut World);\n\n    /// Returns a [`Command`] which executes this [`EntityCommand`] for the given [`Entity`].\n    ///\n    /// This method is called when adding an [`EntityCommand`] to a command queue via [`Commands`].\n    /// You can override the provided implementation if you can return a `Command` with a smaller memory\n    /// footprint than `(Entity, Self)`.\n    /// In most cases the provided implementation is sufficient.\n    #[must_use = \"commands do nothing unless applied to a `World`\"]\n    fn with_entity(self, entity: Entity) -> impl Command\n    where\n        Self: Sized,\n    {\n        move |world: &mut World| self.apply(entity, world)\n    }\n}\n\n/// A list of commands that will be run to modify an [entity](crate::entity).\npub struct EntityCommands<'a> {\n    pub(crate) entity: Entity,\n    pub(crate) commands: Commands<'a, 'a>,\n}\n\nimpl<'a> EntityCommands<'a> {\n    /// Returns the [`Entity`] id of the entity.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use bevy_ecs::prelude::*;\n    /// #\n    /// fn my_system(mut commands: Commands) {\n    ///     let entity_id = commands.spawn_empty().id();\n    /// }\n    /// # bevy_ecs::system::assert_is_system(my_system);\n    /// ```\n    #[inline]\n    #[must_use = \"Omit the .id() call if you do not need to store the `Entity` identifier.\"]\n    pub fn id(&self) -> Entity {\n        self.entity\n    }\n\n    /// Returns an [`EntityCommands`] with a smaller lifetime.\n    /// This is useful if you have `&mut EntityCommands` but you need `EntityCommands`.\n    pub fn reborrow(&mut self) -> EntityCommands {\n        EntityCommands {\n            entity: self.entity,\n            commands: self.commands.reborrow(),\n        }\n    }\n\n    /// Get an [`EntityEntryCommands`] for the [`Component`] `T`,\n    /// allowing you to modify it or insert it if it isn't already present.\n    ///\n    /// See also [`insert_if_new`](Self::insert_if_new), which lets you insert a [`Bundle`] without overwriting it.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use bevy_ecs::prelude::*;\n    /// # #[derive(Resource)]\n    /// # struct PlayerEntity { entity: Entity }\n    /// #[derive(Component)]\n    /// struct Level(u32);\n    ///\n    /// fn level_up_system(mut commands: Commands, player: Res<PlayerEntity>) {\n    ///     commands\n    ///         .entity(player.entity)\n    ///         .entry::<Level>()\n    ///         // Modify the component if it exists\n    ///         .and_modify(|mut lvl| lvl.0 += 1)\n    ///         // Otherwise insert a default value\n    ///         .or_insert(Level(0));\n    /// }\n    /// # bevy_ecs::system::assert_is_system(level_up_system);\n    /// ```\n    pub fn entry<T: Component>(&mut self) -> EntityEntryCommands<T> {\n        EntityEntryCommands {\n            entity_commands: self.reborrow(),\n            marker: PhantomData,\n        }\n    }\n\n    /// Adds a [`Bundle`] of components to the entity.\n    ///\n    /// This will overwrite any previous value(s) of the same component type.\n    /// See [`EntityCommands::insert_if_new`] to keep the old value instead.\n    ///\n    /// # Panics\n    ///\n    /// The command will panic when applied if the associated entity does not exist.\n    ///\n    /// To avoid a panic in this case, use the command [`Self::try_insert`] instead.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use bevy_ecs::prelude::*;\n    /// # #[derive(Resource)]\n    /// # struct PlayerEntity { entity: Entity }\n    /// #[derive(Component)]\n    /// struct Health(u32);\n    /// #[derive(Component)]\n    /// struct Strength(u32);\n    /// #[derive(Component)]\n    /// struct Defense(u32);\n    ///\n    /// #[derive(Bundle)]\n    /// struct CombatBundle {\n    ///     health: Health,\n    ///     strength: Strength,\n    /// }\n    ///\n    /// fn add_combat_stats_system(mut commands: Commands, player: Res<PlayerEntity>) {\n    ///     commands\n    ///         .entity(player.entity)\n    ///         // You can insert individual components:\n    ///         .insert(Defense(10))\n    ///         // You can also insert pre-defined bundles of components:\n    ///         .insert(CombatBundle {\n    ///             health: Health(100),\n    ///             strength: Strength(40),\n    ///         })\n    ///         // You can also insert tuples of components and bundles.\n    ///         // This is equivalent to the calls above:\n    ///         .insert((\n    ///             Defense(10),\n    ///             CombatBundle {\n    ///                 health: Health(100),\n    ///                 strength: Strength(40),\n    ///             },\n    ///         ));\n    /// }\n    /// # bevy_ecs::system::assert_is_system(add_combat_stats_system);\n    /// ```\n    #[track_caller]\n    pub fn insert(&mut self, bundle: impl Bundle) -> &mut Self {\n        self.queue(insert(bundle, InsertMode::Replace))\n    }\n\n    /// Similar to [`Self::insert`] but will only insert if the predicate returns true.\n    /// This is useful for chaining method calls.\n    ///\n    /// # Panics\n    ///\n    /// The command will panic when applied if the associated entity does not exist.\n    ///\n    /// To avoid a panic in this case, use the command [`Self::try_insert_if`] instead.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use bevy_ecs::prelude::*;\n    /// # #[derive(Resource)]\n    /// # struct PlayerEntity { entity: Entity }\n    /// # impl PlayerEntity { fn is_spectator(&self) -> bool { true } }\n    /// #[derive(Component)]\n    /// struct StillLoadingStats;\n    /// #[derive(Component)]\n    /// struct Health(u32);\n    ///\n    /// fn add_health_system(mut commands: Commands, player: Res<PlayerEntity>) {\n    ///     commands\n    ///         .entity(player.entity)\n    ///         .insert_if(Health(10), || !player.is_spectator())\n    ///         .remove::<StillLoadingStats>();\n    /// }\n    /// # bevy_ecs::system::assert_is_system(add_health_system);\n    /// ```\n    #[track_caller]\n    pub fn insert_if<F>(&mut self, bundle: impl Bundle, condition: F) -> &mut Self\n    where\n        F: FnOnce() -> bool,\n    {\n        if condition() {\n            self.queue(insert(bundle, InsertMode::Replace))\n        } else {\n            self\n        }\n    }\n\n    /// Adds a [`Bundle`] of components to the entity without overwriting.\n    ///\n    /// This is the same as [`EntityCommands::insert`], but in case of duplicate\n    /// components will leave the old values instead of replacing them with new\n    /// ones.\n    ///\n    /// See also [`entry`](Self::entry), which lets you modify a [`Component`] if it's present,\n    /// as well as initialize it with a default value.\n    ///\n    /// # Panics\n    ///\n    /// The command will panic when applied if the associated entity does not exist.\n    ///\n    /// To avoid a panic in this case, use the command [`Self::try_insert_if_new`] instead.\n    pub fn insert_if_new(&mut self, bundle: impl Bundle) -> &mut Self {\n        self.queue(insert(bundle, InsertMode::Keep))\n    }\n\n    /// Adds a [`Bundle`] of components to the entity without overwriting if the\n    /// predicate returns true.\n    ///\n    /// This is the same as [`EntityCommands::insert_if`], but in case of duplicate\n    /// components will leave the old values instead of replacing them with new\n    /// ones.\n    ///\n    /// # Panics\n    ///\n    /// The command will panic when applied if the associated entity does not\n    /// exist.\n    ///\n    /// To avoid a panic in this case, use the command [`Self::try_insert_if_new`]\n    /// instead.\n    pub fn insert_if_new_and<F>(&mut self, bundle: impl Bundle, condition: F) -> &mut Self\n    where\n        F: FnOnce() -> bool,\n    {\n        if condition() {\n            self.insert_if_new(bundle)\n        } else {\n            self\n        }\n    }\n\n    /// Adds a dynamic component to an entity.\n    ///\n    /// See [`EntityWorldMut::insert_by_id`] for more information.\n    ///\n    /// # Panics\n    ///\n    /// The command will panic when applied if the associated entity does not exist.\n    ///\n    /// To avoid a panic in this case, use the command [`Self::try_insert_by_id`] instead.\n    ///\n    /// # Safety\n    ///\n    /// - [`ComponentId`] must be from the same world as `self`.\n    /// - `T` must have the same layout as the one passed during `component_id` creation.\n    #[track_caller]\n    pub unsafe fn insert_by_id<T: Send + 'static>(\n        &mut self,\n        component_id: ComponentId,\n        value: T,\n    ) -> &mut Self {\n        let caller = Location::caller();\n        // SAFETY: same invariants as parent call\n        self.queue(unsafe {insert_by_id(component_id, value, move |entity| {\n            panic!(\"error[B0003]: {caller}: Could not insert a component {component_id:?} (with type {}) for entity {entity:?} because it doesn't exist in this World. See: https://bevyengine.org/learn/errors/b0003\", core::any::type_name::<T>());\n        })})\n    }\n\n    /// Attempts to add a dynamic component to an entity.\n    ///\n    /// See [`EntityWorldMut::insert_by_id`] for more information.\n    ///\n    /// # Safety\n    ///\n    /// - [`ComponentId`] must be from the same world as `self`.\n    /// - `T` must have the same layout as the one passed during `component_id` creation.\n    pub unsafe fn try_insert_by_id<T: Send + 'static>(\n        &mut self,\n        component_id: ComponentId,\n        value: T,\n    ) -> &mut Self {\n        // SAFETY: same invariants as parent call\n        self.queue(unsafe { insert_by_id(component_id, value, |_| {}) })\n    }\n\n    /// Tries to add a [`Bundle`] of components to the entity.\n    ///\n    /// This will overwrite any previous value(s) of the same component type.\n    ///\n    /// # Note\n    ///\n    /// Unlike [`Self::insert`], this will not panic if the associated entity does not exist.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use bevy_ecs::prelude::*;\n    /// # #[derive(Resource)]\n    /// # struct PlayerEntity { entity: Entity }\n    /// #[derive(Component)]\n    /// struct Health(u32);\n    /// #[derive(Component)]\n    /// struct Strength(u32);\n    /// #[derive(Component)]\n    /// struct Defense(u32);\n    ///\n    /// #[derive(Bundle)]\n    /// struct CombatBundle {\n    ///     health: Health,\n    ///     strength: Strength,\n    /// }\n    ///\n    /// fn add_combat_stats_system(mut commands: Commands, player: Res<PlayerEntity>) {\n    ///   commands.entity(player.entity)\n    ///    // You can try_insert individual components:\n    ///     .try_insert(Defense(10))\n    ///\n    ///    // You can also insert tuples of components:\n    ///     .try_insert(CombatBundle {\n    ///         health: Health(100),\n    ///         strength: Strength(40),\n    ///     });\n    ///\n    ///    // Suppose this occurs in a parallel adjacent system or process\n    ///    commands.entity(player.entity)\n    ///      .despawn();\n    ///\n    ///    commands.entity(player.entity)\n    ///    // This will not panic nor will it add the component\n    ///      .try_insert(Defense(5));\n    /// }\n    /// # bevy_ecs::system::assert_is_system(add_combat_stats_system);\n    /// ```\n    #[track_caller]\n    pub fn try_insert(&mut self, bundle: impl Bundle) -> &mut Self {\n        self.queue(try_insert(bundle, InsertMode::Replace))\n    }\n\n    /// Similar to [`Self::try_insert`] but will only try to insert if the predicate returns true.\n    /// This is useful for chaining method calls.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use bevy_ecs::prelude::*;\n    /// # #[derive(Resource)]\n    /// # struct PlayerEntity { entity: Entity }\n    /// # impl PlayerEntity { fn is_spectator(&self) -> bool { true } }\n    /// #[derive(Component)]\n    /// struct StillLoadingStats;\n    /// #[derive(Component)]\n    /// struct Health(u32);\n    ///\n    /// fn add_health_system(mut commands: Commands, player: Res<PlayerEntity>) {\n    ///   commands.entity(player.entity)\n    ///     .try_insert_if(Health(10), || !player.is_spectator())\n    ///     .remove::<StillLoadingStats>();\n    ///\n    ///    commands.entity(player.entity)\n    ///    // This will not panic nor will it add the component\n    ///      .try_insert_if(Health(5), || !player.is_spectator());\n    /// }\n    /// # bevy_ecs::system::assert_is_system(add_health_system);\n    /// ```\n    #[track_caller]\n    pub fn try_insert_if<F>(&mut self, bundle: impl Bundle, condition: F) -> &mut Self\n    where\n        F: FnOnce() -> bool,\n    {\n        if condition() {\n            self.queue(try_insert(bundle, InsertMode::Replace))\n        } else {\n            self\n        }\n    }\n\n    /// Tries to add a [`Bundle`] of components to the entity without overwriting if the\n    /// predicate returns true.\n    ///\n    /// This is the same as [`EntityCommands::try_insert_if`], but in case of duplicate\n    /// components will leave the old values instead of replacing them with new\n    /// ones.\n    ///\n    /// # Note\n    ///\n    /// Unlike [`Self::insert_if_new_and`], this will not panic if the associated entity does\n    /// not exist.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use bevy_ecs::prelude::*;\n    /// # #[derive(Resource)]\n    /// # struct PlayerEntity { entity: Entity }\n    /// # impl PlayerEntity { fn is_spectator(&self) -> bool { true } }\n    /// #[derive(Component)]\n    /// struct StillLoadingStats;\n    /// #[derive(Component)]\n    /// struct Health(u32);\n    ///\n    /// fn add_health_system(mut commands: Commands, player: Res<PlayerEntity>) {\n    ///   commands.entity(player.entity)\n    ///     .try_insert_if(Health(10), || player.is_spectator())\n    ///     .remove::<StillLoadingStats>();\n    ///\n    ///    commands.entity(player.entity)\n    ///    // This will not panic nor will it overwrite the component\n    ///      .try_insert_if_new_and(Health(5), || player.is_spectator());\n    /// }\n    /// # bevy_ecs::system::assert_is_system(add_health_system);\n    /// ```\n    pub fn try_insert_if_new_and<F>(&mut self, bundle: impl Bundle, condition: F) -> &mut Self\n    where\n        F: FnOnce() -> bool,\n    {\n        if condition() {\n            self.try_insert_if_new(bundle)\n        } else {\n            self\n        }\n    }\n\n    /// Tries to add a [`Bundle`] of components to the entity without overwriting.\n    ///\n    /// This is the same as [`EntityCommands::try_insert`], but in case of duplicate\n    /// components will leave the old values instead of replacing them with new\n    /// ones.\n    ///\n    /// # Note\n    ///\n    /// Unlike [`Self::insert_if_new`], this will not panic if the associated entity does not exist.\n    pub fn try_insert_if_new(&mut self, bundle: impl Bundle) -> &mut Self {\n        self.queue(try_insert(bundle, InsertMode::Keep))\n    }\n\n    /// Removes a [`Bundle`] of components from the entity.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use bevy_ecs::prelude::*;\n    /// #\n    /// # #[derive(Resource)]\n    /// # struct PlayerEntity { entity: Entity }\n    /// #[derive(Component)]\n    /// struct Health(u32);\n    /// #[derive(Component)]\n    /// struct Strength(u32);\n    /// #[derive(Component)]\n    /// struct Defense(u32);\n    ///\n    /// #[derive(Bundle)]\n    /// struct CombatBundle {\n    ///     health: Health,\n    ///     strength: Strength,\n    /// }\n    ///\n    /// fn remove_combat_stats_system(mut commands: Commands, player: Res<PlayerEntity>) {\n    ///     commands\n    ///         .entity(player.entity)\n    ///         // You can remove individual components:\n    ///         .remove::<Defense>()\n    ///         // You can also remove pre-defined Bundles of components:\n    ///         .remove::<CombatBundle>()\n    ///         // You can also remove tuples of components and bundles.\n    ///         // This is equivalent to the calls above:\n    ///         .remove::<(Defense, CombatBundle)>();\n    /// }\n    /// # bevy_ecs::system::assert_is_system(remove_combat_stats_system);\n    /// ```\n    pub fn remove<T>(&mut self) -> &mut Self\n    where\n        T: Bundle,\n    {\n        self.queue(remove::<T>)\n    }\n\n    /// Removes all components in the [`Bundle`] components and remove all required components for each component in the [`Bundle`] from entity.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use bevy_ecs::prelude::*;\n    ///\n    /// #[derive(Component)]\n    /// #[require(B)]\n    /// struct A;\n    /// #[derive(Component, Default)]\n    /// struct B;\n    ///\n    /// #[derive(Resource)]\n    /// struct PlayerEntity { entity: Entity }\n    ///\n    /// fn remove_with_requires_system(mut commands: Commands, player: Res<PlayerEntity>) {\n    ///     commands\n    ///         .entity(player.entity)\n    ///         // Remove both A and B components from the entity, because B is required by A\n    ///         .remove_with_requires::<A>();\n    /// }\n    /// # bevy_ecs::system::assert_is_system(remove_with_requires_system);\n    /// ```\n    pub fn remove_with_requires<T: Bundle>(&mut self) -> &mut Self {\n        self.queue(remove_with_requires::<T>)\n    }\n\n    /// Removes a component from the entity.\n    pub fn remove_by_id(&mut self, component_id: ComponentId) -> &mut Self {\n        self.queue(remove_by_id(component_id))\n    }\n\n    /// Removes all components associated with the entity.\n    pub fn clear(&mut self) -> &mut Self {\n        self.queue(clear())\n    }\n\n    /// Despawns the entity.\n    /// This will emit a warning if the entity does not exist.\n    ///\n    /// See [`World::despawn`] for more details.\n    ///\n    /// # Note\n    ///\n    /// This won't clean up external references to the entity (such as parent-child relationships\n    /// if you're using `bevy_hierarchy`), which may leave the world in an invalid state.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use bevy_ecs::prelude::*;\n    /// #\n    /// # #[derive(Resource)]\n    /// # struct CharacterToRemove { entity: Entity }\n    /// #\n    /// fn remove_character_system(\n    ///     mut commands: Commands,\n    ///     character_to_remove: Res<CharacterToRemove>\n    /// )\n    /// {\n    ///     commands.entity(character_to_remove.entity).despawn();\n    /// }\n    /// # bevy_ecs::system::assert_is_system(remove_character_system);\n    /// ```\n    #[track_caller]\n    pub fn despawn(&mut self) {\n        self.queue(despawn());\n    }\n\n    /// Despawns the entity.\n    /// This will not emit a warning if the entity does not exist, essentially performing\n    /// the same function as [`Self::despawn`] without emitting warnings.\n    #[track_caller]\n    pub fn try_despawn(&mut self) {\n        self.queue(try_despawn());\n    }\n\n    /// Pushes an [`EntityCommand`] to the queue, which will get executed for the current [`Entity`].\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use bevy_ecs::prelude::*;\n    /// # fn my_system(mut commands: Commands) {\n    /// commands\n    ///     .spawn_empty()\n    ///     // Closures with this signature implement `EntityCommand`.\n    ///     .queue(|entity: EntityWorldMut| {\n    ///         println!(\"Executed an EntityCommand for {:?}\", entity.id());\n    ///     });\n    /// # }\n    /// # bevy_ecs::system::assert_is_system(my_system);\n    /// ```\n    pub fn queue<M: 'static>(&mut self, command: impl EntityCommand<M>) -> &mut Self {\n        self.commands.queue(command.with_entity(self.entity));\n        self\n    }\n\n    /// Removes all components except the given [`Bundle`] from the entity.\n    ///\n    /// This can also be used to remove all the components from the entity by passing it an empty Bundle.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use bevy_ecs::prelude::*;\n    /// #\n    /// # #[derive(Resource)]\n    /// # struct PlayerEntity { entity: Entity }\n    /// #[derive(Component)]\n    /// struct Health(u32);\n    /// #[derive(Component)]\n    /// struct Strength(u32);\n    /// #[derive(Component)]\n    /// struct Defense(u32);\n    ///\n    /// #[derive(Bundle)]\n    /// struct CombatBundle {\n    ///     health: Health,\n    ///     strength: Strength,\n    /// }\n    ///\n    /// fn remove_combat_stats_system(mut commands: Commands, player: Res<PlayerEntity>) {\n    ///     commands\n    ///         .entity(player.entity)\n    ///         // You can retain a pre-defined Bundle of components,\n    ///         // with this removing only the Defense component\n    ///         .retain::<CombatBundle>()\n    ///         // You can also retain only a single component\n    ///         .retain::<Health>()\n    ///         // And you can remove all the components by passing in an empty Bundle\n    ///         .retain::<()>();\n    /// }\n    /// # bevy_ecs::system::assert_is_system(remove_combat_stats_system);\n    /// ```\n    pub fn retain<T>(&mut self) -> &mut Self\n    where\n        T: Bundle,\n    {\n        self.queue(retain::<T>)\n    }\n\n    /// Logs the components of the entity at the info level.\n    ///\n    /// # Panics\n    ///\n    /// The command will panic when applied if the associated entity does not exist.\n    pub fn log_components(&mut self) -> &mut Self {\n        self.queue(log_components)\n    }\n\n    /// Returns the underlying [`Commands`].\n    pub fn commands(&mut self) -> Commands {\n        self.commands.reborrow()\n    }\n\n    /// Returns a mutable reference to the underlying [`Commands`].\n    pub fn commands_mut(&mut self) -> &mut Commands<'a, 'a> {\n        &mut self.commands\n    }\n\n    /// Sends a [`Trigger`] targeting this entity. This will run any [`Observer`] of the `event` that\n    /// watches this entity.\n    ///\n    /// [`Trigger`]: crate::observer::Trigger\n    pub fn trigger(&mut self, event: impl Event) -> &mut Self {\n        self.commands.trigger_targets(event, self.entity);\n        self\n    }\n\n    /// Creates an [`Observer`] listening for a trigger of type `T` that targets this entity.\n    pub fn observe<E: Event, B: Bundle, M>(\n        &mut self,\n        system: impl IntoObserverSystem<E, B, M>,\n    ) -> &mut Self {\n        self.queue(observe(system))\n    }\n}\n\n/// A wrapper around [`EntityCommands`] with convenience methods for working with a specified component type.\npub struct EntityEntryCommands<'a, T> {\n    entity_commands: EntityCommands<'a>,\n    marker: PhantomData<T>,\n}\n\nimpl<'a, T: Component> EntityEntryCommands<'a, T> {\n    /// Modify the component `T` if it exists, using the function `modify`.\n    pub fn and_modify(&mut self, modify: impl FnOnce(Mut<T>) + Send + Sync + 'static) -> &mut Self {\n        self.entity_commands\n            .queue(move |mut entity: EntityWorldMut| {\n                if let Some(value) = entity.get_mut() {\n                    modify(value);\n                }\n            });\n        self\n    }\n\n    /// [Insert](EntityCommands::insert) `default` into this entity, if `T` is not already present.\n    ///\n    /// See also [`or_insert_with`](Self::or_insert_with).\n    ///\n    /// # Panics\n    ///\n    /// Panics if the entity does not exist.\n    /// See [`or_try_insert`](Self::or_try_insert) for a non-panicking version.\n    #[track_caller]\n    pub fn or_insert(&mut self, default: T) -> &mut Self {\n        self.entity_commands\n            .queue(insert(default, InsertMode::Keep));\n        self\n    }\n\n    /// [Insert](EntityCommands::insert) `default` into this entity, if `T` is not already present.\n    ///\n    /// Unlike [`or_insert`](Self::or_insert), this will not panic if the entity does not exist.\n    ///\n    /// See also [`or_insert_with`](Self::or_insert_with).\n    #[track_caller]\n    pub fn or_try_insert(&mut self, default: T) -> &mut Self {\n        self.entity_commands\n            .queue(try_insert(default, InsertMode::Keep));\n        self\n    }\n\n    /// [Insert](EntityCommands::insert) the value returned from `default` into this entity, if `T` is not already present.\n    ///\n    /// See also [`or_insert`](Self::or_insert) and [`or_try_insert`](Self::or_try_insert).\n    ///\n    /// # Panics\n    ///\n    /// Panics if the entity does not exist.\n    /// See [`or_try_insert_with`](Self::or_try_insert_with) for a non-panicking version.\n    #[track_caller]\n    pub fn or_insert_with(&mut self, default: impl Fn() -> T) -> &mut Self {\n        self.or_insert(default())\n    }\n\n    /// [Insert](EntityCommands::insert) the value returned from `default` into this entity, if `T` is not already present.\n    ///\n    /// Unlike [`or_insert_with`](Self::or_insert_with), this will not panic if the entity does not exist.\n    ///\n    /// See also [`or_insert`](Self::or_insert) and [`or_try_insert`](Self::or_try_insert).\n    #[track_caller]\n    pub fn or_try_insert_with(&mut self, default: impl Fn() -> T) -> &mut Self {\n        self.or_try_insert(default())\n    }\n\n    /// [Insert](EntityCommands::insert) `T::default` into this entity, if `T` is not already present.\n    ///\n    /// See also [`or_insert`](Self::or_insert) and [`or_from_world`](Self::or_from_world).\n    ///\n    /// # Panics\n    ///\n    /// Panics if the entity does not exist.\n    #[track_caller]\n    pub fn or_default(&mut self) -> &mut Self\n    where\n        T: Default,\n    {\n        #[allow(clippy::unwrap_or_default)]\n        // FIXME: use `expect` once stable\n        self.or_insert(T::default())\n    }\n\n    /// [Insert](EntityCommands::insert) `T::from_world` into this entity, if `T` is not already present.\n    ///\n    /// See also [`or_insert`](Self::or_insert) and [`or_default`](Self::or_default).\n    ///\n    /// # Panics\n    ///\n    /// Panics if the entity does not exist.\n    #[track_caller]\n    pub fn or_from_world(&mut self) -> &mut Self\n    where\n        T: FromWorld,\n    {\n        self.entity_commands\n            .queue(insert_from_world::<T>(InsertMode::Keep));\n        self\n    }\n}\n\nimpl<F> Command for F\nwhere\n    F: FnOnce(&mut World) + Send + 'static,\n{\n    fn apply(self, world: &mut World) {\n        self(world);\n    }\n}\n\nimpl<F> EntityCommand<World> for F\nwhere\n    F: FnOnce(EntityWorldMut) + Send + 'static,\n{\n    fn apply(self, id: Entity, world: &mut World) {\n        self(world.entity_mut(id));\n    }\n}\n\nimpl<F> EntityCommand for F\nwhere\n    F: FnOnce(Entity, &mut World) + Send + 'static,\n{\n    fn apply(self, id: Entity, world: &mut World) {\n        self(id, world);\n    }\n}\n\n/// A [`Command`] that consumes an iterator of [`Bundle`]s to spawn a series of entities.\n///\n/// This is more efficient than spawning the entities individually.\n#[track_caller]\nfn spawn_batch<I, B>(bundles_iter: I) -> impl Command\nwhere\n    I: IntoIterator<Item = B> + Send + Sync + 'static,\n    B: Bundle,\n{\n    #[cfg(feature = \"track_change_detection\")]\n    let caller = Location::caller();\n    move |world: &mut World| {\n        SpawnBatchIter::new(\n            world,\n            bundles_iter.into_iter(),\n            #[cfg(feature = \"track_change_detection\")]\n            caller,\n        );\n    }\n}\n\n/// A [`Command`] that consumes an iterator to add a series of [`Bundle`]s to a set of entities.\n/// If any entities do not already exist in the world, they will be spawned.\n///\n/// This is more efficient than inserting the bundles individually.\n#[track_caller]\nfn insert_or_spawn_batch<I, B>(bundles_iter: I) -> impl Command\nwhere\n    I: IntoIterator<Item = (Entity, B)> + Send + Sync + 'static,\n    B: Bundle,\n{\n    #[cfg(feature = \"track_change_detection\")]\n    let caller = Location::caller();\n    move |world: &mut World| {\n        if let Err(invalid_entities) = world.insert_or_spawn_batch_with_caller(\n            bundles_iter,\n            #[cfg(feature = \"track_change_detection\")]\n            caller,\n        ) {\n            error!(\n                \"Failed to 'insert or spawn' bundle of type {} into the following invalid entities: {:?}\",\n                core::any::type_name::<B>(),\n                invalid_entities\n            );\n        }\n    }\n}\n\n/// A [`Command`] that consumes an iterator to add a series of [`Bundles`](Bundle) to a set of entities.\n/// If any entities do not exist in the world, this command will panic.\n///\n/// This is more efficient than inserting the bundles individually.\n#[track_caller]\nfn insert_batch<I, B>(batch: I) -> impl Command\nwhere\n    I: IntoIterator<Item = (Entity, B)> + Send + Sync + 'static,\n    B: Bundle,\n{\n    #[cfg(feature = \"track_change_detection\")]\n    let caller = Location::caller();\n    move |world: &mut World| {\n        world.insert_batch_with_caller(\n            batch,\n            InsertMode::Replace,\n            #[cfg(feature = \"track_change_detection\")]\n            caller,\n        );\n    }\n}\n\n/// A [`Command`] that consumes an iterator to add a series of [`Bundles`](Bundle) to a set of entities.\n/// If any entities do not exist in the world, this command will panic.\n///\n/// This is more efficient than inserting the bundles individually.\n#[track_caller]\nfn insert_batch_if_new<I, B>(batch: I) -> impl Command\nwhere\n    I: IntoIterator<Item = (Entity, B)> + Send + Sync + 'static,\n    B: Bundle,\n{\n    #[cfg(feature = \"track_change_detection\")]\n    let caller = Location::caller();\n    move |world: &mut World| {\n        world.insert_batch_with_caller(\n            batch,\n            InsertMode::Keep,\n            #[cfg(feature = \"track_change_detection\")]\n            caller,\n        );\n    }\n}\n\n/// A [`Command`] that consumes an iterator to add a series of [`Bundles`](Bundle) to a set of entities.\n/// If any entities do not exist in the world, this command will ignore them.\n///\n/// This is more efficient than inserting the bundles individually.\n#[track_caller]\nfn try_insert_batch<I, B>(batch: I) -> impl Command\nwhere\n    I: IntoIterator<Item = (Entity, B)> + Send + Sync + 'static,\n    B: Bundle,\n{\n    #[cfg(feature = \"track_change_detection\")]\n    let caller = Location::caller();\n    move |world: &mut World| {\n        world.try_insert_batch_with_caller(\n            batch,\n            InsertMode::Replace,\n            #[cfg(feature = \"track_change_detection\")]\n            caller,\n        );\n    }\n}\n\n/// A [`Command`] that consumes an iterator to add a series of [`Bundles`](Bundle) to a set of entities.\n/// If any entities do not exist in the world, this command will ignore them.\n///\n/// This is more efficient than inserting the bundles individually.\n#[track_caller]\nfn try_insert_batch_if_new<I, B>(batch: I) -> impl Command\nwhere\n    I: IntoIterator<Item = (Entity, B)> + Send + Sync + 'static,\n    B: Bundle,\n{\n    #[cfg(feature = \"track_change_detection\")]\n    let caller = Location::caller();\n    move |world: &mut World| {\n        world.try_insert_batch_with_caller(\n            batch,\n            InsertMode::Keep,\n            #[cfg(feature = \"track_change_detection\")]\n            caller,\n        );\n    }\n}\n\n/// A [`Command`] that despawns a specific entity.\n/// This will emit a warning if the entity does not exist.\n///\n/// # Note\n///\n/// This won't clean up external references to the entity (such as parent-child relationships\n/// if you're using `bevy_hierarchy`), which may leave the world in an invalid state.\n#[track_caller]\nfn despawn() -> impl EntityCommand {\n    let caller = Location::caller();\n    move |entity: Entity, world: &mut World| {\n        world.despawn_with_caller(entity, caller, true);\n    }\n}\n\n/// A [`Command`] that despawns a specific entity.\n/// This will not emit a warning if the entity does not exist.\n///\n/// # Note\n///\n/// This won't clean up external references to the entity (such as parent-child relationships\n/// if you're using `bevy_hierarchy`), which may leave the world in an invalid state.\n#[track_caller]\nfn try_despawn() -> impl EntityCommand {\n    let caller = Location::caller();\n    move |entity: Entity, world: &mut World| {\n        world.despawn_with_caller(entity, caller, false);\n    }\n}\n\n/// An [`EntityCommand`] that adds the components in a [`Bundle`] to an entity.\n#[track_caller]\nfn insert<T: Bundle>(bundle: T, mode: InsertMode) -> impl EntityCommand {\n    let caller = Location::caller();\n    move |entity: Entity, world: &mut World| {\n        if let Ok(mut entity) = world.get_entity_mut(entity) {\n            entity.insert_with_caller(\n                bundle,\n                mode,\n                #[cfg(feature = \"track_change_detection\")]\n                caller,\n            );\n        } else {\n            panic!(\"error[B0003]: {caller}: Could not insert a bundle (of type `{}`) for entity {:?} because it doesn't exist in this World. See: https://bevyengine.org/learn/errors/b0003\", core::any::type_name::<T>(), entity);\n        }\n    }\n}\n\n/// An [`EntityCommand`] that adds the component using its `FromWorld` implementation.\n#[track_caller]\nfn insert_from_world<T: Component + FromWorld>(mode: InsertMode) -> impl EntityCommand {\n    let caller = Location::caller();\n    move |entity: Entity, world: &mut World| {\n        let value = T::from_world(world);\n        if let Ok(mut entity) = world.get_entity_mut(entity) {\n            entity.insert_with_caller(\n                value,\n                mode,\n                #[cfg(feature = \"track_change_detection\")]\n                caller,\n            );\n        } else {\n            panic!(\"error[B0003]: {caller}: Could not insert a bundle (of type `{}`) for entity {:?} because it doesn't exist in this World. See: https://bevyengine.org/learn/errors/b0003\", core::any::type_name::<T>(), entity);\n        }\n    }\n}\n\n/// An [`EntityCommand`] that attempts to add the components in a [`Bundle`] to an entity.\n/// Does nothing if the entity does not exist.\n#[track_caller]\nfn try_insert(bundle: impl Bundle, mode: InsertMode) -> impl EntityCommand {\n    #[cfg(feature = \"track_change_detection\")]\n    let caller = Location::caller();\n    move |entity: Entity, world: &mut World| {\n        if let Ok(mut entity) = world.get_entity_mut(entity) {\n            entity.insert_with_caller(\n                bundle,\n                mode,\n                #[cfg(feature = \"track_change_detection\")]\n                caller,\n            );\n        }\n    }\n}\n\n/// An [`EntityCommand`] that attempts to add the dynamic component to an entity.\n///\n/// # Safety\n///\n/// - The returned `EntityCommand` must be queued for the world where `component_id` was created.\n/// - `T` must be the type represented by `component_id`.\nunsafe fn insert_by_id<T: Send + 'static>(\n    component_id: ComponentId,\n    value: T,\n    on_none_entity: impl FnOnce(Entity) + Send + 'static,\n) -> impl EntityCommand {\n    move |entity: Entity, world: &mut World| {\n        if let Ok(mut entity) = world.get_entity_mut(entity) {\n            // SAFETY:\n            // - `component_id` safety is ensured by the caller\n            // - `ptr` is valid within the `make` block;\n            OwningPtr::make(value, |ptr| unsafe {\n                entity.insert_by_id(component_id, ptr);\n            });\n        } else {\n            on_none_entity(entity);\n        }\n    }\n}\n\n/// An [`EntityCommand`] that removes components from an entity.\n///\n/// For a [`Bundle`] type `T`, this will remove any components in the bundle.\n/// Any components in the bundle that aren't found on the entity will be ignored.\nfn remove<T: Bundle>(entity: Entity, world: &mut World) {\n    if let Ok(mut entity) = world.get_entity_mut(entity) {\n        entity.remove::<T>();\n    }\n}\n\n/// An [`EntityCommand`] that removes components with a provided [`ComponentId`] from an entity.\n/// # Panics\n///\n/// Panics if the provided [`ComponentId`] does not exist in the [`World`].\nfn remove_by_id(component_id: ComponentId) -> impl EntityCommand {\n    move |entity: Entity, world: &mut World| {\n        if let Ok(mut entity) = world.get_entity_mut(entity) {\n            entity.remove_by_id(component_id);\n        }\n    }\n}\n\n/// An [`EntityCommand`] that remove all components in the bundle and remove all required components for each component in the bundle.\nfn remove_with_requires<T: Bundle>(entity: Entity, world: &mut World) {\n    if let Ok(mut entity) = world.get_entity_mut(entity) {\n        entity.remove_with_requires::<T>();\n    }\n}\n\n/// An [`EntityCommand`] that removes all components associated with a provided entity.\nfn clear() -> impl EntityCommand {\n    move |entity: Entity, world: &mut World| {\n        if let Ok(mut entity) = world.get_entity_mut(entity) {\n            entity.clear();\n        }\n    }\n}\n\n/// An [`EntityCommand`] that removes components from an entity.\n///\n/// For a [`Bundle`] type `T`, this will remove all components except those in the bundle.\n/// Any components in the bundle that aren't found on the entity will be ignored.\nfn retain<T: Bundle>(entity: Entity, world: &mut World) {\n    if let Ok(mut entity_mut) = world.get_entity_mut(entity) {\n        entity_mut.retain::<T>();\n    }\n}\n\n/// A [`Command`] that inserts a [`Resource`] into the world using a value\n/// created with the [`FromWorld`] trait.\n#[track_caller]\nfn init_resource<R: Resource + FromWorld>(world: &mut World) {\n    world.init_resource::<R>();\n}\n\n/// A [`Command`] that removes the [resource](Resource) `R` from the world.\n#[track_caller]\nfn remove_resource<R: Resource>(world: &mut World) {\n    world.remove_resource::<R>();\n}\n\n/// A [`Command`] that inserts a [`Resource`] into the world.\n#[track_caller]\nfn insert_resource<R: Resource>(resource: R) -> impl Command {\n    #[cfg(feature = \"track_change_detection\")]\n    let caller = Location::caller();\n    move |world: &mut World| {\n        world.insert_resource_with_caller(\n            resource,\n            #[cfg(feature = \"track_change_detection\")]\n            caller,\n        );\n    }\n}\n\n/// [`EntityCommand`] to log the components of a given entity. See [`EntityCommands::log_components`].\nfn log_components(entity: Entity, world: &mut World) {\n    let debug_infos: Vec<_> = world\n        .inspect_entity(entity)\n        .map(ComponentInfo::name)\n        .collect();\n    info!(\"Entity {entity}: {debug_infos:?}\");\n}\n\nfn observe<E: Event, B: Bundle, M>(\n    observer: impl IntoObserverSystem<E, B, M>,\n) -> impl EntityCommand {\n    move |entity: Entity, world: &mut World| {\n        if let Ok(mut entity) = world.get_entity_mut(entity) {\n            entity.observe(observer);\n        }\n    }\n}\n\n#[cfg(test)]\n#[allow(clippy::float_cmp, clippy::approx_constant)]\nmod tests {\n    use crate::{\n        self as bevy_ecs,\n        component::Component,\n        system::{Commands, Resource},\n        world::{CommandQueue, FromWorld, World},\n    };\n    use alloc::sync::Arc;\n    use core::{\n        any::TypeId,\n        sync::atomic::{AtomicUsize, Ordering},\n    };\n\n    #[allow(dead_code)]\n    #[derive(Component)]\n    #[component(storage = \"SparseSet\")]\n    struct SparseDropCk(DropCk);\n\n    #[derive(Component)]\n    struct DropCk(Arc<AtomicUsize>);\n    impl DropCk {\n        fn new_pair() -> (Self, Arc<AtomicUsize>) {\n            let atomic = Arc::new(AtomicUsize::new(0));\n            (DropCk(atomic.clone()), atomic)\n        }\n    }\n\n    impl Drop for DropCk {\n        fn drop(&mut self) {\n            self.0.as_ref().fetch_add(1, Ordering::Relaxed);\n        }\n    }\n\n    #[derive(Component, Resource)]\n    struct W<T>(T);\n\n    fn simple_command(world: &mut World) {\n        world.spawn((W(0u32), W(42u64)));\n    }\n\n    impl FromWorld for W<String> {\n        fn from_world(world: &mut World) -> Self {\n            let v = world.resource::<W<usize>>();\n            Self(\"*\".repeat(v.0))\n        }\n    }\n\n    #[test]\n    fn entity_commands_entry() {\n        let mut world = World::default();\n        let mut queue = CommandQueue::default();\n        let mut commands = Commands::new(&mut queue, &world);\n        let entity = commands.spawn_empty().id();\n        commands\n            .entity(entity)\n            .entry::<W<u32>>()\n            .and_modify(|_| unreachable!());\n        queue.apply(&mut world);\n        assert!(!world.entity(entity).contains::<W<u32>>());\n        let mut commands = Commands::new(&mut queue, &world);\n        commands\n            .entity(entity)\n            .entry::<W<u32>>()\n            .or_insert(W(0))\n            .and_modify(|mut val| {\n                val.0 = 21;\n            });\n        queue.apply(&mut world);\n        assert_eq!(21, world.get::<W<u32>>(entity).unwrap().0);\n        let mut commands = Commands::new(&mut queue, &world);\n        commands\n            .entity(entity)\n            .entry::<W<u64>>()\n            .and_modify(|_| unreachable!())\n            .or_insert(W(42));\n        queue.apply(&mut world);\n        assert_eq!(42, world.get::<W<u64>>(entity).unwrap().0);\n        world.insert_resource(W(5_usize));\n        let mut commands = Commands::new(&mut queue, &world);\n        commands.entity(entity).entry::<W<String>>().or_from_world();\n        queue.apply(&mut world);\n        assert_eq!(\"*****\", &world.get::<W<String>>(entity).unwrap().0);\n    }\n\n    #[test]\n    fn commands() {\n        let mut world = World::default();\n        let mut command_queue = CommandQueue::default();\n        let entity = Commands::new(&mut command_queue, &world)\n            .spawn((W(1u32), W(2u64)))\n            .id();\n        command_queue.apply(&mut world);\n        assert_eq!(world.entities().len(), 1);\n        let results = world\n            .query::<(&W<u32>, &W<u64>)>()\n            .iter(&world)\n            .map(|(a, b)| (a.0, b.0))\n            .collect::<Vec<_>>();\n        assert_eq!(results, vec![(1u32, 2u64)]);\n        // test entity despawn\n        {\n            let mut commands = Commands::new(&mut command_queue, &world);\n            commands.entity(entity).despawn();\n            commands.entity(entity).despawn(); // double despawn shouldn't panic\n        }\n        command_queue.apply(&mut world);\n        let results2 = world\n            .query::<(&W<u32>, &W<u64>)>()\n            .iter(&world)\n            .map(|(a, b)| (a.0, b.0))\n            .collect::<Vec<_>>();\n        assert_eq!(results2, vec![]);\n\n        // test adding simple (FnOnce) commands\n        {\n            let mut commands = Commands::new(&mut command_queue, &world);\n\n            // set up a simple command using a closure that adds one additional entity\n            commands.queue(|world: &mut World| {\n                world.spawn((W(42u32), W(0u64)));\n            });\n\n            // set up a simple command using a function that adds one additional entity\n            commands.queue(simple_command);\n        }\n        command_queue.apply(&mut world);\n        let results3 = world\n            .query::<(&W<u32>, &W<u64>)>()\n            .iter(&world)\n            .map(|(a, b)| (a.0, b.0))\n            .collect::<Vec<_>>();\n\n        assert_eq!(results3, vec![(42u32, 0u64), (0u32, 42u64)]);\n    }\n\n    #[test]\n    fn insert_components() {\n        let mut world = World::default();\n        let mut command_queue1 = CommandQueue::default();\n\n        // insert components\n        let entity = Commands::new(&mut command_queue1, &world)\n            .spawn(())\n            .insert_if(W(1u8), || true)\n            .insert_if(W(2u8), || false)\n            .insert_if_new(W(1u16))\n            .insert_if_new(W(2u16))\n            .insert_if_new_and(W(1u32), || false)\n            .insert_if_new_and(W(2u32), || true)\n            .insert_if_new_and(W(3u32), || true)\n            .id();\n        command_queue1.apply(&mut world);\n\n        let results = world\n            .query::<(&W<u8>, &W<u16>, &W<u32>)>()\n            .iter(&world)\n            .map(|(a, b, c)| (a.0, b.0, c.0))\n            .collect::<Vec<_>>();\n        assert_eq!(results, vec![(1u8, 1u16, 2u32)]);\n\n        // try to insert components after despawning entity\n        // in another command queue\n        Commands::new(&mut command_queue1, &world)\n            .entity(entity)\n            .try_insert_if_new_and(W(1u64), || true);\n\n        let mut command_queue2 = CommandQueue::default();\n        Commands::new(&mut command_queue2, &world)\n            .entity(entity)\n            .despawn();\n        command_queue2.apply(&mut world);\n        command_queue1.apply(&mut world);\n    }\n\n    #[test]\n    fn remove_components() {\n        let mut world = World::default();\n\n        let mut command_queue = CommandQueue::default();\n        let (dense_dropck, dense_is_dropped) = DropCk::new_pair();\n        let (sparse_dropck, sparse_is_dropped) = DropCk::new_pair();\n        let sparse_dropck = SparseDropCk(sparse_dropck);\n\n        let entity = Commands::new(&mut command_queue, &world)\n            .spawn((W(1u32), W(2u64), dense_dropck, sparse_dropck))\n            .id();\n        command_queue.apply(&mut world);\n        let results_before = world\n            .query::<(&W<u32>, &W<u64>)>()\n            .iter(&world)\n            .map(|(a, b)| (a.0, b.0))\n            .collect::<Vec<_>>();\n        assert_eq!(results_before, vec![(1u32, 2u64)]);\n\n        // test component removal\n        Commands::new(&mut command_queue, &world)\n            .entity(entity)\n            .remove::<W<u32>>()\n            .remove::<(W<u32>, W<u64>, SparseDropCk, DropCk)>();\n\n        assert_eq!(dense_is_dropped.load(Ordering::Relaxed), 0);\n        assert_eq!(sparse_is_dropped.load(Ordering::Relaxed), 0);\n        command_queue.apply(&mut world);\n        assert_eq!(dense_is_dropped.load(Ordering::Relaxed), 1);\n        assert_eq!(sparse_is_dropped.load(Ordering::Relaxed), 1);\n\n        let results_after = world\n            .query::<(&W<u32>, &W<u64>)>()\n            .iter(&world)\n            .map(|(a, b)| (a.0, b.0))\n            .collect::<Vec<_>>();\n        assert_eq!(results_after, vec![]);\n        let results_after_u64 = world\n            .query::<&W<u64>>()\n            .iter(&world)\n            .map(|v| v.0)\n            .collect::<Vec<_>>();\n        assert_eq!(results_after_u64, vec![]);\n    }\n\n    #[test]\n    fn remove_components_by_id() {\n        let mut world = World::default();\n\n        let mut command_queue = CommandQueue::default();\n        let (dense_dropck, dense_is_dropped) = DropCk::new_pair();\n        let (sparse_dropck, sparse_is_dropped) = DropCk::new_pair();\n        let sparse_dropck = SparseDropCk(sparse_dropck);\n\n        let entity = Commands::new(&mut command_queue, &world)\n            .spawn((W(1u32), W(2u64), dense_dropck, sparse_dropck))\n            .id();\n        command_queue.apply(&mut world);\n        let results_before = world\n            .query::<(&W<u32>, &W<u64>)>()\n            .iter(&world)\n            .map(|(a, b)| (a.0, b.0))\n            .collect::<Vec<_>>();\n        assert_eq!(results_before, vec![(1u32, 2u64)]);\n\n        // test component removal\n        Commands::new(&mut command_queue, &world)\n            .entity(entity)\n            .remove_by_id(world.components().get_id(TypeId::of::<W<u32>>()).unwrap())\n            .remove_by_id(world.components().get_id(TypeId::of::<W<u64>>()).unwrap())\n            .remove_by_id(world.components().get_id(TypeId::of::<DropCk>()).unwrap())\n            .remove_by_id(\n                world\n                    .components()\n                    .get_id(TypeId::of::<SparseDropCk>())\n                    .unwrap(),\n            );\n\n        assert_eq!(dense_is_dropped.load(Ordering::Relaxed), 0);\n        assert_eq!(sparse_is_dropped.load(Ordering::Relaxed), 0);\n        command_queue.apply(&mut world);\n        assert_eq!(dense_is_dropped.load(Ordering::Relaxed), 1);\n        assert_eq!(sparse_is_dropped.load(Ordering::Relaxed), 1);\n\n        let results_after = world\n            .query::<(&W<u32>, &W<u64>)>()\n            .iter(&world)\n            .map(|(a, b)| (a.0, b.0))\n            .collect::<Vec<_>>();\n        assert_eq!(results_after, vec![]);\n        let results_after_u64 = world\n            .query::<&W<u64>>()\n            .iter(&world)\n            .map(|v| v.0)\n            .collect::<Vec<_>>();\n        assert_eq!(results_after_u64, vec![]);\n    }\n\n    #[test]\n    fn remove_resources() {\n        let mut world = World::default();\n        let mut queue = CommandQueue::default();\n        {\n            let mut commands = Commands::new(&mut queue, &world);\n            commands.insert_resource(W(123i32));\n            commands.insert_resource(W(456.0f64));\n        }\n\n        queue.apply(&mut world);\n        assert!(world.contains_resource::<W<i32>>());\n        assert!(world.contains_resource::<W<f64>>());\n\n        {\n            let mut commands = Commands::new(&mut queue, &world);\n            // test resource removal\n            commands.remove_resource::<W<i32>>();\n        }\n        queue.apply(&mut world);\n        assert!(!world.contains_resource::<W<i32>>());\n        assert!(world.contains_resource::<W<f64>>());\n    }\n\n    #[test]\n    fn remove_component_with_required_components() {\n        #[derive(Component)]\n        #[require(Y)]\n        struct X;\n\n        #[derive(Component, Default)]\n        struct Y;\n\n        #[derive(Component)]\n        struct Z;\n\n        let mut world = World::default();\n        let mut queue = CommandQueue::default();\n        let e = {\n            let mut commands = Commands::new(&mut queue, &world);\n            commands.spawn((X, Z)).id()\n        };\n        queue.apply(&mut world);\n\n        assert!(world.get::<Y>(e).is_some());\n        assert!(world.get::<X>(e).is_some());\n        assert!(world.get::<Z>(e).is_some());\n\n        {\n            let mut commands = Commands::new(&mut queue, &world);\n            commands.entity(e).remove_with_requires::<X>();\n        }\n        queue.apply(&mut world);\n\n        assert!(world.get::<Y>(e).is_none());\n        assert!(world.get::<X>(e).is_none());\n\n        assert!(world.get::<Z>(e).is_some());\n    }\n\n    fn is_send<T: Send>() {}\n    fn is_sync<T: Sync>() {}\n\n    #[test]\n    fn test_commands_are_send_and_sync() {\n        is_send::<Commands>();\n        is_sync::<Commands>();\n    }\n\n    #[test]\n    fn append() {\n        let mut world = World::default();\n        let mut queue_1 = CommandQueue::default();\n        {\n            let mut commands = Commands::new(&mut queue_1, &world);\n            commands.insert_resource(W(123i32));\n        }\n        let mut queue_2 = CommandQueue::default();\n        {\n            let mut commands = Commands::new(&mut queue_2, &world);\n            commands.insert_resource(W(456.0f64));\n        }\n        queue_1.append(&mut queue_2);\n        queue_1.apply(&mut world);\n        assert!(world.contains_resource::<W<i32>>());\n        assert!(world.contains_resource::<W<f64>>());\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "8da1f9bb1400a49f5fee3e631c2f6bebbd93e55d",
    "func": "//! Incremental file based incremental rendering\n\n#![allow(non_snake_case)]\n\nuse chrono::offset::Utc;\nuse chrono::DateTime;\nuse rustc_hash::FxHasher;\nuse std::{hash::BuildHasherDefault, num::NonZeroUsize};\n\nuse super::freshness::RenderFreshness;\n\npub(crate) struct InMemoryCache {\n    #[allow(clippy::type_complexity)]\n    lru: Option<lru::LruCache<String, (DateTime<Utc>, Vec<u8>), BuildHasherDefault<FxHasher>>>,\n    invalidate_after: Option<std::time::Duration>,\n}\n\nimpl InMemoryCache {\n    pub fn new(memory_cache_limit: usize, invalidate_after: Option<std::time::Duration>) -> Self {\n        Self {\n            lru: NonZeroUsize::new(memory_cache_limit)\n                .map(|limit| lru::LruCache::with_hasher(limit, Default::default())),\n            invalidate_after,\n        }\n    }\n\n    pub fn clear(&mut self) {\n        if let Some(cache) = &mut self.lru {\n            cache.clear();\n        }\n    }\n\n    pub fn put(&mut self, route: String, timestamp: DateTime<Utc>, data: Vec<u8>) {\n        if let Some(cache) = &mut self.lru {\n            cache.put(route, (timestamp, data));\n        }\n    }\n\n    pub fn invalidate(&mut self, route: &str) {\n        if let Some(cache) = &mut self.lru {\n            cache.pop(route);\n        }\n    }\n\n    pub fn try_get_or_insert<'a, F: FnOnce() -> Result<(DateTime<Utc>, Vec<u8>), E>, E>(\n        &'a mut self,\n        route: &str,\n        or_insert: F,\n    ) -> Result<Option<(RenderFreshness, &'a [u8])>, E> {\n        if let Some(memory_cache) = self.lru.as_mut() {\n            let (timestamp, _) = memory_cache.try_get_or_insert(route.to_string(), or_insert)?;\n\n            let now = Utc::now();\n            let elapsed = timestamp.signed_duration_since(now);\n            let age = elapsed.num_seconds();\n            // The cache entry is out of date, so we need to remove it.\n            if let Some(invalidate_after) = self.invalidate_after {\n                if elapsed.to_std().unwrap() > invalidate_after {\n                    tracing::trace!(\"memory cache out of date\");\n                    memory_cache.pop(route);\n                    return Ok(None);\n                }\n            }\n\n            // We need to reborrow because we may have invalidated the lifetime if the route was removed.\n            // We know it wasn't because we returned... but rust doesn't understand that.\n            let (timestamp, cache_hit) = memory_cache.get(route).unwrap();\n\n            return match self.invalidate_after {\n                Some(invalidate_after) => {\n                    tracing::trace!(\"memory cache hit\");\n                    let max_age = invalidate_after.as_secs();\n                    let freshness = RenderFreshness::new(age as u64, max_age, *timestamp);\n                    Ok(Some((freshness, cache_hit)))\n                }\n                None => {\n                    tracing::trace!(\"memory cache hit\");\n                    let freshness = RenderFreshness::new_age(age as u64, *timestamp);\n                    Ok(Some((freshness, cache_hit)))\n                }\n            };\n        }\n\n        Ok(None)\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "b04427d7cb4970ac0991c040e18cf8aa8e2ef3c2",
    "func": "// Adapted from https://github.com/Alexhuszagh/rust-lexical.\n\n//! Utilities for Rust numbers.\n\nuse core::ops;\n\n/// Precalculated values of radix**i for i in range [0, arr.len()-1].\n/// Each value can be **exactly** represented as that type.\nconst F32_POW10: [f32; 11] = [\n    1.0,\n    10.0,\n    100.0,\n    1000.0,\n    10000.0,\n    100000.0,\n    1000000.0,\n    10000000.0,\n    100000000.0,\n    1000000000.0,\n    10000000000.0,\n];\n\n/// Precalculated values of radix**i for i in range [0, arr.len()-1].\n/// Each value can be **exactly** represented as that type.\nconst F64_POW10: [f64; 23] = [\n    1.0,\n    10.0,\n    100.0,\n    1000.0,\n    10000.0,\n    100000.0,\n    1000000.0,\n    10000000.0,\n    100000000.0,\n    1000000000.0,\n    10000000000.0,\n    100000000000.0,\n    1000000000000.0,\n    10000000000000.0,\n    100000000000000.0,\n    1000000000000000.0,\n    10000000000000000.0,\n    100000000000000000.0,\n    1000000000000000000.0,\n    10000000000000000000.0,\n    100000000000000000000.0,\n    1000000000000000000000.0,\n    10000000000000000000000.0,\n];\n\n/// Type that can be converted to primitive with `as`.\npub trait AsPrimitive: Sized + Copy + PartialOrd {\n    fn as_u32(self) -> u32;\n    fn as_u64(self) -> u64;\n    fn as_u128(self) -> u128;\n    fn as_usize(self) -> usize;\n    fn as_f32(self) -> f32;\n    fn as_f64(self) -> f64;\n}\n\nmacro_rules! as_primitive_impl {\n    ($($ty:ident)*) => {\n        $(\n            impl AsPrimitive for $ty {\n                #[inline]\n                fn as_u32(self) -> u32 {\n                    self as u32\n                }\n\n                #[inline]\n                fn as_u64(self) -> u64 {\n                    self as u64\n                }\n\n                #[inline]\n                fn as_u128(self) -> u128 {\n                    self as u128\n                }\n\n                #[inline]\n                fn as_usize(self) -> usize {\n                    self as usize\n                }\n\n                #[inline]\n                fn as_f32(self) -> f32 {\n                    self as f32\n                }\n\n                #[inline]\n                fn as_f64(self) -> f64 {\n                    self as f64\n                }\n            }\n        )*\n    };\n}\n\nas_primitive_impl! { u32 u64 u128 usize f32 f64 }\n\n/// An interface for casting between machine scalars.\npub trait AsCast: AsPrimitive {\n    /// Creates a number from another value that can be converted into\n    /// a primitive via the `AsPrimitive` trait.\n    fn as_cast<N: AsPrimitive>(n: N) -> Self;\n}\n\nmacro_rules! as_cast_impl {\n    ($ty:ident, $method:ident) => {\n        impl AsCast for $ty {\n            #[inline]\n            fn as_cast<N: AsPrimitive>(n: N) -> Self {\n                n.$method()\n            }\n        }\n    };\n}\n\nas_cast_impl!(u32, as_u32);\nas_cast_impl!(u64, as_u64);\nas_cast_impl!(u128, as_u128);\nas_cast_impl!(usize, as_usize);\nas_cast_impl!(f32, as_f32);\nas_cast_impl!(f64, as_f64);\n\n/// Numerical type trait.\npub trait Number: AsCast + ops::Add<Output = Self> {}\n\nmacro_rules! number_impl {\n    ($($ty:ident)*) => {\n        $(\n            impl Number for $ty {}\n        )*\n    };\n}\n\nnumber_impl! { u32 u64 u128 usize f32 f64 }\n\n/// Defines a trait that supports integral operations.\npub trait Integer: Number + ops::BitAnd<Output = Self> + ops::Shr<i32, Output = Self> {\n    const ZERO: Self;\n}\n\nmacro_rules! integer_impl {\n    ($($ty:tt)*) => {\n        $(\n            impl Integer for $ty {\n                const ZERO: Self = 0;\n            }\n        )*\n    };\n}\n\ninteger_impl! { u32 u64 u128 usize }\n\n/// Type trait for the mantissa type.\npub trait Mantissa: Integer {\n    /// Mask to extract the high bits from the integer.\n    const HIMASK: Self;\n    /// Mask to extract the low bits from the integer.\n    const LOMASK: Self;\n    /// Full size of the integer, in bits.\n    const FULL: i32;\n    /// Half size of the integer, in bits.\n    const HALF: i32 = Self::FULL / 2;\n}\n\nimpl Mantissa for u64 {\n    const HIMASK: u64 = 0xFFFFFFFF00000000;\n    const LOMASK: u64 = 0x00000000FFFFFFFF;\n    const FULL: i32 = 64;\n}\n\n/// Get exact exponent limit for radix.\npub trait Float: Number {\n    /// Unsigned type of the same size.\n    type Unsigned: Integer;\n\n    /// Literal zero.\n    const ZERO: Self;\n    /// Maximum number of digits that can contribute in the mantissa.\n    ///\n    /// We can exactly represent a float in radix `b` from radix 2 if\n    /// `b` is divisible by 2. This function calculates the exact number of\n    /// digits required to exactly represent that float.\n    ///\n    /// According to the \"Handbook of Floating Point Arithmetic\",\n    /// for IEEE754, with emin being the min exponent, p2 being the\n    /// precision, and b being the radix, the number of digits follows as:\n    ///\n    /// `\u2212emin + p2 + \u230a(emin + 1) log(2, b) \u2212 log(1 \u2212 2^(\u2212p2), b)\u230b`\n    ///\n    /// For f32, this follows as:\n    ///     emin = -126\n    ///     p2 = 24\n    ///\n    /// For f64, this follows as:\n    ///     emin = -1022\n    ///     p2 = 53\n    ///\n    /// In Python:\n    ///     `-emin + p2 + math.floor((emin+1)*math.log(2, b) - math.log(1-2**(-p2), b))`\n    ///\n    /// This was used to calculate the maximum number of digits for [2, 36].\n    const MAX_DIGITS: usize;\n\n    // MASKS\n\n    /// Bitmask for the exponent, including the hidden bit.\n    const EXPONENT_MASK: Self::Unsigned;\n    /// Bitmask for the hidden bit in exponent, which is an implicit 1 in the fraction.\n    const HIDDEN_BIT_MASK: Self::Unsigned;\n    /// Bitmask for the mantissa (fraction), excluding the hidden bit.\n    const MANTISSA_MASK: Self::Unsigned;\n\n    // PROPERTIES\n\n    /// Positive infinity as bits.\n    const INFINITY_BITS: Self::Unsigned;\n    /// Size of the significand (mantissa) without hidden bit.\n    const MANTISSA_SIZE: i32;\n    /// Bias of the exponent\n    const EXPONENT_BIAS: i32;\n    /// Exponent portion of a denormal float.\n    const DENORMAL_EXPONENT: i32;\n    /// Maximum exponent value in float.\n    const MAX_EXPONENT: i32;\n\n    // ROUNDING\n\n    /// Default number of bits to shift (or 64 - mantissa size - 1).\n    const DEFAULT_SHIFT: i32;\n    /// Mask to determine if a full-carry occurred (1 in bit above hidden bit).\n    const CARRY_MASK: u64;\n\n    /// Get min and max exponent limits (exact) from radix.\n    fn exponent_limit() -> (i32, i32);\n\n    /// Get the number of digits that can be shifted from exponent to mantissa.\n    fn mantissa_limit() -> i32;\n\n    // Re-exported methods from std.\n    fn pow10(self, n: i32) -> Self;\n    fn from_bits(u: Self::Unsigned) -> Self;\n    fn to_bits(self) -> Self::Unsigned;\n    fn is_sign_positive(self) -> bool;\n\n    /// Returns true if the float is a denormal.\n    #[inline]\n    fn is_denormal(self) -> bool {\n        self.to_bits() & Self::EXPONENT_MASK == Self::Unsigned::ZERO\n    }\n\n    /// Returns true if the float is a NaN or Infinite.\n    #[inline]\n    fn is_special(self) -> bool {\n        self.to_bits() & Self::EXPONENT_MASK == Self::EXPONENT_MASK\n    }\n\n    /// Returns true if the float is infinite.\n    #[inline]\n    fn is_inf(self) -> bool {\n        self.is_special() && (self.to_bits() & Self::MANTISSA_MASK) == Self::Unsigned::ZERO\n    }\n\n    /// Get exponent component from the float.\n    #[inline]\n    fn exponent(self) -> i32 {\n        if self.is_denormal() {\n            return Self::DENORMAL_EXPONENT;\n        }\n\n        let bits = self.to_bits();\n        let biased_e = ((bits & Self::EXPONENT_MASK) >> Self::MANTISSA_SIZE).as_u32();\n        biased_e as i32 - Self::EXPONENT_BIAS\n    }\n\n    /// Get mantissa (significand) component from float.\n    #[inline]\n    fn mantissa(self) -> Self::Unsigned {\n        let bits = self.to_bits();\n        let s = bits & Self::MANTISSA_MASK;\n        if !self.is_denormal() {\n            s + Self::HIDDEN_BIT_MASK\n        } else {\n            s\n        }\n    }\n\n    /// Get next greater float for a positive float.\n    /// Value must be >= 0.0 and < INFINITY.\n    #[inline]\n    fn next_positive(self) -> Self {\n        debug_assert!(self.is_sign_positive() && !self.is_inf());\n        Self::from_bits(self.to_bits() + Self::Unsigned::as_cast(1u32))\n    }\n\n    /// Round a positive number to even.\n    #[inline]\n    fn round_positive_even(self) -> Self {\n        if self.mantissa() & Self::Unsigned::as_cast(1u32) == Self::Unsigned::as_cast(1u32) {\n            self.next_positive()\n        } else {\n            self\n        }\n    }\n}\n\nimpl Float for f32 {\n    type Unsigned = u32;\n\n    const ZERO: f32 = 0.0;\n    const MAX_DIGITS: usize = 114;\n    const EXPONENT_MASK: u32 = 0x7F800000;\n    const HIDDEN_BIT_MASK: u32 = 0x00800000;\n    const MANTISSA_MASK: u32 = 0x007FFFFF;\n    const INFINITY_BITS: u32 = 0x7F800000;\n    const MANTISSA_SIZE: i32 = 23;\n    const EXPONENT_BIAS: i32 = 127 + Self::MANTISSA_SIZE;\n    const DENORMAL_EXPONENT: i32 = 1 - Self::EXPONENT_BIAS;\n    const MAX_EXPONENT: i32 = 0xFF - Self::EXPONENT_BIAS;\n    const DEFAULT_SHIFT: i32 = u64::FULL - f32::MANTISSA_SIZE - 1;\n    const CARRY_MASK: u64 = 0x1000000;\n\n    #[inline]\n    fn exponent_limit() -> (i32, i32) {\n        (-10, 10)\n    }\n\n    #[inline]\n    fn mantissa_limit() -> i32 {\n        7\n    }\n\n    #[inline]\n    fn pow10(self, n: i32) -> f32 {\n        // Check the exponent is within bounds in debug builds.\n        debug_assert!({\n            let (min, max) = Self::exponent_limit();\n            n >= min && n <= max\n        });\n\n        if n > 0 {\n            self * F32_POW10[n as usize]\n        } else {\n            self / F32_POW10[-n as usize]\n        }\n    }\n\n    #[inline]\n    fn from_bits(u: u32) -> f32 {\n        f32::from_bits(u)\n    }\n\n    #[inline]\n    fn to_bits(self) -> u32 {\n        f32::to_bits(self)\n    }\n\n    #[inline]\n    fn is_sign_positive(self) -> bool {\n        f32::is_sign_positive(self)\n    }\n}\n\nimpl Float for f64 {\n    type Unsigned = u64;\n\n    const ZERO: f64 = 0.0;\n    const MAX_DIGITS: usize = 769;\n    const EXPONENT_MASK: u64 = 0x7FF0000000000000;\n    const HIDDEN_BIT_MASK: u64 = 0x0010000000000000;\n    const MANTISSA_MASK: u64 = 0x000FFFFFFFFFFFFF;\n    const INFINITY_BITS: u64 = 0x7FF0000000000000;\n    const MANTISSA_SIZE: i32 = 52;\n    const EXPONENT_BIAS: i32 = 1023 + Self::MANTISSA_SIZE;\n    const DENORMAL_EXPONENT: i32 = 1 - Self::EXPONENT_BIAS;\n    const MAX_EXPONENT: i32 = 0x7FF - Self::EXPONENT_BIAS;\n    const DEFAULT_SHIFT: i32 = u64::FULL - f64::MANTISSA_SIZE - 1;\n    const CARRY_MASK: u64 = 0x20000000000000;\n\n    #[inline]\n    fn exponent_limit() -> (i32, i32) {\n        (-22, 22)\n    }\n\n    #[inline]\n    fn mantissa_limit() -> i32 {\n        15\n    }\n\n    #[inline]\n    fn pow10(self, n: i32) -> f64 {\n        // Check the exponent is within bounds in debug builds.\n        debug_assert!({\n            let (min, max) = Self::exponent_limit();\n            n >= min && n <= max\n        });\n\n        if n > 0 {\n            self * F64_POW10[n as usize]\n        } else {\n            self / F64_POW10[-n as usize]\n        }\n    }\n\n    #[inline]\n    fn from_bits(u: u64) -> f64 {\n        f64::from_bits(u)\n    }\n\n    #[inline]\n    fn to_bits(self) -> u64 {\n        f64::to_bits(self)\n    }\n\n    #[inline]\n    fn is_sign_positive(self) -> bool {\n        f64::is_sign_positive(self)\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "320d03d2e61ea23416a02b40efdea3b657acbb20",
    "func": "use std::{io, marker::PhantomData, mem::MaybeUninit, task::Poll};\n\nuse actix_codec::Decoder;\nuse bytes::{Bytes, BytesMut};\nuse http::{\n    header::{self, HeaderName, HeaderValue},\n    Method, StatusCode, Uri, Version,\n};\nuse tracing::{debug, error, trace};\n\nuse super::chunked::ChunkedState;\nuse crate::{error::ParseError, header::HeaderMap, ConnectionType, Request, ResponseHead};\n\npub(crate) const MAX_BUFFER_SIZE: usize = 131_072;\nconst MAX_HEADERS: usize = 96;\n\n/// Incoming message decoder\npub(crate) struct MessageDecoder<T: MessageType>(PhantomData<T>);\n\n#[derive(Debug)]\n/// Incoming request type\npub(crate) enum PayloadType {\n    None,\n    Payload(PayloadDecoder),\n    Stream(PayloadDecoder),\n}\n\nimpl<T: MessageType> Default for MessageDecoder<T> {\n    fn default() -> Self {\n        MessageDecoder(PhantomData)\n    }\n}\n\nimpl<T: MessageType> Decoder for MessageDecoder<T> {\n    type Item = (T, PayloadType);\n    type Error = ParseError;\n\n    fn decode(&mut self, src: &mut BytesMut) -> Result<Option<Self::Item>, Self::Error> {\n        T::decode(src)\n    }\n}\n\npub(crate) enum PayloadLength {\n    Payload(PayloadType),\n    UpgradeWebSocket,\n    None,\n}\n\nimpl PayloadLength {\n    /// Returns true if variant is `None`.\n    fn is_none(&self) -> bool {\n        matches!(self, Self::None)\n    }\n\n    /// Returns true if variant is represents zero-length (not none) payload.\n    fn is_zero(&self) -> bool {\n        matches!(\n            self,\n            PayloadLength::Payload(PayloadType::Payload(PayloadDecoder {\n                kind: Kind::Length(0)\n            }))\n        )\n    }\n}\n\npub(crate) trait MessageType: Sized {\n    fn set_connection_type(&mut self, conn_type: Option<ConnectionType>);\n\n    fn set_expect(&mut self);\n\n    fn headers_mut(&mut self) -> &mut HeaderMap;\n\n    fn decode(src: &mut BytesMut) -> Result<Option<(Self, PayloadType)>, ParseError>;\n\n    fn set_headers(\n        &mut self,\n        slice: &Bytes,\n        raw_headers: &[HeaderIndex],\n        version: Version,\n    ) -> Result<PayloadLength, ParseError> {\n        let mut ka = None;\n        let mut has_upgrade_websocket = false;\n        let mut expect = false;\n        let mut chunked = false;\n        let mut seen_te = false;\n        let mut content_length = None;\n\n        {\n            let headers = self.headers_mut();\n\n            for idx in raw_headers.iter() {\n                let name = HeaderName::from_bytes(&slice[idx.name.0..idx.name.1]).unwrap();\n\n                // SAFETY: httparse already checks header value is only visible ASCII bytes\n                // from_maybe_shared_unchecked contains debug assertions so they are omitted here\n                let value = unsafe {\n                    HeaderValue::from_maybe_shared_unchecked(slice.slice(idx.value.0..idx.value.1))\n                };\n\n                match name {\n                    header::CONTENT_LENGTH if content_length.is_some() => {\n                        debug!(\"multiple Content-Length\");\n                        return Err(ParseError::Header);\n                    }\n\n                    header::CONTENT_LENGTH => match value.to_str().map(str::trim) {\n                        Ok(val) if val.starts_with('+') => {\n                            debug!(\"illegal Content-Length: {:?}\", val);\n                            return Err(ParseError::Header);\n                        }\n\n                        Ok(val) => {\n                            if let Ok(len) = val.parse::<u64>() {\n                                // accept 0 lengths here and remove them in `decode` after all\n                                // headers have been processed to prevent request smuggling issues\n                                content_length = Some(len);\n                            } else {\n                                debug!(\"illegal Content-Length: {:?}\", val);\n                                return Err(ParseError::Header);\n                            }\n                        }\n\n                        Err(_) => {\n                            debug!(\"illegal Content-Length: {:?}\", value);\n                            return Err(ParseError::Header);\n                        }\n                    },\n\n                    // transfer-encoding\n                    header::TRANSFER_ENCODING if seen_te => {\n                        debug!(\"multiple Transfer-Encoding not allowed\");\n                        return Err(ParseError::Header);\n                    }\n\n                    header::TRANSFER_ENCODING if version == Version::HTTP_11 => {\n                        seen_te = true;\n\n                        if let Ok(val) = value.to_str().map(str::trim) {\n                            if val.eq_ignore_ascii_case(\"chunked\") {\n                                chunked = true;\n                            } else if val.eq_ignore_ascii_case(\"identity\") {\n                                // allow silently since multiple TE headers are already checked\n                            } else {\n                                debug!(\"illegal Transfer-Encoding: {:?}\", val);\n                                return Err(ParseError::Header);\n                            }\n                        } else {\n                            return Err(ParseError::Header);\n                        }\n                    }\n\n                    // connection keep-alive state\n                    header::CONNECTION => {\n                        ka = if let Ok(conn) = value.to_str().map(str::trim) {\n                            if conn.eq_ignore_ascii_case(\"keep-alive\") {\n                                Some(ConnectionType::KeepAlive)\n                            } else if conn.eq_ignore_ascii_case(\"close\") {\n                                Some(ConnectionType::Close)\n                            } else if conn.eq_ignore_ascii_case(\"upgrade\") {\n                                Some(ConnectionType::Upgrade)\n                            } else {\n                                None\n                            }\n                        } else {\n                            None\n                        };\n                    }\n\n                    header::UPGRADE => {\n                        if let Ok(val) = value.to_str().map(str::trim) {\n                            if val.eq_ignore_ascii_case(\"websocket\") {\n                                has_upgrade_websocket = true;\n                            }\n                        }\n                    }\n\n                    header::EXPECT => {\n                        let bytes = value.as_bytes();\n                        if bytes.len() >= 4 && &bytes[0..4] == b\"100-\" {\n                            expect = true;\n                        }\n                    }\n\n                    _ => {}\n                }\n\n                headers.append(name, value);\n            }\n        }\n\n        self.set_connection_type(ka);\n\n        if expect {\n            self.set_expect()\n        }\n\n        // https://datatracker.ietf.org/doc/html/rfc7230#section-3.3.3\n        if chunked {\n            // Chunked encoding\n            Ok(PayloadLength::Payload(PayloadType::Payload(\n                PayloadDecoder::chunked(),\n            )))\n        } else if has_upgrade_websocket {\n            Ok(PayloadLength::UpgradeWebSocket)\n        } else if let Some(len) = content_length {\n            // Content-Length\n            Ok(PayloadLength::Payload(PayloadType::Payload(\n                PayloadDecoder::length(len),\n            )))\n        } else {\n            Ok(PayloadLength::None)\n        }\n    }\n}\n\nimpl MessageType for Request {\n    fn set_connection_type(&mut self, conn_type: Option<ConnectionType>) {\n        if let Some(ctype) = conn_type {\n            self.head_mut().set_connection_type(ctype);\n        }\n    }\n\n    fn set_expect(&mut self) {\n        self.head_mut().set_expect();\n    }\n\n    fn headers_mut(&mut self) -> &mut HeaderMap {\n        &mut self.head_mut().headers\n    }\n\n    fn decode(src: &mut BytesMut) -> Result<Option<(Self, PayloadType)>, ParseError> {\n        let mut headers: [HeaderIndex; MAX_HEADERS] = EMPTY_HEADER_INDEX_ARRAY;\n\n        let (len, method, uri, ver, h_len) = {\n            // SAFETY:\n            // Create an uninitialized array of `MaybeUninit`. The `assume_init` is safe because the\n            // type we are claiming to have initialized here is a bunch of `MaybeUninit`s, which\n            // do not require initialization.\n            let mut parsed = unsafe {\n                MaybeUninit::<[MaybeUninit<httparse::Header<'_>>; MAX_HEADERS]>::uninit()\n                    .assume_init()\n            };\n\n            let mut req = httparse::Request::new(&mut []);\n\n            match req.parse_with_uninit_headers(src, &mut parsed)? {\n                httparse::Status::Complete(len) => {\n                    let method = Method::from_bytes(req.method.unwrap().as_bytes())\n                        .map_err(|_| ParseError::Method)?;\n                    let uri = Uri::try_from(req.path.unwrap())?;\n                    let version = if req.version.unwrap() == 1 {\n                        Version::HTTP_11\n                    } else {\n                        Version::HTTP_10\n                    };\n                    HeaderIndex::record(src, req.headers, &mut headers);\n\n                    (len, method, uri, version, req.headers.len())\n                }\n\n                httparse::Status::Partial => {\n                    return if src.len() >= MAX_BUFFER_SIZE {\n                        trace!(\"MAX_BUFFER_SIZE unprocessed data reached, closing\");\n                        Err(ParseError::TooLarge)\n                    } else {\n                        // Return None to notify more read are needed for parsing request\n                        Ok(None)\n                    };\n                }\n            }\n        };\n\n        let mut msg = Request::new();\n\n        // convert headers\n        let mut length = msg.set_headers(&src.split_to(len).freeze(), &headers[..h_len], ver)?;\n\n        // disallow HTTP/1.0 POST requests that do not contain a Content-Length headers\n        // see https://datatracker.ietf.org/doc/html/rfc1945#section-7.2.2\n        if ver == Version::HTTP_10 && method == Method::POST && length.is_none() {\n            debug!(\"no Content-Length specified for HTTP/1.0 POST request\");\n            return Err(ParseError::Header);\n        }\n\n        // Remove CL value if 0 now that all headers and HTTP/1.0 special cases are processed.\n        // Protects against some request smuggling attacks.\n        // See https://github.com/actix/actix-web/issues/2767.\n        if length.is_zero() {\n            length = PayloadLength::None;\n        }\n\n        // payload decoder\n        let decoder = match length {\n            PayloadLength::Payload(pl) => pl,\n            PayloadLength::UpgradeWebSocket => {\n                // upgrade (WebSocket)\n                PayloadType::Stream(PayloadDecoder::eof())\n            }\n            PayloadLength::None => {\n                if method == Method::CONNECT {\n                    PayloadType::Stream(PayloadDecoder::eof())\n                } else {\n                    PayloadType::None\n                }\n            }\n        };\n\n        let head = msg.head_mut();\n        head.uri = uri;\n        head.method = method;\n        head.version = ver;\n\n        Ok(Some((msg, decoder)))\n    }\n}\n\nimpl MessageType for ResponseHead {\n    fn set_connection_type(&mut self, conn_type: Option<ConnectionType>) {\n        if let Some(ctype) = conn_type {\n            ResponseHead::set_connection_type(self, ctype);\n        }\n    }\n\n    fn set_expect(&mut self) {}\n\n    fn headers_mut(&mut self) -> &mut HeaderMap {\n        &mut self.headers\n    }\n\n    fn decode(src: &mut BytesMut) -> Result<Option<(Self, PayloadType)>, ParseError> {\n        let mut headers: [HeaderIndex; MAX_HEADERS] = EMPTY_HEADER_INDEX_ARRAY;\n\n        let (len, ver, status, h_len) = {\n            // SAFETY:\n            // Create an uninitialized array of `MaybeUninit`. The `assume_init` is safe because the\n            // type we are claiming to have initialized here is a bunch of `MaybeUninit`s, which\n            // do not require initialization.\n            let mut parsed = unsafe {\n                MaybeUninit::<[MaybeUninit<httparse::Header<'_>>; MAX_HEADERS]>::uninit()\n                    .assume_init()\n            };\n\n            let mut res = httparse::Response::new(&mut []);\n\n            let mut config = httparse::ParserConfig::default();\n            config.allow_spaces_after_header_name_in_responses(true);\n\n            match config.parse_response_with_uninit_headers(&mut res, src, &mut parsed)? {\n                httparse::Status::Complete(len) => {\n                    let version = if res.version.unwrap() == 1 {\n                        Version::HTTP_11\n                    } else {\n                        Version::HTTP_10\n                    };\n\n                    let status =\n                        StatusCode::from_u16(res.code.unwrap()).map_err(|_| ParseError::Status)?;\n                    HeaderIndex::record(src, res.headers, &mut headers);\n\n                    (len, version, status, res.headers.len())\n                }\n\n                httparse::Status::Partial => {\n                    return if src.len() >= MAX_BUFFER_SIZE {\n                        error!(\"MAX_BUFFER_SIZE unprocessed data reached, closing\");\n                        Err(ParseError::TooLarge)\n                    } else {\n                        Ok(None)\n                    }\n                }\n            }\n        };\n\n        let mut msg = ResponseHead::new(status);\n        msg.version = ver;\n\n        // convert headers\n        let mut length = msg.set_headers(&src.split_to(len).freeze(), &headers[..h_len], ver)?;\n\n        // Remove CL value if 0 now that all headers and HTTP/1.0 special cases are processed.\n        // Protects against some request smuggling attacks.\n        // See https://github.com/actix/actix-web/issues/2767.\n        if length.is_zero() {\n            length = PayloadLength::None;\n        }\n\n        // message payload\n        let decoder = if let PayloadLength::Payload(pl) = length {\n            pl\n        } else if status == StatusCode::SWITCHING_PROTOCOLS {\n            // switching protocol or connect\n            PayloadType::Stream(PayloadDecoder::eof())\n        } else {\n            // for HTTP/1.0 read to eof and close connection\n            if msg.version == Version::HTTP_10 {\n                msg.set_connection_type(ConnectionType::Close);\n                PayloadType::Payload(PayloadDecoder::eof())\n            } else {\n                PayloadType::None\n            }\n        };\n\n        Ok(Some((msg, decoder)))\n    }\n}\n\n#[derive(Clone, Copy)]\npub(crate) struct HeaderIndex {\n    pub(crate) name: (usize, usize),\n    pub(crate) value: (usize, usize),\n}\n\npub(crate) const EMPTY_HEADER_INDEX: HeaderIndex = HeaderIndex {\n    name: (0, 0),\n    value: (0, 0),\n};\n\npub(crate) const EMPTY_HEADER_INDEX_ARRAY: [HeaderIndex; MAX_HEADERS] =\n    [EMPTY_HEADER_INDEX; MAX_HEADERS];\n\nimpl HeaderIndex {\n    pub(crate) fn record(\n        bytes: &[u8],\n        headers: &[httparse::Header<'_>],\n        indices: &mut [HeaderIndex],\n    ) {\n        let bytes_ptr = bytes.as_ptr() as usize;\n        for (header, indices) in headers.iter().zip(indices.iter_mut()) {\n            let name_start = header.name.as_ptr() as usize - bytes_ptr;\n            let name_end = name_start + header.name.len();\n            indices.name = (name_start, name_end);\n            let value_start = header.value.as_ptr() as usize - bytes_ptr;\n            let value_end = value_start + header.value.len();\n            indices.value = (value_start, value_end);\n        }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\n/// Chunk type yielded while decoding a payload.\npub enum PayloadItem {\n    Chunk(Bytes),\n    Eof,\n}\n\n/// Decoder that can handle different payload types.\n///\n/// If a message body does not use `Transfer-Encoding`, it should include a `Content-Length`.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct PayloadDecoder {\n    kind: Kind,\n}\n\nimpl PayloadDecoder {\n    /// Constructs a fixed-length payload decoder.\n    pub fn length(x: u64) -> PayloadDecoder {\n        PayloadDecoder {\n            kind: Kind::Length(x),\n        }\n    }\n\n    /// Constructs a chunked encoding decoder.\n    pub fn chunked() -> PayloadDecoder {\n        PayloadDecoder {\n            kind: Kind::Chunked(ChunkedState::Size, 0),\n        }\n    }\n\n    /// Creates an decoder that yields chunks until the stream returns EOF.\n    pub fn eof() -> PayloadDecoder {\n        PayloadDecoder { kind: Kind::Eof }\n    }\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\nenum Kind {\n    /// A reader used when a `Content-Length` header is passed with a positive integer.\n    Length(u64),\n\n    /// A reader used when `Transfer-Encoding` is `chunked`.\n    Chunked(ChunkedState, u64),\n\n    /// A reader used for responses that don't indicate a length or chunked.\n    ///\n    /// Note: This should only used for `Response`s. It is illegal for a `Request` to be made\n    /// without either of `Content-Length` and `Transfer-Encoding: chunked` missing, as explained\n    /// in [RFC 7230 \u00a73.3.3]:\n    ///\n    /// > If a Transfer-Encoding header field is present in a response and the chunked transfer\n    /// > coding is not the final encoding, the message body length is determined by reading the\n    /// > connection until it is closed by the server. If a Transfer-Encoding header field is\n    /// > present in a request and the chunked transfer coding is not the final encoding, the\n    /// > message body length cannot be determined reliably; the server MUST respond with the 400\n    /// > (Bad Request) status code and then close the connection.\n    ///\n    /// [RFC 7230 \u00a73.3.3]: https://datatracker.ietf.org/doc/html/rfc7230#section-3.3.3\n    Eof,\n}\n\nimpl Decoder for PayloadDecoder {\n    type Item = PayloadItem;\n    type Error = io::Error;\n\n    fn decode(&mut self, src: &mut BytesMut) -> Result<Option<Self::Item>, Self::Error> {\n        match self.kind {\n            Kind::Length(ref mut remaining) => {\n                if *remaining == 0 {\n                    Ok(Some(PayloadItem::Eof))\n                } else {\n                    if src.is_empty() {\n                        return Ok(None);\n                    }\n                    let len = src.len() as u64;\n                    let buf;\n                    if *remaining > len {\n                        buf = src.split().freeze();\n                        *remaining -= len;\n                    } else {\n                        buf = src.split_to(*remaining as usize).freeze();\n                        *remaining = 0;\n                    };\n                    trace!(\"Length read: {}\", buf.len());\n                    Ok(Some(PayloadItem::Chunk(buf)))\n                }\n            }\n\n            Kind::Chunked(ref mut state, ref mut size) => {\n                loop {\n                    let mut buf = None;\n\n                    // advances the chunked state\n                    *state = match state.step(src, size, &mut buf) {\n                        Poll::Pending => return Ok(None),\n                        Poll::Ready(Ok(state)) => state,\n                        Poll::Ready(Err(err)) => return Err(err),\n                    };\n\n                    if *state == ChunkedState::End {\n                        trace!(\"End of chunked stream\");\n                        return Ok(Some(PayloadItem::Eof));\n                    }\n\n                    if let Some(buf) = buf {\n                        return Ok(Some(PayloadItem::Chunk(buf)));\n                    }\n\n                    if src.is_empty() {\n                        return Ok(None);\n                    }\n                }\n            }\n\n            Kind::Eof => {\n                if src.is_empty() {\n                    Ok(None)\n                } else {\n                    Ok(Some(PayloadItem::Chunk(src.split().freeze())))\n                }\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{header::SET_COOKIE, HttpMessage as _};\n\n    impl PayloadType {\n        pub(crate) fn unwrap(self) -> PayloadDecoder {\n            match self {\n                PayloadType::Payload(pl) => pl,\n                _ => panic!(),\n            }\n        }\n\n        pub(crate) fn is_unhandled(&self) -> bool {\n            matches!(self, PayloadType::Stream(_))\n        }\n    }\n\n    impl PayloadItem {\n        pub(crate) fn chunk(self) -> Bytes {\n            match self {\n                PayloadItem::Chunk(chunk) => chunk,\n                _ => panic!(\"error\"),\n            }\n        }\n\n        pub(crate) fn eof(&self) -> bool {\n            matches!(*self, PayloadItem::Eof)\n        }\n    }\n\n    macro_rules! parse_ready {\n        ($e:expr) => {{\n            match MessageDecoder::<Request>::default().decode($e) {\n                Ok(Some((msg, _))) => msg,\n                Ok(_) => unreachable!(\"Eof during parsing http request\"),\n                Err(err) => unreachable!(\"Error during parsing http request: {:?}\", err),\n            }\n        }};\n    }\n\n    macro_rules! expect_parse_err {\n        ($e:expr) => {{\n            match MessageDecoder::<Request>::default().decode($e) {\n                Err(err) => match err {\n                    ParseError::Io(_) => unreachable!(\"Parse error expected\"),\n                    _ => {}\n                },\n                _ => unreachable!(\"Error expected\"),\n            }\n        }};\n    }\n\n    #[test]\n    fn test_parse() {\n        let mut buf = BytesMut::from(\"GET /test HTTP/1.1\\r\\n\\r\\n\");\n\n        let mut reader = MessageDecoder::<Request>::default();\n        match reader.decode(&mut buf) {\n            Ok(Some((req, _))) => {\n                assert_eq!(req.version(), Version::HTTP_11);\n                assert_eq!(*req.method(), Method::GET);\n                assert_eq!(req.path(), \"/test\");\n            }\n            Ok(_) | Err(_) => unreachable!(\"Error during parsing http request\"),\n        }\n    }\n\n    #[test]\n    fn test_parse_partial() {\n        let mut buf = BytesMut::from(\"PUT /test HTTP/1\");\n\n        let mut reader = MessageDecoder::<Request>::default();\n        assert!(reader.decode(&mut buf).unwrap().is_none());\n\n        buf.extend(b\".1\\r\\n\\r\\n\");\n        let (req, _) = reader.decode(&mut buf).unwrap().unwrap();\n        assert_eq!(req.version(), Version::HTTP_11);\n        assert_eq!(*req.method(), Method::PUT);\n        assert_eq!(req.path(), \"/test\");\n    }\n\n    #[test]\n    fn parse_h09_reject() {\n        let mut buf = BytesMut::from(\n            \"GET /test1 HTTP/0.9\\r\\n\\\n            \\r\\n\",\n        );\n\n        let mut reader = MessageDecoder::<Request>::default();\n        reader.decode(&mut buf).unwrap_err();\n\n        let mut buf = BytesMut::from(\n            \"POST /test2 HTTP/0.9\\r\\n\\\n            Content-Length: 3\\r\\n\\\n            \\r\\n\n            abc\",\n        );\n\n        let mut reader = MessageDecoder::<Request>::default();\n        reader.decode(&mut buf).unwrap_err();\n    }\n\n    #[test]\n    fn parse_h10_get() {\n        let mut buf = BytesMut::from(\n            \"GET /test1 HTTP/1.0\\r\\n\\\n            \\r\\n\",\n        );\n\n        let mut reader = MessageDecoder::<Request>::default();\n        let (req, _) = reader.decode(&mut buf).unwrap().unwrap();\n        assert_eq!(req.version(), Version::HTTP_10);\n        assert_eq!(*req.method(), Method::GET);\n        assert_eq!(req.path(), \"/test1\");\n\n        let mut buf = BytesMut::from(\n            \"GET /test2 HTTP/1.0\\r\\n\\\n            Content-Length: 0\\r\\n\\\n            \\r\\n\",\n        );\n\n        let mut reader = MessageDecoder::<Request>::default();\n        let (req, _) = reader.decode(&mut buf).unwrap().unwrap();\n        assert_eq!(req.version(), Version::HTTP_10);\n        assert_eq!(*req.method(), Method::GET);\n        assert_eq!(req.path(), \"/test2\");\n\n        let mut buf = BytesMut::from(\n            \"GET /test3 HTTP/1.0\\r\\n\\\n            Content-Length: 3\\r\\n\\\n            \\r\\n\n            abc\",\n        );\n\n        let mut reader = MessageDecoder::<Request>::default();\n        let (req, _) = reader.decode(&mut buf).unwrap().unwrap();\n        assert_eq!(req.version(), Version::HTTP_10);\n        assert_eq!(*req.method(), Method::GET);\n        assert_eq!(req.path(), \"/test3\");\n    }\n\n    #[test]\n    fn parse_h10_post() {\n        let mut buf = BytesMut::from(\n            \"POST /test1 HTTP/1.0\\r\\n\\\n            Content-Length: 3\\r\\n\\\n            \\r\\n\\\n            abc\",\n        );\n\n        let mut reader = MessageDecoder::<Request>::default();\n        let (req, _) = reader.decode(&mut buf).unwrap().unwrap();\n        assert_eq!(req.version(), Version::HTTP_10);\n        assert_eq!(*req.method(), Method::POST);\n        assert_eq!(req.path(), \"/test1\");\n\n        let mut buf = BytesMut::from(\n            \"POST /test2 HTTP/1.0\\r\\n\\\n            Content-Length: 0\\r\\n\\\n            \\r\\n\",\n        );\n\n        let mut reader = MessageDecoder::<Request>::default();\n        let (req, _) = reader.decode(&mut buf).unwrap().unwrap();\n        assert_eq!(req.version(), Version::HTTP_10);\n        assert_eq!(*req.method(), Method::POST);\n        assert_eq!(req.path(), \"/test2\");\n\n        let mut buf = BytesMut::from(\n            \"POST /test3 HTTP/1.0\\r\\n\\\n            \\r\\n\",\n        );\n\n        let mut reader = MessageDecoder::<Request>::default();\n        let err = reader.decode(&mut buf).unwrap_err();\n        assert!(err.to_string().contains(\"Header\"))\n    }\n\n    #[test]\n    fn test_parse_body() {\n        let mut buf = BytesMut::from(\"GET /test HTTP/1.1\\r\\nContent-Length: 4\\r\\n\\r\\nbody\");\n\n        let mut reader = MessageDecoder::<Request>::default();\n        let (req, pl) = reader.decode(&mut buf).unwrap().unwrap();\n        let mut pl = pl.unwrap();\n        assert_eq!(req.version(), Version::HTTP_11);\n        assert_eq!(*req.method(), Method::GET);\n        assert_eq!(req.path(), \"/test\");\n        assert_eq!(\n            pl.decode(&mut buf).unwrap().unwrap().chunk().as_ref(),\n            b\"body\"\n        );\n    }\n\n    #[test]\n    fn test_parse_body_crlf() {\n        let mut buf = BytesMut::from(\"\\r\\nGET /test HTTP/1.1\\r\\nContent-Length: 4\\r\\n\\r\\nbody\");\n\n        let mut reader = MessageDecoder::<Request>::default();\n        let (req, pl) = reader.decode(&mut buf).unwrap().unwrap();\n        let mut pl = pl.unwrap();\n        assert_eq!(req.version(), Version::HTTP_11);\n        assert_eq!(*req.method(), Method::GET);\n        assert_eq!(req.path(), \"/test\");\n        assert_eq!(\n            pl.decode(&mut buf).unwrap().unwrap().chunk().as_ref(),\n            b\"body\"\n        );\n    }\n\n    #[test]\n    fn test_parse_partial_eof() {\n        let mut buf = BytesMut::from(\"GET /test HTTP/1.1\\r\\n\");\n        let mut reader = MessageDecoder::<Request>::default();\n        assert!(reader.decode(&mut buf).unwrap().is_none());\n\n        buf.extend(b\"\\r\\n\");\n        let (req, _) = reader.decode(&mut buf).unwrap().unwrap();\n        assert_eq!(req.version(), Version::HTTP_11);\n        assert_eq!(*req.method(), Method::GET);\n        assert_eq!(req.path(), \"/test\");\n    }\n\n    #[test]\n    fn test_headers_split_field() {\n        let mut buf = BytesMut::from(\"GET /test HTTP/1.1\\r\\n\");\n\n        let mut reader = MessageDecoder::<Request>::default();\n        assert! { reader.decode(&mut buf).unwrap().is_none() }\n\n        buf.extend(b\"t\");\n        assert! { reader.decode(&mut buf).unwrap().is_none() }\n\n        buf.extend(b\"es\");\n        assert! { reader.decode(&mut buf).unwrap().is_none() }\n\n        buf.extend(b\"t: value\\r\\n\\r\\n\");\n        let (req, _) = reader.decode(&mut buf).unwrap().unwrap();\n        assert_eq!(req.version(), Version::HTTP_11);\n        assert_eq!(*req.method(), Method::GET);\n        assert_eq!(req.path(), \"/test\");\n        assert_eq!(\n            req.headers()\n                .get(HeaderName::try_from(\"test\").unwrap())\n                .unwrap()\n                .as_bytes(),\n            b\"value\"\n        );\n    }\n\n    #[test]\n    fn test_headers_multi_value() {\n        let mut buf = BytesMut::from(\n            \"GET /test HTTP/1.1\\r\\n\\\n             Set-Cookie: c1=cookie1\\r\\n\\\n             Set-Cookie: c2=cookie2\\r\\n\\r\\n\",\n        );\n        let mut reader = MessageDecoder::<Request>::default();\n        let (req, _) = reader.decode(&mut buf).unwrap().unwrap();\n\n        let val: Vec<_> = req\n            .headers()\n            .get_all(SET_COOKIE)\n            .map(|v| v.to_str().unwrap().to_owned())\n            .collect();\n        assert_eq!(val[0], \"c1=cookie1\");\n        assert_eq!(val[1], \"c2=cookie2\");\n    }\n\n    #[test]\n    fn test_conn_default_1_0() {\n        let req = parse_ready!(&mut BytesMut::from(\"GET /test HTTP/1.0\\r\\n\\r\\n\"));\n        assert_eq!(req.head().connection_type(), ConnectionType::Close);\n    }\n\n    #[test]\n    fn test_conn_default_1_1() {\n        let req = parse_ready!(&mut BytesMut::from(\"GET /test HTTP/1.1\\r\\n\\r\\n\"));\n        assert_eq!(req.head().connection_type(), ConnectionType::KeepAlive);\n    }\n\n    #[test]\n    fn test_conn_close() {\n        let req = parse_ready!(&mut BytesMut::from(\n            \"GET /test HTTP/1.1\\r\\n\\\n             connection: close\\r\\n\\r\\n\",\n        ));\n        assert_eq!(req.head().connection_type(), ConnectionType::Close);\n\n        let req = parse_ready!(&mut BytesMut::from(\n            \"GET /test HTTP/1.1\\r\\n\\\n             connection: Close\\r\\n\\r\\n\",\n        ));\n        assert_eq!(req.head().connection_type(), ConnectionType::Close);\n    }\n\n    #[test]\n    fn test_conn_close_1_0() {\n        let req = parse_ready!(&mut BytesMut::from(\n            \"GET /test HTTP/1.0\\r\\n\\\n             connection: close\\r\\n\\r\\n\",\n        ));\n        assert_eq!(req.head().connection_type(), ConnectionType::Close);\n    }\n\n    #[test]\n    fn test_conn_keep_alive_1_0() {\n        let req = parse_ready!(&mut BytesMut::from(\n            \"GET /test HTTP/1.0\\r\\n\\\n             connection: keep-alive\\r\\n\\r\\n\",\n        ));\n        assert_eq!(req.head().connection_type(), ConnectionType::KeepAlive);\n\n        let req = parse_ready!(&mut BytesMut::from(\n            \"GET /test HTTP/1.0\\r\\n\\\n             connection: Keep-Alive\\r\\n\\r\\n\",\n        ));\n        assert_eq!(req.head().connection_type(), ConnectionType::KeepAlive);\n    }\n\n    #[test]\n    fn test_conn_keep_alive_1_1() {\n        let req = parse_ready!(&mut BytesMut::from(\n            \"GET /test HTTP/1.1\\r\\n\\\n             connection: keep-alive\\r\\n\\r\\n\",\n        ));\n        assert_eq!(req.head().connection_type(), ConnectionType::KeepAlive);\n    }\n\n    #[test]\n    fn test_conn_other_1_0() {\n        let req = parse_ready!(&mut BytesMut::from(\n            \"GET /test HTTP/1.0\\r\\n\\\n             connection: other\\r\\n\\r\\n\",\n        ));\n        assert_eq!(req.head().connection_type(), ConnectionType::Close);\n    }\n\n    #[test]\n    fn test_conn_other_1_1() {\n        let req = parse_ready!(&mut BytesMut::from(\n            \"GET /test HTTP/1.1\\r\\n\\\n             connection: other\\r\\n\\r\\n\",\n        ));\n        assert_eq!(req.head().connection_type(), ConnectionType::KeepAlive);\n    }\n\n    #[test]\n    fn test_conn_upgrade() {\n        let req = parse_ready!(&mut BytesMut::from(\n            \"GET /test HTTP/1.1\\r\\n\\\n             upgrade: websockets\\r\\n\\\n             connection: upgrade\\r\\n\\r\\n\",\n        ));\n\n        assert!(req.upgrade());\n        assert_eq!(req.head().connection_type(), ConnectionType::Upgrade);\n\n        let req = parse_ready!(&mut BytesMut::from(\n            \"GET /test HTTP/1.1\\r\\n\\\n             upgrade: Websockets\\r\\n\\\n             connection: Upgrade\\r\\n\\r\\n\",\n        ));\n\n        assert!(req.upgrade());\n        assert_eq!(req.head().connection_type(), ConnectionType::Upgrade);\n    }\n\n    #[test]\n    fn test_conn_upgrade_connect_method() {\n        let req = parse_ready!(&mut BytesMut::from(\n            \"CONNECT /test HTTP/1.1\\r\\n\\\n             content-type: text/plain\\r\\n\\r\\n\",\n        ));\n\n        assert!(req.upgrade());\n    }\n\n    #[test]\n    fn test_headers_bad_content_length() {\n        // string CL\n        expect_parse_err!(&mut BytesMut::from(\n            \"GET /test HTTP/1.1\\r\\n\\\n             content-length: line\\r\\n\\r\\n\",\n        ));\n\n        // negative CL\n        expect_parse_err!(&mut BytesMut::from(\n            \"GET /test HTTP/1.1\\r\\n\\\n             content-length: -1\\r\\n\\r\\n\",\n        ));\n    }\n\n    #[test]\n    fn octal_ish_cl_parsed_as_decimal() {\n        let mut buf = BytesMut::from(\n            \"POST /test HTTP/1.1\\r\\n\\\n             content-length: 011\\r\\n\\r\\n\",\n        );\n        let mut reader = MessageDecoder::<Request>::default();\n        let (_req, pl) = reader.decode(&mut buf).unwrap().unwrap();\n        assert!(matches!(\n            pl,\n            PayloadType::Payload(pl) if pl == PayloadDecoder::length(11)\n        ));\n    }\n\n    #[test]\n    fn test_invalid_header() {\n        expect_parse_err!(&mut BytesMut::from(\n            \"GET /test HTTP/1.1\\r\\n\\\n             test line\\r\\n\\r\\n\",\n        ));\n    }\n\n    #[test]\n    fn test_invalid_name() {\n        expect_parse_err!(&mut BytesMut::from(\n            \"GET /test HTTP/1.1\\r\\n\\\n             test[]: line\\r\\n\\r\\n\",\n        ));\n    }\n\n    #[test]\n    fn test_http_request_bad_status_line() {\n        expect_parse_err!(&mut BytesMut::from(\"getpath \\r\\n\\r\\n\"));\n    }\n\n    #[test]\n    fn test_http_request_upgrade_websocket() {\n        let mut buf = BytesMut::from(\n            \"GET /test HTTP/1.1\\r\\n\\\n             connection: upgrade\\r\\n\\\n             upgrade: websocket\\r\\n\\r\\n\\\n             some raw data\",\n        );\n        let mut reader = MessageDecoder::<Request>::default();\n        let (req, pl) = reader.decode(&mut buf).unwrap().unwrap();\n        assert_eq!(req.head().connection_type(), ConnectionType::Upgrade);\n        assert!(req.upgrade());\n        assert!(pl.is_unhandled());\n    }\n\n    #[test]\n    fn test_http_request_upgrade_h2c() {\n        let mut buf = BytesMut::from(\n            \"GET /test HTTP/1.1\\r\\n\\\n             connection: upgrade, http2-settings\\r\\n\\\n             upgrade: h2c\\r\\n\\\n             http2-settings: dummy\\r\\n\\r\\n\",\n        );\n        let mut reader = MessageDecoder::<Request>::default();\n        let (req, pl) = reader.decode(&mut buf).unwrap().unwrap();\n        // `connection: upgrade, http2-settings` doesn't work properly..\n        // see MessageType::set_headers().\n        //\n        // The line below should be:\n        // assert_eq!(req.head().connection_type(), ConnectionType::Upgrade);\n        assert_eq!(req.head().connection_type(), ConnectionType::KeepAlive);\n        assert!(req.upgrade());\n        assert!(!pl.is_unhandled());\n    }\n\n    #[test]\n    fn test_http_request_parser_utf8() {\n        let req = parse_ready!(&mut BytesMut::from(\n            \"GET /test HTTP/1.1\\r\\n\\\n             x-test: \u0442\u0435\u0441\u0442\\r\\n\\r\\n\",\n        ));\n\n        assert_eq!(\n            req.headers().get(\"x-test\").unwrap().as_bytes(),\n            \"\u0442\u0435\u0441\u0442\".as_bytes()\n        );\n    }\n\n    #[test]\n    fn test_http_request_parser_two_slashes() {\n        let req = parse_ready!(&mut BytesMut::from(\"GET //path HTTP/1.1\\r\\n\\r\\n\"));\n        assert_eq!(req.path(), \"//path\");\n    }\n\n    #[test]\n    fn test_http_request_parser_bad_method() {\n        expect_parse_err!(&mut BytesMut::from(\"!12%()+=~$ /get HTTP/1.1\\r\\n\\r\\n\"));\n    }\n\n    #[test]\n    fn test_http_request_parser_bad_version() {\n        expect_parse_err!(&mut BytesMut::from(\"GET //get HT/11\\r\\n\\r\\n\"));\n    }\n\n    #[test]\n    fn test_response_http10_read_until_eof() {\n        let mut buf = BytesMut::from(\"HTTP/1.0 200 Ok\\r\\n\\r\\ntest data\");\n\n        let mut reader = MessageDecoder::<ResponseHead>::default();\n        let (_msg, pl) = reader.decode(&mut buf).unwrap().unwrap();\n        let mut pl = pl.unwrap();\n\n        let chunk = pl.decode(&mut buf).unwrap().unwrap();\n        assert_eq!(chunk, PayloadItem::Chunk(Bytes::from_static(b\"test data\")));\n    }\n\n    #[test]\n    fn hrs_multiple_content_length() {\n        expect_parse_err!(&mut BytesMut::from(\n            \"GET / HTTP/1.1\\r\\n\\\n            Host: example.com\\r\\n\\\n            Content-Length: 4\\r\\n\\\n            Content-Length: 2\\r\\n\\\n            \\r\\n\\\n            abcd\",\n        ));\n\n        expect_parse_err!(&mut BytesMut::from(\n            \"GET / HTTP/1.1\\r\\n\\\n            Host: example.com\\r\\n\\\n            Content-Length: 0\\r\\n\\\n            Content-Length: 2\\r\\n\\\n            \\r\\n\\\n            ab\",\n        ));\n    }\n\n    #[test]\n    fn hrs_content_length_plus() {\n        expect_parse_err!(&mut BytesMut::from(\n            \"GET / HTTP/1.1\\r\\n\\\n            Host: example.com\\r\\n\\\n            Content-Length: +3\\r\\n\\\n            \\r\\n\\\n            000\",\n        ));\n    }\n\n    #[test]\n    fn hrs_te_http10() {\n        // in HTTP/1.0 transfer encoding is ignored and must therefore contain a CL header\n\n        expect_parse_err!(&mut BytesMut::from(\n            \"POST / HTTP/1.0\\r\\n\\\n            Host: example.com\\r\\n\\\n            Transfer-Encoding: chunked\\r\\n\\\n            \\r\\n\\\n            3\\r\\n\\\n            aaa\\r\\n\\\n            0\\r\\n\\\n            \",\n        ));\n    }\n\n    #[test]\n    fn hrs_cl_and_te_http10() {\n        // in HTTP/1.0 transfer encoding is simply ignored so it's fine to have both\n\n        let mut buf = BytesMut::from(\n            \"GET / HTTP/1.0\\r\\n\\\n            Host: example.com\\r\\n\\\n            Content-Length: 3\\r\\n\\\n            Transfer-Encoding: chunked\\r\\n\\\n            \\r\\n\\\n            000\",\n        );\n\n        parse_ready!(&mut buf);\n    }\n\n    #[test]\n    fn hrs_unknown_transfer_encoding() {\n        let mut buf = BytesMut::from(\n            \"GET / HTTP/1.1\\r\\n\\\n            Host: example.com\\r\\n\\\n            Transfer-Encoding: JUNK\\r\\n\\\n            Transfer-Encoding: chunked\\r\\n\\\n            \\r\\n\\\n            5\\r\\n\\\n            hello\\r\\n\\\n            0\",\n        );\n\n        expect_parse_err!(&mut buf);\n    }\n\n    #[test]\n    fn hrs_multiple_transfer_encoding() {\n        let mut buf = BytesMut::from(\n            \"GET / HTTP/1.1\\r\\n\\\n            Host: example.com\\r\\n\\\n            Content-Length: 51\\r\\n\\\n            Transfer-Encoding: identity\\r\\n\\\n            Transfer-Encoding: chunked\\r\\n\\\n            \\r\\n\\\n            0\\r\\n\\\n            \\r\\n\\\n            GET /forbidden HTTP/1.1\\r\\n\\\n            Host: example.com\\r\\n\\r\\n\",\n        );\n\n        expect_parse_err!(&mut buf);\n    }\n\n    #[test]\n    fn transfer_encoding_agrees() {\n        let mut buf = BytesMut::from(\n            \"GET /test HTTP/1.1\\r\\n\\\n            Host: example.com\\r\\n\\\n            Content-Length: 3\\r\\n\\\n            Transfer-Encoding: identity\\r\\n\\\n            \\r\\n\\\n            0\\r\\n\",\n        );\n\n        let mut reader = MessageDecoder::<Request>::default();\n        let (_msg, pl) = reader.decode(&mut buf).unwrap().unwrap();\n        let mut pl = pl.unwrap();\n\n        let chunk = pl.decode(&mut buf).unwrap().unwrap();\n        assert_eq!(chunk, PayloadItem::Chunk(Bytes::from_static(b\"0\\r\\n\")));\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "d21f7f107984da8d49b2d9c032fc18b9e880d676",
    "func": "use serde_derive::Serialize;\nuse std::collections::HashMap;\n\n#[derive(Serialize)]\nstruct Foo(#[serde(flatten)] HashMap<String, String>);\n\nfn main() {}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "64229911c282ce14b8ae7065ded11ba163d7097a",
    "func": "use serde_derive::Serialize;\n\n#[derive(Serialize)]\n#[serde(field_identifier)]\nenum F {\n    A,\n    B,\n}\n\nfn main() {}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "3e42e1da0d0b7dceb7b35fd198613f838bf3e31c",
    "func": "use std::{\n    convert::Infallible,\n    pin::Pin,\n    task::{Context, Poll},\n};\n\nuse bytes::Bytes;\n\nuse super::{BodySize, MessageBody};\n\n/// Body type for responses that forbid payloads.\n///\n/// This is distinct from an \"empty\" response which _would_ contain a `Content-Length` header.\n/// For an \"empty\" body, use `()` or `Bytes::new()`.\n///\n/// For example, the HTTP spec forbids a payload to be sent with a `204 No Content` response.\n/// In this case, the payload (or lack thereof) is implicit from the status code, so a\n/// `Content-Length` header is not required.\n#[derive(Debug, Clone, Copy, Default)]\n#[non_exhaustive]\npub struct None;\n\nimpl None {\n    /// Constructs new \"none\" body.\n    #[inline]\n    pub fn new() -> Self {\n        None\n    }\n}\n\nimpl MessageBody for None {\n    type Error = Infallible;\n\n    #[inline]\n    fn size(&self) -> BodySize {\n        BodySize::None\n    }\n\n    #[inline]\n    fn poll_next(\n        self: Pin<&mut Self>,\n        _cx: &mut Context<'_>,\n    ) -> Poll<Option<Result<Bytes, Self::Error>>> {\n        Poll::Ready(Option::None)\n    }\n\n    #[inline]\n    fn try_into_bytes(self) -> Result<Bytes, Self> {\n        Ok(Bytes::new())\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "759472c6eaed95735a5317ab6f4a1022325db60e",
    "func": "use crate::runtime::scheduler::multi_thread::{queue, Stats};\nuse crate::runtime::tests::{unowned, NoopSchedule};\n\nuse loom::thread;\nuse std::cell::RefCell;\n\nfn new_stats() -> Stats {\n    Stats::new(&crate::runtime::WorkerMetrics::new())\n}\n\n#[test]\nfn basic() {\n    loom::model(|| {\n        let (steal, mut local) = queue::local();\n        let inject = RefCell::new(vec![]);\n        let mut stats = new_stats();\n\n        let th = thread::spawn(move || {\n            let mut stats = new_stats();\n            let (_, mut local) = queue::local();\n            let mut n = 0;\n\n            for _ in 0..3 {\n                if steal.steal_into(&mut local, &mut stats).is_some() {\n                    n += 1;\n                }\n\n                while local.pop().is_some() {\n                    n += 1;\n                }\n            }\n\n            n\n        });\n\n        let mut n = 0;\n\n        for _ in 0..2 {\n            for _ in 0..2 {\n                let (task, _) = unowned(async {});\n                local.push_back_or_overflow(task, &inject, &mut stats);\n            }\n\n            if local.pop().is_some() {\n                n += 1;\n            }\n\n            // Push another task\n            let (task, _) = unowned(async {});\n            local.push_back_or_overflow(task, &inject, &mut stats);\n\n            while local.pop().is_some() {\n                n += 1;\n            }\n        }\n\n        n += inject.borrow_mut().drain(..).count();\n\n        n += th.join().unwrap();\n\n        assert_eq!(6, n);\n    });\n}\n\n#[test]\nfn steal_overflow() {\n    loom::model(|| {\n        let (steal, mut local) = queue::local();\n        let inject = RefCell::new(vec![]);\n        let mut stats = new_stats();\n\n        let th = thread::spawn(move || {\n            let mut stats = new_stats();\n            let (_, mut local) = queue::local();\n            let mut n = 0;\n\n            if steal.steal_into(&mut local, &mut stats).is_some() {\n                n += 1;\n            }\n\n            while local.pop().is_some() {\n                n += 1;\n            }\n\n            n\n        });\n\n        let mut n = 0;\n\n        // push a task, pop a task\n        let (task, _) = unowned(async {});\n        local.push_back_or_overflow(task, &inject, &mut stats);\n\n        if local.pop().is_some() {\n            n += 1;\n        }\n\n        for _ in 0..6 {\n            let (task, _) = unowned(async {});\n            local.push_back_or_overflow(task, &inject, &mut stats);\n        }\n\n        n += th.join().unwrap();\n\n        while local.pop().is_some() {\n            n += 1;\n        }\n\n        n += inject.borrow_mut().drain(..).count();\n\n        assert_eq!(7, n);\n    });\n}\n\n#[test]\nfn multi_stealer() {\n    const NUM_TASKS: usize = 5;\n\n    fn steal_tasks(steal: queue::Steal<NoopSchedule>) -> usize {\n        let mut stats = new_stats();\n        let (_, mut local) = queue::local();\n\n        if steal.steal_into(&mut local, &mut stats).is_none() {\n            return 0;\n        }\n\n        let mut n = 1;\n\n        while local.pop().is_some() {\n            n += 1;\n        }\n\n        n\n    }\n\n    loom::model(|| {\n        let (steal, mut local) = queue::local();\n        let inject = RefCell::new(vec![]);\n        let mut stats = new_stats();\n\n        // Push work\n        for _ in 0..NUM_TASKS {\n            let (task, _) = unowned(async {});\n            local.push_back_or_overflow(task, &inject, &mut stats);\n        }\n\n        let th1 = {\n            let steal = steal.clone();\n            thread::spawn(move || steal_tasks(steal))\n        };\n\n        let th2 = thread::spawn(move || steal_tasks(steal));\n\n        let mut n = 0;\n\n        while local.pop().is_some() {\n            n += 1;\n        }\n\n        n += inject.borrow_mut().drain(..).count();\n\n        n += th1.join().unwrap();\n        n += th2.join().unwrap();\n\n        assert_eq!(n, NUM_TASKS);\n    });\n}\n\n#[test]\nfn chained_steal() {\n    loom::model(|| {\n        let mut stats = new_stats();\n        let (s1, mut l1) = queue::local();\n        let (s2, mut l2) = queue::local();\n        let inject = RefCell::new(vec![]);\n\n        // Load up some tasks\n        for _ in 0..4 {\n            let (task, _) = unowned(async {});\n            l1.push_back_or_overflow(task, &inject, &mut stats);\n\n            let (task, _) = unowned(async {});\n            l2.push_back_or_overflow(task, &inject, &mut stats);\n        }\n\n        // Spawn a task to steal from **our** queue\n        let th = thread::spawn(move || {\n            let mut stats = new_stats();\n            let (_, mut local) = queue::local();\n            s1.steal_into(&mut local, &mut stats);\n\n            while local.pop().is_some() {}\n        });\n\n        // Drain our tasks, then attempt to steal\n        while l1.pop().is_some() {}\n\n        s2.steal_into(&mut l1, &mut stats);\n\n        th.join().unwrap();\n\n        while l1.pop().is_some() {}\n        while l2.pop().is_some() {}\n    });\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "baad91ee13986c4e4b101b68f134a554e5a9617d",
    "func": "//! Scroll elements using their MountedData\n//!\n//! Dioxus exposes a few helpful APIs around elements (mimicking the DOM APIs) to allow you to interact with elements\n//! across the renderers. This includes scrolling, reading dimensions, and more.\n//!\n//! In this example we demonstrate how to scroll to the top of the page using the `scroll_to` method on the `MountedData`\n\nuse dioxus::prelude::*;\n\nfn main() {\n    dioxus::launch(app);\n}\n\nfn app() -> Element {\n    let mut header_element = use_signal(|| None);\n\n    rsx! {\n        div {\n            h1 {\n                onmounted: move |cx| header_element.set(Some(cx.data())),\n                \"Scroll to top example\"\n            }\n\n            for i in 0..100 {\n                div { \"Item {i}\" }\n            }\n\n            button {\n                onclick: move |_| async move {\n                    if let Some(header) = header_element.cloned() {\n                        let _ = header.scroll_to(ScrollBehavior::Smooth).await;\n                    }\n                },\n                \"Scroll to top\"\n            }\n        }\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "f82cfe6bd5edefd4c82b445220df1070b33084ad",
    "func": "#![no_implicit_prelude]\n\n// Shadow primitives\n#[allow(non_camel_case_types)]\npub struct bool;\n#[allow(non_camel_case_types)]\npub struct char;\n#[allow(non_camel_case_types)]\npub struct f32;\n#[allow(non_camel_case_types)]\npub struct f64;\n#[allow(non_camel_case_types)]\npub struct i128;\n#[allow(non_camel_case_types)]\npub struct i16;\n#[allow(non_camel_case_types)]\npub struct i32;\n#[allow(non_camel_case_types)]\npub struct i64;\n#[allow(non_camel_case_types)]\npub struct i8;\n#[allow(non_camel_case_types)]\npub struct isize;\n#[allow(non_camel_case_types)]\npub struct str;\n#[allow(non_camel_case_types)]\npub struct u128;\n#[allow(non_camel_case_types)]\npub struct u16;\n#[allow(non_camel_case_types)]\npub struct u32;\n#[allow(non_camel_case_types)]\npub struct u64;\n#[allow(non_camel_case_types)]\npub struct u8;\n#[allow(non_camel_case_types)]\npub struct usize;\n\nfn main() {\n    _ = ::yew::html! {};\n    _ = ::yew::html! { <></> };\n    _ = ::yew::html! {\n        <>\n            <></>\n            <></>\n        </>\n    };\n    _ = ::yew::html! {\n        <key={::std::string::ToString::to_string(\"key\")}>\n        </>\n    };\n\n    let children = ::std::vec![\n        ::yew::html! { <span>{ \"Hello\" }</span> },\n        ::yew::html! { <span>{ \"World\" }</span> },\n    ];\n    _ = ::yew::html! { <>{ children }</> };\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "735cd84e7e2c8bc1cd47e676ad166c04d5e304e6",
    "func": "#![cfg(all(target_arch = \"wasm32\", not(target_os = \"wasi\")))]\n\nmod common;\n\nwasm_bindgen_test::wasm_bindgen_test_configure!(run_in_browser);\n\nuse std::time::Duration;\n\nuse common::obtain_result;\nuse wasm_bindgen_futures::spawn_local;\nuse wasm_bindgen_test::*;\nuse yew::platform::time::sleep;\nuse yew::prelude::*;\n\n#[wasm_bindgen_test]\nasync fn change_nested_after_append() {\n    #[function_component]\n    fn Nested() -> Html {\n        let delayed_trigger = use_state(|| true);\n\n        {\n            let delayed_trigger = delayed_trigger.clone();\n            use_effect_with((), move |_| {\n                spawn_local(async move {\n                    sleep(Duration::from_millis(50)).await;\n                    delayed_trigger.set(false);\n                });\n                || {}\n            });\n        }\n\n        if *delayed_trigger {\n            html! { <div>{\"failure\"}</div> }\n        } else {\n            html! { <><i></i><span id=\"result\">{\"success\"}</span></> }\n        }\n    }\n\n    #[function_component]\n    fn Top() -> Html {\n        html! { <Nested /> }\n    }\n\n    #[function_component]\n    fn App() -> Html {\n        let show_bottom = use_state_eq(|| false);\n\n        {\n            let show_bottom = show_bottom.clone();\n\n            use_effect_with((), move |_| {\n                show_bottom.set(true);\n                || {}\n            });\n        }\n\n        html! {\n            <>\n                <Top />\n                if *show_bottom {\n                    <div>{\"<div>Bottom</div>\"}</div>\n                }\n            </>\n        }\n    }\n\n    yew::Renderer::<App>::with_root(gloo::utils::document().get_element_by_id(\"output\").unwrap())\n        .render();\n\n    sleep(Duration::from_millis(100)).await;\n\n    let result = obtain_result();\n    assert_eq!(result.as_str(), \"success\");\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "910b7c92c3fbdbadad3e7b69a0e592d5f3ecd8b1",
    "func": "//! Using `wry`'s http module, we can stream a video file from the local file system.\n//!\n//! You could load in any file type, but this example uses a video file.\n\nuse dioxus::desktop::wry::http;\nuse dioxus::desktop::wry::http::Response;\nuse dioxus::desktop::{use_asset_handler, AssetRequest};\nuse dioxus::prelude::*;\nuse http::{header::*, response::Builder as ResponseBuilder, status::StatusCode};\nuse std::{io::SeekFrom, path::PathBuf};\nuse tokio::io::{AsyncReadExt, AsyncSeekExt, AsyncWriteExt};\n\nconst VIDEO_PATH: &str = \"./examples/assets/test_video.mp4\";\n\nfn main() {\n    // For the sake of this example, we will download the video file if it doesn't exist\n    ensure_video_is_loaded();\n\n    dioxus::LaunchBuilder::desktop().launch(app);\n}\n\nfn app() -> Element {\n    // Any request to /videos will be handled by this handler\n    use_asset_handler(\"videos\", move |request, responder| {\n        // Using spawn works, but is slower than a dedicated thread\n        tokio::task::spawn(async move {\n            let video_file = PathBuf::from(VIDEO_PATH);\n            let mut file = tokio::fs::File::open(&video_file).await.unwrap();\n\n            match get_stream_response(&mut file, &request).await {\n                Ok(response) => responder.respond(response),\n                Err(err) => eprintln!(\"Error: {}\", err),\n            }\n        });\n    });\n\n    rsx! {\n        div {\n            video {\n                src: \"/videos/test_video.mp4\",\n                autoplay: true,\n                controls: true,\n                width: 640,\n                height: 480\n            }\n        }\n    }\n}\n\n/// This was taken from wry's example\nasync fn get_stream_response(\n    asset: &mut (impl tokio::io::AsyncSeek + tokio::io::AsyncRead + Unpin + Send + Sync),\n    request: &AssetRequest,\n) -> Result<Response<Vec<u8>>, Box<dyn std::error::Error>> {\n    // get stream length\n    let len = {\n        let old_pos = asset.stream_position().await?;\n        let len = asset.seek(SeekFrom::End(0)).await?;\n        asset.seek(SeekFrom::Start(old_pos)).await?;\n        len\n    };\n\n    let mut resp = ResponseBuilder::new().header(CONTENT_TYPE, \"video/mp4\");\n\n    // if the webview sent a range header, we need to send a 206 in return\n    // Actually only macOS and Windows are supported. Linux will ALWAYS return empty headers.\n    let http_response = if let Some(range_header) = request.headers().get(\"range\") {\n        let not_satisfiable = || {\n            ResponseBuilder::new()\n                .status(StatusCode::RANGE_NOT_SATISFIABLE)\n                .header(CONTENT_RANGE, format!(\"bytes */{len}\"))\n                .body(vec![])\n        };\n\n        // parse range header\n        let ranges = if let Ok(ranges) = http_range::HttpRange::parse(range_header.to_str()?, len) {\n            ranges\n                .iter()\n                // map the output back to spec range <start-end>, example: 0-499\n                .map(|r| (r.start, r.start + r.length - 1))\n                .collect::<Vec<_>>()\n        } else {\n            return Ok(not_satisfiable()?);\n        };\n\n        /// The Maximum bytes we send in one range\n        const MAX_LEN: u64 = 1000 * 1024;\n\n        if ranges.len() == 1 {\n            let &(start, mut end) = ranges.first().unwrap();\n\n            // check if a range is not satisfiable\n            //\n            // this should be already taken care of by HttpRange::parse\n            // but checking here again for extra assurance\n            if start >= len || end >= len || end < start {\n                return Ok(not_satisfiable()?);\n            }\n\n            // adjust end byte for MAX_LEN\n            end = start + (end - start).min(len - start).min(MAX_LEN - 1);\n\n            // calculate number of bytes needed to be read\n            let bytes_to_read = end + 1 - start;\n\n            // allocate a buf with a suitable capacity\n            let mut buf = Vec::with_capacity(bytes_to_read as usize);\n            // seek the file to the starting byte\n            asset.seek(SeekFrom::Start(start)).await?;\n            // read the needed bytes\n            asset.take(bytes_to_read).read_to_end(&mut buf).await?;\n\n            resp = resp.header(CONTENT_RANGE, format!(\"bytes {start}-{end}/{len}\"));\n            resp = resp.header(CONTENT_LENGTH, end + 1 - start);\n            resp = resp.status(StatusCode::PARTIAL_CONTENT);\n            resp.body(buf)\n        } else {\n            let mut buf = Vec::new();\n            let ranges = ranges\n                .iter()\n                .filter_map(|&(start, mut end)| {\n                    // filter out unsatisfiable ranges\n                    //\n                    // this should be already taken care of by HttpRange::parse\n                    // but checking here again for extra assurance\n                    if start >= len || end >= len || end < start {\n                        None\n                    } else {\n                        // adjust end byte for MAX_LEN\n                        end = start + (end - start).min(len - start).min(MAX_LEN - 1);\n                        Some((start, end))\n                    }\n                })\n                .collect::<Vec<_>>();\n\n            let boundary = format!(\"{:x}\", rand::random::<u64>());\n            let boundary_sep = format!(\"\\r\\n--{boundary}\\r\\n\");\n            let boundary_closer = format!(\"\\r\\n--{boundary}\\r\\n\");\n\n            resp = resp.header(\n                CONTENT_TYPE,\n                format!(\"multipart/byteranges; boundary={boundary}\"),\n            );\n\n            for (end, start) in ranges {\n                // a new range is being written, write the range boundary\n                buf.write_all(boundary_sep.as_bytes()).await?;\n\n                // write the needed headers `Content-Type` and `Content-Range`\n                buf.write_all(format!(\"{CONTENT_TYPE}: video/mp4\\r\\n\").as_bytes())\n                    .await?;\n                buf.write_all(format!(\"{CONTENT_RANGE}: bytes {start}-{end}/{len}\\r\\n\").as_bytes())\n                    .await?;\n\n                // write the separator to indicate the start of the range body\n                buf.write_all(\"\\r\\n\".as_bytes()).await?;\n\n                // calculate number of bytes needed to be read\n                let bytes_to_read = end + 1 - start;\n\n                let mut local_buf = vec![0_u8; bytes_to_read as usize];\n                asset.seek(SeekFrom::Start(start)).await?;\n                asset.read_exact(&mut local_buf).await?;\n                buf.extend_from_slice(&local_buf);\n            }\n            // all ranges have been written, write the closing boundary\n            buf.write_all(boundary_closer.as_bytes()).await?;\n\n            resp.body(buf)\n        }\n    } else {\n        resp = resp.header(CONTENT_LENGTH, len);\n        let mut buf = Vec::with_capacity(len as usize);\n        asset.read_to_end(&mut buf).await?;\n        resp.body(buf)\n    };\n\n    http_response.map_err(Into::into)\n}\n\nfn ensure_video_is_loaded() {\n    let video_file = PathBuf::from(VIDEO_PATH);\n    if !video_file.exists() {\n        tokio::runtime::Runtime::new()\n            .unwrap()\n            .block_on(async move {\n                println!(\"Downloading video file...\");\n                let video_url =\n                    \"http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4\";\n                let mut response = reqwest::get(video_url).await.unwrap();\n                let mut file = tokio::fs::File::create(&video_file).await.unwrap();\n                while let Some(chunk) = response.chunk().await.unwrap() {\n                    file.write_all(&chunk).await.unwrap();\n                }\n            });\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "a24938b562b4e584d2a4ce9ad30d35d2e7b14e6f",
    "func": "use serde_derive::Deserialize;\n\n#[derive(Deserialize)]\n#[serde(default)]\nstruct Unit;\n\nfn main() {}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "c8163b65eb1fee5265a7a644a6a8e8f2a8d7d162",
    "func": "#![deny(trivial_numeric_casts)]\n#![allow(\n    clippy::derive_partial_eq_without_eq,\n    clippy::enum_variant_names,\n    clippy::redundant_field_names,\n    clippy::too_many_lines\n)]\n\nmod bytes;\n\nuse serde_derive::{Deserialize, Serialize};\nuse serde_test::{assert_de_tokens, assert_de_tokens_error, assert_tokens, Token};\nuse std::collections::BTreeMap;\nuse std::iter::FromIterator;\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nstruct Unit;\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nstruct Newtype(BTreeMap<String, String>);\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nstruct Struct {\n    f: u8,\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\nenum Enum {\n    Unit,\n    Newtype(u8),\n    Tuple(u8, u8),\n    Struct { f: u8 },\n}\n\n#[derive(Debug, PartialEq, Serialize, Deserialize)]\n#[serde(tag = \"tag\")]\nenum InternallyTagged {\n    Unit,\n    NewtypeUnit(()),\n    NewtypeUnitStruct(Unit),\n    NewtypeNewtype(Newtype),\n    NewtypeMap(BTreeMap<String, String>),\n    NewtypeStruct(Struct),\n    NewtypeEnum(Enum),\n    Struct { a: u8 },\n    StructEnum { enum_: Enum },\n}\n\n#[test]\nfn unit() {\n    assert_tokens(\n        &InternallyTagged::Unit,\n        &[\n            Token::Struct {\n                name: \"InternallyTagged\",\n                len: 1,\n            },\n            Token::Str(\"tag\"),\n            Token::Str(\"Unit\"),\n            Token::StructEnd,\n        ],\n    );\n    assert_de_tokens(\n        &InternallyTagged::Unit,\n        &[\n            Token::Struct {\n                name: \"InternallyTagged\",\n                len: 1,\n            },\n            Token::BorrowedStr(\"tag\"),\n            Token::BorrowedStr(\"Unit\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &InternallyTagged::Unit,\n        &[\n            Token::Map { len: Some(1) },\n            Token::Str(\"tag\"),\n            Token::Str(\"Unit\"),\n            Token::MapEnd,\n        ],\n    );\n    assert_de_tokens(\n        &InternallyTagged::Unit,\n        &[\n            Token::Map { len: Some(1) },\n            Token::BorrowedStr(\"tag\"),\n            Token::BorrowedStr(\"Unit\"),\n            Token::MapEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &InternallyTagged::Unit,\n        &[\n            Token::Seq { len: Some(1) },\n            Token::Str(\"Unit\"), // tag\n            Token::SeqEnd,\n        ],\n    );\n    assert_de_tokens(\n        &InternallyTagged::Unit,\n        &[\n            Token::Seq { len: Some(1) },\n            Token::BorrowedStr(\"Unit\"), // tag\n            Token::SeqEnd,\n        ],\n    );\n}\n\n#[test]\nfn newtype_unit() {\n    let value = InternallyTagged::NewtypeUnit(());\n\n    assert_tokens(\n        &value,\n        &[\n            Token::Map { len: Some(1) },\n            Token::Str(\"tag\"),\n            Token::Str(\"NewtypeUnit\"),\n            Token::MapEnd,\n        ],\n    );\n    assert_de_tokens(\n        &value,\n        &[\n            Token::Map { len: Some(1) },\n            Token::BorrowedStr(\"tag\"),\n            Token::BorrowedStr(\"NewtypeUnit\"),\n            Token::MapEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &value,\n        &[\n            Token::Struct {\n                name: \"InternallyTagged\",\n                len: 1,\n            },\n            Token::Str(\"tag\"),\n            Token::Str(\"NewtypeUnit\"),\n            Token::StructEnd,\n        ],\n    );\n    assert_de_tokens(\n        &value,\n        &[\n            Token::Struct {\n                name: \"InternallyTagged\",\n                len: 1,\n            },\n            Token::BorrowedStr(\"tag\"),\n            Token::BorrowedStr(\"NewtypeUnit\"),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn newtype_unit_struct() {\n    let value = InternallyTagged::NewtypeUnitStruct(Unit);\n\n    assert_tokens(\n        &value,\n        &[\n            Token::Map { len: Some(1) },\n            Token::Str(\"tag\"),\n            Token::Str(\"NewtypeUnitStruct\"),\n            Token::MapEnd,\n        ],\n    );\n    assert_de_tokens(\n        &value,\n        &[\n            Token::Map { len: Some(1) },\n            Token::BorrowedStr(\"tag\"),\n            Token::BorrowedStr(\"NewtypeUnitStruct\"),\n            Token::MapEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &value,\n        &[\n            Token::Struct {\n                name: \"InternallyTagged\",\n                len: 1,\n            },\n            Token::Str(\"tag\"),\n            Token::Str(\"NewtypeUnitStruct\"),\n            Token::StructEnd,\n        ],\n    );\n    assert_de_tokens(\n        &value,\n        &[\n            Token::Struct {\n                name: \"InternallyTagged\",\n                len: 1,\n            },\n            Token::BorrowedStr(\"tag\"),\n            Token::BorrowedStr(\"NewtypeUnitStruct\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &value,\n        &[\n            Token::Seq { len: Some(1) },\n            Token::Str(\"NewtypeUnitStruct\"), // tag\n            Token::SeqEnd,\n        ],\n    );\n    assert_de_tokens(\n        &value,\n        &[\n            Token::Seq { len: Some(1) },\n            Token::BorrowedStr(\"NewtypeUnitStruct\"), // tag\n            Token::SeqEnd,\n        ],\n    );\n}\n\n#[test]\nfn newtype_newtype() {\n    assert_tokens(\n        &InternallyTagged::NewtypeNewtype(Newtype(BTreeMap::new())),\n        &[\n            Token::Map { len: Some(1) },\n            Token::Str(\"tag\"),\n            Token::Str(\"NewtypeNewtype\"),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn newtype_map() {\n    let value = InternallyTagged::NewtypeMap(BTreeMap::new());\n\n    // Special case: empty map\n    assert_tokens(\n        &value,\n        &[\n            Token::Map { len: Some(1) },\n            Token::Str(\"tag\"),\n            Token::Str(\"NewtypeMap\"),\n            Token::MapEnd,\n        ],\n    );\n    assert_de_tokens(\n        &value,\n        &[\n            Token::Map { len: Some(1) },\n            Token::BorrowedStr(\"tag\"),\n            Token::BorrowedStr(\"NewtypeMap\"),\n            Token::MapEnd,\n        ],\n    );\n\n    let value = InternallyTagged::NewtypeMap(BTreeMap::from_iter([(\n        \"field\".to_string(),\n        \"value\".to_string(),\n    )]));\n\n    // Special case: tag field (\"tag\") is the first field\n    assert_tokens(\n        &value,\n        &[\n            Token::Map { len: Some(2) },\n            Token::Str(\"tag\"),\n            Token::Str(\"NewtypeMap\"),\n            Token::Str(\"field\"),\n            Token::Str(\"value\"),\n            Token::MapEnd,\n        ],\n    );\n    assert_de_tokens(\n        &value,\n        &[\n            Token::Map { len: Some(2) },\n            Token::BorrowedStr(\"tag\"),\n            Token::BorrowedStr(\"NewtypeMap\"),\n            Token::BorrowedStr(\"field\"),\n            Token::BorrowedStr(\"value\"),\n            Token::MapEnd,\n        ],\n    );\n\n    // General case: tag field (\"tag\") is not the first field\n    assert_de_tokens(\n        &value,\n        &[\n            Token::Map { len: Some(2) },\n            Token::Str(\"field\"),\n            Token::Str(\"value\"),\n            Token::Str(\"tag\"),\n            Token::Str(\"NewtypeMap\"),\n            Token::MapEnd,\n        ],\n    );\n    assert_de_tokens(\n        &value,\n        &[\n            Token::Map { len: Some(2) },\n            Token::BorrowedStr(\"field\"),\n            Token::BorrowedStr(\"value\"),\n            Token::BorrowedStr(\"tag\"),\n            Token::BorrowedStr(\"NewtypeMap\"),\n            Token::MapEnd,\n        ],\n    );\n\n    assert_de_tokens_error::<InternallyTagged>(\n        &[\n            Token::Seq { len: Some(2) },\n            Token::Str(\"NewtypeMap\"), // tag\n            Token::Map { len: Some(0) },\n            Token::MapEnd,\n            Token::SeqEnd,\n        ],\n        \"invalid type: sequence, expected a map\",\n    );\n}\n\n#[test]\nfn newtype_struct() {\n    let value = InternallyTagged::NewtypeStruct(Struct { f: 6 });\n\n    // Special case: tag field (\"tag\") is the first field\n    assert_tokens(\n        &value,\n        &[\n            Token::Struct {\n                name: \"Struct\",\n                len: 2,\n            },\n            Token::Str(\"tag\"),\n            Token::Str(\"NewtypeStruct\"),\n            Token::Str(\"f\"),\n            Token::U8(6),\n            Token::StructEnd,\n        ],\n    );\n    assert_de_tokens(\n        &value,\n        &[\n            Token::Struct {\n                name: \"Struct\",\n                len: 2,\n            },\n            Token::BorrowedStr(\"tag\"),\n            Token::BorrowedStr(\"NewtypeStruct\"),\n            Token::BorrowedStr(\"f\"),\n            Token::U8(6),\n            Token::StructEnd,\n        ],\n    );\n\n    // General case: tag field (\"tag\") is not the first field\n    assert_de_tokens(\n        &value,\n        &[\n            Token::Struct {\n                name: \"Struct\",\n                len: 2,\n            },\n            Token::Str(\"f\"),\n            Token::U8(6),\n            Token::Str(\"tag\"),\n            Token::Str(\"NewtypeStruct\"),\n            Token::StructEnd,\n        ],\n    );\n    assert_de_tokens(\n        &value,\n        &[\n            Token::Struct {\n                name: \"Struct\",\n                len: 2,\n            },\n            Token::BorrowedStr(\"f\"),\n            Token::U8(6),\n            Token::BorrowedStr(\"tag\"),\n            Token::BorrowedStr(\"NewtypeStruct\"),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &value,\n        &[\n            Token::Seq { len: Some(2) },\n            Token::Str(\"NewtypeStruct\"), // tag\n            Token::U8(6),\n            Token::SeqEnd,\n        ],\n    );\n    assert_de_tokens(\n        &value,\n        &[\n            Token::Seq { len: Some(2) },\n            Token::BorrowedStr(\"NewtypeStruct\"), // tag\n            Token::U8(6),\n            Token::SeqEnd,\n        ],\n    );\n}\n\nmod newtype_enum {\n    use super::*;\n\n    #[test]\n    fn unit() {\n        let value = InternallyTagged::NewtypeEnum(Enum::Unit);\n\n        // Special case: tag field (\"tag\") is the first field\n        assert_tokens(\n            &value,\n            &[\n                Token::Map { len: Some(2) },\n                Token::Str(\"tag\"),\n                Token::Str(\"NewtypeEnum\"),\n                Token::Str(\"Unit\"),\n                Token::Unit,\n                Token::MapEnd,\n            ],\n        );\n        assert_de_tokens(\n            &value,\n            &[\n                Token::Map { len: Some(2) },\n                Token::BorrowedStr(\"tag\"),\n                Token::BorrowedStr(\"NewtypeEnum\"),\n                Token::BorrowedStr(\"Unit\"),\n                Token::Unit,\n                Token::MapEnd,\n            ],\n        );\n\n        // General case: tag field (\"tag\") is not the first field\n        assert_de_tokens(\n            &value,\n            &[\n                Token::Map { len: Some(2) },\n                Token::Str(\"Unit\"),\n                Token::Unit,\n                Token::Str(\"tag\"),\n                Token::Str(\"NewtypeEnum\"),\n                Token::MapEnd,\n            ],\n        );\n        assert_de_tokens(\n            &value,\n            &[\n                Token::Map { len: Some(2) },\n                Token::BorrowedStr(\"Unit\"),\n                Token::Unit,\n                Token::BorrowedStr(\"tag\"),\n                Token::BorrowedStr(\"NewtypeEnum\"),\n                Token::MapEnd,\n            ],\n        );\n    }\n\n    #[test]\n    fn newtype() {\n        let value = InternallyTagged::NewtypeEnum(Enum::Newtype(1));\n\n        // Special case: tag field (\"tag\") is the first field\n        assert_tokens(\n            &value,\n            &[\n                Token::Map { len: Some(2) },\n                Token::Str(\"tag\"),\n                Token::Str(\"NewtypeEnum\"),\n                Token::Str(\"Newtype\"),\n                Token::U8(1),\n                Token::MapEnd,\n            ],\n        );\n        assert_de_tokens(\n            &value,\n            &[\n                Token::Map { len: Some(2) },\n                Token::BorrowedStr(\"tag\"),\n                Token::BorrowedStr(\"NewtypeEnum\"),\n                Token::BorrowedStr(\"Newtype\"),\n                Token::U8(1),\n                Token::MapEnd,\n            ],\n        );\n\n        // General case: tag field (\"tag\") is not the first field\n        assert_de_tokens(\n            &value,\n            &[\n                Token::Map { len: Some(2) },\n                Token::Str(\"Newtype\"),\n                Token::U8(1),\n                Token::Str(\"tag\"),\n                Token::Str(\"NewtypeEnum\"),\n                Token::MapEnd,\n            ],\n        );\n        assert_de_tokens(\n            &value,\n            &[\n                Token::Map { len: Some(2) },\n                Token::BorrowedStr(\"Newtype\"),\n                Token::U8(1),\n                Token::BorrowedStr(\"tag\"),\n                Token::BorrowedStr(\"NewtypeEnum\"),\n                Token::MapEnd,\n            ],\n        );\n    }\n\n    #[test]\n    fn tuple() {\n        let value = InternallyTagged::NewtypeEnum(Enum::Tuple(1, 1));\n\n        // Special case: tag field (\"tag\") is the first field\n        assert_tokens(\n            &value,\n            &[\n                Token::Map { len: Some(2) },\n                Token::Str(\"tag\"),\n                Token::Str(\"NewtypeEnum\"),\n                Token::Str(\"Tuple\"),\n                Token::TupleStruct {\n                    name: \"Tuple\",\n                    len: 2,\n                },\n                Token::U8(1),\n                Token::U8(1),\n                Token::TupleStructEnd,\n                Token::MapEnd,\n            ],\n        );\n        assert_de_tokens(\n            &value,\n            &[\n                Token::Map { len: Some(2) },\n                Token::BorrowedStr(\"tag\"),\n                Token::BorrowedStr(\"NewtypeEnum\"),\n                Token::BorrowedStr(\"Tuple\"),\n                Token::TupleStruct {\n                    name: \"Tuple\",\n                    len: 2,\n                },\n                Token::U8(1),\n                Token::U8(1),\n                Token::TupleStructEnd,\n                Token::MapEnd,\n            ],\n        );\n\n        // Special case: tag field (\"tag\") is not the first field\n        // Reaches crate::private::de::content::VariantDeserializer::tuple_variant\n        // Content::Seq case\n        // via ContentDeserializer::deserialize_enum\n        assert_de_tokens(\n            &value,\n            &[\n                Token::Map { len: Some(2) },\n                Token::Str(\"Tuple\"),\n                Token::TupleStruct {\n                    name: \"Tuple\",\n                    len: 2,\n                },\n                Token::U8(1),\n                Token::U8(1),\n                Token::TupleStructEnd,\n                Token::Str(\"tag\"),\n                Token::Str(\"NewtypeEnum\"),\n                Token::MapEnd,\n            ],\n        );\n        assert_de_tokens(\n            &value,\n            &[\n                Token::Map { len: Some(2) },\n                Token::BorrowedStr(\"Tuple\"),\n                Token::TupleStruct {\n                    name: \"Tuple\",\n                    len: 2,\n                },\n                Token::U8(1),\n                Token::U8(1),\n                Token::TupleStructEnd,\n                Token::BorrowedStr(\"tag\"),\n                Token::BorrowedStr(\"NewtypeEnum\"),\n                Token::MapEnd,\n            ],\n        );\n    }\n\n    #[test]\n    fn struct_() {\n        let value = InternallyTagged::NewtypeEnum(Enum::Struct { f: 1 });\n\n        // Special case: tag field (\"tag\") is the first field\n        assert_tokens(\n            &value,\n            &[\n                Token::Map { len: Some(2) },\n                Token::Str(\"tag\"),\n                Token::Str(\"NewtypeEnum\"),\n                Token::Str(\"Struct\"),\n                Token::Struct {\n                    name: \"Struct\",\n                    len: 1,\n                },\n                Token::Str(\"f\"),\n                Token::U8(1),\n                Token::StructEnd,\n                Token::MapEnd,\n            ],\n        );\n        assert_de_tokens(\n            &value,\n            &[\n                Token::Map { len: Some(2) },\n                Token::BorrowedStr(\"tag\"),\n                Token::BorrowedStr(\"NewtypeEnum\"),\n                Token::BorrowedStr(\"Struct\"),\n                Token::Struct {\n                    name: \"Struct\",\n                    len: 1,\n                },\n                Token::BorrowedStr(\"f\"),\n                Token::U8(1),\n                Token::StructEnd,\n                Token::MapEnd,\n            ],\n        );\n\n        // General case: tag field (\"tag\") is not the first field\n        // Reaches crate::private::de::content::VariantDeserializer::struct_variant\n        // Content::Map case\n        // via ContentDeserializer::deserialize_enum\n        assert_de_tokens(\n            &value,\n            &[\n                Token::Map { len: Some(2) },\n                Token::Str(\"Struct\"),\n                Token::Struct {\n                    name: \"Struct\",\n                    len: 1,\n                },\n                Token::Str(\"f\"),\n                Token::U8(1),\n                Token::StructEnd,\n                Token::Str(\"tag\"),\n                Token::Str(\"NewtypeEnum\"),\n                Token::MapEnd,\n            ],\n        );\n        assert_de_tokens(\n            &value,\n            &[\n                Token::Map { len: Some(2) },\n                Token::BorrowedStr(\"Struct\"),\n                Token::Struct {\n                    name: \"Struct\",\n                    len: 1,\n                },\n                Token::BorrowedStr(\"f\"),\n                Token::U8(1),\n                Token::StructEnd,\n                Token::BorrowedStr(\"tag\"),\n                Token::BorrowedStr(\"NewtypeEnum\"),\n                Token::MapEnd,\n            ],\n        );\n\n        // Special case: tag field (\"tag\") is the first field\n        assert_de_tokens(\n            &value,\n            &[\n                Token::Map { len: Some(2) },\n                Token::Str(\"tag\"),\n                Token::Str(\"NewtypeEnum\"),\n                Token::Str(\"Struct\"),\n                Token::Seq { len: Some(1) },\n                Token::U8(1), // f\n                Token::SeqEnd,\n                Token::MapEnd,\n            ],\n        );\n        assert_de_tokens(\n            &value,\n            &[\n                Token::Map { len: Some(2) },\n                Token::BorrowedStr(\"tag\"),\n                Token::BorrowedStr(\"NewtypeEnum\"),\n                Token::BorrowedStr(\"Struct\"),\n                Token::Seq { len: Some(1) },\n                Token::U8(1), // f\n                Token::SeqEnd,\n                Token::MapEnd,\n            ],\n        );\n\n        // General case: tag field (\"tag\") is not the first field\n        // Reaches crate::private::de::content::VariantDeserializer::struct_variant\n        // Content::Seq case\n        // via ContentDeserializer::deserialize_enum\n        assert_de_tokens(\n            &value,\n            &[\n                Token::Map { len: Some(2) },\n                Token::Str(\"Struct\"),\n                Token::Seq { len: Some(1) },\n                Token::U8(1), // f\n                Token::SeqEnd,\n                Token::Str(\"tag\"),\n                Token::Str(\"NewtypeEnum\"),\n                Token::MapEnd,\n            ],\n        );\n        assert_de_tokens(\n            &value,\n            &[\n                Token::Map { len: Some(2) },\n                Token::BorrowedStr(\"Struct\"),\n                Token::Seq { len: Some(1) },\n                Token::U8(1), // f\n                Token::SeqEnd,\n                Token::BorrowedStr(\"tag\"),\n                Token::BorrowedStr(\"NewtypeEnum\"),\n                Token::MapEnd,\n            ],\n        );\n    }\n}\n\n#[test]\nfn struct_() {\n    let value = InternallyTagged::Struct { a: 1 };\n\n    // Special case: tag field (\"tag\") is the first field\n    assert_tokens(\n        &value,\n        &[\n            Token::Struct {\n                name: \"InternallyTagged\",\n                len: 2,\n            },\n            Token::Str(\"tag\"),\n            Token::Str(\"Struct\"),\n            Token::Str(\"a\"),\n            Token::U8(1),\n            Token::StructEnd,\n        ],\n    );\n    assert_de_tokens(\n        &value,\n        &[\n            Token::Struct {\n                name: \"InternallyTagged\",\n                len: 2,\n            },\n            Token::BorrowedStr(\"tag\"),\n            Token::BorrowedStr(\"Struct\"),\n            Token::BorrowedStr(\"a\"),\n            Token::U8(1),\n            Token::StructEnd,\n        ],\n    );\n\n    // General case: tag field (\"tag\") is not the first field\n    assert_de_tokens(\n        &value,\n        &[\n            Token::Struct {\n                name: \"InternallyTagged\",\n                len: 2,\n            },\n            Token::Str(\"a\"),\n            Token::U8(1),\n            Token::Str(\"tag\"),\n            Token::Str(\"Struct\"),\n            Token::StructEnd,\n        ],\n    );\n    assert_de_tokens(\n        &value,\n        &[\n            Token::Struct {\n                name: \"InternallyTagged\",\n                len: 2,\n            },\n            Token::BorrowedStr(\"a\"),\n            Token::U8(1),\n            Token::BorrowedStr(\"tag\"),\n            Token::BorrowedStr(\"Struct\"),\n            Token::StructEnd,\n        ],\n    );\n\n    // Special case: tag field (\"tag\") is the first field\n    assert_de_tokens(\n        &value,\n        &[\n            Token::Map { len: Some(2) },\n            Token::Str(\"tag\"),\n            Token::Str(\"Struct\"),\n            Token::Str(\"a\"),\n            Token::U8(1),\n            Token::MapEnd,\n        ],\n    );\n    assert_de_tokens(\n        &value,\n        &[\n            Token::Map { len: Some(2) },\n            Token::BorrowedStr(\"tag\"),\n            Token::BorrowedStr(\"Struct\"),\n            Token::BorrowedStr(\"a\"),\n            Token::U8(1),\n            Token::MapEnd,\n        ],\n    );\n\n    // General case: tag field (\"tag\") is not the first field\n    assert_de_tokens(\n        &value,\n        &[\n            Token::Map { len: Some(2) },\n            Token::Str(\"a\"),\n            Token::U8(1),\n            Token::Str(\"tag\"),\n            Token::Str(\"Struct\"),\n            Token::MapEnd,\n        ],\n    );\n    assert_de_tokens(\n        &value,\n        &[\n            Token::Map { len: Some(2) },\n            Token::BorrowedStr(\"a\"),\n            Token::U8(1),\n            Token::BorrowedStr(\"tag\"),\n            Token::BorrowedStr(\"Struct\"),\n            Token::MapEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &value,\n        &[\n            Token::Seq { len: Some(2) },\n            Token::Str(\"Struct\"), // tag\n            Token::U8(1),\n            Token::SeqEnd,\n        ],\n    );\n    assert_de_tokens(\n        &value,\n        &[\n            Token::Seq { len: Some(2) },\n            Token::BorrowedStr(\"Struct\"), // tag\n            Token::U8(1),\n            Token::SeqEnd,\n        ],\n    );\n}\n\nmod struct_enum {\n    use super::*;\n\n    #[test]\n    fn unit() {\n        assert_de_tokens(\n            &Enum::Unit,\n            &[\n                Token::Enum { name: \"Enum\" },\n                Token::BorrowedStr(\"Unit\"),\n                Token::Unit,\n            ],\n        );\n\n        let value = InternallyTagged::StructEnum { enum_: Enum::Unit };\n\n        // Special case: tag field (\"tag\") is the first field\n        assert_tokens(\n            &value,\n            &[\n                Token::Struct {\n                    name: \"InternallyTagged\",\n                    len: 2,\n                },\n                Token::Str(\"tag\"),\n                Token::Str(\"StructEnum\"),\n                Token::Str(\"enum_\"),\n                Token::Enum { name: \"Enum\" },\n                Token::Str(\"Unit\"),\n                Token::Unit,\n                Token::StructEnd,\n            ],\n        );\n        assert_de_tokens(\n            &value,\n            &[\n                Token::Struct {\n                    name: \"InternallyTagged\",\n                    len: 2,\n                },\n                Token::BorrowedStr(\"tag\"),\n                Token::BorrowedStr(\"StructEnum\"),\n                Token::BorrowedStr(\"enum_\"),\n                Token::Enum { name: \"Enum\" },\n                Token::BorrowedStr(\"Unit\"),\n                Token::Unit,\n                Token::StructEnd,\n            ],\n        );\n\n        // General case: tag field (\"tag\") is not the first field\n        assert_de_tokens(\n            &value,\n            &[\n                Token::Struct {\n                    name: \"InternallyTagged\",\n                    len: 2,\n                },\n                Token::Str(\"enum_\"),\n                Token::Enum { name: \"Enum\" },\n                Token::Str(\"Unit\"),\n                Token::Unit,\n                Token::Str(\"tag\"),\n                Token::Str(\"StructEnum\"),\n                Token::StructEnd,\n            ],\n        );\n        assert_de_tokens(\n            &value,\n            &[\n                Token::Struct {\n                    name: \"InternallyTagged\",\n                    len: 2,\n                },\n                Token::BorrowedStr(\"enum_\"),\n                Token::Enum { name: \"Enum\" },\n                Token::BorrowedStr(\"Unit\"),\n                Token::Unit,\n                Token::BorrowedStr(\"tag\"),\n                Token::BorrowedStr(\"StructEnum\"),\n                Token::StructEnd,\n            ],\n        );\n\n        // Special case: tag field (\"tag\") is the first field\n        assert_de_tokens(\n            &value,\n            &[\n                Token::Map { len: Some(2) },\n                Token::Str(\"tag\"),\n                Token::Str(\"StructEnum\"),\n                Token::Str(\"enum_\"),\n                Token::Enum { name: \"Enum\" },\n                Token::Str(\"Unit\"),\n                Token::Unit,\n                Token::MapEnd,\n            ],\n        );\n        assert_de_tokens(\n            &value,\n            &[\n                Token::Map { len: Some(2) },\n                Token::BorrowedStr(\"tag\"),\n                Token::BorrowedStr(\"StructEnum\"),\n                Token::BorrowedStr(\"enum_\"),\n                Token::Enum { name: \"Enum\" },\n                Token::BorrowedStr(\"Unit\"),\n                Token::Unit,\n                Token::MapEnd,\n            ],\n        );\n\n        // General case: tag field (\"tag\") is not the first field\n        assert_de_tokens(\n            &value,\n            &[\n                Token::Map { len: Some(2) },\n                Token::Str(\"enum_\"),\n                Token::Enum { name: \"Enum\" },\n                Token::Str(\"Unit\"),\n                Token::Unit,\n                Token::Str(\"tag\"),\n                Token::Str(\"StructEnum\"),\n                Token::MapEnd,\n            ],\n        );\n        assert_de_tokens(\n            &value,\n            &[\n                Token::Map { len: Some(2) },\n                Token::BorrowedStr(\"enum_\"),\n                Token::Enum { name: \"Enum\" },\n                Token::BorrowedStr(\"Unit\"),\n                Token::Unit,\n                Token::BorrowedStr(\"tag\"),\n                Token::BorrowedStr(\"StructEnum\"),\n                Token::MapEnd,\n            ],\n        );\n\n        assert_de_tokens(\n            &value,\n            &[\n                Token::Seq { len: Some(2) },\n                Token::Str(\"StructEnum\"),     // tag\n                Token::Enum { name: \"Enum\" }, // enum_\n                Token::Str(\"Unit\"),\n                Token::Unit,\n                Token::SeqEnd,\n            ],\n        );\n        assert_de_tokens(\n            &value,\n            &[\n                Token::Seq { len: Some(2) },\n                Token::BorrowedStr(\"StructEnum\"), // tag\n                Token::Enum { name: \"Enum\" },     // enum_\n                Token::BorrowedStr(\"Unit\"),\n                Token::Unit,\n                Token::SeqEnd,\n            ],\n        );\n    }\n}\n\n#[test]\nfn wrong_tag() {\n    assert_de_tokens_error::<InternallyTagged>(\n        &[Token::Map { len: Some(0) }, Token::MapEnd],\n        \"missing field `tag`\",\n    );\n\n    assert_de_tokens_error::<InternallyTagged>(\n        &[\n            Token::Map { len: Some(1) },\n            Token::Str(\"tag\"),\n            Token::Str(\"Z\"),\n            Token::MapEnd,\n        ],\n        \"unknown variant `Z`, expected one of \\\n        `Unit`, \\\n        `NewtypeUnit`, \\\n        `NewtypeUnitStruct`, \\\n        `NewtypeNewtype`, \\\n        `NewtypeMap`, \\\n        `NewtypeStruct`, \\\n        `NewtypeEnum`, \\\n        `Struct`, \\\n        `StructEnum`\",\n    );\n}\n\n#[test]\nfn untagged_variant() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(tag = \"tag\")]\n    enum InternallyTagged {\n        Tagged {\n            a: u8,\n        },\n        #[serde(untagged)]\n        Untagged {\n            tag: String,\n            b: u8,\n        },\n    }\n\n    assert_de_tokens(\n        &InternallyTagged::Tagged { a: 1 },\n        &[\n            Token::Map { len: Some(2) },\n            Token::Str(\"tag\"),\n            Token::Str(\"Tagged\"),\n            Token::Str(\"a\"),\n            Token::U8(1),\n            Token::MapEnd,\n        ],\n    );\n\n    assert_tokens(\n        &InternallyTagged::Tagged { a: 1 },\n        &[\n            Token::Struct {\n                name: \"InternallyTagged\",\n                len: 2,\n            },\n            Token::Str(\"tag\"),\n            Token::Str(\"Tagged\"),\n            Token::Str(\"a\"),\n            Token::U8(1),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_de_tokens(\n        &InternallyTagged::Untagged {\n            tag: \"Foo\".to_owned(),\n            b: 2,\n        },\n        &[\n            Token::Map { len: Some(2) },\n            Token::Str(\"tag\"),\n            Token::Str(\"Foo\"),\n            Token::Str(\"b\"),\n            Token::U8(2),\n            Token::MapEnd,\n        ],\n    );\n\n    assert_tokens(\n        &InternallyTagged::Untagged {\n            tag: \"Foo\".to_owned(),\n            b: 2,\n        },\n        &[\n            Token::Struct {\n                name: \"InternallyTagged\",\n                len: 2,\n            },\n            Token::Str(\"tag\"),\n            Token::Str(\"Foo\"),\n            Token::Str(\"b\"),\n            Token::U8(2),\n            Token::StructEnd,\n        ],\n    );\n\n    assert_tokens(\n        &InternallyTagged::Untagged {\n            tag: \"Tagged\".to_owned(),\n            b: 2,\n        },\n        &[\n            Token::Struct {\n                name: \"InternallyTagged\",\n                len: 2,\n            },\n            Token::Str(\"tag\"),\n            Token::Str(\"Tagged\"),\n            Token::Str(\"b\"),\n            Token::U8(2),\n            Token::StructEnd,\n        ],\n    );\n}\n\nmod string_and_bytes {\n    use super::*;\n\n    #[derive(Debug, PartialEq, Deserialize)]\n    #[serde(tag = \"tag\")]\n    enum InternallyTagged {\n        String {\n            string: String,\n        },\n        Bytes {\n            #[serde(with = \"bytes\")]\n            bytes: Vec<u8>,\n        },\n    }\n\n    #[test]\n    fn string_from_string() {\n        assert_de_tokens(\n            &InternallyTagged::String {\n                string: \"\\0\".to_owned(),\n            },\n            &[\n                Token::Struct {\n                    name: \"String\",\n                    len: 2,\n                },\n                Token::Str(\"tag\"),\n                Token::Str(\"String\"),\n                Token::Str(\"string\"),\n                Token::Str(\"\\0\"),\n                Token::StructEnd,\n            ],\n        );\n\n        assert_de_tokens(\n            &InternallyTagged::String {\n                string: \"\\0\".to_owned(),\n            },\n            &[\n                Token::Struct {\n                    name: \"String\",\n                    len: 2,\n                },\n                Token::Str(\"tag\"),\n                Token::Str(\"String\"),\n                Token::Str(\"string\"),\n                Token::String(\"\\0\"),\n                Token::StructEnd,\n            ],\n        );\n    }\n\n    #[test]\n    fn string_from_bytes() {\n        assert_de_tokens(\n            &InternallyTagged::String {\n                string: \"\\0\".to_owned(),\n            },\n            &[\n                Token::Struct {\n                    name: \"String\",\n                    len: 2,\n                },\n                Token::Str(\"tag\"),\n                Token::Str(\"String\"),\n                Token::Str(\"string\"),\n                Token::Bytes(b\"\\0\"),\n                Token::StructEnd,\n            ],\n        );\n\n        assert_de_tokens(\n            &InternallyTagged::String {\n                string: \"\\0\".to_owned(),\n            },\n            &[\n                Token::Struct {\n                    name: \"String\",\n                    len: 2,\n                },\n                Token::Str(\"tag\"),\n                Token::Str(\"String\"),\n                Token::Str(\"string\"),\n                Token::ByteBuf(b\"\\0\"),\n                Token::StructEnd,\n            ],\n        );\n    }\n\n    #[test]\n    fn bytes_from_string() {\n        assert_de_tokens(\n            &InternallyTagged::Bytes { bytes: vec![0] },\n            &[\n                Token::Struct {\n                    name: \"Bytes\",\n                    len: 2,\n                },\n                Token::Str(\"tag\"),\n                Token::Str(\"Bytes\"),\n                Token::Str(\"bytes\"),\n                Token::Str(\"\\0\"),\n                Token::StructEnd,\n            ],\n        );\n\n        assert_de_tokens(\n            &InternallyTagged::Bytes { bytes: vec![0] },\n            &[\n                Token::Struct {\n                    name: \"Bytes\",\n                    len: 2,\n                },\n                Token::Str(\"tag\"),\n                Token::Str(\"Bytes\"),\n                Token::Str(\"bytes\"),\n                Token::String(\"\\0\"),\n                Token::StructEnd,\n            ],\n        );\n    }\n\n    #[test]\n    fn bytes_from_bytes() {\n        assert_de_tokens(\n            &InternallyTagged::Bytes { bytes: vec![0] },\n            &[\n                Token::Struct {\n                    name: \"Bytes\",\n                    len: 2,\n                },\n                Token::Str(\"tag\"),\n                Token::Str(\"Bytes\"),\n                Token::Str(\"bytes\"),\n                Token::Bytes(b\"\\0\"),\n                Token::StructEnd,\n            ],\n        );\n\n        assert_de_tokens(\n            &InternallyTagged::Bytes { bytes: vec![0] },\n            &[\n                Token::Struct {\n                    name: \"Bytes\",\n                    len: 2,\n                },\n                Token::Str(\"tag\"),\n                Token::Str(\"Bytes\"),\n                Token::Str(\"bytes\"),\n                Token::ByteBuf(b\"\\0\"),\n                Token::StructEnd,\n            ],\n        );\n    }\n\n    #[test]\n    fn bytes_from_seq() {\n        assert_de_tokens(\n            &InternallyTagged::Bytes { bytes: vec![0] },\n            &[\n                Token::Struct {\n                    name: \"Bytes\",\n                    len: 2,\n                },\n                Token::Str(\"tag\"),\n                Token::Str(\"Bytes\"),\n                Token::Str(\"bytes\"),\n                Token::Seq { len: Some(1) },\n                Token::U8(0),\n                Token::SeqEnd,\n                Token::StructEnd,\n            ],\n        );\n    }\n}\n\n#[test]\nfn borrow() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(tag = \"tag\")]\n    enum Input<'a> {\n        Package { name: &'a str },\n    }\n\n    assert_tokens(\n        &Input::Package { name: \"borrowed\" },\n        &[\n            Token::Struct {\n                name: \"Input\",\n                len: 2,\n            },\n            Token::BorrowedStr(\"tag\"),\n            Token::BorrowedStr(\"Package\"),\n            Token::BorrowedStr(\"name\"),\n            Token::BorrowedStr(\"borrowed\"),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn with_skipped_conflict() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(tag = \"tag\")]\n    enum Data {\n        A,\n        #[serde(skip)]\n        #[allow(dead_code)]\n        B {\n            t: String,\n        },\n        C {\n            #[serde(default, skip)]\n            t: String,\n        },\n    }\n\n    let data = Data::C { t: String::new() };\n\n    assert_tokens(\n        &data,\n        &[\n            Token::Struct {\n                name: \"Data\",\n                len: 1,\n            },\n            Token::Str(\"tag\"),\n            Token::Str(\"C\"),\n            Token::StructEnd,\n        ],\n    );\n}\n\n#[test]\nfn containing_flatten() {\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    #[serde(tag = \"tag\")]\n    enum Data {\n        A {\n            a: i32,\n            #[serde(flatten)]\n            flat: Flat,\n        },\n    }\n\n    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n    struct Flat {\n        b: i32,\n    }\n\n    let data = Data::A {\n        a: 0,\n        flat: Flat { b: 0 },\n    };\n\n    assert_tokens(\n        &data,\n        &[\n            Token::Map { len: None },\n            Token::Str(\"tag\"),\n            Token::Str(\"A\"),\n            Token::Str(\"a\"),\n            Token::I32(0),\n            Token::Str(\"b\"),\n            Token::I32(0),\n            Token::MapEnd,\n        ],\n    );\n}\n\n#[test]\nfn unit_variant_with_unknown_fields() {\n    let value = InternallyTagged::Unit;\n\n    assert_de_tokens(\n        &value,\n        &[\n            Token::Map { len: None },\n            Token::Str(\"tag\"),\n            Token::Str(\"Unit\"),\n            Token::Str(\"b\"),\n            Token::I32(0),\n            Token::MapEnd,\n        ],\n    );\n\n    // Unknown elements are not allowed in sequences\n    assert_de_tokens_error::<InternallyTagged>(\n        &[\n            Token::Seq { len: None },\n            Token::Str(\"Unit\"), // tag\n            Token::I32(0),\n            Token::SeqEnd,\n        ],\n        \"invalid length 1, expected 0 elements in sequence\",\n    );\n}\n\n#[test]\nfn expecting_message() {\n    #[derive(Deserialize)]\n    #[serde(tag = \"tag\")]\n    #[serde(expecting = \"something strange...\")]\n    enum Enum {\n        InternallyTagged,\n    }\n\n    assert_de_tokens_error::<Enum>(\n        &[Token::Str(\"InternallyTagged\")],\n        r#\"invalid type: string \"InternallyTagged\", expected something strange...\"#,\n    );\n\n    // Check that #[serde(expecting = \"...\")] doesn't affect variant identifier error message\n    assert_de_tokens_error::<Enum>(\n        &[Token::Map { len: None }, Token::Str(\"tag\"), Token::Unit],\n        \"invalid type: unit value, expected variant identifier\",\n    );\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "c21cefd061e29e0079619a77022e9790fa3cdf0d",
    "func": "// Copyright 2019-2024 Tauri Programme within The Commons Conservancy\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\n\nuse serde::Serialize;\n\nuse crate::plugin::{Builder, TauriPlugin};\nuse crate::Manager;\nuse crate::{command, image::Image, ResourceId, Runtime, Webview};\n\n#[command(root = \"crate\")]\nfn new<R: Runtime>(\n  webview: Webview<R>,\n  rgba: Vec<u8>,\n  width: u32,\n  height: u32,\n) -> crate::Result<ResourceId> {\n  let image = Image::new_owned(rgba, width, height);\n  let mut resources_table = webview.resources_table();\n  let rid = resources_table.add(image);\n  Ok(rid)\n}\n\n#[cfg(any(feature = \"image-ico\", feature = \"image-png\"))]\n#[command(root = \"crate\")]\nfn from_bytes<R: Runtime>(webview: Webview<R>, bytes: Vec<u8>) -> crate::Result<ResourceId> {\n  let image = Image::from_bytes(&bytes)?.to_owned();\n  let mut resources_table = webview.resources_table();\n  let rid = resources_table.add(image);\n  Ok(rid)\n}\n\n#[cfg(not(any(feature = \"image-ico\", feature = \"image-png\")))]\n#[command(root = \"crate\")]\nfn from_bytes() -> std::result::Result<(), &'static str> {\n  Err(\"from_bytes is only supported if the `image-ico` or `image-png` Cargo features are enabled\")\n}\n\n#[cfg(any(feature = \"image-ico\", feature = \"image-png\"))]\n#[command(root = \"crate\")]\nfn from_path<R: Runtime>(\n  webview: Webview<R>,\n  path: std::path::PathBuf,\n) -> crate::Result<ResourceId> {\n  let image = Image::from_path(path)?.to_owned();\n  let mut resources_table = webview.resources_table();\n  let rid = resources_table.add(image);\n  Ok(rid)\n}\n\n#[cfg(not(any(feature = \"image-ico\", feature = \"image-png\")))]\n#[command(root = \"crate\")]\nfn from_path() -> std::result::Result<(), &'static str> {\n  Err(\"from_path is only supported if the `image-ico` or `image-png` Cargo features are enabled\")\n}\n\n#[command(root = \"crate\")]\nfn rgba<R: Runtime>(webview: Webview<R>, rid: ResourceId) -> crate::Result<Vec<u8>> {\n  let resources_table = webview.resources_table();\n  let image = resources_table.get::<Image<'_>>(rid)?;\n  Ok(image.rgba().to_vec())\n}\n\n#[derive(Serialize)]\nstruct Size {\n  width: u32,\n  height: u32,\n}\n\n#[command(root = \"crate\")]\nfn size<R: Runtime>(webview: Webview<R>, rid: ResourceId) -> crate::Result<Size> {\n  let resources_table = webview.resources_table();\n  let image = resources_table.get::<Image<'_>>(rid)?;\n  Ok(Size {\n    width: image.width(),\n    height: image.height(),\n  })\n}\n\n/// Initializes the plugin.\npub fn init<R: Runtime>() -> TauriPlugin<R> {\n  Builder::new(\"image\")\n    .invoke_handler(crate::generate_handler![\n      new, from_bytes, from_path, rgba, size\n    ])\n    .build()\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "3a96844d71158b36cb86f3b650a767b4bf1f881b",
    "func": "use crate::associations::BelongsTo;\nuse crate::backend::Backend;\nuse crate::deserialize::{\n    self, FromSqlRow, FromStaticSqlRow, Queryable, SqlTypeOrSelectable, StaticallySizedRow,\n};\nuse crate::expression::{\n    is_contained_in_group_by, AppearsOnTable, AsExpression, AsExpressionList, Expression,\n    IsContainedInGroupBy, MixedAggregates, QueryMetadata, Selectable, SelectableExpression,\n    TypedExpressionType, ValidGrouping,\n};\nuse crate::insertable::{CanInsertInSingleQuery, InsertValues, Insertable, InsertableOptionHelper};\nuse crate::query_builder::*;\nuse crate::query_dsl::load_dsl::CompatibleType;\nuse crate::query_source::*;\nuse crate::result::QueryResult;\nuse crate::row::*;\nuse crate::sql_types::{HasSqlType, IntoNullable, Nullable, OneIsNullable, SqlType};\nuse crate::util::{TupleAppend, TupleSize};\n\nimpl<T> TupleSize for T\nwhere\n    T: crate::sql_types::SingleValue,\n{\n    const SIZE: usize = 1;\n}\n\nmacro_rules! tuple_impls {\n    ($(\n        $Tuple:tt {\n            $(($idx:tt) -> $T:ident, $ST:ident, $TT:ident,)+\n        }\n    )+) => {\n        $(\n            impl<$($T),+, __DB> HasSqlType<($($T,)+)> for __DB where\n                $(__DB: HasSqlType<$T>),+,\n                __DB: Backend,\n            {\n                fn metadata(_: &mut __DB::MetadataLookup) -> __DB::TypeMetadata {\n                    unreachable!(\"Tuples should never implement `ToSql` directly\");\n                }\n            }\n\n            impl_from_sql_row!(($($T,)+), ($($ST,)+));\n\n\n            impl<$($T: Expression),+> Expression for ($($T,)+)\n            where ($($T::SqlType, )*): TypedExpressionType\n            {\n                type SqlType = ($(<$T as Expression>::SqlType,)+);\n            }\n\n            impl<$($T: TypedExpressionType,)*> TypedExpressionType for ($($T,)*) {}\n            impl<$($T: SqlType + TypedExpressionType,)*> TypedExpressionType for Nullable<($($T,)*)>\n            where ($($T,)*): SqlType\n            {\n            }\n\n            impl<$($T: SqlType,)*> IntoNullable for ($($T,)*)\n                where Self: SqlType,\n            {\n                type Nullable = Nullable<($($T,)*)>;\n            }\n\n            impl<$($T,)+ __DB> Selectable<__DB> for ($($T,)+)\n            where\n                __DB: Backend,\n                $($T: Selectable<__DB>),+,\n            {\n                type SelectExpression = ($($T::SelectExpression,)+);\n\n                fn construct_selection() -> Self::SelectExpression {\n                    ($($T::construct_selection(),)+)\n                }\n            }\n\n            impl<$($T: QueryFragment<__DB>),+, __DB: Backend> QueryFragment<__DB> for ($($T,)+) {\n                #[allow(unused_assignments)]\n                fn walk_ast<'b>(&'b self, mut out: AstPass<'_, 'b, __DB>) -> QueryResult<()>\n                {\n                    let mut needs_comma = false;\n                    $(\n                        if !self.$idx.is_noop(out.backend())? {\n                            if needs_comma {\n                                out.push_sql(\", \");\n                            }\n                            self.$idx.walk_ast(out.reborrow())?;\n                            needs_comma = true;\n                        }\n                    )+\n                    Ok(())\n                }\n            }\n\n            impl<$($T,)+ Tab> ColumnList for ($($T,)+)\n            where\n                $($T: ColumnList<Table = Tab>,)+\n            {\n                type Table = Tab;\n\n                fn walk_ast<__DB: Backend>(&self, mut out: AstPass<'_, '_, __DB>) -> QueryResult<()> {\n                    $(\n                        if $idx != 0 {\n                            out.push_sql(\", \");\n                        }\n                        self.$idx.walk_ast(out.reborrow())?;\n                    )+\n                    Ok(())\n                }\n            }\n\n            impl<$($T: QueryId),+> QueryId for ($($T,)+) {\n                type QueryId = ($($T::QueryId,)+);\n\n                const HAS_STATIC_QUERY_ID: bool = $($T::HAS_STATIC_QUERY_ID &&)+ true;\n            }\n\n            impl_valid_grouping_for_tuple_of_columns!($($T,)*);\n\n            impl<$($T,)+ Tab> UndecoratedInsertRecord<Tab> for ($($T,)+)\n            where\n                $($T: UndecoratedInsertRecord<Tab>,)+\n            {\n            }\n\n            impl<$($T,)+ __DB> CanInsertInSingleQuery<__DB> for ($($T,)+)\n            where\n                __DB: Backend,\n                $($T: CanInsertInSingleQuery<__DB>,)+\n            {\n                fn rows_to_insert(&self) -> Option<usize> {\n                    $(debug_assert_eq!(self.$idx.rows_to_insert(), Some(1));)+\n                    Some(1)\n                }\n            }\n\n            impl<$($T,)+ $($ST,)+ Tab> Insertable<Tab> for ($($T,)+)\n            where\n                $($T: Insertable<Tab, Values = ValuesClause<$ST, Tab>>,)+\n            {\n                type Values = ValuesClause<($($ST,)+), Tab>;\n\n                fn values(self) -> Self::Values {\n                    ValuesClause::new(($(self.$idx.values().values,)+))\n                }\n            }\n\n            impl<'a, $($T,)+ Tab> Insertable<Tab> for &'a ($($T,)+)\n            where\n                ($(&'a $T,)+): Insertable<Tab>,\n            {\n                type Values = <($(&'a $T,)+) as Insertable<Tab>>::Values;\n\n                fn values(self) -> Self::Values {\n                    ($(&self.$idx,)+).values()\n                }\n            }\n\n            #[allow(unused_assignments)]\n            impl<$($T,)+ Tab, __DB> InsertValues<__DB, Tab> for ($($T,)+)\n            where\n                Tab: Table,\n                __DB: Backend,\n                $($T: InsertValues<__DB, Tab>,)+\n            {\n                fn column_names(&self, mut out: AstPass<'_, '_, __DB>) -> QueryResult<()> {\n                    let mut needs_comma = false;\n                    $(\n                        let noop_element = self.$idx.is_noop(out.backend())?;\n                        if !noop_element {\n                            if needs_comma {\n                                out.push_sql(\", \");\n                            }\n                            self.$idx.column_names(out.reborrow())?;\n                            needs_comma = true;\n                        }\n                    )+\n                    Ok(())\n                }\n            }\n\n            impl<__T, $($ST,)* Tab> Insertable<Tab> for InsertableOptionHelper<__T, ($($ST,)*)>\n            where\n                __T: Insertable<Tab>,\n                __T::Values: Default,\n            {\n                type Values = __T::Values;\n\n                fn values(self) -> Self::Values {\n                    self.0.map(|v| v.values()).unwrap_or_default()\n                }\n            }\n\n            impl<$($T,)+ QS> SelectableExpression<QS> for ($($T,)+) where\n                $($T: SelectableExpression<QS>,)+\n                ($($T,)+): AppearsOnTable<QS>,\n            {\n            }\n\n            impl<$($T,)+ QS> AppearsOnTable<QS> for ($($T,)+) where\n                $($T: AppearsOnTable<QS>,)+\n                ($($T,)+): Expression,\n            {\n            }\n\n            impl<Target, $($T,)+> AsChangeset for ($($T,)+) where\n                $($T: AsChangeset<Target=Target>,)+\n                Target: QuerySource,\n            {\n                type Target = Target;\n                type Changeset = ($($T::Changeset,)+);\n\n                fn as_changeset(self) -> Self::Changeset {\n                    ($(self.$idx.as_changeset(),)+)\n                }\n            }\n\n            impl<$($T,)+ Parent> BelongsTo<Parent> for ($($T,)+) where\n                T0: BelongsTo<Parent>,\n            {\n                type ForeignKey = T0::ForeignKey;\n                type ForeignKeyColumn = T0::ForeignKeyColumn;\n\n                fn foreign_key(&self) -> Option<&Self::ForeignKey> {\n                    self.0.foreign_key()\n                }\n\n                fn foreign_key_column() -> Self::ForeignKeyColumn {\n                    T0::foreign_key_column()\n                }\n            }\n\n            impl<$($T,)+ Next> TupleAppend<Next> for ($($T,)+) {\n                type Output = ($($T,)+ Next);\n\n                #[allow(non_snake_case)]\n                fn tuple_append(self, next: Next) -> Self::Output {\n                    let ($($T,)+) = self;\n                    ($($T,)+ next)\n                }\n            }\n\n            impl<$($T,)+ ST> AsExpressionList<ST> for ($($T,)+) where\n                $($T: AsExpression<ST>,)+\n                ST: SqlType + TypedExpressionType,\n            {\n                type Expression = ($($T::Expression,)+);\n\n                fn as_expression_list(self) -> Self::Expression {\n                    ($(self.$idx.as_expression(),)+)\n                }\n            }\n\n            impl_sql_type!($($T,)*);\n\n            impl<$($T,)* __DB, $($ST,)*> Queryable<($($ST,)*), __DB> for ($($T,)*)\n            where __DB: Backend,\n                  Self: FromStaticSqlRow<($($ST,)*), __DB>,\n            {\n                type Row = Self;\n\n                fn build(row: Self::Row) -> deserialize::Result<Self> {\n                    Ok(row)\n                }\n            }\n\n            impl<__T, $($ST,)*  __DB> FromStaticSqlRow<Nullable<($($ST,)*)>, __DB> for Option<__T> where\n                __DB: Backend,\n                ($($ST,)*): SqlType,\n                __T: FromSqlRow<($($ST,)*), __DB>,\n            {\n\n                #[allow(non_snake_case, unused_variables, unused_mut)]\n                fn build_from_row<'a>(row: &impl Row<'a, __DB>)\n                                      -> deserialize::Result<Self>\n                {\n                    match <__T as FromSqlRow<($($ST,)*), __DB>>::build_from_row(row) {\n                        Ok(v) => Ok(Some(v)),\n                        Err(e) if e.is::<crate::result::UnexpectedNullError>() => Ok(None),\n                        Err(e) => Err(e)\n                    }\n                }\n            }\n\n            impl<__T,  __DB, $($ST,)*> Queryable<Nullable<($($ST,)*)>, __DB> for Option<__T>\n            where __DB: Backend,\n                  Self: FromStaticSqlRow<Nullable<($($ST,)*)>, __DB>,\n                  ($($ST,)*): SqlType,\n            {\n                type Row = Self;\n\n                fn build(row: Self::Row) -> deserialize::Result<Self> {\n                    Ok(row)\n                }\n            }\n\n            impl<$($T,)*> TupleSize for ($($T,)*)\n                where $($T: TupleSize,)*\n            {\n                const SIZE: usize = $($T::SIZE +)* 0;\n            }\n\n            impl<$($T,)*> TupleSize for Nullable<($($T,)*)>\n            where $($T: TupleSize,)*\n                  ($($T,)*): SqlType,\n            {\n                const SIZE: usize = $($T::SIZE +)* 0;\n            }\n\n            impl<$($T,)* __DB> QueryMetadata<($($T,)*)> for __DB\n            where __DB: Backend,\n                 $(__DB: QueryMetadata<$T>,)*\n            {\n                fn row_metadata(lookup: &mut Self::MetadataLookup, row: &mut Vec<Option<__DB::TypeMetadata>>) {\n                    $(\n                        <__DB as QueryMetadata<$T>>::row_metadata(lookup, row);\n                    )*\n                }\n            }\n\n            impl<$($T,)* __DB> QueryMetadata<Nullable<($($T,)*)>> for __DB\n            where __DB: Backend,\n                  $(__DB: QueryMetadata<$T>,)*\n            {\n                fn row_metadata(lookup: &mut Self::MetadataLookup, row: &mut Vec<Option<__DB::TypeMetadata>>) {\n                    $(\n                        <__DB as QueryMetadata<$T>>::row_metadata(lookup, row);\n                    )*\n                }\n            }\n\n            impl<$($T,)* __DB> deserialize::QueryableByName< __DB> for ($($T,)*)\n            where __DB: Backend,\n            $($T: deserialize::QueryableByName<__DB>,)*\n            {\n                fn build<'a>(row: &impl NamedRow<'a, __DB>) -> deserialize::Result<Self> {\n                    Ok(($(\n                        <$T as deserialize::QueryableByName<__DB>>::build(row)?,\n                    )*))\n                }\n            }\n\n            impl<__T, $($ST,)* __DB> CompatibleType<__T, __DB> for ($($ST,)*)\n            where\n                __DB: Backend,\n                __T: FromSqlRow<($($ST,)*), __DB>,\n            {\n                type SqlType = Self;\n            }\n\n            impl<__T, $($ST,)* __DB> CompatibleType<Option<__T>, __DB> for Nullable<($($ST,)*)>\n            where\n                __DB: Backend,\n                ($($ST,)*): CompatibleType<__T, __DB>\n            {\n                type SqlType = Nullable<<($($ST,)*) as CompatibleType<__T, __DB>>::SqlType>;\n            }\n\n            impl<$($ST,)*> SqlTypeOrSelectable for ($($ST,)*)\n            where $($ST: SqlTypeOrSelectable,)*\n            {}\n\n            impl<$($ST,)*> SqlTypeOrSelectable for Nullable<($($ST,)*)>\n            where ($($ST,)*): SqlTypeOrSelectable\n            {}\n        )+\n    }\n}\n\nmacro_rules! impl_from_sql_row {\n    (($T1: ident,), ($ST1: ident,)) => {\n        impl<$T1, $ST1, __DB> crate::deserialize::FromStaticSqlRow<($ST1,), __DB> for ($T1,) where\n            __DB: Backend,\n            $ST1: CompatibleType<$T1, __DB>,\n            $T1: FromSqlRow<<$ST1 as CompatibleType<$T1, __DB>>::SqlType, __DB>,\n        {\n\n            #[allow(non_snake_case, unused_variables, unused_mut)]\n            fn build_from_row<'a>(row: &impl Row<'a, __DB>)\n                                                       -> deserialize::Result<Self>\n            {\n                Ok(($T1::build_from_row(row)?,))\n            }\n        }\n    };\n    (($T1: ident, $($T: ident,)*), ($ST1: ident, $($ST: ident,)*)) => {\n        impl<$T1, $($T,)* $($ST,)* __DB> FromSqlRow<($($ST,)* crate::sql_types::Untyped), __DB> for ($($T,)* $T1)\n        where __DB: Backend,\n              $T1: FromSqlRow<crate::sql_types::Untyped, __DB>,\n            $(\n                $T: FromSqlRow<$ST, __DB> + StaticallySizedRow<$ST, __DB>,\n        )*\n        {\n            #[allow(non_snake_case, unused_variables, unused_mut)]\n            fn build_from_row<'a>(full_row: &impl Row<'a, __DB>)\n                -> deserialize::Result<Self>\n            {\n                let field_count = full_row.field_count();\n\n                let mut static_field_count = 0;\n                $(\n                    let row = full_row.partial_row(static_field_count..static_field_count + $T::FIELD_COUNT);\n                    static_field_count += $T::FIELD_COUNT;\n                    let $T = $T::build_from_row(&row)?;\n                )*\n\n                let row = full_row.partial_row(static_field_count..field_count);\n\n                Ok(($($T,)* $T1::build_from_row(&row)?,))\n            }\n        }\n\n        impl<$T1, $ST1, $($T,)* $($ST,)* __DB> FromStaticSqlRow<($($ST,)* $ST1,), __DB> for ($($T,)* $T1,) where\n            __DB: Backend,\n            $ST1: CompatibleType<$T1, __DB>,\n            $T1: FromSqlRow<<$ST1 as CompatibleType<$T1, __DB>>::SqlType, __DB>,\n            $(\n                $ST: CompatibleType<$T, __DB>,\n                $T: FromSqlRow<<$ST as CompatibleType<$T, __DB>>::SqlType, __DB> + StaticallySizedRow<<$ST as CompatibleType<$T, __DB>>::SqlType, __DB>,\n            )*\n\n        {\n\n            #[allow(non_snake_case, unused_variables, unused_mut)]\n            fn build_from_row<'a>(full_row: &impl Row<'a, __DB>)\n                -> deserialize::Result<Self>\n            {\n                let field_count = full_row.field_count();\n\n                let mut static_field_count = 0;\n                $(\n                    let row = full_row.partial_row(static_field_count..static_field_count + $T::FIELD_COUNT);\n                    static_field_count += $T::FIELD_COUNT;\n                    let $T = <$T as FromSqlRow<<$ST as CompatibleType<$T, __DB>>::SqlType, __DB>>::build_from_row(&row)?;\n                )*\n\n                let row = full_row.partial_row(static_field_count..field_count);\n\n                Ok(($($T,)* $T1::build_from_row(&row)?,))\n            }\n        }\n    }\n}\n\nmacro_rules! impl_valid_grouping_for_tuple_of_columns {\n    ($T1: ident, $($T: ident,)+) => {\n        impl<$T1, $($T,)* __GroupByClause> ValidGrouping<__GroupByClause> for ($T1, $($T,)*)\n        where\n            $T1: ValidGrouping<__GroupByClause>,\n            ($($T,)*): ValidGrouping<__GroupByClause>,\n            $T1::IsAggregate: MixedAggregates<<($($T,)*) as ValidGrouping<__GroupByClause>>::IsAggregate>,\n        {\n            type IsAggregate = <$T1::IsAggregate as MixedAggregates<<($($T,)*) as ValidGrouping<__GroupByClause>>::IsAggregate>>::Output;\n        }\n\n        impl<$T1, $($T,)* Col> IsContainedInGroupBy<Col> for ($T1, $($T,)*)\n        where Col: Column,\n              ($($T,)*): IsContainedInGroupBy<Col>,\n              $T1: IsContainedInGroupBy<Col>,\n              $T1::Output: is_contained_in_group_by::IsAny<<($($T,)*) as IsContainedInGroupBy<Col>>::Output>\n        {\n            type Output = <$T1::Output as is_contained_in_group_by::IsAny<<($($T,)*) as IsContainedInGroupBy<Col>>::Output>>::Output;\n        }\n    };\n    ($T1: ident,) => {\n        impl<$T1, Col> IsContainedInGroupBy<Col> for ($T1,)\n        where Col: Column,\n              $T1: IsContainedInGroupBy<Col>\n        {\n            type Output = <$T1 as IsContainedInGroupBy<Col>>::Output;\n        }\n\n        impl<$T1, __GroupByClause> ValidGrouping<__GroupByClause> for ($T1,)\n            where $T1: ValidGrouping<__GroupByClause>\n        {\n            type IsAggregate = $T1::IsAggregate;\n        }\n    };\n}\n\nmacro_rules! impl_sql_type {\n    (\n        @build\n        start_ts = [$($ST: ident,)*],\n        ts = [$T1: ident,],\n        bounds = [$($bounds: tt)*],\n        is_null = [$($is_null: tt)*],\n    )=> {\n        impl<$($ST,)*> SqlType for ($($ST,)*)\n        where\n            $($ST: SqlType,)*\n            $($bounds)*\n            $T1::IsNull: OneIsNullable<$($is_null)*>,\n        {\n            type IsNull = <$T1::IsNull as OneIsNullable<$($is_null)*>>::Out;\n        }\n\n    };\n    (\n        @build\n        start_ts = [$($ST: ident,)*],\n        ts = [$T1: ident, $($T: ident,)+],\n        bounds = [$($bounds: tt)*],\n        is_null = [$($is_null: tt)*],\n    )=> {\n        impl_sql_type!{\n            @build\n            start_ts = [$($ST,)*],\n            ts = [$($T,)*],\n            bounds = [$($bounds)* $T1::IsNull: OneIsNullable<$($is_null)*>,],\n            is_null = [<$T1::IsNull as OneIsNullable<$($is_null)*>>::Out],\n        }\n    };\n    ($T1: ident, $($T: ident,)+) => {\n        impl_sql_type!{\n            @build\n            start_ts = [$T1, $($T,)*],\n            ts = [$($T,)*],\n            bounds = [],\n            is_null = [$T1::IsNull],\n        }\n    };\n    ($T1: ident,) => {\n        impl<$T1> SqlType for ($T1,)\n        where $T1: SqlType,\n        {\n            type IsNull = $T1::IsNull;\n        }\n    }\n}\n\ndiesel_derives::__diesel_for_each_tuple!(tuple_impls);\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "e83063e041212191bb5153921852af1befdf43f2",
    "func": "#![warn(rust_2018_idioms)]\n\nuse tokio_stream::StreamExt;\nuse tokio_test::assert_ok;\nuse tokio_util::codec::{Decoder, Encoder, Framed, FramedParts};\n\nuse bytes::{Buf, BufMut, BytesMut};\nuse std::io::{self, Read};\nuse std::pin::Pin;\nuse std::task::{Context, Poll};\n\nconst INITIAL_CAPACITY: usize = 8 * 1024;\n\n/// Encode and decode u32 values.\n#[derive(Default)]\nstruct U32Codec {\n    read_bytes: usize,\n}\n\nimpl Decoder for U32Codec {\n    type Item = u32;\n    type Error = io::Error;\n\n    fn decode(&mut self, buf: &mut BytesMut) -> io::Result<Option<u32>> {\n        if buf.len() < 4 {\n            return Ok(None);\n        }\n\n        let n = buf.split_to(4).get_u32();\n        self.read_bytes += 4;\n        Ok(Some(n))\n    }\n}\n\nimpl Encoder<u32> for U32Codec {\n    type Error = io::Error;\n\n    fn encode(&mut self, item: u32, dst: &mut BytesMut) -> io::Result<()> {\n        // Reserve space\n        dst.reserve(4);\n        dst.put_u32(item);\n        Ok(())\n    }\n}\n\n/// Encode and decode u64 values.\n#[derive(Default)]\nstruct U64Codec {\n    read_bytes: usize,\n}\n\nimpl Decoder for U64Codec {\n    type Item = u64;\n    type Error = io::Error;\n\n    fn decode(&mut self, buf: &mut BytesMut) -> io::Result<Option<u64>> {\n        if buf.len() < 8 {\n            return Ok(None);\n        }\n\n        let n = buf.split_to(8).get_u64();\n        self.read_bytes += 8;\n        Ok(Some(n))\n    }\n}\n\nimpl Encoder<u64> for U64Codec {\n    type Error = io::Error;\n\n    fn encode(&mut self, item: u64, dst: &mut BytesMut) -> io::Result<()> {\n        // Reserve space\n        dst.reserve(8);\n        dst.put_u64(item);\n        Ok(())\n    }\n}\n\n/// This value should never be used\nstruct DontReadIntoThis;\n\nimpl Read for DontReadIntoThis {\n    fn read(&mut self, _: &mut [u8]) -> io::Result<usize> {\n        Err(io::Error::new(\n            io::ErrorKind::Other,\n            \"Read into something you weren't supposed to.\",\n        ))\n    }\n}\n\nimpl tokio::io::AsyncRead for DontReadIntoThis {\n    fn poll_read(\n        self: Pin<&mut Self>,\n        _cx: &mut Context<'_>,\n        _buf: &mut tokio::io::ReadBuf<'_>,\n    ) -> Poll<io::Result<()>> {\n        unreachable!()\n    }\n}\n\n#[tokio::test]\nasync fn can_read_from_existing_buf() {\n    let mut parts = FramedParts::new(DontReadIntoThis, U32Codec::default());\n    parts.read_buf = BytesMut::from(&[0, 0, 0, 42][..]);\n\n    let mut framed = Framed::from_parts(parts);\n    let num = assert_ok!(framed.next().await.unwrap());\n\n    assert_eq!(num, 42);\n    assert_eq!(framed.codec().read_bytes, 4);\n}\n\n#[tokio::test]\nasync fn can_read_from_existing_buf_after_codec_changed() {\n    let mut parts = FramedParts::new(DontReadIntoThis, U32Codec::default());\n    parts.read_buf = BytesMut::from(&[0, 0, 0, 42, 0, 0, 0, 0, 0, 0, 0, 84][..]);\n\n    let mut framed = Framed::from_parts(parts);\n    let num = assert_ok!(framed.next().await.unwrap());\n\n    assert_eq!(num, 42);\n    assert_eq!(framed.codec().read_bytes, 4);\n\n    let mut framed = framed.map_codec(|codec| U64Codec {\n        read_bytes: codec.read_bytes,\n    });\n    let num = assert_ok!(framed.next().await.unwrap());\n\n    assert_eq!(num, 84);\n    assert_eq!(framed.codec().read_bytes, 12);\n}\n\n#[test]\nfn external_buf_grows_to_init() {\n    let mut parts = FramedParts::new(DontReadIntoThis, U32Codec::default());\n    parts.read_buf = BytesMut::from(&[0, 0, 0, 42][..]);\n\n    let framed = Framed::from_parts(parts);\n    let FramedParts { read_buf, .. } = framed.into_parts();\n\n    assert_eq!(read_buf.capacity(), INITIAL_CAPACITY);\n}\n\n#[test]\nfn external_buf_does_not_shrink() {\n    let mut parts = FramedParts::new(DontReadIntoThis, U32Codec::default());\n    parts.read_buf = BytesMut::from(&vec![0; INITIAL_CAPACITY * 2][..]);\n\n    let framed = Framed::from_parts(parts);\n    let FramedParts { read_buf, .. } = framed.into_parts();\n\n    assert_eq!(read_buf.capacity(), INITIAL_CAPACITY * 2);\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "922ec26449e016c66d7d51ba9a6574f1570808d1",
    "func": "use bevy_ecs::{component::Component, prelude::*, world::World};\nuse bevy_tasks::{ComputeTaskPool, TaskPool};\nuse criterion::{black_box, criterion_group, criterion_main, BenchmarkId, Criterion};\n\ncriterion_group!(benches, empty_archetypes);\ncriterion_main!(benches);\n\n#[derive(Component)]\nstruct A<const N: u16>(f32);\n\nfn iter(\n    query: Query<(\n        &A<0>,\n        &A<1>,\n        &A<2>,\n        &A<3>,\n        &A<4>,\n        &A<5>,\n        &A<6>,\n        &A<7>,\n        &A<8>,\n        &A<9>,\n        &A<10>,\n        &A<11>,\n        &A<12>,\n    )>,\n) {\n    for comp in query.iter() {\n        black_box(comp);\n    }\n}\n\nfn for_each(\n    query: Query<(\n        &A<0>,\n        &A<1>,\n        &A<2>,\n        &A<3>,\n        &A<4>,\n        &A<5>,\n        &A<6>,\n        &A<7>,\n        &A<8>,\n        &A<9>,\n        &A<10>,\n        &A<11>,\n        &A<12>,\n    )>,\n) {\n    query.for_each(|comp| {\n        black_box(comp);\n    });\n}\n\nfn par_for_each(\n    task_pool: Res<ComputeTaskPool>,\n    query: Query<(\n        &A<0>,\n        &A<1>,\n        &A<2>,\n        &A<3>,\n        &A<4>,\n        &A<5>,\n        &A<6>,\n        &A<7>,\n        &A<8>,\n        &A<9>,\n        &A<10>,\n        &A<11>,\n        &A<12>,\n    )>,\n) {\n    query.par_for_each(&*task_pool, 64, |comp| {\n        black_box(comp);\n    });\n}\n\nfn setup(parallel: bool, setup: impl FnOnce(&mut Schedule)) -> (World, Schedule) {\n    let mut world = World::new();\n    let mut schedule = Schedule::default();\n    if parallel {\n        world.insert_resource(ComputeTaskPool(TaskPool::default()));\n    }\n    setup(&mut schedule);\n    (world, schedule)\n}\n\n/// create `count` entities with distinct archetypes\nfn add_archetypes(world: &mut World, count: u16) {\n    for i in 0..count {\n        let mut e = world.spawn();\n        e.insert(A::<0>(1.0));\n        e.insert(A::<1>(1.0));\n        e.insert(A::<2>(1.0));\n        e.insert(A::<3>(1.0));\n        e.insert(A::<4>(1.0));\n        e.insert(A::<5>(1.0));\n        e.insert(A::<6>(1.0));\n        e.insert(A::<7>(1.0));\n        e.insert(A::<8>(1.0));\n        e.insert(A::<9>(1.0));\n        e.insert(A::<10>(1.0));\n        e.insert(A::<11>(1.0));\n        e.insert(A::<12>(1.0));\n        if i & 1 << 1 != 0 {\n            e.insert(A::<13>(1.0));\n        }\n        if i & 1 << 2 != 0 {\n            e.insert(A::<14>(1.0));\n        }\n        if i & 1 << 3 != 0 {\n            e.insert(A::<15>(1.0));\n        }\n        if i & 1 << 4 != 0 {\n            e.insert(A::<16>(1.0));\n        }\n        if i & 1 << 5 != 0 {\n            e.insert(A::<18>(1.0));\n        }\n        if i & 1 << 6 != 0 {\n            e.insert(A::<19>(1.0));\n        }\n        if i & 1 << 7 != 0 {\n            e.insert(A::<20>(1.0));\n        }\n        if i & 1 << 8 != 0 {\n            e.insert(A::<21>(1.0));\n        }\n        if i & 1 << 9 != 0 {\n            e.insert(A::<22>(1.0));\n        }\n        if i & 1 << 10 != 0 {\n            e.insert(A::<23>(1.0));\n        }\n        if i & 1 << 11 != 0 {\n            e.insert(A::<24>(1.0));\n        }\n        if i & 1 << 12 != 0 {\n            e.insert(A::<25>(1.0));\n        }\n        if i & 1 << 13 != 0 {\n            e.insert(A::<26>(1.0));\n        }\n        if i & 1 << 14 != 0 {\n            e.insert(A::<27>(1.0));\n        }\n        if i & 1 << 15 != 0 {\n            e.insert(A::<28>(1.0));\n        }\n    }\n}\n\nfn empty_archetypes(criterion: &mut Criterion) {\n    let mut group = criterion.benchmark_group(\"empty_archetypes\");\n    for archetype_count in [10, 100, 500, 1000, 2000, 5000, 10000] {\n        let (mut world, mut schedule) = setup(true, |schedule| {\n            schedule.add_systems(iter);\n        });\n        add_archetypes(&mut world, archetype_count);\n        world.clear_entities();\n        let mut e = world.spawn();\n        e.insert(A::<0>(1.0));\n        e.insert(A::<1>(1.0));\n        e.insert(A::<2>(1.0));\n        e.insert(A::<3>(1.0));\n        e.insert(A::<4>(1.0));\n        e.insert(A::<5>(1.0));\n        e.insert(A::<6>(1.0));\n        e.insert(A::<7>(1.0));\n        e.insert(A::<8>(1.0));\n        e.insert(A::<9>(1.0));\n        e.insert(A::<10>(1.0));\n        e.insert(A::<11>(1.0));\n        e.insert(A::<12>(1.0));\n        schedule.run(&mut world);\n        group.bench_with_input(\n            BenchmarkId::new(\"iter\", archetype_count),\n            &archetype_count,\n            |bencher, &_| {\n                bencher.iter(|| {\n                    schedule.run(&mut world);\n                })\n            },\n        );\n    }\n    for archetype_count in [10, 100, 500, 1000, 2000, 5000, 10000] {\n        let (mut world, mut schedule) = setup(true, |schedule| {\n            schedule.add_systems(for_each);\n        });\n        add_archetypes(&mut world, archetype_count);\n        world.clear_entities();\n        let mut e = world.spawn();\n        e.insert(A::<0>(1.0));\n        e.insert(A::<1>(1.0));\n        e.insert(A::<2>(1.0));\n        e.insert(A::<3>(1.0));\n        e.insert(A::<4>(1.0));\n        e.insert(A::<5>(1.0));\n        e.insert(A::<6>(1.0));\n        e.insert(A::<7>(1.0));\n        e.insert(A::<8>(1.0));\n        e.insert(A::<9>(1.0));\n        e.insert(A::<10>(1.0));\n        e.insert(A::<11>(1.0));\n        e.insert(A::<12>(1.0));\n        schedule.run(&mut world);\n        group.bench_with_input(\n            BenchmarkId::new(\"for_each\", archetype_count),\n            &archetype_count,\n            |bencher, &_| {\n                bencher.iter(|| {\n                    schedule.run(&mut world);\n                })\n            },\n        );\n    }\n    for archetype_count in [10, 100, 500, 1000, 2000, 5000, 10000] {\n        let (mut world, mut schedule) = setup(true, |schedule| {\n            schedule.add_systems(par_for_each);\n        });\n        add_archetypes(&mut world, archetype_count);\n        world.clear_entities();\n        let mut e = world.spawn();\n        e.insert(A::<0>(1.0));\n        e.insert(A::<1>(1.0));\n        e.insert(A::<2>(1.0));\n        e.insert(A::<3>(1.0));\n        e.insert(A::<4>(1.0));\n        e.insert(A::<5>(1.0));\n        e.insert(A::<6>(1.0));\n        e.insert(A::<7>(1.0));\n        e.insert(A::<8>(1.0));\n        e.insert(A::<9>(1.0));\n        e.insert(A::<10>(1.0));\n        e.insert(A::<11>(1.0));\n        e.insert(A::<12>(1.0));\n        schedule.run(&mut world);\n        group.bench_with_input(\n            BenchmarkId::new(\"par_for_each\", archetype_count),\n            &archetype_count,\n            |bencher, &_| {\n                bencher.iter(|| {\n                    schedule.run(&mut world);\n                })\n            },\n        );\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "ccfe71305c745470d4739d1c79f56067f6270938",
    "func": "use crate::*;\nuse std::ops::Deref;\n\nconst QUOTE: Quote = Quote(b'\"', b'\"');\n\npub trait QueryBuilder:\n    QuotedBuilder + EscapeBuilder + TableRefBuilder + OperLeftAssocDecider + PrecedenceDecider\n{\n    /// The type of placeholder the builder uses for values, and whether it is numbered.\n    fn placeholder(&self) -> (&str, bool) {\n        (\"?\", false)\n    }\n\n    /// Prefix for tuples in VALUES list (e.g. ROW for Mysql)\n    fn values_list_tuple_prefix(&self) -> &str {\n        \"\"\n    }\n\n    /// Translate [`InsertStatement`] into SQL statement.\n    fn prepare_insert_statement(&self, insert: &InsertStatement, sql: &mut dyn SqlWriter) {\n        self.prepare_insert(insert.replace, sql);\n\n        if let Some(table) = &insert.table {\n            write!(sql, \" INTO \").unwrap();\n            self.prepare_table_ref(table, sql);\n        }\n\n        if insert.default_values.is_some() && insert.columns.is_empty() && insert.source.is_none() {\n            self.prepare_output(&insert.returning, sql);\n            write!(sql, \" \").unwrap();\n            let num_rows = insert.default_values.unwrap();\n            self.insert_default_values(num_rows, sql);\n        } else {\n            write!(sql, \" \").unwrap();\n            write!(sql, \"(\").unwrap();\n            insert.columns.iter().fold(true, |first, col| {\n                if !first {\n                    write!(sql, \", \").unwrap()\n                }\n                col.prepare(sql.as_writer(), self.quote());\n                false\n            });\n            write!(sql, \")\").unwrap();\n\n            self.prepare_output(&insert.returning, sql);\n\n            if let Some(source) = &insert.source {\n                write!(sql, \" \").unwrap();\n                match source {\n                    InsertValueSource::Values(values) => {\n                        write!(sql, \"VALUES \").unwrap();\n                        values.iter().fold(true, |first, row| {\n                            if !first {\n                                write!(sql, \", \").unwrap()\n                            }\n                            write!(sql, \"(\").unwrap();\n                            row.iter().fold(true, |first, col| {\n                                if !first {\n                                    write!(sql, \", \").unwrap()\n                                }\n                                self.prepare_simple_expr(col, sql);\n                                false\n                            });\n                            write!(sql, \")\").unwrap();\n                            false\n                        });\n                    }\n                    InsertValueSource::Select(select_query) => {\n                        self.prepare_select_statement(select_query.deref(), sql);\n                    }\n                }\n            }\n        }\n\n        self.prepare_on_conflict(&insert.on_conflict, sql);\n\n        self.prepare_returning(&insert.returning, sql);\n    }\n\n    fn prepare_union_statement(\n        &self,\n        union_type: UnionType,\n        select_statement: &SelectStatement,\n        sql: &mut dyn SqlWriter,\n    ) {\n        match union_type {\n            UnionType::Intersect => write!(sql, \" INTERSECT (\").unwrap(),\n            UnionType::Distinct => write!(sql, \" UNION (\").unwrap(),\n            UnionType::Except => write!(sql, \" EXCEPT (\").unwrap(),\n            UnionType::All => write!(sql, \" UNION ALL (\").unwrap(),\n        }\n        self.prepare_select_statement(select_statement, sql);\n        write!(sql, \")\").unwrap();\n    }\n\n    /// Translate [`SelectStatement`] into SQL statement.\n    fn prepare_select_statement(&self, select: &SelectStatement, sql: &mut dyn SqlWriter) {\n        write!(sql, \"SELECT \").unwrap();\n\n        if let Some(distinct) = &select.distinct {\n            self.prepare_select_distinct(distinct, sql);\n            write!(sql, \" \").unwrap();\n        }\n\n        select.selects.iter().fold(true, |first, expr| {\n            if !first {\n                write!(sql, \", \").unwrap()\n            }\n            self.prepare_select_expr(expr, sql);\n            false\n        });\n\n        if !select.from.is_empty() {\n            write!(sql, \" FROM \").unwrap();\n            select.from.iter().fold(true, |first, table_ref| {\n                if !first {\n                    write!(sql, \", \").unwrap()\n                }\n                self.prepare_table_ref(table_ref, sql);\n                false\n            });\n            self.prepare_index_hints(select, sql);\n        }\n\n        if !select.join.is_empty() {\n            for expr in select.join.iter() {\n                write!(sql, \" \").unwrap();\n                self.prepare_join_expr(expr, sql);\n            }\n        }\n\n        self.prepare_condition(&select.r#where, \"WHERE\", sql);\n\n        if !select.groups.is_empty() {\n            write!(sql, \" GROUP BY \").unwrap();\n            select.groups.iter().fold(true, |first, expr| {\n                if !first {\n                    write!(sql, \", \").unwrap()\n                }\n                self.prepare_simple_expr(expr, sql);\n                false\n            });\n        }\n\n        self.prepare_condition(&select.having, \"HAVING\", sql);\n\n        if !select.unions.is_empty() {\n            select.unions.iter().for_each(|(union_type, query)| {\n                self.prepare_union_statement(*union_type, query, sql);\n            });\n        }\n\n        if !select.orders.is_empty() {\n            write!(sql, \" ORDER BY \").unwrap();\n            select.orders.iter().fold(true, |first, expr| {\n                if !first {\n                    write!(sql, \", \").unwrap()\n                }\n                self.prepare_order_expr(expr, sql);\n                false\n            });\n        }\n\n        self.prepare_select_limit_offset(select, sql);\n\n        if let Some(lock) = &select.lock {\n            write!(sql, \" \").unwrap();\n            self.prepare_select_lock(lock, sql);\n        }\n\n        if let Some((name, query)) = &select.window {\n            write!(sql, \" WINDOW \").unwrap();\n            name.prepare(sql.as_writer(), self.quote());\n            write!(sql, \" AS \").unwrap();\n            self.prepare_window_statement(query, sql);\n        }\n    }\n\n    // Translate the LIMIT and OFFSET expression in [`SelectStatement`]\n    fn prepare_select_limit_offset(&self, select: &SelectStatement, sql: &mut dyn SqlWriter) {\n        if let Some(limit) = &select.limit {\n            write!(sql, \" LIMIT \").unwrap();\n            self.prepare_value(limit, sql);\n        }\n\n        if let Some(offset) = &select.offset {\n            write!(sql, \" OFFSET \").unwrap();\n            self.prepare_value(offset, sql);\n        }\n    }\n\n    /// Translate [`UpdateStatement`] into SQL statement.\n    fn prepare_update_statement(&self, update: &UpdateStatement, sql: &mut dyn SqlWriter) {\n        write!(sql, \"UPDATE \").unwrap();\n\n        if let Some(table) = &update.table {\n            self.prepare_table_ref(table, sql);\n        }\n\n        write!(sql, \" SET \").unwrap();\n\n        update.values.iter().fold(true, |first, row| {\n            if !first {\n                write!(sql, \", \").unwrap()\n            }\n            let (col, v) = row;\n            col.prepare(sql.as_writer(), self.quote());\n            write!(sql, \" = \").unwrap();\n            self.prepare_simple_expr(v, sql);\n            false\n        });\n\n        self.prepare_output(&update.returning, sql);\n\n        self.prepare_condition(&update.r#where, \"WHERE\", sql);\n\n        self.prepare_update_order_by(update, sql);\n\n        self.prepare_update_limit(update, sql);\n\n        self.prepare_returning(&update.returning, sql);\n    }\n\n    /// Translate ORDER BY expression in [`UpdateStatement`].\n    fn prepare_update_order_by(&self, update: &UpdateStatement, sql: &mut dyn SqlWriter) {\n        if !update.orders.is_empty() {\n            write!(sql, \" ORDER BY \").unwrap();\n            update.orders.iter().fold(true, |first, expr| {\n                if !first {\n                    write!(sql, \", \").unwrap();\n                }\n                self.prepare_order_expr(expr, sql);\n                false\n            });\n        }\n    }\n\n    /// Translate LIMIT expression in [`UpdateStatement`].\n    fn prepare_update_limit(&self, update: &UpdateStatement, sql: &mut dyn SqlWriter) {\n        if let Some(limit) = &update.limit {\n            write!(sql, \" LIMIT \").unwrap();\n            self.prepare_value(limit, sql);\n        }\n    }\n\n    /// Translate [`DeleteStatement`] into SQL statement.\n    fn prepare_delete_statement(&self, delete: &DeleteStatement, sql: &mut dyn SqlWriter) {\n        write!(sql, \"DELETE \").unwrap();\n\n        if let Some(table) = &delete.table {\n            write!(sql, \"FROM \").unwrap();\n            self.prepare_table_ref(table, sql);\n        }\n\n        self.prepare_output(&delete.returning, sql);\n\n        self.prepare_condition(&delete.r#where, \"WHERE\", sql);\n\n        self.prepare_delete_order_by(delete, sql);\n\n        self.prepare_delete_limit(delete, sql);\n\n        self.prepare_returning(&delete.returning, sql);\n    }\n\n    /// Translate ORDER BY expression in [`DeleteStatement`].\n    fn prepare_delete_order_by(&self, delete: &DeleteStatement, sql: &mut dyn SqlWriter) {\n        if !delete.orders.is_empty() {\n            write!(sql, \" ORDER BY \").unwrap();\n            delete.orders.iter().fold(true, |first, expr| {\n                if !first {\n                    write!(sql, \", \").unwrap();\n                }\n                self.prepare_order_expr(expr, sql);\n                false\n            });\n        }\n    }\n\n    /// Translate LIMIT expression in [`DeleteStatement`].\n    fn prepare_delete_limit(&self, delete: &DeleteStatement, sql: &mut dyn SqlWriter) {\n        if let Some(limit) = &delete.limit {\n            write!(sql, \" LIMIT \").unwrap();\n            self.prepare_value(limit, sql);\n        }\n    }\n\n    /// Translate [`SimpleExpr`] into SQL statement.\n    fn prepare_simple_expr(&self, simple_expr: &SimpleExpr, sql: &mut dyn SqlWriter) {\n        self.prepare_simple_expr_common(simple_expr, sql);\n    }\n\n    fn prepare_simple_expr_common(&self, simple_expr: &SimpleExpr, sql: &mut dyn SqlWriter) {\n        match simple_expr {\n            SimpleExpr::Column(column_ref) => {\n                self.prepare_column_ref(column_ref, sql);\n            }\n            SimpleExpr::Tuple(exprs) => {\n                self.prepare_tuple(exprs, sql);\n            }\n            SimpleExpr::Unary(op, expr) => {\n                self.prepare_un_oper(op, sql);\n                write!(sql, \" \").unwrap();\n                let drop_expr_paren =\n                    self.inner_expr_well_known_greater_precedence(expr, &(*op).into());\n                if !drop_expr_paren {\n                    write!(sql, \"(\").unwrap();\n                }\n                self.prepare_simple_expr(expr, sql);\n                if !drop_expr_paren {\n                    write!(sql, \")\").unwrap();\n                }\n            }\n            SimpleExpr::FunctionCall(func) => {\n                self.prepare_function_name(&func.func, sql);\n                self.prepare_function_arguments(func, sql);\n            }\n            SimpleExpr::Binary(left, op, right) => match (op, right.as_ref()) {\n                (BinOper::In, SimpleExpr::Tuple(t)) if t.is_empty() => {\n                    self.binary_expr(&1i32.into(), &BinOper::Equal, &2i32.into(), sql)\n                }\n                (BinOper::NotIn, SimpleExpr::Tuple(t)) if t.is_empty() => {\n                    self.binary_expr(&1i32.into(), &BinOper::Equal, &1i32.into(), sql)\n                }\n                _ => self.binary_expr(left, op, right, sql),\n            },\n            SimpleExpr::SubQuery(oper, sel) => {\n                if let Some(oper) = oper {\n                    self.prepare_sub_query_oper(oper, sql);\n                }\n                write!(sql, \"(\").unwrap();\n                self.prepare_query_statement(sel.deref(), sql);\n                write!(sql, \")\").unwrap();\n            }\n            SimpleExpr::Value(val) => {\n                self.prepare_value(val, sql);\n            }\n            SimpleExpr::Values(list) => {\n                write!(sql, \"(\").unwrap();\n                list.iter().fold(true, |first, val| {\n                    if !first {\n                        write!(sql, \", \").unwrap();\n                    }\n                    self.prepare_value(val, sql);\n                    false\n                });\n                write!(sql, \")\").unwrap();\n            }\n            SimpleExpr::Custom(s) => {\n                write!(sql, \"{s}\").unwrap();\n            }\n            SimpleExpr::CustomWithExpr(expr, values) => {\n                let (placeholder, numbered) = self.placeholder();\n                let mut tokenizer = Tokenizer::new(expr).iter().peekable();\n                let mut count = 0;\n                while let Some(token) = tokenizer.next() {\n                    match token {\n                        Token::Punctuation(mark) if mark == placeholder => match tokenizer.peek() {\n                            Some(Token::Punctuation(mark)) if mark == placeholder => {\n                                write!(sql, \"{mark}\").unwrap();\n                                tokenizer.next();\n                            }\n                            Some(Token::Unquoted(tok)) if numbered => {\n                                if let Ok(num) = tok.parse::<usize>() {\n                                    self.prepare_simple_expr(&values[num - 1], sql);\n                                }\n                                tokenizer.next();\n                            }\n                            _ => {\n                                self.prepare_simple_expr(&values[count], sql);\n                                count += 1;\n                            }\n                        },\n                        _ => write!(sql, \"{token}\").unwrap(),\n                    };\n                }\n            }\n            SimpleExpr::Keyword(keyword) => {\n                self.prepare_keyword(keyword, sql);\n            }\n            SimpleExpr::AsEnum(_, expr) => {\n                self.prepare_simple_expr(expr, sql);\n            }\n            SimpleExpr::Case(case_stmt) => {\n                self.prepare_case_statement(case_stmt, sql);\n            }\n            SimpleExpr::Constant(val) => {\n                self.prepare_constant(val, sql);\n            }\n        }\n    }\n\n    /// Translate [`CaseStatement`] into SQL statement.\n    fn prepare_case_statement(&self, stmts: &CaseStatement, sql: &mut dyn SqlWriter) {\n        write!(sql, \"(CASE\").unwrap();\n\n        let CaseStatement { when, r#else } = stmts;\n\n        for case in when.iter() {\n            write!(sql, \" WHEN (\").unwrap();\n            self.prepare_condition_where(&case.condition, sql);\n            write!(sql, \") THEN \").unwrap();\n\n            self.prepare_simple_expr(&case.result, sql);\n        }\n        if let Some(r#else) = r#else.clone() {\n            write!(sql, \" ELSE \").unwrap();\n            self.prepare_simple_expr(&r#else, sql);\n        }\n\n        write!(sql, \" END)\").unwrap();\n    }\n\n    /// Translate [`SelectDistinct`] into SQL statement.\n    fn prepare_select_distinct(&self, select_distinct: &SelectDistinct, sql: &mut dyn SqlWriter) {\n        match select_distinct {\n            SelectDistinct::All => write!(sql, \"ALL\").unwrap(),\n            SelectDistinct::Distinct => write!(sql, \"DISTINCT\").unwrap(),\n            _ => {}\n        }\n    }\n\n    /// Translate [`IndexHint`] into SQL statement.\n    fn prepare_index_hints(&self, _select: &SelectStatement, _sql: &mut dyn SqlWriter) {}\n\n    /// Translate [`LockType`] into SQL statement.\n    fn prepare_select_lock(&self, lock: &LockClause, sql: &mut dyn SqlWriter) {\n        write!(\n            sql,\n            \"FOR {}\",\n            match lock.r#type {\n                LockType::Update => \"UPDATE\",\n                LockType::NoKeyUpdate => \"NO KEY UPDATE\",\n                LockType::Share => \"SHARE\",\n                LockType::KeyShare => \"KEY SHARE\",\n            }\n        )\n        .unwrap();\n        if !lock.tables.is_empty() {\n            write!(sql, \" OF \").unwrap();\n            lock.tables.iter().fold(true, |first, table_ref| {\n                if !first {\n                    write!(sql, \", \").unwrap();\n                }\n                self.prepare_table_ref(table_ref, sql);\n                false\n            });\n        }\n        if let Some(behavior) = lock.behavior {\n            match behavior {\n                LockBehavior::Nowait => write!(sql, \" NOWAIT\").unwrap(),\n                LockBehavior::SkipLocked => write!(sql, \" SKIP LOCKED\").unwrap(),\n            }\n        }\n    }\n\n    /// Translate [`SelectExpr`] into SQL statement.\n    fn prepare_select_expr(&self, select_expr: &SelectExpr, sql: &mut dyn SqlWriter) {\n        self.prepare_simple_expr(&select_expr.expr, sql);\n        match &select_expr.window {\n            Some(WindowSelectType::Name(name)) => {\n                write!(sql, \" OVER \").unwrap();\n                name.prepare(sql.as_writer(), self.quote())\n            }\n            Some(WindowSelectType::Query(window)) => {\n                write!(sql, \" OVER \").unwrap();\n                write!(sql, \"( \").unwrap();\n                self.prepare_window_statement(window, sql);\n                write!(sql, \" )\").unwrap();\n            }\n            None => {}\n        };\n\n        match &select_expr.alias {\n            Some(alias) => {\n                write!(sql, \" AS \").unwrap();\n                alias.prepare(sql.as_writer(), self.quote());\n            }\n            None => {}\n        };\n    }\n\n    /// Translate [`JoinExpr`] into SQL statement.\n    fn prepare_join_expr(&self, join_expr: &JoinExpr, sql: &mut dyn SqlWriter) {\n        self.prepare_join_type(&join_expr.join, sql);\n        write!(sql, \" \").unwrap();\n        self.prepare_join_table_ref(join_expr, sql);\n        if let Some(on) = &join_expr.on {\n            self.prepare_join_on(on, sql);\n        }\n    }\n\n    fn prepare_join_table_ref(&self, join_expr: &JoinExpr, sql: &mut dyn SqlWriter) {\n        if join_expr.lateral {\n            write!(sql, \"LATERAL \").unwrap();\n        }\n        self.prepare_table_ref(&join_expr.table, sql);\n    }\n\n    /// Translate [`TableRef`] into SQL statement.\n    fn prepare_table_ref(&self, table_ref: &TableRef, sql: &mut dyn SqlWriter) {\n        match table_ref {\n            TableRef::SubQuery(query, alias) => {\n                write!(sql, \"(\").unwrap();\n                self.prepare_select_statement(query, sql);\n                write!(sql, \")\").unwrap();\n                write!(sql, \" AS \").unwrap();\n                alias.prepare(sql.as_writer(), self.quote());\n            }\n            TableRef::ValuesList(values, alias) => {\n                write!(sql, \"(\").unwrap();\n                self.prepare_values_list(values, sql);\n                write!(sql, \")\").unwrap();\n                write!(sql, \" AS \").unwrap();\n                alias.prepare(sql.as_writer(), self.quote());\n            }\n            TableRef::FunctionCall(func, alias) => {\n                self.prepare_function_name(&func.func, sql);\n                self.prepare_function_arguments(func, sql);\n                write!(sql, \" AS \").unwrap();\n                alias.prepare(sql.as_writer(), self.quote());\n            }\n            _ => self.prepare_table_ref_iden(table_ref, sql),\n        }\n    }\n\n    fn prepare_column_ref(&self, column_ref: &ColumnRef, sql: &mut dyn SqlWriter) {\n        match column_ref {\n            ColumnRef::Column(column) => column.prepare(sql.as_writer(), self.quote()),\n            ColumnRef::TableColumn(table, column) => {\n                table.prepare(sql.as_writer(), self.quote());\n                write!(sql, \".\").unwrap();\n                column.prepare(sql.as_writer(), self.quote());\n            }\n            ColumnRef::SchemaTableColumn(schema, table, column) => {\n                schema.prepare(sql.as_writer(), self.quote());\n                write!(sql, \".\").unwrap();\n                table.prepare(sql.as_writer(), self.quote());\n                write!(sql, \".\").unwrap();\n                column.prepare(sql.as_writer(), self.quote());\n            }\n            ColumnRef::Asterisk => {\n                write!(sql, \"*\").unwrap();\n            }\n            ColumnRef::TableAsterisk(table) => {\n                table.prepare(sql.as_writer(), self.quote());\n                write!(sql, \".*\").unwrap();\n            }\n        };\n    }\n\n    /// Translate [`UnOper`] into SQL statement.\n    fn prepare_un_oper(&self, un_oper: &UnOper, sql: &mut dyn SqlWriter) {\n        write!(\n            sql,\n            \"{}\",\n            match un_oper {\n                UnOper::Not => \"NOT\",\n            }\n        )\n        .unwrap();\n    }\n\n    fn prepare_bin_oper_common(&self, bin_oper: &BinOper, sql: &mut dyn SqlWriter) {\n        write!(\n            sql,\n            \"{}\",\n            match bin_oper {\n                BinOper::And => \"AND\",\n                BinOper::Or => \"OR\",\n                BinOper::Like => \"LIKE\",\n                BinOper::NotLike => \"NOT LIKE\",\n                BinOper::Is => \"IS\",\n                BinOper::IsNot => \"IS NOT\",\n                BinOper::In => \"IN\",\n                BinOper::NotIn => \"NOT IN\",\n                BinOper::Between => \"BETWEEN\",\n                BinOper::NotBetween => \"NOT BETWEEN\",\n                BinOper::Equal => \"=\",\n                BinOper::NotEqual => \"<>\",\n                BinOper::SmallerThan => \"<\",\n                BinOper::GreaterThan => \">\",\n                BinOper::SmallerThanOrEqual => \"<=\",\n                BinOper::GreaterThanOrEqual => \">=\",\n                BinOper::Add => \"+\",\n                BinOper::Sub => \"-\",\n                BinOper::Mul => \"*\",\n                BinOper::Div => \"/\",\n                BinOper::Mod => \"%\",\n                BinOper::LShift => \"<<\",\n                BinOper::RShift => \">>\",\n                BinOper::As => \"AS\",\n                BinOper::Escape => \"ESCAPE\",\n                BinOper::Custom(raw) => raw,\n                #[allow(unreachable_patterns)]\n                _ => unimplemented!(),\n            }\n        )\n        .unwrap();\n    }\n\n    /// Translate [`BinOper`] into SQL statement.\n    fn prepare_bin_oper(&self, bin_oper: &BinOper, sql: &mut dyn SqlWriter) {\n        self.prepare_bin_oper_common(bin_oper, sql);\n    }\n\n    /// Translate [`SubQueryOper`] into SQL statement.\n    fn prepare_sub_query_oper(&self, oper: &SubQueryOper, sql: &mut dyn SqlWriter) {\n        write!(\n            sql,\n            \"{}\",\n            match oper {\n                SubQueryOper::Exists => \"EXISTS\",\n                SubQueryOper::Any => \"ANY\",\n                SubQueryOper::Some => \"SOME\",\n                SubQueryOper::All => \"ALL\",\n            }\n        )\n        .unwrap();\n    }\n\n    /// Translate [`LogicalChainOper`] into SQL statement.\n    fn prepare_logical_chain_oper(\n        &self,\n        log_chain_oper: &LogicalChainOper,\n        i: usize,\n        length: usize,\n        sql: &mut dyn SqlWriter,\n    ) {\n        let (simple_expr, oper) = match log_chain_oper {\n            LogicalChainOper::And(simple_expr) => (simple_expr, \"AND\"),\n            LogicalChainOper::Or(simple_expr) => (simple_expr, \"OR\"),\n        };\n        if i > 0 {\n            write!(sql, \" {oper} \").unwrap();\n        }\n        let both_binary = match simple_expr {\n            SimpleExpr::Binary(_, _, right) => {\n                matches!(right.as_ref(), SimpleExpr::Binary(_, _, _))\n            }\n            _ => false,\n        };\n        let need_parentheses = length > 1 && both_binary;\n        if need_parentheses {\n            write!(sql, \"(\").unwrap();\n        }\n        self.prepare_simple_expr(simple_expr, sql);\n        if need_parentheses {\n            write!(sql, \")\").unwrap();\n        }\n    }\n\n    /// Translate [`Function`] into SQL statement.\n    fn prepare_function_name_common(&self, function: &Function, sql: &mut dyn SqlWriter) {\n        if let Function::Custom(iden) = function {\n            iden.unquoted(sql.as_writer());\n        } else {\n            write!(\n                sql,\n                \"{}\",\n                match function {\n                    Function::Max => \"MAX\",\n                    Function::Min => \"MIN\",\n                    Function::Sum => \"SUM\",\n                    Function::Avg => \"AVG\",\n                    Function::Abs => \"ABS\",\n                    Function::Coalesce => \"COALESCE\",\n                    Function::Count => \"COUNT\",\n                    Function::IfNull => self.if_null_function(),\n                    Function::CharLength => self.char_length_function(),\n                    Function::Cast => \"CAST\",\n                    Function::Lower => \"LOWER\",\n                    Function::Upper => \"UPPER\",\n                    Function::BitAnd => \"BIT_AND\",\n                    Function::BitOr => \"BIT_OR\",\n                    Function::Custom(_) => \"\",\n                    Function::Random => self.random_function(),\n                    Function::Round => \"ROUND\",\n                    Function::Md5 => \"MD5\",\n                    #[cfg(feature = \"backend-postgres\")]\n                    Function::PgFunction(_) => unimplemented!(),\n                }\n            )\n            .unwrap();\n        }\n    }\n\n    fn prepare_function_arguments(&self, func: &FunctionCall, sql: &mut dyn SqlWriter) {\n        write!(sql, \"(\").unwrap();\n        for (i, expr) in func.args.iter().enumerate() {\n            if i != 0 {\n                write!(sql, \", \").unwrap();\n            }\n            if func.mods[i].distinct {\n                write!(sql, \"DISTINCT \").unwrap();\n            }\n            self.prepare_simple_expr(expr, sql);\n        }\n        write!(sql, \")\").unwrap();\n    }\n\n    /// Translate [`QueryStatement`] into SQL statement.\n    fn prepare_query_statement(&self, query: &SubQueryStatement, sql: &mut dyn SqlWriter);\n\n    fn prepare_with_query(&self, query: &WithQuery, sql: &mut dyn SqlWriter) {\n        self.prepare_with_clause(&query.with_clause, sql);\n        self.prepare_query_statement(query.query.as_ref().unwrap().deref(), sql);\n    }\n\n    fn prepare_with_clause(&self, with_clause: &WithClause, sql: &mut dyn SqlWriter) {\n        self.prepare_with_clause_start(with_clause, sql);\n        self.prepare_with_clause_common_tables(with_clause, sql);\n        if with_clause.recursive {\n            self.prepare_with_clause_recursive_options(with_clause, sql);\n        }\n    }\n\n    fn prepare_with_clause_recursive_options(\n        &self,\n        with_clause: &WithClause,\n        sql: &mut dyn SqlWriter,\n    ) {\n        if with_clause.recursive {\n            if let Some(search) = &with_clause.search {\n                write!(\n                    sql,\n                    \"SEARCH {} FIRST BY \",\n                    match &search.order.as_ref().unwrap() {\n                        SearchOrder::BREADTH => \"BREADTH\",\n                        SearchOrder::DEPTH => \"DEPTH\",\n                    }\n                )\n                .unwrap();\n\n                self.prepare_simple_expr(&search.expr.as_ref().unwrap().expr, sql);\n\n                write!(sql, \" SET \").unwrap();\n\n                search\n                    .expr\n                    .as_ref()\n                    .unwrap()\n                    .alias\n                    .as_ref()\n                    .unwrap()\n                    .prepare(sql.as_writer(), self.quote());\n                write!(sql, \" \").unwrap();\n            }\n            if let Some(cycle) = &with_clause.cycle {\n                write!(sql, \"CYCLE \").unwrap();\n\n                self.prepare_simple_expr(cycle.expr.as_ref().unwrap(), sql);\n\n                write!(sql, \" SET \").unwrap();\n\n                cycle\n                    .set_as\n                    .as_ref()\n                    .unwrap()\n                    .prepare(sql.as_writer(), self.quote());\n                write!(sql, \" USING \").unwrap();\n                cycle\n                    .using\n                    .as_ref()\n                    .unwrap()\n                    .prepare(sql.as_writer(), self.quote());\n                write!(sql, \" \").unwrap();\n            }\n        }\n    }\n\n    fn prepare_with_clause_common_tables(&self, with_clause: &WithClause, sql: &mut dyn SqlWriter) {\n        let mut cte_first = true;\n        assert_ne!(\n            with_clause.cte_expressions.len(),\n            0,\n            \"Cannot build a with query that has no common table expression!\"\n        );\n\n        if with_clause.recursive {\n            assert_eq!(\n                with_clause.cte_expressions.len(),\n                1,\n                \"Cannot build a recursive query with more than one common table! \\\n                A recursive with query must have a single cte inside it that has a union query of \\\n                two queries!\"\n            );\n        }\n        for cte in &with_clause.cte_expressions {\n            if !cte_first {\n                write!(sql, \", \").unwrap();\n            }\n            cte_first = false;\n\n            self.prepare_with_query_clause_common_table(cte, sql);\n        }\n    }\n\n    fn prepare_with_query_clause_common_table(\n        &self,\n        cte: &CommonTableExpression,\n        sql: &mut dyn SqlWriter,\n    ) {\n        cte.table_name\n            .as_ref()\n            .unwrap()\n            .prepare(sql.as_writer(), self.quote());\n\n        if cte.cols.is_empty() {\n            write!(sql, \" \").unwrap();\n        } else {\n            write!(sql, \" (\").unwrap();\n\n            let mut col_first = true;\n            for col in &cte.cols {\n                if !col_first {\n                    write!(sql, \", \").unwrap();\n                }\n                col_first = false;\n                col.prepare(sql.as_writer(), self.quote());\n            }\n\n            write!(sql, \") \").unwrap();\n        }\n\n        write!(sql, \"AS \").unwrap();\n\n        self.prepare_with_query_clause_materialization(cte, sql);\n\n        write!(sql, \"(\").unwrap();\n\n        self.prepare_query_statement(cte.query.as_ref().unwrap().deref(), sql);\n\n        write!(sql, \") \").unwrap();\n    }\n\n    fn prepare_with_query_clause_materialization(\n        &self,\n        cte: &CommonTableExpression,\n        sql: &mut dyn SqlWriter,\n    ) {\n        if let Some(materialized) = cte.materialized {\n            write!(\n                sql,\n                \"{} MATERIALIZED \",\n                if materialized { \"\" } else { \"NOT\" }\n            )\n            .unwrap()\n        }\n    }\n\n    fn prepare_with_clause_start(&self, with_clause: &WithClause, sql: &mut dyn SqlWriter) {\n        write!(sql, \"WITH \").unwrap();\n\n        if with_clause.recursive {\n            write!(sql, \"RECURSIVE \").unwrap();\n        }\n    }\n\n    fn prepare_insert(&self, replace: bool, sql: &mut dyn SqlWriter) {\n        if replace {\n            write!(sql, \"REPLACE\").unwrap();\n        } else {\n            write!(sql, \"INSERT\").unwrap();\n        }\n    }\n\n    fn prepare_function_name(&self, function: &Function, sql: &mut dyn SqlWriter) {\n        self.prepare_function_name_common(function, sql)\n    }\n\n    /// Translate [`JoinType`] into SQL statement.\n    fn prepare_join_type(&self, join_type: &JoinType, sql: &mut dyn SqlWriter) {\n        self.prepare_join_type_common(join_type, sql)\n    }\n\n    fn prepare_join_type_common(&self, join_type: &JoinType, sql: &mut dyn SqlWriter) {\n        write!(\n            sql,\n            \"{}\",\n            match join_type {\n                JoinType::Join => \"JOIN\",\n                JoinType::CrossJoin => \"CROSS JOIN\",\n                JoinType::InnerJoin => \"INNER JOIN\",\n                JoinType::LeftJoin => \"LEFT JOIN\",\n                JoinType::RightJoin => \"RIGHT JOIN\",\n                JoinType::FullOuterJoin => \"FULL OUTER JOIN\",\n            }\n        )\n        .unwrap()\n    }\n\n    /// Translate [`OrderExpr`] into SQL statement.\n    fn prepare_order_expr(&self, order_expr: &OrderExpr, sql: &mut dyn SqlWriter) {\n        if !matches!(order_expr.order, Order::Field(_)) {\n            self.prepare_simple_expr(&order_expr.expr, sql);\n        }\n        self.prepare_order(order_expr, sql);\n    }\n\n    /// Translate [`JoinOn`] into SQL statement.\n    fn prepare_join_on(&self, join_on: &JoinOn, sql: &mut dyn SqlWriter) {\n        match join_on {\n            JoinOn::Condition(c) => self.prepare_condition(c, \"ON\", sql),\n            JoinOn::Columns(_c) => unimplemented!(),\n        }\n    }\n\n    /// Translate [`Order`] into SQL statement.\n    fn prepare_order(&self, order_expr: &OrderExpr, sql: &mut dyn SqlWriter) {\n        match &order_expr.order {\n            Order::Asc => write!(sql, \" ASC\").unwrap(),\n            Order::Desc => write!(sql, \" DESC\").unwrap(),\n            Order::Field(values) => self.prepare_field_order(order_expr, values, sql),\n        }\n    }\n\n    /// Translate [`Order::Field`] into SQL statement\n    fn prepare_field_order(\n        &self,\n        order_expr: &OrderExpr,\n        values: &Values,\n        sql: &mut dyn SqlWriter,\n    ) {\n        write!(sql, \"CASE \").unwrap();\n        let mut i = 0;\n        for value in &values.0 {\n            write!(sql, \"WHEN \").unwrap();\n            self.prepare_simple_expr(&order_expr.expr, sql);\n            write!(sql, \"=\").unwrap();\n            let value = self.value_to_string(value);\n            write!(sql, \"{value}\").unwrap();\n            write!(sql, \" THEN {i} \").unwrap();\n            i += 1;\n        }\n        write!(sql, \"ELSE {i} END\").unwrap();\n    }\n\n    /// Write [`Value`] into SQL statement as parameter.\n    fn prepare_value(&self, value: &Value, sql: &mut dyn SqlWriter);\n\n    /// Write [`Value`] inline.\n    fn prepare_constant(&self, value: &Value, sql: &mut dyn SqlWriter) {\n        let string = self.value_to_string(value);\n        write!(sql, \"{string}\").unwrap();\n    }\n\n    /// Translate a `&[ValueTuple]` into a VALUES list.\n    fn prepare_values_list(&self, value_tuples: &[ValueTuple], sql: &mut dyn SqlWriter) {\n        write!(sql, \"VALUES \").unwrap();\n        value_tuples.iter().fold(true, |first, value_tuple| {\n            if !first {\n                write!(sql, \", \").unwrap();\n            }\n            write!(sql, \"{}\", self.values_list_tuple_prefix()).unwrap();\n            write!(sql, \"(\").unwrap();\n            value_tuple.clone().into_iter().fold(true, |first, value| {\n                if !first {\n                    write!(sql, \", \").unwrap();\n                }\n                self.prepare_value(&value, sql);\n                false\n            });\n\n            write!(sql, \")\").unwrap();\n            false\n        });\n    }\n\n    /// Translate [`SimpleExpr::Tuple`] into SQL statement.\n    fn prepare_tuple(&self, exprs: &[SimpleExpr], sql: &mut dyn SqlWriter) {\n        write!(sql, \"(\").unwrap();\n        for (i, expr) in exprs.iter().enumerate() {\n            if i != 0 {\n                write!(sql, \", \").unwrap();\n            }\n            self.prepare_simple_expr(expr, sql);\n        }\n        write!(sql, \")\").unwrap();\n    }\n\n    /// Translate [`Keyword`] into SQL statement.\n    fn prepare_keyword(&self, keyword: &Keyword, sql: &mut dyn SqlWriter) {\n        match keyword {\n            Keyword::Null => write!(sql, \"NULL\").unwrap(),\n            Keyword::CurrentDate => write!(sql, \"CURRENT_DATE\").unwrap(),\n            Keyword::CurrentTime => write!(sql, \"CURRENT_TIME\").unwrap(),\n            Keyword::CurrentTimestamp => write!(sql, \"CURRENT_TIMESTAMP\").unwrap(),\n            Keyword::Custom(iden) => iden.unquoted(sql.as_writer()),\n        }\n    }\n\n    /// Convert a SQL value into syntax-specific string\n    fn value_to_string(&self, v: &Value) -> String {\n        self.value_to_string_common(v)\n    }\n\n    fn value_to_string_common(&self, v: &Value) -> String {\n        let mut s = String::new();\n        match v {\n            Value::Bool(None)\n            | Value::TinyInt(None)\n            | Value::SmallInt(None)\n            | Value::Int(None)\n            | Value::BigInt(None)\n            | Value::TinyUnsigned(None)\n            | Value::SmallUnsigned(None)\n            | Value::Unsigned(None)\n            | Value::BigUnsigned(None)\n            | Value::Float(None)\n            | Value::Double(None)\n            | Value::String(None)\n            | Value::Char(None)\n            | Value::Bytes(None) => write!(s, \"NULL\").unwrap(),\n            #[cfg(feature = \"with-json\")]\n            Value::Json(None) => write!(s, \"NULL\").unwrap(),\n            #[cfg(feature = \"with-chrono\")]\n            Value::ChronoDate(None) => write!(s, \"NULL\").unwrap(),\n            #[cfg(feature = \"with-chrono\")]\n            Value::ChronoTime(None) => write!(s, \"NULL\").unwrap(),\n            #[cfg(feature = \"with-chrono\")]\n            Value::ChronoDateTime(None) => write!(s, \"NULL\").unwrap(),\n            #[cfg(feature = \"with-chrono\")]\n            Value::ChronoDateTimeUtc(None) => write!(s, \"NULL\").unwrap(),\n            #[cfg(feature = \"with-chrono\")]\n            Value::ChronoDateTimeLocal(None) => write!(s, \"NULL\").unwrap(),\n            #[cfg(feature = \"with-chrono\")]\n            Value::ChronoDateTimeWithTimeZone(None) => write!(s, \"NULL\").unwrap(),\n            #[cfg(feature = \"with-time\")]\n            Value::TimeDate(None) => write!(s, \"NULL\").unwrap(),\n            #[cfg(feature = \"with-time\")]\n            Value::TimeTime(None) => write!(s, \"NULL\").unwrap(),\n            #[cfg(feature = \"with-time\")]\n            Value::TimeDateTime(None) => write!(s, \"NULL\").unwrap(),\n            #[cfg(feature = \"with-time\")]\n            Value::TimeDateTimeWithTimeZone(None) => write!(s, \"NULL\").unwrap(),\n            #[cfg(feature = \"with-rust_decimal\")]\n            Value::Decimal(None) => write!(s, \"NULL\").unwrap(),\n            #[cfg(feature = \"with-bigdecimal\")]\n            Value::BigDecimal(None) => write!(s, \"NULL\").unwrap(),\n            #[cfg(feature = \"with-uuid\")]\n            Value::Uuid(None) => write!(s, \"NULL\").unwrap(),\n            #[cfg(feature = \"with-ipnetwork\")]\n            Value::IpNetwork(None) => write!(s, \"NULL\").unwrap(),\n            #[cfg(feature = \"with-mac_address\")]\n            Value::MacAddress(None) => write!(s, \"NULL\").unwrap(),\n            #[cfg(feature = \"postgres-array\")]\n            Value::Array(_, None) => write!(s, \"NULL\").unwrap(),\n            #[cfg(feature = \"postgres-vector\")]\n            Value::Vector(None) => write!(s, \"NULL\").unwrap(),\n            Value::Bool(Some(b)) => write!(s, \"{}\", if *b { \"TRUE\" } else { \"FALSE\" }).unwrap(),\n            Value::TinyInt(Some(v)) => write!(s, \"{v}\").unwrap(),\n            Value::SmallInt(Some(v)) => write!(s, \"{v}\").unwrap(),\n            Value::Int(Some(v)) => write!(s, \"{v}\").unwrap(),\n            Value::BigInt(Some(v)) => write!(s, \"{v}\").unwrap(),\n            Value::TinyUnsigned(Some(v)) => write!(s, \"{v}\").unwrap(),\n            Value::SmallUnsigned(Some(v)) => write!(s, \"{v}\").unwrap(),\n            Value::Unsigned(Some(v)) => write!(s, \"{v}\").unwrap(),\n            Value::BigUnsigned(Some(v)) => write!(s, \"{v}\").unwrap(),\n            Value::Float(Some(v)) => write!(s, \"{v}\").unwrap(),\n            Value::Double(Some(v)) => write!(s, \"{v}\").unwrap(),\n            Value::String(Some(v)) => self.write_string_quoted(v, &mut s),\n            Value::Char(Some(v)) => {\n                self.write_string_quoted(std::str::from_utf8(&[*v as u8]).unwrap(), &mut s)\n            }\n            Value::Bytes(Some(v)) => self.write_bytes(v, &mut s),\n            #[cfg(feature = \"with-json\")]\n            Value::Json(Some(v)) => self.write_string_quoted(&v.to_string(), &mut s),\n            #[cfg(feature = \"with-chrono\")]\n            Value::ChronoDate(Some(v)) => write!(s, \"'{}'\", v.format(\"%Y-%m-%d\")).unwrap(),\n            #[cfg(feature = \"with-chrono\")]\n            Value::ChronoTime(Some(v)) => write!(s, \"'{}'\", v.format(\"%H:%M:%S\")).unwrap(),\n            #[cfg(feature = \"with-chrono\")]\n            Value::ChronoDateTime(Some(v)) => {\n                write!(s, \"'{}'\", v.format(\"%Y-%m-%d %H:%M:%S\")).unwrap()\n            }\n            #[cfg(feature = \"with-chrono\")]\n            Value::ChronoDateTimeUtc(Some(v)) => {\n                write!(s, \"'{}'\", v.format(\"%Y-%m-%d %H:%M:%S %:z\")).unwrap()\n            }\n            #[cfg(feature = \"with-chrono\")]\n            Value::ChronoDateTimeLocal(Some(v)) => {\n                write!(s, \"'{}'\", v.format(\"%Y-%m-%d %H:%M:%S %:z\")).unwrap()\n            }\n            #[cfg(feature = \"with-chrono\")]\n            Value::ChronoDateTimeWithTimeZone(Some(v)) => {\n                write!(s, \"'{}'\", v.format(\"%Y-%m-%d %H:%M:%S %:z\")).unwrap()\n            }\n            #[cfg(feature = \"with-time\")]\n            Value::TimeDate(Some(v)) => {\n                write!(s, \"'{}'\", v.format(time_format::FORMAT_DATE).unwrap()).unwrap()\n            }\n            #[cfg(feature = \"with-time\")]\n            Value::TimeTime(Some(v)) => {\n                write!(s, \"'{}'\", v.format(time_format::FORMAT_TIME).unwrap()).unwrap()\n            }\n            #[cfg(feature = \"with-time\")]\n            Value::TimeDateTime(Some(v)) => {\n                write!(s, \"'{}'\", v.format(time_format::FORMAT_DATETIME).unwrap()).unwrap()\n            }\n            #[cfg(feature = \"with-time\")]\n            Value::TimeDateTimeWithTimeZone(Some(v)) => write!(\n                s,\n                \"'{}'\",\n                v.format(time_format::FORMAT_DATETIME_TZ).unwrap()\n            )\n            .unwrap(),\n            #[cfg(feature = \"with-rust_decimal\")]\n            Value::Decimal(Some(v)) => write!(s, \"{v}\").unwrap(),\n            #[cfg(feature = \"with-bigdecimal\")]\n            Value::BigDecimal(Some(v)) => write!(s, \"{v}\").unwrap(),\n            #[cfg(feature = \"with-uuid\")]\n            Value::Uuid(Some(v)) => write!(s, \"'{v}'\").unwrap(),\n            #[cfg(feature = \"postgres-array\")]\n            Value::Array(_, Some(v)) => write!(\n                s,\n                \"ARRAY [{}]\",\n                v.iter()\n                    .map(|element| self.value_to_string(element))\n                    .collect::<Vec<String>>()\n                    .join(\",\")\n            )\n            .unwrap(),\n            #[cfg(feature = \"postgres-vector\")]\n            Value::Vector(Some(v)) => {\n                write!(s, \"'[\").unwrap();\n                for (i, &element) in v.as_slice().iter().enumerate() {\n                    if i != 0 {\n                        write!(s, \",\").unwrap();\n                    }\n                    write!(s, \"{element}\").unwrap();\n                }\n                write!(s, \"]'\").unwrap();\n            }\n            #[cfg(feature = \"with-ipnetwork\")]\n            Value::IpNetwork(Some(v)) => write!(s, \"'{v}'\").unwrap(),\n            #[cfg(feature = \"with-mac_address\")]\n            Value::MacAddress(Some(v)) => write!(s, \"'{v}'\").unwrap(),\n        };\n        s\n    }\n\n    #[doc(hidden)]\n    /// Write ON CONFLICT expression\n    fn prepare_on_conflict(&self, on_conflict: &Option<OnConflict>, sql: &mut dyn SqlWriter) {\n        if let Some(on_conflict) = on_conflict {\n            self.prepare_on_conflict_keywords(sql);\n            self.prepare_on_conflict_target(&on_conflict.targets, sql);\n            self.prepare_on_conflict_condition(&on_conflict.target_where, sql);\n            self.prepare_on_conflict_action(&on_conflict.action, sql);\n            self.prepare_on_conflict_condition(&on_conflict.action_where, sql);\n        }\n    }\n\n    #[doc(hidden)]\n    /// Write ON CONFLICT target\n    fn prepare_on_conflict_target(\n        &self,\n        on_conflict_targets: &[OnConflictTarget],\n        sql: &mut dyn SqlWriter,\n    ) {\n        if on_conflict_targets.is_empty() {\n            return;\n        }\n\n        write!(sql, \"(\").unwrap();\n        on_conflict_targets.iter().fold(true, |first, target| {\n            if !first {\n                write!(sql, \", \").unwrap()\n            }\n            match target {\n                OnConflictTarget::ConflictColumn(col) => {\n                    col.prepare(sql.as_writer(), self.quote());\n                }\n\n                OnConflictTarget::ConflictExpr(expr) => {\n                    self.prepare_simple_expr(expr, sql);\n                }\n            }\n            false\n        });\n        write!(sql, \")\").unwrap();\n    }\n\n    #[doc(hidden)]\n    /// Write ON CONFLICT action\n    fn prepare_on_conflict_action(\n        &self,\n        on_conflict_action: &Option<OnConflictAction>,\n        sql: &mut dyn SqlWriter,\n    ) {\n        self.prepare_on_conflict_action_common(on_conflict_action, sql);\n    }\n\n    fn prepare_on_conflict_action_common(\n        &self,\n        on_conflict_action: &Option<OnConflictAction>,\n        sql: &mut dyn SqlWriter,\n    ) {\n        if let Some(action) = on_conflict_action {\n            match action {\n                OnConflictAction::DoNothing(_) => {\n                    write!(sql, \" DO NOTHING\").unwrap();\n                }\n                OnConflictAction::Update(update_strats) => {\n                    self.prepare_on_conflict_do_update_keywords(sql);\n                    update_strats.iter().fold(true, |first, update_strat| {\n                        if !first {\n                            write!(sql, \", \").unwrap()\n                        }\n                        match update_strat {\n                            OnConflictUpdate::Column(col) => {\n                                col.prepare(sql.as_writer(), self.quote());\n                                write!(sql, \" = \").unwrap();\n                                self.prepare_on_conflict_excluded_table(col, sql);\n                            }\n                            OnConflictUpdate::Expr(col, expr) => {\n                                col.prepare(sql.as_writer(), self.quote());\n                                write!(sql, \" = \").unwrap();\n                                self.prepare_simple_expr(expr, sql);\n                            }\n                        }\n                        false\n                    });\n                }\n            }\n        }\n    }\n\n    #[doc(hidden)]\n    /// Write ON CONFLICT keywords\n    fn prepare_on_conflict_keywords(&self, sql: &mut dyn SqlWriter) {\n        write!(sql, \" ON CONFLICT \").unwrap();\n    }\n\n    #[doc(hidden)]\n    /// Write ON CONFLICT keywords\n    fn prepare_on_conflict_do_update_keywords(&self, sql: &mut dyn SqlWriter) {\n        write!(sql, \" DO UPDATE SET \").unwrap();\n    }\n\n    #[doc(hidden)]\n    /// Write ON CONFLICT update action by retrieving value from the excluded table\n    fn prepare_on_conflict_excluded_table(&self, col: &DynIden, sql: &mut dyn SqlWriter) {\n        write!(\n            sql,\n            \"{}excluded{}\",\n            self.quote().left(),\n            self.quote().right()\n        )\n        .unwrap();\n        write!(sql, \".\").unwrap();\n        col.prepare(sql.as_writer(), self.quote());\n    }\n\n    #[doc(hidden)]\n    /// Write ON CONFLICT conditions\n    fn prepare_on_conflict_condition(\n        &self,\n        on_conflict_condition: &ConditionHolder,\n        sql: &mut dyn SqlWriter,\n    ) {\n        self.prepare_condition(on_conflict_condition, \"WHERE\", sql)\n    }\n\n    #[doc(hidden)]\n    /// Hook to insert \"OUTPUT\" expressions.\n    fn prepare_output(&self, _returning: &Option<ReturningClause>, _sql: &mut dyn SqlWriter) {}\n\n    #[doc(hidden)]\n    /// Hook to insert \"RETURNING\" statements.\n    fn prepare_returning(&self, returning: &Option<ReturningClause>, sql: &mut dyn SqlWriter) {\n        if let Some(returning) = returning {\n            write!(sql, \" RETURNING \").unwrap();\n            match &returning {\n                ReturningClause::All => write!(sql, \"*\").unwrap(),\n                ReturningClause::Columns(cols) => {\n                    cols.iter().fold(true, |first, column_ref| {\n                        if !first {\n                            write!(sql, \", \").unwrap()\n                        }\n                        self.prepare_column_ref(column_ref, sql);\n                        false\n                    });\n                }\n                ReturningClause::Exprs(exprs) => {\n                    exprs.iter().fold(true, |first, expr| {\n                        if !first {\n                            write!(sql, \", \").unwrap()\n                        }\n                        self.prepare_simple_expr(expr, sql);\n                        false\n                    });\n                }\n            }\n        }\n    }\n\n    #[doc(hidden)]\n    /// Translate a condition to a \"WHERE\" clause.\n    fn prepare_condition(\n        &self,\n        condition: &ConditionHolder,\n        keyword: &str,\n        sql: &mut dyn SqlWriter,\n    ) {\n        match &condition.contents {\n            ConditionHolderContents::Empty => (),\n            ConditionHolderContents::Chain(conditions) => {\n                write!(sql, \" {keyword} \").unwrap();\n                for (i, log_chain_oper) in conditions.iter().enumerate() {\n                    self.prepare_logical_chain_oper(log_chain_oper, i, conditions.len(), sql);\n                }\n            }\n            ConditionHolderContents::Condition(c) => {\n                write!(sql, \" {keyword} \").unwrap();\n                self.prepare_condition_where(c, sql);\n            }\n        }\n    }\n\n    #[doc(hidden)]\n    /// Translate part of a condition to part of a \"WHERE\" clause.\n    fn prepare_condition_where(&self, condition: &Condition, sql: &mut dyn SqlWriter) {\n        let simple_expr = condition.to_simple_expr();\n        self.prepare_simple_expr(&simple_expr, sql);\n    }\n\n    #[doc(hidden)]\n    /// Translate [`Frame`] into SQL statement.\n    fn prepare_frame(&self, frame: &Frame, sql: &mut dyn SqlWriter) {\n        match *frame {\n            Frame::UnboundedPreceding => write!(sql, \"UNBOUNDED PRECEDING\").unwrap(),\n            Frame::Preceding(v) => {\n                self.prepare_value(&v.into(), sql);\n                write!(sql, \"PRECEDING\").unwrap();\n            }\n            Frame::CurrentRow => write!(sql, \"CURRENT ROW\").unwrap(),\n            Frame::Following(v) => {\n                self.prepare_value(&v.into(), sql);\n                write!(sql, \"FOLLOWING\").unwrap();\n            }\n            Frame::UnboundedFollowing => write!(sql, \"UNBOUNDED FOLLOWING\").unwrap(),\n        }\n    }\n\n    #[doc(hidden)]\n    /// Translate [`WindowStatement`] into SQL statement.\n    fn prepare_window_statement(&self, window: &WindowStatement, sql: &mut dyn SqlWriter) {\n        if !window.partition_by.is_empty() {\n            write!(sql, \"PARTITION BY \").unwrap();\n            window.partition_by.iter().fold(true, |first, expr| {\n                if !first {\n                    write!(sql, \", \").unwrap()\n                }\n                self.prepare_simple_expr(expr, sql);\n                false\n            });\n        }\n\n        if !window.order_by.is_empty() {\n            write!(sql, \" ORDER BY \").unwrap();\n            window.order_by.iter().fold(true, |first, expr| {\n                if !first {\n                    write!(sql, \", \").unwrap()\n                }\n                self.prepare_order_expr(expr, sql);\n                false\n            });\n        }\n\n        if let Some(frame) = &window.frame {\n            match frame.r#type {\n                FrameType::Range => write!(sql, \" RANGE \").unwrap(),\n                FrameType::Rows => write!(sql, \" ROWS \").unwrap(),\n            };\n            if let Some(end) = &frame.end {\n                write!(sql, \"BETWEEN \").unwrap();\n                self.prepare_frame(&frame.start, sql);\n                write!(sql, \" AND \").unwrap();\n                self.prepare_frame(end, sql);\n            } else {\n                self.prepare_frame(&frame.start, sql);\n            }\n        }\n    }\n\n    #[doc(hidden)]\n    /// Translate a binary expr to SQL.\n    fn binary_expr(\n        &self,\n        left: &SimpleExpr,\n        op: &BinOper,\n        right: &SimpleExpr,\n        sql: &mut dyn SqlWriter,\n    ) {\n        // If left has higher precedence than op, we can drop parentheses around left\n        let drop_left_higher_precedence =\n            self.inner_expr_well_known_greater_precedence(left, &(*op).into());\n\n        // Figure out if left associativity rules allow us to drop the left parenthesis\n        let drop_left_assoc = left.is_binary()\n            && op == left.get_bin_oper().unwrap()\n            && self.well_known_left_associative(op);\n\n        let left_paren = !drop_left_higher_precedence && !drop_left_assoc;\n        if left_paren {\n            write!(sql, \"(\").unwrap();\n        }\n        self.prepare_simple_expr(left, sql);\n        if left_paren {\n            write!(sql, \")\").unwrap();\n        }\n\n        write!(sql, \" \").unwrap();\n        self.prepare_bin_oper(op, sql);\n        write!(sql, \" \").unwrap();\n\n        // If right has higher precedence than op, we can drop parentheses around right\n        let drop_right_higher_precedence =\n            self.inner_expr_well_known_greater_precedence(right, &(*op).into());\n\n        let op_as_oper = Oper::BinOper(*op);\n        // Due to representation of trinary op between as nested binary ops.\n        let drop_right_between_hack = op_as_oper.is_between()\n            && right.is_binary()\n            && matches!(right.get_bin_oper(), Some(&BinOper::And));\n\n        // Due to representation of trinary op like/not like with optional arg escape as nested binary ops.\n        let drop_right_escape_hack = op_as_oper.is_like()\n            && right.is_binary()\n            && matches!(right.get_bin_oper(), Some(&BinOper::Escape));\n\n        // Due to custom representation of casting AS datatype\n        let drop_right_as_hack = (op == &BinOper::As) && matches!(right, SimpleExpr::Custom(_));\n\n        let right_paren = !drop_right_higher_precedence\n            && !drop_right_escape_hack\n            && !drop_right_between_hack\n            && !drop_right_as_hack;\n        if right_paren {\n            write!(sql, \"(\").unwrap();\n        }\n        self.prepare_simple_expr(right, sql);\n        if right_paren {\n            write!(sql, \")\").unwrap();\n        }\n    }\n\n    #[doc(hidden)]\n    /// Write a string surrounded by escaped quotes.\n    fn write_string_quoted(&self, string: &str, buffer: &mut String) {\n        write!(buffer, \"'{}'\", self.escape_string(string)).unwrap()\n    }\n\n    #[doc(hidden)]\n    /// Write bytes enclosed with engine specific byte syntax\n    fn write_bytes(&self, bytes: &[u8], buffer: &mut String) {\n        write!(buffer, \"x'\").unwrap();\n        for b in bytes {\n            write!(buffer, \"{b:02X}\").unwrap();\n        }\n        write!(buffer, \"'\").unwrap();\n    }\n\n    #[doc(hidden)]\n    /// The name of the function that represents the \"if null\" condition.\n    fn if_null_function(&self) -> &str {\n        \"IFNULL\"\n    }\n\n    #[doc(hidden)]\n    /// The name of the function that returns the char length.\n    fn char_length_function(&self) -> &str {\n        \"CHAR_LENGTH\"\n    }\n\n    #[doc(hidden)]\n    /// The name of the function that returns a random number\n    fn random_function(&self) -> &str {\n        // Returning it with parens as part of the name because the tuple preparer can't deal with empty lists\n        \"RANDOM\"\n    }\n\n    /// The keywords for insert default row.\n    fn insert_default_keyword(&self) -> &str {\n        \"(DEFAULT)\"\n    }\n\n    /// Write insert default rows expression.\n    fn insert_default_values(&self, num_rows: u32, sql: &mut dyn SqlWriter) {\n        write!(sql, \"VALUES \").unwrap();\n        (0..num_rows).fold(true, |first, _| {\n            if !first {\n                write!(sql, \", \").unwrap()\n            }\n            write!(sql, \"{}\", self.insert_default_keyword()).unwrap();\n            false\n        });\n    }\n\n    /// Write TRUE constant\n    fn prepare_constant_true(&self, sql: &mut dyn SqlWriter) {\n        self.prepare_constant(&true.into(), sql);\n    }\n\n    /// Write FALSE constant\n    fn prepare_constant_false(&self, sql: &mut dyn SqlWriter) {\n        self.prepare_constant(&false.into(), sql);\n    }\n}\n\nimpl SubQueryStatement {\n    pub(crate) fn prepare_statement(\n        &self,\n        query_builder: &dyn QueryBuilder,\n        sql: &mut dyn SqlWriter,\n    ) {\n        use SubQueryStatement::*;\n        match self {\n            SelectStatement(stmt) => query_builder.prepare_select_statement(stmt, sql),\n            InsertStatement(stmt) => query_builder.prepare_insert_statement(stmt, sql),\n            UpdateStatement(stmt) => query_builder.prepare_update_statement(stmt, sql),\n            DeleteStatement(stmt) => query_builder.prepare_delete_statement(stmt, sql),\n            WithStatement(stmt) => query_builder.prepare_with_query(stmt, sql),\n        }\n    }\n}\n\npub(crate) struct CommonSqlQueryBuilder;\n\nimpl OperLeftAssocDecider for CommonSqlQueryBuilder {\n    fn well_known_left_associative(&self, op: &BinOper) -> bool {\n        common_well_known_left_associative(op)\n    }\n}\n\nimpl PrecedenceDecider for CommonSqlQueryBuilder {\n    fn inner_expr_well_known_greater_precedence(\n        &self,\n        inner: &SimpleExpr,\n        outer_oper: &Oper,\n    ) -> bool {\n        common_inner_expr_well_known_greater_precedence(inner, outer_oper)\n    }\n}\n\nimpl QueryBuilder for CommonSqlQueryBuilder {\n    fn prepare_query_statement(&self, query: &SubQueryStatement, sql: &mut dyn SqlWriter) {\n        query.prepare_statement(self, sql);\n    }\n\n    fn prepare_value(&self, value: &Value, sql: &mut dyn SqlWriter) {\n        sql.push_param(value.clone(), self as _);\n    }\n}\n\nimpl QuotedBuilder for CommonSqlQueryBuilder {\n    fn quote(&self) -> Quote {\n        QUOTE\n    }\n}\n\nimpl EscapeBuilder for CommonSqlQueryBuilder {}\n\nimpl TableRefBuilder for CommonSqlQueryBuilder {}\n\n#[cfg_attr(\n    feature = \"option-more-parentheses\",\n    allow(unreachable_code, unused_variables)\n)]\npub(crate) fn common_inner_expr_well_known_greater_precedence(\n    inner: &SimpleExpr,\n    outer_oper: &Oper,\n) -> bool {\n    match inner {\n        // We only consider the case where an inner expression is contained in either a\n        // unary or binary expression (with an outer_oper).\n        // We do not need to wrap with parentheses:\n        // Columns, tuples (already wrapped), constants, function calls, values,\n        // keywords, subqueries (already wrapped), case (already wrapped)\n        SimpleExpr::Column(_)\n        | SimpleExpr::Tuple(_)\n        | SimpleExpr::Constant(_)\n        | SimpleExpr::FunctionCall(_)\n        | SimpleExpr::Value(_)\n        | SimpleExpr::Keyword(_)\n        | SimpleExpr::Case(_)\n        | SimpleExpr::SubQuery(_, _) => true,\n        SimpleExpr::Binary(_, inner_oper, _) => {\n            #[cfg(feature = \"option-more-parentheses\")]\n            {\n                return false;\n            }\n            let inner_oper: Oper = (*inner_oper).into();\n            if inner_oper.is_arithmetic() || inner_oper.is_shift() {\n                outer_oper.is_comparison()\n                    || outer_oper.is_between()\n                    || outer_oper.is_in()\n                    || outer_oper.is_like()\n                    || outer_oper.is_logical()\n            } else if inner_oper.is_comparison()\n                || inner_oper.is_in()\n                || inner_oper.is_like()\n                || inner_oper.is_is()\n            {\n                outer_oper.is_logical()\n            } else {\n                false\n            }\n        }\n        _ => false,\n    }\n}\n\npub(crate) fn common_well_known_left_associative(op: &BinOper) -> bool {\n    matches!(\n        op,\n        BinOper::And | BinOper::Or | BinOper::Add | BinOper::Sub | BinOper::Mul | BinOper::Mod\n    )\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "03dfda770e32fd59c16b283ecec9bf224259f8e1",
    "func": "pub use super::*;\nuse uuid::Uuid;\n\npub async fn test_create_cake(db: &DbConn) {\n    let seaside_bakery = bakery::ActiveModel {\n        name: Set(\"SeaSide Bakery\".to_owned()),\n        profit_margin: Set(10.4),\n        ..Default::default()\n    };\n    let bakery_insert_res = Bakery::insert(seaside_bakery)\n        .exec(db)\n        .await\n        .expect(\"could not insert bakery\");\n\n    let baker_bob = baker::ActiveModel {\n        name: Set(\"Baker Bob\".to_owned()),\n        contact_details: Set(serde_json::json!({\n            \"mobile\": \"+61424000000\",\n            \"home\": \"0395555555\",\n            \"address\": \"12 Test St, Testville, Vic, Australia\"\n        })),\n        bakery_id: Set(Some(bakery_insert_res.last_insert_id)),\n        ..Default::default()\n    };\n    let baker_insert_res = Baker::insert(baker_bob)\n        .exec(db)\n        .await\n        .expect(\"could not insert baker\");\n    let uuid = Uuid::new_v4();\n\n    let mud_cake = cake::ActiveModel {\n        name: Set(\"Mud Cake\".to_owned()),\n        price: Set(rust_dec(-10.25)),\n        gluten_free: Set(false),\n        serial: Set(uuid),\n        bakery_id: Set(Some(bakery_insert_res.last_insert_id)),\n        ..Default::default()\n    };\n\n    let cake_insert_res = Cake::insert(mud_cake)\n        .exec(db)\n        .await\n        .expect(\"could not insert cake\");\n\n    let cake: Option<cake::Model> = Cake::find_by_id(cake_insert_res.last_insert_id)\n        .one(db)\n        .await\n        .expect(\"could not find cake\");\n\n    let cake_baker = cakes_bakers::ActiveModel {\n        cake_id: Set(cake_insert_res.last_insert_id),\n        baker_id: Set(baker_insert_res.last_insert_id),\n    };\n    let cake_baker_res = CakesBakers::insert(cake_baker.clone())\n        .exec(db)\n        .await\n        .expect(\"could not insert cake_baker\");\n    assert_eq!(\n        cake_baker_res.last_insert_id,\n        (cake_baker.cake_id.unwrap(), cake_baker.baker_id.unwrap())\n    );\n\n    assert!(cake.is_some());\n    let cake_model = cake.unwrap();\n    assert_eq!(cake_model.name, \"Mud Cake\");\n    assert_eq!(cake_model.price, rust_dec(-10.25));\n    assert!(!cake_model.gluten_free);\n    assert_eq!(\n        cake_model\n            .find_related(Bakery)\n            .one(db)\n            .await\n            .expect(\"Bakery not found\")\n            .unwrap()\n            .name,\n        \"SeaSide Bakery\"\n    );\n    assert_eq!(cake_model.serial, uuid);\n\n    let related_bakers: Vec<baker::Model> = cake_model\n        .find_related(Baker)\n        .all(db)\n        .await\n        .expect(\"could not find related bakers\");\n    assert_eq!(related_bakers.len(), 1);\n    assert_eq!(related_bakers[0].name, \"Baker Bob\");\n\n    let baker: Option<baker::Model> = Baker::find_by_id(baker_insert_res.last_insert_id)\n        .one(db)\n        .await\n        .expect(\"could not find baker\");\n\n    let related_cakes: Vec<cake::Model> = baker\n        .unwrap()\n        .find_related(Cake)\n        .all(db)\n        .await\n        .expect(\"could not find related cakes\");\n    assert_eq!(related_cakes.len(), 1);\n    assert_eq!(related_cakes[0].name, \"Mud Cake\")\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "1d5feadfb3af452c81c853428a59e9cdaa2010cf",
    "func": "fn main() {\n    let proto_file = \"./proto/post.proto\";\n\n    tonic_build::configure()\n        .build_server(true)\n        .compile(&[proto_file], &[\".\"])\n        .unwrap_or_else(|e| panic!(\"protobuf compile error: {}\", e));\n\n    println!(\"cargo:rerun-if-changed={}\", proto_file);\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "ae4d6455e4f19eb9f2f284839800ab175afc309e",
    "func": "extern crate base64;\nuse std::collections::HashMap;\n\nuse base64::engine::general_purpose::STANDARD;\nuse base64::Engine;\nuse gloo::file::callbacks::FileReader;\nuse web_sys::{DragEvent, Event, HtmlInputElement};\nuse yew::html::TargetCast;\nuse yew::{html, Callback, Component, Context, Html};\n\npub struct FileDetails {\n    name: String,\n    file_type: String,\n    data: Vec<u8>,\n}\n\npub enum Msg {\n    Loaded(FileDetails),\n    Files(Option<web_sys::FileList>),\n}\n\npub struct App {\n    readers: HashMap<String, FileReader>,\n    files: Vec<FileDetails>,\n}\n\nimpl Component for App {\n    type Message = Msg;\n    type Properties = ();\n\n    fn create(_ctx: &Context<Self>) -> Self {\n        Self {\n            readers: HashMap::default(),\n            files: Vec::default(),\n        }\n    }\n\n    fn update(&mut self, ctx: &Context<Self>, msg: Self::Message) -> bool {\n        match msg {\n            Msg::Loaded(file) => {\n                self.readers.remove(&file.name);\n                self.files.push(file);\n                true\n            }\n            Msg::Files(files) => {\n                for file in gloo::file::FileList::from(files.expect(\"files\")).iter() {\n                    let link = ctx.link().clone();\n                    let name = file.name().clone();\n                    let file_type = file.raw_mime_type();\n\n                    let task = {\n                        gloo::file::callbacks::read_as_bytes(file, move |res| {\n                            link.send_message(Msg::Loaded(FileDetails {\n                                data: res.expect(\"failed to read file\"),\n                                file_type,\n                                name,\n                            }))\n                        })\n                    };\n                    self.readers.insert(file.name(), task);\n                }\n                true\n            }\n        }\n    }\n\n    fn view(&self, ctx: &Context<Self>) -> Html {\n        let noop_drag = Callback::from(|e: DragEvent| {\n            e.prevent_default();\n        });\n\n        html! {\n            <div id=\"wrapper\">\n                <p id=\"title\">{ \"Upload Your Files To The Cloud\" }</p>\n                <label for=\"file-upload\">\n                    <div\n                        id=\"drop-container\"\n                        ondrop={ctx.link().callback(|event: DragEvent| {\n                            event.prevent_default();\n                            Msg::Files(event.data_transfer().unwrap().files())\n                        })}\n                        ondragover={&noop_drag}\n                        ondragenter={&noop_drag}\n                    >\n                        <i class=\"fa fa-cloud-upload\"></i>\n                        <p>{\"Drop your images here or click to select\"}</p>\n                    </div>\n                </label>\n                <input\n                    id=\"file-upload\"\n                    type=\"file\"\n                    accept=\"image/*,video/*\"\n                    multiple={true}\n                    onchange={ctx.link().callback(move |e: Event| {\n                        let input: HtmlInputElement = e.target_unchecked_into();\n                        Msg::Files(input.files())\n                    })}\n                />\n                <div id=\"preview-area\">\n                    { for self.files.iter().map(Self::view_file) }\n                </div>\n            </div>\n        }\n    }\n}\n\nimpl App {\n    fn view_file(file: &FileDetails) -> Html {\n        let file_type = file.file_type.to_string();\n        let src = format!(\"data:{};base64,{}\", file_type, STANDARD.encode(&file.data));\n        html! {\n            <div class=\"preview-tile\">\n                <p class=\"preview-name\">{ &file.name }</p>\n                <div class=\"preview-media\">\n                    if file.file_type.contains(\"image\") {\n                        <img src={src} />\n                    } else if file.file_type.contains(\"video\") {\n                        <video controls={true}>\n                            <source src={src} type={ file_type }/>\n                        </video>\n                    }\n                </div>\n            </div>\n        }\n    }\n}\nfn main() {\n    yew::Renderer::<App>::new().render();\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "7458dbbdd952fd0968f044bdc13f6623637eb549",
    "func": "use std::io::BufRead;\nuse std::marker::PhantomData;\n\nuse super::CommonOptions;\nuse super::CopyFormat;\nuse super::CopyTarget;\nuse crate::deserialize::FromSqlRow;\n#[cfg(feature = \"postgres\")]\nuse crate::pg::value::TypeOidLookup;\nuse crate::pg::Pg;\nuse crate::query_builder::QueryFragment;\nuse crate::query_builder::QueryId;\nuse crate::row::Row;\n#[cfg(feature = \"postgres\")]\nuse crate::row::{self, Field, PartialRow, RowIndex, RowSealed};\nuse crate::AppearsOnTable;\nuse crate::Connection;\nuse crate::Expression;\nuse crate::QueryResult;\nuse crate::Selectable;\n\n#[derive(Default, Debug)]\npub struct CopyToOptions {\n    common: CommonOptions,\n    header: Option<bool>,\n}\n\nimpl CopyToOptions {\n    fn any_set(&self) -> bool {\n        self.common.any_set() || self.header.is_some()\n    }\n}\n\nimpl QueryFragment<Pg> for CopyToOptions {\n    fn walk_ast<'b>(\n        &'b self,\n        mut pass: crate::query_builder::AstPass<'_, 'b, Pg>,\n    ) -> crate::QueryResult<()> {\n        if self.any_set() {\n            let mut comma = \"\";\n            pass.push_sql(\" WITH (\");\n            self.common.walk_ast(pass.reborrow(), &mut comma);\n            if let Some(header_is_set) = self.header {\n                pass.push_sql(comma);\n                // commented out because rustc complains otherwise\n                //comma = \", \";\n                pass.push_sql(\"HEADER \");\n                pass.push_sql(if header_is_set { \"1\" } else { \"0\" });\n            }\n\n            pass.push_sql(\")\");\n        }\n        Ok(())\n    }\n}\n\n#[derive(Debug)]\npub struct CopyToCommand<S> {\n    options: CopyToOptions,\n    p: PhantomData<S>,\n}\n\nimpl<S> QueryId for CopyToCommand<S>\nwhere\n    S: CopyTarget,\n{\n    type QueryId = ();\n\n    const HAS_STATIC_QUERY_ID: bool = false;\n}\n\nimpl<S> QueryFragment<Pg> for CopyToCommand<S>\nwhere\n    S: CopyTarget,\n{\n    fn walk_ast<'b>(\n        &'b self,\n        mut pass: crate::query_builder::AstPass<'_, 'b, Pg>,\n    ) -> crate::QueryResult<()> {\n        pass.unsafe_to_cache_prepared();\n        pass.push_sql(\"COPY \");\n        S::walk_target(pass.reborrow())?;\n        pass.push_sql(\" TO STDOUT\");\n        self.options.walk_ast(pass.reborrow())?;\n        Ok(())\n    }\n}\n\n#[derive(Debug, Clone, Copy)]\npub struct NotSet;\n\npub trait CopyToMarker: Sized {\n    fn setup_options<T>(q: CopyToQuery<T, Self>) -> CopyToQuery<T, CopyToOptions>;\n}\n\nimpl CopyToMarker for NotSet {\n    fn setup_options<T>(q: CopyToQuery<T, Self>) -> CopyToQuery<T, CopyToOptions> {\n        CopyToQuery {\n            target: q.target,\n            options: CopyToOptions::default(),\n        }\n    }\n}\nimpl CopyToMarker for CopyToOptions {\n    fn setup_options<T>(q: CopyToQuery<T, Self>) -> CopyToQuery<T, CopyToOptions> {\n        q\n    }\n}\n/// The structure returned by [`copy_to`]\n///\n/// The [`load`] and the [`load_raw`] methods allow\n/// to receive the configured data from the database.\n/// If you don't have any special needs you should prefer using\n/// the more convenient `load` method.\n///\n/// The `with_*` methods allow to configure the settings used for the\n/// copy statement.\n///\n/// [`load`]: CopyToQuery::load\n/// [`load_raw`]: CopyToQuery::load_raw\n#[derive(Debug)]\n#[must_use = \"`COPY TO` statements are only executed when calling `.load()` or `load_raw()`.\"]\n#[cfg(feature = \"postgres_backend\")]\npub struct CopyToQuery<T, O> {\n    target: T,\n    options: O,\n}\n\n#[cfg(feature = \"postgres\")]\nstruct CopyRow<'a> {\n    buffers: Vec<Option<&'a [u8]>>,\n    result: &'a crate::pg::connection::PgResult,\n}\n\n#[cfg(feature = \"postgres\")]\nstruct CopyField<'a> {\n    field: &'a Option<&'a [u8]>,\n    result: &'a crate::pg::connection::PgResult,\n    col_idx: usize,\n}\n\n#[cfg(feature = \"postgres\")]\nimpl<'f> Field<'f, Pg> for CopyField<'f> {\n    fn field_name(&self) -> Option<&str> {\n        None\n    }\n\n    fn value(&self) -> Option<<Pg as crate::backend::Backend>::RawValue<'_>> {\n        let value = self.field.as_deref()?;\n        Some(crate::pg::PgValue::new_internal(value, self))\n    }\n}\n\n#[cfg(feature = \"postgres\")]\nimpl<'a> TypeOidLookup for CopyField<'a> {\n    fn lookup(&self) -> std::num::NonZeroU32 {\n        self.result.column_type(self.col_idx)\n    }\n}\n\n#[cfg(feature = \"postgres\")]\nimpl RowSealed for CopyRow<'_> {}\n\n#[cfg(feature = \"postgres\")]\nimpl RowIndex<usize> for CopyRow<'_> {\n    fn idx(&self, idx: usize) -> Option<usize> {\n        if idx < self.field_count() {\n            Some(idx)\n        } else {\n            None\n        }\n    }\n}\n\n#[cfg(feature = \"postgres\")]\nimpl<'a> RowIndex<&'a str> for CopyRow<'_> {\n    fn idx(&self, _idx: &'a str) -> Option<usize> {\n        None\n    }\n}\n\n#[cfg(feature = \"postgres\")]\nimpl<'a> Row<'a, Pg> for CopyRow<'_> {\n    type Field<'f> = CopyField<'f>\n    where\n        'a: 'f,\n        Self: 'f;\n\n    type InnerPartialRow = Self;\n\n    fn field_count(&self) -> usize {\n        self.buffers.len()\n    }\n\n    fn get<'b, I>(&'b self, idx: I) -> Option<Self::Field<'b>>\n    where\n        'a: 'b,\n        Self: RowIndex<I>,\n    {\n        let idx = self.idx(idx)?;\n        let buffer = self.buffers.get(idx)?;\n        Some(CopyField {\n            field: buffer,\n            result: self.result,\n            col_idx: idx,\n        })\n    }\n\n    fn partial_row(\n        &self,\n        range: std::ops::Range<usize>,\n    ) -> row::PartialRow<'_, Self::InnerPartialRow> {\n        PartialRow::new(self, range)\n    }\n}\n\npub trait ExecuteCopyToConnection: Connection<Backend = Pg> {\n    type CopyToBuffer<'a>: BufRead;\n\n    fn make_row<'a, 'b>(\n        out: &'a Self::CopyToBuffer<'_>,\n        buffers: Vec<Option<&'a [u8]>>,\n    ) -> impl Row<'b, Pg> + 'a;\n\n    fn get_buffer<'a>(out: &'a Self::CopyToBuffer<'_>) -> &'a [u8];\n\n    fn execute<T>(&mut self, command: CopyToCommand<T>) -> QueryResult<Self::CopyToBuffer<'_>>\n    where\n        T: CopyTarget;\n}\n\n#[cfg(feature = \"postgres\")]\nimpl ExecuteCopyToConnection for crate::PgConnection {\n    type CopyToBuffer<'a> = crate::pg::connection::copy::CopyToBuffer<'a>;\n\n    fn make_row<'a, 'b>(\n        out: &'a Self::CopyToBuffer<'_>,\n        buffers: Vec<Option<&'a [u8]>>,\n    ) -> impl Row<'b, Pg> + 'a {\n        CopyRow {\n            buffers,\n            result: out.get_result(),\n        }\n    }\n\n    fn get_buffer<'a>(out: &'a Self::CopyToBuffer<'_>) -> &'a [u8] {\n        out.data_slice()\n    }\n\n    fn execute<T>(&mut self, command: CopyToCommand<T>) -> QueryResult<Self::CopyToBuffer<'_>>\n    where\n        T: CopyTarget,\n    {\n        self.copy_to(command)\n    }\n}\n\n#[cfg(feature = \"r2d2\")]\nimpl<C> ExecuteCopyToConnection for crate::r2d2::PooledConnection<crate::r2d2::ConnectionManager<C>>\nwhere\n    C: ExecuteCopyToConnection + crate::r2d2::R2D2Connection + 'static,\n{\n    type CopyToBuffer<'a> = C::CopyToBuffer<'a>;\n\n    fn make_row<'a, 'b>(\n        out: &'a Self::CopyToBuffer<'_>,\n        buffers: Vec<Option<&'a [u8]>>,\n    ) -> impl Row<'b, Pg> + 'a {\n        C::make_row(out, buffers)\n    }\n\n    fn get_buffer<'a>(out: &'a Self::CopyToBuffer<'_>) -> &'a [u8] {\n        C::get_buffer(out)\n    }\n\n    fn execute<T>(&mut self, command: CopyToCommand<T>) -> QueryResult<Self::CopyToBuffer<'_>>\n    where\n        T: CopyTarget,\n    {\n        C::execute(&mut **self, command)\n    }\n}\n\nimpl<T> CopyToQuery<T, NotSet>\nwhere\n    T: CopyTarget,\n{\n    /// Copy data from the database by returning an iterator of deserialized data\n    ///\n    /// This function allows to easily load data from the database via a `COPY TO` statement.\n    /// It does **not** allow to configure any settings via the `with_*` method, as it internally\n    /// sets the required options itself. It will use the binary format to deserialize the result\n    /// into the specified type `U`. Column selection is performed via [`Selectable`].\n    pub fn load<U, C>(self, conn: &mut C) -> QueryResult<impl Iterator<Item = QueryResult<U>> + '_>\n    where\n        U: FromSqlRow<<U::SelectExpression as Expression>::SqlType, Pg> + Selectable<Pg>,\n        U::SelectExpression: AppearsOnTable<T::Table> + CopyTarget<Table = T::Table>,\n        C: ExecuteCopyToConnection,\n    {\n        let io_result_mapper = |e| crate::result::Error::DeserializationError(Box::new(e));\n\n        let command = CopyToCommand {\n            p: PhantomData::<U::SelectExpression>,\n            options: CopyToOptions {\n                header: None,\n                common: CommonOptions {\n                    format: Some(CopyFormat::Binary),\n                    ..Default::default()\n                },\n            },\n        };\n        // see https://www.postgresql.org/docs/current/sql-copy.html for\n        // a description of the binary format\n        //\n        // We don't write oids\n\n        let mut out = ExecuteCopyToConnection::execute(conn, command)?;\n        let buffer = out.fill_buf().map_err(io_result_mapper)?;\n        if buffer[..super::COPY_MAGIC_HEADER.len()] != super::COPY_MAGIC_HEADER {\n            return Err(crate::result::Error::DeserializationError(\n                \"Unexpected protocol header\".into(),\n            ));\n        }\n        // we care only about bit 16-31 here, so we can just skip the bytes in between\n        let flags_backward_incompatible = i16::from_be_bytes(\n            (&buffer[super::COPY_MAGIC_HEADER.len() + 2..super::COPY_MAGIC_HEADER.len() + 4])\n                .try_into()\n                .expect(\"Exactly 2 byte\"),\n        );\n        if flags_backward_incompatible != 0 {\n            return Err(crate::result::Error::DeserializationError(\n                format!(\"Unexpected flag value: {flags_backward_incompatible:x}\").into(),\n            ));\n        }\n        let header_size = usize::try_from(i32::from_be_bytes(\n            (&buffer[super::COPY_MAGIC_HEADER.len() + 4..super::COPY_MAGIC_HEADER.len() + 8])\n                .try_into()\n                .expect(\"Exactly 4 byte\"),\n        ))\n        .map_err(|e| crate::result::Error::DeserializationError(Box::new(e)))?;\n        out.consume(super::COPY_MAGIC_HEADER.len() + 8 + header_size);\n        let mut len = None;\n        Ok(std::iter::from_fn(move || {\n            if let Some(len) = len {\n                out.consume(len);\n                if let Err(e) = out.fill_buf().map_err(io_result_mapper) {\n                    return Some(Err(e));\n                }\n            }\n            let buffer = C::get_buffer(&out);\n            len = Some(buffer.len());\n            let tuple_count =\n                i16::from_be_bytes((&buffer[..2]).try_into().expect(\"Exactly 2 bytes\"));\n            if tuple_count > 0 {\n                let tuple_count = match usize::try_from(tuple_count) {\n                    Ok(o) => o,\n                    Err(e) => {\n                        return Some(Err(crate::result::Error::DeserializationError(Box::new(e))))\n                    }\n                };\n                let mut buffers = Vec::with_capacity(tuple_count);\n                let mut offset = 2;\n                for _t in 0..tuple_count {\n                    let data_size = i32::from_be_bytes(\n                        (&buffer[offset..offset + 4])\n                            .try_into()\n                            .expect(\"Exactly 4 bytes\"),\n                    );\n\n                    if data_size < 0 {\n                        buffers.push(None);\n                    } else {\n                        match usize::try_from(data_size) {\n                            Ok(data_size) => {\n                                buffers.push(Some(&buffer[offset + 4..offset + 4 + data_size]));\n                                offset = offset + 4 + data_size;\n                            }\n                            Err(e) => {\n                                return Some(Err(crate::result::Error::DeserializationError(\n                                    Box::new(e),\n                                )));\n                            }\n                        }\n                    }\n                }\n\n                let row = C::make_row(&out, buffers);\n                Some(U::build_from_row(&row).map_err(crate::result::Error::DeserializationError))\n            } else {\n                None\n            }\n        }))\n    }\n}\n\nimpl<T, O> CopyToQuery<T, O>\nwhere\n    O: CopyToMarker,\n    T: CopyTarget,\n{\n    /// Copy data from the database by directly accessing the provided response\n    ///\n    /// This function returns a type that implements [`std::io::BufRead`] which allows to directly read\n    /// the data as provided by the database. The exact format depends on what options are\n    /// set via the various `with_*` methods.\n    pub fn load_raw<C>(self, conn: &mut C) -> QueryResult<impl BufRead + '_>\n    where\n        C: ExecuteCopyToConnection,\n    {\n        let q = O::setup_options(self);\n        let command = CopyToCommand {\n            p: PhantomData::<T>,\n            options: q.options,\n        };\n        ExecuteCopyToConnection::execute(conn, command)\n    }\n\n    /// The format used for the copy statement\n    ///\n    /// See the [PostgreSQL documentation](https://www.postgresql.org/docs/current/sql-copy.html)\n    /// for more details.\n    pub fn with_format(self, format: CopyFormat) -> CopyToQuery<T, CopyToOptions> {\n        let mut out = O::setup_options(self);\n        out.options.common.format = Some(format);\n        out\n    }\n\n    /// Whether or not the `freeze` option is set\n    ///\n    /// See the [PostgreSQL documentation](https://www.postgresql.org/docs/current/sql-copy.html)\n    /// for more details.\n    pub fn with_freeze(self, freeze: bool) -> CopyToQuery<T, CopyToOptions> {\n        let mut out = O::setup_options(self);\n        out.options.common.freeze = Some(freeze);\n        out\n    }\n\n    /// Which delimiter should be used for textual output formats\n    ///\n    /// See the [PostgreSQL documentation](https://www.postgresql.org/docs/current/sql-copy.html)\n    /// for more details.\n    pub fn with_delimiter(self, delimiter: char) -> CopyToQuery<T, CopyToOptions> {\n        let mut out = O::setup_options(self);\n        out.options.common.delimiter = Some(delimiter);\n        out\n    }\n\n    /// Which string should be used in place of a `NULL` value\n    /// for textual output formats\n    ///\n    /// See the [PostgreSQL documentation](https://www.postgresql.org/docs/current/sql-copy.html)\n    /// for more details.\n    pub fn with_null(self, null: impl Into<String>) -> CopyToQuery<T, CopyToOptions> {\n        let mut out = O::setup_options(self);\n        out.options.common.null = Some(null.into());\n        out\n    }\n\n    /// Which quote character should be used for textual output formats\n    ///\n    /// See the [PostgreSQL documentation](https://www.postgresql.org/docs/current/sql-copy.html)\n    /// for more details.\n    pub fn with_quote(self, quote: char) -> CopyToQuery<T, CopyToOptions> {\n        let mut out = O::setup_options(self);\n        out.options.common.quote = Some(quote);\n        out\n    }\n\n    /// Which escape character should be used for textual output formats\n    ///\n    /// See the [PostgreSQL documentation](https://www.postgresql.org/docs/current/sql-copy.html)\n    /// for more details.\n    pub fn with_escape(self, escape: char) -> CopyToQuery<T, CopyToOptions> {\n        let mut out = O::setup_options(self);\n        out.options.common.escape = Some(escape);\n        out\n    }\n\n    /// Is a header provided as part of the textual input or not\n    ///\n    /// See the [PostgreSQL documentation](https://www.postgresql.org/docs/current/sql-copy.html)\n    /// for more details.\n    pub fn with_header(self, set: bool) -> CopyToQuery<T, CopyToOptions> {\n        let mut out = O::setup_options(self);\n        out.options.header = Some(set);\n        out\n    }\n}\n\n/// Creates a `COPY TO` statement\n///\n/// This function constructs a `COPY TO` statement which copies data\n/// from the database **to** a client side target. It's designed to move\n/// larger amounts of data out of the database.\n///\n/// This function accepts a target selection (table name or list of columns) as argument.\n///\n/// There are two ways to use a `COPY TO` statement with diesel:\n///\n/// * By using [`CopyToQuery::load`] directly to load the deserialized result\n///   directly into a specified type\n/// * By using the `with_*` methods to configure the format sent by the database\n///   and then by calling [`CopyToQuery::load_raw`] to receive the raw data\n///   sent by the database.\n///\n/// The first variant uses the `BINARY` format internally to receive\n/// the selected data efficiently. It automatically sets the right options\n/// and does not allow to change them via `with_*` methods.\n///\n/// The second variant allows you to control the behaviour of the\n/// generated `COPY TO` statement in detail. You can use the various\n/// `with_*` methods for that before issuing the statement via [`CopyToQuery::load_raw`].\n/// That method will return an type that implements [`std::io::BufRead`], which\n/// allows you to directly read the response from the database in the configured\n/// format.\n/// See [the postgresql documentation](https://www.postgresql.org/docs/current/sql-copy.html)\n/// for more details about the supported formats.\n///\n/// If you don't have any specific needs you should prefer using the more\n/// convenient first variant.\n///\n/// This functionality is postgresql specific.\n///\n/// # Examples\n///\n/// ## Via [`CopyToQuery::load()`]\n///\n/// ```rust\n/// # include!(\"../../../doctest_setup.rs\");\n/// # use crate::schema::users;\n///\n/// #[derive(Queryable, Selectable, PartialEq, Debug)]\n/// #[diesel(table_name = users)]\n/// #[diesel(check_for_backend(diesel::pg::Pg))]\n/// struct User {\n///     name: String,\n/// }\n///\n/// # fn run_test() -> QueryResult<()> {\n/// # let connection = &mut establish_connection();\n/// let out = diesel::copy_to(users::table)\n///     .load::<User, _>(connection)?\n///     .collect::<Result<Vec<_>, _>>()?;\n///\n/// assert_eq!(out, vec![User{ name: \"Sean\".into() }, User{ name: \"Tess\".into() }]);\n/// # Ok(())\n/// # }\n/// # fn main() {\n/// #    run_test().unwrap();\n/// # }\n/// ```\n///\n/// ## Via [`CopyToQuery::load_raw()`]\n///\n/// ```rust\n/// # include!(\"../../../doctest_setup.rs\");\n/// # fn run_test() -> QueryResult<()> {\n/// # use crate::schema::users;\n/// use diesel::pg::CopyFormat;\n/// use std::io::Read;\n/// # let connection = &mut establish_connection();\n///\n/// let mut copy = diesel::copy_to(users::table)\n///     .with_format(CopyFormat::Csv)\n///     .load_raw(connection)?;\n///\n/// let mut out = String::new();\n/// copy.read_to_string(&mut out).unwrap();\n/// assert_eq!(out, \"1,Sean\\n2,Tess\\n\");\n/// # Ok(())\n/// # }\n/// # fn main() {\n/// #    run_test().unwrap();\n/// # }\n/// ```\n#[cfg(feature = \"postgres_backend\")]\npub fn copy_to<T>(target: T) -> CopyToQuery<T, NotSet>\nwhere\n    T: CopyTarget,\n{\n    CopyToQuery {\n        target,\n        options: NotSet,\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "a40ae29935f3b3860f6bb4dd469b201cd7558372",
    "func": "// Adapted from https://github.com/Alexhuszagh/rust-lexical.\n\n//! Precalculated large powers for limbs.\n\n#[cfg(fast_arithmetic = \"32\")]\npub(crate) use super::large_powers32::*;\n\n#[cfg(fast_arithmetic = \"64\")]\npub(crate) use super::large_powers64::*;\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "8e4a0a1522488ce40da2b100f7dc94aae7f188ac",
    "func": "use sea_orm::entity::prelude::*;\n\n#[derive(Copy, Clone, Default, Debug, DeriveEntity)]\npub struct Entity;\n\nimpl EntityName for Entity {\n    fn schema_name(&self) -> Option<&str> {\n        Some(\"schema_name\")\n    }\n\n    fn table_name(&self) -> &str {\n        \"collection\"\n    }\n}\n\n#[derive(Clone, Debug, PartialEq, DeriveModel, DeriveActiveModel, Eq)]\npub struct Model {\n    pub id: i32,\n    pub integers: Vec<i32>,\n    pub integers_opt: Option<Vec<i32>>,\n}\n\n#[derive(Copy, Clone, Debug, EnumIter, DeriveColumn)]\npub enum Column {\n    Id,\n    Integers,\n    IntegersOpt,\n}\n\n#[derive(Copy, Clone, Debug, EnumIter, DerivePrimaryKey)]\npub enum PrimaryKey {\n    Id,\n}\n\nimpl PrimaryKeyTrait for PrimaryKey {\n    type ValueType = i32;\n    fn auto_increment() -> bool {\n        true\n    }\n}\n\n#[derive(Copy, Clone, Debug, EnumIter)]\npub enum Relation {}\n\nimpl ColumnTrait for Column {\n    type EntityName = Entity;\n    fn def(&self) -> ColumnDef {\n        match self {\n            Self::Id => ColumnType::Integer.def(),\n            Self::Integers => ColumnType::Array(RcOrArc::new(ColumnType::Integer)).def(),\n            Self::IntegersOpt => ColumnType::Array(RcOrArc::new(ColumnType::Integer))\n                .def()\n                .null(),\n        }\n    }\n}\n\nimpl RelationTrait for Relation {\n    fn def(&self) -> RelationDef {\n        panic!(\"No RelationDef\")\n    }\n}\n\nimpl ActiveModelBehavior for ActiveModel {}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "083a5c2a9a27f2bad58a09ef79935b0b3a436466",
    "func": "// @generated automatically by Diesel CLI.\n\npub mod smdb {\n    pub mod sql_types {\n        #[derive(diesel::query_builder::QueryId, Clone, diesel::sql_types::SqlType)]\n        #[diesel(postgres_type(name = \"service_endpoint\", schema = \"smdb\"))]\n        pub struct ServiceEndpoint;\n    }\n\n    diesel::table! {\n        use diesel::sql_types::*;\n        use super::sql_types::ServiceEndpoint;\n\n        smdb.service (service_id) {\n            service_id -> Int4,\n            name -> Text,\n            version -> Int4,\n            online -> Bool,\n            description -> Text,\n            health_check_uri -> Text,\n            base_uri -> Text,\n            dependencies -> Array<Nullable<Int4>>,\n            endpoints -> Array<Nullable<ServiceEndpoint>>,\n        }\n    }\n}\n"
  },
  {
    "project": "",
    "target": 0,
    "commit_id": "27ab990ba48dba44f9667a8a207fa15d01fd5097",
    "func": "// No longer used. Old versions of serde used this macro for supporting targets\n// that did not yet have 128-bit integer support.\n#[macro_export]\n#[doc(hidden)]\nmacro_rules! serde_if_integer128 {\n    ($($tt:tt)*) => {\n        $($tt)*\n    };\n}\n"
  }
]