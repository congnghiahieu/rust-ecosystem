[
  {
    "file_change_id": "85796880631308",
    "hash": "8bfc20506cc5e098fe6eb3d1cafe3bea791215ce",
    "old_path": "lettre/src/smtp/client/mod.rs",
    "new_path": "lettre/src/smtp/client/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -51,7 +51,15 @@ impl ClientCodec {\n                     match self.escape_count {\n                         0 => self.escape_count = if *byte == b'\\r' { 1 } else { 0 },\n                         1 => self.escape_count = if *byte == b'\\n' { 2 } else { 0 },\n-                        2 => self.escape_count = if *byte == b'.' { 3 } else { 0 },\n+                        2 => {\n+                            self.escape_count = if *byte == b'.' {\n+                                3\n+                            } else if *byte == b'\\r' {\n+                                1\n+                            } else {\n+                                0\n+                            }\n+                        }\n                         _ => unreachable!(),\n                     }\n                     if self.escape_count == 3 {\n@@ -286,6 +294,7 @@ mod test {\n         let mut buf: Vec<u8> = vec![];\n \n         assert!(codec.encode(b\"test\\r\\n\", &mut buf).is_ok());\n+        assert!(codec.encode(b\"test\\r\\n\\r\\n\", &mut buf).is_ok());\n         assert!(codec.encode(b\".\\r\\n\", &mut buf).is_ok());\n         assert!(codec.encode(b\"\\r\\ntest\", &mut buf).is_ok());\n         assert!(codec.encode(b\"te\\r\\n.\\r\\nst\", &mut buf).is_ok());\n@@ -296,7 +305,7 @@ mod test {\n         assert!(codec.encode(b\"test\", &mut buf).is_ok());\n         assert_eq!(\n             String::from_utf8(buf).unwrap(),\n-            \"test\\r\\n..\\r\\n\\r\\ntestte\\r\\n..\\r\\nsttesttest.test\\n.test\\ntest\"\n+            \"test\\r\\ntest\\r\\n\\r\\n..\\r\\n\\r\\ntestte\\r\\n..\\r\\nsttesttest.test\\n.test\\ntest\"\n         );\n     }\n \n",
    "diff_parsed": "{'added': [(54, '                        2 => {'), (55, \"                            self.escape_count = if *byte == b'.' {\"), (56, '                                3'), (57, \"                            } else if *byte == b'\\\\r' {\"), (58, '                                1'), (59, '                            } else {'), (60, '                                0'), (61, '                            }'), (62, '                        }'), (297, '        assert!(codec.encode(b\"test\\\\r\\\\n\\\\r\\\\n\", &mut buf).is_ok());'), (308, '            \"test\\\\r\\\\ntest\\\\r\\\\n\\\\r\\\\n..\\\\r\\\\n\\\\r\\\\ntestte\\\\r\\\\n..\\\\r\\\\nsttesttest.test\\\\n.test\\\\ntest\"')], 'deleted': [(54, \"                        2 => self.escape_count = if *byte == b'.' { 3 } else { 0 },\"), (299, '            \"test\\\\r\\\\n..\\\\r\\\\n\\\\r\\\\ntestte\\\\r\\\\n..\\\\r\\\\nsttesttest.test\\\\n.test\\\\ntest\"')]}",
    "num_lines_added": "11",
    "num_lines_deleted": "2",
    "nloc": "245"
  },
  {
    "file_change_id": "23619786521794",
    "hash": "24c7a5550807ac8a09648b5878f19d14c3a69135",
    "old_path": "src/crypto/scalarmult/curve25519.rs",
    "new_path": "src/crypto/scalarmult/curve25519.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -23,14 +23,20 @@ new_type! {\n \n /// `scalarmult()` multiplies a group element `p`\n /// by an integer `n`. It returns the resulting group element\n-/// `q`.\n+/// `Ok(q)`.\n+/// If the the `GroupElement` is all zero, `scalarmult()` returns `Err(())` since\n+/// the resulting `GroupElement` would be all zero, no matter the `Scalar`.\n pub fn scalarmult(&Scalar(ref n): &Scalar,\n-                  &GroupElement(ref p): &GroupElement) -> GroupElement {\n+                  &GroupElement(ref p): &GroupElement)\n+                  -> Result<GroupElement, ()> {\n     let mut q = [0; GROUPELEMENTBYTES];\n     unsafe {\n-        ffi::crypto_scalarmult_curve25519(&mut q, n, p);\n+        if ffi::crypto_scalarmult_curve25519(&mut q, n, p) != 0 {\n+            Err(())\n+        } else {\n+            Ok(GroupElement(q))\n+        }\n     }\n-    GroupElement(q)\n }\n \n /// `scalarmult_base()` computes the scalar product of a standard\n@@ -47,18 +53,17 @@ pub fn scalarmult_base(&Scalar(ref n): &Scalar) -> GroupElement {\n #[cfg(test)]\n mod test {\n     use super::*;\n+    use randombytes::randombytes_into;\n \n     #[test]\n     fn test_vector_1() {\n         // corresponding to tests/scalarmult.c and tests/scalarmult3.cpp from NaCl\n-        let alicesk = Scalar([0x77,0x07,0x6d,0x0a,0x73,0x18,0xa5,0x7d\n-                             ,0x3c,0x16,0xc1,0x72,0x51,0xb2,0x66,0x45\n-                             ,0xdf,0x4c,0x2f,0x87,0xeb,0xc0,0x99,0x2a\n-                             ,0xb1,0x77,0xfb,0xa5,0x1d,0xb9,0x2c,0x2a]);\n-        let alicepk_expected = [0x85,0x20,0xf0,0x09,0x89,0x30,0xa7,0x54\n-                               ,0x74,0x8b,0x7d,0xdc,0xb4,0x3e,0xf7,0x5a\n-                               ,0x0d,0xbf,0x3a,0x0d,0x26,0x38,0x1a,0xf4\n-                               ,0xeb,0xa4,0xa9,0x8e,0xaa,0x9b,0x4e,0x6a];\n+        let alicesk = Scalar([0x77, 0x07, 0x6d, 0x0a, 0x73, 0x18, 0xa5, 0x7d, 0x3c, 0x16, 0xc1,\n+                              0x72, 0x51, 0xb2, 0x66, 0x45, 0xdf, 0x4c, 0x2f, 0x87, 0xeb, 0xc0,\n+                              0x99, 0x2a, 0xb1, 0x77, 0xfb, 0xa5, 0x1d, 0xb9, 0x2c, 0x2a]);\n+        let alicepk_expected = [0x85, 0x20, 0xf0, 0x09, 0x89, 0x30, 0xa7, 0x54, 0x74, 0x8b, 0x7d,\n+                                0xdc, 0xb4, 0x3e, 0xf7, 0x5a, 0x0d, 0xbf, 0x3a, 0x0d, 0x26, 0x38,\n+                                0x1a, 0xf4, 0xeb, 0xa4, 0xa9, 0x8e, 0xaa, 0x9b, 0x4e, 0x6a];\n         let GroupElement(alicepk) = scalarmult_base(&alicesk);\n         assert!(alicepk == alicepk_expected);\n     }\n@@ -66,14 +71,12 @@ mod test {\n     #[test]\n     fn test_vector_2() {\n         // corresponding to tests/scalarmult2.c and tests/scalarmult4.cpp from NaCl\n-        let bobsk = Scalar([0x5d,0xab,0x08,0x7e,0x62,0x4a,0x8a,0x4b\n-                           ,0x79,0xe1,0x7f,0x8b,0x83,0x80,0x0e,0xe6\n-                           ,0x6f,0x3b,0xb1,0x29,0x26,0x18,0xb6,0xfd\n-                           ,0x1c,0x2f,0x8b,0x27,0xff,0x88,0xe0,0xeb]);\n-        let bobpk_expected = [0xde,0x9e,0xdb,0x7d,0x7b,0x7d,0xc1,0xb4\n-                             ,0xd3,0x5b,0x61,0xc2,0xec,0xe4,0x35,0x37\n-                             ,0x3f,0x83,0x43,0xc8,0x5b,0x78,0x67,0x4d\n-                             ,0xad,0xfc,0x7e,0x14,0x6f,0x88,0x2b,0x4f];\n+        let bobsk = Scalar([0x5d, 0xab, 0x08, 0x7e, 0x62, 0x4a, 0x8a, 0x4b, 0x79, 0xe1, 0x7f,\n+                            0x8b, 0x83, 0x80, 0x0e, 0xe6, 0x6f, 0x3b, 0xb1, 0x29, 0x26, 0x18,\n+                            0xb6, 0xfd, 0x1c, 0x2f, 0x8b, 0x27, 0xff, 0x88, 0xe0, 0xeb]);\n+        let bobpk_expected = [0xde, 0x9e, 0xdb, 0x7d, 0x7b, 0x7d, 0xc1, 0xb4, 0xd3, 0x5b, 0x61,\n+                              0xc2, 0xec, 0xe4, 0x35, 0x37, 0x3f, 0x83, 0x43, 0xc8, 0x5b, 0x78,\n+                              0x67, 0x4d, 0xad, 0xfc, 0x7e, 0x14, 0x6f, 0x88, 0x2b, 0x4f];\n         let GroupElement(bobpk) = scalarmult_base(&bobsk);\n         assert!(bobpk == bobpk_expected);\n     }\n@@ -81,40 +84,46 @@ mod test {\n     #[test]\n     fn test_vector_3() {\n         // corresponding to tests/scalarmult5.c and tests/scalarmult7.cpp from NaCl\n-        let alicesk = Scalar([0x77,0x07,0x6d,0x0a,0x73,0x18,0xa5,0x7d\n-                             ,0x3c,0x16,0xc1,0x72,0x51,0xb2,0x66,0x45\n-                             ,0xdf,0x4c,0x2f,0x87,0xeb,0xc0,0x99,0x2a\n-                             ,0xb1,0x77,0xfb,0xa5,0x1d,0xb9,0x2c,0x2a]);\n-        let bobpk = GroupElement([0xde,0x9e,0xdb,0x7d,0x7b,0x7d,0xc1,0xb4\n-                                 ,0xd3,0x5b,0x61,0xc2,0xec,0xe4,0x35,0x37\n-                                 ,0x3f,0x83,0x43,0xc8,0x5b,0x78,0x67,0x4d\n-                                 ,0xad,0xfc,0x7e,0x14,0x6f,0x88,0x2b,0x4f]);\n-        let k_expected = [0x4a,0x5d,0x9d,0x5b,0xa4,0xce,0x2d,0xe1\n-                         ,0x72,0x8e,0x3b,0xf4,0x80,0x35,0x0f,0x25\n-                         ,0xe0,0x7e,0x21,0xc9,0x47,0xd1,0x9e,0x33\n-                         ,0x76,0xf0,0x9b,0x3c,0x1e,0x16,0x17,0x42];\n-        let GroupElement(k) = scalarmult(&alicesk, &bobpk);\n+        let alicesk = Scalar([0x77, 0x07, 0x6d, 0x0a, 0x73, 0x18, 0xa5, 0x7d, 0x3c, 0x16, 0xc1,\n+                              0x72, 0x51, 0xb2, 0x66, 0x45, 0xdf, 0x4c, 0x2f, 0x87, 0xeb, 0xc0,\n+                              0x99, 0x2a, 0xb1, 0x77, 0xfb, 0xa5, 0x1d, 0xb9, 0x2c, 0x2a]);\n+        let bobpk = GroupElement([0xde, 0x9e, 0xdb, 0x7d, 0x7b, 0x7d, 0xc1, 0xb4, 0xd3, 0x5b,\n+                                  0x61, 0xc2, 0xec, 0xe4, 0x35, 0x37, 0x3f, 0x83, 0x43, 0xc8,\n+                                  0x5b, 0x78, 0x67, 0x4d, 0xad, 0xfc, 0x7e, 0x14, 0x6f, 0x88,\n+                                  0x2b, 0x4f]);\n+        let k_expected = [0x4a, 0x5d, 0x9d, 0x5b, 0xa4, 0xce, 0x2d, 0xe1, 0x72, 0x8e, 0x3b, 0xf4,\n+                          0x80, 0x35, 0x0f, 0x25, 0xe0, 0x7e, 0x21, 0xc9, 0x47, 0xd1, 0x9e, 0x33,\n+                          0x76, 0xf0, 0x9b, 0x3c, 0x1e, 0x16, 0x17, 0x42];\n+        let GroupElement(k) = scalarmult(&alicesk, &bobpk).unwrap();\n         assert!(k == k_expected);\n     }\n \n     #[test]\n     fn test_vector_4() {\n         // corresponding to tests/scalarmult6.c from NaCl\n-        let bobsk = Scalar([0x5d,0xab,0x08,0x7e,0x62,0x4a,0x8a,0x4b\n-                           ,0x79,0xe1,0x7f,0x8b,0x83,0x80,0x0e,0xe6\n-                           ,0x6f,0x3b,0xb1,0x29,0x26,0x18,0xb6,0xfd\n-                           ,0x1c,0x2f,0x8b,0x27,0xff,0x88,0xe0,0xeb]);\n-        let alicepk = GroupElement([0x85,0x20,0xf0,0x09,0x89,0x30,0xa7,0x54\n-                                   ,0x74,0x8b,0x7d,0xdc,0xb4,0x3e,0xf7,0x5a\n-                                   ,0x0d,0xbf,0x3a,0x0d,0x26,0x38,0x1a,0xf4\n-                                   ,0xeb,0xa4,0xa9,0x8e,0xaa,0x9b,0x4e,0x6a]);\n-        let k_expected = [0x4a,0x5d,0x9d,0x5b,0xa4,0xce,0x2d,0xe1\n-                         ,0x72,0x8e,0x3b,0xf4,0x80,0x35,0x0f,0x25\n-                         ,0xe0,0x7e,0x21,0xc9,0x47,0xd1,0x9e,0x33\n-                         ,0x76,0xf0,0x9b,0x3c,0x1e,0x16,0x17,0x42];\n-        let GroupElement(k) = scalarmult(&bobsk, &alicepk);\n+        let bobsk = Scalar([0x5d, 0xab, 0x08, 0x7e, 0x62, 0x4a, 0x8a, 0x4b, 0x79, 0xe1, 0x7f,\n+                            0x8b, 0x83, 0x80, 0x0e, 0xe6, 0x6f, 0x3b, 0xb1, 0x29, 0x26, 0x18,\n+                            0xb6, 0xfd, 0x1c, 0x2f, 0x8b, 0x27, 0xff, 0x88, 0xe0, 0xeb]);\n+        let alicepk = GroupElement([0x85, 0x20, 0xf0, 0x09, 0x89, 0x30, 0xa7, 0x54, 0x74, 0x8b,\n+                                    0x7d, 0xdc, 0xb4, 0x3e, 0xf7, 0x5a, 0x0d, 0xbf, 0x3a, 0x0d,\n+                                    0x26, 0x38, 0x1a, 0xf4, 0xeb, 0xa4, 0xa9, 0x8e, 0xaa, 0x9b,\n+                                    0x4e, 0x6a]);\n+        let k_expected = [0x4a, 0x5d, 0x9d, 0x5b, 0xa4, 0xce, 0x2d, 0xe1, 0x72, 0x8e, 0x3b, 0xf4,\n+                          0x80, 0x35, 0x0f, 0x25, 0xe0, 0x7e, 0x21, 0xc9, 0x47, 0xd1, 0x9e, 0x33,\n+                          0x76, 0xf0, 0x9b, 0x3c, 0x1e, 0x16, 0x17, 0x42];\n+        let GroupElement(k) = scalarmult(&bobsk, &alicepk).unwrap();\n         assert!(k == k_expected);\n     }\n+\n+    #[test]\n+    #[should_panic]\n+    fn test_all_zero() {\n+        let mut sk = [0; SCALARBYTES];\n+        randombytes_into(&mut sk);\n+        let sk = Scalar(sk);\n+        let pk = GroupElement([0; GROUPELEMENTBYTES]);\n+        let _ = scalarmult(&sk, &pk).unwrap();\n+    }\n }\n \n #[cfg(feature = \"benchmarks\")]\n",
    "diff_parsed": "{'added': [(30, '                  &GroupElement(ref p): &GroupElement)'), (31, '                  -> Result<GroupElement, ()> {'), (34, '        if ffi::crypto_scalarmult_curve25519(&mut q, n, p) != 0 {'), (35, '            Err(())'), (36, '        } else {'), (37, '            Ok(GroupElement(q))'), (38, '        }'), (56, '    use randombytes::randombytes_into;'), (61, '        let alicesk = Scalar([0x77, 0x07, 0x6d, 0x0a, 0x73, 0x18, 0xa5, 0x7d, 0x3c, 0x16, 0xc1,'), (62, '                              0x72, 0x51, 0xb2, 0x66, 0x45, 0xdf, 0x4c, 0x2f, 0x87, 0xeb, 0xc0,'), (63, '                              0x99, 0x2a, 0xb1, 0x77, 0xfb, 0xa5, 0x1d, 0xb9, 0x2c, 0x2a]);'), (64, '        let alicepk_expected = [0x85, 0x20, 0xf0, 0x09, 0x89, 0x30, 0xa7, 0x54, 0x74, 0x8b, 0x7d,'), (65, '                                0xdc, 0xb4, 0x3e, 0xf7, 0x5a, 0x0d, 0xbf, 0x3a, 0x0d, 0x26, 0x38,'), (66, '                                0x1a, 0xf4, 0xeb, 0xa4, 0xa9, 0x8e, 0xaa, 0x9b, 0x4e, 0x6a];'), (74, '        let bobsk = Scalar([0x5d, 0xab, 0x08, 0x7e, 0x62, 0x4a, 0x8a, 0x4b, 0x79, 0xe1, 0x7f,'), (75, '                            0x8b, 0x83, 0x80, 0x0e, 0xe6, 0x6f, 0x3b, 0xb1, 0x29, 0x26, 0x18,'), (76, '                            0xb6, 0xfd, 0x1c, 0x2f, 0x8b, 0x27, 0xff, 0x88, 0xe0, 0xeb]);'), (77, '        let bobpk_expected = [0xde, 0x9e, 0xdb, 0x7d, 0x7b, 0x7d, 0xc1, 0xb4, 0xd3, 0x5b, 0x61,'), (78, '                              0xc2, 0xec, 0xe4, 0x35, 0x37, 0x3f, 0x83, 0x43, 0xc8, 0x5b, 0x78,'), (79, '                              0x67, 0x4d, 0xad, 0xfc, 0x7e, 0x14, 0x6f, 0x88, 0x2b, 0x4f];'), (87, '        let alicesk = Scalar([0x77, 0x07, 0x6d, 0x0a, 0x73, 0x18, 0xa5, 0x7d, 0x3c, 0x16, 0xc1,'), (88, '                              0x72, 0x51, 0xb2, 0x66, 0x45, 0xdf, 0x4c, 0x2f, 0x87, 0xeb, 0xc0,'), (89, '                              0x99, 0x2a, 0xb1, 0x77, 0xfb, 0xa5, 0x1d, 0xb9, 0x2c, 0x2a]);'), (90, '        let bobpk = GroupElement([0xde, 0x9e, 0xdb, 0x7d, 0x7b, 0x7d, 0xc1, 0xb4, 0xd3, 0x5b,'), (91, '                                  0x61, 0xc2, 0xec, 0xe4, 0x35, 0x37, 0x3f, 0x83, 0x43, 0xc8,'), (92, '                                  0x5b, 0x78, 0x67, 0x4d, 0xad, 0xfc, 0x7e, 0x14, 0x6f, 0x88,'), (93, '                                  0x2b, 0x4f]);'), (94, '        let k_expected = [0x4a, 0x5d, 0x9d, 0x5b, 0xa4, 0xce, 0x2d, 0xe1, 0x72, 0x8e, 0x3b, 0xf4,'), (95, '                          0x80, 0x35, 0x0f, 0x25, 0xe0, 0x7e, 0x21, 0xc9, 0x47, 0xd1, 0x9e, 0x33,'), (96, '                          0x76, 0xf0, 0x9b, 0x3c, 0x1e, 0x16, 0x17, 0x42];'), (97, '        let GroupElement(k) = scalarmult(&alicesk, &bobpk).unwrap();'), (104, '        let bobsk = Scalar([0x5d, 0xab, 0x08, 0x7e, 0x62, 0x4a, 0x8a, 0x4b, 0x79, 0xe1, 0x7f,'), (105, '                            0x8b, 0x83, 0x80, 0x0e, 0xe6, 0x6f, 0x3b, 0xb1, 0x29, 0x26, 0x18,'), (106, '                            0xb6, 0xfd, 0x1c, 0x2f, 0x8b, 0x27, 0xff, 0x88, 0xe0, 0xeb]);'), (107, '        let alicepk = GroupElement([0x85, 0x20, 0xf0, 0x09, 0x89, 0x30, 0xa7, 0x54, 0x74, 0x8b,'), (108, '                                    0x7d, 0xdc, 0xb4, 0x3e, 0xf7, 0x5a, 0x0d, 0xbf, 0x3a, 0x0d,'), (109, '                                    0x26, 0x38, 0x1a, 0xf4, 0xeb, 0xa4, 0xa9, 0x8e, 0xaa, 0x9b,'), (110, '                                    0x4e, 0x6a]);'), (111, '        let k_expected = [0x4a, 0x5d, 0x9d, 0x5b, 0xa4, 0xce, 0x2d, 0xe1, 0x72, 0x8e, 0x3b, 0xf4,'), (112, '                          0x80, 0x35, 0x0f, 0x25, 0xe0, 0x7e, 0x21, 0xc9, 0x47, 0xd1, 0x9e, 0x33,'), (113, '                          0x76, 0xf0, 0x9b, 0x3c, 0x1e, 0x16, 0x17, 0x42];'), (114, '        let GroupElement(k) = scalarmult(&bobsk, &alicepk).unwrap();'), (118, '    #[test]'), (119, '    #[should_panic]'), (120, '    fn test_all_zero() {'), (121, '        let mut sk = [0; SCALARBYTES];'), (122, '        randombytes_into(&mut sk);'), (123, '        let sk = Scalar(sk);'), (124, '        let pk = GroupElement([0; GROUPELEMENTBYTES]);'), (125, '        let _ = scalarmult(&sk, &pk).unwrap();'), (126, '    }')], 'deleted': [(28, '                  &GroupElement(ref p): &GroupElement) -> GroupElement {'), (31, '        ffi::crypto_scalarmult_curve25519(&mut q, n, p);'), (33, '    GroupElement(q)'), (54, '        let alicesk = Scalar([0x77,0x07,0x6d,0x0a,0x73,0x18,0xa5,0x7d'), (55, '                             ,0x3c,0x16,0xc1,0x72,0x51,0xb2,0x66,0x45'), (56, '                             ,0xdf,0x4c,0x2f,0x87,0xeb,0xc0,0x99,0x2a'), (57, '                             ,0xb1,0x77,0xfb,0xa5,0x1d,0xb9,0x2c,0x2a]);'), (58, '        let alicepk_expected = [0x85,0x20,0xf0,0x09,0x89,0x30,0xa7,0x54'), (59, '                               ,0x74,0x8b,0x7d,0xdc,0xb4,0x3e,0xf7,0x5a'), (60, '                               ,0x0d,0xbf,0x3a,0x0d,0x26,0x38,0x1a,0xf4'), (61, '                               ,0xeb,0xa4,0xa9,0x8e,0xaa,0x9b,0x4e,0x6a];'), (69, '        let bobsk = Scalar([0x5d,0xab,0x08,0x7e,0x62,0x4a,0x8a,0x4b'), (70, '                           ,0x79,0xe1,0x7f,0x8b,0x83,0x80,0x0e,0xe6'), (71, '                           ,0x6f,0x3b,0xb1,0x29,0x26,0x18,0xb6,0xfd'), (72, '                           ,0x1c,0x2f,0x8b,0x27,0xff,0x88,0xe0,0xeb]);'), (73, '        let bobpk_expected = [0xde,0x9e,0xdb,0x7d,0x7b,0x7d,0xc1,0xb4'), (74, '                             ,0xd3,0x5b,0x61,0xc2,0xec,0xe4,0x35,0x37'), (75, '                             ,0x3f,0x83,0x43,0xc8,0x5b,0x78,0x67,0x4d'), (76, '                             ,0xad,0xfc,0x7e,0x14,0x6f,0x88,0x2b,0x4f];'), (84, '        let alicesk = Scalar([0x77,0x07,0x6d,0x0a,0x73,0x18,0xa5,0x7d'), (85, '                             ,0x3c,0x16,0xc1,0x72,0x51,0xb2,0x66,0x45'), (86, '                             ,0xdf,0x4c,0x2f,0x87,0xeb,0xc0,0x99,0x2a'), (87, '                             ,0xb1,0x77,0xfb,0xa5,0x1d,0xb9,0x2c,0x2a]);'), (88, '        let bobpk = GroupElement([0xde,0x9e,0xdb,0x7d,0x7b,0x7d,0xc1,0xb4'), (89, '                                 ,0xd3,0x5b,0x61,0xc2,0xec,0xe4,0x35,0x37'), (90, '                                 ,0x3f,0x83,0x43,0xc8,0x5b,0x78,0x67,0x4d'), (91, '                                 ,0xad,0xfc,0x7e,0x14,0x6f,0x88,0x2b,0x4f]);'), (92, '        let k_expected = [0x4a,0x5d,0x9d,0x5b,0xa4,0xce,0x2d,0xe1'), (93, '                         ,0x72,0x8e,0x3b,0xf4,0x80,0x35,0x0f,0x25'), (94, '                         ,0xe0,0x7e,0x21,0xc9,0x47,0xd1,0x9e,0x33'), (95, '                         ,0x76,0xf0,0x9b,0x3c,0x1e,0x16,0x17,0x42];'), (96, '        let GroupElement(k) = scalarmult(&alicesk, &bobpk);'), (103, '        let bobsk = Scalar([0x5d,0xab,0x08,0x7e,0x62,0x4a,0x8a,0x4b'), (104, '                           ,0x79,0xe1,0x7f,0x8b,0x83,0x80,0x0e,0xe6'), (105, '                           ,0x6f,0x3b,0xb1,0x29,0x26,0x18,0xb6,0xfd'), (106, '                           ,0x1c,0x2f,0x8b,0x27,0xff,0x88,0xe0,0xeb]);'), (107, '        let alicepk = GroupElement([0x85,0x20,0xf0,0x09,0x89,0x30,0xa7,0x54'), (108, '                                   ,0x74,0x8b,0x7d,0xdc,0xb4,0x3e,0xf7,0x5a'), (109, '                                   ,0x0d,0xbf,0x3a,0x0d,0x26,0x38,0x1a,0xf4'), (110, '                                   ,0xeb,0xa4,0xa9,0x8e,0xaa,0x9b,0x4e,0x6a]);'), (111, '        let k_expected = [0x4a,0x5d,0x9d,0x5b,0xa4,0xce,0x2d,0xe1'), (112, '                         ,0x72,0x8e,0x3b,0xf4,0x80,0x35,0x0f,0x25'), (113, '                         ,0xe0,0x7e,0x21,0xc9,0x47,0xd1,0x9e,0x33'), (114, '                         ,0x76,0xf0,0x9b,0x3c,0x1e,0x16,0x17,0x42];'), (115, '        let GroupElement(k) = scalarmult(&bobsk, &alicepk);')]}",
    "num_lines_added": "51",
    "num_lines_deleted": "45",
    "nloc": "122"
  },
  {
    "file_change_id": "265029568563639",
    "hash": "7ab8a264980d23c2ed64e72f4636f38b7381eb39",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -178,7 +178,7 @@ pub fn time_remaining(timeout_point: std::time::Instant) -> std::time::Duration\n /// Creates a future for `job` and runs `job`. The result of `job` will be set as result into the\n /// future. The parameter passed to `job` is a function that returns if the future is still waiting\n /// so that `job` can check for cancellation.\n-pub fn async_with_state<T: 'static, U: 'static, F: FnOnce(Future<T, U>) + Send + 'static>(job: F, shared_state: U) -> Future<T, U> {\n+pub fn async_with_state<T: 'static + Send, U: 'static + Send, F: FnOnce(Future<T, U>) + Send + 'static>(job: F, shared_state: U) -> Future<T, U> {\n \tuse std::clone::Clone;\n \t\n \t// Create future and spawn job\n@@ -192,7 +192,7 @@ pub fn async_with_state<T: 'static, U: 'static, F: FnOnce(Future<T, U>) + Send +\n /// Creates a future for `job` and runs `job`. The result of `job` will be set as result into the\n /// future. The parameter passed to `job` is a function that returns if the future is still waiting\n /// so that `job` can check for cancellation.\n-pub fn async<T: 'static, F: FnOnce(Future<T, ()>) + Send + 'static>(job: F) -> Future<T, ()> {\n+pub fn async<T: 'static + Send, F: FnOnce(Future<T, ()>) + Send + 'static>(job: F) -> Future<T, ()> {\n \tasync_with_state(job, ())\n }\n \n",
    "diff_parsed": "{'added': [(181, \"pub fn async_with_state<T: 'static + Send, U: 'static + Send, F: FnOnce(Future<T, U>) + Send + 'static>(job: F, shared_state: U) -> Future<T, U> {\"), (195, \"pub fn async<T: 'static + Send, F: FnOnce(Future<T, ()>) + Send + 'static>(job: F) -> Future<T, ()> {\")], 'deleted': [(181, \"pub fn async_with_state<T: 'static, U: 'static, F: FnOnce(Future<T, U>) + Send + 'static>(job: F, shared_state: U) -> Future<T, U> {\"), (195, \"pub fn async<T: 'static, F: FnOnce(Future<T, ()>) + Send + 'static>(job: F) -> Future<T, ()> {\")]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "193"
  },
  {
    "file_change_id": "35664439883993",
    "hash": "c7919199a0f6d1ce0e3c33499d1b37f862c990e4",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -162,7 +162,7 @@ impl<T, U> Clone for Future<T, U> {\n \t\tFuture(self.0.clone())\n \t}\n }\n-unsafe impl<T, U> Send for Future<T, U> {}\n+unsafe impl<T: Send, U: Send> Send for Future<T, U> {}\n unsafe impl<T, U> Sync for Future<T, U> {}\n \n \n",
    "diff_parsed": "{'added': [(165, 'unsafe impl<T: Send, U: Send> Send for Future<T, U> {}')], 'deleted': [(165, 'unsafe impl<T, U> Send for Future<T, U> {}')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "193"
  },
  {
    "file_change_id": "70602414388617",
    "hash": "2ef3628dac35aeba0a97d5fb3a57746b4e1d62b3",
    "old_path": "src/functions.rs",
    "new_path": "src/functions.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -12,6 +12,8 @@\n //! use regex::Regex;\n //! use rusqlite::functions::FunctionFlags;\n //! use rusqlite::{Connection, Error, Result, NO_PARAMS};\n+//! use std::sync::Arc;\n+//! type BoxError = Box<dyn std::error::Error + Send + Sync + 'static>;\n //!\n //! fn add_regexp_function(db: &Connection) -> Result<()> {\n //!     db.create_scalar_function(\n@@ -20,34 +22,19 @@\n //!         FunctionFlags::SQLITE_UTF8 | FunctionFlags::SQLITE_DETERMINISTIC,\n //!         move |ctx| {\n //!             assert_eq!(ctx.len(), 2, \"called with unexpected number of arguments\");\n-//!\n-//!             let saved_re: Option<&Regex> = ctx.get_aux(0)?;\n-//!             let new_re = match saved_re {\n-//!                 None => {\n-//!                     let s = ctx.get::<String>(0)?;\n-//!                     match Regex::new(&s) {\n-//!                         Ok(r) => Some(r),\n-//!                         Err(err) => return Err(Error::UserFunctionError(Box::new(err))),\n-//!                     }\n-//!                 }\n-//!                 Some(_) => None,\n-//!             };\n-//!\n+//!             let regexp: Arc<Regex> = ctx\n+//!                 .get_or_create_aux(0, |vr| -> Result<_, BoxError> {\n+//!                     Ok(Regex::new(vr.as_str()?)?)\n+//!                 })?;\n //!             let is_match = {\n-//!                 let re = saved_re.unwrap_or_else(|| new_re.as_ref().unwrap());\n-//!\n //!                 let text = ctx\n //!                     .get_raw(1)\n //!                     .as_str()\n //!                     .map_err(|e| Error::UserFunctionError(e.into()))?;\n //!\n-//!                 re.is_match(text)\n+//!                 regexp.is_match(text)\n //!             };\n //!\n-//!             if let Some(re) = new_re {\n-//!                 ctx.set_aux(0, re);\n-//!             }\n-//!\n //!             Ok(is_match)\n //!         },\n //!     )\n@@ -67,11 +54,12 @@\n //!     Ok(())\n //! }\n //! ```\n-use std::any::TypeId;\n+use std::any::Any;\n use std::os::raw::{c_int, c_void};\n use std::panic::{catch_unwind, RefUnwindSafe, UnwindSafe};\n use std::ptr;\n use std::slice;\n+use std::sync::Arc;\n \n use crate::ffi;\n use crate::ffi::sqlite3_context;\n@@ -121,6 +109,7 @@ unsafe extern \"C\" fn free_boxed_value<T>(p: *mut c_void) {\n pub struct Context<'a> {\n     ctx: *mut sqlite3_context,\n     args: &'a [*mut sqlite3_value],\n+    // conn: PhantomData<&'conn mut Connection>,\n }\n \n impl Context<'_> {\n@@ -174,47 +163,60 @@ impl Context<'_> {\n         unsafe { ValueRef::from_value(arg) }\n     }\n \n+    pub fn get_or_create_aux<T, E, F>(&self, arg: c_int, func: F) -> Result<Arc<T>>\n+    where\n+        T: Send + Sync + 'static,\n+        E: Into<Box<dyn std::error::Error + Send + Sync + 'static>>,\n+        F: FnOnce(ValueRef<'_>) -> Result<T, E>,\n+    {\n+        if let Some(v) = self.get_aux(arg)? {\n+            Ok(v)\n+        } else {\n+            let vr = self.get_raw(arg as usize);\n+            self.set_aux(\n+                arg,\n+                func(vr).map_err(|e| Error::UserFunctionError(e.into()))?,\n+            )\n+        }\n+    }\n+\n     /// Sets the auxilliary data associated with a particular parameter. See\n     /// https://www.sqlite.org/c3ref/get_auxdata.html for a discussion of\n     /// this feature, or the unit tests of this module for an example.\n-    pub fn set_aux<T: 'static>(&self, arg: c_int, value: T) {\n-        let boxed = Box::into_raw(Box::new(AuxData {\n-            id: TypeId::of::<T>(),\n-            value,\n-        }));\n+    pub fn set_aux<T: Send + Sync + 'static>(&self, arg: c_int, value: T) -> Result<Arc<T>> {\n+        let orig: Arc<T> = Arc::new(value);\n+        let inner: AuxInner = orig.clone();\n+        let outer = Box::new(inner);\n+        let raw: *mut AuxInner = Box::into_raw(outer);\n         unsafe {\n             ffi::sqlite3_set_auxdata(\n                 self.ctx,\n                 arg,\n-                boxed as *mut c_void,\n-                Some(free_boxed_value::<AuxData<T>>),\n+                raw as *mut _,\n+                Some(free_boxed_value::<AuxInner>),\n             )\n         };\n+        Ok(orig)\n     }\n \n-    /// Gets the auxilliary data that was associated with a given parameter\n-    /// via `set_aux`. Returns `Ok(None)` if no data has been associated,\n-    /// and .\n-    pub fn get_aux<T: 'static>(&self, arg: c_int) -> Result<Option<&T>> {\n-        let p = unsafe { ffi::sqlite3_get_auxdata(self.ctx, arg) as *const AuxData<T> };\n+    /// Gets the auxilliary data that was associated with a given parameter via\n+    /// `set_aux`. Returns `Ok(None)` if no data has been associated, and\n+    /// Ok(Some(v)) if it has. Returns an error if the requested type does not\n+    /// match.\n+    pub fn get_aux<T: Send + Sync + 'static>(&self, arg: c_int) -> Result<Option<Arc<T>>> {\n+        let p = unsafe { ffi::sqlite3_get_auxdata(self.ctx, arg) as *const AuxInner };\n         if p.is_null() {\n             Ok(None)\n         } else {\n-            let id = unsafe { (*p).id };\n-            if TypeId::of::<T>() != id {\n-                Err(Error::GetAuxWrongType)\n-            } else {\n-                Ok(Some(unsafe { &(*p).value }))\n-            }\n+            let v: AuxInner = AuxInner::clone(unsafe { &*p });\n+            v.downcast::<T>()\n+                .map(Some)\n+                .map_err(|_| Error::GetAuxWrongType)\n         }\n     }\n }\n \n-#[repr(C)]\n-struct AuxData<T: 'static> {\n-    id: TypeId,\n-    value: T,\n-}\n+type AuxInner = Arc<dyn Any + Send + Sync + 'static>;\n \n /// `feature = \"functions\"` Aggregate is the callback interface for user-defined\n /// aggregate function.\n@@ -776,34 +778,21 @@ mod test {\n     // expression multiple times within one query.\n     fn regexp_with_auxilliary(ctx: &Context<'_>) -> Result<bool> {\n         assert_eq!(ctx.len(), 2, \"called with unexpected number of arguments\");\n-\n-        let saved_re: Option<&Regex> = ctx.get_aux(0)?;\n-        let new_re = match saved_re {\n-            None => {\n-                let s = ctx.get::<String>(0)?;\n-                match Regex::new(&s) {\n-                    Ok(r) => Some(r),\n-                    Err(err) => return Err(Error::UserFunctionError(Box::new(err))),\n-                }\n-            }\n-            Some(_) => None,\n-        };\n+        type BoxError = Box<dyn std::error::Error + Send + Sync + 'static>;\n+        let regexp: std::sync::Arc<Regex> = ctx\n+            .get_or_create_aux(0, |vr| -> Result<_, BoxError> {\n+                Ok(Regex::new(vr.as_str()?)?)\n+            })?;\n \n         let is_match = {\n-            let re = saved_re.unwrap_or_else(|| new_re.as_ref().unwrap());\n-\n             let text = ctx\n                 .get_raw(1)\n                 .as_str()\n                 .map_err(|e| Error::UserFunctionError(e.into()))?;\n \n-            re.is_match(text)\n+            regexp.is_match(text)\n         };\n \n-        if let Some(re) = new_re {\n-            ctx.set_aux(0, re);\n-        }\n-\n         Ok(is_match)\n     }\n \n@@ -878,10 +867,10 @@ mod test {\n         let db = Connection::open_in_memory().unwrap();\n         db.create_scalar_function(\"example\", 2, FunctionFlags::default(), |ctx| {\n             if !ctx.get::<bool>(1)? {\n-                ctx.set_aux::<i64>(0, 100);\n+                ctx.set_aux::<i64>(0, 100)?;\n             } else {\n                 assert_eq!(ctx.get_aux::<String>(0), Err(Error::GetAuxWrongType));\n-                assert_eq!(ctx.get_aux::<i64>(0), Ok(Some(&100)));\n+                assert_eq!(*ctx.get_aux::<i64>(0).unwrap().unwrap(), 100);\n             }\n             Ok(true)\n         })\n",
    "diff_parsed": "{'added': [(57, 'use std::any::Any;'), (62, 'use std::sync::Arc;'), (166, '    pub fn get_or_create_aux<T, E, F>(&self, arg: c_int, func: F) -> Result<Arc<T>>'), (167, '    where'), (168, \"        T: Send + Sync + 'static,\"), (169, \"        E: Into<Box<dyn std::error::Error + Send + Sync + 'static>>,\"), (170, \"        F: FnOnce(ValueRef<'_>) -> Result<T, E>,\"), (171, '    {'), (172, '        if let Some(v) = self.get_aux(arg)? {'), (173, '            Ok(v)'), (174, '        } else {'), (175, '            let vr = self.get_raw(arg as usize);'), (176, '            self.set_aux('), (177, '                arg,'), (178, '                func(vr).map_err(|e| Error::UserFunctionError(e.into()))?,'), (179, '            )'), (180, '        }'), (181, '    }'), (186, \"    pub fn set_aux<T: Send + Sync + 'static>(&self, arg: c_int, value: T) -> Result<Arc<T>> {\"), (187, '        let orig: Arc<T> = Arc::new(value);'), (188, '        let inner: AuxInner = orig.clone();'), (189, '        let outer = Box::new(inner);'), (190, '        let raw: *mut AuxInner = Box::into_raw(outer);'), (195, '                raw as *mut _,'), (196, '                Some(free_boxed_value::<AuxInner>),'), (199, '        Ok(orig)'), (206, \"    pub fn get_aux<T: Send + Sync + 'static>(&self, arg: c_int) -> Result<Option<Arc<T>>> {\"), (207, '        let p = unsafe { ffi::sqlite3_get_auxdata(self.ctx, arg) as *const AuxInner };'), (211, '            let v: AuxInner = AuxInner::clone(unsafe { &*p });'), (212, '            v.downcast::<T>()'), (213, '                .map(Some)'), (214, '                .map_err(|_| Error::GetAuxWrongType)'), (219, \"type AuxInner = Arc<dyn Any + Send + Sync + 'static>;\"), (781, \"        type BoxError = Box<dyn std::error::Error + Send + Sync + 'static>;\"), (782, '        let regexp: std::sync::Arc<Regex> = ctx'), (783, '            .get_or_create_aux(0, |vr| -> Result<_, BoxError> {'), (784, '                Ok(Regex::new(vr.as_str()?)?)'), (785, '            })?;'), (793, '            regexp.is_match(text)'), (870, '                ctx.set_aux::<i64>(0, 100)?;'), (873, '                assert_eq!(*ctx.get_aux::<i64>(0).unwrap().unwrap(), 100);')], 'deleted': [(70, 'use std::any::TypeId;'), (180, \"    pub fn set_aux<T: 'static>(&self, arg: c_int, value: T) {\"), (181, '        let boxed = Box::into_raw(Box::new(AuxData {'), (182, '            id: TypeId::of::<T>(),'), (183, '            value,'), (184, '        }));'), (189, '                boxed as *mut c_void,'), (190, '                Some(free_boxed_value::<AuxData<T>>),'), (198, \"    pub fn get_aux<T: 'static>(&self, arg: c_int) -> Result<Option<&T>> {\"), (199, '        let p = unsafe { ffi::sqlite3_get_auxdata(self.ctx, arg) as *const AuxData<T> };'), (203, '            let id = unsafe { (*p).id };'), (204, '            if TypeId::of::<T>() != id {'), (205, '                Err(Error::GetAuxWrongType)'), (206, '            } else {'), (207, '                Ok(Some(unsafe { &(*p).value }))'), (208, '            }'), (213, '#[repr(C)]'), (214, \"struct AuxData<T: 'static> {\"), (215, '    id: TypeId,'), (216, '    value: T,'), (217, '}'), (780, '        let saved_re: Option<&Regex> = ctx.get_aux(0)?;'), (781, '        let new_re = match saved_re {'), (782, '            None => {'), (783, '                let s = ctx.get::<String>(0)?;'), (784, '                match Regex::new(&s) {'), (785, '                    Ok(r) => Some(r),'), (786, '                    Err(err) => return Err(Error::UserFunctionError(Box::new(err))),'), (787, '                }'), (788, '            }'), (789, '            Some(_) => None,'), (790, '        };'), (793, '            let re = saved_re.unwrap_or_else(|| new_re.as_ref().unwrap());'), (800, '            re.is_match(text)'), (803, '        if let Some(re) = new_re {'), (804, '            ctx.set_aux(0, re);'), (805, '        }'), (881, '                ctx.set_aux::<i64>(0, 100);'), (884, '                assert_eq!(ctx.get_aux::<i64>(0), Ok(Some(&100)));')]}",
    "num_lines_added": "41",
    "num_lines_deleted": "39",
    "nloc": "842"
  },
  {
    "file_change_id": "116375983580527",
    "hash": "b0d2bd20eb40b9cbc2958b981ba2dcd9e6f9396e",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -81,8 +81,10 @@ pub struct Singleton<T: 'static> {\n \n // The Singleton need to implement Send & Sync to ensure cross core compile check mechanics\n // this is safe as the inner RWLock ensures cross core safety\n-unsafe impl<T> Sync for Singleton<T> {}\n-unsafe impl<T> Send for Singleton<T> {}\n+// but we need to be conditional on the inner type to prevent interior mutable types beeing used\n+// inside a singleton\n+unsafe impl<T> Sync for Singleton<T> where T: Sync {}\n+unsafe impl<T> Send for Singleton<T> where T: Send {}\n \n impl<T: 'static> Singleton<T> {\n     /// Create a new [Singleton] instance to be used in a static variable. Only ``const fn`` constructors are allowed\n",
    "diff_parsed": "{'added': [(86, 'unsafe impl<T> Sync for Singleton<T> where T: Sync {}'), (87, 'unsafe impl<T> Send for Singleton<T> where T: Send {}')], 'deleted': [(84, 'unsafe impl<T> Sync for Singleton<T> {}'), (85, 'unsafe impl<T> Send for Singleton<T> {}')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "51"
  },
  {
    "file_change_id": "263761662823596",
    "hash": "71b2f5187b0cbace3f8b6ff53432ff2ca0defcf0",
    "old_path": "src/functions.rs",
    "new_path": "src/functions.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -67,6 +67,7 @@\n //!     Ok(())\n //! }\n //! ```\n+use std::any::TypeId;\n use std::os::raw::{c_int, c_void};\n use std::panic::{catch_unwind, RefUnwindSafe, UnwindSafe};\n use std::ptr;\n@@ -177,13 +178,16 @@ impl Context<'_> {\n     /// https://www.sqlite.org/c3ref/get_auxdata.html for a discussion of\n     /// this feature, or the unit tests of this module for an example.\n     pub fn set_aux<T: 'static>(&self, arg: c_int, value: T) {\n-        let boxed = Box::into_raw(Box::new((std::any::TypeId::of::<T>(), value)));\n+        let boxed = Box::into_raw(Box::new(AuxData {\n+            id: TypeId::of::<T>(),\n+            value,\n+        }));\n         unsafe {\n             ffi::sqlite3_set_auxdata(\n                 self.ctx,\n                 arg,\n                 boxed as *mut c_void,\n-                Some(free_boxed_value::<(std::any::TypeId, T)>),\n+                Some(free_boxed_value::<AuxData<T>>),\n             )\n         };\n     }\n@@ -192,20 +196,26 @@ impl Context<'_> {\n     /// via `set_aux`. Returns `Ok(None)` if no data has been associated,\n     /// and .\n     pub fn get_aux<T: 'static>(&self, arg: c_int) -> Result<Option<&T>> {\n-        let p = unsafe { ffi::sqlite3_get_auxdata(self.ctx, arg) as *mut (std::any::TypeId, T) };\n+        let p = unsafe { ffi::sqlite3_get_auxdata(self.ctx, arg) as *const AuxData<T> };\n         if p.is_null() {\n             Ok(None)\n         } else {\n-            let id_val = unsafe { &*p };\n-            if std::any::TypeId::of::<T>() != id_val.0 {\n+            let id = unsafe { (*p).id };\n+            if TypeId::of::<T>() != id {\n                 Err(Error::GetAuxWrongType)\n             } else {\n-                Ok(Some(&id_val.1))\n+                Ok(Some(unsafe { &(*p).value }))\n             }\n         }\n     }\n }\n \n+#[repr(C)]\n+struct AuxData<T: 'static> {\n+    id: TypeId,\n+    value: T,\n+}\n+\n /// `feature = \"functions\"` Aggregate is the callback interface for user-defined\n /// aggregate function.\n ///\n",
    "diff_parsed": "{'added': [(70, 'use std::any::TypeId;'), (181, '        let boxed = Box::into_raw(Box::new(AuxData {'), (182, '            id: TypeId::of::<T>(),'), (183, '            value,'), (184, '        }));'), (190, '                Some(free_boxed_value::<AuxData<T>>),'), (199, '        let p = unsafe { ffi::sqlite3_get_auxdata(self.ctx, arg) as *const AuxData<T> };'), (203, '            let id = unsafe { (*p).id };'), (204, '            if TypeId::of::<T>() != id {'), (207, '                Ok(Some(unsafe { &(*p).value }))'), (213, '#[repr(C)]'), (214, \"struct AuxData<T: 'static> {\"), (215, '    id: TypeId,'), (216, '    value: T,'), (217, '}')], 'deleted': [(180, '        let boxed = Box::into_raw(Box::new((std::any::TypeId::of::<T>(), value)));'), (186, '                Some(free_boxed_value::<(std::any::TypeId, T)>),'), (195, '        let p = unsafe { ffi::sqlite3_get_auxdata(self.ctx, arg) as *mut (std::any::TypeId, T) };'), (199, '            let id_val = unsafe { &*p };'), (200, '            if std::any::TypeId::of::<T>() != id_val.0 {'), (203, '                Ok(Some(&id_val.1))')]}",
    "num_lines_added": "15",
    "num_lines_deleted": "6",
    "nloc": "904"
  },
  {
    "file_change_id": "2727197405810",
    "hash": "5ba218ac29df4786b002d7d12b47fa0c04a331f2",
    "old_path": "nanorand/src/gen.rs",
    "new_path": "nanorand/src/gen.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -101,44 +101,44 @@ impl<R: RNG> RandomRange<R> for usize {\n \n impl<R: RNG> RandomGen<R> for u32 {\n \tfn random(r: &mut R) -> Self {\n-\t\t(r.generate::<u64>() >> 32) as u32\n+\t\tr.generate::<u64>() as u32\n \t}\n }\n \n impl<R: RNG> RandomRange<R> for u32 {\n \tfn random_range(r: &mut R, lower: u32, upper: u32) -> Self {\n-\t\t(r.generate_range::<u64>(lower as u64, upper as u64) >> 32) as u32\n+\t\tr.generate_range::<u64>(lower as u64, upper as u64) as u32\n \t}\n }\n \n impl<R: RNG> RandomGen<R> for u16 {\n \tfn random(r: &mut R) -> Self {\n-\t\t(r.generate::<u64>() >> 16) as u16\n+\t\tr.generate::<u64>() as u16\n \t}\n }\n \n impl<R: RNG> RandomRange<R> for u16 {\n \tfn random_range(r: &mut R, lower: u16, upper: u16) -> Self {\n-\t\t(r.generate_range::<u64>(lower as u64, upper as u64) >> 16) as u16\n+\t\tr.generate_range::<u64>(lower as u64, upper as u64) as u16\n \t}\n }\n \n impl<R: RNG> RandomGen<R> for u8 {\n \tfn random(r: &mut R) -> Self {\n-\t\t(r.generate::<u64>() >> 8) as u8\n+\t\tr.generate::<u64>() as u8\n \t}\n }\n \n impl<R: RNG> RandomRange<R> for u8 {\n \tfn random_range(r: &mut R, lower: u8, upper: u8) -> Self {\n-\t\t(r.generate_range::<u64>(lower as u64, upper as u64) >> 8) as u8\n+\t\tr.generate_range::<u64>(lower as u64, upper as u64) as u8\n \t}\n }\n \n impl<R: RNG> RandomRange<R> for char {\n \tfn random_range(r: &mut R, lower: char, upper: char) -> Self {\n \t\tloop {\n-\t\t\tlet ret = (r.generate_range::<u64>(lower as u64, upper as u64) >> 32) as u32;\n+\t\t\tlet ret = r.generate_range::<u64>(lower as u64, upper as u64) as u32;\n \t\t\tif let Some(c) = core::char::from_u32(ret) {\n \t\t\t\tbreak c;\n \t\t\t}\n",
    "diff_parsed": "{'added': [(104, '\\t\\tr.generate::<u64>() as u32'), (110, '\\t\\tr.generate_range::<u64>(lower as u64, upper as u64) as u32'), (116, '\\t\\tr.generate::<u64>() as u16'), (122, '\\t\\tr.generate_range::<u64>(lower as u64, upper as u64) as u16'), (128, '\\t\\tr.generate::<u64>() as u8'), (134, '\\t\\tr.generate_range::<u64>(lower as u64, upper as u64) as u8'), (141, '\\t\\t\\tlet ret = r.generate_range::<u64>(lower as u64, upper as u64) as u32;')], 'deleted': [(104, '\\t\\t(r.generate::<u64>() >> 32) as u32'), (110, '\\t\\t(r.generate_range::<u64>(lower as u64, upper as u64) >> 32) as u32'), (116, '\\t\\t(r.generate::<u64>() >> 16) as u16'), (122, '\\t\\t(r.generate_range::<u64>(lower as u64, upper as u64) >> 16) as u16'), (128, '\\t\\t(r.generate::<u64>() >> 8) as u8'), (134, '\\t\\t(r.generate_range::<u64>(lower as u64, upper as u64) >> 8) as u8'), (141, '\\t\\t\\tlet ret = (r.generate_range::<u64>(lower as u64, upper as u64) >> 32) as u32;')]}",
    "num_lines_added": "7",
    "num_lines_deleted": "7",
    "nloc": "127"
  },
  {
    "file_change_id": "208073945757665",
    "hash": "8f28ec275e412dd3af4f3cda460605512faf332c",
    "old_path": "src/subframe.rs",
    "new_path": "src/subframe.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -254,12 +254,25 @@ fn decode_residual<R: ReadBytes>(input: &mut Bitstream<R>,\n     // most 2^16 - 1 samples in the block. No values have been marked as\n     // invalid by the specification though.\n     let n_partitions = 1u32 << order;\n-    let n_samples = block_size >> order;\n+    let n_samples_per_partition = block_size >> order;\n+\n+    // The partitions together must fill the block. If the block size is not a\n+    // multiple of 2^order; if we shifted off some bits, then we would not fill\n+    // the entire block. Such a partition order is invalid for this block size.\n+    if block_size & (n_partitions - 1) as u16 != 0 {\n+        return fmt_err(\"invalid partition order\")\n+    }\n+\n+    // NOTE: the check above checks that block_size is a multiple of n_partitions\n+    // (this works because n_partitions is a power of 2). The check below is\n+    // equivalent but more expensive.\n+    debug_assert_eq!(n_partitions * n_samples_per_partition as u32, block_size as u32);\n+\n     let n_warm_up = block_size - buffer.len() as u16;\n \n     // The partition size must be at least as big as the number of warm-up\n     // samples, otherwise the size of the first partition is negative.\n-    if n_warm_up > n_samples {\n+    if n_warm_up > n_samples_per_partition {\n         return fmt_err(\"invalid residual\");\n     }\n \n@@ -267,22 +280,22 @@ fn decode_residual<R: ReadBytes>(input: &mut Bitstream<R>,\n     match partition_type {\n         RicePartitionType::Rice => {\n             let mut start = 0;\n-            let mut len = n_samples - n_warm_up;\n+            let mut len = n_samples_per_partition - n_warm_up;\n             for _ in 0..n_partitions {\n                 let slice = &mut buffer[start..start + len as usize];\n                 try!(decode_rice_partition(input, slice));\n                 start = start + len as usize;\n-                len = n_samples;\n+                len = n_samples_per_partition;\n             }\n         }\n         RicePartitionType::Rice2 => {\n             let mut start = 0;\n-            let mut len = n_samples - n_warm_up;\n+            let mut len = n_samples_per_partition - n_warm_up;\n             for _ in 0..n_partitions {\n                 let slice = &mut buffer[start..start + len as usize];\n                 try!(decode_rice2_partition(input, slice));\n                 start = start + len as usize;\n-                len = n_samples;\n+                len = n_samples_per_partition;\n             }\n         }\n     }\n",
    "diff_parsed": "{'added': [(257, '    let n_samples_per_partition = block_size >> order;'), (262, '    if block_size & (n_partitions - 1) as u16 != 0 {'), (263, '        return fmt_err(\"invalid partition order\")'), (264, '    }'), (269, '    debug_assert_eq!(n_partitions * n_samples_per_partition as u32, block_size as u32);'), (275, '    if n_warm_up > n_samples_per_partition {'), (283, '            let mut len = n_samples_per_partition - n_warm_up;'), (288, '                len = n_samples_per_partition;'), (293, '            let mut len = n_samples_per_partition - n_warm_up;'), (298, '                len = n_samples_per_partition;')], 'deleted': [(257, '    let n_samples = block_size >> order;'), (262, '    if n_warm_up > n_samples {'), (270, '            let mut len = n_samples - n_warm_up;'), (275, '                len = n_samples;'), (280, '            let mut len = n_samples - n_warm_up;'), (285, '                len = n_samples;')]}",
    "num_lines_added": "10",
    "num_lines_deleted": "6",
    "nloc": "373"
  },
  {
    "file_change_id": "207914854328258",
    "hash": "0b962f218f0cdd796dadfe26c3f09e68f7861b26",
    "old_path": "frame/ethereum/src/lib.rs",
    "new_path": "frame/ethereum/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -190,6 +190,27 @@ pub mod pallet {\n \n \t\tfn validate_unsigned(_source: TransactionSource, call: &Self::Call) -> TransactionValidity {\n \t\t\tif let Call::transact(transaction) = call {\n+\t\t\t\t// We must ensure a transaction can pay the cost of its data bytes.\n+\t\t\t\t// If it can't it should not be included in a block.\n+\t\t\t\tlet mut gasometer = evm::gasometer::Gasometer::new(\n+\t\t\t\t\ttransaction.gas_limit.low_u64(),\n+\t\t\t\t\t<T as pallet_evm::Config>::config(),\n+\t\t\t\t);\n+\t\t\t\tlet transaction_cost = match transaction.action {\n+\t\t\t\t\tTransactionAction::Call(_) => {\n+\t\t\t\t\t\tevm::gasometer::call_transaction_cost(&transaction.input)\n+\t\t\t\t\t}\n+\t\t\t\t\tTransactionAction::Create => {\n+\t\t\t\t\t\tevm::gasometer::create_transaction_cost(&transaction.input)\n+\t\t\t\t\t}\n+\t\t\t\t};\n+\t\t\t\tif gasometer.record_transaction(transaction_cost).is_err() {\n+\t\t\t\t\treturn InvalidTransaction::Custom(\n+\t\t\t\t\t\tTransactionValidationError::InvalidGasLimit as u8,\n+\t\t\t\t\t)\n+\t\t\t\t\t.into();\n+\t\t\t\t}\n+\n \t\t\t\tif let Some(chain_id) = transaction.signature.chain_id() {\n \t\t\t\t\tif chain_id != T::ChainId::get() {\n \t\t\t\t\t\treturn InvalidTransaction::Custom(\n",
    "diff_parsed": "{'added': [(195, '\\t\\t\\t\\tlet mut gasometer = evm::gasometer::Gasometer::new('), (196, '\\t\\t\\t\\t\\ttransaction.gas_limit.low_u64(),'), (197, '\\t\\t\\t\\t\\t<T as pallet_evm::Config>::config(),'), (198, '\\t\\t\\t\\t);'), (199, '\\t\\t\\t\\tlet transaction_cost = match transaction.action {'), (200, '\\t\\t\\t\\t\\tTransactionAction::Call(_) => {'), (201, '\\t\\t\\t\\t\\t\\tevm::gasometer::call_transaction_cost(&transaction.input)'), (202, '\\t\\t\\t\\t\\t}'), (203, '\\t\\t\\t\\t\\tTransactionAction::Create => {'), (204, '\\t\\t\\t\\t\\t\\tevm::gasometer::create_transaction_cost(&transaction.input)'), (205, '\\t\\t\\t\\t\\t}'), (206, '\\t\\t\\t\\t};'), (207, '\\t\\t\\t\\tif gasometer.record_transaction(transaction_cost).is_err() {'), (208, '\\t\\t\\t\\t\\treturn InvalidTransaction::Custom('), (209, '\\t\\t\\t\\t\\t\\tTransactionValidationError::InvalidGasLimit as u8,'), (210, '\\t\\t\\t\\t\\t)'), (211, '\\t\\t\\t\\t\\t.into();'), (212, '\\t\\t\\t\\t}')], 'deleted': []}",
    "num_lines_added": "18",
    "num_lines_deleted": "0",
    "nloc": "436"
  },
  {
    "file_change_id": "100555313756930",
    "hash": "2327d3b774927fdf48903c0bdc1ca7ec93c7c8d0",
    "old_path": "src/trace.rs",
    "new_path": "src/trace.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -61,7 +61,7 @@ pub unsafe fn config_log(callback: Option<fn(c_int, &str)>) -> Result<()> {\n pub fn log(err_code: c_int, msg: &str) {\n     let msg = CString::new(msg).expect(\"SQLite log messages cannot contain embedded zeroes\");\n     unsafe {\n-        ffi::sqlite3_log(err_code, msg.as_ptr());\n+        ffi::sqlite3_log(err_code, b\"%s\\0\" as *const _ as *const c_char, msg.as_ptr());\n     }\n }\n \n",
    "diff_parsed": "{'added': [(64, '        ffi::sqlite3_log(err_code, b\"%s\\\\0\" as *const _ as *const c_char, msg.as_ptr());')], 'deleted': [(64, '        ffi::sqlite3_log(err_code, msg.as_ptr());')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "135"
  },
  {
    "file_change_id": "130794596646955",
    "hash": "8f93123efef5c1361086688fe4f34c83c89cec02",
    "old_path": "src/proto/h1/role.rs",
    "new_path": "src/proto/h1/role.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -213,6 +213,8 @@ impl Http1Transaction for Server {\n                     if headers::is_chunked_(&value) {\n                         is_te_chunked = true;\n                         decoder = DecodedLength::CHUNKED;\n+                    } else {\n+                        is_te_chunked = false;\n                     }\n                 }\n                 header::CONTENT_LENGTH => {\n@@ -1444,6 +1446,16 @@ mod tests {\n             \"transfer-encoding doesn't end in chunked\",\n         );\n \n+        parse_err(\n+            \"\\\n+             POST / HTTP/1.1\\r\\n\\\n+             transfer-encoding: chunked\\r\\n\\\n+             transfer-encoding: afterlol\\r\\n\\\n+             \\r\\n\\\n+             \",\n+            \"transfer-encoding multiple lines doesn't end in chunked\",\n+        );\n+\n         // http/1.0\n \n         assert_eq!(\n",
    "diff_parsed": "{'added': [(216, '                    } else {'), (217, '                        is_te_chunked = false;'), (1449, '        parse_err('), (1450, '            \"\\\\'), (1451, '             POST / HTTP/1.1\\\\r\\\\n\\\\'), (1452, '             transfer-encoding: chunked\\\\r\\\\n\\\\'), (1453, '             transfer-encoding: afterlol\\\\r\\\\n\\\\'), (1454, '             \\\\r\\\\n\\\\'), (1455, '             \",'), (1456, '            \"transfer-encoding multiple lines doesn\\'t end in chunked\",'), (1457, '        );')], 'deleted': []}",
    "num_lines_added": "11",
    "num_lines_deleted": "0",
    "nloc": "1882"
  },
  {
    "file_change_id": "253409544191593",
    "hash": "d44011a69e0674acfa9c59bd7ad7f0523eb61d42",
    "old_path": "runtime/ops/fs.rs",
    "new_path": "runtime/ops/fs.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1370,7 +1370,8 @@ fn op_symlink_sync(\n   let oldpath = PathBuf::from(&args.oldpath);\n   let newpath = PathBuf::from(&args.newpath);\n \n-  state.borrow_mut::<Permissions>().write.check(&newpath)?;\n+  state.borrow_mut::<Permissions>().write.check_all()?;\n+  state.borrow_mut::<Permissions>().read.check_all()?;\n \n   debug!(\n     \"op_symlink_sync {} {}\",\n@@ -1432,7 +1433,8 @@ async fn op_symlink_async(\n \n   {\n     let mut state = state.borrow_mut();\n-    state.borrow_mut::<Permissions>().write.check(&newpath)?;\n+    state.borrow_mut::<Permissions>().write.check_all()?;\n+    state.borrow_mut::<Permissions>().read.check_all()?;\n   }\n \n   tokio::task::spawn_blocking(move || {\n",
    "diff_parsed": "{'added': [(1373, '  state.borrow_mut::<Permissions>().write.check_all()?;'), (1374, '  state.borrow_mut::<Permissions>().read.check_all()?;'), (1436, '    state.borrow_mut::<Permissions>().write.check_all()?;'), (1437, '    state.borrow_mut::<Permissions>().read.check_all()?;')], 'deleted': [(1373, '  state.borrow_mut::<Permissions>().write.check(&newpath)?;'), (1435, '    state.borrow_mut::<Permissions>().write.check(&newpath)?;')]}",
    "num_lines_added": "4",
    "num_lines_deleted": "2",
    "nloc": "1726"
  },
  {
    "file_change_id": "22224429939467",
    "hash": "45fd77ee43c38eea4d6f4e2e56c1667a55ec654f",
    "old_path": "src/unlock_notify.rs",
    "new_path": "src/unlock_notify.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -26,12 +26,13 @@ impl UnlockNotification {\n         }\n     }\n \n-    fn fired(&mut self) {\n-        *self.mutex.lock().unwrap() = true;\n+    fn fired(&self) {\n+        let mut flag = self.mutex.lock().unwrap();\n+        *flag = true;\n         self.cond.notify_one();\n     }\n \n-    fn wait(&mut self) {\n+    fn wait(&self) {\n         let mut fired = self.mutex.lock().unwrap();\n         while !*fired {\n             fired = self.cond.wait(fired).unwrap();\n@@ -43,12 +44,9 @@ impl UnlockNotification {\n #[cfg(feature = \"unlock_notify\")]\n unsafe extern \"C\" fn unlock_notify_cb(ap_arg: *mut *mut c_void, n_arg: c_int) {\n     use std::slice::from_raw_parts;\n-    let args = from_raw_parts(ap_arg, n_arg as usize);\n-    for arg in args {\n-        let _ = catch_unwind(|| {\n-            let un: &mut UnlockNotification = &mut *(*arg as *mut UnlockNotification);\n-            un.fired()\n-        });\n+    let args = from_raw_parts(ap_arg as *const &UnlockNotification, n_arg as usize);\n+    for un in args {\n+        let _ = catch_unwind(std::panic::AssertUnwindSafe(|| un.fired()));\n     }\n }\n \n@@ -73,12 +71,12 @@ pub unsafe fn is_locked(db: *mut ffi::sqlite3, rc: c_int) -> bool {\n /// back the current transaction (if any).\n #[cfg(feature = \"unlock_notify\")]\n pub unsafe fn wait_for_unlock_notify(db: *mut ffi::sqlite3) -> c_int {\n-    let mut un = UnlockNotification::new();\n+    let un = UnlockNotification::new();\n     /* Register for an unlock-notify callback. */\n     let rc = ffi::sqlite3_unlock_notify(\n         db,\n         Some(unlock_notify_cb),\n-        &mut un as *mut UnlockNotification as *mut c_void,\n+        &un as *const UnlockNotification as *mut c_void,\n     );\n     debug_assert!(\n         rc == ffi::SQLITE_LOCKED || rc == ffi::SQLITE_LOCKED_SHAREDCACHE || rc == ffi::SQLITE_OK\n",
    "diff_parsed": "{'added': [(29, '    fn fired(&self) {'), (30, '        let mut flag = self.mutex.lock().unwrap();'), (31, '        *flag = true;'), (35, '    fn wait(&self) {'), (47, '    let args = from_raw_parts(ap_arg as *const &UnlockNotification, n_arg as usize);'), (48, '    for un in args {'), (49, '        let _ = catch_unwind(std::panic::AssertUnwindSafe(|| un.fired()));'), (74, '    let un = UnlockNotification::new();'), (79, '        &un as *const UnlockNotification as *mut c_void,')], 'deleted': [(29, '    fn fired(&mut self) {'), (30, '        *self.mutex.lock().unwrap() = true;'), (34, '    fn wait(&mut self) {'), (46, '    let args = from_raw_parts(ap_arg, n_arg as usize);'), (47, '    for arg in args {'), (48, '        let _ = catch_unwind(|| {'), (49, '            let un: &mut UnlockNotification = &mut *(*arg as *mut UnlockNotification);'), (50, '            un.fired()'), (51, '        });'), (76, '    let mut un = UnlockNotification::new();'), (81, '        &mut un as *mut UnlockNotification as *mut c_void,')]}",
    "num_lines_added": "9",
    "num_lines_deleted": "11",
    "nloc": "101"
  },
  {
    "file_change_id": "253540755897670",
    "hash": "b4e6dc76f4845ab03104187a42ac6d1bbc1e0021",
    "old_path": "src/daemon.rs",
    "new_path": "src/daemon.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -85,6 +85,7 @@ async fn main() -> Result<(), Box<dyn std::error::Error>> {\n     }\n \n     let load_config = || {\n+        seteuid(env::var(\"PKEXEC_UID\").unwrap().parse::<u32>().unwrap()); // Dropping privileges to invoking user.\n         let config_file_path: std::path::PathBuf = if args.is_present(\"config\") {\n             Path::new(args.value_of(\"config\").unwrap()).to_path_buf()\n         } else {\n@@ -114,7 +115,7 @@ async fn main() -> Result<(), Box<dyn std::error::Error>> {\n     };\n \n     let mut hotkeys = load_config();\n-\n+    seteuid(0); // Escalating back to root after reading config file.\n     log::trace!(\"Attempting to find all keyboard file descriptors.\");\n     let keyboard_devices: Vec<Device> =\n         evdev::enumerate().filter(check_device_is_keyboard).collect();\n@@ -399,3 +400,14 @@ pub fn fetch_xdg_config_path() -> std::path::PathBuf {\n     };\n     config_file_path\n }\n+\n+pub fn seteuid(uid: u32) {\n+    let uid = nix::unistd::Uid::from_raw(uid);\n+    match nix::unistd::seteuid(uid) {\n+        Ok(_) => log::debug!(\"Dropping privileges...\"),\n+        Err(e) => {\n+            log::error!(\"Failed to set UID: {:#?}\", e);\n+            exit(1);\n+        }\n+    }\n+}\n",
    "diff_parsed": "{'added': [(88, '        seteuid(env::var(\"PKEXEC_UID\").unwrap().parse::<u32>().unwrap()); // Dropping privileges to invoking user.'), (118, '    seteuid(0); // Escalating back to root after reading config file.'), (404, 'pub fn seteuid(uid: u32) {'), (405, '    let uid = nix::unistd::Uid::from_raw(uid);'), (406, '    match nix::unistd::seteuid(uid) {'), (407, '        Ok(_) => log::debug!(\"Dropping privileges...\"),'), (408, '        Err(e) => {'), (409, '            log::error!(\"Failed to set UID: {:#?}\", e);'), (410, '            exit(1);'), (411, '        }'), (412, '    }'), (413, '}')], 'deleted': []}",
    "num_lines_added": "12",
    "num_lines_deleted": "0",
    "nloc": "356"
  },
  {
    "file_change_id": "176482830117422",
    "hash": "2a36405339c87b16ed6c76e91ad5b76638fbdb0c",
    "old_path": "src/install.rs",
    "new_path": "src/install.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -16,9 +16,11 @@ use anyhow::{bail, Context, Result};\n use lazy_static::lazy_static;\n use nix::mount;\n use regex::Regex;\n-use std::fs::{copy as fscopy, create_dir_all, read_dir, File, OpenOptions};\n+use std::fs::{\n+    copy as fscopy, create_dir_all, read_dir, set_permissions, File, OpenOptions, Permissions,\n+};\n use std::io::{copy, Read, Seek, SeekFrom, Write};\n-use std::os::unix::fs::FileTypeExt;\n+use std::os::unix::fs::{FileTypeExt, PermissionsExt};\n use std::path::{Path, PathBuf};\n \n use crate::blockdev::*;\n@@ -248,7 +250,21 @@ fn write_ignition(\n     // make parent directory\n     let mut config_dest = mountpoint.to_path_buf();\n     config_dest.push(\"ignition\");\n-    create_dir_all(&config_dest).context(\"creating Ignition config directory\")?;\n+    if !config_dest.is_dir() {\n+        create_dir_all(&config_dest).with_context(|| {\n+            format!(\n+                \"creating Ignition config directory {}\",\n+                config_dest.display()\n+            )\n+        })?;\n+        // Ignition data may contain secrets; restrict to root\n+        set_permissions(&config_dest, Permissions::from_mode(0o700)).with_context(|| {\n+            format!(\n+                \"setting file mode for Ignition directory {}\",\n+                config_dest.display()\n+            )\n+        })?;\n+    }\n \n     // do the copy\n     config_dest.push(\"config.ign\");\n@@ -262,6 +278,13 @@ fn write_ignition(\n                 config_dest.display()\n             )\n         })?;\n+    // Ignition config may contain secrets; restrict to root\n+    set_permissions(&config_dest, Permissions::from_mode(0o600)).with_context(|| {\n+        format!(\n+            \"setting file mode for destination Ignition config {}\",\n+            config_dest.display()\n+        )\n+    })?;\n     copy(&mut config_in, &mut config_out).context(\"writing Ignition config\")?;\n \n     Ok(())\n",
    "diff_parsed": "{'added': [(19, 'use std::fs::{'), (20, '    copy as fscopy, create_dir_all, read_dir, set_permissions, File, OpenOptions, Permissions,'), (21, '};'), (23, 'use std::os::unix::fs::{FileTypeExt, PermissionsExt};'), (253, '    if !config_dest.is_dir() {'), (254, '        create_dir_all(&config_dest).with_context(|| {'), (255, '            format!('), (256, '                \"creating Ignition config directory {}\",'), (257, '                config_dest.display()'), (258, '            )'), (259, '        })?;'), (261, '        set_permissions(&config_dest, Permissions::from_mode(0o700)).with_context(|| {'), (262, '            format!('), (263, '                \"setting file mode for Ignition directory {}\",'), (264, '                config_dest.display()'), (265, '            )'), (266, '        })?;'), (267, '    }'), (282, '    set_permissions(&config_dest, Permissions::from_mode(0o600)).with_context(|| {'), (283, '        format!('), (284, '            \"setting file mode for destination Ignition config {}\",'), (285, '            config_dest.display()'), (286, '        )'), (287, '    })?;')], 'deleted': [(19, 'use std::fs::{copy as fscopy, create_dir_all, read_dir, File, OpenOptions};'), (21, 'use std::os::unix::fs::FileTypeExt;'), (251, '    create_dir_all(&config_dest).context(\"creating Ignition config directory\")?;')]}",
    "num_lines_added": "24",
    "num_lines_deleted": "3",
    "nloc": "542"
  },
  {
    "file_change_id": "261395532360057",
    "hash": "e661a4940df78fbb7b52c622ac4ae6a3a7f7d8aa",
    "old_path": "src/daemon.rs",
    "new_path": "src/daemon.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -39,6 +39,7 @@ impl KeyboardState {\n #[tokio::main]\n async fn main() -> Result<(), Box<dyn std::error::Error>> {\n     let args = set_command_line_args().get_matches();\n+    let invoking_uid = env::var(\"PKEXEC_UID\").unwrap().parse::<u32>().unwrap();\n     env::set_var(\"RUST_LOG\", \"swhkd=warn\");\n \n     if args.is_present(\"debug\") {\n@@ -48,7 +49,7 @@ async fn main() -> Result<(), Box<dyn std::error::Error>> {\n     env_logger::init();\n     log::trace!(\"Logger initialized.\");\n \n-    let pidfile: String = String::from(\"/tmp/swhkd.pid\");\n+    let pidfile: String = String::from(format!(\"/etc/swhkd/runtime/swhkd_{}.pid\", invoking_uid));\n     if Path::new(&pidfile).exists() {\n         log::trace!(\"Reading {} file and checking for running instances.\", pidfile);\n         let swhkd_pid = match fs::read_to_string(&pidfile) {\n@@ -85,7 +86,7 @@ async fn main() -> Result<(), Box<dyn std::error::Error>> {\n     }\n \n     let load_config = || {\n-        seteuid(env::var(\"PKEXEC_UID\").unwrap().parse::<u32>().unwrap()); // Dropping privileges to invoking user.\n+        seteuid(invoking_uid); // Dropping privileges to invoking user.\n         let config_file_path: std::path::PathBuf = if args.is_present(\"config\") {\n             Path::new(args.value_of(\"config\").unwrap()).to_path_buf()\n         } else {\n",
    "diff_parsed": "{'added': [(42, '    let invoking_uid = env::var(\"PKEXEC_UID\").unwrap().parse::<u32>().unwrap();'), (52, '    let pidfile: String = String::from(format!(\"/etc/swhkd/runtime/swhkd_{}.pid\", invoking_uid));'), (89, '        seteuid(invoking_uid); // Dropping privileges to invoking user.')], 'deleted': [(51, '    let pidfile: String = String::from(\"/tmp/swhkd.pid\");'), (88, '        seteuid(env::var(\"PKEXEC_UID\").unwrap().parse::<u32>().unwrap()); // Dropping privileges to invoking user.')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "2",
    "nloc": "355"
  },
  {
    "file_change_id": "92745574425821",
    "hash": "da7904c04f82e1cb43cc42eaf6a1dba072b5c921",
    "old_path": "lib/extensions/serve_static.rs",
    "new_path": "lib/extensions/serve_static.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -320,7 +320,7 @@ impl ServeStatic {\n fn process_req(req: Request, cell: &RwLock<ServeStatic>) -> (Response, bool) {\n     let this = cell.read().unwrap();\n \n-    let mut path = format!(\"{}{}\", this.data_dir, req.path.replace(\"/..\", \"\"));\n+    let mut path = safe_path(req.path.to_owned());\n \n     // Add Index.html if path ends with /\n     if path.ends_with('/') {\n@@ -364,6 +364,14 @@ fn get_type(path: &str, types: &[(String, String)]) -> String {\n     \"application/octet-stream\".to_owned()\n }\n \n+#[inline]\n+fn safe_path(mut path: String) -> String {\n+    while path.contains(\"/..\") {\n+        path = path.replace(\"/..\", \"\");\n+    }\n+    path\n+}\n+\n /// Common MIME Types\n ///\n /// Used by Servestatic Extentions\n",
    "diff_parsed": "{'added': [(323, '    let mut path = safe_path(req.path.to_owned());'), (367, '#[inline]'), (368, 'fn safe_path(mut path: String) -> String {'), (369, '    while path.contains(\"/..\") {'), (370, '        path = path.replace(\"/..\", \"\");'), (371, '    }'), (372, '    path'), (373, '}')], 'deleted': [(323, '    let mut path = format!(\"{}{}\", this.data_dir, req.path.replace(\"/..\", \"\"));')]}",
    "num_lines_added": "8",
    "num_lines_deleted": "1",
    "nloc": "202"
  },
  {
    "file_change_id": "209554123423780",
    "hash": "0b620a09605afb815c6d8d8953bbb7a10a8c0575",
    "old_path": "src/server.rs",
    "new_path": "src/server.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -12,7 +12,7 @@ fn main() -> std::io::Result<()> {\n     env::set_var(\"RUST_LOG\", \"swhks=trace\");\n     env_logger::init();\n \n-    let pid_file_path = String::from(\"/tmp/swhks.pid\");\n+    let pid_file_path = String::from(format!(\"/run/user/{}/swhks.pid\", unistd::Uid::current()));\n     let sock_file_path = String::from(format!(\"/run/user/{}/swhkd.sock\", unistd::Uid::current()));\n \n     if Path::new(&pid_file_path).exists() {\n",
    "diff_parsed": "{'added': [(15, '    let pid_file_path = String::from(format!(\"/run/user/{}/swhks.pid\", unistd::Uid::current()));')], 'deleted': [(15, '    let pid_file_path = String::from(\"/tmp/swhks.pid\");')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "82"
  },
  {
    "file_change_id": "231473489100497",
    "hash": "8a93fdc6c9f4eb1d2f2a11b7ff1d12d70bf5a664",
    "old_path": "frame/evm/precompile/modexp/src/lib.rs",
    "new_path": "frame/evm/precompile/modexp/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -47,7 +47,10 @@ fn calculate_gas_cost(\n \t\t\twords += 1;\n \t\t}\n \n-\t\t// TODO: prevent/handle overflow\n+\t\t// Note: can't overflow because we take words to be some u64 value / 8, which is\n+\t\t// necessarily less than sqrt(u64::MAX).\n+\t\t// Additionally, both base_length and mod_length are bounded to 1024, so this has\n+\t\t// an upper bound of roughly (1024 / 8) squared\n \t\twords * words\n \t}\n \n@@ -63,8 +66,17 @@ fn calculate_gas_cost(\n \t\t\tlet bytes: [u8; 32] = [0xFF; 32];\n \t\t\tlet max_256_bit_uint = BigUint::from_bytes_be(&bytes);\n \n+\t\t\t// from the EIP spec:\n+\t\t\t// (8 * (exp_length - 32)) + ((exponent & (2**256 - 1)).bit_length() - 1)\n+\t\t\t//\n+\t\t\t// Notes:\n+\t\t\t// * exp_length is bounded to 1024 and is > 32\n+\t\t\t// * exponent can be zero, so we subtract 1 after adding the other terms (whose sum\n+\t\t\t//   must be > 0)\n+\t\t\t// * the addition can't overflow because the terms are both capped at roughly\n+\t\t\t//   8 * max size of exp_length (1024)\n \t\t\titeration_count =\n-\t\t\t\t(8 * (exp_length - 32)) + ((exponent.bitand(max_256_bit_uint)).bits() - 1);\n+\t\t\t\t(8 * (exp_length - 32)) + exponent.bitand(max_256_bit_uint).bits() - 1;\n \t\t}\n \n \t\tmax(iteration_count, 1)\n@@ -89,7 +101,7 @@ fn calculate_gas_cost(\n // 6) modulus, size as described above\n //\n //\n-// NOTE: input sizes are arbitrarily large (up to 256 bits), with the expectation\n+// NOTE: input sizes are bound to 1024 bytes, with the expectation\n //       that gas limits would be applied before actual computation.\n //\n //       maximum stack size will also prevent abuse.\n@@ -133,7 +145,7 @@ impl Precompile for Modexp {\n \t\tlet mod_len_big = BigUint::from_bytes_be(&buf);\n \t\tif mod_len_big > max_size_big {\n \t\t\treturn Err(PrecompileFailure::Error {\n-\t\t\t\texit_status: ExitError::Other(\"unreasonably large exponent length\".into()),\n+\t\t\t\texit_status: ExitError::Other(\"unreasonably large modulus length\".into()),\n \t\t\t});\n \t\t}\n \n@@ -162,7 +174,6 @@ impl Precompile for Modexp {\n \t\t\tlet exponent = BigUint::from_bytes_be(&input[exp_start..exp_start + exp_len]);\n \n \t\t\t// do our gas accounting\n-\t\t\t// TODO: we could technically avoid reading base first...\n \t\t\tlet gas_cost =\n \t\t\t\tcalculate_gas_cost(base_len as u64, exp_len as u64, mod_len as u64, &exponent);\n \t\t\tif let Some(gas_left) = target_gas {\n@@ -423,4 +434,39 @@ mod tests {\n \t\t\t}\n \t\t}\n \t}\n+\n+\t#[test]\n+\tfn test_zero_exp_with_33_length() {\n+\t\t// This is a regression test which ensures that the 'iteration_count' calculation\n+\t\t// in 'calculate_iteration_count' cannot underflow.\n+\t\t//\n+\t\t// In debug mode, this underflow could cause a panic. Otherwise, it causes N**0 to\n+\t\t// be calculated at more-than-normal expense.\n+\t\t//\n+\t\t// TODO: cite security advisory\n+\n+\t\tlet input = vec![\n+\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t\t0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t\t0, 0, 0, 0, 0, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,\n+\t\t];\n+\n+\t\tlet cost: u64 = 100000;\n+\n+\t\tlet context: Context = Context {\n+\t\t\taddress: Default::default(),\n+\t\t\tcaller: Default::default(),\n+\t\t\tapparent_value: From::from(0),\n+\t\t};\n+\n+\t\tlet precompile_result = Modexp::execute(&input, Some(cost), &context, false)\n+\t\t\t.expect(\"Modexp::execute() returned error\");\n+\n+\t\tassert_eq!(precompile_result.output.len(), 1); // should be same length as mod\n+\t\tlet result = BigUint::from_bytes_be(&precompile_result.output[..]);\n+\t\tlet expected = BigUint::parse_bytes(b\"0\", 10).unwrap();\n+\t\tassert_eq!(result, expected);\n+\t}\n }\n",
    "diff_parsed": "{'added': [(79, '\\t\\t\\t\\t(8 * (exp_length - 32)) + exponent.bitand(max_256_bit_uint).bits() - 1;'), (148, '\\t\\t\\t\\texit_status: ExitError::Other(\"unreasonably large modulus length\".into()),'), (438, '\\t#[test]'), (439, '\\tfn test_zero_exp_with_33_length() {'), (448, '\\t\\tlet input = vec!['), (449, '\\t\\t\\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,'), (450, '\\t\\t\\t0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,'), (451, '\\t\\t\\t0, 0, 0, 0, 0, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,'), (452, '\\t\\t\\t0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,'), (453, '\\t\\t\\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,'), (454, '\\t\\t];'), (456, '\\t\\tlet cost: u64 = 100000;'), (458, '\\t\\tlet context: Context = Context {'), (459, '\\t\\t\\taddress: Default::default(),'), (460, '\\t\\t\\tcaller: Default::default(),'), (461, '\\t\\t\\tapparent_value: From::from(0),'), (462, '\\t\\t};'), (464, '\\t\\tlet precompile_result = Modexp::execute(&input, Some(cost), &context, false)'), (465, '\\t\\t\\t.expect(\"Modexp::execute() returned error\");'), (467, '\\t\\tassert_eq!(precompile_result.output.len(), 1); // should be same length as mod'), (468, '\\t\\tlet result = BigUint::from_bytes_be(&precompile_result.output[..]);'), (469, '\\t\\tlet expected = BigUint::parse_bytes(b\"0\", 10).unwrap();'), (470, '\\t\\tassert_eq!(result, expected);'), (471, '\\t}')], 'deleted': [(67, '\\t\\t\\t\\t(8 * (exp_length - 32)) + ((exponent.bitand(max_256_bit_uint)).bits() - 1);'), (136, '\\t\\t\\t\\texit_status: ExitError::Other(\"unreasonably large exponent length\".into()),')]}",
    "num_lines_added": "24",
    "num_lines_deleted": "2",
    "nloc": "344"
  },
  {
    "file_change_id": "245772584568325",
    "hash": "369e55736f9bd29c37b1712afc2923f4028148c6",
    "old_path": "src/vector.rs",
    "new_path": "src/vector.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -49,9 +49,10 @@ pub trait Vector {\n     }\n \n     fn insert(&mut self, index: usize, element: Self::Item) {\n+        let len = self.len();\n+        assert!(index <= len);\n         self.reserve(1);\n         unsafe {\n-            let len = self.len();\n             let ptr = self.as_mut_ptr().uoffset(index);\n             copy(ptr, ptr.uoffset(1), len - index);\n             write(ptr, element);\n",
    "diff_parsed": "{'added': [(52, '        let len = self.len();'), (53, '        assert!(index <= len);')], 'deleted': [(54, '            let len = self.len();')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "1",
    "nloc": "165"
  },
  {
    "file_change_id": "121578795865963",
    "hash": "268301a714934dd067ba33f59f22c5f003aa20f3",
    "old_path": "src/cell.rs",
    "new_path": "src/cell.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -62,7 +62,7 @@ pub struct OnceCell<T, B> {\n /********** impl Send + Sync **********************************************************************/\n \n unsafe impl<T, B> Send for OnceCell<T, B> where T: Send {}\n-unsafe impl<T, B> Sync for OnceCell<T, B> where T: Sync {}\n+unsafe impl<T, B> Sync for OnceCell<T, B> where T: Send + Sync {}\n \n /********** impl inherent *************************************************************************/\n \n",
    "diff_parsed": "{'added': [(65, 'unsafe impl<T, B> Sync for OnceCell<T, B> where T: Send + Sync {}')], 'deleted': [(65, 'unsafe impl<T, B> Sync for OnceCell<T, B> where T: Sync {}')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "252"
  },
  {
    "file_change_id": "36243835198171",
    "hash": "e325e2fce4d9f9f392761e9fb58b418a48cef8bb",
    "old_path": "core/http/src/uri/formatter.rs",
    "new_path": "core/http/src/uri/formatter.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -334,26 +334,42 @@ impl Formatter<'_, Query> {\n     fn with_prefix<F>(&mut self, prefix: &str, f: F) -> fmt::Result\n         where F: FnOnce(&mut Self) -> fmt::Result\n     {\n-        // The `prefix` string is pushed in a `StackVec` for use by recursive\n-        // (nested) calls to `write_raw`. The string is pushed here and then\n-        // popped here. `self.prefixes` is modified nowhere else, and no strings\n-        // leak from the the vector. As a result, it is impossible for a\n-        // `prefix` to be accessed incorrectly as:\n-        //\n-        //   * Rust _guarantees_ it exists for the lifetime of this method\n-        //   * it is only reachable while this method's stack is active because\n-        //     it is popped before this method returns\n-        //   * thus, at any point that it's reachable, it's valid\n-        //\n-        // Said succinctly: this `prefixes` stack shadows a subset of the\n-        // `with_prefix` stack precisely, making it reachable to other code.\n-        let prefix: &'static str = unsafe { std::mem::transmute(prefix) };\n-\n-        self.prefixes.push(prefix);\n-        let result = f(self);\n-        self.prefixes.pop();\n \n-        result\n+        struct PrefixGuard<'f, 'i>(&'f mut Formatter<'i, Query>);\n+\n+        impl<'f, 'i> PrefixGuard<'f, 'i> {\n+            fn new(prefix: &str, f: &'f mut Formatter<'i, Query>) -> Self {\n+                // SAFETY: The `prefix` string is pushed in a `StackVec` for use\n+                // by recursive (nested) calls to `write_raw`. The string is\n+                // pushed in `PrefixGuard` here and then popped in `Drop`.\n+                // `prefixes` is modified nowhere else, and no concrete-lifetime\n+                // strings leak from the the vector. As a result, it is\n+                // impossible for a `prefix` to be accessed incorrectly as:\n+                //\n+                //   * Rust _guarantees_ `prefix` is valid for this method\n+                //   * `prefix` is only reachable while this method's stack is\n+                //     active because it is unconditionally popped before this\n+                //     method returns via `PrefixGuard::drop()`.\n+                //   * should a panic occur in `f()`, `PrefixGuard::drop()` is\n+                //     still called (or the program aborts), ensuring `prefix`\n+                //     is no longer in `prefixes` and thus inaccessible.\n+                //   * thus, at any point `prefix` is reachable, it is valid\n+                //\n+                // Said succinctly: `prefixes` shadows a subset of the\n+                // `with_prefix` stack, making it reachable to other code.\n+                let prefix = unsafe { std::mem::transmute(prefix) };\n+                f.prefixes.push(prefix);\n+                PrefixGuard(f)\n+            }\n+        }\n+\n+        impl Drop for PrefixGuard<'_, '_> {\n+            fn drop(&mut self) {\n+                self.0.prefixes.pop();\n+            }\n+        }\n+\n+        f(&mut PrefixGuard::new(prefix, self).0)\n     }\n \n     /// Writes the named value `value` by prefixing `name` followed by `=` to\n@@ -468,3 +484,54 @@ impl UriArguments<'_> {\n         Origin::new(path, query)\n     }\n }\n+\n+// See https://github.com/SergioBenitez/Rocket/issues/1534.\n+#[cfg(test)]\n+mod prefix_soundness_test {\n+    use crate::uri::{Formatter, Query, UriDisplay};\n+\n+    struct MyValue;\n+\n+    impl UriDisplay<Query> for MyValue {\n+        fn fmt(&self, _f: &mut Formatter<'_, Query>) -> std::fmt::Result {\n+            panic!()\n+        }\n+    }\n+\n+    struct MyDisplay;\n+\n+    impl UriDisplay<Query> for MyDisplay {\n+        fn fmt(&self, formatter: &mut Formatter<'_, Query>) -> std::fmt::Result {\n+            struct Wrapper<'a, 'b>(&'a mut Formatter<'b, Query>);\n+\n+            impl<'a, 'b> Drop for Wrapper<'a, 'b> {\n+                fn drop(&mut self) {\n+                    let _overlap = String::from(\"12345\");\n+                    self.0.write_raw(\"world\").ok();\n+                    assert!(self.0.prefixes.is_empty());\n+                }\n+            }\n+\n+            let wrapper = Wrapper(formatter);\n+            let temporary_string = String::from(\"hello\");\n+\n+            // `write_named_value` will push `temp_string` into a buffer and\n+            // call the formatter for `MyValue`, which panics. At the panic\n+            // point, `formatter` contains an (illegal) static reference to\n+            // `temp_string` in its `prefixes` stack. When unwinding occurs,\n+            // `Wrapper` will be dropped. `Wrapper` holds a reference to\n+            // `Formatter`, thus `Formatter` must be consistent at this point.\n+            let _ = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {\n+                wrapper.0.write_named_value(&temporary_string, MyValue)\n+            }));\n+\n+            Ok(())\n+        }\n+    }\n+\n+    #[test]\n+    fn check_consistency() {\n+        let string = format!(\"{}\", &MyDisplay as &dyn UriDisplay<Query>);\n+        assert_eq!(string, \"world\");\n+    }\n+}\n",
    "diff_parsed": "{'added': [(338, \"        struct PrefixGuard<'f, 'i>(&'f mut Formatter<'i, Query>);\"), (340, \"        impl<'f, 'i> PrefixGuard<'f, 'i> {\"), (341, \"            fn new(prefix: &str, f: &'f mut Formatter<'i, Query>) -> Self {\"), (360, '                let prefix = unsafe { std::mem::transmute(prefix) };'), (361, '                f.prefixes.push(prefix);'), (362, '                PrefixGuard(f)'), (363, '            }'), (364, '        }'), (366, \"        impl Drop for PrefixGuard<'_, '_> {\"), (367, '            fn drop(&mut self) {'), (368, '                self.0.prefixes.pop();'), (369, '            }'), (370, '        }'), (372, '        f(&mut PrefixGuard::new(prefix, self).0)'), (489, '#[cfg(test)]'), (490, 'mod prefix_soundness_test {'), (491, '    use crate::uri::{Formatter, Query, UriDisplay};'), (493, '    struct MyValue;'), (495, '    impl UriDisplay<Query> for MyValue {'), (496, \"        fn fmt(&self, _f: &mut Formatter<'_, Query>) -> std::fmt::Result {\"), (497, '            panic!()'), (498, '        }'), (499, '    }'), (501, '    struct MyDisplay;'), (503, '    impl UriDisplay<Query> for MyDisplay {'), (504, \"        fn fmt(&self, formatter: &mut Formatter<'_, Query>) -> std::fmt::Result {\"), (505, \"            struct Wrapper<'a, 'b>(&'a mut Formatter<'b, Query>);\"), (507, \"            impl<'a, 'b> Drop for Wrapper<'a, 'b> {\"), (508, '                fn drop(&mut self) {'), (509, '                    let _overlap = String::from(\"12345\");'), (510, '                    self.0.write_raw(\"world\").ok();'), (511, '                    assert!(self.0.prefixes.is_empty());'), (512, '                }'), (513, '            }'), (515, '            let wrapper = Wrapper(formatter);'), (516, '            let temporary_string = String::from(\"hello\");'), (524, '            let _ = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {'), (525, '                wrapper.0.write_named_value(&temporary_string, MyValue)'), (526, '            }));'), (528, '            Ok(())'), (529, '        }'), (530, '    }'), (532, '    #[test]'), (533, '    fn check_consistency() {'), (534, '        let string = format!(\"{}\", &MyDisplay as &dyn UriDisplay<Query>);'), (535, '        assert_eq!(string, \"world\");'), (536, '    }'), (537, '}')], 'deleted': [(350, \"        let prefix: &'static str = unsafe { std::mem::transmute(prefix) };\"), (352, '        self.prefixes.push(prefix);'), (353, '        let result = f(self);'), (354, '        self.prefixes.pop();'), (356, '        result')]}",
    "num_lines_added": "48",
    "num_lines_deleted": "5",
    "nloc": "201"
  },
  {
    "file_change_id": "44148363712851",
    "hash": "8783a08e71694b7a5eb4fbc7cd95379b6de0d290",
    "old_path": "src/sync/mutex.rs",
    "new_path": "src/sync/mutex.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -310,6 +310,13 @@ impl<MutexType: RawMutex, T> DerefMut for GenericMutexGuard<'_, MutexType, T> {\n     }\n }\n \n+// Safety: GenericMutexGuard may only be used across threads if the underlying\n+// type is Sync.\n+unsafe impl<MutexType: RawMutex, T: Sync> Sync\n+    for GenericMutexGuard<'_, MutexType, T>\n+{\n+}\n+\n /// A future which resolves when the target mutex has been successfully acquired.\n #[must_use = \"futures do nothing unless polled\"]\n pub struct GenericMutexLockFuture<'a, MutexType: RawMutex, T: 'a> {\n",
    "diff_parsed": "{'added': [(315, 'unsafe impl<MutexType: RawMutex, T: Sync> Sync'), (316, \"    for GenericMutexGuard<'_, MutexType, T>\"), (317, '{'), (318, '}')], 'deleted': []}",
    "num_lines_added": "4",
    "num_lines_deleted": "0",
    "nloc": "353"
  },
  {
    "file_change_id": "190106604866826",
    "hash": "59f2a7311dd6540696bfd0145f5281ce495f4385",
    "old_path": "prost-types/src/lib.rs",
    "new_path": "prost-types/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -26,6 +26,7 @@ pub mod compiler {\n // are defined in both directions.\n \n const NANOS_PER_SECOND: i32 = 1_000_000_000;\n+const NANOS_MAX: i32 = NANOS_PER_SECOND - 1;\n \n impl Duration {\n     /// Normalizes the duration to a canonical format.\n@@ -35,17 +36,42 @@ impl Duration {\n     pub fn normalize(&mut self) {\n         // Make sure nanos is in the range.\n         if self.nanos <= -NANOS_PER_SECOND || self.nanos >= NANOS_PER_SECOND {\n-            self.seconds += (self.nanos / NANOS_PER_SECOND) as i64;\n-            self.nanos %= NANOS_PER_SECOND;\n+            if let Some(seconds) = self\n+                .seconds\n+                .checked_add((self.nanos / NANOS_PER_SECOND) as i64)\n+            {\n+                self.seconds = seconds;\n+                self.nanos %= NANOS_PER_SECOND;\n+            } else if self.nanos < 0 {\n+                // Negative overflow! Set to the least normal value.\n+                self.seconds = i64::MIN;\n+                self.nanos = -NANOS_MAX;\n+            } else {\n+                // Positive overflow! Set to the greatest normal value.\n+                self.seconds = i64::MAX;\n+                self.nanos = NANOS_MAX;\n+            }\n         }\n \n         // nanos should have the same sign as seconds.\n         if self.seconds < 0 && self.nanos > 0 {\n-            self.seconds += 1;\n-            self.nanos -= NANOS_PER_SECOND;\n+            if let Some(seconds) = self.seconds.checked_add(1) {\n+                self.seconds = seconds;\n+                self.nanos -= NANOS_PER_SECOND;\n+            } else {\n+                // Positive overflow! Set to the greatest normal value.\n+                debug_assert_eq!(self.seconds, i64::MAX);\n+                self.nanos = NANOS_MAX;\n+            }\n         } else if self.seconds > 0 && self.nanos < 0 {\n-            self.seconds -= 1;\n-            self.nanos += NANOS_PER_SECOND;\n+            if let Some(seconds) = self.seconds.checked_sub(1) {\n+                self.seconds = seconds;\n+                self.nanos += NANOS_PER_SECOND;\n+            } else {\n+                // Negative overflow! Set to the least normal value.\n+                debug_assert_eq!(self.seconds, i64::MIN);\n+                self.nanos = -NANOS_MAX;\n+            }\n         }\n         // TODO: should this be checked?\n         // debug_assert!(self.seconds >= -315_576_000_000 && self.seconds <= 315_576_000_000,\n@@ -104,14 +130,33 @@ impl Timestamp {\n     pub fn normalize(&mut self) {\n         // Make sure nanos is in the range.\n         if self.nanos <= -NANOS_PER_SECOND || self.nanos >= NANOS_PER_SECOND {\n-            self.seconds += (self.nanos / NANOS_PER_SECOND) as i64;\n-            self.nanos %= NANOS_PER_SECOND;\n+            if let Some(seconds) = self\n+                .seconds\n+                .checked_add((self.nanos / NANOS_PER_SECOND) as i64)\n+            {\n+                self.seconds = seconds;\n+                self.nanos %= NANOS_PER_SECOND;\n+            } else if self.nanos < 0 {\n+                // Negative overflow! Set to the earliest normal value.\n+                self.seconds = i64::MIN;\n+                self.nanos = 0;\n+            } else {\n+                // Positive overflow! Set to the latest normal value.\n+                self.seconds = i64::MAX;\n+                self.nanos = 999_999_999;\n+            }\n         }\n \n         // For Timestamp nanos should be in the range [0, 999999999].\n         if self.nanos < 0 {\n-            self.seconds -= 1;\n-            self.nanos += NANOS_PER_SECOND;\n+            if let Some(seconds) = self.seconds.checked_sub(1) {\n+                self.seconds = seconds;\n+                self.nanos += NANOS_PER_SECOND;\n+            } else {\n+                // Negative overflow! Set to the earliest normal value.\n+                debug_assert_eq!(self.seconds, i64::MIN);\n+                self.nanos = 0;\n+            }\n         }\n \n         // TODO: should this be checked?\n@@ -143,17 +188,56 @@ impl From<std::time::SystemTime> for Timestamp {\n     }\n }\n \n+/// Indicates that a [`Timestamp`] could not be converted to\n+/// [`SystemTime`][std::time::SystemTime] because it is out of range.\n+///\n+/// The range of times that can be represented by `SystemTime` depends on the platform.\n+/// All `Timestamp`s are likely representable on 64-bit Unix-like platforms, but\n+/// other platforms, such as Windows and 32-bit Linux, may not be able to represent\n+/// the full range of `Timestamp`s.\n+#[cfg(feature = \"std\")]\n+#[derive(Debug)]\n+#[non_exhaustive]\n+pub struct TimestampOutOfSystemRangeError {\n+    pub timestamp: Timestamp,\n+}\n+\n+#[cfg(feature = \"std\")]\n+impl core::fmt::Display for TimestampOutOfSystemRangeError {\n+    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n+        write!(\n+            f,\n+            \"{:?} is not representable as a `SystemTime` because it is out of range\",\n+            self\n+        )\n+    }\n+}\n+\n+#[cfg(feature = \"std\")]\n+impl std::error::Error for TimestampOutOfSystemRangeError {}\n+\n #[cfg(feature = \"std\")]\n-impl From<Timestamp> for std::time::SystemTime {\n-    fn from(mut timestamp: Timestamp) -> std::time::SystemTime {\n+impl TryFrom<Timestamp> for std::time::SystemTime {\n+    type Error = TimestampOutOfSystemRangeError;\n+\n+    fn try_from(mut timestamp: Timestamp) -> Result<std::time::SystemTime, Self::Error> {\n+        let orig_timestamp = timestamp.clone();\n         timestamp.normalize();\n+\n         let system_time = if timestamp.seconds >= 0 {\n-            std::time::UNIX_EPOCH + time::Duration::from_secs(timestamp.seconds as u64)\n+            std::time::UNIX_EPOCH.checked_add(time::Duration::from_secs(timestamp.seconds as u64))\n         } else {\n-            std::time::UNIX_EPOCH - time::Duration::from_secs((-timestamp.seconds) as u64)\n+            std::time::UNIX_EPOCH\n+                .checked_sub(time::Duration::from_secs((-timestamp.seconds) as u64))\n         };\n \n-        system_time + time::Duration::from_nanos(timestamp.nanos as u64)\n+        let system_time = system_time.and_then(|system_time| {\n+            system_time.checked_add(time::Duration::from_nanos(timestamp.nanos as u64))\n+        });\n+\n+        system_time.ok_or(TimestampOutOfSystemRangeError {\n+            timestamp: orig_timestamp,\n+        })\n     }\n }\n \n@@ -171,7 +255,19 @@ mod tests {\n         fn check_system_time_roundtrip(\n             system_time in SystemTime::arbitrary(),\n         ) {\n-            prop_assert_eq!(SystemTime::from(Timestamp::from(system_time)), system_time);\n+            prop_assert_eq!(SystemTime::try_from(Timestamp::from(system_time)).unwrap(), system_time);\n+        }\n+\n+        #[test]\n+        fn check_timestamp_roundtrip_via_system_time(\n+            seconds in i64::arbitrary(),\n+            nanos in i32::arbitrary(),\n+        ) {\n+            let mut timestamp = Timestamp { seconds, nanos };\n+            timestamp.normalize();\n+            if let Ok(system_time) = SystemTime::try_from(timestamp.clone()) {\n+                prop_assert_eq!(Timestamp::from(system_time), timestamp);\n+            }\n         }\n     }\n \n@@ -243,4 +339,156 @@ mod tests {\n             }\n         );\n     }\n+\n+    #[test]\n+    fn check_duration_normalize() {\n+        #[rustfmt::skip] // Don't mangle the table formatting.\n+        let cases = [\n+            // --- Table of test cases ---\n+            //        test seconds      test nanos  expected seconds  expected nanos\n+            (line!(),            0,              0,                0,              0),\n+            (line!(),            1,              1,                1,              1),\n+            (line!(),           -1,             -1,               -1,             -1),\n+            (line!(),            0,    999_999_999,                0,    999_999_999),\n+            (line!(),            0,   -999_999_999,                0,   -999_999_999),\n+            (line!(),            0,  1_000_000_000,                1,              0),\n+            (line!(),            0, -1_000_000_000,               -1,              0),\n+            (line!(),            0,  1_000_000_001,                1,              1),\n+            (line!(),            0, -1_000_000_001,               -1,             -1),\n+            (line!(),           -1,              1,                0,   -999_999_999),\n+            (line!(),            1,             -1,                0,    999_999_999),\n+            (line!(),           -1,  1_000_000_000,                0,              0),\n+            (line!(),            1, -1_000_000_000,                0,              0),\n+            (line!(), i64::MIN    ,              0,     i64::MIN    ,              0),\n+            (line!(), i64::MIN + 1,              0,     i64::MIN + 1,              0),\n+            (line!(), i64::MIN    ,              1,     i64::MIN + 1,   -999_999_999),\n+            (line!(), i64::MIN    ,  1_000_000_000,     i64::MIN + 1,              0),\n+            (line!(), i64::MIN    , -1_000_000_000,     i64::MIN    ,   -999_999_999),\n+            (line!(), i64::MIN + 1, -1_000_000_000,     i64::MIN    ,              0),\n+            (line!(), i64::MIN + 2, -1_000_000_000,     i64::MIN + 1,              0),\n+            (line!(), i64::MIN    , -1_999_999_998,     i64::MIN    ,   -999_999_999),\n+            (line!(), i64::MIN + 1, -1_999_999_998,     i64::MIN    ,   -999_999_998),\n+            (line!(), i64::MIN + 2, -1_999_999_998,     i64::MIN + 1,   -999_999_998),\n+            (line!(), i64::MIN    , -1_999_999_999,     i64::MIN    ,   -999_999_999),\n+            (line!(), i64::MIN + 1, -1_999_999_999,     i64::MIN    ,   -999_999_999),\n+            (line!(), i64::MIN + 2, -1_999_999_999,     i64::MIN + 1,   -999_999_999),\n+            (line!(), i64::MIN    , -2_000_000_000,     i64::MIN    ,   -999_999_999),\n+            (line!(), i64::MIN + 1, -2_000_000_000,     i64::MIN    ,   -999_999_999),\n+            (line!(), i64::MIN + 2, -2_000_000_000,     i64::MIN    ,              0),\n+            (line!(), i64::MIN    ,   -999_999_998,     i64::MIN    ,   -999_999_998),\n+            (line!(), i64::MIN + 1,   -999_999_998,     i64::MIN + 1,   -999_999_998),\n+            (line!(), i64::MAX    ,              0,     i64::MAX    ,              0),\n+            (line!(), i64::MAX - 1,              0,     i64::MAX - 1,              0),\n+            (line!(), i64::MAX    ,             -1,     i64::MAX - 1,    999_999_999),\n+            (line!(), i64::MAX    ,  1_000_000_000,     i64::MAX    ,    999_999_999),\n+            (line!(), i64::MAX - 1,  1_000_000_000,     i64::MAX    ,              0),\n+            (line!(), i64::MAX - 2,  1_000_000_000,     i64::MAX - 1,              0),\n+            (line!(), i64::MAX    ,  1_999_999_998,     i64::MAX    ,    999_999_999),\n+            (line!(), i64::MAX - 1,  1_999_999_998,     i64::MAX    ,    999_999_998),\n+            (line!(), i64::MAX - 2,  1_999_999_998,     i64::MAX - 1,    999_999_998),\n+            (line!(), i64::MAX    ,  1_999_999_999,     i64::MAX    ,    999_999_999),\n+            (line!(), i64::MAX - 1,  1_999_999_999,     i64::MAX    ,    999_999_999),\n+            (line!(), i64::MAX - 2,  1_999_999_999,     i64::MAX - 1,    999_999_999),\n+            (line!(), i64::MAX    ,  2_000_000_000,     i64::MAX    ,    999_999_999),\n+            (line!(), i64::MAX - 1,  2_000_000_000,     i64::MAX    ,    999_999_999),\n+            (line!(), i64::MAX - 2,  2_000_000_000,     i64::MAX    ,              0),\n+            (line!(), i64::MAX    ,    999_999_998,     i64::MAX    ,    999_999_998),\n+            (line!(), i64::MAX - 1,    999_999_998,     i64::MAX - 1,    999_999_998),\n+        ];\n+\n+        for case in cases.iter() {\n+            let mut test_duration = crate::Duration {\n+                seconds: case.1,\n+                nanos: case.2,\n+            };\n+            test_duration.normalize();\n+\n+            assert_eq!(\n+                test_duration,\n+                crate::Duration {\n+                    seconds: case.3,\n+                    nanos: case.4,\n+                },\n+                \"test case on line {} doesn't match\",\n+                case.0,\n+            );\n+        }\n+    }\n+\n+    #[cfg(feature = \"std\")]\n+    #[test]\n+    fn check_timestamp_normalize() {\n+        // Make sure that `Timestamp::normalize` behaves correctly on and near overflow.\n+        #[rustfmt::skip] // Don't mangle the table formatting.\n+        let cases = [\n+            // --- Table of test cases ---\n+            //        test seconds      test nanos  expected seconds  expected nanos\n+            (line!(),            0,              0,                0,              0),\n+            (line!(),            1,              1,                1,              1),\n+            (line!(),           -1,             -1,               -2,    999_999_999),\n+            (line!(),            0,    999_999_999,                0,    999_999_999),\n+            (line!(),            0,   -999_999_999,               -1,              1),\n+            (line!(),            0,  1_000_000_000,                1,              0),\n+            (line!(),            0, -1_000_000_000,               -1,              0),\n+            (line!(),            0,  1_000_000_001,                1,              1),\n+            (line!(),            0, -1_000_000_001,               -2,    999_999_999),\n+            (line!(),           -1,              1,               -1,              1),\n+            (line!(),            1,             -1,                0,    999_999_999),\n+            (line!(),           -1,  1_000_000_000,                0,              0),\n+            (line!(),            1, -1_000_000_000,                0,              0),\n+            (line!(), i64::MIN    ,              0,     i64::MIN    ,              0),\n+            (line!(), i64::MIN + 1,              0,     i64::MIN + 1,              0),\n+            (line!(), i64::MIN    ,              1,     i64::MIN    ,              1),\n+            (line!(), i64::MIN    ,  1_000_000_000,     i64::MIN + 1,              0),\n+            (line!(), i64::MIN    , -1_000_000_000,     i64::MIN    ,              0),\n+            (line!(), i64::MIN + 1, -1_000_000_000,     i64::MIN    ,              0),\n+            (line!(), i64::MIN + 2, -1_000_000_000,     i64::MIN + 1,              0),\n+            (line!(), i64::MIN    , -1_999_999_998,     i64::MIN    ,              0),\n+            (line!(), i64::MIN + 1, -1_999_999_998,     i64::MIN    ,              0),\n+            (line!(), i64::MIN + 2, -1_999_999_998,     i64::MIN    ,              2),\n+            (line!(), i64::MIN    , -1_999_999_999,     i64::MIN    ,              0),\n+            (line!(), i64::MIN + 1, -1_999_999_999,     i64::MIN    ,              0),\n+            (line!(), i64::MIN + 2, -1_999_999_999,     i64::MIN    ,              1),\n+            (line!(), i64::MIN    , -2_000_000_000,     i64::MIN    ,              0),\n+            (line!(), i64::MIN + 1, -2_000_000_000,     i64::MIN    ,              0),\n+            (line!(), i64::MIN + 2, -2_000_000_000,     i64::MIN    ,              0),\n+            (line!(), i64::MIN    ,   -999_999_998,     i64::MIN    ,              0),\n+            (line!(), i64::MIN + 1,   -999_999_998,     i64::MIN    ,              2),\n+            (line!(), i64::MAX    ,              0,     i64::MAX    ,              0),\n+            (line!(), i64::MAX - 1,              0,     i64::MAX - 1,              0),\n+            (line!(), i64::MAX    ,             -1,     i64::MAX - 1,    999_999_999),\n+            (line!(), i64::MAX    ,  1_000_000_000,     i64::MAX    ,    999_999_999),\n+            (line!(), i64::MAX - 1,  1_000_000_000,     i64::MAX    ,              0),\n+            (line!(), i64::MAX - 2,  1_000_000_000,     i64::MAX - 1,              0),\n+            (line!(), i64::MAX    ,  1_999_999_998,     i64::MAX    ,    999_999_999),\n+            (line!(), i64::MAX - 1,  1_999_999_998,     i64::MAX    ,    999_999_998),\n+            (line!(), i64::MAX - 2,  1_999_999_998,     i64::MAX - 1,    999_999_998),\n+            (line!(), i64::MAX    ,  1_999_999_999,     i64::MAX    ,    999_999_999),\n+            (line!(), i64::MAX - 1,  1_999_999_999,     i64::MAX    ,    999_999_999),\n+            (line!(), i64::MAX - 2,  1_999_999_999,     i64::MAX - 1,    999_999_999),\n+            (line!(), i64::MAX    ,  2_000_000_000,     i64::MAX    ,    999_999_999),\n+            (line!(), i64::MAX - 1,  2_000_000_000,     i64::MAX    ,    999_999_999),\n+            (line!(), i64::MAX - 2,  2_000_000_000,     i64::MAX    ,              0),\n+            (line!(), i64::MAX    ,    999_999_998,     i64::MAX    ,    999_999_998),\n+            (line!(), i64::MAX - 1,    999_999_998,     i64::MAX - 1,    999_999_998),\n+        ];\n+\n+        for case in cases.iter() {\n+            let mut test_timestamp = crate::Timestamp {\n+                seconds: case.1,\n+                nanos: case.2,\n+            };\n+            test_timestamp.normalize();\n+\n+            assert_eq!(\n+                test_timestamp,\n+                crate::Timestamp {\n+                    seconds: case.3,\n+                    nanos: case.4,\n+                },\n+                \"test case on line {} doesn't match\",\n+                case.0,\n+            );\n+        }\n+    }\n }\n",
    "diff_parsed": "{'added': [(29, 'const NANOS_MAX: i32 = NANOS_PER_SECOND - 1;'), (39, '            if let Some(seconds) = self'), (40, '                .seconds'), (41, '                .checked_add((self.nanos / NANOS_PER_SECOND) as i64)'), (42, '            {'), (43, '                self.seconds = seconds;'), (44, '                self.nanos %= NANOS_PER_SECOND;'), (45, '            } else if self.nanos < 0 {'), (47, '                self.seconds = i64::MIN;'), (48, '                self.nanos = -NANOS_MAX;'), (49, '            } else {'), (51, '                self.seconds = i64::MAX;'), (52, '                self.nanos = NANOS_MAX;'), (53, '            }'), (58, '            if let Some(seconds) = self.seconds.checked_add(1) {'), (59, '                self.seconds = seconds;'), (60, '                self.nanos -= NANOS_PER_SECOND;'), (61, '            } else {'), (63, '                debug_assert_eq!(self.seconds, i64::MAX);'), (64, '                self.nanos = NANOS_MAX;'), (65, '            }'), (67, '            if let Some(seconds) = self.seconds.checked_sub(1) {'), (68, '                self.seconds = seconds;'), (69, '                self.nanos += NANOS_PER_SECOND;'), (70, '            } else {'), (72, '                debug_assert_eq!(self.seconds, i64::MIN);'), (73, '                self.nanos = -NANOS_MAX;'), (74, '            }'), (133, '            if let Some(seconds) = self'), (134, '                .seconds'), (135, '                .checked_add((self.nanos / NANOS_PER_SECOND) as i64)'), (136, '            {'), (137, '                self.seconds = seconds;'), (138, '                self.nanos %= NANOS_PER_SECOND;'), (139, '            } else if self.nanos < 0 {'), (141, '                self.seconds = i64::MIN;'), (142, '                self.nanos = 0;'), (143, '            } else {'), (145, '                self.seconds = i64::MAX;'), (146, '                self.nanos = 999_999_999;'), (147, '            }'), (152, '            if let Some(seconds) = self.seconds.checked_sub(1) {'), (153, '                self.seconds = seconds;'), (154, '                self.nanos += NANOS_PER_SECOND;'), (155, '            } else {'), (157, '                debug_assert_eq!(self.seconds, i64::MIN);'), (158, '                self.nanos = 0;'), (159, '            }'), (198, '#[cfg(feature = \"std\")]'), (199, '#[derive(Debug)]'), (200, '#[non_exhaustive]'), (201, 'pub struct TimestampOutOfSystemRangeError {'), (202, '    pub timestamp: Timestamp,'), (203, '}'), (205, '#[cfg(feature = \"std\")]'), (206, 'impl core::fmt::Display for TimestampOutOfSystemRangeError {'), (207, \"    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\"), (208, '        write!('), (209, '            f,'), (210, '            \"{:?} is not representable as a `SystemTime` because it is out of range\",'), (211, '            self'), (212, '        )'), (213, '    }'), (214, '}'), (216, '#[cfg(feature = \"std\")]'), (217, 'impl std::error::Error for TimestampOutOfSystemRangeError {}'), (220, 'impl TryFrom<Timestamp> for std::time::SystemTime {'), (221, '    type Error = TimestampOutOfSystemRangeError;'), (223, '    fn try_from(mut timestamp: Timestamp) -> Result<std::time::SystemTime, Self::Error> {'), (224, '        let orig_timestamp = timestamp.clone();'), (228, '            std::time::UNIX_EPOCH.checked_add(time::Duration::from_secs(timestamp.seconds as u64))'), (230, '            std::time::UNIX_EPOCH'), (231, '                .checked_sub(time::Duration::from_secs((-timestamp.seconds) as u64))'), (234, '        let system_time = system_time.and_then(|system_time| {'), (235, '            system_time.checked_add(time::Duration::from_nanos(timestamp.nanos as u64))'), (236, '        });'), (238, '        system_time.ok_or(TimestampOutOfSystemRangeError {'), (239, '            timestamp: orig_timestamp,'), (240, '        })'), (258, '            prop_assert_eq!(SystemTime::try_from(Timestamp::from(system_time)).unwrap(), system_time);'), (259, '        }'), (261, '        #[test]'), (262, '        fn check_timestamp_roundtrip_via_system_time('), (263, '            seconds in i64::arbitrary(),'), (264, '            nanos in i32::arbitrary(),'), (265, '        ) {'), (266, '            let mut timestamp = Timestamp { seconds, nanos };'), (267, '            timestamp.normalize();'), (268, '            if let Ok(system_time) = SystemTime::try_from(timestamp.clone()) {'), (269, '                prop_assert_eq!(Timestamp::from(system_time), timestamp);'), (270, '            }'), (343, '    #[test]'), (344, '    fn check_duration_normalize() {'), (345, \"        #[rustfmt::skip] // Don't mangle the table formatting.\"), (346, '        let cases = ['), (349, '            (line!(),            0,              0,                0,              0),'), (350, '            (line!(),            1,              1,                1,              1),'), (351, '            (line!(),           -1,             -1,               -1,             -1),'), (352, '            (line!(),            0,    999_999_999,                0,    999_999_999),'), (353, '            (line!(),            0,   -999_999_999,                0,   -999_999_999),'), (354, '            (line!(),            0,  1_000_000_000,                1,              0),'), (355, '            (line!(),            0, -1_000_000_000,               -1,              0),'), (356, '            (line!(),            0,  1_000_000_001,                1,              1),'), (357, '            (line!(),            0, -1_000_000_001,               -1,             -1),'), (358, '            (line!(),           -1,              1,                0,   -999_999_999),'), (359, '            (line!(),            1,             -1,                0,    999_999_999),'), (360, '            (line!(),           -1,  1_000_000_000,                0,              0),'), (361, '            (line!(),            1, -1_000_000_000,                0,              0),'), (362, '            (line!(), i64::MIN    ,              0,     i64::MIN    ,              0),'), (363, '            (line!(), i64::MIN + 1,              0,     i64::MIN + 1,              0),'), (364, '            (line!(), i64::MIN    ,              1,     i64::MIN + 1,   -999_999_999),'), (365, '            (line!(), i64::MIN    ,  1_000_000_000,     i64::MIN + 1,              0),'), (366, '            (line!(), i64::MIN    , -1_000_000_000,     i64::MIN    ,   -999_999_999),'), (367, '            (line!(), i64::MIN + 1, -1_000_000_000,     i64::MIN    ,              0),'), (368, '            (line!(), i64::MIN + 2, -1_000_000_000,     i64::MIN + 1,              0),'), (369, '            (line!(), i64::MIN    , -1_999_999_998,     i64::MIN    ,   -999_999_999),'), (370, '            (line!(), i64::MIN + 1, -1_999_999_998,     i64::MIN    ,   -999_999_998),'), (371, '            (line!(), i64::MIN + 2, -1_999_999_998,     i64::MIN + 1,   -999_999_998),'), (372, '            (line!(), i64::MIN    , -1_999_999_999,     i64::MIN    ,   -999_999_999),'), (373, '            (line!(), i64::MIN + 1, -1_999_999_999,     i64::MIN    ,   -999_999_999),'), (374, '            (line!(), i64::MIN + 2, -1_999_999_999,     i64::MIN + 1,   -999_999_999),'), (375, '            (line!(), i64::MIN    , -2_000_000_000,     i64::MIN    ,   -999_999_999),'), (376, '            (line!(), i64::MIN + 1, -2_000_000_000,     i64::MIN    ,   -999_999_999),'), (377, '            (line!(), i64::MIN + 2, -2_000_000_000,     i64::MIN    ,              0),'), (378, '            (line!(), i64::MIN    ,   -999_999_998,     i64::MIN    ,   -999_999_998),'), (379, '            (line!(), i64::MIN + 1,   -999_999_998,     i64::MIN + 1,   -999_999_998),'), (380, '            (line!(), i64::MAX    ,              0,     i64::MAX    ,              0),'), (381, '            (line!(), i64::MAX - 1,              0,     i64::MAX - 1,              0),'), (382, '            (line!(), i64::MAX    ,             -1,     i64::MAX - 1,    999_999_999),'), (383, '            (line!(), i64::MAX    ,  1_000_000_000,     i64::MAX    ,    999_999_999),'), (384, '            (line!(), i64::MAX - 1,  1_000_000_000,     i64::MAX    ,              0),'), (385, '            (line!(), i64::MAX - 2,  1_000_000_000,     i64::MAX - 1,              0),'), (386, '            (line!(), i64::MAX    ,  1_999_999_998,     i64::MAX    ,    999_999_999),'), (387, '            (line!(), i64::MAX - 1,  1_999_999_998,     i64::MAX    ,    999_999_998),'), (388, '            (line!(), i64::MAX - 2,  1_999_999_998,     i64::MAX - 1,    999_999_998),'), (389, '            (line!(), i64::MAX    ,  1_999_999_999,     i64::MAX    ,    999_999_999),'), (390, '            (line!(), i64::MAX - 1,  1_999_999_999,     i64::MAX    ,    999_999_999),'), (391, '            (line!(), i64::MAX - 2,  1_999_999_999,     i64::MAX - 1,    999_999_999),'), (392, '            (line!(), i64::MAX    ,  2_000_000_000,     i64::MAX    ,    999_999_999),'), (393, '            (line!(), i64::MAX - 1,  2_000_000_000,     i64::MAX    ,    999_999_999),'), (394, '            (line!(), i64::MAX - 2,  2_000_000_000,     i64::MAX    ,              0),'), (395, '            (line!(), i64::MAX    ,    999_999_998,     i64::MAX    ,    999_999_998),'), (396, '            (line!(), i64::MAX - 1,    999_999_998,     i64::MAX - 1,    999_999_998),'), (397, '        ];'), (399, '        for case in cases.iter() {'), (400, '            let mut test_duration = crate::Duration {'), (401, '                seconds: case.1,'), (402, '                nanos: case.2,'), (403, '            };'), (404, '            test_duration.normalize();'), (406, '            assert_eq!('), (407, '                test_duration,'), (408, '                crate::Duration {'), (409, '                    seconds: case.3,'), (410, '                    nanos: case.4,'), (411, '                },'), (412, '                \"test case on line {} doesn\\'t match\",'), (413, '                case.0,'), (414, '            );'), (415, '        }'), (416, '    }'), (418, '    #[cfg(feature = \"std\")]'), (419, '    #[test]'), (420, '    fn check_timestamp_normalize() {'), (422, \"        #[rustfmt::skip] // Don't mangle the table formatting.\"), (423, '        let cases = ['), (426, '            (line!(),            0,              0,                0,              0),'), (427, '            (line!(),            1,              1,                1,              1),'), (428, '            (line!(),           -1,             -1,               -2,    999_999_999),'), (429, '            (line!(),            0,    999_999_999,                0,    999_999_999),'), (430, '            (line!(),            0,   -999_999_999,               -1,              1),'), (431, '            (line!(),            0,  1_000_000_000,                1,              0),'), (432, '            (line!(),            0, -1_000_000_000,               -1,              0),'), (433, '            (line!(),            0,  1_000_000_001,                1,              1),'), (434, '            (line!(),            0, -1_000_000_001,               -2,    999_999_999),'), (435, '            (line!(),           -1,              1,               -1,              1),'), (436, '            (line!(),            1,             -1,                0,    999_999_999),'), (437, '            (line!(),           -1,  1_000_000_000,                0,              0),'), (438, '            (line!(),            1, -1_000_000_000,                0,              0),'), (439, '            (line!(), i64::MIN    ,              0,     i64::MIN    ,              0),'), (440, '            (line!(), i64::MIN + 1,              0,     i64::MIN + 1,              0),'), (441, '            (line!(), i64::MIN    ,              1,     i64::MIN    ,              1),'), (442, '            (line!(), i64::MIN    ,  1_000_000_000,     i64::MIN + 1,              0),'), (443, '            (line!(), i64::MIN    , -1_000_000_000,     i64::MIN    ,              0),'), (444, '            (line!(), i64::MIN + 1, -1_000_000_000,     i64::MIN    ,              0),'), (445, '            (line!(), i64::MIN + 2, -1_000_000_000,     i64::MIN + 1,              0),'), (446, '            (line!(), i64::MIN    , -1_999_999_998,     i64::MIN    ,              0),'), (447, '            (line!(), i64::MIN + 1, -1_999_999_998,     i64::MIN    ,              0),'), (448, '            (line!(), i64::MIN + 2, -1_999_999_998,     i64::MIN    ,              2),'), (449, '            (line!(), i64::MIN    , -1_999_999_999,     i64::MIN    ,              0),'), (450, '            (line!(), i64::MIN + 1, -1_999_999_999,     i64::MIN    ,              0),'), (451, '            (line!(), i64::MIN + 2, -1_999_999_999,     i64::MIN    ,              1),'), (452, '            (line!(), i64::MIN    , -2_000_000_000,     i64::MIN    ,              0),'), (453, '            (line!(), i64::MIN + 1, -2_000_000_000,     i64::MIN    ,              0),'), (454, '            (line!(), i64::MIN + 2, -2_000_000_000,     i64::MIN    ,              0),'), (455, '            (line!(), i64::MIN    ,   -999_999_998,     i64::MIN    ,              0),'), (456, '            (line!(), i64::MIN + 1,   -999_999_998,     i64::MIN    ,              2),'), (457, '            (line!(), i64::MAX    ,              0,     i64::MAX    ,              0),'), (458, '            (line!(), i64::MAX - 1,              0,     i64::MAX - 1,              0),'), (459, '            (line!(), i64::MAX    ,             -1,     i64::MAX - 1,    999_999_999),'), (460, '            (line!(), i64::MAX    ,  1_000_000_000,     i64::MAX    ,    999_999_999),'), (461, '            (line!(), i64::MAX - 1,  1_000_000_000,     i64::MAX    ,              0),'), (462, '            (line!(), i64::MAX - 2,  1_000_000_000,     i64::MAX - 1,              0),'), (463, '            (line!(), i64::MAX    ,  1_999_999_998,     i64::MAX    ,    999_999_999),'), (464, '            (line!(), i64::MAX - 1,  1_999_999_998,     i64::MAX    ,    999_999_998),'), (465, '            (line!(), i64::MAX - 2,  1_999_999_998,     i64::MAX - 1,    999_999_998),'), (466, '            (line!(), i64::MAX    ,  1_999_999_999,     i64::MAX    ,    999_999_999),'), (467, '            (line!(), i64::MAX - 1,  1_999_999_999,     i64::MAX    ,    999_999_999),'), (468, '            (line!(), i64::MAX - 2,  1_999_999_999,     i64::MAX - 1,    999_999_999),'), (469, '            (line!(), i64::MAX    ,  2_000_000_000,     i64::MAX    ,    999_999_999),'), (470, '            (line!(), i64::MAX - 1,  2_000_000_000,     i64::MAX    ,    999_999_999),'), (471, '            (line!(), i64::MAX - 2,  2_000_000_000,     i64::MAX    ,              0),'), (472, '            (line!(), i64::MAX    ,    999_999_998,     i64::MAX    ,    999_999_998),'), (473, '            (line!(), i64::MAX - 1,    999_999_998,     i64::MAX - 1,    999_999_998),'), (474, '        ];'), (476, '        for case in cases.iter() {'), (477, '            let mut test_timestamp = crate::Timestamp {'), (478, '                seconds: case.1,'), (479, '                nanos: case.2,'), (480, '            };'), (481, '            test_timestamp.normalize();'), (483, '            assert_eq!('), (484, '                test_timestamp,'), (485, '                crate::Timestamp {'), (486, '                    seconds: case.3,'), (487, '                    nanos: case.4,'), (488, '                },'), (489, '                \"test case on line {} doesn\\'t match\",'), (490, '                case.0,'), (491, '            );'), (492, '        }'), (493, '    }')], 'deleted': [(38, '            self.seconds += (self.nanos / NANOS_PER_SECOND) as i64;'), (39, '            self.nanos %= NANOS_PER_SECOND;'), (44, '            self.seconds += 1;'), (45, '            self.nanos -= NANOS_PER_SECOND;'), (47, '            self.seconds -= 1;'), (48, '            self.nanos += NANOS_PER_SECOND;'), (107, '            self.seconds += (self.nanos / NANOS_PER_SECOND) as i64;'), (108, '            self.nanos %= NANOS_PER_SECOND;'), (113, '            self.seconds -= 1;'), (114, '            self.nanos += NANOS_PER_SECOND;'), (147, 'impl From<Timestamp> for std::time::SystemTime {'), (148, '    fn from(mut timestamp: Timestamp) -> std::time::SystemTime {'), (151, '            std::time::UNIX_EPOCH + time::Duration::from_secs(timestamp.seconds as u64)'), (153, '            std::time::UNIX_EPOCH - time::Duration::from_secs((-timestamp.seconds) as u64)'), (156, '        system_time + time::Duration::from_nanos(timestamp.nanos as u64)'), (174, '            prop_assert_eq!(SystemTime::from(Timestamp::from(system_time)), system_time);')]}",
    "num_lines_added": "232",
    "num_lines_deleted": "16",
    "nloc": "421"
  },
  {
    "file_change_id": "223217532484110",
    "hash": "6b83f9d0708337a9f8b709c1624a8587021ceba2",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -224,11 +224,13 @@ impl<T> Arena<T> {\n         &'a mut self,\n         selected: I,\n     ) -> Option<(&mut T, ArenaSplit<'a, T>)> {\n-        if let Some(value) = self.get_mut(selected.borrow()) {\n+        let selected = selected.borrow();\n+\n+        if let Some(value) = self.get_mut(selected) {\n             Some((\n                 unsafe { (value as *mut T).as_mut().unwrap() },\n                 ArenaSplit {\n-                    selected: selected.borrow().clone(),\n+                    selected: selected.clone(),\n                     arena: self,\n                     __type: Default::default(),\n                 },\n@@ -421,6 +423,7 @@ impl<T> Into<Vec<T>> for Arena<T> {\n #[cfg(test)]\n mod tests {\n     use super::*;\n+    use std::cell::Cell;\n \n     fn setup_arena() -> (Arena<String>, Idx, Idx, Idx, Idx) {\n         let mut arena = Arena::new();\n@@ -707,4 +710,54 @@ mod tests {\n \n         assert_eq!(format!(\"{:?}\", john), \"Removed Idx ( 0 )\");\n     }\n+\n+    #[test]\n+    fn compare_should_work_for_idx() {\n+        let mut arena = Arena::new();\n+        let left = arena.alloc(1);\n+        let right = left.clone();\n+\n+        assert!(left.borrow() == right.borrow());\n+    }\n+\n+    #[test]\n+    fn splitting_should_be_safe() {\n+        // A bug described here (https://github.com/bennetthardwick/nano-arena/issues/1) meant that\n+        // multiple mutable references could be handed out.\n+\n+        struct ToggleIdx {\n+            first: Idx,\n+            second: Idx,\n+            state: Cell<bool>,\n+        }\n+\n+        impl Borrow<Idx> for ToggleIdx {\n+            fn borrow(&self) -> &Idx {\n+                self.state.set(!self.state.get());\n+\n+                if self.state.get() {\n+                    &self.first\n+                } else {\n+                    &self.second\n+                }\n+            }\n+        }\n+\n+        let mut arena = Arena::new();\n+\n+        let first = arena.alloc(1);\n+        let second = arena.alloc(2);\n+\n+        let toggle_idx = ToggleIdx {\n+            first: first.clone(),\n+            second: second.clone(),\n+            state: Cell::new(false),\n+        };\n+\n+        let (first_mut_ref, mut split_arena) = arena.split_at(toggle_idx).unwrap();\n+        let second_mut_ref = split_arena.get_mut(&first);\n+\n+        drop(first_mut_ref);\n+        assert!(second_mut_ref.is_none());\n+    }\n }\n",
    "diff_parsed": "{'added': [(227, '        let selected = selected.borrow();'), (229, '        if let Some(value) = self.get_mut(selected) {'), (233, '                    selected: selected.clone(),'), (426, '    use std::cell::Cell;'), (714, '    #[test]'), (715, '    fn compare_should_work_for_idx() {'), (716, '        let mut arena = Arena::new();'), (717, '        let left = arena.alloc(1);'), (718, '        let right = left.clone();'), (720, '        assert!(left.borrow() == right.borrow());'), (721, '    }'), (723, '    #[test]'), (724, '    fn splitting_should_be_safe() {'), (728, '        struct ToggleIdx {'), (729, '            first: Idx,'), (730, '            second: Idx,'), (731, '            state: Cell<bool>,'), (732, '        }'), (734, '        impl Borrow<Idx> for ToggleIdx {'), (735, '            fn borrow(&self) -> &Idx {'), (736, '                self.state.set(!self.state.get());'), (738, '                if self.state.get() {'), (739, '                    &self.first'), (740, '                } else {'), (741, '                    &self.second'), (742, '                }'), (743, '            }'), (744, '        }'), (746, '        let mut arena = Arena::new();'), (748, '        let first = arena.alloc(1);'), (749, '        let second = arena.alloc(2);'), (751, '        let toggle_idx = ToggleIdx {'), (752, '            first: first.clone(),'), (753, '            second: second.clone(),'), (754, '            state: Cell::new(false),'), (755, '        };'), (757, '        let (first_mut_ref, mut split_arena) = arena.split_at(toggle_idx).unwrap();'), (758, '        let second_mut_ref = split_arena.get_mut(&first);'), (760, '        drop(first_mut_ref);'), (761, '        assert!(second_mut_ref.is_none());'), (762, '    }')], 'deleted': [(227, '        if let Some(value) = self.get_mut(selected.borrow()) {'), (231, '                    selected: selected.borrow().clone(),')]}",
    "num_lines_added": "41",
    "num_lines_deleted": "2",
    "nloc": "633"
  },
  {
    "file_change_id": "39605958652818",
    "hash": "340f893dbc9db3e43c6315b05eff4b0b150220d2",
    "old_path": "nanorand/src/tls.rs",
    "new_path": "nanorand/src/tls.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,32 +1,27 @@\n-use crate::WyRand;\n-use std::{\n-\tcell::UnsafeCell,\n-\tops::{Deref, DerefMut},\n-\trc::Rc,\n-};\n+use crate::{Rng, WyRand};\n+use std::{cell::RefCell, rc::Rc};\n \n thread_local! {\n-\tstatic WYRAND: Rc<UnsafeCell<WyRand>> = Rc::new(UnsafeCell::new(WyRand::new()));\n+\tstatic WYRAND: Rc<RefCell<WyRand>> = Rc::new(RefCell::new(WyRand::new()));\n }\n \n+#[derive(Clone)]\n #[doc(hidden)]\n-pub struct TlsWyRand(Rc<UnsafeCell<WyRand>>);\n+pub struct TlsWyRand(Rc<RefCell<WyRand>>);\n \n-impl Deref for TlsWyRand {\n-\ttype Target = WyRand;\n+impl Rng for TlsWyRand {\n+\ttype Output = [u8; 8];\n \n-\t/// Safety: [`TlsWyRand`] is neither [Send] nor [Sync], and thus,\n-\t/// there will always be a thread-local [`WyRand`] when there is a [`TlsWyRand`]\n-\tfn deref(&self) -> &Self::Target {\n-\t\tunsafe { &*self.0.get() }\n+\tfn rand(&mut self) -> Self::Output {\n+\t\tself.0.borrow_mut().rand()\n+\t}\n+\n+\tfn rand_with_seed(seed: &[u8]) -> Self::Output {\n+\t\tWyRand::rand_with_seed(seed)\n \t}\n-}\n \n-impl DerefMut for TlsWyRand {\n-\t/// Safety: [`TlsWyRand`] is neither [Send] nor [Sync], and thus,\n-\t/// there will always be a thread-local [`WyRand`] when there is a [`TlsWyRand`]\n-\tfn deref_mut(&mut self) -> &mut Self::Target {\n-\t\tunsafe { &mut *(*self.0).get() }\n+\tfn reseed(&mut self, new_seed: &[u8]) {\n+\t\tself.0.borrow_mut().reseed(new_seed)\n \t}\n }\n \n",
    "diff_parsed": "{'added': [(1, 'use crate::{Rng, WyRand};'), (2, 'use std::{cell::RefCell, rc::Rc};'), (5, '\\tstatic WYRAND: Rc<RefCell<WyRand>> = Rc::new(RefCell::new(WyRand::new()));'), (8, '#[derive(Clone)]'), (10, 'pub struct TlsWyRand(Rc<RefCell<WyRand>>);'), (12, 'impl Rng for TlsWyRand {'), (13, '\\ttype Output = [u8; 8];'), (15, '\\tfn rand(&mut self) -> Self::Output {'), (16, '\\t\\tself.0.borrow_mut().rand()'), (17, '\\t}'), (19, '\\tfn rand_with_seed(seed: &[u8]) -> Self::Output {'), (20, '\\t\\tWyRand::rand_with_seed(seed)'), (23, '\\tfn reseed(&mut self, new_seed: &[u8]) {'), (24, '\\t\\tself.0.borrow_mut().reseed(new_seed)')], 'deleted': [(1, 'use crate::WyRand;'), (2, 'use std::{'), (3, '\\tcell::UnsafeCell,'), (4, '\\tops::{Deref, DerefMut},'), (5, '\\trc::Rc,'), (6, '};'), (9, '\\tstatic WYRAND: Rc<UnsafeCell<WyRand>> = Rc::new(UnsafeCell::new(WyRand::new()));'), (13, 'pub struct TlsWyRand(Rc<UnsafeCell<WyRand>>);'), (15, 'impl Deref for TlsWyRand {'), (16, '\\ttype Target = WyRand;'), (20, '\\tfn deref(&self) -> &Self::Target {'), (21, '\\t\\tunsafe { &*self.0.get() }'), (23, '}'), (25, 'impl DerefMut for TlsWyRand {'), (28, '\\tfn deref_mut(&mut self) -> &mut Self::Target {'), (29, '\\t\\tunsafe { &mut *(*self.0).get() }')]}",
    "num_lines_added": "14",
    "num_lines_deleted": "16",
    "nloc": "23"
  },
  {
    "file_change_id": "186035882032733",
    "hash": "1660818b60832fdf58b982a37d81f5ef10abe0be",
    "old_path": "build/cg/struct.rs",
    "new_path": "build/cg/struct.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1459,27 +1459,71 @@ impl CodeGen {\n                     if let Some(doc) = doc {\n                         doc.emit(out, 1)?;\n                     }\n-                    writeln!(out, \"    pub fn {}(&self{}) -> &str {{\", name, params)?;\n+                    // String returned from X may not be valid utf-8.\n+                    // To overcome this, we provide two methods:\n+                    //   - one that returns Result<&str, Utf8Error>\n+                    //   - one that returns &[u8]\n+                    // see rust-xcb#96\n+                    writeln!(\n+                        out,\n+                        \"{}pub fn {}(&self{}) -> Result<&str, std::str::Utf8Error> {{\",\n+                        cg::ind(1),\n+                        name,\n+                        params\n+                    )?;\n \n-                    writeln!(out, \"        unsafe {{\")?;\n+                    writeln!(out, \"{}unsafe {{\", cg::ind(2))?;\n                     writeln!(\n                         out,\n-                        \"            let offset = {};\",\n+                        \"{}let offset = {};\",\n+                        cg::ind(3),\n                         self.build_rs_expr(wire_off, \"self.\", \"()\", fields)\n                     )?;\n                     writeln!(\n                         out,\n-                        \"            let len = {} as _;\",\n+                        \"{}let len = {} as _;\",\n+                        cg::ind(3),\n                         self.build_rs_expr(len_expr, \"self.\", \"()\", fields)\n                     )?;\n-                    writeln!(out, \"            let ptr = self.wire_ptr().add(offset);\",)?;\n+                    writeln!(out, \"{}let ptr = self.wire_ptr().add(offset);\", cg::ind(3))?;\n                     writeln!(\n                         out,\n-                        \"            let utf8 = std::slice::from_raw_parts(ptr, len);\",\n+                        \"{}let raw = std::slice::from_raw_parts(ptr, len);\",\n+                        cg::ind(3)\n                     )?;\n-                    writeln!(out, \"            std::str::from_utf8(utf8).unwrap()\")?;\n-                    writeln!(out, \"        }}\")?;\n-                    writeln!(out, \"    }}\")?;\n+                    writeln!(out, \"{}std::str::from_utf8(raw)\", cg::ind(3))?;\n+                    writeln!(out, \"{}}}\", cg::ind(2))?;\n+                    writeln!(out, \"{}}}\", cg::ind(1))?;\n+\n+                    writeln!(out)?;\n+                    if let Some(doc) = doc {\n+                        doc.emit(out, 1)?;\n+                    }\n+                    writeln!(\n+                        out,\n+                        \"{}pub fn {}_raw(&self{}) -> &[u8] {{\",\n+                        cg::ind(1),\n+                        name,\n+                        params\n+                    )?;\n+\n+                    writeln!(out, \"{}unsafe {{\", cg::ind(2))?;\n+                    writeln!(\n+                        out,\n+                        \"{}let offset = {};\",\n+                        cg::ind(3),\n+                        self.build_rs_expr(wire_off, \"self.\", \"()\", fields)\n+                    )?;\n+                    writeln!(\n+                        out,\n+                        \"{}let len = {} as _;\",\n+                        cg::ind(3),\n+                        self.build_rs_expr(len_expr, \"self.\", \"()\", fields)\n+                    )?;\n+                    writeln!(out, \"{}let ptr = self.wire_ptr().add(offset);\", cg::ind(3))?;\n+                    writeln!(out, \"{}std::slice::from_raw_parts(ptr, len)\", cg::ind(3))?;\n+                    writeln!(out, \"{}}}\", cg::ind(2))?;\n+                    writeln!(out, \"{}}}\", cg::ind(1))?;\n                 }\n                 Field::List {\n                     name,\n",
    "diff_parsed": "{'added': [(1467, '                    writeln!('), (1468, '                        out,'), (1469, '                        \"{}pub fn {}(&self{}) -> Result<&str, std::str::Utf8Error> {{\",'), (1470, '                        cg::ind(1),'), (1471, '                        name,'), (1472, '                        params'), (1473, '                    )?;'), (1475, '                    writeln!(out, \"{}unsafe {{\", cg::ind(2))?;'), (1478, '                        \"{}let offset = {};\",'), (1479, '                        cg::ind(3),'), (1484, '                        \"{}let len = {} as _;\",'), (1485, '                        cg::ind(3),'), (1488, '                    writeln!(out, \"{}let ptr = self.wire_ptr().add(offset);\", cg::ind(3))?;'), (1491, '                        \"{}let raw = std::slice::from_raw_parts(ptr, len);\",'), (1492, '                        cg::ind(3)'), (1494, '                    writeln!(out, \"{}std::str::from_utf8(raw)\", cg::ind(3))?;'), (1495, '                    writeln!(out, \"{}}}\", cg::ind(2))?;'), (1496, '                    writeln!(out, \"{}}}\", cg::ind(1))?;'), (1498, '                    writeln!(out)?;'), (1499, '                    if let Some(doc) = doc {'), (1500, '                        doc.emit(out, 1)?;'), (1501, '                    }'), (1502, '                    writeln!('), (1503, '                        out,'), (1504, '                        \"{}pub fn {}_raw(&self{}) -> &[u8] {{\",'), (1505, '                        cg::ind(1),'), (1506, '                        name,'), (1507, '                        params'), (1508, '                    )?;'), (1510, '                    writeln!(out, \"{}unsafe {{\", cg::ind(2))?;'), (1511, '                    writeln!('), (1512, '                        out,'), (1513, '                        \"{}let offset = {};\",'), (1514, '                        cg::ind(3),'), (1515, '                        self.build_rs_expr(wire_off, \"self.\", \"()\", fields)'), (1516, '                    )?;'), (1517, '                    writeln!('), (1518, '                        out,'), (1519, '                        \"{}let len = {} as _;\",'), (1520, '                        cg::ind(3),'), (1521, '                        self.build_rs_expr(len_expr, \"self.\", \"()\", fields)'), (1522, '                    )?;'), (1523, '                    writeln!(out, \"{}let ptr = self.wire_ptr().add(offset);\", cg::ind(3))?;'), (1524, '                    writeln!(out, \"{}std::slice::from_raw_parts(ptr, len)\", cg::ind(3))?;'), (1525, '                    writeln!(out, \"{}}}\", cg::ind(2))?;'), (1526, '                    writeln!(out, \"{}}}\", cg::ind(1))?;')], 'deleted': [(1462, '                    writeln!(out, \"    pub fn {}(&self{}) -> &str {{\", name, params)?;'), (1464, '                    writeln!(out, \"        unsafe {{\")?;'), (1467, '                        \"            let offset = {};\",'), (1472, '                        \"            let len = {} as _;\",'), (1475, '                    writeln!(out, \"            let ptr = self.wire_ptr().add(offset);\",)?;'), (1478, '                        \"            let utf8 = std::slice::from_raw_parts(ptr, len);\",'), (1480, '                    writeln!(out, \"            std::str::from_utf8(utf8).unwrap()\")?;'), (1481, '                    writeln!(out, \"        }}\")?;'), (1482, '                    writeln!(out, \"    }}\")?;')]}",
    "num_lines_added": "46",
    "num_lines_deleted": "9",
    "nloc": "1818"
  },
  {
    "file_change_id": "28571218207488",
    "hash": "6299af0ab17f070a78b75367e14b9101c29ce475",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -134,8 +134,7 @@ impl<'a> Record<'a> {\n             return Err(Error::RecordTooShort(len));\n         }\n \n-        data.reserve(len - 5);\n-        unsafe { data.set_len(len) };\n+        data.resize(len, 0);\n         input.read_exact(&mut data[5..len])?;\n \n         let data_offset = misc::read_dec_5(&data[12..17])?;\n",
    "diff_parsed": "{'added': [(137, '        data.resize(len, 0);')], 'deleted': [(137, '        data.reserve(len - 5);'), (138, '        unsafe { data.set_len(len) };')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "2",
    "nloc": "1048"
  },
  {
    "file_change_id": "81907049805017",
    "hash": "6dd7ca0d50f2464df708975cdafcfaeeb6d41c66",
    "old_path": "src/aref.rs",
    "new_path": "src/aref.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -516,7 +516,7 @@ impl<'a, U: ?Sized> ARefs<'a, U> {\n     /// assert_eq!(*aref.map(|s| &s[1]), 5);\n     /// ```\n     #[inline]\n-    pub fn map<V: ?Sized, F: FnOnce(&U) -> &V>(self, f: F) -> ARefs<'a, V> { ARefs(self.0.map(f)) }\n+    pub fn map<V: ?Sized + Send, F: FnOnce(&U) -> &V>(self, f: F) -> ARefs<'a, V> { ARefs(self.0.map(f)) }\n \n     /// Like map, but with Result passthrough.\n     ///\n@@ -528,11 +528,11 @@ impl<'a, U: ?Sized> ARefs<'a, U> {\n     /// assert_eq!(aref.try_map(|s| s.get(9).ok_or(())), Err(()));\n     /// ```\n     #[inline]\n-    pub fn try_map<E, V: ?Sized, F: FnOnce(&U) -> Result<&V, E>>(self, f: F) -> Result<ARefs<'a, V>, E> {\n+    pub fn try_map<E, V: ?Sized + Send, F: FnOnce(&U) -> Result<&V, E>>(self, f: F) -> Result<ARefs<'a, V>, E> {\n         self.0.try_map(f).map(|z| ARefs(z))\n     }\n \n-    /// Removes the type information that this struct is Send + Sync.\n+    /// Removes the type information that this struct is Send.\n     #[inline]\n     pub fn into_aref(self) -> ARef<'a, U> { self.0 }\n }\n@@ -564,7 +564,7 @@ impl<'a, U: ?Sized> ARefss<'a, U> {\n     /// assert_eq!(*aref.map(|s| &s[1]), 5);\n     /// ```\n     #[inline]\n-    pub fn map<V: ?Sized, F: FnOnce(&U) -> &V>(self, f: F) -> ARefss<'a, V> { ARefss(self.0.map(f)) }\n+    pub fn map<V: ?Sized + Send + Sync, F: FnOnce(&U) -> &V>(self, f: F) -> ARefss<'a, V> { ARefss(self.0.map(f)) }\n \n     /// Like map, but with Result passthrough.\n     ///\n@@ -576,7 +576,7 @@ impl<'a, U: ?Sized> ARefss<'a, U> {\n     /// assert_eq!(aref.try_map(|s| s.get(9).ok_or(())), Err(()));\n     /// ```\n     #[inline]\n-    pub fn try_map<E, V: ?Sized, F: FnOnce(&U) -> Result<&V, E>>(self, f: F) -> Result<ARefss<'a, V>, E> {\n+    pub fn try_map<E, V: ?Sized + Send + Sync, F: FnOnce(&U) -> Result<&V, E>>(self, f: F) -> Result<ARefss<'a, V>, E> {\n         self.0.try_map(f).map(|z| ARefss(z))\n     }\n \n",
    "diff_parsed": "{'added': [(519, \"    pub fn map<V: ?Sized + Send, F: FnOnce(&U) -> &V>(self, f: F) -> ARefs<'a, V> { ARefs(self.0.map(f)) }\"), (531, \"    pub fn try_map<E, V: ?Sized + Send, F: FnOnce(&U) -> Result<&V, E>>(self, f: F) -> Result<ARefs<'a, V>, E> {\"), (567, \"    pub fn map<V: ?Sized + Send + Sync, F: FnOnce(&U) -> &V>(self, f: F) -> ARefss<'a, V> { ARefss(self.0.map(f)) }\"), (579, \"    pub fn try_map<E, V: ?Sized + Send + Sync, F: FnOnce(&U) -> Result<&V, E>>(self, f: F) -> Result<ARefss<'a, V>, E> {\")], 'deleted': [(519, \"    pub fn map<V: ?Sized, F: FnOnce(&U) -> &V>(self, f: F) -> ARefs<'a, V> { ARefs(self.0.map(f)) }\"), (531, \"    pub fn try_map<E, V: ?Sized, F: FnOnce(&U) -> Result<&V, E>>(self, f: F) -> Result<ARefs<'a, V>, E> {\"), (567, \"    pub fn map<V: ?Sized, F: FnOnce(&U) -> &V>(self, f: F) -> ARefss<'a, V> { ARefss(self.0.map(f)) }\"), (579, \"    pub fn try_map<E, V: ?Sized, F: FnOnce(&U) -> Result<&V, E>>(self, f: F) -> Result<ARefss<'a, V>, E> {\")]}",
    "num_lines_added": "4",
    "num_lines_deleted": "4",
    "nloc": "532"
  },
  {
    "file_change_id": "223289116624393",
    "hash": "3199bd8623d05341b4047f53e143ae67d7d9f064",
    "old_path": "buttplug/src/util/future.rs",
    "new_path": "buttplug/src/util/future.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -85,9 +85,9 @@ pub struct ButtplugFutureStateShared<T> {\n   state: Arc<Mutex<ButtplugFutureState<T>>>,\n }\n \n-unsafe impl<T> Sync for ButtplugFutureStateShared<T> {\n+unsafe impl<T: Sync> Sync for ButtplugFutureStateShared<T> {\n }\n-unsafe impl<T> Send for ButtplugFutureStateShared<T> {\n+unsafe impl<T: Send> Send for ButtplugFutureStateShared<T> {\n }\n \n impl<T> ButtplugFutureStateShared<T> {\n",
    "diff_parsed": "{'added': [(88, 'unsafe impl<T: Sync> Sync for ButtplugFutureStateShared<T> {'), (90, 'unsafe impl<T: Send> Send for ButtplugFutureStateShared<T> {')], 'deleted': [(88, 'unsafe impl<T> Sync for ButtplugFutureStateShared<T> {'), (90, 'unsafe impl<T> Send for ButtplugFutureStateShared<T> {')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "95"
  },
  {
    "file_change_id": "32055837066654",
    "hash": "2928a87a0c9f86c46ba70f8c8058d9b7b10a241d",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -146,8 +146,8 @@ impl<T> Clone for Intern<T> {\n /// because we never free the data pointed to by an `Intern`.\n impl<T> Copy for Intern<T> {}\n \n-unsafe impl<T> Send for Intern<T> {}\n-unsafe impl<T> Sync for Intern<T> {}\n+unsafe impl<T: Send> Send for Intern<T> {}\n+unsafe impl<T: Sync> Sync for Intern<T> {}\n \n impl<T: Eq + Hash + Send + 'static> Intern<T> {\n     fn get_mutex() -> &'static Mutex<HashSet<Box<T>>> {\n",
    "diff_parsed": "{'added': [(149, 'unsafe impl<T: Send> Send for Intern<T> {}'), (150, 'unsafe impl<T: Sync> Sync for Intern<T> {}')], 'deleted': [(149, 'unsafe impl<T> Send for Intern<T> {}'), (150, 'unsafe impl<T> Sync for Intern<T> {}')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "724"
  },
  {
    "file_change_id": "7181450227808",
    "hash": "8e970aaa60471a845a309c0fe82ebe59779341ca",
    "old_path": "src/generic.rs",
    "new_path": "src/generic.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -527,5 +527,6 @@ where\n     }\n }\n \n+// Safety: Same bounds as `std::borrow::Cow`.\n unsafe impl<T: Beef + Sync + ?Sized, U: Capacity> Sync for Cow<'_, T, U> {}\n-unsafe impl<T: Beef + Send + ?Sized, U: Capacity> Send for Cow<'_, T, U> {}\n+unsafe impl<T: Beef + Send + Sync + ?Sized, U: Capacity> Send for Cow<'_, T, U> {}\n",
    "diff_parsed": "{'added': [(532, \"unsafe impl<T: Beef + Send + Sync + ?Sized, U: Capacity> Send for Cow<'_, T, U> {}\")], 'deleted': [(531, \"unsafe impl<T: Beef + Send + ?Sized, U: Capacity> Send for Cow<'_, T, U> {}\")]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "419"
  },
  {
    "file_change_id": "177645884391944",
    "hash": "cdff034e6d93cdfdafd13d8c6956e22fa5a57b79",
    "old_path": "crates/xdv/src/lib.rs",
    "new_path": "crates/xdv/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -221,10 +221,9 @@ impl<T: XdvEvents> XdvParser<T> {\n     {\n         const BUF_SIZE: usize = 4096;\n         let mut parser = Self::new(events);\n-        let mut buf = Vec::with_capacity(BUF_SIZE);\n-        unsafe {\n-            buf.set_len(BUF_SIZE);\n-        }\n+        // Note that it is unsound to pass uninitialized data to a read() call,\n+        // even though it *should* never cause problems ...\n+        let mut buf = vec![0; BUF_SIZE];\n         let mut n_saved_bytes = 0;\n \n         loop {\n",
    "diff_parsed": "{'added': [(226, '        let mut buf = vec![0; BUF_SIZE];')], 'deleted': [(224, '        let mut buf = Vec::with_capacity(BUF_SIZE);'), (225, '        unsafe {'), (226, '            buf.set_len(BUF_SIZE);'), (227, '        }')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "4",
    "nloc": "869"
  },
  {
    "file_change_id": "38071644224003",
    "hash": "599313b39c249ee89144c69eb09da0f56d579922",
    "old_path": "src/read.rs",
    "new_path": "src/read.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -17,12 +17,9 @@ impl<R: io::Read> IoReader<R> {\n \n impl<R: io::Read> BufReadExact for IoReader<R> {\n     fn buf_read_exact(&mut self, len: usize) -> io::Result<&[u8]> {\n-        unsafe {\n-            self.buf.reserve(len);\n-            let slice = self.buf.get_unchecked_mut(..len);\n-            self.rdr.read_exact(slice)?;\n-            Ok(slice)\n-        }\n+        self.buf.resize(len, 0);\n+        self.rdr.read_exact(self.buf.as_mut_slice())?;\n+        Ok(self.buf.as_slice())\n     }\n }\n \n",
    "diff_parsed": "{'added': [(20, '        self.buf.resize(len, 0);'), (21, '        self.rdr.read_exact(self.buf.as_mut_slice())?;'), (22, '        Ok(self.buf.as_slice())')], 'deleted': [(20, '        unsafe {'), (21, '            self.buf.reserve(len);'), (22, '            let slice = self.buf.get_unchecked_mut(..len);'), (23, '            self.rdr.read_exact(slice)?;'), (24, '            Ok(slice)'), (25, '        }')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "6",
    "nloc": "39"
  },
  {
    "file_change_id": "898269493666",
    "hash": "291fca7dbfb2e3fe235180b41ce9e845ef0b2895",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -319,14 +319,9 @@ impl<A> State<A> {\n         let start_ptr = self.tip.as_mut_ptr()\n                                 .offset(self.tip.len_items() as isize);\n \n-        let padding = start_ptr as usize % alignment;\n-\n-        debug_assert!(padding < alignment);\n-        debug_assert_eq!(padding, 0);\n-\n+        let padding = (alignment - (start_ptr as usize % alignment)) % alignment;\n         let start_ptr = start_ptr.offset(AlignedVec::<A>::bytes_to_items(padding) as isize);\n-\n-        let new_used = self.tip.len_items() + padding + AlignedVec::<A>::bytes_to_items(size);\n+        let new_used = self.tip.len_items() + AlignedVec::<A>::bytes_to_items(padding + size);\n \n         if new_used <= self.tip.capacity_items() {\n             self.tip.set_len_items(new_used);\n",
    "diff_parsed": "{'added': [(322, '        let padding = (alignment - (start_ptr as usize % alignment)) % alignment;'), (324, '        let new_used = self.tip.len_items() + AlignedVec::<A>::bytes_to_items(padding + size);')], 'deleted': [(322, '        let padding = start_ptr as usize % alignment;'), (324, '        debug_assert!(padding < alignment);'), (325, '        debug_assert_eq!(padding, 0);'), (329, '        let new_used = self.tip.len_items() + padding + AlignedVec::<A>::bytes_to_items(size);')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "4",
    "nloc": "448"
  },
  {
    "file_change_id": "239940022885768",
    "hash": "936ab41a87d2b4876e09efc43864faf591dc0c2c",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -712,16 +712,13 @@ impl VendorInfo {\n     /// Return vendor identification as human readable string.\n     pub fn as_string<'a>(&'a self) -> &'a str {\n         let brand_string_start = self as *const VendorInfo as *const u8;\n-        unsafe {\n+        let slice = unsafe {\n             // Safety: VendorInfo is laid out with repr(C) and exactly\n             // 12 byte long without any padding.\n-            let slice: &'a [u8] =\n-                slice::from_raw_parts(brand_string_start, size_of::<VendorInfo>());\n-            // Safety: The field is specified to be ASCII, and the only safe\n-            // way to construct VendorInfo is from real CPUID data or the\n-            // Default implementation.\n-            str::from_utf8_unchecked(slice)\n-        }\n+            slice::from_raw_parts(brand_string_start, size_of::<VendorInfo>())\n+        };\n+\n+        str::from_utf8(slice).unwrap_or(\"InvalidVendorString\")\n     }\n }\n \n@@ -4193,15 +4190,11 @@ pub struct SoCVendorBrand {\n impl SoCVendorBrand {\n     pub fn as_string<'a>(&'a self) -> &'a str {\n         let brand_string_start = self as *const SoCVendorBrand as *const u8;\n-        unsafe {\n+        let slice = unsafe {\n             // Safety: SoCVendorBrand is laid out with repr(C).\n-            let slice: &'a [u8] =\n-                slice::from_raw_parts(brand_string_start, size_of::<SoCVendorBrand>());\n-            // Safety: The field is specified to be ASCII, and the only safe\n-            // way to construct SoCVendorBrand is from real CPUID data or the\n-            // Default implementation.\n-            str::from_utf8_unchecked(slice)\n-        }\n+            slice::from_raw_parts(brand_string_start, size_of::<SoCVendorBrand>())\n+        };\n+        str::from_utf8(slice).unwrap_or(\"InvalidSoCVendorString\")\n     }\n }\n \n@@ -4329,10 +4322,7 @@ impl ExtendedFunctionInfo {\n             // Brand terminated at nul byte or end, whichever comes first.\n             let slice = slice.split(|&x| x == 0).next().unwrap();\n \n-            // Safety: Field is specified to be ASCII, and the only safe way\n-            // to construct ExtendedFunctionInfo is from real CPUID data\n-            // or the Default implementation.\n-            Some(unsafe { str::from_utf8_unchecked(slice) })\n+            str::from_utf8(slice).ok()\n         } else {\n             None\n         }\n",
    "diff_parsed": "{'added': [(715, '        let slice = unsafe {'), (718, '            slice::from_raw_parts(brand_string_start, size_of::<VendorInfo>())'), (719, '        };'), (721, '        str::from_utf8(slice).unwrap_or(\"InvalidVendorString\")'), (4193, '        let slice = unsafe {'), (4195, '            slice::from_raw_parts(brand_string_start, size_of::<SoCVendorBrand>())'), (4196, '        };'), (4197, '        str::from_utf8(slice).unwrap_or(\"InvalidSoCVendorString\")'), (4325, '            str::from_utf8(slice).ok()')], 'deleted': [(715, '        unsafe {'), (718, \"            let slice: &'a [u8] =\"), (719, '                slice::from_raw_parts(brand_string_start, size_of::<VendorInfo>());'), (723, '            str::from_utf8_unchecked(slice)'), (724, '        }'), (4196, '        unsafe {'), (4198, \"            let slice: &'a [u8] =\"), (4199, '                slice::from_raw_parts(brand_string_start, size_of::<SoCVendorBrand>());'), (4203, '            str::from_utf8_unchecked(slice)'), (4204, '        }'), (4335, '            Some(unsafe { str::from_utf8_unchecked(slice) })')]}",
    "num_lines_added": "9",
    "num_lines_deleted": "11",
    "nloc": "3679"
  },
  {
    "file_change_id": "240487279583862",
    "hash": "dd0639bf2876773b66382f47285f7db701f628d",
    "old_path": "src/main.rs",
    "new_path": "src/main.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -106,6 +106,14 @@ struct Server {\n     port_ranges: Vec<(u16, u16)>,\n }\n \n+impl Server {\n+    fn validate_hostname(&self) -> bool {\n+        self.hostname\n+            .chars()\n+            .all(|c| c.is_ascii_alphanumeric() || c == '-')\n+    }\n+}\n+\n // latitude and longitude omitted\n #[derive(serde::Deserialize)]\n struct City {\n@@ -130,13 +138,26 @@ struct ServerList {\n \n impl ServerList {\n     fn new(client: reqwest::blocking::Client, token: &str) -> Self {\n-        client\n+        let server_list = client\n             .get(&format!(\"{}/vpn/servers\", BASE_URL))\n             .bearer_auth(token)\n             .send()\n             .unwrap()\n             .json::<ServerList>()\n-            .unwrap()\n+            .unwrap();\n+        if let Some(server) = server_list\n+            .countries\n+            .iter()\n+            .flat_map(|country| country.cities.iter().flat_map(|city| city.servers.iter()))\n+            .find(|server| !server.validate_hostname())\n+        {\n+            eprintln!(\n+                \"A server contains invalid characters in its hostname: {}\",\n+                server.hostname\n+            );\n+            std::process::exit(3);\n+        }\n+        server_list\n     }\n }\n \n",
    "diff_parsed": "{'added': [(109, 'impl Server {'), (110, '    fn validate_hostname(&self) -> bool {'), (111, '        self.hostname'), (112, '            .chars()'), (113, \"            .all(|c| c.is_ascii_alphanumeric() || c == '-')\"), (114, '    }'), (115, '}'), (141, '        let server_list = client'), (147, '            .unwrap();'), (148, '        if let Some(server) = server_list'), (149, '            .countries'), (150, '            .iter()'), (151, '            .flat_map(|country| country.cities.iter().flat_map(|city| city.servers.iter()))'), (152, '            .find(|server| !server.validate_hostname())'), (153, '        {'), (154, '            eprintln!('), (155, '                \"A server contains invalid characters in its hostname: {}\",'), (156, '                server.hostname'), (157, '            );'), (158, '            std::process::exit(3);'), (159, '        }'), (160, '        server_list')], 'deleted': [(133, '        client'), (139, '            .unwrap()')]}",
    "num_lines_added": "22",
    "num_lines_deleted": "2",
    "nloc": "523"
  },
  {
    "file_change_id": "89398062357828",
    "hash": "f9e8a1c13cca73e356b48f8a16a6bd308f20988",
    "old_path": "src/sync/ms_queue.rs",
    "new_path": "src/sync/ms_queue.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -174,7 +174,7 @@ impl<T> MsQueue<T> {\n                         unsafe {\n                             // signal the thread\n                             (*signal).data = Some(cache.into_data());\n-                            (*signal).ready.store(true, Relaxed);\n+                            (*signal).ready.store(true, Release);\n                             (*signal).thread.unpark();\n                             guard.unlinked(head);\n                             return;\n@@ -295,7 +295,7 @@ impl<T> MsQueue<T> {\n             // case, blocked.\n             match self.push_internal(&guard, tail, node) {\n                 Ok(()) => {\n-                    while !signal.ready.load(Relaxed) {\n+                    while !signal.ready.load(Acquire) {\n                         thread::park();\n                     }\n                     return signal.data.unwrap();\n",
    "diff_parsed": "{'added': [(177, '                            (*signal).ready.store(true, Release);'), (298, '                    while !signal.ready.load(Acquire) {')], 'deleted': [(177, '                            (*signal).ready.store(true, Relaxed);'), (298, '                    while !signal.ready.load(Relaxed) {')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "392"
  },
  {
    "file_change_id": "52281260016306",
    "hash": "f86e6d392326f0e4dc25eeec8b26af36f2b0fbc",
    "old_path": "src/instance.rs",
    "new_path": "src/instance.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -494,9 +494,9 @@ impl<T> std::convert::From<Py<T>> for PyObject\n where\n     T: AsRef<PyAny>,\n {\n+    #[inline]\n     fn from(other: Py<T>) -> Self {\n-        let Py(ptr, _) = other;\n-        Py(ptr, PhantomData)\n+        unsafe { Self::from_non_null(other.into_non_null()) }\n     }\n }\n \n@@ -647,4 +647,14 @@ mod test {\n         };\n         assert_eq!(unsafe { ffi::Py_REFCNT(dict.as_ptr()) }, 1);\n     }\n+\n+    #[test]\n+    fn pyobject_from_py() {\n+        Python::with_gil(|py| {\n+            let dict: Py<PyDict> = PyDict::new(py).into();\n+            let cnt = dict.get_refcnt(py);\n+            let p: PyObject = dict.into();\n+            assert_eq!(p.get_refcnt(py), cnt);\n+        });\n+    }\n }\n",
    "diff_parsed": "{'added': [(497, '    #[inline]'), (499, '        unsafe { Self::from_non_null(other.into_non_null()) }'), (651, '    #[test]'), (652, '    fn pyobject_from_py() {'), (653, '        Python::with_gil(|py| {'), (654, '            let dict: Py<PyDict> = PyDict::new(py).into();'), (655, '            let cnt = dict.get_refcnt(py);'), (656, '            let p: PyObject = dict.into();'), (657, '            assert_eq!(p.get_refcnt(py), cnt);'), (658, '        });'), (659, '    }')], 'deleted': [(498, '        let Py(ptr, _) = other;'), (499, '        Py(ptr, PhantomData)')]}",
    "num_lines_added": "11",
    "num_lines_deleted": "2",
    "nloc": "404"
  },
  {
    "file_change_id": "175650609377847",
    "hash": "45f172cf8407e05cb9ed431f68663ad4f46b232",
    "old_path": "streebog/src/streebog.rs",
    "new_path": "streebog/src/streebog.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -61,12 +61,10 @@ impl StreebogState {\n     }\n \n     fn update_sigma(&mut self, m: &Block) {\n-        let mut over = false;\n+        let mut carry = 0;\n         for (a, b) in self.sigma.iter_mut().zip(m.iter()) {\n-            let (res, loc_over) = (*a).overflowing_add(*b);\n-            *a = res;\n-            if over { *a += 1; }\n-            over = loc_over;\n+            carry = (*a as u16) + (*b as u16) + (carry >> 8);\n+            *a = (carry & 0xFF) as u8;\n         }\n     }\n \n",
    "diff_parsed": "{'added': [(64, '        let mut carry = 0;'), (66, '            carry = (*a as u16) + (*b as u16) + (carry >> 8);'), (67, '            *a = (carry & 0xFF) as u8;')], 'deleted': [(64, '        let mut over = false;'), (66, '            let (res, loc_over) = (*a).overflowing_add(*b);'), (67, '            *a = res;'), (68, '            if over { *a += 1; }'), (69, '            over = loc_over;')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "5",
    "nloc": "137"
  },
  {
    "file_change_id": "26255975533873",
    "hash": "bbe7cc5381c5380b54fb8bbb4f77a3725917ff0",
    "old_path": "src/transport/sendmail/mod.rs",
    "new_path": "src/transport/sendmail/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -120,6 +120,7 @@ impl SendmailTransport {\n         c.arg(\"-i\")\n             .arg(\"-f\")\n             .arg(envelope.from().map(|f| f.as_ref()).unwrap_or(\"\\\"\\\"\"))\n+            .arg(\"--\")\n             .args(envelope.to())\n             .stdin(Stdio::piped())\n             .stdout(Stdio::piped());\n@@ -135,6 +136,7 @@ impl SendmailTransport {\n         c.arg(\"-i\")\n             .arg(\"-f\")\n             .arg(envelope.from().map(|f| f.as_ref()).unwrap_or(\"\\\"\\\"\"))\n+            .arg(\"--\")\n             .args(envelope.to())\n             .stdin(Stdio::piped())\n             .stdout(Stdio::piped());\n@@ -150,6 +152,7 @@ impl SendmailTransport {\n         c.arg(\"-i\")\n             .arg(\"-f\")\n             .arg(envelope.from().map(|f| f.as_ref()).unwrap_or(\"\\\"\\\"\"))\n+            .arg(\"--\")\n             .args(envelope.to())\n             .stdin(Stdio::piped())\n             .stdout(Stdio::piped());\n",
    "diff_parsed": "{'added': [(123, '            .arg(\"--\")'), (139, '            .arg(\"--\")'), (155, '            .arg(\"--\")')], 'deleted': []}",
    "num_lines_added": "3",
    "num_lines_deleted": "0",
    "nloc": "150"
  },
  {
    "file_change_id": "196628380876484",
    "hash": "414bc9e7abac7500312e0324378ec320c079a98",
    "old_path": "src/transport/sendmail/mod.rs",
    "new_path": "src/transport/sendmail/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -117,10 +117,11 @@ impl SendmailTransport {\n \n     fn command(&self, envelope: &Envelope) -> Command {\n         let mut c = Command::new(&self.command);\n-        c.arg(\"-i\")\n-            .arg(\"-f\")\n-            .arg(envelope.from().map(|f| f.as_ref()).unwrap_or(\"\\\"\\\"\"))\n-            .arg(\"--\")\n+        c.arg(\"-i\");\n+        if let Some(from) = envelope.from() {\n+            c.arg(\"-f\").arg(from);\n+        }\n+        c.arg(\"--\")\n             .args(envelope.to())\n             .stdin(Stdio::piped())\n             .stdout(Stdio::piped());\n@@ -133,10 +134,11 @@ impl SendmailTransport {\n \n         let mut c = Command::new(&self.command);\n         c.kill_on_drop(true);\n-        c.arg(\"-i\")\n-            .arg(\"-f\")\n-            .arg(envelope.from().map(|f| f.as_ref()).unwrap_or(\"\\\"\\\"\"))\n-            .arg(\"--\")\n+        c.arg(\"-i\");\n+        if let Some(from) = envelope.from() {\n+            c.arg(\"-f\").arg(from);\n+        }\n+        c.arg(\"--\")\n             .args(envelope.to())\n             .stdin(Stdio::piped())\n             .stdout(Stdio::piped());\n@@ -149,10 +151,11 @@ impl SendmailTransport {\n \n         let mut c = Command::new(&self.command);\n         c.kill_on_drop(true);\n-        c.arg(\"-i\")\n-            .arg(\"-f\")\n-            .arg(envelope.from().map(|f| f.as_ref()).unwrap_or(\"\\\"\\\"\"))\n-            .arg(\"--\")\n+        c.arg(\"-i\");\n+        if let Some(from) = envelope.from() {\n+            c.arg(\"-f\").arg(from);\n+        }\n+        c.arg(\"--\")\n             .args(envelope.to())\n             .stdin(Stdio::piped())\n             .stdout(Stdio::piped());\n",
    "diff_parsed": "{'added': [(120, '        c.arg(\"-i\");'), (121, '        if let Some(from) = envelope.from() {'), (122, '            c.arg(\"-f\").arg(from);'), (123, '        }'), (124, '        c.arg(\"--\")'), (137, '        c.arg(\"-i\");'), (138, '        if let Some(from) = envelope.from() {'), (139, '            c.arg(\"-f\").arg(from);'), (140, '        }'), (141, '        c.arg(\"--\")'), (154, '        c.arg(\"-i\");'), (155, '        if let Some(from) = envelope.from() {'), (156, '            c.arg(\"-f\").arg(from);'), (157, '        }'), (158, '        c.arg(\"--\")')], 'deleted': [(120, '        c.arg(\"-i\")'), (121, '            .arg(\"-f\")'), (122, '            .arg(envelope.from().map(|f| f.as_ref()).unwrap_or(\"\\\\\"\\\\\"\"))'), (123, '            .arg(\"--\")'), (136, '        c.arg(\"-i\")'), (137, '            .arg(\"-f\")'), (138, '            .arg(envelope.from().map(|f| f.as_ref()).unwrap_or(\"\\\\\"\\\\\"\"))'), (139, '            .arg(\"--\")'), (152, '        c.arg(\"-i\")'), (153, '            .arg(\"-f\")'), (154, '            .arg(envelope.from().map(|f| f.as_ref()).unwrap_or(\"\\\\\"\\\\\"\"))'), (155, '            .arg(\"--\")')]}",
    "num_lines_added": "15",
    "num_lines_deleted": "12",
    "nloc": "153"
  },
  {
    "file_change_id": "159906672727159",
    "hash": "76bc9b5fbae73262307c41e72dbcfa0796073f3",
    "old_path": "src/array.rs",
    "new_path": "src/array.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -174,26 +174,24 @@ macro_rules! impl_array {\n         where\n             F: FnMut(T) -> U,\n         {\n-            fn map_array(mut values: [T; $size], mut f: F) -> Self {\n+            fn map_array(values: [T; $size], mut f: F) -> Self {\n                 use std::{\n-                    mem::forget,\n+                    mem::{ManuallyDrop, MaybeUninit},\n                     ptr::{read, write},\n                 };\n \n+                // Use `ManuallyDrop<_>` to guard against panic safety issue.\n+                // Upon panic in `f`, `values` isn't dropped\n+                // and thus item copied by `read()` is dropped only once.\n+                let mut values = ManuallyDrop::new(values);\n                 unsafe {\n-                    // All elements of `result` is written.\n-                    // Each element of `values` read once and then forgotten.\n-                    // Hence safe in case `f` never panics.\n-                    // TODO: Make it panic-safe.\n-                    let mut result: ::std::mem::MaybeUninit<[U; $size]> =\n-                        ::std::mem::MaybeUninit::zeroed();\n+                    let mut result: MaybeUninit<[U; $size]> = MaybeUninit::zeroed();\n                     for i in 0..$size {\n                         write(\n                             result.as_mut_ptr().cast::<U>().add(i),\n                             f(read(&mut values[i])),\n                         );\n                     }\n-                    forget(values);\n                     result.assume_init()\n                 }\n             }\n",
    "diff_parsed": "{'added': [(177, '            fn map_array(values: [T; $size], mut f: F) -> Self {'), (179, '                    mem::{ManuallyDrop, MaybeUninit},'), (186, '                let mut values = ManuallyDrop::new(values);'), (188, '                    let mut result: MaybeUninit<[U; $size]> = MaybeUninit::zeroed();')], 'deleted': [(177, '            fn map_array(mut values: [T; $size], mut f: F) -> Self {'), (179, '                    mem::forget,'), (188, '                    let mut result: ::std::mem::MaybeUninit<[U; $size]> ='), (189, '                        ::std::mem::MaybeUninit::zeroed();'), (196, '                    forget(values);')]}",
    "num_lines_added": "4",
    "num_lines_deleted": "5",
    "nloc": "265"
  },
  {
    "file_change_id": "206233344722417",
    "hash": "ee5d1cf3b2df709ae1521d11521f38e335c45be",
    "old_path": "tokio-rustls/src/common/mod.rs",
    "new_path": "tokio-rustls/src/common/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -218,7 +218,10 @@ impl<'a, IO: AsyncRead + AsyncWrite + Unpin, S: Session> Stream<'a, IO, S> {\n             while !self.eof && self.session.wants_read() {\n                 match self.read_io(cx) {\n                     Poll::Ready(Ok(0)) => self.eof = true,\n-                    Poll::Ready(Ok(n)) => rdlen += n,\n+                    Poll::Ready(Ok(n)) => {\n+                        rdlen += n;\n+                        self.process_new_packets(cx)?;\n+                    }\n                     Poll::Pending => {\n                         read_would_block = true;\n                         break;\n@@ -227,8 +230,6 @@ impl<'a, IO: AsyncRead + AsyncWrite + Unpin, S: Session> Stream<'a, IO, S> {\n                 }\n             }\n \n-            self.process_new_packets(cx)?;\n-\n             return match (self.eof, self.session.is_handshaking()) {\n                 (true, true) => {\n                     let err = io::Error::new(io::ErrorKind::UnexpectedEof, \"tls handshake eof\");\n@@ -266,7 +267,7 @@ impl<'a, IO: AsyncRead + AsyncWrite + Unpin, S: Session> AsyncRead for Stream<'a\n                         self.eof = true;\n                         break;\n                     }\n-                    Poll::Ready(Ok(_)) => (),\n+                    Poll::Ready(Ok(_)) => self.process_new_packets(cx)?,\n                     Poll::Pending => {\n                         would_block = true;\n                         break;\n@@ -275,8 +276,6 @@ impl<'a, IO: AsyncRead + AsyncWrite + Unpin, S: Session> AsyncRead for Stream<'a\n                 }\n             }\n \n-            self.process_new_packets(cx)?;\n-\n             return match self.session.read(&mut buf[pos..]) {\n                 Ok(0) if pos == 0 && would_block => Poll::Pending,\n                 Ok(n) if self.eof || would_block => Poll::Ready(Ok(pos + n)),\n",
    "diff_parsed": "{'added': [(221, '                    Poll::Ready(Ok(n)) => {'), (222, '                        rdlen += n;'), (223, '                        self.process_new_packets(cx)?;'), (224, '                    }'), (270, '                    Poll::Ready(Ok(_)) => self.process_new_packets(cx)?,')], 'deleted': [(221, '                    Poll::Ready(Ok(n)) => rdlen += n,'), (230, '            self.process_new_packets(cx)?;'), (269, '                    Poll::Ready(Ok(_)) => (),'), (278, '            self.process_new_packets(cx)?;')]}",
    "num_lines_added": "5",
    "num_lines_deleted": "4",
    "nloc": "333"
  },
  {
    "file_change_id": "59766125992021",
    "hash": "a986a9335d591fa5c826157d1674d47aa525357",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -50,7 +50,7 @@ pub struct ReadTicket<T> {\n     data: Arc<UnsafeCell<T>>,\n }\n \n-unsafe impl<T> Send for ReadTicket<T> {}\n+unsafe impl<T: Send> Send for ReadTicket<T> {}\n \n #[cfg(not(feature = \"futures\"))]\n impl<T> ReadTicket<T> {\n@@ -112,7 +112,7 @@ pub struct WriteTicket<T> {\n     data: Arc<UnsafeCell<T>>,\n }\n \n-unsafe impl<T> Send for WriteTicket<T> {}\n+unsafe impl<T: Send> Send for WriteTicket<T> {}\n \n #[cfg(not(feature = \"futures\"))]\n impl<T> WriteTicket<T> {\n",
    "diff_parsed": "{'added': [(53, 'unsafe impl<T: Send> Send for ReadTicket<T> {}'), (115, 'unsafe impl<T: Send> Send for WriteTicket<T> {}')], 'deleted': [(53, 'unsafe impl<T> Send for ReadTicket<T> {}'), (115, 'unsafe impl<T> Send for WriteTicket<T> {}')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "139"
  },
  {
    "file_change_id": "158946158104955",
    "hash": "3bbb69d25b9ca995a4c25838781f89c62f2ca92",
    "old_path": "tremor-cli/src/run.rs",
    "new_path": "tremor-cli/src/run.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -40,7 +40,8 @@ struct Ingress {\n     codec: Box<dyn Codec>,\n }\n \n-type IngressHandler<T> = dyn Fn(&mut T, &mut u64, &mut Egress, u64, Value) -> Result<()>;\n+type IngressHandler<T> =\n+    dyn Fn(&mut T, &mut u64, &mut Egress, &mut Value<'static>, u64, Value) -> Result<()>;\n \n impl Ingress {\n     fn from_args(matches: &ArgMatches) -> Result<Self> {\n@@ -86,6 +87,7 @@ impl Ingress {\n         mut egress: &mut Egress,\n         handler: &IngressHandler<T>,\n     ) -> Result<()> {\n+        let mut state: Value<'static> = Value::null();\n         loop {\n             match self.buffer.read(&mut self.buf) {\n                 Ok(0) => {\n@@ -104,7 +106,6 @@ impl Ingress {\n                             Ok(None) => continue,\n                             Err(e) => return Err(e.into()),\n                         };\n-                        let event = event.clone();\n \n                         if self.is_interactive {\n                             eprintln!(\n@@ -114,7 +115,7 @@ impl Ingress {\n                             );\n                             highlight(self.is_pretty, &event)?;\n                         }\n-                        handler(runnable, &mut id, &mut egress, at, event)?;\n+                        handler(runnable, &mut id, &mut egress, &mut state, at, event)?;\n                     }\n                 }\n                 Err(e) => {\n@@ -245,15 +246,14 @@ fn run_tremor_source(matches: &ArgMatches, src: String) -> Result<()> {\n                 &mut script,\n                 id,\n                 &mut egress,\n-                &move |runnable, _id, egress, at, event| {\n+                &move |runnable, _id, egress, state, at, event| {\n                     let mut global_map = Value::object();\n-                    let mut state = Value::null();\n                     let mut event = event.clone_static();\n                     match runnable.run(\n                         &EventContext::new(at, None),\n                         AggrType::Tick,\n                         &mut event,\n-                        &mut state,\n+                        state,\n                         &mut global_map,\n                     ) {\n                         Ok(r) => egress.process(&src, &event, r),\n@@ -340,7 +340,7 @@ fn run_trickle_source(matches: &ArgMatches, src: String) -> Result<()> {\n         &mut pipeline,\n         id,\n         &mut egress,\n-        &move |runnable, id, egress, at, event| {\n+        &move |runnable, id, egress, _state, at, event| {\n             let value = EventPayload::new(vec![], |_| ValueAndMeta::from(event.clone_static()));\n \n             let mut continuation = vec![];\n",
    "diff_parsed": "{'added': [(43, 'type IngressHandler<T> ='), (44, \"    dyn Fn(&mut T, &mut u64, &mut Egress, &mut Value<'static>, u64, Value) -> Result<()>;\"), (90, \"        let mut state: Value<'static> = Value::null();\"), (118, '                        handler(runnable, &mut id, &mut egress, &mut state, at, event)?;'), (249, '                &move |runnable, _id, egress, state, at, event| {'), (256, '                        state,'), (343, '        &move |runnable, id, egress, _state, at, event| {')], 'deleted': [(43, 'type IngressHandler<T> = dyn Fn(&mut T, &mut u64, &mut Egress, u64, Value) -> Result<()>;'), (107, '                        let event = event.clone();'), (117, '                        handler(runnable, &mut id, &mut egress, at, event)?;'), (248, '                &move |runnable, _id, egress, at, event| {'), (250, '                    let mut state = Value::null();'), (256, '                        &mut state,'), (343, '        &move |runnable, id, egress, at, event| {')]}",
    "num_lines_added": "7",
    "num_lines_deleted": "7",
    "nloc": "367"
  },
  {
    "file_change_id": "127902549599046",
    "hash": "96ccccd55ddbff7f03a9d484f52d1080f40eae8",
    "old_path": "sha2/src/sha512/x86.rs",
    "new_path": "sha2/src/sha512/x86.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -106,8 +106,8 @@ unsafe fn load_data_avx2(\n \n     macro_rules! unrolled_iterations {\n         ($($i:literal),*) => {$(\n-            x[$i] = _mm256_insertf128_si256(x[$i], _mm_loadu_si128(data.add($i) as *const _), 1);\n-            x[$i] = _mm256_insertf128_si256(x[$i], _mm_loadu_si128(data.add($i + 1) as *const _), 0);\n+            x[$i] = _mm256_insertf128_si256(x[$i], _mm_loadu_si128(data.add(8 + $i) as *const _), 1);\n+            x[$i] = _mm256_insertf128_si256(x[$i], _mm_loadu_si128(data.add($i) as *const _), 0);\n \n             x[$i] = _mm256_shuffle_epi8(x[$i], MASK);\n \n",
    "diff_parsed": "{'added': [(109, '            x[$i] = _mm256_insertf128_si256(x[$i], _mm_loadu_si128(data.add(8 + $i) as *const _), 1);'), (110, '            x[$i] = _mm256_insertf128_si256(x[$i], _mm_loadu_si128(data.add($i) as *const _), 0);')], 'deleted': [(109, '            x[$i] = _mm256_insertf128_si256(x[$i], _mm_loadu_si128(data.add($i) as *const _), 1);'), (110, '            x[$i] = _mm256_insertf128_si256(x[$i], _mm_loadu_si128(data.add($i + 1) as *const _), 0);')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "268"
  },
  {
    "file_change_id": "63307996926572",
    "hash": "543687d6c85f39338a283d72614ea96a7fc8188",
    "old_path": "futures-task/src/waker.rs",
    "new_path": "futures-task/src/waker.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -18,7 +18,7 @@ pub(super) fn waker_vtable<W: ArcWake>() -> &'static RawWakerVTable {\n /// [`ArcWake.wake()`](ArcWake::wake) if awoken.\n pub fn waker<W>(wake: Arc<W>) -> Waker\n where\n-    W: ArcWake,\n+    W: ArcWake + 'static,\n {\n     let ptr = Arc::into_raw(wake) as *const ();\n \n",
    "diff_parsed": "{'added': [(21, \"    W: ArcWake + 'static,\")], 'deleted': [(21, '    W: ArcWake,')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "46"
  },
  {
    "file_change_id": "259742708188968",
    "hash": "cdc4276a7e3ec67185c2b66fcb7585ec8716de1",
    "old_path": "src/api.rs",
    "new_path": "src/api.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -291,7 +291,7 @@ pub trait RenderDocV110: RenderDocV100 {\n     ///\n     /// Data is saved to a capture log file at the location specified via\n     /// `set_log_file_path_template()`.\n-    fn trigger_multi_frame_capture(&self, num_frames: u32) {\n+    fn trigger_multi_frame_capture(&mut self, num_frames: u32) {\n         unsafe {\n             (self.entry_v110().TriggerMultiFrameCapture.unwrap())(num_frames);\n         }\n@@ -353,7 +353,7 @@ pub trait RenderDocV120: RenderDocV112 {\n     unsafe fn entry_v120(&self) -> &EntryV120;\n \n     #[allow(missing_docs)]\n-    fn set_capture_file_comments<'a, P, C>(&self, path: P, comments: C)\n+    fn set_capture_file_comments<'a, P, C>(&mut self, path: P, comments: C)\n     where\n         P: Into<Option<&'a str>>,\n         C: AsRef<str>,\n",
    "diff_parsed": "{'added': [(294, '    fn trigger_multi_frame_capture(&mut self, num_frames: u32) {'), (356, \"    fn set_capture_file_comments<'a, P, C>(&mut self, path: P, comments: C)\")], 'deleted': [(294, '    fn trigger_multi_frame_capture(&self, num_frames: u32) {'), (356, \"    fn set_capture_file_comments<'a, P, C>(&self, path: P, comments: C)\")]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "267"
  },
  {
    "file_change_id": "272755071335078",
    "hash": "85e98d1c9d5ba8af623120e8fee6c97a2c2aee0",
    "old_path": "src/untrusted.rs",
    "new_path": "src/untrusted.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -316,11 +316,11 @@ impl<'a> Reader<'a> {\n     pub fn skip_and_get_input(&mut self, num_bytes: usize)\n                               -> Result<Input<'a>, EndOfInput> {\n         let new_i = try!(self.i.checked_add(num_bytes).ok_or(EndOfInput));\n-        let ret = self.input.get_slice(self.i..new_i)\n-                            .map(|subslice| Input { value: subslice })\n-                            .ok_or(EndOfInput);\n+        let ret = try!(self.input.get_slice(self.i..new_i)\n+                                 .map(|subslice| Input { value: subslice })\n+                                 .ok_or(EndOfInput));\n         self.i = new_i;\n-        ret\n+        Ok(ret)\n     }\n \n     /// Skips the reader to the end of the input, returning the skipped input\n",
    "diff_parsed": "{'added': [(319, '        let ret = try!(self.input.get_slice(self.i..new_i)'), (320, '                                 .map(|subslice| Input { value: subslice })'), (321, '                                 .ok_or(EndOfInput));'), (323, '        Ok(ret)')], 'deleted': [(319, '        let ret = self.input.get_slice(self.i..new_i)'), (320, '                            .map(|subslice| Input { value: subslice })'), (321, '                            .ok_or(EndOfInput);'), (323, '        ret')]}",
    "num_lines_added": "4",
    "num_lines_deleted": "4",
    "nloc": "289"
  },
  {
    "file_change_id": "100236268304514",
    "hash": "93458d01fed0ec81c0e7b4e98e6f35961356fae",
    "old_path": "src/transport/smtp/client/mod.rs",
    "new_path": "src/transport/smtp/client/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -78,7 +78,15 @@ impl ClientCodec {\n                     match self.escape_count {\n                         0 => self.escape_count = if *byte == b'\\r' { 1 } else { 0 },\n                         1 => self.escape_count = if *byte == b'\\n' { 2 } else { 0 },\n-                        2 => self.escape_count = if *byte == b'.' { 3 } else { 0 },\n+                        2 => {\n+                            self.escape_count = if *byte == b'.' {\n+                                3\n+                            } else if *byte == b'\\r' {\n+                                1\n+                            } else {\n+                                0\n+                            }\n+                        }\n                         _ => unreachable!(),\n                     }\n                     if self.escape_count == 3 {\n@@ -111,6 +119,7 @@ mod test {\n         let mut buf: Vec<u8> = vec![];\n \n         codec.encode(b\"test\\r\\n\", &mut buf);\n+        codec.encode(b\"test\\r\\n\\r\\n\", &mut buf);\n         codec.encode(b\".\\r\\n\", &mut buf);\n         codec.encode(b\"\\r\\ntest\", &mut buf);\n         codec.encode(b\"te\\r\\n.\\r\\nst\", &mut buf);\n@@ -121,7 +130,7 @@ mod test {\n         codec.encode(b\"test\", &mut buf);\n         assert_eq!(\n             String::from_utf8(buf).unwrap(),\n-            \"test\\r\\n..\\r\\n\\r\\ntestte\\r\\n..\\r\\nsttesttest.test\\n.test\\ntest\"\n+            \"test\\r\\ntest\\r\\n\\r\\n..\\r\\n\\r\\ntestte\\r\\n..\\r\\nsttesttest.test\\n.test\\ntest\"\n         );\n     }\n \n",
    "diff_parsed": "{'added': [(81, '                        2 => {'), (82, \"                            self.escape_count = if *byte == b'.' {\"), (83, '                                3'), (84, \"                            } else if *byte == b'\\\\r' {\"), (85, '                                1'), (86, '                            } else {'), (87, '                                0'), (88, '                            }'), (89, '                        }'), (122, '        codec.encode(b\"test\\\\r\\\\n\\\\r\\\\n\", &mut buf);'), (133, '            \"test\\\\r\\\\ntest\\\\r\\\\n\\\\r\\\\n..\\\\r\\\\n\\\\r\\\\ntestte\\\\r\\\\n..\\\\r\\\\nsttesttest.test\\\\n.test\\\\ntest\"')], 'deleted': [(81, \"                        2 => self.escape_count = if *byte == b'.' { 3 } else { 0 },\"), (124, '            \"test\\\\r\\\\n..\\\\r\\\\n\\\\r\\\\ntestte\\\\r\\\\n..\\\\r\\\\nsttesttest.test\\\\n.test\\\\ntest\"')]}",
    "num_lines_added": "11",
    "num_lines_deleted": "2",
    "nloc": "106"
  },
  {
    "file_change_id": "259772580375172",
    "hash": "38d308785f84f7037e63c04c0de1cb20d1c8284",
    "old_path": "crossbeam-channel/src/flavors/list.rs",
    "new_path": "crossbeam-channel/src/flavors/list.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -2,7 +2,7 @@\n \n use std::cell::UnsafeCell;\n use std::marker::PhantomData;\n-use std::mem::{self, ManuallyDrop};\n+use std::mem::MaybeUninit;\n use std::ptr;\n use std::sync::atomic::{self, AtomicPtr, AtomicUsize, Ordering};\n use std::time::Instant;\n@@ -42,7 +42,7 @@ const MARK_BIT: usize = 1;\n /// A slot in a block.\n struct Slot<T> {\n     /// The message.\n-    msg: UnsafeCell<ManuallyDrop<T>>,\n+    msg: UnsafeCell<MaybeUninit<T>>,\n \n     /// The state of the slot.\n     state: AtomicUsize,\n@@ -72,7 +72,13 @@ struct Block<T> {\n impl<T> Block<T> {\n     /// Creates an empty block.\n     fn new() -> Block<T> {\n-        unsafe { mem::zeroed() }\n+        // SAFETY: This is safe because:\n+        //  [1] `Block::next` (AtomicPtr) may be safely zero initialized.\n+        //  [2] `Block::slots` (Array) may be safely zero initialized because of [3, 4].\n+        //  [3] `Slot::msg` (UnsafeCell) may be safely zero initialized because it\n+        //       holds a MaybeUninit.\n+        //  [4] `Slot::state` (AtomicUsize) may be safely zero initialized.\n+        unsafe { MaybeUninit::zeroed().assume_init() }\n     }\n \n     /// Waits until the next pointer is set.\n@@ -280,7 +286,7 @@ impl<T> Channel<T> {\n         let block = token.list.block as *mut Block<T>;\n         let offset = token.list.offset;\n         let slot = (*block).slots.get_unchecked(offset);\n-        slot.msg.get().write(ManuallyDrop::new(msg));\n+        slot.msg.get().write(MaybeUninit::new(msg));\n         slot.state.fetch_or(WRITE, Ordering::Release);\n \n         // Wake a sleeping receiver.\n@@ -385,8 +391,7 @@ impl<T> Channel<T> {\n         let offset = token.list.offset;\n         let slot = (*block).slots.get_unchecked(offset);\n         slot.wait_write();\n-        let m = slot.msg.get().read();\n-        let msg = ManuallyDrop::into_inner(m);\n+        let msg = slot.msg.get().read().assume_init();\n \n         // Destroy the block if we've reached the end, or if another thread wanted to destroy but\n         // couldn't because we were busy reading from the slot.\n@@ -572,7 +577,8 @@ impl<T> Drop for Channel<T> {\n                 if offset < BLOCK_CAP {\n                     // Drop the message in the slot.\n                     let slot = (*block).slots.get_unchecked(offset);\n-                    ManuallyDrop::drop(&mut *(*slot).msg.get());\n+                    let p = &mut *slot.msg.get();\n+                    ptr::drop_in_place(p.as_mut_ptr());\n                 } else {\n                     // Deallocate the block and move to the next one.\n                     let next = (*block).next.load(Ordering::Relaxed);\n",
    "diff_parsed": "{'added': [(5, 'use std::mem::MaybeUninit;'), (45, '    msg: UnsafeCell<MaybeUninit<T>>,'), (81, '        unsafe { MaybeUninit::zeroed().assume_init() }'), (289, '        slot.msg.get().write(MaybeUninit::new(msg));'), (394, '        let msg = slot.msg.get().read().assume_init();'), (580, '                    let p = &mut *slot.msg.get();'), (581, '                    ptr::drop_in_place(p.as_mut_ptr());')], 'deleted': [(5, 'use std::mem::{self, ManuallyDrop};'), (45, '    msg: UnsafeCell<ManuallyDrop<T>>,'), (75, '        unsafe { mem::zeroed() }'), (283, '        slot.msg.get().write(ManuallyDrop::new(msg));'), (388, '        let m = slot.msg.get().read();'), (389, '        let msg = ManuallyDrop::into_inner(m);'), (575, '                    ManuallyDrop::drop(&mut *(*slot).msg.get());')]}",
    "num_lines_added": "7",
    "num_lines_deleted": "7",
    "nloc": "447"
  },
  {
    "file_change_id": "139571592264440",
    "hash": "7b35a3d17f5c5ec53f70576d4ca0e18be8ed289",
    "old_path": "crossbeam-queue/src/seg_queue.rs",
    "new_path": "crossbeam-queue/src/seg_queue.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -2,7 +2,7 @@ use alloc::boxed::Box;\n use core::cell::UnsafeCell;\n use core::fmt;\n use core::marker::PhantomData;\n-use core::mem::{self, ManuallyDrop};\n+use core::mem::MaybeUninit;\n use core::ptr;\n use core::sync::atomic::{self, AtomicPtr, AtomicUsize, Ordering};\n \n@@ -30,7 +30,7 @@ const HAS_NEXT: usize = 1;\n /// A slot in a block.\n struct Slot<T> {\n     /// The value.\n-    value: UnsafeCell<ManuallyDrop<T>>,\n+    value: UnsafeCell<MaybeUninit<T>>,\n \n     /// The state of the slot.\n     state: AtomicUsize,\n@@ -60,7 +60,13 @@ struct Block<T> {\n impl<T> Block<T> {\n     /// Creates an empty block that starts at `start_index`.\n     fn new() -> Block<T> {\n-        unsafe { mem::zeroed() }\n+        // SAFETY: This is safe because:\n+        //  [1] `Block::next` (AtomicPtr) may be safely zero initialized.\n+        //  [2] `Block::slots` (Array) may be safely zero initialized because of [3, 4].\n+        //  [3] `Slot::value` (UnsafeCell) may be safely zero initialized because it\n+        //       holds a MaybeUninit.\n+        //  [4] `Slot::state` (AtomicUsize) may be safely zero initialized.\n+        unsafe { MaybeUninit::zeroed().assume_init() }\n     }\n \n     /// Waits until the next pointer is set.\n@@ -244,7 +250,7 @@ impl<T> SegQueue<T> {\n \n                     // Write the value into the slot.\n                     let slot = (*block).slots.get_unchecked(offset);\n-                    slot.value.get().write(ManuallyDrop::new(value));\n+                    slot.value.get().write(MaybeUninit::new(value));\n                     slot.state.fetch_or(WRITE, Ordering::Release);\n \n                     return;\n@@ -339,8 +345,7 @@ impl<T> SegQueue<T> {\n                     // Read the value.\n                     let slot = (*block).slots.get_unchecked(offset);\n                     slot.wait_write();\n-                    let m = slot.value.get().read();\n-                    let value = ManuallyDrop::into_inner(m);\n+                    let value = slot.value.get().read().assume_init();\n \n                     // Destroy the block if we've reached the end, or if another thread wanted to\n                     // destroy but couldn't because we were busy reading from the slot.\n@@ -451,7 +456,8 @@ impl<T> Drop for SegQueue<T> {\n                 if offset < BLOCK_CAP {\n                     // Drop the value in the slot.\n                     let slot = (*block).slots.get_unchecked(offset);\n-                    ManuallyDrop::drop(&mut *(*slot).value.get());\n+                    let p = &mut *slot.value.get();\n+                    ptr::drop_in_place(p.as_mut_ptr());\n                 } else {\n                     // Deallocate the block and move to the next one.\n                     let next = (*block).next.load(Ordering::Relaxed);\n",
    "diff_parsed": "{'added': [(5, 'use core::mem::MaybeUninit;'), (33, '    value: UnsafeCell<MaybeUninit<T>>,'), (69, '        unsafe { MaybeUninit::zeroed().assume_init() }'), (253, '                    slot.value.get().write(MaybeUninit::new(value));'), (348, '                    let value = slot.value.get().read().assume_init();'), (459, '                    let p = &mut *slot.value.get();'), (460, '                    ptr::drop_in_place(p.as_mut_ptr());')], 'deleted': [(5, 'use core::mem::{self, ManuallyDrop};'), (33, '    value: UnsafeCell<ManuallyDrop<T>>,'), (63, '        unsafe { mem::zeroed() }'), (247, '                    slot.value.get().write(ManuallyDrop::new(value));'), (342, '                    let m = slot.value.get().read();'), (343, '                    let value = ManuallyDrop::into_inner(m);'), (454, '                    ManuallyDrop::drop(&mut *(*slot).value.get());')]}",
    "num_lines_added": "7",
    "num_lines_deleted": "7",
    "nloc": "273"
  },
  {
    "file_change_id": "177245379304518",
    "hash": "68e8708c2dda24e4b3b1807f5f301ca2b8ffa35",
    "old_path": "crossbeam-deque/src/lib.rs",
    "new_path": "crossbeam-deque/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -97,7 +97,7 @@ use std::cmp;\n use std::fmt;\n use std::iter::FromIterator;\n use std::marker::PhantomData;\n-use std::mem::{self, ManuallyDrop};\n+use std::mem::{self, MaybeUninit};\n use std::ptr;\n use std::sync::atomic::{self, AtomicIsize, AtomicPtr, AtomicUsize, Ordering};\n use std::sync::Arc;\n@@ -1140,7 +1140,7 @@ const HAS_NEXT: usize = 1;\n /// A slot in a block.\n struct Slot<T> {\n     /// The task.\n-    task: UnsafeCell<ManuallyDrop<T>>,\n+    task: UnsafeCell<MaybeUninit<T>>,\n \n     /// The state of the slot.\n     state: AtomicUsize,\n@@ -1170,7 +1170,13 @@ struct Block<T> {\n impl<T> Block<T> {\n     /// Creates an empty block that starts at `start_index`.\n     fn new() -> Block<T> {\n-        unsafe { mem::zeroed() }\n+        // SAFETY: This is safe because:\n+        //  [1] `Block::next` (AtomicPtr) may be safely zero initialized.\n+        //  [2] `Block::slots` (Array) may be safely zero initialized because of [3, 4].\n+        //  [3] `Slot::task` (UnsafeCell) may be safely zero initialized because it\n+        //       holds a MaybeUninit.\n+        //  [4] `Slot::state` (AtomicUsize) may be safely zero initialized.\n+        unsafe { MaybeUninit::zeroed().assume_init() }\n     }\n \n     /// Waits until the next pointer is set.\n@@ -1329,7 +1335,7 @@ impl<T> Injector<T> {\n \n                     // Write the task into the slot.\n                     let slot = (*block).slots.get_unchecked(offset);\n-                    slot.task.get().write(ManuallyDrop::new(task));\n+                    slot.task.get().write(MaybeUninit::new(task));\n                     slot.state.fetch_or(WRITE, Ordering::Release);\n \n                     return;\n@@ -1422,8 +1428,7 @@ impl<T> Injector<T> {\n             // Read the task.\n             let slot = (*block).slots.get_unchecked(offset);\n             slot.wait_write();\n-            let m = slot.task.get().read();\n-            let task = ManuallyDrop::into_inner(m);\n+            let task = slot.task.get().read().assume_init();\n \n             // Destroy the block if we've reached the end, or if another thread wanted to destroy\n             // but couldn't because we were busy reading from the slot.\n@@ -1548,8 +1553,7 @@ impl<T> Injector<T> {\n                         // Read the task.\n                         let slot = (*block).slots.get_unchecked(offset + i);\n                         slot.wait_write();\n-                        let m = slot.task.get().read();\n-                        let task = ManuallyDrop::into_inner(m);\n+                        let task = slot.task.get().read().assume_init();\n \n                         // Write it into the destination queue.\n                         dest_buffer.write(dest_b.wrapping_add(i as isize), task);\n@@ -1561,8 +1565,7 @@ impl<T> Injector<T> {\n                         // Read the task.\n                         let slot = (*block).slots.get_unchecked(offset + i);\n                         slot.wait_write();\n-                        let m = slot.task.get().read();\n-                        let task = ManuallyDrop::into_inner(m);\n+                        let task = slot.task.get().read().assume_init();\n \n                         // Write it into the destination queue.\n                         dest_buffer.write(dest_b.wrapping_add((batch_size - 1 - i) as isize), task);\n@@ -1704,8 +1707,7 @@ impl<T> Injector<T> {\n             // Read the task.\n             let slot = (*block).slots.get_unchecked(offset);\n             slot.wait_write();\n-            let m = slot.task.get().read();\n-            let task = ManuallyDrop::into_inner(m);\n+            let task = slot.task.get().read().assume_init();\n \n             match dest.flavor {\n                 Flavor::Fifo => {\n@@ -1714,8 +1716,7 @@ impl<T> Injector<T> {\n                         // Read the task.\n                         let slot = (*block).slots.get_unchecked(offset + i + 1);\n                         slot.wait_write();\n-                        let m = slot.task.get().read();\n-                        let task = ManuallyDrop::into_inner(m);\n+                        let task = slot.task.get().read().assume_init();\n \n                         // Write it into the destination queue.\n                         dest_buffer.write(dest_b.wrapping_add(i as isize), task);\n@@ -1728,8 +1729,7 @@ impl<T> Injector<T> {\n                         // Read the task.\n                         let slot = (*block).slots.get_unchecked(offset + i + 1);\n                         slot.wait_write();\n-                        let m = slot.task.get().read();\n-                        let task = ManuallyDrop::into_inner(m);\n+                        let task = slot.task.get().read().assume_init();\n \n                         // Write it into the destination queue.\n                         dest_buffer.write(dest_b.wrapping_add((batch_size - 1 - i) as isize), task);\n@@ -1804,7 +1804,8 @@ impl<T> Drop for Injector<T> {\n                 if offset < BLOCK_CAP {\n                     // Drop the task in the slot.\n                     let slot = (*block).slots.get_unchecked(offset);\n-                    ManuallyDrop::drop(&mut *(*slot).task.get());\n+                    let p = &mut *slot.task.get();\n+                    ptr::drop_in_place(p.as_mut_ptr());\n                 } else {\n                     // Deallocate the block and move to the next one.\n                     let next = (*block).next.load(Ordering::Relaxed);\n",
    "diff_parsed": "{'added': [(100, 'use std::mem::{self, MaybeUninit};'), (1143, '    task: UnsafeCell<MaybeUninit<T>>,'), (1179, '        unsafe { MaybeUninit::zeroed().assume_init() }'), (1338, '                    slot.task.get().write(MaybeUninit::new(task));'), (1431, '            let task = slot.task.get().read().assume_init();'), (1556, '                        let task = slot.task.get().read().assume_init();'), (1568, '                        let task = slot.task.get().read().assume_init();'), (1710, '            let task = slot.task.get().read().assume_init();'), (1719, '                        let task = slot.task.get().read().assume_init();'), (1732, '                        let task = slot.task.get().read().assume_init();'), (1807, '                    let p = &mut *slot.task.get();'), (1808, '                    ptr::drop_in_place(p.as_mut_ptr());')], 'deleted': [(100, 'use std::mem::{self, ManuallyDrop};'), (1143, '    task: UnsafeCell<ManuallyDrop<T>>,'), (1173, '        unsafe { mem::zeroed() }'), (1332, '                    slot.task.get().write(ManuallyDrop::new(task));'), (1425, '            let m = slot.task.get().read();'), (1426, '            let task = ManuallyDrop::into_inner(m);'), (1551, '                        let m = slot.task.get().read();'), (1552, '                        let task = ManuallyDrop::into_inner(m);'), (1564, '                        let m = slot.task.get().read();'), (1565, '                        let task = ManuallyDrop::into_inner(m);'), (1707, '            let m = slot.task.get().read();'), (1708, '            let task = ManuallyDrop::into_inner(m);'), (1717, '                        let m = slot.task.get().read();'), (1718, '                        let task = ManuallyDrop::into_inner(m);'), (1731, '                        let m = slot.task.get().read();'), (1732, '                        let task = ManuallyDrop::into_inner(m);'), (1807, '                    ManuallyDrop::drop(&mut *(*slot).task.get());')]}",
    "num_lines_added": "12",
    "num_lines_deleted": "17",
    "nloc": "997"
  },
  {
    "file_change_id": "84023723202769",
    "hash": "e0fd465b9b7de8b60b0b588e264aca1fa92fbd1",
    "old_path": "crossbeam-epoch/src/deferred.rs",
    "new_path": "crossbeam-epoch/src/deferred.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,7 +1,7 @@\n use alloc::boxed::Box;\n use core::fmt;\n use core::marker::PhantomData;\n-use core::mem;\n+use core::mem::{self, MaybeUninit};\n use core::ptr;\n \n /// Number of words a piece of `Data` can hold.\n@@ -36,11 +36,8 @@ impl Deferred {\n \n         unsafe {\n             if size <= mem::size_of::<Data>() && align <= mem::align_of::<Data>() {\n-                // TODO(taiki-e): when the minimum supported Rust version is bumped to 1.36+,\n-                // replace this with `mem::MaybeUninit`.\n-                #[allow(deprecated)]\n-                let mut data: Data = mem::uninitialized();\n-                ptr::write(&mut data as *mut Data as *mut F, f);\n+                let mut data = MaybeUninit::<Data>::uninit();\n+                ptr::write(data.as_mut_ptr() as *mut F, f);\n \n                 unsafe fn call<F: FnOnce()>(raw: *mut u8) {\n                     let f: F = ptr::read(raw as *mut F);\n@@ -49,16 +46,13 @@ impl Deferred {\n \n                 Deferred {\n                     call: call::<F>,\n-                    data,\n+                    data: data.assume_init(),\n                     _marker: PhantomData,\n                 }\n             } else {\n                 let b: Box<F> = Box::new(f);\n-                // TODO(taiki-e): when the minimum supported Rust version is bumped to 1.36+,\n-                // replace this with `mem::MaybeUninit`.\n-                #[allow(deprecated)]\n-                let mut data: Data = mem::uninitialized();\n-                ptr::write(&mut data as *mut Data as *mut Box<F>, b);\n+                let mut data = MaybeUninit::<Data>::uninit();\n+                ptr::write(data.as_mut_ptr() as *mut Box<F>, b);\n \n                 unsafe fn call<F: FnOnce()>(raw: *mut u8) {\n                     let b: Box<F> = ptr::read(raw as *mut Box<F>);\n@@ -67,7 +61,7 @@ impl Deferred {\n \n                 Deferred {\n                     call: call::<F>,\n-                    data,\n+                    data: data.assume_init(),\n                     _marker: PhantomData,\n                 }\n             }\n",
    "diff_parsed": "{'added': [(4, 'use core::mem::{self, MaybeUninit};'), (39, '                let mut data = MaybeUninit::<Data>::uninit();'), (40, '                ptr::write(data.as_mut_ptr() as *mut F, f);'), (49, '                    data: data.assume_init(),'), (54, '                let mut data = MaybeUninit::<Data>::uninit();'), (55, '                ptr::write(data.as_mut_ptr() as *mut Box<F>, b);'), (64, '                    data: data.assume_init(),')], 'deleted': [(4, 'use core::mem;'), (41, '                #[allow(deprecated)]'), (42, '                let mut data: Data = mem::uninitialized();'), (43, '                ptr::write(&mut data as *mut Data as *mut F, f);'), (52, '                    data,'), (59, '                #[allow(deprecated)]'), (60, '                let mut data: Data = mem::uninitialized();'), (61, '                ptr::write(&mut data as *mut Data as *mut Box<F>, b);'), (70, '                    data,')]}",
    "num_lines_added": "7",
    "num_lines_deleted": "9",
    "nloc": "103"
  },
  {
    "file_change_id": "239461305213347",
    "hash": "f48c1c763a73467e2fde6158c0abc2faa162ae8",
    "old_path": "crossbeam-epoch/src/sync/queue.rs",
    "new_path": "crossbeam-epoch/src/sync/queue.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -8,8 +8,7 @@\n //! Simon Doherty, Lindsay Groves, Victor Luchangco, and Mark Moir. 2004b. Formal Verification of a\n //! Practical Lock-Free Queue Algorithm. https://doi.org/10.1007/978-3-540-30232-2_7\n \n-use core::mem::{self, ManuallyDrop};\n-use core::ptr;\n+use core::mem::MaybeUninit;\n use core::sync::atomic::Ordering::{Acquire, Relaxed, Release};\n \n use crossbeam_utils::CachePadded;\n@@ -29,11 +28,11 @@ pub struct Queue<T> {\n struct Node<T> {\n     /// The slot in which a value of type `T` can be stored.\n     ///\n-    /// The type of `data` is `ManuallyDrop<T>` because a `Node<T>` doesn't always contain a `T`.\n+    /// The type of `data` is `MaybeUninit<T>` because a `Node<T>` doesn't always contain a `T`.\n     /// For example, the sentinel node in a queue never contains a value: its slot is always empty.\n     /// Other nodes start their life with a push operation and contain a value until it gets popped\n     /// out. After that such empty nodes get added to the collector for destruction.\n-    data: ManuallyDrop<T>,\n+    data: MaybeUninit<T>,\n \n     next: Atomic<Node<T>>,\n }\n@@ -49,11 +48,8 @@ impl<T> Queue<T> {\n             head: CachePadded::new(Atomic::null()),\n             tail: CachePadded::new(Atomic::null()),\n         };\n-        // TODO(taiki-e): when the minimum supported Rust version is bumped to 1.36+,\n-        // replace this with `mem::MaybeUninit`.\n-        #[allow(deprecated)]\n         let sentinel = Owned::new(Node {\n-            data: unsafe { mem::uninitialized() },\n+            data: MaybeUninit::uninit(),\n             next: Atomic::null(),\n         });\n         unsafe {\n@@ -93,7 +89,7 @@ impl<T> Queue<T> {\n     /// Adds `t` to the back of the queue, possibly waking up threads blocked on `pop`.\n     pub fn push(&self, t: T, guard: &Guard) {\n         let new = Owned::new(Node {\n-            data: ManuallyDrop::new(t),\n+            data: MaybeUninit::new(t),\n             next: Atomic::null(),\n         });\n         let new = Owned::into_shared(new, guard);\n@@ -126,7 +122,8 @@ impl<T> Queue<T> {\n                             let _ = self.tail.compare_and_set(tail, next, Release, guard);\n                         }\n                         guard.defer_destroy(head);\n-                        Some(ManuallyDrop::into_inner(ptr::read(&n.data)))\n+                        // TODO: Replace with MaybeUninit::read when api is stable\n+                        Some(n.data.as_ptr().read())\n                     })\n                     .map_err(|_| ())\n             },\n@@ -145,22 +142,25 @@ impl<T> Queue<T> {\n         let head = self.head.load(Acquire, guard);\n         let h = unsafe { head.deref() };\n         let next = h.next.load(Acquire, guard);\n-        match unsafe { next.as_ref() } {\n-            Some(n) if condition(&n.data) => unsafe {\n-                self.head\n-                    .compare_and_set(head, next, Release, guard)\n-                    .map(|_| {\n-                        let tail = self.tail.load(Relaxed, guard);\n-                        // Advance the tail so that we don't retire a pointer to a reachable node.\n-                        if head == tail {\n-                            let _ = self.tail.compare_and_set(tail, next, Release, guard);\n-                        }\n-                        guard.defer_destroy(head);\n-                        Some(ManuallyDrop::into_inner(ptr::read(&n.data)))\n-                    })\n-                    .map_err(|_| ())\n-            },\n-            None | Some(_) => Ok(None),\n+        unsafe {\n+            match next.as_ref() {\n+                Some(n) if condition(&*n.data.as_ptr()) => {\n+                    self.head\n+                        .compare_and_set(head, next, Release, guard)\n+                        .map(|_| {\n+                            let tail = self.tail.load(Relaxed, guard);\n+                            // Advance the tail so that we don't retire a pointer to a reachable node.\n+                            if head == tail {\n+                                let _ = self.tail.compare_and_set(tail, next, Release, guard);\n+                            }\n+                            guard.defer_destroy(head);\n+                            // TODO: Replace with MaybeUninit::read when api is stable\n+                            Some(n.data.as_ptr().read())\n+                        })\n+                        .map_err(|_| ())\n+                }\n+                None | Some(_) => Ok(None),\n+            }\n         }\n     }\n \n",
    "diff_parsed": "{'added': [(11, 'use core::mem::MaybeUninit;'), (35, '    data: MaybeUninit<T>,'), (52, '            data: MaybeUninit::uninit(),'), (92, '            data: MaybeUninit::new(t),'), (126, '                        Some(n.data.as_ptr().read())'), (145, '        unsafe {'), (146, '            match next.as_ref() {'), (147, '                Some(n) if condition(&*n.data.as_ptr()) => {'), (148, '                    self.head'), (149, '                        .compare_and_set(head, next, Release, guard)'), (150, '                        .map(|_| {'), (151, '                            let tail = self.tail.load(Relaxed, guard);'), (153, '                            if head == tail {'), (154, '                                let _ = self.tail.compare_and_set(tail, next, Release, guard);'), (155, '                            }'), (156, '                            guard.defer_destroy(head);'), (158, '                            Some(n.data.as_ptr().read())'), (159, '                        })'), (160, '                        .map_err(|_| ())'), (161, '                }'), (162, '                None | Some(_) => Ok(None),'), (163, '            }')], 'deleted': [(11, 'use core::mem::{self, ManuallyDrop};'), (12, 'use core::ptr;'), (36, '    data: ManuallyDrop<T>,'), (54, '        #[allow(deprecated)]'), (56, '            data: unsafe { mem::uninitialized() },'), (96, '            data: ManuallyDrop::new(t),'), (129, '                        Some(ManuallyDrop::into_inner(ptr::read(&n.data)))'), (148, '        match unsafe { next.as_ref() } {'), (149, '            Some(n) if condition(&n.data) => unsafe {'), (150, '                self.head'), (151, '                    .compare_and_set(head, next, Release, guard)'), (152, '                    .map(|_| {'), (153, '                        let tail = self.tail.load(Relaxed, guard);'), (155, '                        if head == tail {'), (156, '                            let _ = self.tail.compare_and_set(tail, next, Release, guard);'), (157, '                        }'), (158, '                        guard.defer_destroy(head);'), (159, '                        Some(ManuallyDrop::into_inner(ptr::read(&n.data)))'), (160, '                    })'), (161, '                    .map_err(|_| ())'), (162, '            },'), (163, '            None | Some(_) => Ok(None),')]}",
    "num_lines_added": "22",
    "num_lines_deleted": "22",
    "nloc": "363"
  },
  {
    "file_change_id": "137558877138477",
    "hash": "6f3a3c17ea89fe16f55246cdfb64d684a52a529",
    "old_path": "crossbeam-queue/src/array_queue.rs",
    "new_path": "crossbeam-queue/src/array_queue.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -12,7 +12,7 @@ use alloc::vec::Vec;\n use core::cell::UnsafeCell;\n use core::fmt;\n use core::marker::PhantomData;\n-use core::mem;\n+use core::mem::{self, MaybeUninit};\n use core::ptr;\n use core::sync::atomic::{self, AtomicUsize, Ordering};\n \n@@ -29,7 +29,7 @@ struct Slot<T> {\n     stamp: AtomicUsize,\n \n     /// The value in this slot.\n-    value: UnsafeCell<T>,\n+    value: UnsafeCell<MaybeUninit<T>>,\n }\n \n /// A bounded multi-producer multi-consumer queue.\n@@ -186,9 +186,7 @@ impl<T> ArrayQueue<T> {\n                 ) {\n                     Ok(_) => {\n                         // Write the value into the slot and update the stamp.\n-                        unsafe {\n-                            slot.value.get().write(value);\n-                        }\n+                        unsafe { slot.value.get().write(MaybeUninit::new(value)) }\n                         slot.stamp.store(tail + 1, Ordering::Release);\n                         return Ok(());\n                     }\n@@ -266,7 +264,7 @@ impl<T> ArrayQueue<T> {\n                 ) {\n                     Ok(_) => {\n                         // Read the value from the slot and update the stamp.\n-                        let msg = unsafe { slot.value.get().read() };\n+                        let msg = unsafe { slot.value.get().read().assume_init() };\n                         slot.stamp\n                             .store(head.wrapping_add(self.one_lap), Ordering::Release);\n                         return Ok(msg);\n",
    "diff_parsed": "{'added': [(15, 'use core::mem::{self, MaybeUninit};'), (32, '    value: UnsafeCell<MaybeUninit<T>>,'), (189, '                        unsafe { slot.value.get().write(MaybeUninit::new(value)) }'), (267, '                        let msg = unsafe { slot.value.get().read().assume_init() };')], 'deleted': [(15, 'use core::mem;'), (32, '    value: UnsafeCell<T>,'), (189, '                        unsafe {'), (190, '                            slot.value.get().write(value);'), (191, '                        }'), (269, '                        let msg = unsafe { slot.value.get().read() };')]}",
    "num_lines_added": "4",
    "num_lines_deleted": "6",
    "nloc": "195"
  },
  {
    "file_change_id": "182780424865075",
    "hash": "71d2799afe690ef9d07bb77614c6bb164cb8e67",
    "old_path": "crossbeam-channel/src/flavors/array.rs",
    "new_path": "crossbeam-channel/src/flavors/array.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -15,7 +15,7 @@\n \n use std::cell::UnsafeCell;\n use std::marker::PhantomData;\n-use std::mem;\n+use std::mem::{self, MaybeUninit};\n use std::ptr;\n use std::sync::atomic::{self, AtomicUsize, Ordering};\n use std::time::Instant;\n@@ -33,7 +33,7 @@ struct Slot<T> {\n     stamp: AtomicUsize,\n \n     /// The message in this slot.\n-    msg: UnsafeCell<T>,\n+    msg: UnsafeCell<MaybeUninit<T>>,\n }\n \n /// The token type for the array flavor.\n@@ -233,7 +233,7 @@ impl<T> Channel<T> {\n         let slot: &Slot<T> = &*(token.array.slot as *const Slot<T>);\n \n         // Write the message into the slot and update the stamp.\n-        slot.msg.get().write(msg);\n+        slot.msg.get().write(MaybeUninit::new(msg));\n         slot.stamp.store(token.array.stamp, Ordering::Release);\n \n         // Wake a sleeping receiver.\n@@ -323,7 +323,7 @@ impl<T> Channel<T> {\n         let slot: &Slot<T> = &*(token.array.slot as *const Slot<T>);\n \n         // Read the message from the slot and update the stamp.\n-        let msg = slot.msg.get().read();\n+        let msg = slot.msg.get().read().assume_init();\n         slot.stamp.store(token.array.stamp, Ordering::Release);\n \n         // Wake a sleeping sender.\n",
    "diff_parsed": "{'added': [(18, 'use std::mem::{self, MaybeUninit};'), (36, '    msg: UnsafeCell<MaybeUninit<T>>,'), (236, '        slot.msg.get().write(MaybeUninit::new(msg));'), (326, '        let msg = slot.msg.get().read().assume_init();')], 'deleted': [(18, 'use std::mem;'), (36, '    msg: UnsafeCell<T>,'), (236, '        slot.msg.get().write(msg);'), (326, '        let msg = slot.msg.get().read();')]}",
    "num_lines_added": "4",
    "num_lines_deleted": "4",
    "nloc": "410"
  },
  {
    "file_change_id": "259485550739693",
    "hash": "d78de60ea78c3aa0eeca66f42dda0154a7cc89fc",
    "old_path": "crossbeam-queue/src/array_queue.rs",
    "new_path": "crossbeam-queue/src/array_queue.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -413,7 +413,17 @@ impl<T> Drop for ArrayQueue<T> {\n             };\n \n             unsafe {\n-                self.buffer.add(index).drop_in_place();\n+                let ptr = self.buffer.add(index);\n+                {\n+                    // This requires an extra scope because when we drop the Slot,\n+                    // reference to it should not exist.\n+                    let slot = &mut *ptr;\n+                    let value = &mut *slot.value.get();\n+                    // Drop the message (MaybeUninit<T>).\n+                    value.as_mut_ptr().drop_in_place();\n+                }\n+                // Drop slot (This should be a no-op).\n+                ptr.drop_in_place();\n             }\n         }\n \n",
    "diff_parsed": "{'added': [(416, '                let ptr = self.buffer.add(index);'), (417, '                {'), (420, '                    let slot = &mut *ptr;'), (421, '                    let value = &mut *slot.value.get();'), (423, '                    value.as_mut_ptr().drop_in_place();'), (424, '                }'), (426, '                ptr.drop_in_place();')], 'deleted': [(416, '                self.buffer.add(index).drop_in_place();')]}",
    "num_lines_added": "7",
    "num_lines_deleted": "1",
    "nloc": "201"
  },
  {
    "file_change_id": "253125448388907",
    "hash": "dce3e118f2778423113e6d6019dd05d88cf7e0e6",
    "old_path": "crossbeam-channel/src/flavors/array.rs",
    "new_path": "crossbeam-channel/src/flavors/array.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -542,7 +542,17 @@ impl<T> Drop for Channel<T> {\n             };\n \n             unsafe {\n-                self.buffer.add(index).drop_in_place();\n+                let ptr = self.buffer.add(index);\n+                {\n+                    // This requires an extra scope because when we drop the Slot,\n+                    // reference to it should not exist.\n+                    let slot = &mut *ptr;\n+                    let msg = &mut *slot.msg.get();\n+                    // Drop the message (MaybeUninit<T>).\n+                    msg.as_mut_ptr().drop_in_place();\n+                }\n+                // Drop slot (This should be a no-op).\n+                ptr.drop_in_place();\n             }\n         }\n \n",
    "diff_parsed": "{'added': [(545, '                let ptr = self.buffer.add(index);'), (546, '                {'), (549, '                    let slot = &mut *ptr;'), (550, '                    let msg = &mut *slot.msg.get();'), (552, '                    msg.as_mut_ptr().drop_in_place();'), (553, '                }'), (555, '                ptr.drop_in_place();')], 'deleted': [(545, '                self.buffer.add(index).drop_in_place();')]}",
    "num_lines_added": "7",
    "num_lines_deleted": "1",
    "nloc": "416"
  },
  {
    "file_change_id": "234010389358531",
    "hash": "65d17446c4242da0f9e1ae84b9dbce5108a822f",
    "old_path": "src/hdr/decoder.rs",
    "new_path": "src/hdr/decoder.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -330,57 +330,48 @@ impl<R: BufRead> HDRDecoder<R> {\n     pub fn read_image_transform<T: Send, F: Send + Sync + Fn(RGBE8Pixel) -> T>(\n         mut self,\n         f: F,\n-    ) -> ImageResult<Vec<T>> {\n+        output_slice: &mut [T],\n+    ) -> ImageResult<()> {\n+        assert_eq!(output_slice.len(), self.width as usize * self.height as usize);\n+\n         // Don't read anything if image is empty\n         if self.width == 0 || self.height == 0 {\n-            return Ok(vec![]);\n+            return Ok(());\n         }\n-        // expression self.width > 0 && self.height > 0 is true from now to the end of this method\n-        // scanline buffer\n-        let uszwidth = self.width as usize;\n \n-        let pixel_count = self.width as usize * self.height as usize;\n-        let mut ret = Vec::with_capacity(pixel_count);\n-        unsafe {\n-            // RGBE8Pixel doesn't implement Drop, so it's Ok to drop half-initialized ret\n-            ret.set_len(pixel_count);\n-        } // ret contains uninitialized data, so now it's my responsibility to return fully initialized ret\n-\n-        {\n-            let chunks_iter = ret.chunks_mut(uszwidth);\n-            let mut pool = Pool::new(8); //\n-\n-            try!(pool.scoped(|scope| {\n-                for chunk in chunks_iter {\n-                    let mut buf = Vec::<RGBE8Pixel>::with_capacity(uszwidth);\n-                    unsafe {\n-                        buf.set_len(uszwidth);\n+        let chunks_iter = output_slice.chunks_mut(self.width as usize);\n+        let mut pool = Pool::new(8); //\n+\n+        try!(pool.scoped(|scope| {\n+            for chunk in chunks_iter {\n+                let mut buf = vec![Default::default(); self.width as usize];\n+                try!(read_scanline(&mut self.r, &mut buf[..]));\n+                let f = &f;\n+                scope.execute(move || {\n+                    for (dst, &pix) in chunk.iter_mut().zip(buf.iter()) {\n+                        *dst = f(pix);\n                     }\n-                    try!(read_scanline(&mut self.r, &mut buf[..]));\n-                    let f = &f;\n-                    scope.execute(move || {\n-                        for (dst, &pix) in chunk.iter_mut().zip(buf.iter()) {\n-                            *dst = f(pix);\n-                        }\n-                    });\n-                }\n-                Ok(())\n-            }) as Result<(), ImageError>);\n-        }\n-\n-        Ok(ret)\n+                });\n+            }\n+            Ok(())\n+        }) as Result<(), ImageError>);\n+        Ok(())\n     }\n \n     /// Consumes decoder and returns a vector of Rgb<u8> pixels.\n     /// scale = 1, gamma = 2.2\n     pub fn read_image_ldr(self) -> ImageResult<Vec<Rgb<u8>>> {\n-        self.read_image_transform(|pix| pix.to_ldr())\n+        let mut ret = vec![Rgb([0,0,0]); self.width as usize * self.height as usize];\n+        self.read_image_transform(|pix| pix.to_ldr(), &mut ret[..])?;\n+        Ok(ret)\n     }\n \n     /// Consumes decoder and returns a vector of Rgb<f32> pixels.\n     ///\n     pub fn read_image_hdr(self) -> ImageResult<Vec<Rgb<f32>>> {\n-        self.read_image_transform(|pix| pix.to_hdr())\n+        let mut ret = vec![Rgb([0.0, 0.0, 0.0]); self.width as usize * self.height as usize];\n+        self.read_image_transform(|pix| pix.to_hdr(), &mut ret[..])?;\n+        Ok(ret)\n     }\n }\n \n",
    "diff_parsed": "{'added': [(333, '        output_slice: &mut [T],'), (334, '    ) -> ImageResult<()> {'), (335, '        assert_eq!(output_slice.len(), self.width as usize * self.height as usize);'), (339, '            return Ok(());'), (342, '        let chunks_iter = output_slice.chunks_mut(self.width as usize);'), (343, '        let mut pool = Pool::new(8); //'), (345, '        try!(pool.scoped(|scope| {'), (346, '            for chunk in chunks_iter {'), (347, '                let mut buf = vec![Default::default(); self.width as usize];'), (348, '                try!(read_scanline(&mut self.r, &mut buf[..]));'), (349, '                let f = &f;'), (350, '                scope.execute(move || {'), (351, '                    for (dst, &pix) in chunk.iter_mut().zip(buf.iter()) {'), (352, '                        *dst = f(pix);'), (354, '                });'), (355, '            }'), (356, '            Ok(())'), (357, '        }) as Result<(), ImageError>);'), (358, '        Ok(())'), (364, '        let mut ret = vec![Rgb([0,0,0]); self.width as usize * self.height as usize];'), (365, '        self.read_image_transform(|pix| pix.to_ldr(), &mut ret[..])?;'), (366, '        Ok(ret)'), (372, '        let mut ret = vec![Rgb([0.0, 0.0, 0.0]); self.width as usize * self.height as usize];'), (373, '        self.read_image_transform(|pix| pix.to_hdr(), &mut ret[..])?;'), (374, '        Ok(ret)')], 'deleted': [(333, '    ) -> ImageResult<Vec<T>> {'), (336, '            return Ok(vec![]);'), (340, '        let uszwidth = self.width as usize;'), (342, '        let pixel_count = self.width as usize * self.height as usize;'), (343, '        let mut ret = Vec::with_capacity(pixel_count);'), (344, '        unsafe {'), (346, '            ret.set_len(pixel_count);'), (347, \"        } // ret contains uninitialized data, so now it's my responsibility to return fully initialized ret\"), (349, '        {'), (350, '            let chunks_iter = ret.chunks_mut(uszwidth);'), (351, '            let mut pool = Pool::new(8); //'), (353, '            try!(pool.scoped(|scope| {'), (354, '                for chunk in chunks_iter {'), (355, '                    let mut buf = Vec::<RGBE8Pixel>::with_capacity(uszwidth);'), (356, '                    unsafe {'), (357, '                        buf.set_len(uszwidth);'), (359, '                    try!(read_scanline(&mut self.r, &mut buf[..]));'), (360, '                    let f = &f;'), (361, '                    scope.execute(move || {'), (362, '                        for (dst, &pix) in chunk.iter_mut().zip(buf.iter()) {'), (363, '                            *dst = f(pix);'), (364, '                        }'), (365, '                    });'), (366, '                }'), (367, '                Ok(())'), (368, '            }) as Result<(), ImageError>);'), (369, '        }'), (371, '        Ok(ret)'), (377, '        self.read_image_transform(|pix| pix.to_ldr())'), (383, '        self.read_image_transform(|pix| pix.to_hdr())')]}",
    "num_lines_added": "25",
    "num_lines_deleted": "30",
    "nloc": "737"
  },
  {
    "file_change_id": "273167565290950",
    "hash": "6c7bf22907a75d1bbaed52e4f7dd9716f5e6f73",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -143,7 +143,8 @@ pub fn clean_text(src: &str) -> String {\n             ' ' => \"&#32;\",\n             '\\t' => \"&#9;\",\n             '\\n' => \"&#10;\",\n-            '\\r' => \"&#12;\",\n+            '\\x0c' => \"&#12;\",\n+            '\\r' => \"&#13;\",\n             // a spec-compliant browser will perform this replacement anyway, but the middleware might not\n             '\\0' => \"&#65533;\",\n             // ALL OTHER CHARACTERS ARE PASSED THROUGH VERBATIM\n@@ -3436,6 +3437,14 @@ mod test {\n         );\n     }\n \n+    #[test]\n+    fn clean_text_spaces_test() {\n+        assert_eq!(\n+            clean_text(\"\\x09\\x0a\\x0c\\x20\"),\n+            \"&#9;&#10;&#12;&#32;\"\n+        );\n+    }\n+\n     #[test]\n     fn ns_svg() {\n         // https://github.com/cure53/DOMPurify/pull/495\n",
    "diff_parsed": "{'added': [(146, '            \\'\\\\x0c\\' => \"&#12;\",'), (147, '            \\'\\\\r\\' => \"&#13;\",'), (3440, '    #[test]'), (3441, '    fn clean_text_spaces_test() {'), (3442, '        assert_eq!('), (3443, '            clean_text(\"\\\\x09\\\\x0a\\\\x0c\\\\x20\"),'), (3444, '            \"&#9;&#10;&#12;&#32;\"'), (3445, '        );'), (3446, '    }')], 'deleted': [(146, '            \\'\\\\r\\' => \"&#12;\",')]}",
    "num_lines_added": "9",
    "num_lines_deleted": "1",
    "nloc": "2648"
  },
  {
    "file_change_id": "108450201109879",
    "hash": "4218155363f893032362d083a0e7fe5c5b0865c",
    "old_path": "tower-http/src/services/fs/serve_dir.rs",
    "new_path": "tower-http/src/services/fs/serve_dir.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -137,7 +137,7 @@ fn build_and_validate_path(base_path: &Path, requested_path: &str) -> Option<Pat\n \n     let mut full_path = base_path.to_path_buf();\n     for seg in path_decoded.split('/') {\n-        if seg.starts_with(\"..\") || seg.contains('\\\\') {\n+        if seg.starts_with(\"..\") || seg.contains('\\\\') || seg.contains(':') {\n             return None;\n         }\n         full_path.push(seg);\n",
    "diff_parsed": "{'added': [(140, '        if seg.starts_with(\"..\") || seg.contains(\\'\\\\\\\\\\') || seg.contains(\\':\\') {')], 'deleted': [(140, '        if seg.starts_with(\"..\") || seg.contains(\\'\\\\\\\\\\') {')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "874"
  },
  {
    "file_change_id": "33814480829671",
    "hash": "4ee8515f969d55768d875ea0b32491037a52fa1",
    "old_path": "tower-http/src/services/fs/serve_dir.rs",
    "new_path": "tower-http/src/services/fs/serve_dir.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -130,19 +130,26 @@ impl ServeVariant {\n }\n \n fn build_and_validate_path(base_path: &Path, requested_path: &str) -> Option<PathBuf> {\n-    // build and validate the path\n     let path = requested_path.trim_start_matches('/');\n \n     let path_decoded = percent_decode(path.as_ref()).decode_utf8().ok()?;\n+    let path_decoded = Path::new(&*path_decoded);\n \n     let mut full_path = base_path.to_path_buf();\n-    for seg in path_decoded.split('/') {\n-        if seg.starts_with(\"..\") || seg.contains('\\\\') || seg.contains(':') {\n-            return None;\n+    for component in path_decoded.components() {\n+        match component {\n+            std::path::Component::Normal(comp) => full_path.push(comp),\n+            std::path::Component::CurDir => {}\n+            std::path::Component::Prefix(_)\n+            | std::path::Component::RootDir\n+            | std::path::Component::ParentDir => return None,\n         }\n-        full_path.push(seg);\n     }\n-    Some(full_path)\n+    if full_path.is_relative() {\n+        Some(full_path)\n+    } else {\n+        None\n+    }\n }\n \n impl ServeDir {\n@@ -984,15 +991,10 @@ mod tests {\n \n     #[tokio::test]\n     async fn access_cjk_percent_encoded_uri_path() {\n-        let cjk_filename = \"\u4f60\u597d\u4e16\u754c.txt\";\n         // percent encoding present of \u4f60\u597d\u4e16\u754c.txt\n         let cjk_filename_encoded = \"%E4%BD%A0%E5%A5%BD%E4%B8%96%E7%95%8C.txt\";\n \n-        let tmp_dir = std::env::temp_dir();\n-        let tmp_filename = std::path::Path::new(tmp_dir.as_path()).join(cjk_filename);\n-        let _ = tokio::fs::File::create(&tmp_filename).await.unwrap();\n-\n-        let svc = ServeDir::new(&tmp_dir);\n+        let svc = ServeDir::new(\"../test-files\");\n \n         let req = Request::builder()\n             .uri(format!(\"/{}\", cjk_filename_encoded))\n@@ -1002,20 +1004,13 @@ mod tests {\n \n         assert_eq!(res.status(), StatusCode::OK);\n         assert_eq!(res.headers()[\"content-type\"], \"text/plain\");\n-        let _ = tokio::fs::remove_file(&tmp_filename).await.unwrap();\n     }\n \n     #[tokio::test]\n     async fn access_space_percent_encoded_uri_path() {\n-        let raw_filename = \"filename with space.txt\";\n-        // percent encoding present of \"filename with space.txt\"\n         let encoded_filename = \"filename%20with%20space.txt\";\n \n-        let tmp_dir = std::env::temp_dir();\n-        let tmp_filename = std::path::Path::new(tmp_dir.as_path()).join(raw_filename);\n-        let _ = tokio::fs::File::create(&tmp_filename).await.unwrap();\n-\n-        let svc = ServeDir::new(&tmp_dir);\n+        let svc = ServeDir::new(\"../test-files\");\n \n         let req = Request::builder()\n             .uri(format!(\"/{}\", encoded_filename))\n@@ -1025,7 +1020,6 @@ mod tests {\n \n         assert_eq!(res.status(), StatusCode::OK);\n         assert_eq!(res.headers()[\"content-type\"], \"text/plain\");\n-        let _ = tokio::fs::remove_file(&tmp_filename).await.unwrap();\n     }\n \n     #[tokio::test]\n",
    "diff_parsed": "{'added': [(136, '    let path_decoded = Path::new(&*path_decoded);'), (139, '    for component in path_decoded.components() {'), (140, '        match component {'), (141, '            std::path::Component::Normal(comp) => full_path.push(comp),'), (142, '            std::path::Component::CurDir => {}'), (143, '            std::path::Component::Prefix(_)'), (144, '            | std::path::Component::RootDir'), (145, '            | std::path::Component::ParentDir => return None,'), (148, '    if full_path.is_relative() {'), (149, '        Some(full_path)'), (150, '    } else {'), (151, '        None'), (152, '    }'), (997, '        let svc = ServeDir::new(\"../test-files\");'), (1013, '        let svc = ServeDir::new(\"../test-files\");')], 'deleted': [(139, \"    for seg in path_decoded.split('/') {\"), (140, '        if seg.starts_with(\"..\") || seg.contains(\\'\\\\\\\\\\') || seg.contains(\\':\\') {'), (141, '            return None;'), (143, '        full_path.push(seg);'), (145, '    Some(full_path)'), (987, '        let cjk_filename = \"\u4f60\u597d\u4e16\u754c.txt\";'), (991, '        let tmp_dir = std::env::temp_dir();'), (992, '        let tmp_filename = std::path::Path::new(tmp_dir.as_path()).join(cjk_filename);'), (993, '        let _ = tokio::fs::File::create(&tmp_filename).await.unwrap();'), (995, '        let svc = ServeDir::new(&tmp_dir);'), (1005, '        let _ = tokio::fs::remove_file(&tmp_filename).await.unwrap();'), (1010, '        let raw_filename = \"filename with space.txt\";'), (1014, '        let tmp_dir = std::env::temp_dir();'), (1015, '        let tmp_filename = std::path::Path::new(tmp_dir.as_path()).join(raw_filename);'), (1016, '        let _ = tokio::fs::File::create(&tmp_filename).await.unwrap();'), (1018, '        let svc = ServeDir::new(&tmp_dir);'), (1028, '        let _ = tokio::fs::remove_file(&tmp_filename).await.unwrap();')]}",
    "num_lines_added": "15",
    "num_lines_deleted": "17",
    "nloc": "872"
  },
  {
    "file_change_id": "158081428607345",
    "hash": "877dc0a52adedd1daaabcfcb56d90d1da1da862",
    "old_path": "src/proto/h1/role.rs",
    "new_path": "src/proto/h1/role.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,16 +1,14 @@\n-// `mem::uninitialized` replaced with `mem::MaybeUninit`,\n-// can't upgrade yet\n #![allow(deprecated)]\n \n use std::fmt::{self, Write};\n-use std::mem;\n+use std::mem::{self, MaybeUninit};\n \n #[cfg(any(test, feature = \"server\", feature = \"ffi\"))]\n use bytes::Bytes;\n use bytes::BytesMut;\n-use http::header::{self, Entry, HeaderName, HeaderValue};\n #[cfg(feature = \"server\")]\n use http::header::ValueIter;\n+use http::header::{self, Entry, HeaderName, HeaderValue};\n use http::{HeaderMap, Method, StatusCode, Version};\n \n use crate::body::DecodedLength;\n@@ -126,7 +124,10 @@ impl Http1Transaction for Server {\n         // but we *never* read any of it until after httparse has assigned\n         // values into it. By not zeroing out the stack memory, this saves\n         // a good ~5% on pipeline benchmarks.\n-        let mut headers_indices: [HeaderIndices; MAX_HEADERS] = unsafe { mem::uninitialized() };\n+        let mut headers_indices: [MaybeUninit<HeaderIndices>; MAX_HEADERS] = unsafe {\n+            // SAFETY: We can go safely from MaybeUninit array to array of MaybeUninit\n+            MaybeUninit::uninit().assume_init()\n+        };\n         {\n             let mut headers: [httparse::Header<'_>; MAX_HEADERS] = unsafe { mem::uninitialized() };\n             trace!(\n@@ -205,6 +206,8 @@ impl Http1Transaction for Server {\n         headers.reserve(headers_len);\n \n         for header in &headers_indices[..headers_len] {\n+            // SAFETY: array is valid up to `headers_len`\n+            let header = unsafe { &*header.as_ptr() };\n             let name = header_name!(&slice[header.name.0..header.name.1]);\n             let value = header_value!(slice.slice(header.value.0..header.value.1));\n \n@@ -880,7 +883,10 @@ impl Http1Transaction for Client {\n         // Loop to skip information status code headers (100 Continue, etc).\n         loop {\n             // Unsafe: see comment in Server Http1Transaction, above.\n-            let mut headers_indices: [HeaderIndices; MAX_HEADERS] = unsafe { mem::uninitialized() };\n+            let mut headers_indices: [MaybeUninit<HeaderIndices>; MAX_HEADERS] = unsafe {\n+                // SAFETY: We can go safely from MaybeUninit array to array of MaybeUninit\n+                MaybeUninit::uninit().assume_init()\n+            };\n             let (len, status, reason, version, headers_len) = {\n                 let mut headers: [httparse::Header<'_>; MAX_HEADERS] =\n                     unsafe { mem::uninitialized() };\n@@ -891,8 +897,7 @@ impl Http1Transaction for Client {\n                 );\n                 let mut res = httparse::Response::new(&mut headers);\n                 let bytes = buf.as_ref();\n-                match ctx.h1_parser_config.parse_response(&mut res, bytes)\n-                {\n+                match ctx.h1_parser_config.parse_response(&mut res, bytes) {\n                     Ok(httparse::Status::Complete(len)) => {\n                         trace!(\"Response.parse Complete({})\", len);\n                         let status = StatusCode::from_u16(res.code.unwrap())?;\n@@ -948,6 +953,8 @@ impl Http1Transaction for Client {\n \n             headers.reserve(headers_len);\n             for header in &headers_indices[..headers_len] {\n+                // SAFETY: array is valid up to `headers_len`\n+                let header = unsafe { &*header.as_ptr() };\n                 let name = header_name!(&slice[header.name.0..header.name.1]);\n                 let value = header_value!(slice.slice(header.value.0..header.value.1));\n \n@@ -1290,7 +1297,7 @@ struct HeaderIndices {\n fn record_header_indices(\n     bytes: &[u8],\n     headers: &[httparse::Header<'_>],\n-    indices: &mut [HeaderIndices],\n+    indices: &mut [MaybeUninit<HeaderIndices>],\n ) -> Result<(), crate::error::Parse> {\n     let bytes_ptr = bytes.as_ptr() as usize;\n \n@@ -1301,10 +1308,19 @@ fn record_header_indices(\n         }\n         let name_start = header.name.as_ptr() as usize - bytes_ptr;\n         let name_end = name_start + header.name.len();\n-        indices.name = (name_start, name_end);\n         let value_start = header.value.as_ptr() as usize - bytes_ptr;\n         let value_end = value_start + header.value.len();\n-        indices.value = (value_start, value_end);\n+\n+        // FIXME(maybe_uninit_extra)\n+        // FIXME(addr_of)\n+        // Currently we don't have `ptr::addr_of_mut` in stable rust or\n+        // MaybeUninit::write, so this is some way of assigning into a MaybeUninit\n+        // safely\n+        let new_header_indices = HeaderIndices {\n+            name: (name_start, name_end),\n+            value: (value_start, value_end),\n+        };\n+        *indices = MaybeUninit::new(new_header_indices);\n     }\n \n     Ok(())\n",
    "diff_parsed": "{'added': [(4, 'use std::mem::{self, MaybeUninit};'), (11, 'use http::header::{self, Entry, HeaderName, HeaderValue};'), (127, '        let mut headers_indices: [MaybeUninit<HeaderIndices>; MAX_HEADERS] = unsafe {'), (129, '            MaybeUninit::uninit().assume_init()'), (130, '        };'), (210, '            let header = unsafe { &*header.as_ptr() };'), (886, '            let mut headers_indices: [MaybeUninit<HeaderIndices>; MAX_HEADERS] = unsafe {'), (888, '                MaybeUninit::uninit().assume_init()'), (889, '            };'), (900, '                match ctx.h1_parser_config.parse_response(&mut res, bytes) {'), (957, '                let header = unsafe { &*header.as_ptr() };'), (1300, '    indices: &mut [MaybeUninit<HeaderIndices>],'), (1319, '        let new_header_indices = HeaderIndices {'), (1320, '            name: (name_start, name_end),'), (1321, '            value: (value_start, value_end),'), (1322, '        };'), (1323, '        *indices = MaybeUninit::new(new_header_indices);')], 'deleted': [(6, 'use std::mem;'), (11, 'use http::header::{self, Entry, HeaderName, HeaderValue};'), (129, '        let mut headers_indices: [HeaderIndices; MAX_HEADERS] = unsafe { mem::uninitialized() };'), (883, '            let mut headers_indices: [HeaderIndices; MAX_HEADERS] = unsafe { mem::uninitialized() };'), (894, '                match ctx.h1_parser_config.parse_response(&mut res, bytes)'), (895, '                {'), (1293, '    indices: &mut [HeaderIndices],'), (1304, '        indices.name = (name_start, name_end);'), (1307, '        indices.value = (value_start, value_end);')]}",
    "num_lines_added": "17",
    "num_lines_deleted": "9",
    "nloc": "2478"
  },
  {
    "file_change_id": "67708705380686",
    "hash": "7500d7ddfd1c39a5fbfefd54b9014842d9862af",
    "old_path": "src/proto/h1/role.rs",
    "new_path": "src/proto/h1/role.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -129,15 +129,18 @@ impl Http1Transaction for Server {\n             MaybeUninit::uninit().assume_init()\n         };\n         {\n-            let mut headers: [httparse::Header<'_>; MAX_HEADERS] = unsafe { mem::uninitialized() };\n+            /* SAFETY: it is safe to go from MaybeUninit array to array of MaybeUninit */\n+            let mut headers: [MaybeUninit<httparse::Header<'_>>; MAX_HEADERS] = unsafe {\n+                MaybeUninit::uninit().assume_init()\n+            };\n             trace!(\n                 \"Request.parse([Header; {}], [u8; {}])\",\n                 headers.len(),\n                 buf.len()\n             );\n-            let mut req = httparse::Request::new(&mut headers);\n             let bytes = buf.as_ref();\n-            match req.parse(bytes) {\n+            let (req, status) = httparse::Request::with_uninit_headers(&mut headers, bytes);\n+            match status {\n                 Ok(httparse::Status::Complete(parsed_len)) => {\n                     trace!(\"Request.parse Complete({})\", parsed_len);\n                     len = parsed_len;\n",
    "diff_parsed": "{'added': [(132, '            /* SAFETY: it is safe to go from MaybeUninit array to array of MaybeUninit */'), (133, \"            let mut headers: [MaybeUninit<httparse::Header<'_>>; MAX_HEADERS] = unsafe {\"), (134, '                MaybeUninit::uninit().assume_init()'), (135, '            };'), (142, '            let (req, status) = httparse::Request::with_uninit_headers(&mut headers, bytes);'), (143, '            match status {')], 'deleted': [(132, \"            let mut headers: [httparse::Header<'_>; MAX_HEADERS] = unsafe { mem::uninitialized() };\"), (138, '            let mut req = httparse::Request::new(&mut headers);'), (140, '            match req.parse(bytes) {')]}",
    "num_lines_added": "6",
    "num_lines_deleted": "3",
    "nloc": "2480"
  },
  {
    "file_change_id": "256280172089561",
    "hash": "e57b06f701462547dc5eceb032b0651501ee974",
    "old_path": "src/proto/h1/role.rs",
    "new_path": "src/proto/h1/role.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -891,16 +891,17 @@ impl Http1Transaction for Client {\n                 MaybeUninit::uninit().assume_init()\n             };\n             let (len, status, reason, version, headers_len) = {\n-                let mut headers: [httparse::Header<'_>; MAX_HEADERS] =\n-                    unsafe { mem::uninitialized() };\n+                // SAFETY: We can go safely from MaybeUninit array to array of MaybeUninit\n+                let mut headers: [MaybeUninit<httparse::Header<'_>>; MAX_HEADERS] =\n+                    unsafe { MaybeUninit::uninit().assume_init() };\n                 trace!(\n                     \"Response.parse([Header; {}], [u8; {}])\",\n                     headers.len(),\n                     buf.len()\n                 );\n-                let mut res = httparse::Response::new(&mut headers);\n                 let bytes = buf.as_ref();\n-                match ctx.h1_parser_config.parse_response(&mut res, bytes) {\n+                let (res, status) = ctx.h1_parser_config.parse_response_with_uninit_headers(&mut headers, bytes);\n+                match status {\n                     Ok(httparse::Status::Complete(len)) => {\n                         trace!(\"Response.parse Complete({})\", len);\n                         let status = StatusCode::from_u16(res.code.unwrap())?;\n",
    "diff_parsed": "{'added': [(895, \"                let mut headers: [MaybeUninit<httparse::Header<'_>>; MAX_HEADERS] =\"), (896, '                    unsafe { MaybeUninit::uninit().assume_init() };'), (903, '                let (res, status) = ctx.h1_parser_config.parse_response_with_uninit_headers(&mut headers, bytes);'), (904, '                match status {')], 'deleted': [(894, \"                let mut headers: [httparse::Header<'_>; MAX_HEADERS] =\"), (895, '                    unsafe { mem::uninitialized() };'), (901, '                let mut res = httparse::Response::new(&mut headers);'), (903, '                match ctx.h1_parser_config.parse_response(&mut res, bytes) {')]}",
    "num_lines_added": "4",
    "num_lines_deleted": "4",
    "nloc": "2481"
  },
  {
    "file_change_id": "176486328971501",
    "hash": "5cf0b14921d2d21b0317307441cd6e7c36fa0da",
    "old_path": "src/proto/h1/role.rs",
    "new_path": "src/proto/h1/role.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -138,9 +138,9 @@ impl Http1Transaction for Server {\n                 headers.len(),\n                 buf.len()\n             );\n+            let mut req = httparse::Request::new(&mut []);\n             let bytes = buf.as_ref();\n-            let (req, status) = httparse::Request::with_uninit_headers(&mut headers, bytes);\n-            match status {\n+            match req.parse_with_uninit_headers(bytes, &mut headers) {\n                 Ok(httparse::Status::Complete(parsed_len)) => {\n                     trace!(\"Request.parse Complete({})\", parsed_len);\n                     len = parsed_len;\n@@ -899,9 +899,11 @@ impl Http1Transaction for Client {\n                     headers.len(),\n                     buf.len()\n                 );\n+                let mut res = httparse::Response::new(&mut []);\n                 let bytes = buf.as_ref();\n-                let (res, status) = ctx.h1_parser_config.parse_response_with_uninit_headers(&mut headers, bytes);\n-                match status {\n+                match ctx.h1_parser_config\n+                    .parse_response_with_uninit_headers(&mut res, bytes, &mut headers)\n+                {\n                     Ok(httparse::Status::Complete(len)) => {\n                         trace!(\"Response.parse Complete({})\", len);\n                         let status = StatusCode::from_u16(res.code.unwrap())?;\n",
    "diff_parsed": "{'added': [(141, '            let mut req = httparse::Request::new(&mut []);'), (143, '            match req.parse_with_uninit_headers(bytes, &mut headers) {'), (902, '                let mut res = httparse::Response::new(&mut []);'), (904, '                match ctx.h1_parser_config'), (905, '                    .parse_response_with_uninit_headers(&mut res, bytes, &mut headers)'), (906, '                {')], 'deleted': [(142, '            let (req, status) = httparse::Request::with_uninit_headers(&mut headers, bytes);'), (143, '            match status {'), (903, '                let (res, status) = ctx.h1_parser_config.parse_response_with_uninit_headers(&mut headers, bytes);'), (904, '                match status {')]}",
    "num_lines_added": "6",
    "num_lines_deleted": "4",
    "nloc": "2483"
  },
  {
    "file_change_id": "280036525338500",
    "hash": "684f2fa76d44fa2b1b063ad0443a1b0d16dfad0e",
    "old_path": "src/proto/h1/role.rs",
    "new_path": "src/proto/h1/role.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1308,36 +1308,18 @@ fn record_header_indices(\n     Ok(())\n }\n \n-// Write header names as title case. The header name is assumed to be ASCII,\n-// therefore it is trivial to convert an ASCII character from lowercase to\n-// uppercase. It is as simple as XORing the lowercase character byte with\n-// space.\n+// Write header names as title case. The header name is assumed to be ASCII.\n fn title_case(dst: &mut Vec<u8>, name: &[u8]) {\n     dst.reserve(name.len());\n \n-    let mut iter = name.iter();\n-\n-    // Uppercase the first character\n-    if let Some(c) = iter.next() {\n-        if *c >= b'a' && *c <= b'z' {\n-            dst.push(*c ^ b' ');\n-        } else {\n-            dst.push(*c);\n-        }\n-    }\n-\n-    while let Some(c) = iter.next() {\n-        dst.push(*c);\n-\n-        if *c == b'-' {\n-            if let Some(c) = iter.next() {\n-                if *c >= b'a' && *c <= b'z' {\n-                    dst.push(*c ^ b' ');\n-                } else {\n-                    dst.push(*c);\n-                }\n-            }\n+    // Ensure first character is uppercased\n+    let mut prev = b'-';\n+    for &(mut c) in name {\n+        if prev == b'-' {\n+            c.make_ascii_uppercase();\n         }\n+        dst.push(c);\n+        prev = c;\n     }\n }\n \n@@ -2316,6 +2298,8 @@ mod tests {\n             .insert(\"content-length\", HeaderValue::from_static(\"10\"));\n         head.headers\n             .insert(\"content-type\", HeaderValue::from_static(\"application/json\"));\n+        head.headers\n+            .insert(\"weird--header\", HeaderValue::from_static(\"\"));\n \n         let mut vec = Vec::new();\n         Server::encode(\n@@ -2331,7 +2315,7 @@ mod tests {\n         .unwrap();\n \n         let expected_response =\n-            b\"HTTP/1.1 200 OK\\r\\nContent-Length: 10\\r\\nContent-Type: application/json\\r\\n\";\n+            b\"HTTP/1.1 200 OK\\r\\nContent-Length: 10\\r\\nContent-Type: application/json\\r\\nWeird--Header: \\r\\n\";\n \n         assert_eq!(&vec[..expected_response.len()], &expected_response[..]);\n     }\n",
    "diff_parsed": "{'added': [(1316, \"    let mut prev = b'-';\"), (1317, '    for &(mut c) in name {'), (1318, \"        if prev == b'-' {\"), (1319, '            c.make_ascii_uppercase();'), (1321, '        dst.push(c);'), (1322, '        prev = c;'), (2301, '        head.headers'), (2302, '            .insert(\"weird--header\", HeaderValue::from_static(\"\"));'), (2318, '            b\"HTTP/1.1 200 OK\\\\r\\\\nContent-Length: 10\\\\r\\\\nContent-Type: application/json\\\\r\\\\nWeird--Header: \\\\r\\\\n\";')], 'deleted': [(1318, '    let mut iter = name.iter();'), (1321, '    if let Some(c) = iter.next() {'), (1322, \"        if *c >= b'a' && *c <= b'z' {\"), (1323, \"            dst.push(*c ^ b' ');\"), (1324, '        } else {'), (1325, '            dst.push(*c);'), (1326, '        }'), (1327, '    }'), (1329, '    while let Some(c) = iter.next() {'), (1330, '        dst.push(*c);'), (1332, \"        if *c == b'-' {\"), (1333, '            if let Some(c) = iter.next() {'), (1334, \"                if *c >= b'a' && *c <= b'z' {\"), (1335, \"                    dst.push(*c ^ b' ');\"), (1336, '                } else {'), (1337, '                    dst.push(*c);'), (1338, '                }'), (1339, '            }'), (2334, '            b\"HTTP/1.1 200 OK\\\\r\\\\nContent-Length: 10\\\\r\\\\nContent-Type: application/json\\\\r\\\\n\";')]}",
    "num_lines_added": "9",
    "num_lines_deleted": "19",
    "nloc": "2527"
  },
  {
    "file_change_id": "168842320939340",
    "hash": "df65b33f8a9dbd06b95b0a6af7521f0d4723354",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1135,7 +1135,7 @@ impl<K: Hash + Eq, V, S: BuildHasher> IntoIterator for LinkedHashMap<K, V, S> {\n         }\n         self.clear_free_list();\n         // drop the HashMap but not the LinkedHashMap\n-        self.map = unsafe { mem::uninitialized() };\n+        unsafe { ptr::drop_in_place(&mut self.map); }\n         mem::forget(self);\n \n         IntoIter {\n",
    "diff_parsed": "{'added': [(1138, '        unsafe { ptr::drop_in_place(&mut self.map); }')], 'deleted': [(1138, '        self.map = unsafe { mem::uninitialized() };')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "927"
  },
  {
    "file_change_id": "51650506781063",
    "hash": "a83ccecf515b5273e4dd0306c1b9f6dcb7daf96",
    "old_path": "lib.rs",
    "new_path": "lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -63,7 +63,7 @@ use std::iter::{repeat, FromIterator, IntoIterator};\n #[cfg(feature = \"serde\")]\n use std::marker::PhantomData;\n use std::mem;\n-use std::mem::ManuallyDrop;\n+use std::mem::MaybeUninit;\n use std::ops;\n use std::ptr;\n use std::slice;\n@@ -280,29 +280,27 @@ impl<'a, T: 'a> Drop for Drain<'a, T> {\n \n #[cfg(feature = \"union\")]\n union SmallVecData<A: Array> {\n-    inline: ManuallyDrop<A>,\n+    inline: MaybeUninit<A>,\n     heap: (*mut A::Item, usize),\n }\n \n #[cfg(feature = \"union\")]\n impl<A: Array> SmallVecData<A> {\n     #[inline]\n-    unsafe fn inline(&self) -> &A {\n-        &self.inline\n+    unsafe fn inline(&self) -> *const A::Item {\n+        self.inline.as_ptr() as *const A::Item\n     }\n     #[inline]\n-    unsafe fn inline_mut(&mut self) -> &mut A {\n-        &mut self.inline\n+    unsafe fn inline_mut(&mut self) -> *mut A::Item {\n+        self.inline.as_mut_ptr() as *mut A::Item\n     }\n     #[inline]\n-    fn from_inline(inline: A) -> SmallVecData<A> {\n-        SmallVecData {\n-            inline: ManuallyDrop::new(inline),\n-        }\n+    fn from_inline(inline: MaybeUninit<A>) -> SmallVecData<A> {\n+        SmallVecData { inline }\n     }\n     #[inline]\n-    unsafe fn into_inline(self) -> A {\n-        ManuallyDrop::into_inner(self.inline)\n+    unsafe fn into_inline(self) -> MaybeUninit<A> {\n+        self.inline\n     }\n     #[inline]\n     unsafe fn heap(&self) -> (*mut A::Item, usize) {\n@@ -320,34 +318,34 @@ impl<A: Array> SmallVecData<A> {\n \n #[cfg(not(feature = \"union\"))]\n enum SmallVecData<A: Array> {\n-    Inline(ManuallyDrop<A>),\n+    Inline(MaybeUninit<A>),\n     Heap((*mut A::Item, usize)),\n }\n \n #[cfg(not(feature = \"union\"))]\n impl<A: Array> SmallVecData<A> {\n     #[inline]\n-    unsafe fn inline(&self) -> &A {\n+    unsafe fn inline(&self) -> *const A::Item {\n         match *self {\n-            SmallVecData::Inline(ref a) => a,\n+            SmallVecData::Inline(ref a) => a.as_ptr() as *const A::Item,\n             _ => debug_unreachable!(),\n         }\n     }\n     #[inline]\n-    unsafe fn inline_mut(&mut self) -> &mut A {\n+    unsafe fn inline_mut(&mut self) -> *mut A::Item {\n         match *self {\n-            SmallVecData::Inline(ref mut a) => a,\n+            SmallVecData::Inline(ref mut a) => a.as_mut_ptr() as *mut A::Item,\n             _ => debug_unreachable!(),\n         }\n     }\n     #[inline]\n-    fn from_inline(inline: A) -> SmallVecData<A> {\n-        SmallVecData::Inline(ManuallyDrop::new(inline))\n+    fn from_inline(inline: MaybeUninit<A>) -> SmallVecData<A> {\n+        SmallVecData::Inline(inline)\n     }\n     #[inline]\n-    unsafe fn into_inline(self) -> A {\n+    unsafe fn into_inline(self) -> MaybeUninit<A> {\n         match self {\n-            SmallVecData::Inline(a) => ManuallyDrop::into_inner(a),\n+            SmallVecData::Inline(a) => a,\n             _ => debug_unreachable!(),\n         }\n     }\n@@ -412,11 +410,15 @@ impl<A: Array> SmallVec<A> {\n     /// Construct an empty vector\n     #[inline]\n     pub fn new() -> SmallVec<A> {\n-        unsafe {\n-            SmallVec {\n-                capacity: 0,\n-                data: SmallVecData::from_inline(mem::uninitialized()),\n-            }\n+        // Try to detect invalid custom implementations of `Array`. Hopefuly,\n+        // this check should be optimized away entirely for valid ones.\n+        assert!(\n+            mem::size_of::<A>() == A::size() * mem::size_of::<A::Item>()\n+                && mem::align_of::<A>() >= mem::align_of::<A::Item>()\n+        );\n+        SmallVec {\n+            capacity: 0,\n+            data: SmallVecData::from_inline(MaybeUninit::uninit()),\n         }\n     }\n \n@@ -456,10 +458,10 @@ impl<A: Array> SmallVec<A> {\n     pub fn from_vec(mut vec: Vec<A::Item>) -> SmallVec<A> {\n         if vec.capacity() <= A::size() {\n             unsafe {\n-                let mut data = SmallVecData::<A>::from_inline(mem::uninitialized());\n+                let mut data = SmallVecData::<A>::from_inline(MaybeUninit::uninit());\n                 let len = vec.len();\n                 vec.set_len(0);\n-                ptr::copy_nonoverlapping(vec.as_ptr(), data.inline_mut().ptr_mut(), len);\n+                ptr::copy_nonoverlapping(vec.as_ptr(), data.inline_mut(), len);\n \n                 SmallVec {\n                     capacity: len,\n@@ -492,7 +494,7 @@ impl<A: Array> SmallVec<A> {\n     pub fn from_buf(buf: A) -> SmallVec<A> {\n         SmallVec {\n             capacity: A::size(),\n-            data: SmallVecData::from_inline(buf),\n+            data: SmallVecData::from_inline(MaybeUninit::new(buf)),\n         }\n     }\n \n@@ -511,7 +513,7 @@ impl<A: Array> SmallVec<A> {\n     #[inline]\n     pub fn from_buf_and_len(buf: A, len: usize) -> SmallVec<A> {\n         assert!(len <= A::size());\n-        unsafe { SmallVec::from_buf_and_len_unchecked(buf, len) }\n+        unsafe { SmallVec::from_buf_and_len_unchecked(MaybeUninit::new(buf), len) }\n     }\n \n     /// Constructs a new `SmallVec` on the stack from an `A` without\n@@ -520,16 +522,17 @@ impl<A: Array> SmallVec<A> {\n     ///\n     /// ```rust\n     /// use smallvec::SmallVec;\n+    /// use std::mem::MaybeUninit;\n     ///\n     /// let buf = [1, 2, 3, 4, 5, 0, 0, 0];\n     /// let small_vec: SmallVec<_> = unsafe {\n-    ///     SmallVec::from_buf_and_len_unchecked(buf, 5)\n+    ///     SmallVec::from_buf_and_len_unchecked(MaybeUninit::new(buf), 5)\n     /// };\n     ///\n     /// assert_eq!(&*small_vec, &[1, 2, 3, 4, 5]);\n     /// ```\n     #[inline]\n-    pub unsafe fn from_buf_and_len_unchecked(buf: A, len: usize) -> SmallVec<A> {\n+    pub unsafe fn from_buf_and_len_unchecked(buf: MaybeUninit<A>, len: usize) -> SmallVec<A> {\n         SmallVec {\n             capacity: len,\n             data: SmallVecData::from_inline(buf),\n@@ -579,7 +582,7 @@ impl<A: Array> SmallVec<A> {\n                 let (ptr, len) = self.data.heap();\n                 (ptr, len, self.capacity)\n             } else {\n-                (self.data.inline().ptr(), self.capacity, A::size())\n+                (self.data.inline(), self.capacity, A::size())\n             }\n         }\n     }\n@@ -592,11 +595,7 @@ impl<A: Array> SmallVec<A> {\n                 let &mut (ptr, ref mut len_ptr) = self.data.heap_mut();\n                 (ptr, len_ptr, self.capacity)\n             } else {\n-                (\n-                    self.data.inline_mut().ptr_mut(),\n-                    &mut self.capacity,\n-                    A::size(),\n-                )\n+                (self.data.inline_mut(), &mut self.capacity, A::size())\n             }\n         }\n     }\n@@ -663,8 +662,8 @@ impl<A: Array> SmallVec<A> {\n                 if unspilled {\n                     return;\n                 }\n-                self.data = SmallVecData::from_inline(mem::uninitialized());\n-                ptr::copy_nonoverlapping(ptr, self.data.inline_mut().ptr_mut(), len);\n+                self.data = SmallVecData::from_inline(MaybeUninit::uninit());\n+                ptr::copy_nonoverlapping(ptr, self.data.inline_mut(), len);\n                 self.capacity = len;\n             } else if new_cap != cap {\n                 let mut vec = Vec::with_capacity(new_cap);\n@@ -730,8 +729,8 @@ impl<A: Array> SmallVec<A> {\n         if self.inline_size() >= len {\n             unsafe {\n                 let (ptr, len) = self.data.heap();\n-                self.data = SmallVecData::from_inline(mem::uninitialized());\n-                ptr::copy_nonoverlapping(ptr, self.data.inline_mut().ptr_mut(), len);\n+                self.data = SmallVecData::from_inline(MaybeUninit::uninit());\n+                ptr::copy_nonoverlapping(ptr, self.data.inline_mut(), len);\n                 deallocate(ptr, self.capacity);\n                 self.capacity = len;\n             }\n@@ -900,7 +899,7 @@ impl<A: Array> SmallVec<A> {\n             unsafe {\n                 let data = ptr::read(&self.data);\n                 mem::forget(self);\n-                Ok(data.into_inline())\n+                Ok(data.into_inline().assume_init())\n             }\n         }\n     }\n@@ -1062,8 +1061,12 @@ where\n             SmallVec {\n                 capacity: len,\n                 data: SmallVecData::from_inline(unsafe {\n-                    let mut data: A = mem::uninitialized();\n-                    ptr::copy_nonoverlapping(slice.as_ptr(), data.ptr_mut(), len);\n+                    let mut data: MaybeUninit<A> = MaybeUninit::uninit();\n+                    ptr::copy_nonoverlapping(\n+                        slice.as_ptr(),\n+                        data.as_mut_ptr() as *mut A::Item,\n+                        len,\n+                    );\n                     data\n                 }),\n             }\n@@ -1603,10 +1606,6 @@ pub unsafe trait Array {\n     type Item;\n     /// Returns the number of items the array can hold.\n     fn size() -> usize;\n-    /// Returns a pointer to the first element of the array.\n-    fn ptr(&self) -> *const Self::Item;\n-    /// Returns a mutable pointer to the first element of the array.\n-    fn ptr_mut(&mut self) -> *mut Self::Item;\n }\n \n /// Set the length of the vec when the `SetLenOnDrop` value goes out of scope.\n@@ -1650,8 +1649,6 @@ macro_rules! impl_array(\n             unsafe impl<T> Array for [T; $size] {\n                 type Item = T;\n                 fn size() -> usize { $size }\n-                fn ptr(&self) -> *const T { self.as_ptr() }\n-                fn ptr_mut(&mut self) -> *mut T { self.as_mut_ptr() }\n             }\n         )+\n     }\n@@ -1985,7 +1982,7 @@ mod tests {\n         );\n     }\n \n-    #[cfg(feature = \"std\")]\n+    #[cfg(all(feature = \"std\", not(miri)))] // Miri currently does not support unwinding\n     #[test]\n     // https://github.com/servo/rust-smallvec/issues/96\n     fn test_insert_many_panic() {\n",
    "diff_parsed": "{'added': [(66, 'use std::mem::MaybeUninit;'), (283, '    inline: MaybeUninit<A>,'), (290, '    unsafe fn inline(&self) -> *const A::Item {'), (291, '        self.inline.as_ptr() as *const A::Item'), (294, '    unsafe fn inline_mut(&mut self) -> *mut A::Item {'), (295, '        self.inline.as_mut_ptr() as *mut A::Item'), (298, '    fn from_inline(inline: MaybeUninit<A>) -> SmallVecData<A> {'), (299, '        SmallVecData { inline }'), (302, '    unsafe fn into_inline(self) -> MaybeUninit<A> {'), (303, '        self.inline'), (321, '    Inline(MaybeUninit<A>),'), (328, '    unsafe fn inline(&self) -> *const A::Item {'), (330, '            SmallVecData::Inline(ref a) => a.as_ptr() as *const A::Item,'), (335, '    unsafe fn inline_mut(&mut self) -> *mut A::Item {'), (337, '            SmallVecData::Inline(ref mut a) => a.as_mut_ptr() as *mut A::Item,'), (342, '    fn from_inline(inline: MaybeUninit<A>) -> SmallVecData<A> {'), (343, '        SmallVecData::Inline(inline)'), (346, '    unsafe fn into_inline(self) -> MaybeUninit<A> {'), (348, '            SmallVecData::Inline(a) => a,'), (415, '        assert!('), (416, '            mem::size_of::<A>() == A::size() * mem::size_of::<A::Item>()'), (417, '                && mem::align_of::<A>() >= mem::align_of::<A::Item>()'), (418, '        );'), (419, '        SmallVec {'), (420, '            capacity: 0,'), (421, '            data: SmallVecData::from_inline(MaybeUninit::uninit()),'), (461, '                let mut data = SmallVecData::<A>::from_inline(MaybeUninit::uninit());'), (464, '                ptr::copy_nonoverlapping(vec.as_ptr(), data.inline_mut(), len);'), (497, '            data: SmallVecData::from_inline(MaybeUninit::new(buf)),'), (516, '        unsafe { SmallVec::from_buf_and_len_unchecked(MaybeUninit::new(buf), len) }'), (535, '    pub unsafe fn from_buf_and_len_unchecked(buf: MaybeUninit<A>, len: usize) -> SmallVec<A> {'), (585, '                (self.data.inline(), self.capacity, A::size())'), (598, '                (self.data.inline_mut(), &mut self.capacity, A::size())'), (665, '                self.data = SmallVecData::from_inline(MaybeUninit::uninit());'), (666, '                ptr::copy_nonoverlapping(ptr, self.data.inline_mut(), len);'), (732, '                self.data = SmallVecData::from_inline(MaybeUninit::uninit());'), (733, '                ptr::copy_nonoverlapping(ptr, self.data.inline_mut(), len);'), (902, '                Ok(data.into_inline().assume_init())'), (1064, '                    let mut data: MaybeUninit<A> = MaybeUninit::uninit();'), (1065, '                    ptr::copy_nonoverlapping('), (1066, '                        slice.as_ptr(),'), (1067, '                        data.as_mut_ptr() as *mut A::Item,'), (1068, '                        len,'), (1069, '                    );'), (1985, '    #[cfg(all(feature = \"std\", not(miri)))] // Miri currently does not support unwinding')], 'deleted': [(66, 'use std::mem::ManuallyDrop;'), (283, '    inline: ManuallyDrop<A>,'), (290, '    unsafe fn inline(&self) -> &A {'), (291, '        &self.inline'), (294, '    unsafe fn inline_mut(&mut self) -> &mut A {'), (295, '        &mut self.inline'), (298, '    fn from_inline(inline: A) -> SmallVecData<A> {'), (299, '        SmallVecData {'), (300, '            inline: ManuallyDrop::new(inline),'), (301, '        }'), (304, '    unsafe fn into_inline(self) -> A {'), (305, '        ManuallyDrop::into_inner(self.inline)'), (323, '    Inline(ManuallyDrop<A>),'), (330, '    unsafe fn inline(&self) -> &A {'), (332, '            SmallVecData::Inline(ref a) => a,'), (337, '    unsafe fn inline_mut(&mut self) -> &mut A {'), (339, '            SmallVecData::Inline(ref mut a) => a,'), (344, '    fn from_inline(inline: A) -> SmallVecData<A> {'), (345, '        SmallVecData::Inline(ManuallyDrop::new(inline))'), (348, '    unsafe fn into_inline(self) -> A {'), (350, '            SmallVecData::Inline(a) => ManuallyDrop::into_inner(a),'), (415, '        unsafe {'), (416, '            SmallVec {'), (417, '                capacity: 0,'), (418, '                data: SmallVecData::from_inline(mem::uninitialized()),'), (419, '            }'), (459, '                let mut data = SmallVecData::<A>::from_inline(mem::uninitialized());'), (462, '                ptr::copy_nonoverlapping(vec.as_ptr(), data.inline_mut().ptr_mut(), len);'), (495, '            data: SmallVecData::from_inline(buf),'), (514, '        unsafe { SmallVec::from_buf_and_len_unchecked(buf, len) }'), (532, '    pub unsafe fn from_buf_and_len_unchecked(buf: A, len: usize) -> SmallVec<A> {'), (582, '                (self.data.inline().ptr(), self.capacity, A::size())'), (595, '                ('), (596, '                    self.data.inline_mut().ptr_mut(),'), (597, '                    &mut self.capacity,'), (598, '                    A::size(),'), (599, '                )'), (666, '                self.data = SmallVecData::from_inline(mem::uninitialized());'), (667, '                ptr::copy_nonoverlapping(ptr, self.data.inline_mut().ptr_mut(), len);'), (733, '                self.data = SmallVecData::from_inline(mem::uninitialized());'), (734, '                ptr::copy_nonoverlapping(ptr, self.data.inline_mut().ptr_mut(), len);'), (903, '                Ok(data.into_inline())'), (1065, '                    let mut data: A = mem::uninitialized();'), (1066, '                    ptr::copy_nonoverlapping(slice.as_ptr(), data.ptr_mut(), len);'), (1607, '    fn ptr(&self) -> *const Self::Item;'), (1609, '    fn ptr_mut(&mut self) -> *mut Self::Item;'), (1653, '                fn ptr(&self) -> *const T { self.as_ptr() }'), (1654, '                fn ptr_mut(&mut self) -> *mut T { self.as_mut_ptr() }'), (1988, '    #[cfg(feature = \"std\")]')]}",
    "num_lines_added": "45",
    "num_lines_deleted": "49",
    "nloc": "1961"
  },
  {
    "file_change_id": "224149053670860",
    "hash": "390a7b1049fa5ba1d627feaef2a1629e0e7826b",
    "old_path": "rand_core/src/le.rs",
    "new_path": "rand_core/src/le.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -16,7 +16,7 @@ use core::convert::TryInto;\n /// Reads unsigned 32 bit integers from `src` into `dst`.\n #[inline]\n pub fn read_u32_into(src: &[u8], dst: &mut [u32]) {\n-    assert!(4 * src.len() >= dst.len());\n+    assert!(src.len() >= 4 * dst.len());\n     for (out, chunk) in dst.iter_mut().zip(src.chunks_exact(4)) {\n         *out = u32::from_le_bytes(chunk.try_into().unwrap());\n     }\n@@ -25,7 +25,7 @@ pub fn read_u32_into(src: &[u8], dst: &mut [u32]) {\n /// Reads unsigned 64 bit integers from `src` into `dst`.\n #[inline]\n pub fn read_u64_into(src: &[u8], dst: &mut [u64]) {\n-    assert!(8 * src.len() >= dst.len());\n+    assert!(src.len() >= 8 * dst.len());\n     for (out, chunk) in dst.iter_mut().zip(src.chunks_exact(8)) {\n         *out = u64::from_le_bytes(chunk.try_into().unwrap());\n     }\n",
    "diff_parsed": "{'added': [(19, '    assert!(src.len() >= 4 * dst.len());'), (28, '    assert!(src.len() >= 8 * dst.len());')], 'deleted': [(19, '    assert!(4 * src.len() >= dst.len());'), (28, '    assert!(8 * src.len() >= dst.len());')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "34"
  },
  {
    "file_change_id": "1584003648461",
    "hash": "a6d7cdd2221ae5087fa354a100733b2cc4fd008",
    "old_path": "src/snip.rs",
    "new_path": "src/snip.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -13,7 +13,7 @@ pub(crate) fn preamble_skipcount<R: Read>(reader: &mut R, n_preamble_rows: usize\n     let mut skipcount = 0;\n     loop {\n         let cap = 1 << 12;\n-        let mut buffer = Vec::with_capacity(cap);\n+        let mut buffer = vec![0; cap];\n         unsafe { buffer.set_len(cap); }\n         let n_read = reader.read(&mut buffer)?;\n         let mut crlf_pos = 0;\n",
    "diff_parsed": "{'added': [(16, '        let mut buffer = vec![0; cap];')], 'deleted': [(16, '        let mut buffer = Vec::with_capacity(cap);')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "42"
  },
  {
    "file_change_id": "156903777009113",
    "hash": "4b8426b89b861d9bea20e126576b0febb9d1351",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1781,7 +1781,8 @@ impl<'a> Builder<'a> {\n                 removed.push(node);\n                 continue;\n             }\n-            let pass = self.clean_child(&mut node, url_base);\n+            let pass_clean = self.clean_child(&mut node, url_base);\n+            let pass = pass_clean && self.check_expected_namespace(&parent, &node);\n             if pass {\n                 self.adjust_node_attributes(&mut node, &link_rel, url_base, self.id_prefix);\n                 dom.append(&parent.clone(), NodeOrText::AppendNode(node.clone()));\n@@ -1892,6 +1893,125 @@ impl<'a> Builder<'a> {\n         }\n     }\n \n+    // Check for unexpected namespace changes.\n+    //\n+    // The issue happens if developers added to the list of allowed tags any\n+    // tag which is parsed in RCDATA state, PLAINTEXT state or RCDATA state,\n+    // that is:\n+    //\n+    // * title\n+    // * textarea\n+    // * style\n+    // * xmp\n+    // * iframe\n+    // * noembed\n+    // * noframes\n+    // * plaintext\n+    //\n+    // An example in the wild is Plume, that allows iframe [1].  So in next\n+    // examples I'll assume the following policy:\n+    //\n+    //     Builder::new()\n+    //        .add_tags(&[\"iframe\"])\n+    //\n+    // In HTML namespace `<iframe>` is parsed specially; that is, its content is\n+    // treated as text. For instance, the following html:\n+    //\n+    //     <iframe><a>test\n+    //\n+    // Is parsed into the following DOM tree:\n+    //\n+    //     iframe\n+    //     \u2514\u2500 #text: <a>test\n+    //\n+    // So iframe cannot have any children other than a text node.\n+    //\n+    // The same is not true, though, in \"foreign content\"; that is, within\n+    // <svg> or <math> tags. The following html:\n+    //\n+    //     <svg><iframe><a>test\n+    //\n+    // is parsed differently:\n+    //\n+    //    svg\n+    //    \u2514\u2500 iframe\n+    //       \u2514\u2500 a\n+    //          \u2514\u2500 #text: test\n+    //\n+    // So in SVG namespace iframe can have children.\n+    //\n+    // Ammonia disallows <svg> but it keeps its content after deleting it. And\n+    // the parser internally keeps track of the namespace of the element. So\n+    // assume we have the following snippet:\n+    //\n+    //     <svg><iframe><a title=\"</iframe><img src onerror=alert(1)>\">test\n+    //\n+    // It is parsed into:\n+    //\n+    //     svg\n+    //     \u2514\u2500 iframe\n+    //        \u2514\u2500 a title=\"</iframe><img src onerror=alert(1)>\"\n+    //           \u2514\u2500 #text: test\n+    //\n+    // This DOM tree is harmless from ammonia point of view because the piece\n+    // of code that looks like XSS is in a title attribute. Hence, the\n+    // resulting \"safe\" HTML from ammonia would be:\n+    //\n+    //     <iframe><a title=\"</iframe><img src onerror=alert(1)>\" rel=\"noopener\n+    // noreferrer\">test</a></iframe>\n+    //\n+    // However, at this point, the information about namespace is lost, which\n+    // means that the browser will parse this snippet into:\n+    //\n+    //     \u251c\u2500 iframe\n+    //     \u2502  \u2514\u2500 #text: <a title=\"\n+    //     \u251c\u2500 img src=\"\" onerror=\"alert(1)\"\n+    //     \u2514\u2500 #text: \" rel=\"noopener noreferrer\">test\n+    //\n+    // Leading to XSS.\n+    //\n+    // To solve this issue, check for unexpected namespace switches after cleanup.\n+    // Elements which change namespace at an unexpected point are removed.\n+    // This function returns `true` if `child` should be kept, and `false` if it\n+    // should be removed.\n+    fn check_expected_namespace(&self, parent: &Handle, child: &Handle) -> bool {\n+        let (parent, child) = match (&parent.data, &child.data) {\n+            (NodeData::Element { name: pn, .. }, NodeData::Element { name: cn, .. }) => (pn, cn),\n+            _ => return true,\n+        };\n+        // The only way to switch from html to svg is with the <svg> tag\n+        if parent.ns == ns!(html) && child.ns == ns!(svg) {\n+            child.local == local_name!(\"svg\")\n+        // The only way to switch from html to mathml is with the <math> tag\n+        } else if parent.ns == ns!(html) && child.ns == ns!(mathml) {\n+            child.local == local_name!(\"math\")\n+        // The only way to switch from mathml to svg/html is with a text integration point\n+        } else if parent.ns == ns!(mathml) && child.ns != ns!(mathml) {\n+            // https://html.spec.whatwg.org/#mathml\n+            matches!(\n+                &*parent.local,\n+                \"mi\" | \"mo\" | \"mn\" | \"ms\" | \"mtext\" | \"annotation-xml\"\n+            )\n+        // The only way to switch from svg to mathml/html is with an html integration point\n+        } else if parent.ns == ns!(svg) && child.ns != ns!(svg) {\n+            // https://html.spec.whatwg.org/#svg-0\n+            matches!(&*parent.local, \"foreignObject\")\n+        } else if child.ns == ns!(svg) {\n+            is_svg_tag(&*child.local)\n+        } else if child.ns == ns!(mathml) {\n+            is_mathml_tag(&*child.local)\n+        } else if child.ns == ns!(html) {\n+            (!is_svg_tag(&*child.local) && !is_mathml_tag(&*child.local))\n+                || matches!(\n+                    &*child.local,\n+                    \"title\" | \"style\" | \"font\" | \"a\" | \"script\" | \"span\"\n+                )\n+        } else {\n+            // There are no other supported ways to switch namespace\n+            parent.ns == child.ns\n+        }\n+    }\n+\n     /// Add and transform special-cased attributes and elements.\n     ///\n     /// This function handles:\n@@ -2050,6 +2170,280 @@ fn is_url_attr(element: &str, attr: &str) -> bool {\n         || (element == \"video\" && attr == \"poster\")\n }\n \n+/// Given an element name, check if it's SVG\n+fn is_svg_tag(element: &str) -> bool {\n+    // https://svgwg.org/svg2-draft/eltindex.html\n+    match element {\n+        \"a\"\n+        | \"animate\"\n+        | \"animateMotion\"\n+        | \"animateTransform\"\n+        | \"circle\"\n+        | \"clipPath\"\n+        | \"defs\"\n+        | \"desc\"\n+        | \"discard\"\n+        | \"ellipse\"\n+        | \"feBlend\"\n+        | \"feColorMatrix\"\n+        | \"feComponentTransfer\"\n+        | \"feComposite\"\n+        | \"feConvolveMatrix\"\n+        | \"feDiffuseLighting\"\n+        | \"feDisplacementMap\"\n+        | \"feDistantLight\"\n+        | \"feDropShadow\"\n+        | \"feFlood\"\n+        | \"feFuncA\"\n+        | \"feFuncB\"\n+        | \"feFuncG\"\n+        | \"feFuncR\"\n+        | \"feGaussianBlur\"\n+        | \"feImage\"\n+        | \"feMerge\"\n+        | \"feMergeNode\"\n+        | \"feMorphology\"\n+        | \"feOffset\"\n+        | \"fePointLight\"\n+        | \"feSpecularLighting\"\n+        | \"feSpotLight\"\n+        | \"feTile\"\n+        | \"feTurbulence\"\n+        | \"filter\"\n+        | \"foreignObject\"\n+        | \"g\"\n+        | \"image\"\n+        | \"line\"\n+        | \"linearGradient\"\n+        | \"marker\"\n+        | \"mask\"\n+        | \"metadata\"\n+        | \"mpath\"\n+        | \"path\"\n+        | \"pattern\"\n+        | \"polygon\"\n+        | \"polyline\"\n+        | \"radialGradient\"\n+        | \"rect\"\n+        | \"script\"\n+        | \"set\"\n+        | \"stop\"\n+        | \"style\"\n+        | \"svg\"\n+        | \"switch\"\n+        | \"symbol\"\n+        | \"text\"\n+        | \"textPath\"\n+        | \"title\"\n+        | \"tspan\"\n+        | \"use\"\n+        | \"view\" => true,\n+        _ => false,\n+    }\n+}\n+\n+/// Given an element name, check if it's Math\n+fn is_mathml_tag(element: &str) -> bool {\n+    // https://svgwg.org/svg2-draft/eltindex.html\n+    match element {\n+        \"abs\"\n+        | \"and\"\n+        | \"annotation\"\n+        | \"annotation-xml\"\n+        | \"apply\"\n+        | \"approx\"\n+        | \"arccos\"\n+        | \"arccosh\"\n+        | \"arccot\"\n+        | \"arccoth\"\n+        | \"arccsc\"\n+        | \"arccsch\"\n+        | \"arcsec\"\n+        | \"arcsech\"\n+        | \"arcsin\"\n+        | \"arcsinh\"\n+        | \"arctan\"\n+        | \"arctanh\"\n+        | \"arg\"\n+        | \"bind\"\n+        | \"bvar\"\n+        | \"card\"\n+        | \"cartesianproduct\"\n+        | \"cbytes\"\n+        | \"ceiling\"\n+        | \"cerror\"\n+        | \"ci\"\n+        | \"cn\"\n+        | \"codomain\"\n+        | \"complexes\"\n+        | \"compose\"\n+        | \"condition\"\n+        | \"conjugate\"\n+        | \"cos\"\n+        | \"cosh\"\n+        | \"cot\"\n+        | \"coth\"\n+        | \"cs\"\n+        | \"csc\"\n+        | \"csch\"\n+        | \"csymbol\"\n+        | \"curl\"\n+        | \"declare\"\n+        | \"degree\"\n+        | \"determinant\"\n+        | \"diff\"\n+        | \"divergence\"\n+        | \"divide\"\n+        | \"domain\"\n+        | \"domainofapplication\"\n+        | \"emptyset\"\n+        | \"eq\"\n+        | \"equivalent\"\n+        | \"eulergamma\"\n+        | \"exists\"\n+        | \"exp\"\n+        | \"exponentiale\"\n+        | \"factorial\"\n+        | \"factorof\"\n+        | \"false\"\n+        | \"floor\"\n+        | \"fn\"\n+        | \"forall\"\n+        | \"gcd\"\n+        | \"geq\"\n+        | \"grad\"\n+        | \"gt\"\n+        | \"ident\"\n+        | \"image\"\n+        | \"imaginary\"\n+        | \"imaginaryi\"\n+        | \"implies\"\n+        | \"in\"\n+        | \"infinity\"\n+        | \"int\"\n+        | \"integers\"\n+        | \"intersect\"\n+        | \"interval\"\n+        | \"inverse\"\n+        | \"lambda\"\n+        | \"laplacian\"\n+        | \"lcm\"\n+        | \"leq\"\n+        | \"limit\"\n+        | \"list\"\n+        | \"ln\"\n+        | \"log\"\n+        | \"logbase\"\n+        | \"lowlimit\"\n+        | \"lt\"\n+        | \"maction\"\n+        | \"maligngroup\"\n+        | \"malignmark\"\n+        | \"math\"\n+        | \"matrix\"\n+        | \"matrixrow\"\n+        | \"max\"\n+        | \"mean\"\n+        | \"median\"\n+        | \"menclose\"\n+        | \"merror\"\n+        | \"mfenced\"\n+        | \"mfrac\"\n+        | \"mglyph\"\n+        | \"mi\"\n+        | \"min\"\n+        | \"minus\"\n+        | \"mlabeledtr\"\n+        | \"mlongdiv\"\n+        | \"mmultiscripts\"\n+        | \"mn\"\n+        | \"mo\"\n+        | \"mode\"\n+        | \"moment\"\n+        | \"momentabout\"\n+        | \"mover\"\n+        | \"mpadded\"\n+        | \"mphantom\"\n+        | \"mprescripts\"\n+        | \"mroot\"\n+        | \"mrow\"\n+        | \"ms\"\n+        | \"mscarries\"\n+        | \"mscarry\"\n+        | \"msgroup\"\n+        | \"msline\"\n+        | \"mspace\"\n+        | \"msqrt\"\n+        | \"msrow\"\n+        | \"mstack\"\n+        | \"mstyle\"\n+        | \"msub\"\n+        | \"msubsup\"\n+        | \"msup\"\n+        | \"mtable\"\n+        | \"mtd\"\n+        | \"mtext\"\n+        | \"mtr\"\n+        | \"munder\"\n+        | \"munderover\"\n+        | \"naturalnumbers\"\n+        | \"neq\"\n+        | \"none\"\n+        | \"not\"\n+        | \"notanumber\"\n+        | \"notin\"\n+        | \"notprsubset\"\n+        | \"notsubset\"\n+        | \"or\"\n+        | \"otherwise\"\n+        | \"outerproduct\"\n+        | \"partialdiff\"\n+        | \"pi\"\n+        | \"piece\"\n+        | \"piecewise\"\n+        | \"plus\"\n+        | \"power\"\n+        | \"primes\"\n+        | \"product\"\n+        | \"prsubset\"\n+        | \"quotient\"\n+        | \"rationals\"\n+        | \"real\"\n+        | \"reals\"\n+        | \"reln\"\n+        | \"rem\"\n+        | \"root\"\n+        | \"scalarproduct\"\n+        | \"sdev\"\n+        | \"sec\"\n+        | \"sech\"\n+        | \"selector\"\n+        | \"semantics\"\n+        | \"sep\"\n+        | \"set\"\n+        | \"setdiff\"\n+        | \"share\"\n+        | \"sin\"\n+        | \"sinh\"\n+        | \"span\"\n+        | \"subset\"\n+        | \"sum\"\n+        | \"tan\"\n+        | \"tanh\"\n+        | \"tendsto\"\n+        | \"times\"\n+        | \"transpose\"\n+        | \"true\"\n+        | \"union\"\n+        | \"uplimit\"\n+        | \"variance\"\n+        | \"vector\"\n+        | \"vectorproduct\"\n+        | \"xor\" => true,\n+        _ => false,\n+    }\n+}\n+\n fn is_url_relative(url: &str) -> bool {\n     matches!(\n         Url::parse(url),\n@@ -2479,7 +2873,8 @@ mod test {\n                         (\"rel\", \"noopener noreferrer\") => true,\n                         _ => false,\n                     },\n-                    \"{}\", value.to_string()\n+                    \"{}\",\n+                    value.to_string()\n                 );\n                 Some(value.into())\n             })\n@@ -3037,6 +3432,64 @@ mod test {\n         );\n     }\n \n+    #[test]\n+    fn ns_svg() {\n+        // https://github.com/cure53/DOMPurify/pull/495\n+        let fragment = r##\"<svg><iframe><a title=\"</iframe><img src onerror=alert(1)>\">test\"##;\n+        let result = String::from(Builder::new().add_tags(&[\"iframe\"]).clean(fragment));\n+        assert_eq!(\n+            result.to_string(),\n+            \"test\"\n+        );\n+\n+        let fragment = \"<svg><iframe>remove me</iframe></svg><iframe>keep me</iframe>\";\n+        let result = String::from(Builder::new().add_tags(&[\"iframe\"]).clean(fragment));\n+        assert_eq!(result.to_string(), \"remove me<iframe>keep me</iframe>\");\n+\n+        let fragment = \"<svg><a>remove me</a></svg><iframe>keep me</iframe>\";\n+        let result = String::from(Builder::new().add_tags(&[\"iframe\"]).clean(fragment));\n+        assert_eq!(result.to_string(), \"remove me<iframe>keep me</iframe>\");\n+\n+        let fragment = \"<svg><a>keep me</a></svg><iframe>keep me</iframe>\";\n+        let result = String::from(Builder::new().add_tags(&[\"iframe\", \"svg\"]).clean(fragment));\n+        assert_eq!(\n+            result.to_string(),\n+            \"<svg><a rel=\\\"noopener noreferrer\\\">keep me</a></svg><iframe>keep me</iframe>\"\n+        );\n+    }\n+\n+    #[test]\n+    fn ns_mathml() {\n+        // https://github.com/cure53/DOMPurify/pull/495\n+        let fragment = \"<mglyph></mglyph>\";\n+        let result = String::from(\n+            Builder::new()\n+                .add_tags(&[\"math\", \"mtext\", \"mglyph\"])\n+                .clean(fragment),\n+        );\n+        assert_eq!(result.to_string(), \"\");\n+        let fragment = \"<math><mtext><div><mglyph>\";\n+        let result = String::from(\n+            Builder::new()\n+                .add_tags(&[\"math\", \"mtext\", \"mglyph\"])\n+                .clean(fragment),\n+        );\n+        assert_eq!(\n+            result.to_string(),\n+            \"<math><mtext><div></div></mtext></math>\"\n+        );\n+        let fragment = \"<math><mtext><mglyph>\";\n+        let result = String::from(\n+            Builder::new()\n+                .add_tags(&[\"math\", \"mtext\", \"mglyph\"])\n+                .clean(fragment),\n+        );\n+        assert_eq!(\n+            result.to_string(),\n+            \"<math><mtext><mglyph></mglyph></mtext></math>\"\n+        );\n+    }\n+\n     #[test]\n     fn generic_attribute_prefixes() {\n         let prefix_data = [\"data-\"];\n",
    "diff_parsed": "{'added': [(1784, '            let pass_clean = self.clean_child(&mut node, url_base);'), (1785, '            let pass = pass_clean && self.check_expected_namespace(&parent, &node);'), (1977, '    fn check_expected_namespace(&self, parent: &Handle, child: &Handle) -> bool {'), (1978, '        let (parent, child) = match (&parent.data, &child.data) {'), (1979, '            (NodeData::Element { name: pn, .. }, NodeData::Element { name: cn, .. }) => (pn, cn),'), (1980, '            _ => return true,'), (1981, '        };'), (1983, '        if parent.ns == ns!(html) && child.ns == ns!(svg) {'), (1984, '            child.local == local_name!(\"svg\")'), (1986, '        } else if parent.ns == ns!(html) && child.ns == ns!(mathml) {'), (1987, '            child.local == local_name!(\"math\")'), (1989, '        } else if parent.ns == ns!(mathml) && child.ns != ns!(mathml) {'), (1991, '            matches!('), (1992, '                &*parent.local,'), (1993, '                \"mi\" | \"mo\" | \"mn\" | \"ms\" | \"mtext\" | \"annotation-xml\"'), (1994, '            )'), (1996, '        } else if parent.ns == ns!(svg) && child.ns != ns!(svg) {'), (1998, '            matches!(&*parent.local, \"foreignObject\")'), (1999, '        } else if child.ns == ns!(svg) {'), (2000, '            is_svg_tag(&*child.local)'), (2001, '        } else if child.ns == ns!(mathml) {'), (2002, '            is_mathml_tag(&*child.local)'), (2003, '        } else if child.ns == ns!(html) {'), (2004, '            (!is_svg_tag(&*child.local) && !is_mathml_tag(&*child.local))'), (2005, '                || matches!('), (2006, '                    &*child.local,'), (2007, '                    \"title\" | \"style\" | \"font\" | \"a\" | \"script\" | \"span\"'), (2008, '                )'), (2009, '        } else {'), (2011, '            parent.ns == child.ns'), (2012, '        }'), (2013, '    }'), (2174, 'fn is_svg_tag(element: &str) -> bool {'), (2176, '    match element {'), (2177, '        \"a\"'), (2178, '        | \"animate\"'), (2179, '        | \"animateMotion\"'), (2180, '        | \"animateTransform\"'), (2181, '        | \"circle\"'), (2182, '        | \"clipPath\"'), (2183, '        | \"defs\"'), (2184, '        | \"desc\"'), (2185, '        | \"discard\"'), (2186, '        | \"ellipse\"'), (2187, '        | \"feBlend\"'), (2188, '        | \"feColorMatrix\"'), (2189, '        | \"feComponentTransfer\"'), (2190, '        | \"feComposite\"'), (2191, '        | \"feConvolveMatrix\"'), (2192, '        | \"feDiffuseLighting\"'), (2193, '        | \"feDisplacementMap\"'), (2194, '        | \"feDistantLight\"'), (2195, '        | \"feDropShadow\"'), (2196, '        | \"feFlood\"'), (2197, '        | \"feFuncA\"'), (2198, '        | \"feFuncB\"'), (2199, '        | \"feFuncG\"'), (2200, '        | \"feFuncR\"'), (2201, '        | \"feGaussianBlur\"'), (2202, '        | \"feImage\"'), (2203, '        | \"feMerge\"'), (2204, '        | \"feMergeNode\"'), (2205, '        | \"feMorphology\"'), (2206, '        | \"feOffset\"'), (2207, '        | \"fePointLight\"'), (2208, '        | \"feSpecularLighting\"'), (2209, '        | \"feSpotLight\"'), (2210, '        | \"feTile\"'), (2211, '        | \"feTurbulence\"'), (2212, '        | \"filter\"'), (2213, '        | \"foreignObject\"'), (2214, '        | \"g\"'), (2215, '        | \"image\"'), (2216, '        | \"line\"'), (2217, '        | \"linearGradient\"'), (2218, '        | \"marker\"'), (2219, '        | \"mask\"'), (2220, '        | \"metadata\"'), (2221, '        | \"mpath\"'), (2222, '        | \"path\"'), (2223, '        | \"pattern\"'), (2224, '        | \"polygon\"'), (2225, '        | \"polyline\"'), (2226, '        | \"radialGradient\"'), (2227, '        | \"rect\"'), (2228, '        | \"script\"'), (2229, '        | \"set\"'), (2230, '        | \"stop\"'), (2231, '        | \"style\"'), (2232, '        | \"svg\"'), (2233, '        | \"switch\"'), (2234, '        | \"symbol\"'), (2235, '        | \"text\"'), (2236, '        | \"textPath\"'), (2237, '        | \"title\"'), (2238, '        | \"tspan\"'), (2239, '        | \"use\"'), (2240, '        | \"view\" => true,'), (2241, '        _ => false,'), (2242, '    }'), (2243, '}'), (2246, 'fn is_mathml_tag(element: &str) -> bool {'), (2248, '    match element {'), (2249, '        \"abs\"'), (2250, '        | \"and\"'), (2251, '        | \"annotation\"'), (2252, '        | \"annotation-xml\"'), (2253, '        | \"apply\"'), (2254, '        | \"approx\"'), (2255, '        | \"arccos\"'), (2256, '        | \"arccosh\"'), (2257, '        | \"arccot\"'), (2258, '        | \"arccoth\"'), (2259, '        | \"arccsc\"'), (2260, '        | \"arccsch\"'), (2261, '        | \"arcsec\"'), (2262, '        | \"arcsech\"'), (2263, '        | \"arcsin\"'), (2264, '        | \"arcsinh\"'), (2265, '        | \"arctan\"'), (2266, '        | \"arctanh\"'), (2267, '        | \"arg\"'), (2268, '        | \"bind\"'), (2269, '        | \"bvar\"'), (2270, '        | \"card\"'), (2271, '        | \"cartesianproduct\"'), (2272, '        | \"cbytes\"'), (2273, '        | \"ceiling\"'), (2274, '        | \"cerror\"'), (2275, '        | \"ci\"'), (2276, '        | \"cn\"'), (2277, '        | \"codomain\"'), (2278, '        | \"complexes\"'), (2279, '        | \"compose\"'), (2280, '        | \"condition\"'), (2281, '        | \"conjugate\"'), (2282, '        | \"cos\"'), (2283, '        | \"cosh\"'), (2284, '        | \"cot\"'), (2285, '        | \"coth\"'), (2286, '        | \"cs\"'), (2287, '        | \"csc\"'), (2288, '        | \"csch\"'), (2289, '        | \"csymbol\"'), (2290, '        | \"curl\"'), (2291, '        | \"declare\"'), (2292, '        | \"degree\"'), (2293, '        | \"determinant\"'), (2294, '        | \"diff\"'), (2295, '        | \"divergence\"'), (2296, '        | \"divide\"'), (2297, '        | \"domain\"'), (2298, '        | \"domainofapplication\"'), (2299, '        | \"emptyset\"'), (2300, '        | \"eq\"'), (2301, '        | \"equivalent\"'), (2302, '        | \"eulergamma\"'), (2303, '        | \"exists\"'), (2304, '        | \"exp\"'), (2305, '        | \"exponentiale\"'), (2306, '        | \"factorial\"'), (2307, '        | \"factorof\"'), (2308, '        | \"false\"'), (2309, '        | \"floor\"'), (2310, '        | \"fn\"'), (2311, '        | \"forall\"'), (2312, '        | \"gcd\"'), (2313, '        | \"geq\"'), (2314, '        | \"grad\"'), (2315, '        | \"gt\"'), (2316, '        | \"ident\"'), (2317, '        | \"image\"'), (2318, '        | \"imaginary\"'), (2319, '        | \"imaginaryi\"'), (2320, '        | \"implies\"'), (2321, '        | \"in\"'), (2322, '        | \"infinity\"'), (2323, '        | \"int\"'), (2324, '        | \"integers\"'), (2325, '        | \"intersect\"'), (2326, '        | \"interval\"'), (2327, '        | \"inverse\"'), (2328, '        | \"lambda\"'), (2329, '        | \"laplacian\"'), (2330, '        | \"lcm\"'), (2331, '        | \"leq\"'), (2332, '        | \"limit\"'), (2333, '        | \"list\"'), (2334, '        | \"ln\"'), (2335, '        | \"log\"'), (2336, '        | \"logbase\"'), (2337, '        | \"lowlimit\"'), (2338, '        | \"lt\"'), (2339, '        | \"maction\"'), (2340, '        | \"maligngroup\"'), (2341, '        | \"malignmark\"'), (2342, '        | \"math\"'), (2343, '        | \"matrix\"'), (2344, '        | \"matrixrow\"'), (2345, '        | \"max\"'), (2346, '        | \"mean\"'), (2347, '        | \"median\"'), (2348, '        | \"menclose\"'), (2349, '        | \"merror\"'), (2350, '        | \"mfenced\"'), (2351, '        | \"mfrac\"'), (2352, '        | \"mglyph\"'), (2353, '        | \"mi\"'), (2354, '        | \"min\"'), (2355, '        | \"minus\"'), (2356, '        | \"mlabeledtr\"'), (2357, '        | \"mlongdiv\"'), (2358, '        | \"mmultiscripts\"'), (2359, '        | \"mn\"'), (2360, '        | \"mo\"'), (2361, '        | \"mode\"'), (2362, '        | \"moment\"'), (2363, '        | \"momentabout\"'), (2364, '        | \"mover\"'), (2365, '        | \"mpadded\"'), (2366, '        | \"mphantom\"'), (2367, '        | \"mprescripts\"'), (2368, '        | \"mroot\"'), (2369, '        | \"mrow\"'), (2370, '        | \"ms\"'), (2371, '        | \"mscarries\"'), (2372, '        | \"mscarry\"'), (2373, '        | \"msgroup\"'), (2374, '        | \"msline\"'), (2375, '        | \"mspace\"'), (2376, '        | \"msqrt\"'), (2377, '        | \"msrow\"'), (2378, '        | \"mstack\"'), (2379, '        | \"mstyle\"'), (2380, '        | \"msub\"'), (2381, '        | \"msubsup\"'), (2382, '        | \"msup\"'), (2383, '        | \"mtable\"'), (2384, '        | \"mtd\"'), (2385, '        | \"mtext\"'), (2386, '        | \"mtr\"'), (2387, '        | \"munder\"'), (2388, '        | \"munderover\"'), (2389, '        | \"naturalnumbers\"'), (2390, '        | \"neq\"'), (2391, '        | \"none\"'), (2392, '        | \"not\"'), (2393, '        | \"notanumber\"'), (2394, '        | \"notin\"'), (2395, '        | \"notprsubset\"'), (2396, '        | \"notsubset\"'), (2397, '        | \"or\"'), (2398, '        | \"otherwise\"'), (2399, '        | \"outerproduct\"'), (2400, '        | \"partialdiff\"'), (2401, '        | \"pi\"'), (2402, '        | \"piece\"'), (2403, '        | \"piecewise\"'), (2404, '        | \"plus\"'), (2405, '        | \"power\"'), (2406, '        | \"primes\"'), (2407, '        | \"product\"'), (2408, '        | \"prsubset\"'), (2409, '        | \"quotient\"'), (2410, '        | \"rationals\"'), (2411, '        | \"real\"'), (2412, '        | \"reals\"'), (2413, '        | \"reln\"'), (2414, '        | \"rem\"'), (2415, '        | \"root\"'), (2416, '        | \"scalarproduct\"'), (2417, '        | \"sdev\"'), (2418, '        | \"sec\"'), (2419, '        | \"sech\"'), (2420, '        | \"selector\"'), (2421, '        | \"semantics\"'), (2422, '        | \"sep\"'), (2423, '        | \"set\"'), (2424, '        | \"setdiff\"'), (2425, '        | \"share\"'), (2426, '        | \"sin\"'), (2427, '        | \"sinh\"'), (2428, '        | \"span\"'), (2429, '        | \"subset\"'), (2430, '        | \"sum\"'), (2431, '        | \"tan\"'), (2432, '        | \"tanh\"'), (2433, '        | \"tendsto\"'), (2434, '        | \"times\"'), (2435, '        | \"transpose\"'), (2436, '        | \"true\"'), (2437, '        | \"union\"'), (2438, '        | \"uplimit\"'), (2439, '        | \"variance\"'), (2440, '        | \"vector\"'), (2441, '        | \"vectorproduct\"'), (2442, '        | \"xor\" => true,'), (2443, '        _ => false,'), (2444, '    }'), (2445, '}'), (2876, '                    \"{}\",'), (2877, '                    value.to_string()'), (3435, '    #[test]'), (3436, '    fn ns_svg() {'), (3438, '        let fragment = r##\"<svg><iframe><a title=\"</iframe><img src onerror=alert(1)>\">test\"##;'), (3439, '        let result = String::from(Builder::new().add_tags(&[\"iframe\"]).clean(fragment));'), (3440, '        assert_eq!('), (3441, '            result.to_string(),'), (3442, '            \"test\"'), (3443, '        );'), (3445, '        let fragment = \"<svg><iframe>remove me</iframe></svg><iframe>keep me</iframe>\";'), (3446, '        let result = String::from(Builder::new().add_tags(&[\"iframe\"]).clean(fragment));'), (3447, '        assert_eq!(result.to_string(), \"remove me<iframe>keep me</iframe>\");'), (3449, '        let fragment = \"<svg><a>remove me</a></svg><iframe>keep me</iframe>\";'), (3450, '        let result = String::from(Builder::new().add_tags(&[\"iframe\"]).clean(fragment));'), (3451, '        assert_eq!(result.to_string(), \"remove me<iframe>keep me</iframe>\");'), (3453, '        let fragment = \"<svg><a>keep me</a></svg><iframe>keep me</iframe>\";'), (3454, '        let result = String::from(Builder::new().add_tags(&[\"iframe\", \"svg\"]).clean(fragment));'), (3455, '        assert_eq!('), (3456, '            result.to_string(),'), (3457, '            \"<svg><a rel=\\\\\"noopener noreferrer\\\\\">keep me</a></svg><iframe>keep me</iframe>\"'), (3458, '        );'), (3459, '    }'), (3461, '    #[test]'), (3462, '    fn ns_mathml() {'), (3464, '        let fragment = \"<mglyph></mglyph>\";'), (3465, '        let result = String::from('), (3466, '            Builder::new()'), (3467, '                .add_tags(&[\"math\", \"mtext\", \"mglyph\"])'), (3468, '                .clean(fragment),'), (3469, '        );'), (3470, '        assert_eq!(result.to_string(), \"\");'), (3471, '        let fragment = \"<math><mtext><div><mglyph>\";'), (3472, '        let result = String::from('), (3473, '            Builder::new()'), (3474, '                .add_tags(&[\"math\", \"mtext\", \"mglyph\"])'), (3475, '                .clean(fragment),'), (3476, '        );'), (3477, '        assert_eq!('), (3478, '            result.to_string(),'), (3479, '            \"<math><mtext><div></div></mtext></math>\"'), (3480, '        );'), (3481, '        let fragment = \"<math><mtext><mglyph>\";'), (3482, '        let result = String::from('), (3483, '            Builder::new()'), (3484, '                .add_tags(&[\"math\", \"mtext\", \"mglyph\"])'), (3485, '                .clean(fragment),'), (3486, '        );'), (3487, '        assert_eq!('), (3488, '            result.to_string(),'), (3489, '            \"<math><mtext><mglyph></mglyph></mtext></math>\"'), (3490, '        );'), (3491, '    }')], 'deleted': [(1784, '            let pass = self.clean_child(&mut node, url_base);'), (2482, '                    \"{}\", value.to_string()')]}",
    "num_lines_added": "353",
    "num_lines_deleted": "2",
    "nloc": "2639"
  },
  {
    "file_change_id": "204417078166784",
    "hash": "582b6221887e92aeab1ac9008c75133974ed939",
    "old_path": "parc/src/lib.rs",
    "new_path": "parc/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -380,7 +380,7 @@ impl<T> LockWeak<T> {\n     }\n }\n \n-unsafe impl<T> Send for LockWeak<T> {}\n+unsafe impl<T: Sync> Send for LockWeak<T> {}\n \n /// Unclonable owned reference to a [`ParentArc`](struct.ParentArc.html).\n ///\n",
    "diff_parsed": "{'added': [(383, 'unsafe impl<T: Sync> Send for LockWeak<T> {}')], 'deleted': [(383, 'unsafe impl<T> Send for LockWeak<T> {}')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "309"
  },
  {
    "file_change_id": "243018059384384",
    "hash": "813a329f11b4901f962d89fe340004bb32129ac",
    "old_path": "src/net.rs",
    "new_path": "src/net.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -13,6 +13,8 @@ use std::sync::atomic::{AtomicUsize, Ordering};\n \n use winapi::ctypes::*;\n use winapi::shared::guiddef::*;\n+use winapi::shared::in6addr::{in6_addr_u, IN6_ADDR};\n+use winapi::shared::inaddr::{in_addr_S_un, IN_ADDR};\n use winapi::shared::minwindef::*;\n use winapi::shared::minwindef::{FALSE, TRUE};\n use winapi::shared::ntdef::*;\n@@ -456,16 +458,64 @@ fn cvt(i: c_int, size: DWORD) -> io::Result<Option<usize>> {\n     }\n }\n \n-fn socket_addr_to_ptrs(addr: &SocketAddr) -> (*const SOCKADDR, c_int) {\n+/// A type with the same memory layout as `SOCKADDR`. Used in converting Rust level\n+/// SocketAddr* types into their system representation. The benefit of this specific\n+/// type over using `SOCKADDR_STORAGE` is that this type is exactly as large as it\n+/// needs to be and not a lot larger. And it can be initialized cleaner from Rust.\n+#[repr(C)]\n+pub(crate) union SocketAddrCRepr {\n+    v4: SOCKADDR_IN,\n+    v6: SOCKADDR_IN6_LH,\n+}\n+\n+impl SocketAddrCRepr {\n+    pub(crate) fn as_ptr(&self) -> *const SOCKADDR {\n+        self as *const _ as *const SOCKADDR\n+    }\n+}\n+\n+fn socket_addr_to_ptrs(addr: &SocketAddr) -> (SocketAddrCRepr, c_int) {\n     match *addr {\n-        SocketAddr::V4(ref a) => (\n-            a as *const _ as *const _,\n-            mem::size_of::<SOCKADDR_IN>() as c_int,\n-        ),\n-        SocketAddr::V6(ref a) => (\n-            a as *const _ as *const _,\n-            mem::size_of::<SOCKADDR_IN6_LH>() as c_int,\n-        ),\n+        SocketAddr::V4(ref a) => {\n+            let sin_addr = unsafe {\n+                let mut s_un = mem::zeroed::<in_addr_S_un>();\n+                *s_un.S_addr_mut() = u32::from_ne_bytes(a.ip().octets());\n+                IN_ADDR { S_un: s_un }\n+            };\n+\n+            let sockaddr_in = SOCKADDR_IN {\n+                sin_family: AF_INET as ADDRESS_FAMILY,\n+                sin_port: a.port().to_be(),\n+                sin_addr,\n+                sin_zero: [0; 8],\n+            };\n+\n+            let sockaddr = SocketAddrCRepr { v4: sockaddr_in };\n+            (sockaddr, mem::size_of::<SOCKADDR_IN>() as c_int)\n+        }\n+        SocketAddr::V6(ref a) => {\n+            let sin6_addr = unsafe {\n+                let mut u = mem::zeroed::<in6_addr_u>();\n+                *u.Byte_mut() = a.ip().octets();\n+                IN6_ADDR { u }\n+            };\n+            let u = unsafe {\n+                let mut u = mem::zeroed::<SOCKADDR_IN6_LH_u>();\n+                *u.sin6_scope_id_mut() = a.scope_id();\n+                u\n+            };\n+\n+            let sockaddr_in6 = SOCKADDR_IN6_LH {\n+                sin6_family: AF_INET6 as ADDRESS_FAMILY,\n+                sin6_port: a.port().to_be(),\n+                sin6_addr,\n+                sin6_flowinfo: a.flowinfo(),\n+                u,\n+            };\n+\n+            let sockaddr = SocketAddrCRepr { v6: sockaddr_in6 };\n+            (sockaddr, mem::size_of::<SOCKADDR_IN6_LH>() as c_int)\n+        }\n     }\n }\n \n@@ -650,7 +700,7 @@ unsafe fn connect_overlapped(\n     let mut bytes_sent: DWORD = 0;\n     let r = connect_ex(\n         socket,\n-        addr_buf,\n+        addr_buf.as_ptr(),\n         addr_len,\n         buf.as_ptr() as *mut _,\n         buf.len() as u32,\n@@ -723,7 +773,7 @@ impl UdpSocketExt for UdpSocket {\n             1,\n             &mut sent_bytes,\n             0,\n-            addr_buf as *const _,\n+            addr_buf.as_ptr() as *const _,\n             addr_len,\n             overlapped,\n             None,\n",
    "diff_parsed": "{'added': [(16, 'use winapi::shared::in6addr::{in6_addr_u, IN6_ADDR};'), (17, 'use winapi::shared::inaddr::{in_addr_S_un, IN_ADDR};'), (465, '#[repr(C)]'), (466, 'pub(crate) union SocketAddrCRepr {'), (467, '    v4: SOCKADDR_IN,'), (468, '    v6: SOCKADDR_IN6_LH,'), (469, '}'), (471, 'impl SocketAddrCRepr {'), (472, '    pub(crate) fn as_ptr(&self) -> *const SOCKADDR {'), (473, '        self as *const _ as *const SOCKADDR'), (474, '    }'), (475, '}'), (477, 'fn socket_addr_to_ptrs(addr: &SocketAddr) -> (SocketAddrCRepr, c_int) {'), (479, '        SocketAddr::V4(ref a) => {'), (480, '            let sin_addr = unsafe {'), (481, '                let mut s_un = mem::zeroed::<in_addr_S_un>();'), (482, '                *s_un.S_addr_mut() = u32::from_ne_bytes(a.ip().octets());'), (483, '                IN_ADDR { S_un: s_un }'), (484, '            };'), (486, '            let sockaddr_in = SOCKADDR_IN {'), (487, '                sin_family: AF_INET as ADDRESS_FAMILY,'), (488, '                sin_port: a.port().to_be(),'), (489, '                sin_addr,'), (490, '                sin_zero: [0; 8],'), (491, '            };'), (493, '            let sockaddr = SocketAddrCRepr { v4: sockaddr_in };'), (494, '            (sockaddr, mem::size_of::<SOCKADDR_IN>() as c_int)'), (495, '        }'), (496, '        SocketAddr::V6(ref a) => {'), (497, '            let sin6_addr = unsafe {'), (498, '                let mut u = mem::zeroed::<in6_addr_u>();'), (499, '                *u.Byte_mut() = a.ip().octets();'), (500, '                IN6_ADDR { u }'), (501, '            };'), (502, '            let u = unsafe {'), (503, '                let mut u = mem::zeroed::<SOCKADDR_IN6_LH_u>();'), (504, '                *u.sin6_scope_id_mut() = a.scope_id();'), (505, '                u'), (506, '            };'), (508, '            let sockaddr_in6 = SOCKADDR_IN6_LH {'), (509, '                sin6_family: AF_INET6 as ADDRESS_FAMILY,'), (510, '                sin6_port: a.port().to_be(),'), (511, '                sin6_addr,'), (512, '                sin6_flowinfo: a.flowinfo(),'), (513, '                u,'), (514, '            };'), (516, '            let sockaddr = SocketAddrCRepr { v6: sockaddr_in6 };'), (517, '            (sockaddr, mem::size_of::<SOCKADDR_IN6_LH>() as c_int)'), (518, '        }'), (703, '        addr_buf.as_ptr(),'), (776, '            addr_buf.as_ptr() as *const _,')], 'deleted': [(459, 'fn socket_addr_to_ptrs(addr: &SocketAddr) -> (*const SOCKADDR, c_int) {'), (461, '        SocketAddr::V4(ref a) => ('), (462, '            a as *const _ as *const _,'), (463, '            mem::size_of::<SOCKADDR_IN>() as c_int,'), (464, '        ),'), (465, '        SocketAddr::V6(ref a) => ('), (466, '            a as *const _ as *const _,'), (467, '            mem::size_of::<SOCKADDR_IN6_LH>() as c_int,'), (468, '        ),'), (653, '        addr_buf,'), (726, '            addr_buf as *const _,')]}",
    "num_lines_added": "51",
    "num_lines_deleted": "11",
    "nloc": "876"
  },
  {
    "file_change_id": "60385310024988",
    "hash": "2783715269d56a0020160179c0f2ba883d12d87",
    "old_path": "src/net.rs",
    "new_path": "src/net.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -13,6 +13,8 @@ use std::os::windows::prelude::*;\n \n use net2::TcpBuilder;\n use winapi::*;\n+use winapi::shared::inaddr::{in_addr_S_un, IN_ADDR};\n+use winapi::shared::in6addr::{in6_addr_u, IN6_ADDR};\n use ws2_32::*;\n \n /// A type to represent a buffer in which a socket address will be stored.\n@@ -478,13 +480,63 @@ fn cvt(i: c_int, size: DWORD) -> io::Result<Option<usize>> {\n     }\n }\n \n-fn socket_addr_to_ptrs(addr: &SocketAddr) -> (*const SOCKADDR, c_int) {\n+/// A type with the same memory layout as `SOCKADDR`. Used in converting Rust level\n+/// SocketAddr* types into their system representation. The benefit of this specific\n+/// type over using `SOCKADDR_STORAGE` is that this type is exactly as large as it\n+/// needs to be and not a lot larger. And it can be initialized cleaner from Rust.\n+#[repr(C)]\n+pub(crate) union SocketAddrCRepr {\n+    v4: SOCKADDR_IN,\n+    v6: SOCKADDR_IN6_LH,\n+}\n+\n+impl SocketAddrCRepr {\n+    pub(crate) fn as_ptr(&self) -> *const SOCKADDR {\n+        self as *const _ as *const SOCKADDR\n+    }\n+}\n+\n+fn socket_addr_to_ptrs(addr: &SocketAddr) -> (SocketAddrCRepr, c_int) {\n     match *addr {\n         SocketAddr::V4(ref a) => {\n-            (a as *const _ as *const _, mem::size_of::<SOCKADDR_IN>() as c_int)\n+            let sin_addr = unsafe {\n+                let mut s_un = mem::zeroed::<in_addr_S_un>();\n+                *s_un.S_addr_mut() = u32::from_ne_bytes(a.ip().octets());\n+                IN_ADDR { S_un: s_un }\n+            };\n+\n+            let sockaddr_in = SOCKADDR_IN {\n+                sin_family: AF_INET as ADDRESS_FAMILY,\n+                sin_port: a.port().to_be(),\n+                sin_addr,\n+                sin_zero: [0; 8],\n+            };\n+\n+            let sockaddr = SocketAddrCRepr { v4: sockaddr_in };\n+            (sockaddr, mem::size_of::<SOCKADDR_IN>() as c_int)\n         }\n         SocketAddr::V6(ref a) => {\n-            (a as *const _ as *const _, mem::size_of::<sockaddr_in6>() as c_int)\n+            let sin6_addr = unsafe {\n+                let mut u = mem::zeroed::<in6_addr_u>();\n+                *u.Byte_mut() = a.ip().octets();\n+                IN6_ADDR { u }\n+            };\n+            let u = unsafe {\n+                let mut u = mem::zeroed::<SOCKADDR_IN6_LH_u>();\n+                *u.sin6_scope_id_mut() = a.scope_id();\n+                u\n+            };\n+\n+            let sockaddr_in6 = SOCKADDR_IN6_LH {\n+                sin6_family: AF_INET6 as ADDRESS_FAMILY,\n+                sin6_port: a.port().to_be(),\n+                sin6_addr,\n+                sin6_flowinfo: a.flowinfo(),\n+                u,\n+            };\n+\n+            let sockaddr = SocketAddrCRepr { v6: sockaddr_in6 };\n+            (sockaddr, mem::size_of::<SOCKADDR_IN6_LH>() as c_int)\n         }\n     }\n }\n@@ -643,7 +695,7 @@ unsafe fn connect_overlapped(socket: SOCKET,\n \n     let (addr_buf, addr_len) = socket_addr_to_ptrs(addr);\n     let mut bytes_sent: DWORD = 0;\n-    let r = connect_ex(socket, addr_buf, addr_len,\n+    let r = connect_ex(socket, addr_buf.as_ptr(), addr_len,\n                        buf.as_ptr() as *mut _,\n                        buf.len() as u32,\n                        &mut bytes_sent, overlapped);\n@@ -694,7 +746,7 @@ impl UdpSocketExt for UdpSocket {\n         let mut sent_bytes = 0;\n         let r = WSASendTo(self.as_raw_socket(), &mut buf, 1,\n                           &mut sent_bytes, 0,\n-                          addr_buf as *const _, addr_len,\n+                          addr_buf.as_ptr() as *const _, addr_len,\n                           overlapped, None);\n         cvt(r, sent_bytes)\n     }\n",
    "diff_parsed": "{'added': [(16, 'use winapi::shared::inaddr::{in_addr_S_un, IN_ADDR};'), (17, 'use winapi::shared::in6addr::{in6_addr_u, IN6_ADDR};'), (487, '#[repr(C)]'), (488, 'pub(crate) union SocketAddrCRepr {'), (489, '    v4: SOCKADDR_IN,'), (490, '    v6: SOCKADDR_IN6_LH,'), (491, '}'), (493, 'impl SocketAddrCRepr {'), (494, '    pub(crate) fn as_ptr(&self) -> *const SOCKADDR {'), (495, '        self as *const _ as *const SOCKADDR'), (496, '    }'), (497, '}'), (499, 'fn socket_addr_to_ptrs(addr: &SocketAddr) -> (SocketAddrCRepr, c_int) {'), (502, '            let sin_addr = unsafe {'), (503, '                let mut s_un = mem::zeroed::<in_addr_S_un>();'), (504, '                *s_un.S_addr_mut() = u32::from_ne_bytes(a.ip().octets());'), (505, '                IN_ADDR { S_un: s_un }'), (506, '            };'), (508, '            let sockaddr_in = SOCKADDR_IN {'), (509, '                sin_family: AF_INET as ADDRESS_FAMILY,'), (510, '                sin_port: a.port().to_be(),'), (511, '                sin_addr,'), (512, '                sin_zero: [0; 8],'), (513, '            };'), (515, '            let sockaddr = SocketAddrCRepr { v4: sockaddr_in };'), (516, '            (sockaddr, mem::size_of::<SOCKADDR_IN>() as c_int)'), (519, '            let sin6_addr = unsafe {'), (520, '                let mut u = mem::zeroed::<in6_addr_u>();'), (521, '                *u.Byte_mut() = a.ip().octets();'), (522, '                IN6_ADDR { u }'), (523, '            };'), (524, '            let u = unsafe {'), (525, '                let mut u = mem::zeroed::<SOCKADDR_IN6_LH_u>();'), (526, '                *u.sin6_scope_id_mut() = a.scope_id();'), (527, '                u'), (528, '            };'), (530, '            let sockaddr_in6 = SOCKADDR_IN6_LH {'), (531, '                sin6_family: AF_INET6 as ADDRESS_FAMILY,'), (532, '                sin6_port: a.port().to_be(),'), (533, '                sin6_addr,'), (534, '                sin6_flowinfo: a.flowinfo(),'), (535, '                u,'), (536, '            };'), (538, '            let sockaddr = SocketAddrCRepr { v6: sockaddr_in6 };'), (539, '            (sockaddr, mem::size_of::<SOCKADDR_IN6_LH>() as c_int)'), (698, '    let r = connect_ex(socket, addr_buf.as_ptr(), addr_len,'), (749, '                          addr_buf.as_ptr() as *const _, addr_len,')], 'deleted': [(481, 'fn socket_addr_to_ptrs(addr: &SocketAddr) -> (*const SOCKADDR, c_int) {'), (484, '            (a as *const _ as *const _, mem::size_of::<SOCKADDR_IN>() as c_int)'), (487, '            (a as *const _ as *const _, mem::size_of::<sockaddr_in6>() as c_int)'), (646, '    let r = connect_ex(socket, addr_buf, addr_len,'), (697, '                          addr_buf as *const _, addr_len,')]}",
    "num_lines_added": "47",
    "num_lines_deleted": "5",
    "nloc": "758"
  },
  {
    "file_change_id": "90851717272224",
    "hash": "27b77cc870b922d305015841978b581ceb18e3b",
    "old_path": "src/net.rs",
    "new_path": "src/net.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -13,8 +13,9 @@ use std::os::windows::prelude::*;\n \n use net2::TcpBuilder;\n use winapi::*;\n-use winapi::shared::inaddr::{in_addr_S_un, IN_ADDR};\n-use winapi::shared::in6addr::{in6_addr_u, IN6_ADDR};\n+use winapi::inaddr::IN_ADDR;\n+use winapi::ws2def::SOCKADDR_IN;\n+use winapi::ws2ipdef::{in6_addr, sockaddr_in6};\n use ws2_32::*;\n \n /// A type to represent a buffer in which a socket address will be stored.\n@@ -487,7 +488,7 @@ fn cvt(i: c_int, size: DWORD) -> io::Result<Option<usize>> {\n #[repr(C)]\n pub(crate) union SocketAddrCRepr {\n     v4: SOCKADDR_IN,\n-    v6: SOCKADDR_IN6_LH,\n+    v6: sockaddr_in6,\n }\n \n impl SocketAddrCRepr {\n@@ -499,16 +500,10 @@ impl SocketAddrCRepr {\n fn socket_addr_to_ptrs(addr: &SocketAddr) -> (SocketAddrCRepr, c_int) {\n     match *addr {\n         SocketAddr::V4(ref a) => {\n-            let sin_addr = unsafe {\n-                let mut s_un = mem::zeroed::<in_addr_S_un>();\n-                *s_un.S_addr_mut() = u32::from_ne_bytes(a.ip().octets());\n-                IN_ADDR { S_un: s_un }\n-            };\n-\n             let sockaddr_in = SOCKADDR_IN {\n                 sin_family: AF_INET as ADDRESS_FAMILY,\n                 sin_port: a.port().to_be(),\n-                sin_addr,\n+                sin_addr: IN_ADDR { S_un: u32::from_ne_bytes(a.ip().octets()) },\n                 sin_zero: [0; 8],\n             };\n \n@@ -516,27 +511,16 @@ fn socket_addr_to_ptrs(addr: &SocketAddr) -> (SocketAddrCRepr, c_int) {\n             (sockaddr, mem::size_of::<SOCKADDR_IN>() as c_int)\n         }\n         SocketAddr::V6(ref a) => {\n-            let sin6_addr = unsafe {\n-                let mut u = mem::zeroed::<in6_addr_u>();\n-                *u.Byte_mut() = a.ip().octets();\n-                IN6_ADDR { u }\n-            };\n-            let u = unsafe {\n-                let mut u = mem::zeroed::<SOCKADDR_IN6_LH_u>();\n-                *u.sin6_scope_id_mut() = a.scope_id();\n-                u\n-            };\n-\n-            let sockaddr_in6 = SOCKADDR_IN6_LH {\n-                sin6_family: AF_INET6 as ADDRESS_FAMILY,\n+            let sockaddr_in6 = sockaddr_in6 {\n+                sin6_family: AF_INET6 as i16,\n                 sin6_port: a.port().to_be(),\n-                sin6_addr,\n+                sin6_addr: in6_addr { s6_addr: a.ip().octets() },\n                 sin6_flowinfo: a.flowinfo(),\n-                u,\n+                sin6_scope_id: a.scope_id(),\n             };\n \n             let sockaddr = SocketAddrCRepr { v6: sockaddr_in6 };\n-            (sockaddr, mem::size_of::<SOCKADDR_IN6_LH>() as c_int)\n+            (sockaddr, mem::size_of::<sockaddr_in6>() as c_int)\n         }\n     }\n }\n",
    "diff_parsed": "{'added': [(16, 'use winapi::inaddr::IN_ADDR;'), (17, 'use winapi::ws2def::SOCKADDR_IN;'), (18, 'use winapi::ws2ipdef::{in6_addr, sockaddr_in6};'), (491, '    v6: sockaddr_in6,'), (506, '                sin_addr: IN_ADDR { S_un: u32::from_ne_bytes(a.ip().octets()) },'), (514, '            let sockaddr_in6 = sockaddr_in6 {'), (515, '                sin6_family: AF_INET6 as i16,'), (517, '                sin6_addr: in6_addr { s6_addr: a.ip().octets() },'), (519, '                sin6_scope_id: a.scope_id(),'), (523, '            (sockaddr, mem::size_of::<sockaddr_in6>() as c_int)')], 'deleted': [(16, 'use winapi::shared::inaddr::{in_addr_S_un, IN_ADDR};'), (17, 'use winapi::shared::in6addr::{in6_addr_u, IN6_ADDR};'), (490, '    v6: SOCKADDR_IN6_LH,'), (502, '            let sin_addr = unsafe {'), (503, '                let mut s_un = mem::zeroed::<in_addr_S_un>();'), (504, '                *s_un.S_addr_mut() = u32::from_ne_bytes(a.ip().octets());'), (505, '                IN_ADDR { S_un: s_un }'), (506, '            };'), (511, '                sin_addr,'), (519, '            let sin6_addr = unsafe {'), (520, '                let mut u = mem::zeroed::<in6_addr_u>();'), (521, '                *u.Byte_mut() = a.ip().octets();'), (522, '                IN6_ADDR { u }'), (523, '            };'), (524, '            let u = unsafe {'), (525, '                let mut u = mem::zeroed::<SOCKADDR_IN6_LH_u>();'), (526, '                *u.sin6_scope_id_mut() = a.scope_id();'), (527, '                u'), (528, '            };'), (530, '            let sockaddr_in6 = SOCKADDR_IN6_LH {'), (531, '                sin6_family: AF_INET6 as ADDRESS_FAMILY,'), (533, '                sin6_addr,'), (535, '                u,'), (539, '            (sockaddr, mem::size_of::<SOCKADDR_IN6_LH>() as c_int)')]}",
    "num_lines_added": "10",
    "num_lines_deleted": "24",
    "nloc": "744"
  },
  {
    "file_change_id": "127426847091038",
    "hash": "043d5f0e4200b9bafc083997cc7bbf2c1bef91d",
    "old_path": "src/windows/mod.rs",
    "new_path": "src/windows/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -6,7 +6,6 @@ use std::borrow::Cow;\n use std::char;\n use std::ffi::OsStr;\n use std::ffi::OsString;\n-use std::mem;\n use std::os::windows::ffi::OsStrExt;\n use std::os::windows::ffi::OsStringExt;\n \n@@ -17,6 +16,73 @@ use crate::OsStringBytes;\n #[allow(clippy::module_inception)]\n mod imp;\n \n+// UTF-8 ranges and tags for encoding characters\n+// From Rust's libcore/char/mod.rs\n+const TAG_CONT: u8 = 0b1000_0000;\n+const TAG_TWO_B: u8 = 0b1100_0000;\n+const TAG_THREE_B: u8 = 0b1110_0000;\n+const TAG_FOUR_B: u8 = 0b1111_0000;\n+const MAX_ONE_B: u32 = 0x80;\n+const MAX_TWO_B: u32 = 0x800;\n+const MAX_THREE_B: u32 = 0x10000;\n+\n+// From Rust's libcore/char/methods.rs (char::len_utf8)\n+fn len_wtf8(code: u32) -> usize {\n+    if code < MAX_ONE_B {\n+        1\n+    } else if code < MAX_TWO_B {\n+        2\n+    } else if code < MAX_THREE_B {\n+        3\n+    } else {\n+        4\n+    }\n+}\n+\n+// From Rust's libcore/char/methods.rs (char::encode_utf8)\n+fn encode_wtf8(code: u32, dst: &mut [u8]) -> &mut [u8] {\n+    let len = len_wtf8(code);\n+    match (len, &mut dst[..]) {\n+        (1, [a, ..]) => {\n+            *a = code as u8;\n+        }\n+        (2, [a, b, ..]) => {\n+            *a = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;\n+            *b = (code & 0x3F) as u8 | TAG_CONT;\n+        }\n+        (3, [a, b, c, ..]) => {\n+            *a = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;\n+            *b = (code >> 6 & 0x3F) as u8 | TAG_CONT;\n+            *c = (code & 0x3F) as u8 | TAG_CONT;\n+        }\n+        (4, [a, b, c, d, ..]) => {\n+            *a = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;\n+            *b = (code >> 12 & 0x3F) as u8 | TAG_CONT;\n+            *c = (code >> 6 & 0x3F) as u8 | TAG_CONT;\n+            *d = (code & 0x3F) as u8 | TAG_CONT;\n+        }\n+        _ => unreachable!(),\n+    };\n+    &mut dst[..len]\n+}\n+\n+// From Rust's libcore/char/methods.rs (char::encode_utf16)\n+fn encode_wide(mut code: u32, dst: &mut [u16]) -> &mut [u16] {\n+    if (code & 0xFFFF) == code && !dst.is_empty() {\n+        // The BMP falls through (assuming non-surrogate, as it should)\n+        dst[0] = code as u16;\n+        &mut dst[..1]\n+    } else if dst.len() >= 2 {\n+        // Supplementary planes break into surrogates.\n+        code -= 0x1_0000;\n+        dst[0] = 0xD800 | ((code >> 10) as u16);\n+        dst[1] = 0xDC00 | ((code as u16) & 0x3FF);\n+        dst\n+    } else {\n+        unreachable!()\n+    }\n+}\n+\n fn wide_to_wtf8<TString>(encoded_string: TString, length: usize) -> Vec<u8>\n where\n     TString: IntoIterator<Item = u16>,\n@@ -24,17 +90,12 @@ where\n     // https://github.com/rust-lang/rust/blob/49c68bd53f90e375bfb3cbba8c1c67a9e0adb9c0/src/libstd/sys_common/wtf8.rs#L183-L199\n \n     let mut string = Vec::with_capacity(length);\n-    let mut buffer = [0; mem::size_of::<char>()];\n+    let mut buffer = [0; 4];\n     for ch in char::decode_utf16(encoded_string) {\n-        let unchecked_char = ch.unwrap_or_else(|surrogate| {\n-            let surrogate = surrogate.unpaired_surrogate().into();\n-            debug_assert!(surrogate <= u32::from(char::MAX));\n-            // SAFETY: https://docs.rs/os_str_bytes/#safety\n-            unsafe { char::from_u32_unchecked(surrogate) }\n-        });\n-        string.extend_from_slice(\n-            unchecked_char.encode_utf8(&mut buffer).as_bytes(),\n-        );\n+        let ch = ch\n+            .map(u32::from)\n+            .unwrap_or_else(|surrogate| surrogate.unpaired_surrogate().into());\n+        string.extend_from_slice(encode_wtf8(ch, &mut buffer));\n     }\n     debug_assert_eq!(string.len(), length);\n     string\n@@ -47,11 +108,7 @@ fn wtf8_to_wide(string: &[u8]) -> Vec<u16> {\n     let mut encoded_string = Vec::new();\n     let mut buffer = [0; 2];\n     while let Some(code_point) = imp::next_code_point(&mut string) {\n-        debug_assert!(code_point <= u32::from(char::MAX));\n-        // SAFETY: https://docs.rs/os_str_bytes/#safety\n-        let unchecked_char = unsafe { char::from_u32_unchecked(code_point) };\n-        encoded_string\n-            .extend_from_slice(unchecked_char.encode_utf16(&mut buffer));\n+        encoded_string.extend_from_slice(encode_wide(code_point, &mut buffer));\n     }\n     encoded_string\n }\n",
    "diff_parsed": "{'added': [(21, 'const TAG_CONT: u8 = 0b1000_0000;'), (22, 'const TAG_TWO_B: u8 = 0b1100_0000;'), (23, 'const TAG_THREE_B: u8 = 0b1110_0000;'), (24, 'const TAG_FOUR_B: u8 = 0b1111_0000;'), (25, 'const MAX_ONE_B: u32 = 0x80;'), (26, 'const MAX_TWO_B: u32 = 0x800;'), (27, 'const MAX_THREE_B: u32 = 0x10000;'), (30, 'fn len_wtf8(code: u32) -> usize {'), (31, '    if code < MAX_ONE_B {'), (32, '        1'), (33, '    } else if code < MAX_TWO_B {'), (34, '        2'), (35, '    } else if code < MAX_THREE_B {'), (36, '        3'), (37, '    } else {'), (38, '        4'), (39, '    }'), (40, '}'), (43, 'fn encode_wtf8(code: u32, dst: &mut [u8]) -> &mut [u8] {'), (44, '    let len = len_wtf8(code);'), (45, '    match (len, &mut dst[..]) {'), (46, '        (1, [a, ..]) => {'), (47, '            *a = code as u8;'), (48, '        }'), (49, '        (2, [a, b, ..]) => {'), (50, '            *a = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;'), (51, '            *b = (code & 0x3F) as u8 | TAG_CONT;'), (52, '        }'), (53, '        (3, [a, b, c, ..]) => {'), (54, '            *a = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;'), (55, '            *b = (code >> 6 & 0x3F) as u8 | TAG_CONT;'), (56, '            *c = (code & 0x3F) as u8 | TAG_CONT;'), (57, '        }'), (58, '        (4, [a, b, c, d, ..]) => {'), (59, '            *a = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;'), (60, '            *b = (code >> 12 & 0x3F) as u8 | TAG_CONT;'), (61, '            *c = (code >> 6 & 0x3F) as u8 | TAG_CONT;'), (62, '            *d = (code & 0x3F) as u8 | TAG_CONT;'), (63, '        }'), (64, '        _ => unreachable!(),'), (65, '    };'), (66, '    &mut dst[..len]'), (67, '}'), (70, 'fn encode_wide(mut code: u32, dst: &mut [u16]) -> &mut [u16] {'), (71, '    if (code & 0xFFFF) == code && !dst.is_empty() {'), (73, '        dst[0] = code as u16;'), (74, '        &mut dst[..1]'), (75, '    } else if dst.len() >= 2 {'), (77, '        code -= 0x1_0000;'), (78, '        dst[0] = 0xD800 | ((code >> 10) as u16);'), (79, '        dst[1] = 0xDC00 | ((code as u16) & 0x3FF);'), (80, '        dst'), (81, '    } else {'), (82, '        unreachable!()'), (83, '    }'), (84, '}'), (93, '    let mut buffer = [0; 4];'), (95, '        let ch = ch'), (96, '            .map(u32::from)'), (97, '            .unwrap_or_else(|surrogate| surrogate.unpaired_surrogate().into());'), (98, '        string.extend_from_slice(encode_wtf8(ch, &mut buffer));'), (111, '        encoded_string.extend_from_slice(encode_wide(code_point, &mut buffer));')], 'deleted': [(9, 'use std::mem;'), (27, '    let mut buffer = [0; mem::size_of::<char>()];'), (29, '        let unchecked_char = ch.unwrap_or_else(|surrogate| {'), (30, '            let surrogate = surrogate.unpaired_surrogate().into();'), (31, '            debug_assert!(surrogate <= u32::from(char::MAX));'), (33, '            unsafe { char::from_u32_unchecked(surrogate) }'), (34, '        });'), (35, '        string.extend_from_slice('), (36, '            unchecked_char.encode_utf8(&mut buffer).as_bytes(),'), (37, '        );'), (50, '        debug_assert!(code_point <= u32::from(char::MAX));'), (52, '        let unchecked_char = unsafe { char::from_u32_unchecked(code_point) };'), (53, '        encoded_string'), (54, '            .extend_from_slice(unchecked_char.encode_utf16(&mut buffer));')]}",
    "num_lines_added": "62",
    "num_lines_deleted": "14",
    "nloc": "167"
  },
  {
    "file_change_id": "31892449503751",
    "hash": "fd4bd03686c476efcc9d758e234f0bdf1732e7d",
    "old_path": "src/windows/mod.rs",
    "new_path": "src/windows/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -42,24 +42,24 @@ fn len_wtf8(code: u32) -> usize {\n // From Rust's libcore/char/methods.rs (char::encode_utf8)\n fn encode_wtf8(code: u32, dst: &mut [u8]) -> &mut [u8] {\n     let len = len_wtf8(code);\n-    match (len, &mut dst[..]) {\n-        (1, [a, ..]) => {\n-            *a = code as u8;\n+    match len {\n+        1 => {\n+            dst[0] = code as u8;\n         }\n-        (2, [a, b, ..]) => {\n-            *a = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;\n-            *b = (code & 0x3F) as u8 | TAG_CONT;\n+        2 => {\n+            dst[0] = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;\n+            dst[1] = (code & 0x3F) as u8 | TAG_CONT;\n         }\n-        (3, [a, b, c, ..]) => {\n-            *a = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;\n-            *b = (code >> 6 & 0x3F) as u8 | TAG_CONT;\n-            *c = (code & 0x3F) as u8 | TAG_CONT;\n+        3 => {\n+            dst[0] = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;\n+            dst[1] = (code >> 6 & 0x3F) as u8 | TAG_CONT;\n+            dst[2] = (code & 0x3F) as u8 | TAG_CONT;\n         }\n-        (4, [a, b, c, d, ..]) => {\n-            *a = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;\n-            *b = (code >> 12 & 0x3F) as u8 | TAG_CONT;\n-            *c = (code >> 6 & 0x3F) as u8 | TAG_CONT;\n-            *d = (code & 0x3F) as u8 | TAG_CONT;\n+        4 => {\n+            dst[0] = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;\n+            dst[1] = (code >> 12 & 0x3F) as u8 | TAG_CONT;\n+            dst[2] = (code >> 6 & 0x3F) as u8 | TAG_CONT;\n+            dst[3] = (code & 0x3F) as u8 | TAG_CONT;\n         }\n         _ => unreachable!(),\n     };\n",
    "diff_parsed": "{'added': [(45, '    match len {'), (46, '        1 => {'), (47, '            dst[0] = code as u8;'), (49, '        2 => {'), (50, '            dst[0] = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;'), (51, '            dst[1] = (code & 0x3F) as u8 | TAG_CONT;'), (53, '        3 => {'), (54, '            dst[0] = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;'), (55, '            dst[1] = (code >> 6 & 0x3F) as u8 | TAG_CONT;'), (56, '            dst[2] = (code & 0x3F) as u8 | TAG_CONT;'), (58, '        4 => {'), (59, '            dst[0] = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;'), (60, '            dst[1] = (code >> 12 & 0x3F) as u8 | TAG_CONT;'), (61, '            dst[2] = (code >> 6 & 0x3F) as u8 | TAG_CONT;'), (62, '            dst[3] = (code & 0x3F) as u8 | TAG_CONT;')], 'deleted': [(45, '    match (len, &mut dst[..]) {'), (46, '        (1, [a, ..]) => {'), (47, '            *a = code as u8;'), (49, '        (2, [a, b, ..]) => {'), (50, '            *a = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;'), (51, '            *b = (code & 0x3F) as u8 | TAG_CONT;'), (53, '        (3, [a, b, c, ..]) => {'), (54, '            *a = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;'), (55, '            *b = (code >> 6 & 0x3F) as u8 | TAG_CONT;'), (56, '            *c = (code & 0x3F) as u8 | TAG_CONT;'), (58, '        (4, [a, b, c, d, ..]) => {'), (59, '            *a = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;'), (60, '            *b = (code >> 12 & 0x3F) as u8 | TAG_CONT;'), (61, '            *c = (code >> 6 & 0x3F) as u8 | TAG_CONT;'), (62, '            *d = (code & 0x3F) as u8 | TAG_CONT;')]}",
    "num_lines_added": "15",
    "num_lines_deleted": "15",
    "nloc": "167"
  },
  {
    "file_change_id": "107164930863950",
    "hash": "9340c55139dc0baaa19df3c3a75c4e46836eda33",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -458,7 +458,7 @@ impl core::fmt::LowerHex for SecretKey {\n }\n \n impl Signature {\n-    pub fn parse(p: &[u8; util::SIGNATURE_SIZE]) -> Signature {\n+    pub fn parse_overflowing(p: &[u8; util::SIGNATURE_SIZE]) -> Signature {\n         let mut r = Scalar::default();\n         let mut s = Scalar::default();\n \n@@ -469,14 +469,39 @@ impl Signature {\n         Signature { r, s }\n     }\n \n-    pub fn parse_slice(p: &[u8]) -> Result<Signature, Error> {\n+    pub fn parse_standard(p: &[u8; util::SIGNATURE_SIZE]) -> Result<Signature, Error> {\n+        let mut r = Scalar::default();\n+        let mut s = Scalar::default();\n+\n+        // Okay for signature to overflow\n+        let overflowed_r = r.set_b32(array_ref!(p, 0, 32));\n+        let overflowed_s = s.set_b32(array_ref!(p, 32, 32));\n+\n+        if bool::from(overflowed_r | overflowed_s) {\n+            return Err(Error::InvalidSignature)\n+        }\n+\n+        Ok(Signature { r, s })\n+    }\n+\n+    pub fn parse_overflowing_slice(p: &[u8]) -> Result<Signature, Error> {\n         if p.len() != util::SIGNATURE_SIZE {\n             return Err(Error::InvalidInputLength);\n         }\n \n         let mut a = [0; util::SIGNATURE_SIZE];\n         a.copy_from_slice(p);\n-        Ok(Self::parse(&a))\n+        Ok(Self::parse_overflowing(&a))\n+    }\n+\n+    pub fn parse_standard_slice(p: &[u8]) -> Result<Signature, Error> {\n+        if p.len() != util::SIGNATURE_SIZE {\n+            return Err(Error::InvalidInputLength);\n+        }\n+\n+        let mut a = [0; util::SIGNATURE_SIZE];\n+        a.copy_from_slice(p);\n+        Ok(Self::parse_standard(&a)?)\n     }\n \n     pub fn parse_der(p: &[u8]) -> Result<Signature, Error> {\n",
    "diff_parsed": "{'added': [(461, '    pub fn parse_overflowing(p: &[u8; util::SIGNATURE_SIZE]) -> Signature {'), (472, '    pub fn parse_standard(p: &[u8; util::SIGNATURE_SIZE]) -> Result<Signature, Error> {'), (473, '        let mut r = Scalar::default();'), (474, '        let mut s = Scalar::default();'), (477, '        let overflowed_r = r.set_b32(array_ref!(p, 0, 32));'), (478, '        let overflowed_s = s.set_b32(array_ref!(p, 32, 32));'), (480, '        if bool::from(overflowed_r | overflowed_s) {'), (481, '            return Err(Error::InvalidSignature)'), (482, '        }'), (484, '        Ok(Signature { r, s })'), (485, '    }'), (487, '    pub fn parse_overflowing_slice(p: &[u8]) -> Result<Signature, Error> {'), (494, '        Ok(Self::parse_overflowing(&a))'), (495, '    }'), (497, '    pub fn parse_standard_slice(p: &[u8]) -> Result<Signature, Error> {'), (498, '        if p.len() != util::SIGNATURE_SIZE {'), (499, '            return Err(Error::InvalidInputLength);'), (500, '        }'), (502, '        let mut a = [0; util::SIGNATURE_SIZE];'), (503, '        a.copy_from_slice(p);'), (504, '        Ok(Self::parse_standard(&a)?)')], 'deleted': [(461, '    pub fn parse(p: &[u8; util::SIGNATURE_SIZE]) -> Signature {'), (472, '    pub fn parse_slice(p: &[u8]) -> Result<Signature, Error> {'), (479, '        Ok(Self::parse(&a))')]}",
    "num_lines_added": "21",
    "num_lines_deleted": "3",
    "nloc": "642"
  },
  {
    "file_change_id": "48101942633990",
    "hash": "f7c378b26e273d237575154800f6c2bd3bf2005",
    "old_path": "crossbeam-utils/src/atomic/atomic_cell.rs",
    "new_path": "crossbeam-utils/src/atomic/atomic_cell.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -465,8 +465,24 @@ macro_rules! impl_arithmetic {\n             /// ```\n             #[inline]\n             pub fn fetch_add(&self, val: $t) -> $t {\n-                let a = unsafe { &*(self.value.get() as *const $atomic) };\n-                a.fetch_add(val, Ordering::AcqRel)\n+                if can_transmute::<$t, $atomic>() {\n+                    let a = unsafe { &*(self.value.get() as *const $atomic) };\n+                    a.fetch_add(val, Ordering::AcqRel)\n+                } else {\n+                    #[cfg(crossbeam_loom)]\n+                    {\n+                        let _ = val;\n+                        unimplemented!(\"loom does not support non-atomic atomic ops\");\n+                    }\n+                    #[cfg(not(crossbeam_loom))]\n+                    {\n+                        let _guard = lock(self.value.get() as usize).write();\n+                        let value = unsafe { &mut *(self.value.get()) };\n+                        let old = *value;\n+                        *value = value.wrapping_add(val);\n+                        old\n+                    }\n+                }\n             }\n \n             /// Decrements the current value by `val` and returns the previous value.\n@@ -485,8 +501,24 @@ macro_rules! impl_arithmetic {\n             /// ```\n             #[inline]\n             pub fn fetch_sub(&self, val: $t) -> $t {\n-                let a = unsafe { &*(self.value.get() as *const $atomic) };\n-                a.fetch_sub(val, Ordering::AcqRel)\n+                if can_transmute::<$t, $atomic>() {\n+                    let a = unsafe { &*(self.value.get() as *const $atomic) };\n+                    a.fetch_sub(val, Ordering::AcqRel)\n+                } else {\n+                    #[cfg(crossbeam_loom)]\n+                    {\n+                        let _ = val;\n+                        unimplemented!(\"loom does not support non-atomic atomic ops\");\n+                    }\n+                    #[cfg(not(crossbeam_loom))]\n+                    {\n+                        let _guard = lock(self.value.get() as usize).write();\n+                        let value = unsafe { &mut *(self.value.get()) };\n+                        let old = *value;\n+                        *value = value.wrapping_sub(val);\n+                        old\n+                    }\n+                }\n             }\n \n             /// Applies bitwise \"and\" to the current value and returns the previous value.\n@@ -503,8 +535,24 @@ macro_rules! impl_arithmetic {\n             /// ```\n             #[inline]\n             pub fn fetch_and(&self, val: $t) -> $t {\n-                let a = unsafe { &*(self.value.get() as *const $atomic) };\n-                a.fetch_and(val, Ordering::AcqRel)\n+                if can_transmute::<$t, $atomic>() {\n+                    let a = unsafe { &*(self.value.get() as *const $atomic) };\n+                    a.fetch_and(val, Ordering::AcqRel)\n+                } else {\n+                    #[cfg(crossbeam_loom)]\n+                    {\n+                        let _ = val;\n+                        unimplemented!(\"loom does not support non-atomic atomic ops\");\n+                    }\n+                    #[cfg(not(crossbeam_loom))]\n+                    {\n+                        let _guard = lock(self.value.get() as usize).write();\n+                        let value = unsafe { &mut *(self.value.get()) };\n+                        let old = *value;\n+                        *value &= val;\n+                        old\n+                    }\n+                }\n             }\n \n             /// Applies bitwise \"or\" to the current value and returns the previous value.\n@@ -521,8 +569,24 @@ macro_rules! impl_arithmetic {\n             /// ```\n             #[inline]\n             pub fn fetch_or(&self, val: $t) -> $t {\n-                let a = unsafe { &*(self.value.get() as *const $atomic) };\n-                a.fetch_or(val, Ordering::AcqRel)\n+                if can_transmute::<$t, $atomic>() {\n+                    let a = unsafe { &*(self.value.get() as *const $atomic) };\n+                    a.fetch_or(val, Ordering::AcqRel)\n+                } else {\n+                    #[cfg(crossbeam_loom)]\n+                    {\n+                        let _ = val;\n+                        unimplemented!(\"loom does not support non-atomic atomic ops\");\n+                    }\n+                    #[cfg(not(crossbeam_loom))]\n+                    {\n+                        let _guard = lock(self.value.get() as usize).write();\n+                        let value = unsafe { &mut *(self.value.get()) };\n+                        let old = *value;\n+                        *value |= val;\n+                        old\n+                    }\n+                }\n             }\n \n             /// Applies bitwise \"xor\" to the current value and returns the previous value.\n@@ -539,8 +603,24 @@ macro_rules! impl_arithmetic {\n             /// ```\n             #[inline]\n             pub fn fetch_xor(&self, val: $t) -> $t {\n-                let a = unsafe { &*(self.value.get() as *const $atomic) };\n-                a.fetch_xor(val, Ordering::AcqRel)\n+                if can_transmute::<$t, $atomic>() {\n+                    let a = unsafe { &*(self.value.get() as *const $atomic) };\n+                    a.fetch_xor(val, Ordering::AcqRel)\n+                } else {\n+                    #[cfg(crossbeam_loom)]\n+                    {\n+                        let _ = val;\n+                        unimplemented!(\"loom does not support non-atomic atomic ops\");\n+                    }\n+                    #[cfg(not(crossbeam_loom))]\n+                    {\n+                        let _guard = lock(self.value.get() as usize).write();\n+                        let value = unsafe { &mut *(self.value.get()) };\n+                        let old = *value;\n+                        *value ^= val;\n+                        old\n+                    }\n+                }\n             }\n         }\n     };\n",
    "diff_parsed": "{'added': [(468, '                if can_transmute::<$t, $atomic>() {'), (469, '                    let a = unsafe { &*(self.value.get() as *const $atomic) };'), (470, '                    a.fetch_add(val, Ordering::AcqRel)'), (471, '                } else {'), (472, '                    #[cfg(crossbeam_loom)]'), (473, '                    {'), (474, '                        let _ = val;'), (475, '                        unimplemented!(\"loom does not support non-atomic atomic ops\");'), (476, '                    }'), (477, '                    #[cfg(not(crossbeam_loom))]'), (478, '                    {'), (479, '                        let _guard = lock(self.value.get() as usize).write();'), (480, '                        let value = unsafe { &mut *(self.value.get()) };'), (481, '                        let old = *value;'), (482, '                        *value = value.wrapping_add(val);'), (483, '                        old'), (484, '                    }'), (485, '                }'), (504, '                if can_transmute::<$t, $atomic>() {'), (505, '                    let a = unsafe { &*(self.value.get() as *const $atomic) };'), (506, '                    a.fetch_sub(val, Ordering::AcqRel)'), (507, '                } else {'), (508, '                    #[cfg(crossbeam_loom)]'), (509, '                    {'), (510, '                        let _ = val;'), (511, '                        unimplemented!(\"loom does not support non-atomic atomic ops\");'), (512, '                    }'), (513, '                    #[cfg(not(crossbeam_loom))]'), (514, '                    {'), (515, '                        let _guard = lock(self.value.get() as usize).write();'), (516, '                        let value = unsafe { &mut *(self.value.get()) };'), (517, '                        let old = *value;'), (518, '                        *value = value.wrapping_sub(val);'), (519, '                        old'), (520, '                    }'), (521, '                }'), (538, '                if can_transmute::<$t, $atomic>() {'), (539, '                    let a = unsafe { &*(self.value.get() as *const $atomic) };'), (540, '                    a.fetch_and(val, Ordering::AcqRel)'), (541, '                } else {'), (542, '                    #[cfg(crossbeam_loom)]'), (543, '                    {'), (544, '                        let _ = val;'), (545, '                        unimplemented!(\"loom does not support non-atomic atomic ops\");'), (546, '                    }'), (547, '                    #[cfg(not(crossbeam_loom))]'), (548, '                    {'), (549, '                        let _guard = lock(self.value.get() as usize).write();'), (550, '                        let value = unsafe { &mut *(self.value.get()) };'), (551, '                        let old = *value;'), (552, '                        *value &= val;'), (553, '                        old'), (554, '                    }'), (555, '                }'), (572, '                if can_transmute::<$t, $atomic>() {'), (573, '                    let a = unsafe { &*(self.value.get() as *const $atomic) };'), (574, '                    a.fetch_or(val, Ordering::AcqRel)'), (575, '                } else {'), (576, '                    #[cfg(crossbeam_loom)]'), (577, '                    {'), (578, '                        let _ = val;'), (579, '                        unimplemented!(\"loom does not support non-atomic atomic ops\");'), (580, '                    }'), (581, '                    #[cfg(not(crossbeam_loom))]'), (582, '                    {'), (583, '                        let _guard = lock(self.value.get() as usize).write();'), (584, '                        let value = unsafe { &mut *(self.value.get()) };'), (585, '                        let old = *value;'), (586, '                        *value |= val;'), (587, '                        old'), (588, '                    }'), (589, '                }'), (606, '                if can_transmute::<$t, $atomic>() {'), (607, '                    let a = unsafe { &*(self.value.get() as *const $atomic) };'), (608, '                    a.fetch_xor(val, Ordering::AcqRel)'), (609, '                } else {'), (610, '                    #[cfg(crossbeam_loom)]'), (611, '                    {'), (612, '                        let _ = val;'), (613, '                        unimplemented!(\"loom does not support non-atomic atomic ops\");'), (614, '                    }'), (615, '                    #[cfg(not(crossbeam_loom))]'), (616, '                    {'), (617, '                        let _guard = lock(self.value.get() as usize).write();'), (618, '                        let value = unsafe { &mut *(self.value.get()) };'), (619, '                        let old = *value;'), (620, '                        *value ^= val;'), (621, '                        old'), (622, '                    }'), (623, '                }')], 'deleted': [(468, '                let a = unsafe { &*(self.value.get() as *const $atomic) };'), (469, '                a.fetch_add(val, Ordering::AcqRel)'), (488, '                let a = unsafe { &*(self.value.get() as *const $atomic) };'), (489, '                a.fetch_sub(val, Ordering::AcqRel)'), (506, '                let a = unsafe { &*(self.value.get() as *const $atomic) };'), (507, '                a.fetch_and(val, Ordering::AcqRel)'), (524, '                let a = unsafe { &*(self.value.get() as *const $atomic) };'), (525, '                a.fetch_or(val, Ordering::AcqRel)'), (542, '                let a = unsafe { &*(self.value.get() as *const $atomic) };'), (543, '                a.fetch_xor(val, Ordering::AcqRel)')]}",
    "num_lines_added": "90",
    "num_lines_deleted": "10",
    "nloc": "548"
  },
  {
    "file_change_id": "202954485020623",
    "hash": "15cb335e66d518a25950ff40906676f982b64a2",
    "old_path": "openssl/src/cms.rs",
    "new_path": "openssl/src/cms.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -138,22 +138,14 @@ impl CmsContentInfo {\n         flags: CMSOptions,\n     ) -> Result<CmsContentInfo, ErrorStack> {\n         unsafe {\n-            let signcert = match signcert {\n-                Some(cert) => cert.as_ptr(),\n-                None => ptr::null_mut(),\n-            };\n-            let pkey = match pkey {\n-                Some(pkey) => pkey.as_ptr(),\n-                None => ptr::null_mut(),\n-            };\n-            let data_bio_ptr = match data {\n-                Some(data) => MemBioSlice::new(data)?.as_ptr(),\n-                None => ptr::null_mut(),\n-            };\n-            let certs = match certs {\n-                Some(certs) => certs.as_ptr(),\n-                None => ptr::null_mut(),\n+            let signcert = signcert.map_or(ptr::null_mut(), |p| p.as_ptr());\n+            let pkey = pkey.map_or(ptr::null_mut(), |p| p.as_ptr());\n+            let data_bio = match data {\n+                Some(data) => Some(MemBioSlice::new(data)?),\n+                None => None,\n             };\n+            let data_bio_ptr = data_bio.as_ref().map_or(ptr::null_mut(), |p| p.as_ptr());\n+            let certs = certs.map_or(ptr::null_mut(), |p| p.as_ptr());\n \n             let cms = cvt_p(ffi::CMS_sign(\n                 signcert,\n",
    "diff_parsed": "{'added': [(141, '            let signcert = signcert.map_or(ptr::null_mut(), |p| p.as_ptr());'), (142, '            let pkey = pkey.map_or(ptr::null_mut(), |p| p.as_ptr());'), (143, '            let data_bio = match data {'), (144, '                Some(data) => Some(MemBioSlice::new(data)?),'), (145, '                None => None,'), (147, '            let data_bio_ptr = data_bio.as_ref().map_or(ptr::null_mut(), |p| p.as_ptr());'), (148, '            let certs = certs.map_or(ptr::null_mut(), |p| p.as_ptr());')], 'deleted': [(141, '            let signcert = match signcert {'), (142, '                Some(cert) => cert.as_ptr(),'), (143, '                None => ptr::null_mut(),'), (144, '            };'), (145, '            let pkey = match pkey {'), (146, '                Some(pkey) => pkey.as_ptr(),'), (147, '                None => ptr::null_mut(),'), (148, '            };'), (149, '            let data_bio_ptr = match data {'), (150, '                Some(data) => MemBioSlice::new(data)?.as_ptr(),'), (151, '                None => ptr::null_mut(),'), (152, '            };'), (153, '            let certs = match certs {'), (154, '                Some(certs) => certs.as_ptr(),'), (155, '                None => ptr::null_mut(),')]}",
    "num_lines_added": "7",
    "num_lines_deleted": "15",
    "nloc": "105"
  },
  {
    "file_change_id": "123884456341153",
    "hash": "7d13cc67dbe94ab0340e2a492c489dc16815300",
    "old_path": "src/vector/focus.rs",
    "new_path": "src/vector/focus.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -279,10 +279,10 @@ impl<A> Clone for TreeFocus<A> {\n \n #[allow(unsafe_code)]\n #[cfg(threadsafe)]\n-unsafe impl<A> Send for TreeFocus<A> {}\n+unsafe impl<A: Send> Send for TreeFocus<A> {}\n #[allow(unsafe_code)]\n #[cfg(threadsafe)]\n-unsafe impl<A> Sync for TreeFocus<A> {}\n+unsafe impl<A: Sync> Sync for TreeFocus<A> {}\n \n #[inline]\n fn contains<A: Ord>(range: &Range<A>, index: &A) -> bool {\n",
    "diff_parsed": "{'added': [(282, 'unsafe impl<A: Send> Send for TreeFocus<A> {}'), (285, 'unsafe impl<A: Sync> Sync for TreeFocus<A> {}')], 'deleted': [(282, 'unsafe impl<A> Send for TreeFocus<A> {}'), (285, 'unsafe impl<A> Sync for TreeFocus<A> {}')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "589"
  },
  {
    "file_change_id": "22405286808640",
    "hash": "623b87397a569729c4bcabae747823c5668cce9",
    "old_path": "src/common.rs",
    "new_path": "src/common.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -239,7 +239,7 @@ impl FromStr for HeaderField {\n     type Err = ();\n \n     fn from_str(s: &str) -> Result<HeaderField, ()> {\n-        AsciiString::from_ascii(s.trim())\n+        AsciiString::from_ascii(s)\n             .map(HeaderField)\n             .map_err(|_| ())\n     }\n",
    "diff_parsed": "{'added': [(242, '        AsciiString::from_ascii(s)')], 'deleted': [(242, '        AsciiString::from_ascii(s.trim())')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "403"
  },
  {
    "file_change_id": "185644328225116",
    "hash": "d4133288261612d43853245aa886e1a3a0d2dbf",
    "old_path": "diesel/src/sqlite/connection/statement_iterator.rs",
    "new_path": "diesel/src/sqlite/connection/statement_iterator.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -42,28 +42,35 @@ where\n \n pub struct NamedStatementIterator<'a, T> {\n     stmt: StatementUse<'a>,\n-    column_indices: HashMap<&'a str, usize>,\n+    column_indices: Option<HashMap<&'a str, usize>>,\n     _marker: PhantomData<T>,\n }\n \n impl<'a, T> NamedStatementIterator<'a, T> {\n     #[allow(clippy::new_ret_no_self)]\n     pub fn new(stmt: StatementUse<'a>) -> QueryResult<Self> {\n-        let column_indices = (0..stmt.num_fields())\n+        Ok(NamedStatementIterator {\n+            stmt,\n+            column_indices: None,\n+            _marker: PhantomData,\n+        })\n+    }\n+\n+    fn populate_column_indices(&mut self) -> QueryResult<()> {\n+        let column_indices = (0..self.stmt.num_fields())\n             .filter_map(|i| {\n-                stmt.field_name(i).map(|column| {\n-                    let column = column\n-                        .to_str()\n+                dbg!(i);\n+                dbg!(self.stmt.field_name(i)).map(|column| {\n+                    let column = dbg!(column\n+                        .to_str())\n                         .map_err(|e| DeserializationError(e.into()))?;\n                     Ok((column, i))\n                 })\n             })\n             .collect::<QueryResult<_>>()?;\n-        Ok(NamedStatementIterator {\n-            stmt,\n-            column_indices,\n-            _marker: PhantomData,\n-        })\n+\n+        self.column_indices = Some(column_indices);\n+        Ok(())\n     }\n }\n \n@@ -78,8 +85,13 @@ where\n             Ok(row) => row,\n             Err(e) => return Some(Err(e)),\n         };\n+        if self.column_indices.is_none() {\n+            if let Err(e) = self.populate_column_indices() {\n+                return Some(Err(e));\n+            }\n+        }\n         row.map(|row| {\n-            let row = row.into_named(&self.column_indices);\n+            let row = row.into_named(self.column_indices.as_ref().expect(\"it's there because we populated it above\"));\n             T::build(&row).map_err(DeserializationError)\n         })\n     }\n",
    "diff_parsed": "{'added': [(45, \"    column_indices: Option<HashMap<&'a str, usize>>,\"), (52, '        Ok(NamedStatementIterator {'), (53, '            stmt,'), (54, '            column_indices: None,'), (55, '            _marker: PhantomData,'), (56, '        })'), (57, '    }'), (59, '    fn populate_column_indices(&mut self) -> QueryResult<()> {'), (60, '        let column_indices = (0..self.stmt.num_fields())'), (62, '                dbg!(i);'), (63, '                dbg!(self.stmt.field_name(i)).map(|column| {'), (64, '                    let column = dbg!(column'), (65, '                        .to_str())'), (72, '        self.column_indices = Some(column_indices);'), (73, '        Ok(())'), (88, '        if self.column_indices.is_none() {'), (89, '            if let Err(e) = self.populate_column_indices() {'), (90, '                return Some(Err(e));'), (91, '            }'), (92, '        }'), (94, '            let row = row.into_named(self.column_indices.as_ref().expect(\"it\\'s there because we populated it above\"));')], 'deleted': [(45, \"    column_indices: HashMap<&'a str, usize>,\"), (52, '        let column_indices = (0..stmt.num_fields())'), (54, '                stmt.field_name(i).map(|column| {'), (55, '                    let column = column'), (56, '                        .to_str()'), (62, '        Ok(NamedStatementIterator {'), (63, '            stmt,'), (64, '            column_indices,'), (65, '            _marker: PhantomData,'), (66, '        })'), (82, '            let row = row.into_named(&self.column_indices);')]}",
    "num_lines_added": "21",
    "num_lines_deleted": "11",
    "nloc": "94"
  },
  {
    "file_change_id": "54452286686336",
    "hash": "dbcbefe069fcd53ebc1981fc97fd5b3f94f396d",
    "old_path": "src/io/compress.rs",
    "new_path": "src/io/compress.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -14,7 +14,7 @@\n \n use anyhow::{Context, Result};\n use flate2::bufread::GzDecoder;\n-use std::io::{self, BufRead, Read};\n+use std::io::{self, BufRead, ErrorKind, Read};\n use xz2::bufread::XzDecoder;\n \n enum CompressDecoder<R: BufRead> {\n@@ -48,8 +48,60 @@ impl<R: BufRead> Read for DecompressReader<R> {\n         use CompressDecoder::*;\n         match &mut self.decoder {\n             Uncompressed(d) => d.read(buf),\n-            Gzip(d) => d.read(buf),\n+            Gzip(d) => {\n+                let count = d.read(buf)?;\n+                if count == 0 {\n+                    // GzDecoder stops reading as soon as it encounters the\n+                    // gzip trailer, so it doesn't notice trailing data,\n+                    // which indicates something wrong with the input.  Try\n+                    // reading one more byte, and fail if there is one.\n+                    let mut buf = [0; 1];\n+                    if d.get_mut().read(&mut buf)? > 0 {\n+                        return Err(io::Error::new(\n+                            ErrorKind::InvalidData,\n+                            \"found trailing data after compressed gzip stream\",\n+                        ));\n+                    }\n+                }\n+                Ok(count)\n+            }\n             Xz(d) => d.read(buf),\n         }\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use std::io::BufReader;\n+\n+    /// Test that DecompressReader fails if data is appended to the\n+    /// compressed stream.\n+    #[test]\n+    fn test_decompress_reader_trailing_data() {\n+        test_decompress_reader_trailing_data_one(\n+            &include_bytes!(\"../../fixtures/verify/1M.gz\")[..],\n+        );\n+        test_decompress_reader_trailing_data_one(\n+            &include_bytes!(\"../../fixtures/verify/1M.xz\")[..],\n+        );\n+    }\n+\n+    fn test_decompress_reader_trailing_data_one(input: &[u8]) {\n+        let mut input = input.to_vec();\n+        let mut output = Vec::new();\n+\n+        // successful run\n+        DecompressReader::new(BufReader::new(&*input))\n+            .unwrap()\n+            .read_to_end(&mut output)\n+            .unwrap();\n+\n+        // add trailing garbage, make sure we notice\n+        input.push(0);\n+        DecompressReader::new(BufReader::new(&*input))\n+            .unwrap()\n+            .read_to_end(&mut output)\n+            .unwrap_err();\n+    }\n+}\n",
    "diff_parsed": "{'added': [(17, 'use std::io::{self, BufRead, ErrorKind, Read};'), (51, '            Gzip(d) => {'), (52, '                let count = d.read(buf)?;'), (53, '                if count == 0 {'), (58, '                    let mut buf = [0; 1];'), (59, '                    if d.get_mut().read(&mut buf)? > 0 {'), (60, '                        return Err(io::Error::new('), (61, '                            ErrorKind::InvalidData,'), (62, '                            \"found trailing data after compressed gzip stream\",'), (63, '                        ));'), (64, '                    }'), (65, '                }'), (66, '                Ok(count)'), (67, '            }'), (73, '#[cfg(test)]'), (74, 'mod tests {'), (75, '    use super::*;'), (76, '    use std::io::BufReader;'), (80, '    #[test]'), (81, '    fn test_decompress_reader_trailing_data() {'), (82, '        test_decompress_reader_trailing_data_one('), (83, '            &include_bytes!(\"../../fixtures/verify/1M.gz\")[..],'), (84, '        );'), (85, '        test_decompress_reader_trailing_data_one('), (86, '            &include_bytes!(\"../../fixtures/verify/1M.xz\")[..],'), (87, '        );'), (88, '    }'), (90, '    fn test_decompress_reader_trailing_data_one(input: &[u8]) {'), (91, '        let mut input = input.to_vec();'), (92, '        let mut output = Vec::new();'), (95, '        DecompressReader::new(BufReader::new(&*input))'), (96, '            .unwrap()'), (97, '            .read_to_end(&mut output)'), (98, '            .unwrap();'), (101, '        input.push(0);'), (102, '        DecompressReader::new(BufReader::new(&*input))'), (103, '            .unwrap()'), (104, '            .read_to_end(&mut output)'), (105, '            .unwrap_err();'), (106, '    }'), (107, '}')], 'deleted': [(17, 'use std::io::{self, BufRead, Read};'), (51, '            Gzip(d) => d.read(buf),')]}",
    "num_lines_added": "41",
    "num_lines_deleted": "2",
    "nloc": "75"
  },
  {
    "file_change_id": "1622430734360",
    "hash": "1faf18eee11f14969b77ae0f76dcd9ebd437d0c",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -372,8 +372,8 @@ pub struct RcuCell<T> {\n     link: LinkWrapper<T>,\n }\n \n-unsafe impl<T> Send for RcuCell<T> {}\n-unsafe impl<T> Sync for RcuCell<T> {}\n+unsafe impl<T: Send> Send for RcuCell<T> {}\n+unsafe impl<T: Sync> Sync for RcuCell<T> {}\n \n impl<T> Default for RcuCell<T> {\n     fn default() -> Self {\n",
    "diff_parsed": "{'added': [(375, 'unsafe impl<T: Send> Send for RcuCell<T> {}'), (376, 'unsafe impl<T: Sync> Sync for RcuCell<T> {}')], 'deleted': [(375, 'unsafe impl<T> Send for RcuCell<T> {}'), (376, 'unsafe impl<T> Sync for RcuCell<T> {}')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "416"
  },
  {
    "file_change_id": "166582456410264",
    "hash": "c13df26bf356b8c33c390b310f22227a7fd654d",
    "old_path": "src/elf.rs",
    "new_path": "src/elf.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,4 +1,3 @@\n-#![allow(clippy::integer_arithmetic)]\n //! This module relocates a BPF ELF\n \n // Note: Typically ELF shared objects are loaded using the program headers and\n@@ -243,10 +242,14 @@ impl<E: UserDefinedError, I: InstructionMeter> Executable<E, I> {\n \n     /// Get the .text section virtual address and bytes\n     pub fn get_text_bytes(&self) -> (u64, &[u8]) {\n-        let offset = (self.text_section_info.vaddr - ebpf::MM_PROGRAM_START) as usize;\n+        let offset = (self\n+            .text_section_info\n+            .vaddr\n+            .saturating_sub(ebpf::MM_PROGRAM_START)) as usize;\n         (\n             self.text_section_info.vaddr,\n-            &self.ro_section[offset..offset + self.text_section_info.offset_range.len()],\n+            &self.ro_section\n+                [offset..offset.saturating_add(self.text_section_info.offset_range.len())],\n         )\n     }\n \n@@ -312,7 +315,10 @@ impl<E: UserDefinedError, I: InstructionMeter> Executable<E, I> {\n         }\n         Err(ElfError::UnresolvedSymbol(\n             name.to_string(),\n-            file_offset / ebpf::INSN_SIZE + ebpf::ELF_INSN_DUMP_OFFSET,\n+            file_offset\n+                .checked_div(ebpf::INSN_SIZE)\n+                .and_then(|offset| offset.checked_add(ebpf::ELF_INSN_DUMP_OFFSET))\n+                .unwrap_or(ebpf::ELF_INSN_DUMP_OFFSET),\n             file_offset,\n         )\n         .into())\n@@ -408,21 +414,25 @@ impl<E: UserDefinedError, I: InstructionMeter> Executable<E, I> {\n         )?;\n \n         // calculate entrypoint offset into the text section\n-        let offset = elf.header.e_entry - text_section.sh_addr;\n-        if offset % ebpf::INSN_SIZE as u64 != 0 {\n+        let offset = elf.header.e_entry.saturating_sub(text_section.sh_addr);\n+        if offset.checked_rem(ebpf::INSN_SIZE as u64) != Some(0) {\n+            return Err(ElfError::InvalidEntrypoint);\n+        }\n+        if let Some(entrypoint) = (offset as usize).checked_div(ebpf::INSN_SIZE) {\n+            bpf_functions.remove(&ebpf::hash_symbol_name(b\"entrypoint\"));\n+            register_bpf_function(\n+                &mut bpf_functions,\n+                entrypoint,\n+                \"entrypoint\",\n+                config.enable_symbol_and_section_labels,\n+            )?;\n+        } else {\n             return Err(ElfError::InvalidEntrypoint);\n         }\n-        let entrypoint = offset as usize / ebpf::INSN_SIZE;\n-        bpf_functions.remove(&ebpf::hash_symbol_name(b\"entrypoint\"));\n-        register_bpf_function(\n-            &mut bpf_functions,\n-            entrypoint,\n-            \"entrypoint\",\n-            config.enable_symbol_and_section_labels,\n-        )?;\n \n         // concatenate the read-only sections into one\n-        let mut ro_length = text_section.sh_addr as usize + text_section_info.offset_range.len();\n+        let mut ro_length =\n+            (text_section.sh_addr as usize).saturating_add(text_section_info.offset_range.len());\n         let ro_slices = elf\n             .section_headers\n             .iter()\n@@ -446,13 +456,17 @@ impl<E: UserDefinedError, I: InstructionMeter> Executable<E, I> {\n                     .as_slice()\n                     .get(section_header.file_range().unwrap_or_default())\n                     .ok_or(ElfError::ValueOutOfBounds)?;\n-                ro_length = ro_length.max(section_header.sh_addr as usize + slice.len());\n+                ro_length =\n+                    ro_length.max((section_header.sh_addr as usize).saturating_add(slice.len()));\n                 Ok((section_header.sh_addr as usize, slice))\n             })\n             .collect::<Result<Vec<_>, ElfError>>()?;\n+        if ro_length > elf_bytes.len() {\n+            return Err(ElfError::ValueOutOfBounds);\n+        }\n         let mut ro_section = vec![0; ro_length];\n         ro_section[text_section.sh_addr as usize\n-            ..text_section.sh_addr as usize + text_section_info.offset_range.len()]\n+            ..(text_section.sh_addr as usize).saturating_add(text_section_info.offset_range.len())]\n             .copy_from_slice(\n                 elf_bytes\n                     .as_slice()\n@@ -460,7 +474,7 @@ impl<E: UserDefinedError, I: InstructionMeter> Executable<E, I> {\n                     .ok_or(ElfError::ValueOutOfBounds)?,\n             );\n         for (offset, slice) in ro_slices.iter() {\n-            ro_section[*offset..*offset + slice.len()].copy_from_slice(slice);\n+            ro_section[*offset..offset.saturating_add(slice.len())].copy_from_slice(slice);\n         }\n \n         Ok(Self {\n@@ -483,13 +497,19 @@ impl<E: UserDefinedError, I: InstructionMeter> Executable<E, I> {\n         bpf_functions: &mut BTreeMap<u32, (usize, String)>,\n         elf_bytes: &mut [u8],\n     ) -> Result<(), ElfError> {\n-        for i in 0..elf_bytes.len() / ebpf::INSN_SIZE {\n+        let instruction_count = elf_bytes\n+            .len()\n+            .checked_div(ebpf::INSN_SIZE)\n+            .ok_or(ElfError::ValueOutOfBounds)?;\n+        for i in 0..instruction_count {\n             let mut insn = ebpf::get_insn(elf_bytes, i);\n             if insn.opc == ebpf::CALL_IMM && insn.imm != -1 {\n-                let target_pc = i as isize + 1 + insn.imm as isize;\n-                if target_pc < 0 || target_pc >= (elf_bytes.len() / ebpf::INSN_SIZE) as isize {\n+                let target_pc = (i as isize)\n+                    .saturating_add(1)\n+                    .saturating_add(insn.imm as isize);\n+                if target_pc < 0 || target_pc >= instruction_count as isize {\n                     return Err(ElfError::RelativeJumpOutOfBounds(\n-                        i + ebpf::ELF_INSN_DUMP_OFFSET,\n+                        i.saturating_add(ebpf::ELF_INSN_DUMP_OFFSET),\n                     ));\n                 }\n                 let name = format!(\"function_{}\", target_pc);\n@@ -500,8 +520,9 @@ impl<E: UserDefinedError, I: InstructionMeter> Executable<E, I> {\n                     enable_symbol_and_section_labels,\n                 )?;\n                 insn.imm = hash as i64;\n+                let offset = i.saturating_mul(ebpf::INSN_SIZE);\n                 let checked_slice = elf_bytes\n-                    .get_mut(i * ebpf::INSN_SIZE..(i * ebpf::INSN_SIZE) + ebpf::INSN_SIZE)\n+                    .get_mut(offset..offset.saturating_add(ebpf::INSN_SIZE))\n                     .ok_or(ElfError::ValueOutOfBounds)?;\n                 checked_slice.copy_from_slice(&insn.to_vec());\n             }\n@@ -527,14 +548,17 @@ impl<E: UserDefinedError, I: InstructionMeter> Executable<E, I> {\n             return Err(ElfError::WrongType);\n         }\n \n-        let num_text_sections = elf.section_headers.iter().fold(0, |count, section_header| {\n-            if let Some(this_name) = elf.shdr_strtab.get_at(section_header.sh_name) {\n-                if this_name == \".text\" {\n-                    return count + 1;\n-                }\n-            }\n-            count\n-        });\n+        let num_text_sections =\n+            elf.section_headers\n+                .iter()\n+                .fold(0, |count: usize, section_header| {\n+                    if let Some(this_name) = elf.shdr_strtab.get_at(section_header.sh_name) {\n+                        if this_name == \".text\" {\n+                            return count.saturating_add(1);\n+                        }\n+                    }\n+                    count\n+                });\n         if 1 != num_text_sections {\n             return Err(ElfError::NotOneTextSection);\n         }\n@@ -628,19 +652,19 @@ impl<E: UserDefinedError, I: InstructionMeter> Executable<E, I> {\n                         .dynsyms\n                         .get(relocation.r_sym)\n                         .ok_or(ElfError::UnknownSymbol(relocation.r_sym))?;\n-                    let addr = (sym.st_value + refd_pa) as u64;\n+                    let addr = sym.st_value.saturating_add(refd_pa) as u64;\n                     let checked_slice = elf_bytes\n                         .get_mut(imm_offset..imm_offset.saturating_add(BYTE_LENGTH_IMMEIDATE))\n                         .ok_or(ElfError::ValueOutOfBounds)?;\n                     LittleEndian::write_u32(checked_slice, (addr & 0xFFFFFFFF) as u32);\n+                    let file_offset = imm_offset.saturating_add(ebpf::INSN_SIZE);\n                     let checked_slice = elf_bytes\n-                        .get_mut(\n-                            imm_offset.saturating_add(ebpf::INSN_SIZE)\n-                                ..imm_offset\n-                                    .saturating_add(ebpf::INSN_SIZE + BYTE_LENGTH_IMMEIDATE),\n-                        )\n+                        .get_mut(file_offset..file_offset.saturating_add(BYTE_LENGTH_IMMEIDATE))\n                         .ok_or(ElfError::ValueOutOfBounds)?;\n-                    LittleEndian::write_u32(checked_slice, (addr >> 32) as u32);\n+                    LittleEndian::write_u32(\n+                        checked_slice,\n+                        addr.checked_shr(32).unwrap_or_default() as u32,\n+                    );\n                 }\n                 Some(BpfRelocationType::R_Bpf_64_Relative) => {\n                     // Raw relocation between sections.  The instruction being relocated contains\n@@ -674,14 +698,14 @@ impl<E: UserDefinedError, I: InstructionMeter> Executable<E, I> {\n                             .get_mut(imm_offset..imm_offset.saturating_add(BYTE_LENGTH_IMMEIDATE))\n                             .ok_or(ElfError::ValueOutOfBounds)?;\n                         LittleEndian::write_u32(checked_slice, (refd_pa & 0xFFFFFFFF) as u32);\n+                        let file_offset = imm_offset.saturating_add(ebpf::INSN_SIZE);\n                         let checked_slice = elf_bytes\n-                            .get_mut(\n-                                imm_offset.saturating_add(ebpf::INSN_SIZE)\n-                                    ..imm_offset\n-                                        .saturating_add(ebpf::INSN_SIZE + BYTE_LENGTH_IMMEIDATE),\n-                            )\n+                            .get_mut(file_offset..file_offset.saturating_add(BYTE_LENGTH_IMMEIDATE))\n                             .ok_or(ElfError::ValueOutOfBounds)?;\n-                        LittleEndian::write_u32(checked_slice, (refd_pa >> 32) as u32);\n+                        LittleEndian::write_u32(\n+                            checked_slice,\n+                            refd_pa.checked_shr(32).unwrap_or_default() as u32,\n+                        );\n                     } else {\n                         // 64 bit memory location, write entire 64 bit physical address directly\n                         let checked_slice = elf_bytes\n@@ -708,8 +732,10 @@ impl<E: UserDefinedError, I: InstructionMeter> Executable<E, I> {\n                         if !text_section.vm_range().contains(&(sym.st_value as usize)) {\n                             return Err(ElfError::ValueOutOfBounds);\n                         }\n-                        let target_pc =\n-                            (sym.st_value - text_section.sh_addr) as usize / ebpf::INSN_SIZE;\n+                        let target_pc = (sym.st_value.saturating_sub(text_section.sh_addr)\n+                            as usize)\n+                            .checked_div(ebpf::INSN_SIZE)\n+                            .unwrap_or_default();\n                         register_bpf_function(\n                             bpf_functions,\n                             target_pc,\n@@ -727,7 +753,12 @@ impl<E: UserDefinedError, I: InstructionMeter> Executable<E, I> {\n                         {\n                             return Err(ElfError::UnresolvedSymbol(\n                                 name.to_string(),\n-                                r_offset / ebpf::INSN_SIZE + ebpf::ELF_INSN_DUMP_OFFSET,\n+                                r_offset\n+                                    .checked_div(ebpf::INSN_SIZE)\n+                                    .and_then(|offset| {\n+                                        offset.checked_add(ebpf::ELF_INSN_DUMP_OFFSET)\n+                                    })\n+                                    .unwrap_or(ebpf::ELF_INSN_DUMP_OFFSET),\n                                 r_offset,\n                             ));\n                         }\n@@ -760,7 +791,9 @@ impl<E: UserDefinedError, I: InstructionMeter> Executable<E, I> {\n                 {\n                     return Err(ElfError::ValueOutOfBounds);\n                 }\n-                let target_pc = (symbol.st_value - text_section.sh_addr) as usize / ebpf::INSN_SIZE;\n+                let target_pc = (symbol.st_value.saturating_sub(text_section.sh_addr) as usize)\n+                    .checked_div(ebpf::INSN_SIZE)\n+                    .unwrap_or_default();\n                 let name = elf\n                     .strtab\n                     .get_at(symbol.st_name)\n",
    "diff_parsed": "{'added': [(245, '        let offset = (self'), (246, '            .text_section_info'), (247, '            .vaddr'), (248, '            .saturating_sub(ebpf::MM_PROGRAM_START)) as usize;'), (251, '            &self.ro_section'), (252, '                [offset..offset.saturating_add(self.text_section_info.offset_range.len())],'), (318, '            file_offset'), (319, '                .checked_div(ebpf::INSN_SIZE)'), (320, '                .and_then(|offset| offset.checked_add(ebpf::ELF_INSN_DUMP_OFFSET))'), (321, '                .unwrap_or(ebpf::ELF_INSN_DUMP_OFFSET),'), (417, '        let offset = elf.header.e_entry.saturating_sub(text_section.sh_addr);'), (418, '        if offset.checked_rem(ebpf::INSN_SIZE as u64) != Some(0) {'), (419, '            return Err(ElfError::InvalidEntrypoint);'), (420, '        }'), (421, '        if let Some(entrypoint) = (offset as usize).checked_div(ebpf::INSN_SIZE) {'), (422, '            bpf_functions.remove(&ebpf::hash_symbol_name(b\"entrypoint\"));'), (423, '            register_bpf_function('), (424, '                &mut bpf_functions,'), (425, '                entrypoint,'), (426, '                \"entrypoint\",'), (427, '                config.enable_symbol_and_section_labels,'), (428, '            )?;'), (429, '        } else {'), (434, '        let mut ro_length ='), (435, '            (text_section.sh_addr as usize).saturating_add(text_section_info.offset_range.len());'), (459, '                ro_length ='), (460, '                    ro_length.max((section_header.sh_addr as usize).saturating_add(slice.len()));'), (464, '        if ro_length > elf_bytes.len() {'), (465, '            return Err(ElfError::ValueOutOfBounds);'), (466, '        }'), (469, '            ..(text_section.sh_addr as usize).saturating_add(text_section_info.offset_range.len())]'), (477, '            ro_section[*offset..offset.saturating_add(slice.len())].copy_from_slice(slice);'), (500, '        let instruction_count = elf_bytes'), (501, '            .len()'), (502, '            .checked_div(ebpf::INSN_SIZE)'), (503, '            .ok_or(ElfError::ValueOutOfBounds)?;'), (504, '        for i in 0..instruction_count {'), (507, '                let target_pc = (i as isize)'), (508, '                    .saturating_add(1)'), (509, '                    .saturating_add(insn.imm as isize);'), (510, '                if target_pc < 0 || target_pc >= instruction_count as isize {'), (512, '                        i.saturating_add(ebpf::ELF_INSN_DUMP_OFFSET),'), (523, '                let offset = i.saturating_mul(ebpf::INSN_SIZE);'), (525, '                    .get_mut(offset..offset.saturating_add(ebpf::INSN_SIZE))'), (551, '        let num_text_sections ='), (552, '            elf.section_headers'), (553, '                .iter()'), (554, '                .fold(0, |count: usize, section_header| {'), (555, '                    if let Some(this_name) = elf.shdr_strtab.get_at(section_header.sh_name) {'), (556, '                        if this_name == \".text\" {'), (557, '                            return count.saturating_add(1);'), (558, '                        }'), (559, '                    }'), (560, '                    count'), (561, '                });'), (655, '                    let addr = sym.st_value.saturating_add(refd_pa) as u64;'), (660, '                    let file_offset = imm_offset.saturating_add(ebpf::INSN_SIZE);'), (662, '                        .get_mut(file_offset..file_offset.saturating_add(BYTE_LENGTH_IMMEIDATE))'), (664, '                    LittleEndian::write_u32('), (665, '                        checked_slice,'), (666, '                        addr.checked_shr(32).unwrap_or_default() as u32,'), (667, '                    );'), (701, '                        let file_offset = imm_offset.saturating_add(ebpf::INSN_SIZE);'), (703, '                            .get_mut(file_offset..file_offset.saturating_add(BYTE_LENGTH_IMMEIDATE))'), (705, '                        LittleEndian::write_u32('), (706, '                            checked_slice,'), (707, '                            refd_pa.checked_shr(32).unwrap_or_default() as u32,'), (708, '                        );'), (735, '                        let target_pc = (sym.st_value.saturating_sub(text_section.sh_addr)'), (736, '                            as usize)'), (737, '                            .checked_div(ebpf::INSN_SIZE)'), (738, '                            .unwrap_or_default();'), (756, '                                r_offset'), (757, '                                    .checked_div(ebpf::INSN_SIZE)'), (758, '                                    .and_then(|offset| {'), (759, '                                        offset.checked_add(ebpf::ELF_INSN_DUMP_OFFSET)'), (760, '                                    })'), (761, '                                    .unwrap_or(ebpf::ELF_INSN_DUMP_OFFSET),'), (794, '                let target_pc = (symbol.st_value.saturating_sub(text_section.sh_addr) as usize)'), (795, '                    .checked_div(ebpf::INSN_SIZE)'), (796, '                    .unwrap_or_default();')], 'deleted': [(1, '#![allow(clippy::integer_arithmetic)]'), (246, '        let offset = (self.text_section_info.vaddr - ebpf::MM_PROGRAM_START) as usize;'), (249, '            &self.ro_section[offset..offset + self.text_section_info.offset_range.len()],'), (315, '            file_offset / ebpf::INSN_SIZE + ebpf::ELF_INSN_DUMP_OFFSET,'), (411, '        let offset = elf.header.e_entry - text_section.sh_addr;'), (412, '        if offset % ebpf::INSN_SIZE as u64 != 0 {'), (415, '        let entrypoint = offset as usize / ebpf::INSN_SIZE;'), (416, '        bpf_functions.remove(&ebpf::hash_symbol_name(b\"entrypoint\"));'), (417, '        register_bpf_function('), (418, '            &mut bpf_functions,'), (419, '            entrypoint,'), (420, '            \"entrypoint\",'), (421, '            config.enable_symbol_and_section_labels,'), (422, '        )?;'), (425, '        let mut ro_length = text_section.sh_addr as usize + text_section_info.offset_range.len();'), (449, '                ro_length = ro_length.max(section_header.sh_addr as usize + slice.len());'), (455, '            ..text_section.sh_addr as usize + text_section_info.offset_range.len()]'), (463, '            ro_section[*offset..*offset + slice.len()].copy_from_slice(slice);'), (486, '        for i in 0..elf_bytes.len() / ebpf::INSN_SIZE {'), (489, '                let target_pc = i as isize + 1 + insn.imm as isize;'), (490, '                if target_pc < 0 || target_pc >= (elf_bytes.len() / ebpf::INSN_SIZE) as isize {'), (492, '                        i + ebpf::ELF_INSN_DUMP_OFFSET,'), (504, '                    .get_mut(i * ebpf::INSN_SIZE..(i * ebpf::INSN_SIZE) + ebpf::INSN_SIZE)'), (530, '        let num_text_sections = elf.section_headers.iter().fold(0, |count, section_header| {'), (531, '            if let Some(this_name) = elf.shdr_strtab.get_at(section_header.sh_name) {'), (532, '                if this_name == \".text\" {'), (533, '                    return count + 1;'), (534, '                }'), (535, '            }'), (536, '            count'), (537, '        });'), (631, '                    let addr = (sym.st_value + refd_pa) as u64;'), (637, '                        .get_mut('), (638, '                            imm_offset.saturating_add(ebpf::INSN_SIZE)'), (639, '                                ..imm_offset'), (640, '                                    .saturating_add(ebpf::INSN_SIZE + BYTE_LENGTH_IMMEIDATE),'), (641, '                        )'), (643, '                    LittleEndian::write_u32(checked_slice, (addr >> 32) as u32);'), (678, '                            .get_mut('), (679, '                                imm_offset.saturating_add(ebpf::INSN_SIZE)'), (680, '                                    ..imm_offset'), (681, '                                        .saturating_add(ebpf::INSN_SIZE + BYTE_LENGTH_IMMEIDATE),'), (682, '                            )'), (684, '                        LittleEndian::write_u32(checked_slice, (refd_pa >> 32) as u32);'), (711, '                        let target_pc ='), (712, '                            (sym.st_value - text_section.sh_addr) as usize / ebpf::INSN_SIZE;'), (730, '                                r_offset / ebpf::INSN_SIZE + ebpf::ELF_INSN_DUMP_OFFSET,'), (763, '                let target_pc = (symbol.st_value - text_section.sh_addr) as usize / ebpf::INSN_SIZE;')]}",
    "num_lines_added": "81",
    "num_lines_deleted": "48",
    "nloc": "950"
  },
  {
    "file_change_id": "180585151170052",
    "hash": "e88c6ff22e0d1a7b0733d9b90fadc4722763d7d",
    "old_path": "src/cfb.rs",
    "new_path": "src/cfb.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -245,9 +245,7 @@ impl Sectors {\n         let end = start + self.size;\n         if end > self.data.len() {\n             let mut len = self.data.len();\n-            unsafe {\n-                self.data.set_len(end);\n-            }\n+            self.data.resize(end, 0);\n             // read_exact or stop if EOF\n             while len < end {\n                 let read = r.read(&mut self.data[len..end]).map_err(CfbError::Io)?;\n",
    "diff_parsed": "{'added': [(248, '            self.data.resize(end, 0);')], 'deleted': [(248, '            unsafe {'), (249, '                self.data.set_len(end);'), (250, '            }')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "3",
    "nloc": "383"
  },
  {
    "file_change_id": "151732644109886",
    "hash": "e093c2b7b6ecbf34f8afbd87ee111df256957e4",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1103,8 +1103,9 @@ pub fn prefresh(pad: WINDOW, pmin_row: i32, pmin_col: i32, smin_row: i32, smin_c\n { unsafe { ll::prefresh(pad, pmin_row, pmin_col, smin_row, smin_col, smax_row, smax_col) } }\n \n \n-pub fn printw(s: &str) -> i32\n-{ unsafe { ll::printw(s.to_c_str().as_ptr()) } }\n+#[deprecated(since = \"5.98.0\", note = \"printw can segfault when printing string that contains % sign. Use addstr instead\")]\n+unsafe pub fn printw(s: &str) -> i32\n+{ ll::printw(s.to_c_str().as_ptr()) }\n \n \n pub fn putp(s: &str) -> i32\n",
    "diff_parsed": "{'added': [(1106, '#[deprecated(since = \"5.98.0\", note = \"printw can segfault when printing string that contains % sign. Use addstr instead\")]'), (1107, 'unsafe pub fn printw(s: &str) -> i32'), (1108, '{ ll::printw(s.to_c_str().as_ptr()) }')], 'deleted': [(1106, 'pub fn printw(s: &str) -> i32'), (1107, '{ unsafe { ll::printw(s.to_c_str().as_ptr()) } }')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "2",
    "nloc": "1259"
  },
  {
    "file_change_id": "139932283641547",
    "hash": "a9165de8065bab6ee6969a1b31ddac549f634c1",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1104,7 +1104,7 @@ pub fn prefresh(pad: WINDOW, pmin_row: i32, pmin_col: i32, smin_row: i32, smin_c\n \n \n #[deprecated(since = \"5.98.0\", note = \"printw can segfault when printing string that contains % sign. Use addstr instead\")]\n-unsafe pub fn printw(s: &str) -> i32\n+pub fn printw(s: &str) -> i32\n { ll::printw(s.to_c_str().as_ptr()) }\n \n \n",
    "diff_parsed": "{'added': [(1107, 'pub fn printw(s: &str) -> i32')], 'deleted': [(1107, 'unsafe pub fn printw(s: &str) -> i32')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "1259"
  },
  {
    "file_change_id": "83185189766760",
    "hash": "7fcee591341b3d37c25676cbac868bd27b4b208",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1105,7 +1105,7 @@ pub fn prefresh(pad: WINDOW, pmin_row: i32, pmin_col: i32, smin_row: i32, smin_c\n \n #[deprecated(since = \"5.98.0\", note = \"printw can segfault when printing string that contains % sign. Use addstr instead\")]\n pub fn printw(s: &str) -> i32\n-{ ll::printw(s.to_c_str().as_ptr()) }\n+{ unsafe { ll::printw(s.to_c_str().as_ptr()) } }\n \n \n pub fn putp(s: &str) -> i32\n",
    "diff_parsed": "{'added': [(1108, '{ unsafe { ll::printw(s.to_c_str().as_ptr()) } }')], 'deleted': [(1108, '{ ll::printw(s.to_c_str().as_ptr()) }')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "1259"
  },
  {
    "file_change_id": "226672161556895",
    "hash": "0df01c9d0c5d42166dc49e903002f53978ef10e",
    "old_path": "src/rw_lock.rs",
    "new_path": "src/rw_lock.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -3,6 +3,7 @@ use core::cell::UnsafeCell;\n use core::ops::{Deref, DerefMut};\n use core::fmt;\n use core::default::Default;\n+use core::mem;\n \n /// A reader-writer lock\n ///\n@@ -16,9 +17,12 @@ use core::default::Default;\n /// allow concurrent access through readers. The RAII guards returned from the\n /// locking methods implement `Deref` (and `DerefMut` for the `write` methods)\n /// to allow access to the contained of the lock.\n+/// \n+/// Read RAII guards are upgradeable to write RAII locks through the\n+/// [`upgrade`](RwLockReadGuard::upgrade) / [`try_upgrade`](RwLockReadGuard::try_upgrade) functions.\n ///\n-/// Based on\n-/// <https://jfdube.wordpress.com/2014/01/03/implementing-a-recursive-read-write-spinlock/>\n+/// Based on Facebook's\n+/// [`folly/RWSpinLock.h`](https://github.com/facebook/folly/blob/a0394d84f2d5c3e50ebfd0566f9d3acb52cfab5a/folly/synchronization/RWSpinLock.h).\n ///\n /// # Examples\n ///\n@@ -48,6 +52,10 @@ pub struct RwLock<T: ?Sized>\n     data: UnsafeCell<T>,\n }\n \n+const READER: usize = 4;\n+const UPGRADED: usize = 2;\n+const WRITER: usize = 1;\n+\n /// A guard from which the protected data can be read\n ///\n /// When the guard falls out of scope it will decrement the read count,\n@@ -69,12 +77,25 @@ pub struct RwLockWriteGuard<'a, T: 'a + ?Sized>\n     data: &'a mut T,\n }\n \n+/// A guard from which the protected data can be read, and can be upgraded\n+/// to a writable guard if needed\n+/// \n+/// No writers or other upgradeable guards can exist while this is in scope. New reader\n+/// creation is prevented (to alleviate writer starvation) but there may be existing readers\n+/// when the lock is acquired.\n+/// \n+/// When the guard falls out of scope it will release the lock.\n+#[derive(Debug)]\n+pub struct RwLockUpgradeableGuard<'a, T: 'a + ?Sized>\n+{\n+    lock: &'a AtomicUsize,\n+    data: &'a T,\n+}\n+\n // Same unsafe impls as `std::sync::RwLock`\n unsafe impl<T: ?Sized + Send> Send for RwLock<T> {}\n unsafe impl<T: ?Sized + Send + Sync> Sync for RwLock<T> {}\n \n-const USIZE_MSB: usize = ::core::isize::MIN as usize;\n-\n impl<T> RwLock<T>\n {\n     /// Creates a new spinlock wrapping the supplied data.\n@@ -103,6 +124,7 @@ impl<T> RwLock<T>\n     }\n \n     /// Consumes this `RwLock`, returning the underlying data.\n+    #[inline]\n     pub fn into_inner(self) -> T\n     {\n         // We know statically that there are no outstanding references to\n@@ -136,35 +158,13 @@ impl<T: ?Sized> RwLock<T>\n     /// }\n     /// ```\n     #[inline]\n-    pub fn read<'a>(&'a self) -> RwLockReadGuard<'a, T>\n+    pub fn read(&self) -> RwLockReadGuard<T>\n     {\n-        // (funny do-while loop)\n-        while {\n-            // Old value, with write bit unset\n-            let mut old;\n-\n-            // Wait for for writer to go away before doing expensive atomic ops\n-            // (funny do-while loop)\n-            while {\n-                old = self.lock.load(Ordering::Relaxed);\n-                old & USIZE_MSB != 0\n-            } {\n-                cpu_relax();\n+        loop {\n+            match self.try_read() {\n+                Some(guard) => return guard,\n+                None => cpu_relax(),\n             }\n-\n-            // unset write bit\n-            old &= !USIZE_MSB;\n-\n-            let new = old + 1;\n-            debug_assert!(new != (!USIZE_MSB) & (!0));\n-\n-            self.lock.compare_and_swap(old, new, Ordering::SeqCst) != old\n-        } {\n-            cpu_relax();\n-        }\n-        RwLockReadGuard {\n-            lock: &self.lock,\n-            data: unsafe { & *self.data.get() },\n         }\n     }\n \n@@ -193,21 +193,19 @@ impl<T: ?Sized> RwLock<T>\n     #[inline]\n     pub fn try_read(&self) -> Option<RwLockReadGuard<T>>\n     {\n-        // Old value, with write bit unset\n-        let old = (!USIZE_MSB) & self.lock.load(Ordering::Relaxed);\n-\n-        let new = old + 1;\n-        debug_assert!(new != (!USIZE_MSB) & (!0));\n-        if self.lock.compare_and_swap(old,\n-                                      new,\n-                                      Ordering::SeqCst) == old\n-        {\n+        let value = self.lock.fetch_add(READER, Ordering::Acquire);\n+\n+        // We check the UPGRADED bit here so that new readers are prevented when an UPGRADED lock is held.\n+        // This helps reduce writer starvation.\n+        if value & (WRITER | UPGRADED) != 0 {\n+            // Lock is taken, undo.\n+            self.lock.fetch_sub(READER, Ordering::Release);\n+            None\n+        } else {\n             Some(RwLockReadGuard {\n                 lock: &self.lock,\n-                data: unsafe { & *self.data.get() },\n+                data: unsafe { &*self.data.get() },\n             })\n-        } else {\n-            None\n         }\n     }\n \n@@ -216,20 +214,23 @@ impl<T: ?Sized> RwLock<T>\n     /// This is *extremely* unsafe if there are outstanding `RwLockReadGuard`s\n     /// live, or if called more times than `read` has been called, but can be\n     /// useful in FFI contexts where the caller doesn't know how to deal with\n-    /// RAII.\n+    /// RAII. The underlying atomic operation uses `Ordering::Release`.\n+    #[inline]\n     pub unsafe fn force_read_decrement(&self) {\n-        debug_assert!(self.lock.load(Ordering::Relaxed) & (!USIZE_MSB) > 0);\n-        self.lock.fetch_sub(1, Ordering::SeqCst);\n+        debug_assert!(self.lock.load(Ordering::Relaxed) & !WRITER > 0);\n+        self.lock.fetch_sub(READER, Ordering::Release);\n     }\n \n     /// Force unlock exclusive write access.\n     ///\n     /// This is *extremely* unsafe if there are outstanding `RwLockWriteGuard`s\n     /// live, or if called when there are current readers, but can be useful in\n-    /// FFI contexts where the caller doesn't know how to deal with RAII.\n+    /// FFI contexts where the caller doesn't know how to deal with RAII. The\n+    /// underlying atomic operation uses `Ordering::Release`.\n+    #[inline]\n     pub unsafe fn force_write_unlock(&self) {\n-        debug_assert_eq!(self.lock.load(Ordering::Relaxed), USIZE_MSB);\n-        self.lock.store(0, Ordering::Relaxed);\n+        debug_assert_eq!(self.lock.load(Ordering::Relaxed) & !(WRITER | UPGRADED), 0);\n+        self.lock.fetch_and(!(WRITER | UPGRADED), Ordering::Release);\n     }\n \n     /// Lock this rwlock with exclusive write access, blocking the current\n@@ -251,29 +252,20 @@ impl<T: ?Sized> RwLock<T>\n     /// }\n     /// ```\n     #[inline]\n-    pub fn write<'a>(&'a self) -> RwLockWriteGuard<'a, T>\n+    pub fn write(&self) -> RwLockWriteGuard<T>\n     {\n-        loop\n-        {\n-            // Old value, with write bit unset.\n-            let old = (!USIZE_MSB) & self.lock.load(Ordering::Relaxed);\n-            // Old value, with write bit set.\n-            let new = USIZE_MSB | old;\n-            if self.lock.compare_and_swap(old,\n-                                          new,\n-                                          Ordering::SeqCst) == old\n-            {\n-                // Wait for readers to go away, then lock is ours.\n-                while self.lock.load(Ordering::Relaxed) != USIZE_MSB {\n-                    cpu_relax();\n-                }\n-                break\n+        loop {\n+            // Use compare_exchange_weak as a slight optimisation instead of just calling try_write which\n+            // uses compare_exchange (strong) internally.\n+            if self.lock.compare_exchange_weak(0, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {\n+                return RwLockWriteGuard {\n+                    lock: &self.lock,\n+                    data: unsafe { &mut *self.data.get() },\n+                };\n+            } else {\n+                cpu_relax();\n             }\n         }\n-        RwLockWriteGuard {\n-            lock: &self.lock,\n-            data: unsafe { &mut *self.data.get() },\n-        }\n     }\n \n     /// Attempt to lock this rwlock with exclusive write access.\n@@ -298,10 +290,7 @@ impl<T: ?Sized> RwLock<T>\n     #[inline]\n     pub fn try_write(&self) -> Option<RwLockWriteGuard<T>>\n     {\n-        if self.lock.compare_and_swap(0,\n-                                      USIZE_MSB,\n-                                      Ordering::SeqCst) == 0\n-        {\n+        if self.lock.compare_exchange(0, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {\n             Some(RwLockWriteGuard {\n                 lock: &self.lock,\n                 data: unsafe { &mut *self.data.get() },\n@@ -310,6 +299,111 @@ impl<T: ?Sized> RwLock<T>\n             None\n         }\n     }\n+\n+    /// Obtain a readable lock guard that can later be upgraded to a writable lock guard.\n+    /// Upgrades can be done through the [`RwLock::upgrade`](RwLock::upgrade) method.\n+    #[inline]\n+    pub fn upgradeable_read(&self) -> RwLockUpgradeableGuard<T> {\n+        loop {\n+            match self.try_upgradeable_read() {\n+                Some(guard) => return guard,\n+                None => cpu_relax(),\n+            }\n+        }\n+    }\n+\n+    /// Tries to obtain an upgradeable lock guard.\n+    #[inline]\n+    pub fn try_upgradeable_read(&self) -> Option<RwLockUpgradeableGuard<T>> {\n+        if self.lock.fetch_or(UPGRADED, Ordering::Acquire) & (WRITER | UPGRADED) == 0 {\n+            Some(RwLockUpgradeableGuard {\n+                lock: &self.lock,\n+                data: unsafe { &mut *self.data.get() },\n+            })\n+        } else {\n+            // We can't unflip the UPGRADED bit back just yet as there is another upgradeable or write lock. \n+            // When they unlock, they will clear the bit.\n+            None\n+        }\n+    }\n+\n+    /// Upgrades an upgradeable lock guard to a writable lock guard.\n+    /// \n+    /// ```\n+    /// let mylock = spin::RwLock::new(0);\n+    /// \n+    /// let upgradeable = mylock.upgradeable_read(); // Readable, but not yet writable\n+    /// let writable = mylock.upgrade(upgradeable);\n+    /// ```\n+    #[inline]\n+    pub fn upgrade<'a>(&self, guard: RwLockUpgradeableGuard<'a, T>) -> RwLockWriteGuard<T> {\n+        loop {\n+            // Use compare_exchange_weak as a slight optimisation instead of just calling try_upgrade which\n+            // uses compare_exchange (strong) internally.\n+            if self.lock.compare_exchange_weak(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {\n+                // Upgrade successful - forget the old guard so its destructor doesn't run\n+                mem::forget(guard);\n+\n+                return RwLockWriteGuard {\n+                    lock: &self.lock,\n+                    data: unsafe { &mut *self.data.get() },\n+                };\n+            }\n+\n+            cpu_relax();\n+        }\n+    }\n+\n+    /// Tries to upgrade an upgradeable lock guard to a writable lock guard.\n+    /// \n+    /// ```\n+    /// let mylock = spin::RwLock::new(0);\n+    /// let upgradeable = mylock.upgradeable_read(); // Readable, but not yet writable\n+    /// \n+    /// match mylock.try_upgrade(upgradeable) {\n+    ///     Ok(writable) => /* upgrade successful - use writable lock guard */ (),\n+    ///     Err(upgradeable) => /* upgrade unsuccessful */ (),\n+    /// };\n+    /// ```\n+    #[inline]\n+    pub fn try_upgrade<'a>(&self, guard: RwLockUpgradeableGuard<'a, T>) -> Result<RwLockWriteGuard<T>, RwLockUpgradeableGuard<'a, T>> {\n+        if self.lock.compare_exchange(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {\n+            // Upgrade successful - forget the old guard so its destructor doesn't run\n+            mem::forget(guard);\n+\n+            Ok(RwLockWriteGuard {\n+                lock: &self.lock,\n+                data: unsafe { &mut *self.data.get() },\n+            })\n+        } else {\n+            Err(guard)\n+        }\n+    }\n+\n+    /// Downgrades the writable lock guard to a readable, shared lock guard. Cannot fail and is guaranteed not to spin.\n+    /// \n+    /// ```\n+    /// let mylock = spin::RwLock::new(0);\n+    /// \n+    /// let mut writable = mylock.write();\n+    /// *writable = 1;\n+    /// \n+    /// let readable = mylock.downgrade(writable); // This is guaranteed not to spin\n+    /// # let readable_2 = mylock.try_read().unwrap();\n+    /// assert_eq!(*readable, 1);\n+    /// ```\n+    #[inline]\n+    pub fn downgrade<'a>(&self, guard: RwLockWriteGuard<'a, T>) -> RwLockReadGuard<T> {\n+        self.lock.fetch_add(READER, Ordering::Acquire);\n+\n+        // Remove the WRITER bit\n+        mem::drop(guard);\n+\n+        RwLockReadGuard {\n+            lock: &self.lock,\n+            data: unsafe { &*self.data.get() },\n+        }\n+    }\n }\n \n impl<T: ?Sized + fmt::Debug> fmt::Debug for RwLock<T>\n@@ -338,6 +432,12 @@ impl<'rwlock, T: ?Sized> Deref for RwLockReadGuard<'rwlock, T> {\n     fn deref(&self) -> &T { self.data }\n }\n \n+impl<'rwlock, T: ?Sized> Deref for RwLockUpgradeableGuard<'rwlock, T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T { self.data }\n+}\n+\n impl<'rwlock, T: ?Sized> Deref for RwLockWriteGuard<'rwlock, T> {\n     type Target = T;\n \n@@ -350,15 +450,25 @@ impl<'rwlock, T: ?Sized> DerefMut for RwLockWriteGuard<'rwlock, T> {\n \n impl<'rwlock, T: ?Sized> Drop for RwLockReadGuard<'rwlock, T> {\n     fn drop(&mut self) {\n-        debug_assert!(self.lock.load(Ordering::Relaxed) & (!USIZE_MSB) > 0);\n-        self.lock.fetch_sub(1, Ordering::SeqCst);\n+        debug_assert!(self.lock.load(Ordering::Relaxed) & !(WRITER | UPGRADED) > 0);\n+        self.lock.fetch_sub(READER, Ordering::Release);\n+    }\n+}\n+\n+impl<'rwlock, T: ?Sized> Drop for RwLockUpgradeableGuard<'rwlock, T> {\n+    fn drop(&mut self) {\n+        debug_assert_eq!(self.lock.load(Ordering::Relaxed) & (WRITER | UPGRADED), UPGRADED);\n+        self.lock.fetch_sub(UPGRADED, Ordering::AcqRel);\n     }\n }\n \n impl<'rwlock, T: ?Sized> Drop for RwLockWriteGuard<'rwlock, T> {\n     fn drop(&mut self) {\n-        debug_assert_eq!(self.lock.load(Ordering::Relaxed), USIZE_MSB);\n-        self.lock.store(0, Ordering::Relaxed);\n+        debug_assert_eq!(self.lock.load(Ordering::Relaxed) & WRITER, WRITER);\n+        \n+        // Writer is responsible for clearing both WRITER and UPGRADED bits.\n+        // The UPGRADED bit may be set if an upgradeable lock attempts an upgrade while this lock is held.\n+        self.lock.fetch_and(!(WRITER | UPGRADED), Ordering::Release);\n     }\n }\n \n@@ -451,7 +561,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_rw_arc_access_in_unwind() {\n+    fn test_rw_access_in_unwind() {\n         let arc = Arc::new(RwLock::new(1));\n         let arc2 = arc.clone();\n         let _ = thread::spawn(move|| -> () {\n@@ -499,6 +609,13 @@ mod tests {\n         drop(read_guard);\n     }\n \n+    #[test]\n+    fn test_rw_try_read() {\n+        let m = RwLock::new(0);\n+        mem::forget(m.write());\n+        assert!(m.try_read().is_none());\n+    }\n+\n     #[test]\n     fn test_into_inner() {\n         let m = RwLock::new(NonCopy(10));\n@@ -551,4 +668,26 @@ mod tests {\n         }\n         assert!(m.try_read().is_some());\n     }\n+\n+    #[test]\n+    fn test_upgrade() {\n+        let m = RwLock::new(());\n+        {\n+            let _r = m.read();\n+            let upg = m.try_upgradeable_read().unwrap();\n+            assert!(m.try_read().is_none());\n+            assert!(m.try_write().is_none());\n+            assert!(m.try_upgrade(upg).is_err());\n+        }\n+        {\n+            let _w = m.write();\n+            assert!(m.try_upgradeable_read().is_none());\n+        }\n+        {\n+            let _u = m.upgradeable_read();\n+            assert!(m.try_upgradeable_read().is_none());\n+        }\n+\n+        assert!(m.try_upgrade(m.try_upgradeable_read().unwrap()).is_ok());\n+    }\n }\n",
    "diff_parsed": "{'added': [(6, 'use core::mem;'), (55, 'const READER: usize = 4;'), (56, 'const UPGRADED: usize = 2;'), (57, 'const WRITER: usize = 1;'), (88, '#[derive(Debug)]'), (89, \"pub struct RwLockUpgradeableGuard<'a, T: 'a + ?Sized>\"), (90, '{'), (91, \"    lock: &'a AtomicUsize,\"), (92, \"    data: &'a T,\"), (93, '}'), (127, '    #[inline]'), (161, '    pub fn read(&self) -> RwLockReadGuard<T>'), (163, '        loop {'), (164, '            match self.try_read() {'), (165, '                Some(guard) => return guard,'), (166, '                None => cpu_relax(),'), (196, '        let value = self.lock.fetch_add(READER, Ordering::Acquire);'), (200, '        if value & (WRITER | UPGRADED) != 0 {'), (202, '            self.lock.fetch_sub(READER, Ordering::Release);'), (203, '            None'), (204, '        } else {'), (207, '                data: unsafe { &*self.data.get() },'), (218, '    #[inline]'), (220, '        debug_assert!(self.lock.load(Ordering::Relaxed) & !WRITER > 0);'), (221, '        self.lock.fetch_sub(READER, Ordering::Release);'), (230, '    #[inline]'), (232, '        debug_assert_eq!(self.lock.load(Ordering::Relaxed) & !(WRITER | UPGRADED), 0);'), (233, '        self.lock.fetch_and(!(WRITER | UPGRADED), Ordering::Release);'), (255, '    pub fn write(&self) -> RwLockWriteGuard<T>'), (257, '        loop {'), (260, '            if self.lock.compare_exchange_weak(0, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {'), (261, '                return RwLockWriteGuard {'), (262, '                    lock: &self.lock,'), (263, '                    data: unsafe { &mut *self.data.get() },'), (264, '                };'), (265, '            } else {'), (266, '                cpu_relax();'), (293, '        if self.lock.compare_exchange(0, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {'), (305, '    #[inline]'), (306, '    pub fn upgradeable_read(&self) -> RwLockUpgradeableGuard<T> {'), (307, '        loop {'), (308, '            match self.try_upgradeable_read() {'), (309, '                Some(guard) => return guard,'), (310, '                None => cpu_relax(),'), (311, '            }'), (312, '        }'), (313, '    }'), (316, '    #[inline]'), (317, '    pub fn try_upgradeable_read(&self) -> Option<RwLockUpgradeableGuard<T>> {'), (318, '        if self.lock.fetch_or(UPGRADED, Ordering::Acquire) & (WRITER | UPGRADED) == 0 {'), (319, '            Some(RwLockUpgradeableGuard {'), (320, '                lock: &self.lock,'), (321, '                data: unsafe { &mut *self.data.get() },'), (322, '            })'), (323, '        } else {'), (326, '            None'), (327, '        }'), (328, '    }'), (338, '    #[inline]'), (339, \"    pub fn upgrade<'a>(&self, guard: RwLockUpgradeableGuard<'a, T>) -> RwLockWriteGuard<T> {\"), (340, '        loop {'), (343, '            if self.lock.compare_exchange_weak(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {'), (345, '                mem::forget(guard);'), (347, '                return RwLockWriteGuard {'), (348, '                    lock: &self.lock,'), (349, '                    data: unsafe { &mut *self.data.get() },'), (350, '                };'), (351, '            }'), (353, '            cpu_relax();'), (354, '        }'), (355, '    }'), (368, '    #[inline]'), (369, \"    pub fn try_upgrade<'a>(&self, guard: RwLockUpgradeableGuard<'a, T>) -> Result<RwLockWriteGuard<T>, RwLockUpgradeableGuard<'a, T>> {\"), (370, '        if self.lock.compare_exchange(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {'), (372, '            mem::forget(guard);'), (374, '            Ok(RwLockWriteGuard {'), (375, '                lock: &self.lock,'), (376, '                data: unsafe { &mut *self.data.get() },'), (377, '            })'), (378, '        } else {'), (379, '            Err(guard)'), (380, '        }'), (381, '    }'), (395, '    #[inline]'), (396, \"    pub fn downgrade<'a>(&self, guard: RwLockWriteGuard<'a, T>) -> RwLockReadGuard<T> {\"), (397, '        self.lock.fetch_add(READER, Ordering::Acquire);'), (400, '        mem::drop(guard);'), (402, '        RwLockReadGuard {'), (403, '            lock: &self.lock,'), (404, '            data: unsafe { &*self.data.get() },'), (405, '        }'), (406, '    }'), (435, \"impl<'rwlock, T: ?Sized> Deref for RwLockUpgradeableGuard<'rwlock, T> {\"), (436, '    type Target = T;'), (438, '    fn deref(&self) -> &T { self.data }'), (439, '}'), (453, '        debug_assert!(self.lock.load(Ordering::Relaxed) & !(WRITER | UPGRADED) > 0);'), (454, '        self.lock.fetch_sub(READER, Ordering::Release);'), (455, '    }'), (456, '}'), (458, \"impl<'rwlock, T: ?Sized> Drop for RwLockUpgradeableGuard<'rwlock, T> {\"), (459, '    fn drop(&mut self) {'), (460, '        debug_assert_eq!(self.lock.load(Ordering::Relaxed) & (WRITER | UPGRADED), UPGRADED);'), (461, '        self.lock.fetch_sub(UPGRADED, Ordering::AcqRel);'), (467, '        debug_assert_eq!(self.lock.load(Ordering::Relaxed) & WRITER, WRITER);'), (471, '        self.lock.fetch_and(!(WRITER | UPGRADED), Ordering::Release);'), (564, '    fn test_rw_access_in_unwind() {'), (612, '    #[test]'), (613, '    fn test_rw_try_read() {'), (614, '        let m = RwLock::new(0);'), (615, '        mem::forget(m.write());'), (616, '        assert!(m.try_read().is_none());'), (617, '    }'), (672, '    #[test]'), (673, '    fn test_upgrade() {'), (674, '        let m = RwLock::new(());'), (675, '        {'), (676, '            let _r = m.read();'), (677, '            let upg = m.try_upgradeable_read().unwrap();'), (678, '            assert!(m.try_read().is_none());'), (679, '            assert!(m.try_write().is_none());'), (680, '            assert!(m.try_upgrade(upg).is_err());'), (681, '        }'), (682, '        {'), (683, '            let _w = m.write();'), (684, '            assert!(m.try_upgradeable_read().is_none());'), (685, '        }'), (686, '        {'), (687, '            let _u = m.upgradeable_read();'), (688, '            assert!(m.try_upgradeable_read().is_none());'), (689, '        }'), (691, '        assert!(m.try_upgrade(m.try_upgradeable_read().unwrap()).is_ok());'), (692, '    }')], 'deleted': [(76, 'const USIZE_MSB: usize = ::core::isize::MIN as usize;'), (139, \"    pub fn read<'a>(&'a self) -> RwLockReadGuard<'a, T>\"), (142, '        while {'), (144, '            let mut old;'), (148, '            while {'), (149, '                old = self.lock.load(Ordering::Relaxed);'), (150, '                old & USIZE_MSB != 0'), (151, '            } {'), (152, '                cpu_relax();'), (156, '            old &= !USIZE_MSB;'), (158, '            let new = old + 1;'), (159, '            debug_assert!(new != (!USIZE_MSB) & (!0));'), (161, '            self.lock.compare_and_swap(old, new, Ordering::SeqCst) != old'), (162, '        } {'), (163, '            cpu_relax();'), (164, '        }'), (165, '        RwLockReadGuard {'), (166, '            lock: &self.lock,'), (167, '            data: unsafe { & *self.data.get() },'), (197, '        let old = (!USIZE_MSB) & self.lock.load(Ordering::Relaxed);'), (199, '        let new = old + 1;'), (200, '        debug_assert!(new != (!USIZE_MSB) & (!0));'), (201, '        if self.lock.compare_and_swap(old,'), (202, '                                      new,'), (203, '                                      Ordering::SeqCst) == old'), (204, '        {'), (207, '                data: unsafe { & *self.data.get() },'), (209, '        } else {'), (210, '            None'), (221, '        debug_assert!(self.lock.load(Ordering::Relaxed) & (!USIZE_MSB) > 0);'), (222, '        self.lock.fetch_sub(1, Ordering::SeqCst);'), (231, '        debug_assert_eq!(self.lock.load(Ordering::Relaxed), USIZE_MSB);'), (232, '        self.lock.store(0, Ordering::Relaxed);'), (254, \"    pub fn write<'a>(&'a self) -> RwLockWriteGuard<'a, T>\"), (256, '        loop'), (257, '        {'), (259, '            let old = (!USIZE_MSB) & self.lock.load(Ordering::Relaxed);'), (261, '            let new = USIZE_MSB | old;'), (262, '            if self.lock.compare_and_swap(old,'), (263, '                                          new,'), (264, '                                          Ordering::SeqCst) == old'), (265, '            {'), (267, '                while self.lock.load(Ordering::Relaxed) != USIZE_MSB {'), (268, '                    cpu_relax();'), (269, '                }'), (270, '                break'), (273, '        RwLockWriteGuard {'), (274, '            lock: &self.lock,'), (275, '            data: unsafe { &mut *self.data.get() },'), (276, '        }'), (301, '        if self.lock.compare_and_swap(0,'), (302, '                                      USIZE_MSB,'), (303, '                                      Ordering::SeqCst) == 0'), (304, '        {'), (353, '        debug_assert!(self.lock.load(Ordering::Relaxed) & (!USIZE_MSB) > 0);'), (354, '        self.lock.fetch_sub(1, Ordering::SeqCst);'), (360, '        debug_assert_eq!(self.lock.load(Ordering::Relaxed), USIZE_MSB);'), (361, '        self.lock.store(0, Ordering::Relaxed);'), (454, '    fn test_rw_arc_access_in_unwind() {')]}",
    "num_lines_added": "133",
    "num_lines_deleted": "59",
    "nloc": "388"
  },
  {
    "file_change_id": "199051539905858",
    "hash": "6d1c1e335998339263f651f33d34220c4bebc5c",
    "old_path": "src/rw_lock.rs",
    "new_path": "src/rw_lock.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,9 +1,10 @@\n-use core::sync::atomic::{AtomicUsize, Ordering, spin_loop_hint as cpu_relax};\n use core::cell::UnsafeCell;\n-use core::ops::{Deref, DerefMut};\n-use core::fmt;\n use core::default::Default;\n+use core::fmt;\n use core::mem;\n+use core::ops::{Deref, DerefMut};\n+use core::ptr::NonNull;\n+use core::sync::atomic::{spin_loop_hint as cpu_relax, AtomicUsize, Ordering};\n \n /// A reader-writer lock\n ///\n@@ -17,9 +18,12 @@ use core::mem;\n /// allow concurrent access through readers. The RAII guards returned from the\n /// locking methods implement `Deref` (and `DerefMut` for the `write` methods)\n /// to allow access to the contained of the lock.\n-/// \n-/// Read RAII guards are upgradeable to write RAII locks through the\n-/// [`upgrade`](RwLockReadGuard::upgrade) / [`try_upgrade`](RwLockReadGuard::try_upgrade) functions.\n+///\n+/// An [`RwLockUpgradeableGuard`](RwLockUpgradeableGuard) can be upgraded to a\n+/// writable guard through the [`RwLockUpgradeableGuard::upgrade`](RwLockUpgradeableGuard::upgrade)\n+/// [`RwLockUpgradeableGuard::try_upgrade`](RwLockUpgradeableGuard::try_upgrade) functions.\n+/// Writable or upgradeable guards can be downgraded through their respective `downgrade`\n+/// functions.\n ///\n /// Based on Facebook's\n /// [`folly/RWSpinLock.h`](https://github.com/facebook/folly/blob/a0394d84f2d5c3e50ebfd0566f9d3acb52cfab5a/folly/synchronization/RWSpinLock.h).\n@@ -46,8 +50,7 @@ use core::mem;\n ///     assert_eq!(*w, 6);\n /// } // write lock is dropped here\n /// ```\n-pub struct RwLock<T: ?Sized>\n-{\n+pub struct RwLock<T: ?Sized> {\n     lock: AtomicUsize,\n     data: UnsafeCell<T>,\n }\n@@ -61,43 +64,39 @@ const WRITER: usize = 1;\n /// When the guard falls out of scope it will decrement the read count,\n /// potentially releasing the lock.\n #[derive(Debug)]\n-pub struct RwLockReadGuard<'a, T: 'a + ?Sized>\n-{\n+pub struct RwLockReadGuard<'a, T: 'a + ?Sized> {\n     lock: &'a AtomicUsize,\n-    data: &'a T,\n+    data: NonNull<T>,\n }\n \n /// A guard to which the protected data can be written\n ///\n /// When the guard falls out of scope it will release the lock.\n #[derive(Debug)]\n-pub struct RwLockWriteGuard<'a, T: 'a + ?Sized>\n-{\n+pub struct RwLockWriteGuard<'a, T: 'a + ?Sized> {\n     lock: &'a AtomicUsize,\n-    data: &'a mut T,\n+    data: NonNull<T>,\n }\n \n /// A guard from which the protected data can be read, and can be upgraded\n /// to a writable guard if needed\n-/// \n+///\n /// No writers or other upgradeable guards can exist while this is in scope. New reader\n /// creation is prevented (to alleviate writer starvation) but there may be existing readers\n /// when the lock is acquired.\n-/// \n+///\n /// When the guard falls out of scope it will release the lock.\n #[derive(Debug)]\n-pub struct RwLockUpgradeableGuard<'a, T: 'a + ?Sized>\n-{\n+pub struct RwLockUpgradeableGuard<'a, T: 'a + ?Sized> {\n     lock: &'a AtomicUsize,\n-    data: &'a T,\n+    data: NonNull<T>,\n }\n \n // Same unsafe impls as `std::sync::RwLock`\n unsafe impl<T: ?Sized + Send> Send for RwLock<T> {}\n unsafe impl<T: ?Sized + Send + Sync> Sync for RwLock<T> {}\n \n-impl<T> RwLock<T>\n-{\n+impl<T> RwLock<T> {\n     /// Creates a new spinlock wrapping the supplied data.\n     ///\n     /// May be used statically:\n@@ -114,10 +113,8 @@ impl<T> RwLock<T>\n     /// }\n     /// ```\n     #[inline]\n-    pub const fn new(user_data: T) -> RwLock<T>\n-    {\n-        RwLock\n-        {\n+    pub const fn new(user_data: T) -> RwLock<T> {\n+        RwLock {\n             lock: AtomicUsize::new(0),\n             data: UnsafeCell::new(user_data),\n         }\n@@ -125,8 +122,7 @@ impl<T> RwLock<T>\n \n     /// Consumes this `RwLock`, returning the underlying data.\n     #[inline]\n-    pub fn into_inner(self) -> T\n-    {\n+    pub fn into_inner(self) -> T {\n         // We know statically that there are no outstanding references to\n         // `self` so there's no need to lock.\n         let RwLock { data, .. } = self;\n@@ -134,8 +130,7 @@ impl<T> RwLock<T>\n     }\n }\n \n-impl<T: ?Sized> RwLock<T>\n-{\n+impl<T: ?Sized> RwLock<T> {\n     /// Locks this rwlock with shared read access, blocking the current thread\n     /// until it can be acquired.\n     ///\n@@ -158,8 +153,7 @@ impl<T: ?Sized> RwLock<T>\n     /// }\n     /// ```\n     #[inline]\n-    pub fn read(&self) -> RwLockReadGuard<T>\n-    {\n+    pub fn read(&self) -> RwLockReadGuard<T> {\n         loop {\n             match self.try_read() {\n                 Some(guard) => return guard,\n@@ -191,8 +185,7 @@ impl<T: ?Sized> RwLock<T>\n     /// }\n     /// ```\n     #[inline]\n-    pub fn try_read(&self) -> Option<RwLockReadGuard<T>>\n-    {\n+    pub fn try_read(&self) -> Option<RwLockReadGuard<T>> {\n         let value = self.lock.fetch_add(READER, Ordering::Acquire);\n \n         // We check the UPGRADED bit here so that new readers are prevented when an UPGRADED lock is held.\n@@ -204,7 +197,7 @@ impl<T: ?Sized> RwLock<T>\n         } else {\n             Some(RwLockReadGuard {\n                 lock: &self.lock,\n-                data: unsafe { &*self.data.get() },\n+                data: unsafe { NonNull::new_unchecked(self.data.get()) },\n             })\n         }\n     }\n@@ -252,15 +245,18 @@ impl<T: ?Sized> RwLock<T>\n     /// }\n     /// ```\n     #[inline]\n-    pub fn write(&self) -> RwLockWriteGuard<T>\n-    {\n+    pub fn write(&self) -> RwLockWriteGuard<T> {\n         loop {\n             // Use compare_exchange_weak as a slight optimisation instead of just calling try_write which\n             // uses compare_exchange (strong) internally.\n-            if self.lock.compare_exchange_weak(0, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {\n+            if self\n+                .lock\n+                .compare_exchange_weak(0, WRITER, Ordering::Acquire, Ordering::Relaxed)\n+                .is_ok()\n+            {\n                 return RwLockWriteGuard {\n                     lock: &self.lock,\n-                    data: unsafe { &mut *self.data.get() },\n+                    data: unsafe { NonNull::new_unchecked(self.data.get()) },\n                 };\n             } else {\n                 cpu_relax();\n@@ -288,12 +284,15 @@ impl<T: ?Sized> RwLock<T>\n     /// }\n     /// ```\n     #[inline]\n-    pub fn try_write(&self) -> Option<RwLockWriteGuard<T>>\n-    {\n-        if self.lock.compare_exchange(0, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {\n+    pub fn try_write(&self) -> Option<RwLockWriteGuard<T>> {\n+        if self\n+            .lock\n+            .compare_exchange(0, WRITER, Ordering::Acquire, Ordering::Relaxed)\n+            .is_ok()\n+        {\n             Some(RwLockWriteGuard {\n                 lock: &self.lock,\n-                data: unsafe { &mut *self.data.get() },\n+                data: unsafe { NonNull::new_unchecked(self.data.get()) },\n             })\n         } else {\n             None\n@@ -301,7 +300,7 @@ impl<T: ?Sized> RwLock<T>\n     }\n \n     /// Obtain a readable lock guard that can later be upgraded to a writable lock guard.\n-    /// Upgrades can be done through the [`RwLock::upgrade`](RwLock::upgrade) method.\n+    /// Upgrades can be done through the [`RwLockUpgradeableGuard::upgrade`](RwLockUpgradeableGuard::upgrade) method.\n     #[inline]\n     pub fn upgradeable_read(&self) -> RwLockUpgradeableGuard<T> {\n         loop {\n@@ -318,36 +317,62 @@ impl<T: ?Sized> RwLock<T>\n         if self.lock.fetch_or(UPGRADED, Ordering::Acquire) & (WRITER | UPGRADED) == 0 {\n             Some(RwLockUpgradeableGuard {\n                 lock: &self.lock,\n-                data: unsafe { &mut *self.data.get() },\n+                data: unsafe { NonNull::new_unchecked(self.data.get()) },\n             })\n         } else {\n-            // We can't unflip the UPGRADED bit back just yet as there is another upgradeable or write lock. \n+            // We can't unflip the UPGRADED bit back just yet as there is another upgradeable or write lock.\n             // When they unlock, they will clear the bit.\n             None\n         }\n     }\n+}\n \n+impl<T: ?Sized + fmt::Debug> fmt::Debug for RwLock<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.try_read() {\n+            Some(guard) => write!(f, \"RwLock {{ data: \")\n+                .and_then(|()| (&*guard).fmt(f))\n+                .and_then(|()| write!(f, \"}}\")),\n+            None => write!(f, \"RwLock {{ <locked> }}\"),\n+        }\n+    }\n+}\n+\n+impl<T: ?Sized + Default> Default for RwLock<T> {\n+    fn default() -> RwLock<T> {\n+        RwLock::new(Default::default())\n+    }\n+}\n+\n+impl<'rwlock, T: ?Sized> RwLockUpgradeableGuard<'rwlock, T> {\n     /// Upgrades an upgradeable lock guard to a writable lock guard.\n-    /// \n+    ///\n     /// ```\n     /// let mylock = spin::RwLock::new(0);\n-    /// \n+    ///\n     /// let upgradeable = mylock.upgradeable_read(); // Readable, but not yet writable\n-    /// let writable = mylock.upgrade(upgradeable);\n+    /// let writable = upgradeable.upgrade();\n     /// ```\n     #[inline]\n-    pub fn upgrade<'a>(&self, guard: RwLockUpgradeableGuard<'a, T>) -> RwLockWriteGuard<T> {\n+    pub fn upgrade(self) -> RwLockWriteGuard<'rwlock, T> {\n         loop {\n             // Use compare_exchange_weak as a slight optimisation instead of just calling try_upgrade which\n             // uses compare_exchange (strong) internally.\n-            if self.lock.compare_exchange_weak(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {\n-                // Upgrade successful - forget the old guard so its destructor doesn't run\n-                mem::forget(guard);\n-\n-                return RwLockWriteGuard {\n-                    lock: &self.lock,\n-                    data: unsafe { &mut *self.data.get() },\n+            if self\n+                .lock\n+                .compare_exchange_weak(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed)\n+                .is_ok()\n+            {\n+                // Upgrade successful\n+                let out = RwLockWriteGuard {\n+                    lock: self.lock,\n+                    data: self.data,\n                 };\n+\n+                // Forget the old guard so its destructor doesn't run\n+                mem::forget(self);\n+\n+                return out;\n             }\n \n             cpu_relax();\n@@ -355,97 +380,120 @@ impl<T: ?Sized> RwLock<T>\n     }\n \n     /// Tries to upgrade an upgradeable lock guard to a writable lock guard.\n-    /// \n+    ///\n     /// ```\n     /// let mylock = spin::RwLock::new(0);\n     /// let upgradeable = mylock.upgradeable_read(); // Readable, but not yet writable\n-    /// \n-    /// match mylock.try_upgrade(upgradeable) {\n+    ///\n+    /// match upgradeable.try_upgrade() {\n     ///     Ok(writable) => /* upgrade successful - use writable lock guard */ (),\n     ///     Err(upgradeable) => /* upgrade unsuccessful */ (),\n     /// };\n     /// ```\n     #[inline]\n-    pub fn try_upgrade<'a>(&self, guard: RwLockUpgradeableGuard<'a, T>) -> Result<RwLockWriteGuard<T>, RwLockUpgradeableGuard<'a, T>> {\n-        if self.lock.compare_exchange(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {\n-            // Upgrade successful - forget the old guard so its destructor doesn't run\n-            mem::forget(guard);\n-\n-            Ok(RwLockWriteGuard {\n+    pub fn try_upgrade(self) -> Result<RwLockWriteGuard<'rwlock, T>, Self> {\n+        if self\n+            .lock\n+            .compare_exchange(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed)\n+            .is_ok()\n+        {\n+            // Upgrade successful\n+            let out = Ok(RwLockWriteGuard {\n                 lock: &self.lock,\n-                data: unsafe { &mut *self.data.get() },\n-            })\n+                data: self.data,\n+            });\n+\n+            // Forget the old guard so its destructor doesn't run\n+            mem::forget(self);\n+\n+            out\n         } else {\n-            Err(guard)\n+            Err(self)\n+        }\n+    }\n+\n+    #[inline]\n+    /// Downgrades the upgradeable lock guard to a readable, shared lock guard. Cannot fail and is guaranteed not to spin.\n+    ///\n+    /// ```\n+    /// let mylock = spin::RwLock::new(1);\n+    ///\n+    /// let upgradeable = mylock.upgradeable_read();\n+    /// assert!(mylock.try_read().is_none());\n+    /// assert_eq!(*upgradeable, 1);\n+    ///\n+    /// let readable = upgradeable.downgrade(); // This is guaranteed not to spin\n+    /// assert!(mylock.try_read().is_some());\n+    /// assert_eq!(*readable, 1);\n+    /// ```\n+    pub fn downgrade(self) -> RwLockReadGuard<'rwlock, T> {\n+        // Reserve the read guard for ourselves\n+        self.lock.fetch_add(READER, Ordering::Acquire);\n+\n+        RwLockReadGuard {\n+            lock: &self.lock,\n+            data: self.data,\n         }\n+\n+        // Dropping self removes the UPGRADED bit\n     }\n+}\n \n+impl<'rwlock, T: ?Sized> RwLockWriteGuard<'rwlock, T> {\n     /// Downgrades the writable lock guard to a readable, shared lock guard. Cannot fail and is guaranteed not to spin.\n-    /// \n+    ///\n     /// ```\n     /// let mylock = spin::RwLock::new(0);\n-    /// \n+    ///\n     /// let mut writable = mylock.write();\n     /// *writable = 1;\n-    /// \n-    /// let readable = mylock.downgrade(writable); // This is guaranteed not to spin\n+    ///\n+    /// let readable = writable.downgrade(); // This is guaranteed not to spin\n     /// # let readable_2 = mylock.try_read().unwrap();\n     /// assert_eq!(*readable, 1);\n     /// ```\n     #[inline]\n-    pub fn downgrade<'a>(&self, guard: RwLockWriteGuard<'a, T>) -> RwLockReadGuard<T> {\n+    pub fn downgrade(self) -> RwLockReadGuard<'rwlock, T> {\n+        // Reserve the read guard for ourselves\n         self.lock.fetch_add(READER, Ordering::Acquire);\n \n-        // Remove the WRITER bit\n-        mem::drop(guard);\n-\n         RwLockReadGuard {\n             lock: &self.lock,\n-            data: unsafe { &*self.data.get() },\n+            data: self.data,\n         }\n-    }\n-}\n \n-impl<T: ?Sized + fmt::Debug> fmt::Debug for RwLock<T>\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result\n-    {\n-        match self.try_read()\n-        {\n-            Some(guard) => write!(f, \"RwLock {{ data: \")\n-                .and_then(|()| (&*guard).fmt(f))\n-                .and_then(|()| write!(f, \"}}\")),\n-            None => write!(f, \"RwLock {{ <locked> }}\"),\n-        }\n-    }\n-}\n-\n-impl<T: ?Sized + Default> Default for RwLock<T> {\n-    fn default() -> RwLock<T> {\n-        RwLock::new(Default::default())\n+        // Dropping self removes the WRITER bit\n     }\n }\n \n impl<'rwlock, T: ?Sized> Deref for RwLockReadGuard<'rwlock, T> {\n     type Target = T;\n \n-    fn deref(&self) -> &T { self.data }\n+    fn deref(&self) -> &T {\n+        unsafe { self.data.as_ref() }\n+    }\n }\n \n impl<'rwlock, T: ?Sized> Deref for RwLockUpgradeableGuard<'rwlock, T> {\n     type Target = T;\n \n-    fn deref(&self) -> &T { self.data }\n+    fn deref(&self) -> &T {\n+        unsafe { self.data.as_ref() }\n+    }\n }\n \n impl<'rwlock, T: ?Sized> Deref for RwLockWriteGuard<'rwlock, T> {\n     type Target = T;\n \n-    fn deref(&self) -> &T { self.data }\n+    fn deref(&self) -> &T {\n+        unsafe { self.data.as_ref() }\n+    }\n }\n \n impl<'rwlock, T: ?Sized> DerefMut for RwLockWriteGuard<'rwlock, T> {\n-    fn deref_mut(&mut self) -> &mut T { self.data }\n+    fn deref_mut(&mut self) -> &mut T {\n+        unsafe { self.data.as_mut() }\n+    }\n }\n \n impl<'rwlock, T: ?Sized> Drop for RwLockReadGuard<'rwlock, T> {\n@@ -457,7 +505,10 @@ impl<'rwlock, T: ?Sized> Drop for RwLockReadGuard<'rwlock, T> {\n \n impl<'rwlock, T: ?Sized> Drop for RwLockUpgradeableGuard<'rwlock, T> {\n     fn drop(&mut self) {\n-        debug_assert_eq!(self.lock.load(Ordering::Relaxed) & (WRITER | UPGRADED), UPGRADED);\n+        debug_assert_eq!(\n+            self.lock.load(Ordering::Relaxed) & (WRITER | UPGRADED),\n+            UPGRADED\n+        );\n         self.lock.fetch_sub(UPGRADED, Ordering::AcqRel);\n     }\n }\n@@ -465,7 +516,7 @@ impl<'rwlock, T: ?Sized> Drop for RwLockUpgradeableGuard<'rwlock, T> {\n impl<'rwlock, T: ?Sized> Drop for RwLockWriteGuard<'rwlock, T> {\n     fn drop(&mut self) {\n         debug_assert_eq!(self.lock.load(Ordering::Relaxed) & WRITER, WRITER);\n-        \n+\n         // Writer is responsible for clearing both WRITER and UPGRADED bits.\n         // The UPGRADED bit may be set if an upgradeable lock attempts an upgrade while this lock is held.\n         self.lock.fetch_and(!(WRITER | UPGRADED), Ordering::Release);\n@@ -476,9 +527,9 @@ impl<'rwlock, T: ?Sized> Drop for RwLockWriteGuard<'rwlock, T> {\n mod tests {\n     use std::prelude::v1::*;\n \n-    use std::sync::Arc;\n-    use std::sync::mpsc::channel;\n     use std::sync::atomic::{AtomicUsize, Ordering};\n+    use std::sync::mpsc::channel;\n+    use std::sync::Arc;\n     use std::thread;\n \n     use super::*;\n@@ -528,7 +579,7 @@ mod tests {\n         let arc2 = arc.clone();\n         let (tx, rx) = channel();\n \n-        thread::spawn(move|| {\n+        thread::spawn(move || {\n             let mut lock = arc2.write();\n             for _ in 0..10 {\n                 let tmp = *lock;\n@@ -543,7 +594,7 @@ mod tests {\n         let mut children = Vec::new();\n         for _ in 0..5 {\n             let arc3 = arc.clone();\n-            children.push(thread::spawn(move|| {\n+            children.push(thread::spawn(move || {\n                 let lock = arc3.read();\n                 assert!(*lock >= 0);\n             }));\n@@ -564,7 +615,7 @@ mod tests {\n     fn test_rw_access_in_unwind() {\n         let arc = Arc::new(RwLock::new(1));\n         let arc2 = arc.clone();\n-        let _ = thread::spawn(move|| -> () {\n+        let _ = thread::spawn(move || -> () {\n             struct Unwinder {\n                 i: Arc<RwLock<isize>>,\n             }\n@@ -576,7 +627,8 @@ mod tests {\n             }\n             let _u = Unwinder { i: arc2 };\n             panic!();\n-        }).join();\n+        })\n+        .join();\n         let lock = arc.read();\n         assert_eq!(*lock, 2);\n     }\n@@ -603,7 +655,10 @@ mod tests {\n         let write_result = lock.try_write();\n         match write_result {\n             None => (),\n-            Some(_) => assert!(false, \"try_write should not succeed while read_guard is in scope\"),\n+            Some(_) => assert!(\n+                false,\n+                \"try_write should not succeed while read_guard is in scope\"\n+            ),\n         }\n \n         drop(read_guard);\n@@ -670,24 +725,28 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_upgrade() {\n+    fn test_upgrade_downgrade() {\n         let m = RwLock::new(());\n         {\n             let _r = m.read();\n             let upg = m.try_upgradeable_read().unwrap();\n             assert!(m.try_read().is_none());\n             assert!(m.try_write().is_none());\n-            assert!(m.try_upgrade(upg).is_err());\n+            assert!(upg.try_upgrade().is_err());\n         }\n         {\n-            let _w = m.write();\n+            let w = m.write();\n             assert!(m.try_upgradeable_read().is_none());\n+            let _r = w.downgrade();\n+            assert!(m.try_upgradeable_read().is_some());\n+            assert!(m.try_read().is_some());\n+            assert!(m.try_write().is_none());\n         }\n         {\n             let _u = m.upgradeable_read();\n             assert!(m.try_upgradeable_read().is_none());\n         }\n \n-        assert!(m.try_upgrade(m.try_upgradeable_read().unwrap()).is_ok());\n+        assert!(m.try_upgradeable_read().unwrap().try_upgrade().is_ok());\n     }\n }\n",
    "diff_parsed": "{'added': [(3, 'use core::fmt;'), (5, 'use core::ops::{Deref, DerefMut};'), (6, 'use core::ptr::NonNull;'), (7, 'use core::sync::atomic::{spin_loop_hint as cpu_relax, AtomicUsize, Ordering};'), (53, 'pub struct RwLock<T: ?Sized> {'), (67, \"pub struct RwLockReadGuard<'a, T: 'a + ?Sized> {\"), (69, '    data: NonNull<T>,'), (76, \"pub struct RwLockWriteGuard<'a, T: 'a + ?Sized> {\"), (78, '    data: NonNull<T>,'), (90, \"pub struct RwLockUpgradeableGuard<'a, T: 'a + ?Sized> {\"), (92, '    data: NonNull<T>,'), (99, 'impl<T> RwLock<T> {'), (116, '    pub const fn new(user_data: T) -> RwLock<T> {'), (117, '        RwLock {'), (125, '    pub fn into_inner(self) -> T {'), (133, 'impl<T: ?Sized> RwLock<T> {'), (156, '    pub fn read(&self) -> RwLockReadGuard<T> {'), (188, '    pub fn try_read(&self) -> Option<RwLockReadGuard<T>> {'), (200, '                data: unsafe { NonNull::new_unchecked(self.data.get()) },'), (248, '    pub fn write(&self) -> RwLockWriteGuard<T> {'), (252, '            if self'), (253, '                .lock'), (254, '                .compare_exchange_weak(0, WRITER, Ordering::Acquire, Ordering::Relaxed)'), (255, '                .is_ok()'), (256, '            {'), (259, '                    data: unsafe { NonNull::new_unchecked(self.data.get()) },'), (287, '    pub fn try_write(&self) -> Option<RwLockWriteGuard<T>> {'), (288, '        if self'), (289, '            .lock'), (290, '            .compare_exchange(0, WRITER, Ordering::Acquire, Ordering::Relaxed)'), (291, '            .is_ok()'), (292, '        {'), (295, '                data: unsafe { NonNull::new_unchecked(self.data.get()) },'), (320, '                data: unsafe { NonNull::new_unchecked(self.data.get()) },'), (328, '}'), (330, 'impl<T: ?Sized + fmt::Debug> fmt::Debug for RwLock<T> {'), (331, '    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {'), (332, '        match self.try_read() {'), (333, '            Some(guard) => write!(f, \"RwLock {{ data: \")'), (334, '                .and_then(|()| (&*guard).fmt(f))'), (335, '                .and_then(|()| write!(f, \"}}\")),'), (336, '            None => write!(f, \"RwLock {{ <locked> }}\"),'), (337, '        }'), (338, '    }'), (339, '}'), (341, 'impl<T: ?Sized + Default> Default for RwLock<T> {'), (342, '    fn default() -> RwLock<T> {'), (343, '        RwLock::new(Default::default())'), (344, '    }'), (345, '}'), (347, \"impl<'rwlock, T: ?Sized> RwLockUpgradeableGuard<'rwlock, T> {\"), (357, \"    pub fn upgrade(self) -> RwLockWriteGuard<'rwlock, T> {\"), (361, '            if self'), (362, '                .lock'), (363, '                .compare_exchange_weak(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed)'), (364, '                .is_ok()'), (365, '            {'), (367, '                let out = RwLockWriteGuard {'), (368, '                    lock: self.lock,'), (369, '                    data: self.data,'), (373, '                mem::forget(self);'), (375, '                return out;'), (394, \"    pub fn try_upgrade(self) -> Result<RwLockWriteGuard<'rwlock, T>, Self> {\"), (395, '        if self'), (396, '            .lock'), (397, '            .compare_exchange(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed)'), (398, '            .is_ok()'), (399, '        {'), (401, '            let out = Ok(RwLockWriteGuard {'), (403, '                data: self.data,'), (404, '            });'), (407, '            mem::forget(self);'), (409, '            out'), (411, '            Err(self)'), (412, '        }'), (413, '    }'), (415, '    #[inline]'), (429, \"    pub fn downgrade(self) -> RwLockReadGuard<'rwlock, T> {\"), (431, '        self.lock.fetch_add(READER, Ordering::Acquire);'), (433, '        RwLockReadGuard {'), (434, '            lock: &self.lock,'), (435, '            data: self.data,'), (440, '}'), (442, \"impl<'rwlock, T: ?Sized> RwLockWriteGuard<'rwlock, T> {\"), (456, \"    pub fn downgrade(self) -> RwLockReadGuard<'rwlock, T> {\"), (462, '            data: self.data,'), (472, '    fn deref(&self) -> &T {'), (473, '        unsafe { self.data.as_ref() }'), (474, '    }'), (480, '    fn deref(&self) -> &T {'), (481, '        unsafe { self.data.as_ref() }'), (482, '    }'), (488, '    fn deref(&self) -> &T {'), (489, '        unsafe { self.data.as_ref() }'), (490, '    }'), (494, '    fn deref_mut(&mut self) -> &mut T {'), (495, '        unsafe { self.data.as_mut() }'), (496, '    }'), (508, '        debug_assert_eq!('), (509, '            self.lock.load(Ordering::Relaxed) & (WRITER | UPGRADED),'), (510, '            UPGRADED'), (511, '        );'), (531, '    use std::sync::mpsc::channel;'), (532, '    use std::sync::Arc;'), (582, '        thread::spawn(move || {'), (597, '            children.push(thread::spawn(move || {'), (618, '        let _ = thread::spawn(move || -> () {'), (630, '        })'), (631, '        .join();'), (658, '            Some(_) => assert!('), (659, '                false,'), (660, '                \"try_write should not succeed while read_guard is in scope\"'), (661, '            ),'), (728, '    fn test_upgrade_downgrade() {'), (735, '            assert!(upg.try_upgrade().is_err());'), (738, '            let w = m.write();'), (740, '            let _r = w.downgrade();'), (741, '            assert!(m.try_upgradeable_read().is_some());'), (742, '            assert!(m.try_read().is_some());'), (743, '            assert!(m.try_write().is_none());'), (750, '        assert!(m.try_upgradeable_read().unwrap().try_upgrade().is_ok());')], 'deleted': [(1, 'use core::sync::atomic::{AtomicUsize, Ordering, spin_loop_hint as cpu_relax};'), (3, 'use core::ops::{Deref, DerefMut};'), (4, 'use core::fmt;'), (49, 'pub struct RwLock<T: ?Sized>'), (50, '{'), (64, \"pub struct RwLockReadGuard<'a, T: 'a + ?Sized>\"), (65, '{'), (67, \"    data: &'a T,\"), (74, \"pub struct RwLockWriteGuard<'a, T: 'a + ?Sized>\"), (75, '{'), (77, \"    data: &'a mut T,\"), (89, \"pub struct RwLockUpgradeableGuard<'a, T: 'a + ?Sized>\"), (90, '{'), (92, \"    data: &'a T,\"), (99, 'impl<T> RwLock<T>'), (100, '{'), (117, '    pub const fn new(user_data: T) -> RwLock<T>'), (118, '    {'), (119, '        RwLock'), (120, '        {'), (128, '    pub fn into_inner(self) -> T'), (129, '    {'), (137, 'impl<T: ?Sized> RwLock<T>'), (138, '{'), (161, '    pub fn read(&self) -> RwLockReadGuard<T>'), (162, '    {'), (194, '    pub fn try_read(&self) -> Option<RwLockReadGuard<T>>'), (195, '    {'), (207, '                data: unsafe { &*self.data.get() },'), (255, '    pub fn write(&self) -> RwLockWriteGuard<T>'), (256, '    {'), (260, '            if self.lock.compare_exchange_weak(0, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {'), (263, '                    data: unsafe { &mut *self.data.get() },'), (291, '    pub fn try_write(&self) -> Option<RwLockWriteGuard<T>>'), (292, '    {'), (293, '        if self.lock.compare_exchange(0, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {'), (296, '                data: unsafe { &mut *self.data.get() },'), (321, '                data: unsafe { &mut *self.data.get() },'), (339, \"    pub fn upgrade<'a>(&self, guard: RwLockUpgradeableGuard<'a, T>) -> RwLockWriteGuard<T> {\"), (343, '            if self.lock.compare_exchange_weak(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {'), (345, '                mem::forget(guard);'), (347, '                return RwLockWriteGuard {'), (348, '                    lock: &self.lock,'), (349, '                    data: unsafe { &mut *self.data.get() },'), (369, \"    pub fn try_upgrade<'a>(&self, guard: RwLockUpgradeableGuard<'a, T>) -> Result<RwLockWriteGuard<T>, RwLockUpgradeableGuard<'a, T>> {\"), (370, '        if self.lock.compare_exchange(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {'), (372, '            mem::forget(guard);'), (374, '            Ok(RwLockWriteGuard {'), (376, '                data: unsafe { &mut *self.data.get() },'), (377, '            })'), (379, '            Err(guard)'), (396, \"    pub fn downgrade<'a>(&self, guard: RwLockWriteGuard<'a, T>) -> RwLockReadGuard<T> {\"), (400, '        mem::drop(guard);'), (404, '            data: unsafe { &*self.data.get() },'), (406, '    }'), (407, '}'), (409, 'impl<T: ?Sized + fmt::Debug> fmt::Debug for RwLock<T>'), (410, '{'), (411, '    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result'), (412, '    {'), (413, '        match self.try_read()'), (414, '        {'), (415, '            Some(guard) => write!(f, \"RwLock {{ data: \")'), (416, '                .and_then(|()| (&*guard).fmt(f))'), (417, '                .and_then(|()| write!(f, \"}}\")),'), (418, '            None => write!(f, \"RwLock {{ <locked> }}\"),'), (419, '        }'), (420, '    }'), (421, '}'), (423, 'impl<T: ?Sized + Default> Default for RwLock<T> {'), (424, '    fn default() -> RwLock<T> {'), (425, '        RwLock::new(Default::default())'), (432, '    fn deref(&self) -> &T { self.data }'), (438, '    fn deref(&self) -> &T { self.data }'), (444, '    fn deref(&self) -> &T { self.data }'), (448, '    fn deref_mut(&mut self) -> &mut T { self.data }'), (460, '        debug_assert_eq!(self.lock.load(Ordering::Relaxed) & (WRITER | UPGRADED), UPGRADED);'), (479, '    use std::sync::Arc;'), (480, '    use std::sync::mpsc::channel;'), (531, '        thread::spawn(move|| {'), (546, '            children.push(thread::spawn(move|| {'), (567, '        let _ = thread::spawn(move|| -> () {'), (579, '        }).join();'), (606, '            Some(_) => assert!(false, \"try_write should not succeed while read_guard is in scope\"),'), (673, '    fn test_upgrade() {'), (680, '            assert!(m.try_upgrade(upg).is_err());'), (683, '            let _w = m.write();'), (691, '        assert!(m.try_upgrade(m.try_upgradeable_read().unwrap()).is_ok());')]}",
    "num_lines_added": "121",
    "num_lines_deleted": "88",
    "nloc": "471"
  },
  {
    "file_change_id": "226024033273744",
    "hash": "2aab6e058ae16f9caa3aff2a6bf2602926eb60a",
    "old_path": "src/rw_lock.rs",
    "new_path": "src/rw_lock.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -4,6 +4,7 @@ use core::fmt;\n use core::mem;\n use core::ops::{Deref, DerefMut};\n use core::ptr::NonNull;\n+use core::marker::PhantomData;\n use core::sync::atomic::{spin_loop_hint as cpu_relax, AtomicUsize, Ordering};\n \n /// A reader-writer lock\n@@ -76,6 +77,8 @@ pub struct RwLockReadGuard<'a, T: 'a + ?Sized> {\n pub struct RwLockWriteGuard<'a, T: 'a + ?Sized> {\n     lock: &'a AtomicUsize,\n     data: NonNull<T>,\n+    #[doc(hidden)]\n+    _invariant: PhantomData<&'a mut T>,\n }\n \n /// A guard from which the protected data can be read, and can be upgraded\n@@ -90,6 +93,8 @@ pub struct RwLockWriteGuard<'a, T: 'a + ?Sized> {\n pub struct RwLockUpgradeableGuard<'a, T: 'a + ?Sized> {\n     lock: &'a AtomicUsize,\n     data: NonNull<T>,\n+    #[doc(hidden)]\n+    _invariant: PhantomData<&'a mut T>,\n }\n \n // Same unsafe impls as `std::sync::RwLock`\n@@ -257,6 +262,7 @@ impl<T: ?Sized> RwLock<T> {\n                 return RwLockWriteGuard {\n                     lock: &self.lock,\n                     data: unsafe { NonNull::new_unchecked(self.data.get()) },\n+                    _invariant: PhantomData,\n                 };\n             } else {\n                 cpu_relax();\n@@ -293,6 +299,7 @@ impl<T: ?Sized> RwLock<T> {\n             Some(RwLockWriteGuard {\n                 lock: &self.lock,\n                 data: unsafe { NonNull::new_unchecked(self.data.get()) },\n+                _invariant: PhantomData,\n             })\n         } else {\n             None\n@@ -318,6 +325,7 @@ impl<T: ?Sized> RwLock<T> {\n             Some(RwLockUpgradeableGuard {\n                 lock: &self.lock,\n                 data: unsafe { NonNull::new_unchecked(self.data.get()) },\n+                _invariant: PhantomData,\n             })\n         } else {\n             // We can't unflip the UPGRADED bit back just yet as there is another upgradeable or write lock.\n@@ -367,6 +375,7 @@ impl<'rwlock, T: ?Sized> RwLockUpgradeableGuard<'rwlock, T> {\n                 let out = RwLockWriteGuard {\n                     lock: self.lock,\n                     data: self.data,\n+                    _invariant: PhantomData,\n                 };\n \n                 // Forget the old guard so its destructor doesn't run\n@@ -401,6 +410,7 @@ impl<'rwlock, T: ?Sized> RwLockUpgradeableGuard<'rwlock, T> {\n             let out = Ok(RwLockWriteGuard {\n                 lock: &self.lock,\n                 data: self.data,\n+                _invariant: PhantomData,\n             });\n \n             // Forget the old guard so its destructor doesn't run\n",
    "diff_parsed": "{'added': [(7, 'use core::marker::PhantomData;'), (80, '    #[doc(hidden)]'), (81, \"    _invariant: PhantomData<&'a mut T>,\"), (96, '    #[doc(hidden)]'), (97, \"    _invariant: PhantomData<&'a mut T>,\"), (265, '                    _invariant: PhantomData,'), (302, '                _invariant: PhantomData,'), (328, '                _invariant: PhantomData,'), (378, '                    _invariant: PhantomData,'), (413, '                _invariant: PhantomData,')], 'deleted': []}",
    "num_lines_added": "10",
    "num_lines_deleted": "0",
    "nloc": "490"
  },
  {
    "file_change_id": "124677808837010",
    "hash": "ba0220287e8801d6ecff0de2199b39d2e699698",
    "old_path": "src/rw_lock.rs",
    "new_path": "src/rw_lock.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,10 +1,10 @@\n use core::cell::UnsafeCell;\n use core::default::Default;\n use core::fmt;\n+use core::marker::PhantomData;\n use core::mem;\n use core::ops::{Deref, DerefMut};\n use core::ptr::NonNull;\n-use core::marker::PhantomData;\n use core::sync::atomic::{spin_loop_hint as cpu_relax, AtomicUsize, Ordering};\n \n /// A reader-writer lock\n@@ -231,6 +231,28 @@ impl<T: ?Sized> RwLock<T> {\n         self.lock.fetch_and(!(WRITER | UPGRADED), Ordering::Release);\n     }\n \n+    #[inline(always)]\n+    fn try_write_internal(&self, strong: bool) -> Option<RwLockWriteGuard<T>> {\n+        if compare_exchange(\n+            &self.lock,\n+            0,\n+            WRITER,\n+            Ordering::Acquire,\n+            Ordering::Relaxed,\n+            strong,\n+        )\n+        .is_ok()\n+        {\n+            Some(RwLockWriteGuard {\n+                lock: &self.lock,\n+                data: unsafe { NonNull::new_unchecked(self.data.get()) },\n+                _invariant: PhantomData,\n+            })\n+        } else {\n+            None\n+        }\n+    }\n+\n     /// Lock this rwlock with exclusive write access, blocking the current\n     /// thread until it can be acquired.\n     ///\n@@ -252,20 +274,9 @@ impl<T: ?Sized> RwLock<T> {\n     #[inline]\n     pub fn write(&self) -> RwLockWriteGuard<T> {\n         loop {\n-            // Use compare_exchange_weak as a slight optimisation instead of just calling try_write which\n-            // uses compare_exchange (strong) internally.\n-            if self\n-                .lock\n-                .compare_exchange_weak(0, WRITER, Ordering::Acquire, Ordering::Relaxed)\n-                .is_ok()\n-            {\n-                return RwLockWriteGuard {\n-                    lock: &self.lock,\n-                    data: unsafe { NonNull::new_unchecked(self.data.get()) },\n-                    _invariant: PhantomData,\n-                };\n-            } else {\n-                cpu_relax();\n+            match self.try_write_internal(false) {\n+                Some(guard) => return guard,\n+                None => cpu_relax(),\n             }\n         }\n     }\n@@ -291,19 +302,7 @@ impl<T: ?Sized> RwLock<T> {\n     /// ```\n     #[inline]\n     pub fn try_write(&self) -> Option<RwLockWriteGuard<T>> {\n-        if self\n-            .lock\n-            .compare_exchange(0, WRITER, Ordering::Acquire, Ordering::Relaxed)\n-            .is_ok()\n-        {\n-            Some(RwLockWriteGuard {\n-                lock: &self.lock,\n-                data: unsafe { NonNull::new_unchecked(self.data.get()) },\n-                _invariant: PhantomData,\n-            })\n-        } else {\n-            None\n-        }\n+        self.try_write_internal(false)\n     }\n \n     /// Obtain a readable lock guard that can later be upgraded to a writable lock guard.\n@@ -353,6 +352,34 @@ impl<T: ?Sized + Default> Default for RwLock<T> {\n }\n \n impl<'rwlock, T: ?Sized> RwLockUpgradeableGuard<'rwlock, T> {\n+    #[inline(always)]\n+    fn try_upgrade_internal(self, strong: bool) -> Result<RwLockWriteGuard<'rwlock, T>, Self> {\n+        if compare_exchange(\n+            &self.lock,\n+            UPGRADED,\n+            WRITER,\n+            Ordering::Acquire,\n+            Ordering::Relaxed,\n+            strong,\n+        )\n+        .is_ok()\n+        {\n+            // Upgrade successful\n+            let out = Ok(RwLockWriteGuard {\n+                lock: &self.lock,\n+                data: self.data,\n+                _invariant: PhantomData,\n+            });\n+\n+            // Forget the old guard so its destructor doesn't run\n+            mem::forget(self);\n+\n+            out\n+        } else {\n+            Err(self)\n+        }\n+    }\n+\n     /// Upgrades an upgradeable lock guard to a writable lock guard.\n     ///\n     /// ```\n@@ -362,27 +389,12 @@ impl<'rwlock, T: ?Sized> RwLockUpgradeableGuard<'rwlock, T> {\n     /// let writable = upgradeable.upgrade();\n     /// ```\n     #[inline]\n-    pub fn upgrade(self) -> RwLockWriteGuard<'rwlock, T> {\n+    pub fn upgrade(mut self) -> RwLockWriteGuard<'rwlock, T> {\n         loop {\n-            // Use compare_exchange_weak as a slight optimisation instead of just calling try_upgrade which\n-            // uses compare_exchange (strong) internally.\n-            if self\n-                .lock\n-                .compare_exchange_weak(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed)\n-                .is_ok()\n-            {\n-                // Upgrade successful\n-                let out = RwLockWriteGuard {\n-                    lock: self.lock,\n-                    data: self.data,\n-                    _invariant: PhantomData,\n-                };\n-\n-                // Forget the old guard so its destructor doesn't run\n-                mem::forget(self);\n-\n-                return out;\n-            }\n+            self = match self.try_upgrade_internal(false) {\n+                Ok(guard) => return guard,\n+                Err(e) => e,\n+            };\n \n             cpu_relax();\n         }\n@@ -401,25 +413,7 @@ impl<'rwlock, T: ?Sized> RwLockUpgradeableGuard<'rwlock, T> {\n     /// ```\n     #[inline]\n     pub fn try_upgrade(self) -> Result<RwLockWriteGuard<'rwlock, T>, Self> {\n-        if self\n-            .lock\n-            .compare_exchange(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed)\n-            .is_ok()\n-        {\n-            // Upgrade successful\n-            let out = Ok(RwLockWriteGuard {\n-                lock: &self.lock,\n-                data: self.data,\n-                _invariant: PhantomData,\n-            });\n-\n-            // Forget the old guard so its destructor doesn't run\n-            mem::forget(self);\n-\n-            out\n-        } else {\n-            Err(self)\n-        }\n+        self.try_upgrade_internal(true)\n     }\n \n     #[inline]\n@@ -533,6 +527,22 @@ impl<'rwlock, T: ?Sized> Drop for RwLockWriteGuard<'rwlock, T> {\n     }\n }\n \n+#[inline(always)]\n+fn compare_exchange(\n+    atomic: &AtomicUsize,\n+    current: usize,\n+    new: usize,\n+    success: Ordering,\n+    failure: Ordering,\n+    strong: bool,\n+) -> Result<usize, usize> {\n+    if strong {\n+        atomic.compare_exchange(current, new, success, failure)\n+    } else {\n+        atomic.compare_exchange_weak(current, new, success, failure)\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use std::prelude::v1::*;\n",
    "diff_parsed": "{'added': [(4, 'use core::marker::PhantomData;'), (234, '    #[inline(always)]'), (235, '    fn try_write_internal(&self, strong: bool) -> Option<RwLockWriteGuard<T>> {'), (236, '        if compare_exchange('), (237, '            &self.lock,'), (238, '            0,'), (239, '            WRITER,'), (240, '            Ordering::Acquire,'), (241, '            Ordering::Relaxed,'), (242, '            strong,'), (243, '        )'), (244, '        .is_ok()'), (245, '        {'), (246, '            Some(RwLockWriteGuard {'), (247, '                lock: &self.lock,'), (248, '                data: unsafe { NonNull::new_unchecked(self.data.get()) },'), (249, '                _invariant: PhantomData,'), (250, '            })'), (251, '        } else {'), (252, '            None'), (253, '        }'), (254, '    }'), (277, '            match self.try_write_internal(false) {'), (278, '                Some(guard) => return guard,'), (279, '                None => cpu_relax(),'), (305, '        self.try_write_internal(false)'), (355, '    #[inline(always)]'), (356, \"    fn try_upgrade_internal(self, strong: bool) -> Result<RwLockWriteGuard<'rwlock, T>, Self> {\"), (357, '        if compare_exchange('), (358, '            &self.lock,'), (359, '            UPGRADED,'), (360, '            WRITER,'), (361, '            Ordering::Acquire,'), (362, '            Ordering::Relaxed,'), (363, '            strong,'), (364, '        )'), (365, '        .is_ok()'), (366, '        {'), (368, '            let out = Ok(RwLockWriteGuard {'), (369, '                lock: &self.lock,'), (370, '                data: self.data,'), (371, '                _invariant: PhantomData,'), (372, '            });'), (375, '            mem::forget(self);'), (377, '            out'), (378, '        } else {'), (379, '            Err(self)'), (380, '        }'), (381, '    }'), (392, \"    pub fn upgrade(mut self) -> RwLockWriteGuard<'rwlock, T> {\"), (394, '            self = match self.try_upgrade_internal(false) {'), (395, '                Ok(guard) => return guard,'), (396, '                Err(e) => e,'), (397, '            };'), (416, '        self.try_upgrade_internal(true)'), (530, '#[inline(always)]'), (531, 'fn compare_exchange('), (532, '    atomic: &AtomicUsize,'), (533, '    current: usize,'), (534, '    new: usize,'), (535, '    success: Ordering,'), (536, '    failure: Ordering,'), (537, '    strong: bool,'), (538, ') -> Result<usize, usize> {'), (539, '    if strong {'), (540, '        atomic.compare_exchange(current, new, success, failure)'), (541, '    } else {'), (542, '        atomic.compare_exchange_weak(current, new, success, failure)'), (543, '    }'), (544, '}')], 'deleted': [(7, 'use core::marker::PhantomData;'), (257, '            if self'), (258, '                .lock'), (259, '                .compare_exchange_weak(0, WRITER, Ordering::Acquire, Ordering::Relaxed)'), (260, '                .is_ok()'), (261, '            {'), (262, '                return RwLockWriteGuard {'), (263, '                    lock: &self.lock,'), (264, '                    data: unsafe { NonNull::new_unchecked(self.data.get()) },'), (265, '                    _invariant: PhantomData,'), (266, '                };'), (267, '            } else {'), (268, '                cpu_relax();'), (294, '        if self'), (295, '            .lock'), (296, '            .compare_exchange(0, WRITER, Ordering::Acquire, Ordering::Relaxed)'), (297, '            .is_ok()'), (298, '        {'), (299, '            Some(RwLockWriteGuard {'), (300, '                lock: &self.lock,'), (301, '                data: unsafe { NonNull::new_unchecked(self.data.get()) },'), (302, '                _invariant: PhantomData,'), (303, '            })'), (304, '        } else {'), (305, '            None'), (306, '        }'), (365, \"    pub fn upgrade(self) -> RwLockWriteGuard<'rwlock, T> {\"), (369, '            if self'), (370, '                .lock'), (371, '                .compare_exchange_weak(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed)'), (372, '                .is_ok()'), (373, '            {'), (375, '                let out = RwLockWriteGuard {'), (376, '                    lock: self.lock,'), (377, '                    data: self.data,'), (378, '                    _invariant: PhantomData,'), (379, '                };'), (382, '                mem::forget(self);'), (384, '                return out;'), (385, '            }'), (404, '        if self'), (405, '            .lock'), (406, '            .compare_exchange(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed)'), (407, '            .is_ok()'), (408, '        {'), (410, '            let out = Ok(RwLockWriteGuard {'), (411, '                lock: &self.lock,'), (412, '                data: self.data,'), (413, '                _invariant: PhantomData,'), (414, '            });'), (417, '            mem::forget(self);'), (419, '            out'), (420, '        } else {'), (421, '            Err(self)'), (422, '        }')]}",
    "num_lines_added": "70",
    "num_lines_deleted": "55",
    "nloc": "513"
  },
  {
    "file_change_id": "259502251510466",
    "hash": "4bda3d9e3837e90008de3a26fb0d8182fc5227e",
    "old_path": "src/rw_lock.rs",
    "new_path": "src/rw_lock.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -302,7 +302,7 @@ impl<T: ?Sized> RwLock<T> {\n     /// ```\n     #[inline]\n     pub fn try_write(&self) -> Option<RwLockWriteGuard<T>> {\n-        self.try_write_internal(false)\n+        self.try_write_internal(true)\n     }\n \n     /// Obtain a readable lock guard that can later be upgraded to a writable lock guard.\n",
    "diff_parsed": "{'added': [(305, '        self.try_write_internal(true)')], 'deleted': [(305, '        self.try_write_internal(false)')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "513"
  },
  {
    "file_change_id": "275842685932283",
    "hash": "f1320f02cb404ec6e8ad5ef638260dcacc9c8b9",
    "old_path": "matrix/src/lib.rs",
    "new_path": "matrix/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -8,7 +8,10 @@ extern crate basic_dsp_vector;\n \n use basic_dsp_vector::numbers::*;\n use basic_dsp_vector::*;\n-use std::{mem, ptr};\n+use std::{\n+    mem::ManuallyDrop,\n+    ptr\n+};\n \n mod mat_impl;\n pub use self::mat_impl::*;\n@@ -230,13 +233,12 @@ impl<S, D> TransformContent<S, D> for [S; 2] {\n     where\n         F: FnMut(S) -> D,\n     {\n+        let self_forget = ManuallyDrop::new(self);\n         unsafe {\n-            let result = [\n-                conversion(ptr::read(&self[0])),\n-                conversion(ptr::read(&self[1])),\n-            ];\n-            mem::forget(self);\n-            result\n+            [\n+                conversion(ptr::read(&self_forget[0])),\n+                conversion(ptr::read(&self_forget[1])),\n+            ]\n         }\n     }\n \n@@ -244,11 +246,11 @@ impl<S, D> TransformContent<S, D> for [S; 2] {\n     where\n         F: FnMut(S) -> TransRes<D>,\n     {\n+        let self_forget = ManuallyDrop::new(self);\n         unsafe {\n             let mut error = None;\n-            let first = try_conv!(conversion(ptr::read(&self[0])), error);\n-            let second = try_conv!(conversion(ptr::read(&self[1])), error);\n-            mem::forget(self);\n+            let first = try_conv!(conversion(ptr::read(&self_forget[0])), error);\n+            let second = try_conv!(conversion(ptr::read(&self_forget[1])), error);\n \n             match error {\n                 None => Ok([first, second]),\n@@ -265,14 +267,14 @@ impl<S, D> TransformContent<S, D> for [S; 3] {\n     where\n         F: FnMut(S) -> D,\n     {\n+        let self_forget = ManuallyDrop::new(self);\n+        \n         unsafe {\n-            let result = [\n-                conversion(ptr::read(&self[0])),\n-                conversion(ptr::read(&self[1])),\n-                conversion(ptr::read(&self[2])),\n-            ];\n-            mem::forget(self);\n-            result\n+            [\n+                conversion(ptr::read(&self_forget[0])),\n+                conversion(ptr::read(&self_forget[1])),\n+                conversion(ptr::read(&self_forget[2])),\n+            ]\n         }\n     }\n \n@@ -280,12 +282,13 @@ impl<S, D> TransformContent<S, D> for [S; 3] {\n     where\n         F: FnMut(S) -> TransRes<D>,\n     {\n+        let self_forget = ManuallyDrop::new(self);\n+\n         unsafe {\n             let mut error = None;\n-            let first = try_conv!(conversion(ptr::read(&self[0])), error);\n-            let second = try_conv!(conversion(ptr::read(&self[1])), error);\n-            let third = try_conv!(conversion(ptr::read(&self[2])), error);\n-            mem::forget(self);\n+            let first = try_conv!(conversion(ptr::read(&self_forget[0])), error);\n+            let second = try_conv!(conversion(ptr::read(&self_forget[1])), error);\n+            let third = try_conv!(conversion(ptr::read(&self_forget[2])), error);\n \n             match error {\n                 None => Ok([first, second, third]),\n@@ -302,15 +305,15 @@ impl<S, D> TransformContent<S, D> for [S; 4] {\n     where\n         F: FnMut(S) -> D,\n     {\n+        let self_forget = ManuallyDrop::new(self);\n+\n         unsafe {\n-            let result = [\n-                conversion(ptr::read(&self[0])),\n-                conversion(ptr::read(&self[1])),\n-                conversion(ptr::read(&self[2])),\n-                conversion(ptr::read(&self[3])),\n-            ];\n-            mem::forget(self);\n-            result\n+            [\n+                conversion(ptr::read(&self_forget[0])),\n+                conversion(ptr::read(&self_forget[1])),\n+                conversion(ptr::read(&self_forget[2])),\n+                conversion(ptr::read(&self_forget[3])),\n+            ]\n         }\n     }\n \n@@ -318,13 +321,14 @@ impl<S, D> TransformContent<S, D> for [S; 4] {\n     where\n         F: FnMut(S) -> TransRes<D>,\n     {\n+        let self_forget = ManuallyDrop::new(self);\n+\n         unsafe {\n             let mut error = None;\n-            let first = try_conv!(conversion(ptr::read(&self[0])), error);\n-            let second = try_conv!(conversion(ptr::read(&self[1])), error);\n-            let third = try_conv!(conversion(ptr::read(&self[2])), error);\n-            let fourth = try_conv!(conversion(ptr::read(&self[3])), error);\n-            mem::forget(self);\n+            let first = try_conv!(conversion(ptr::read(&self_forget[0])), error);\n+            let second = try_conv!(conversion(ptr::read(&self_forget[1])), error);\n+            let third = try_conv!(conversion(ptr::read(&self_forget[2])), error);\n+            let fourth = try_conv!(conversion(ptr::read(&self_forget[3])), error);\n \n             match error {\n                 None => Ok([first, second, third, fourth]),\n",
    "diff_parsed": "{'added': [(11, 'use std::{'), (12, '    mem::ManuallyDrop,'), (13, '    ptr'), (14, '};'), (236, '        let self_forget = ManuallyDrop::new(self);'), (238, '            ['), (239, '                conversion(ptr::read(&self_forget[0])),'), (240, '                conversion(ptr::read(&self_forget[1])),'), (241, '            ]'), (249, '        let self_forget = ManuallyDrop::new(self);'), (252, '            let first = try_conv!(conversion(ptr::read(&self_forget[0])), error);'), (253, '            let second = try_conv!(conversion(ptr::read(&self_forget[1])), error);'), (270, '        let self_forget = ManuallyDrop::new(self);'), (273, '            ['), (274, '                conversion(ptr::read(&self_forget[0])),'), (275, '                conversion(ptr::read(&self_forget[1])),'), (276, '                conversion(ptr::read(&self_forget[2])),'), (277, '            ]'), (285, '        let self_forget = ManuallyDrop::new(self);'), (289, '            let first = try_conv!(conversion(ptr::read(&self_forget[0])), error);'), (290, '            let second = try_conv!(conversion(ptr::read(&self_forget[1])), error);'), (291, '            let third = try_conv!(conversion(ptr::read(&self_forget[2])), error);'), (308, '        let self_forget = ManuallyDrop::new(self);'), (311, '            ['), (312, '                conversion(ptr::read(&self_forget[0])),'), (313, '                conversion(ptr::read(&self_forget[1])),'), (314, '                conversion(ptr::read(&self_forget[2])),'), (315, '                conversion(ptr::read(&self_forget[3])),'), (316, '            ]'), (324, '        let self_forget = ManuallyDrop::new(self);'), (328, '            let first = try_conv!(conversion(ptr::read(&self_forget[0])), error);'), (329, '            let second = try_conv!(conversion(ptr::read(&self_forget[1])), error);'), (330, '            let third = try_conv!(conversion(ptr::read(&self_forget[2])), error);'), (331, '            let fourth = try_conv!(conversion(ptr::read(&self_forget[3])), error);')], 'deleted': [(11, 'use std::{mem, ptr};'), (234, '            let result = ['), (235, '                conversion(ptr::read(&self[0])),'), (236, '                conversion(ptr::read(&self[1])),'), (237, '            ];'), (238, '            mem::forget(self);'), (239, '            result'), (249, '            let first = try_conv!(conversion(ptr::read(&self[0])), error);'), (250, '            let second = try_conv!(conversion(ptr::read(&self[1])), error);'), (251, '            mem::forget(self);'), (269, '            let result = ['), (270, '                conversion(ptr::read(&self[0])),'), (271, '                conversion(ptr::read(&self[1])),'), (272, '                conversion(ptr::read(&self[2])),'), (273, '            ];'), (274, '            mem::forget(self);'), (275, '            result'), (285, '            let first = try_conv!(conversion(ptr::read(&self[0])), error);'), (286, '            let second = try_conv!(conversion(ptr::read(&self[1])), error);'), (287, '            let third = try_conv!(conversion(ptr::read(&self[2])), error);'), (288, '            mem::forget(self);'), (306, '            let result = ['), (307, '                conversion(ptr::read(&self[0])),'), (308, '                conversion(ptr::read(&self[1])),'), (309, '                conversion(ptr::read(&self[2])),'), (310, '                conversion(ptr::read(&self[3])),'), (311, '            ];'), (312, '            mem::forget(self);'), (313, '            result'), (323, '            let first = try_conv!(conversion(ptr::read(&self[0])), error);'), (324, '            let second = try_conv!(conversion(ptr::read(&self[1])), error);'), (325, '            let third = try_conv!(conversion(ptr::read(&self[2])), error);'), (326, '            let fourth = try_conv!(conversion(ptr::read(&self[3])), error);'), (327, '            mem::forget(self);')]}",
    "num_lines_added": "34",
    "num_lines_deleted": "34",
    "nloc": "278"
  },
  {
    "file_change_id": "33096066959590",
    "hash": "4496dd9c1cf543536c024c6d47f0b62613c75f5",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -33,125 +33,49 @@\n #![warn(missing_docs, missing_debug_implementations, rust_2018_idioms)]\n \n use std::io;\n-use std::mem::{self, MaybeUninit};\n use std::net::{SocketAddr, TcpStream};\n-use std::ptr;\n \n-#[cfg(unix)]\n-use {\n-    libc::{sockaddr, sockaddr_storage, socklen_t},\n-    std::os::unix::net::UnixStream,\n-    std::os::unix::prelude::{FromRawFd, RawFd},\n-    std::path::Path,\n-};\n-\n-#[cfg(windows)]\n-use {\n-    std::os::windows::io::FromRawSocket,\n-    winapi::shared::ws2def::{SOCKADDR as sockaddr, SOCKADDR_STORAGE as sockaddr_storage},\n-    winapi::um::ws2tcpip::socklen_t,\n-};\n-\n-/// A raw socket address.\n-struct Addr {\n-    storage: sockaddr_storage,\n-    len: socklen_t,\n-}\n-\n-impl Addr {\n-    /// Creates a raw socket address from `SocketAddr`.\n-    fn new(addr: SocketAddr) -> Self {\n-        let (addr, len): (*const sockaddr, socklen_t) = match &addr {\n-            SocketAddr::V4(addr) => (addr as *const _ as *const _, mem::size_of_val(addr) as _),\n-            SocketAddr::V6(addr) => (addr as *const _ as *const _, mem::size_of_val(addr) as _),\n-        };\n-        unsafe { Self::from_raw_parts(addr, len) }\n-    }\n-\n-    /// Creates an `Addr` from its raw parts.\n-    unsafe fn from_raw_parts(addr: *const sockaddr, len: socklen_t) -> Self {\n-        let mut storage = MaybeUninit::<sockaddr_storage>::uninit();\n-        ptr::copy_nonoverlapping(\n-            addr as *const _ as *const u8,\n-            &mut storage as *mut _ as *mut u8,\n-            len as usize,\n-        );\n-        Self {\n-            storage: storage.assume_init(),\n-            len,\n-        }\n-    }\n-}\n+use socket2::{Domain, Protocol, SockAddr, Socket, Type};\n \n #[cfg(unix)]\n-fn connect(addr: Addr, family: libc::c_int, protocol: libc::c_int) -> io::Result<RawFd> {\n-    /// Calls a libc function and results in `io::Result`.\n-    macro_rules! syscall {\n-        ($fn:ident $args:tt) => {{\n-            let res = unsafe { libc::$fn $args };\n-            if res == -1 {\n-                Err(std::io::Error::last_os_error())\n-            } else {\n-                Ok(res)\n-            }\n-        }};\n-    }\n-\n-    // A guard that closes the file descriptor if an error occurs before the end.\n-    let mut guard;\n-\n-    // On linux, we pass the `SOCK_CLOEXEC` flag to atomically create the socket and set it as\n-    // CLOEXEC.\n-    #[cfg(target_os = \"linux\")]\n-    let fd = {\n-        let fd = syscall!(socket(\n-            family,\n-            libc::SOCK_STREAM | libc::SOCK_CLOEXEC,\n-            protocol,\n-        ))?;\n-        guard = CallOnDrop(Some(move || drop(syscall!(close(fd)))));\n-        fd\n-    };\n-\n-    // On other systems, we first create the socket and then set it as CLOEXEC.\n-    #[cfg(not(target_os = \"linux\"))]\n-    let fd = {\n-        let fd = syscall!(socket(family, libc::SOCK_STREAM, protocol))?;\n-        guard = CallOnDrop(Some(move || drop(syscall!(close(fd)))));\n-\n-        let flags = syscall!(fcntl(fd, libc::F_GETFD))? | libc::FD_CLOEXEC;\n-        syscall!(fcntl(fd, libc::F_SETFD, flags))?;\n-\n-        #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-        {\n-            let payload = &1i32 as *const i32 as *const libc::c_void;\n-            syscall!(setsockopt(\n-                fd,\n-                libc::SOL_SOCKET,\n-                libc::SO_NOSIGPIPE,\n-                payload,\n-                std::mem::size_of::<i32>() as libc::socklen_t,\n-            ))?;\n-        }\n-        fd\n-    };\n-\n-    // Put socket into non-blocking mode.\n-    let flags = syscall!(fcntl(fd, libc::F_GETFL))? | libc::O_NONBLOCK;\n-    syscall!(fcntl(fd, libc::F_SETFL, flags))?;\n-\n-    // Start connecting.\n-    match syscall!(connect(fd, &addr.storage as *const _ as *const _, addr.len)) {\n+use std::{os::unix::net::UnixStream, path::Path};\n+\n+fn connect(addr: SockAddr, domain: Domain, protocol: Option<Protocol>) -> io::Result<Socket> {\n+    let sock_type = Type::STREAM;\n+    #[cfg(any(\n+        target_os = \"android\",\n+        target_os = \"dragonfly\",\n+        target_os = \"freebsd\",\n+        target_os = \"fuchsia\",\n+        target_os = \"illumos\",\n+        target_os = \"linux\",\n+        target_os = \"netbsd\",\n+        target_os = \"openbsd\"\n+    ))]\n+    // If we can, set nonblocking at socket creation for unix\n+    let sock_type = sock_type.nonblocking();\n+    // This automatically handles cloexec on unix, no_inherit on windows and nosigpipe on macos\n+    let socket = Socket::new(domain, sock_type, protocol)?;\n+    #[cfg(not(any(\n+        target_os = \"android\",\n+        target_os = \"dragonfly\",\n+        target_os = \"freebsd\",\n+        target_os = \"fuchsia\",\n+        target_os = \"illumos\",\n+        target_os = \"linux\",\n+        target_os = \"netbsd\",\n+        target_os = \"openbsd\"\n+    )))]\n+    // If the current platform doesn't support nonblocking at creation, enable it after creation\n+    socket.set_nonblocking(true)?;\n+    match socket.connect(&addr) {\n         Ok(_) => {}\n+        #[cfg(unix)]\n         Err(err) if err.raw_os_error() == Some(libc::EINPROGRESS) => {}\n         Err(err) if err.kind() == io::ErrorKind::WouldBlock => {}\n         Err(err) => return Err(err),\n     }\n-\n-    // Disarm the guard so that it doesn't close the file descriptor.\n-    guard.0.take();\n-\n-    Ok(fd)\n+    Ok(socket)\n }\n \n /// Creates a pending Unix connection to the specified path.\n@@ -184,52 +108,8 @@ fn connect(addr: Addr, family: libc::c_int, protocol: libc::c_int) -> io::Result\n /// ```\n #[cfg(unix)]\n pub fn unix<P: AsRef<Path>>(path: P) -> io::Result<UnixStream> {\n-    use std::cmp::Ordering;\n-    use std::os::unix::ffi::OsStrExt;\n-\n-    let addr = unsafe {\n-        let mut addr = mem::zeroed::<libc::sockaddr_un>();\n-        addr.sun_family = libc::AF_UNIX as libc::sa_family_t;\n-\n-        let bytes = path.as_ref().as_os_str().as_bytes();\n-\n-        match (bytes.get(0), bytes.len().cmp(&addr.sun_path.len())) {\n-            // Abstract paths don't need a null terminator\n-            (Some(&0), Ordering::Greater) => {\n-                return Err(io::Error::new(\n-                    io::ErrorKind::InvalidInput,\n-                    \"path must be no longer than SUN_LEN\",\n-                ));\n-            }\n-            (Some(&0), _) => {}\n-            (_, Ordering::Greater) | (_, Ordering::Equal) => {\n-                return Err(io::Error::new(\n-                    io::ErrorKind::InvalidInput,\n-                    \"path must be shorter than SUN_LEN\",\n-                ));\n-            }\n-            _ => {}\n-        }\n-\n-        for (dst, src) in addr.sun_path.iter_mut().zip(bytes) {\n-            *dst = *src as libc::c_char;\n-        }\n-        // null byte for pathname is already there since we zeroed up front\n-\n-        let base = &addr as *const _ as usize;\n-        let path = &addr.sun_path as *const _ as usize;\n-        let sun_path_offset = path - base;\n-\n-        let mut len = sun_path_offset + bytes.len();\n-        match bytes.get(0) {\n-            Some(&0) | None => {}\n-            Some(_) => len += 1,\n-        }\n-        Addr::from_raw_parts(&addr as *const _ as *const _, len as libc::socklen_t)\n-    };\n-\n-    let fd = connect(addr, libc::AF_UNIX, 0)?;\n-    unsafe { Ok(UnixStream::from_raw_fd(fd)) }\n+    let socket = connect(SockAddr::unix(path)?, Domain::UNIX, None)?;\n+    Ok(socket.into())\n }\n \n /// Creates a pending TCP connection to the specified address.\n@@ -263,99 +143,8 @@ pub fn unix<P: AsRef<Path>>(path: P) -> io::Result<UnixStream> {\n /// # std::io::Result::Ok(())\n /// ```\n pub fn tcp<A: Into<SocketAddr>>(addr: A) -> io::Result<TcpStream> {\n-    tcp_connect(addr.into())\n-}\n-\n-#[cfg(unix)]\n-fn tcp_connect(addr: SocketAddr) -> io::Result<TcpStream> {\n     let addr = addr.into();\n-    let fd = connect(\n-        Addr::new(addr),\n-        if addr.is_ipv6() {\n-            libc::AF_INET6\n-        } else {\n-            libc::AF_INET\n-        },\n-        libc::IPPROTO_TCP,\n-    )?;\n-    unsafe { Ok(TcpStream::from_raw_fd(fd)) }\n-}\n-\n-#[cfg(windows)]\n-fn tcp_connect(addr: SocketAddr) -> io::Result<TcpStream> {\n-    use std::net::UdpSocket;\n-    use std::sync::Once;\n-\n-    use winapi::ctypes::{c_int, c_ulong};\n-    use winapi::shared::minwindef::DWORD;\n-    use winapi::shared::ntdef::HANDLE;\n-    use winapi::shared::ws2def::{AF_INET, AF_INET6, IPPROTO_TCP, SOCK_STREAM};\n-    use winapi::um::handleapi::SetHandleInformation;\n-    use winapi::um::winsock2 as sock;\n-\n-    static INIT: Once = Once::new();\n-    INIT.call_once(|| {\n-        // Initialize winsock through the standard library by just creating a dummy socket.\n-        // Whether this is successful or not we drop the result as libstd will be sure to have\n-        // initialized winsock.\n-        let _ = UdpSocket::bind(\"127.0.0.1:34254\");\n-    });\n-\n-    const HANDLE_FLAG_INHERIT: DWORD = 0x00000001;\n-    const WSA_FLAG_OVERLAPPED: DWORD = 0x01;\n-\n-    let family = if addr.is_ipv6() { AF_INET6 } else { AF_INET };\n-    let addr = Addr::new(addr);\n-\n-    unsafe {\n-        let socket = match sock::WSASocketW(\n-            family,\n-            SOCK_STREAM,\n-            IPPROTO_TCP as _,\n-            ptr::null_mut(),\n-            0,\n-            WSA_FLAG_OVERLAPPED,\n-        ) {\n-            sock::INVALID_SOCKET => {\n-                return Err(io::Error::from_raw_os_error(sock::WSAGetLastError()))\n-            }\n-            socket => socket,\n-        };\n-\n-        // Create a TCP stream now so that it closes the socket if an error occurs before the end.\n-        let stream = TcpStream::from_raw_socket(socket as _);\n-\n-        // Set no inherit.\n-        if SetHandleInformation(socket as HANDLE, HANDLE_FLAG_INHERIT, 0) == 0 {\n-            return Err(io::Error::last_os_error());\n-        }\n-\n-        // Put socket into nonblocking mode.\n-        let mut nonblocking = true as c_ulong;\n-        if sock::ioctlsocket(socket, sock::FIONBIO as c_int, &mut nonblocking) != 0 {\n-            return Err(io::Error::last_os_error());\n-        }\n-\n-        // Start connecting.\n-        match sock::connect(socket, &addr.storage as *const _ as *const _, addr.len) {\n-            0 => {}\n-            _ => match io::Error::from_raw_os_error(sock::WSAGetLastError()) {\n-                err if err.kind() == io::ErrorKind::WouldBlock => {}\n-                err => return Err(err),\n-            },\n-        }\n-\n-        Ok(stream)\n-    }\n-}\n-\n-/// Runs a closure when dropped.\n-struct CallOnDrop<F: FnOnce()>(Option<F>);\n-\n-impl<F: FnOnce()> Drop for CallOnDrop<F> {\n-    fn drop(&mut self) {\n-        if let Some(f) = self.0.take() {\n-            f();\n-        }\n-    }\n+    let domain = Domain::for_address(addr);\n+    let socket = connect(addr.into(), domain, Some(Protocol::TCP))?;\n+    Ok(socket.into())\n }\n",
    "diff_parsed": "{'added': [(38, 'use socket2::{Domain, Protocol, SockAddr, Socket, Type};'), (41, 'use std::{os::unix::net::UnixStream, path::Path};'), (43, 'fn connect(addr: SockAddr, domain: Domain, protocol: Option<Protocol>) -> io::Result<Socket> {'), (44, '    let sock_type = Type::STREAM;'), (45, '    #[cfg(any('), (46, '        target_os = \"android\",'), (47, '        target_os = \"dragonfly\",'), (48, '        target_os = \"freebsd\",'), (49, '        target_os = \"fuchsia\",'), (50, '        target_os = \"illumos\",'), (51, '        target_os = \"linux\",'), (52, '        target_os = \"netbsd\",'), (53, '        target_os = \"openbsd\"'), (54, '    ))]'), (56, '    let sock_type = sock_type.nonblocking();'), (58, '    let socket = Socket::new(domain, sock_type, protocol)?;'), (59, '    #[cfg(not(any('), (60, '        target_os = \"android\",'), (61, '        target_os = \"dragonfly\",'), (62, '        target_os = \"freebsd\",'), (63, '        target_os = \"fuchsia\",'), (64, '        target_os = \"illumos\",'), (65, '        target_os = \"linux\",'), (66, '        target_os = \"netbsd\",'), (67, '        target_os = \"openbsd\"'), (68, '    )))]'), (70, '    socket.set_nonblocking(true)?;'), (71, '    match socket.connect(&addr) {'), (73, '        #[cfg(unix)]'), (78, '    Ok(socket)'), (111, '    let socket = connect(SockAddr::unix(path)?, Domain::UNIX, None)?;'), (112, '    Ok(socket.into())'), (147, '    let domain = Domain::for_address(addr);'), (148, '    let socket = connect(addr.into(), domain, Some(Protocol::TCP))?;'), (149, '    Ok(socket.into())')], 'deleted': [(36, 'use std::mem::{self, MaybeUninit};'), (38, 'use std::ptr;'), (40, '#[cfg(unix)]'), (41, 'use {'), (42, '    libc::{sockaddr, sockaddr_storage, socklen_t},'), (43, '    std::os::unix::net::UnixStream,'), (44, '    std::os::unix::prelude::{FromRawFd, RawFd},'), (45, '    std::path::Path,'), (46, '};'), (48, '#[cfg(windows)]'), (49, 'use {'), (50, '    std::os::windows::io::FromRawSocket,'), (51, '    winapi::shared::ws2def::{SOCKADDR as sockaddr, SOCKADDR_STORAGE as sockaddr_storage},'), (52, '    winapi::um::ws2tcpip::socklen_t,'), (53, '};'), (56, 'struct Addr {'), (57, '    storage: sockaddr_storage,'), (58, '    len: socklen_t,'), (59, '}'), (61, 'impl Addr {'), (63, '    fn new(addr: SocketAddr) -> Self {'), (64, '        let (addr, len): (*const sockaddr, socklen_t) = match &addr {'), (65, '            SocketAddr::V4(addr) => (addr as *const _ as *const _, mem::size_of_val(addr) as _),'), (66, '            SocketAddr::V6(addr) => (addr as *const _ as *const _, mem::size_of_val(addr) as _),'), (67, '        };'), (68, '        unsafe { Self::from_raw_parts(addr, len) }'), (69, '    }'), (72, '    unsafe fn from_raw_parts(addr: *const sockaddr, len: socklen_t) -> Self {'), (73, '        let mut storage = MaybeUninit::<sockaddr_storage>::uninit();'), (74, '        ptr::copy_nonoverlapping('), (75, '            addr as *const _ as *const u8,'), (76, '            &mut storage as *mut _ as *mut u8,'), (77, '            len as usize,'), (78, '        );'), (79, '        Self {'), (80, '            storage: storage.assume_init(),'), (81, '            len,'), (82, '        }'), (83, '    }'), (84, '}'), (87, 'fn connect(addr: Addr, family: libc::c_int, protocol: libc::c_int) -> io::Result<RawFd> {'), (89, '    macro_rules! syscall {'), (90, '        ($fn:ident $args:tt) => {{'), (91, '            let res = unsafe { libc::$fn $args };'), (92, '            if res == -1 {'), (93, '                Err(std::io::Error::last_os_error())'), (94, '            } else {'), (95, '                Ok(res)'), (96, '            }'), (97, '        }};'), (98, '    }'), (101, '    let mut guard;'), (105, '    #[cfg(target_os = \"linux\")]'), (106, '    let fd = {'), (107, '        let fd = syscall!(socket('), (108, '            family,'), (109, '            libc::SOCK_STREAM | libc::SOCK_CLOEXEC,'), (110, '            protocol,'), (111, '        ))?;'), (112, '        guard = CallOnDrop(Some(move || drop(syscall!(close(fd)))));'), (113, '        fd'), (114, '    };'), (117, '    #[cfg(not(target_os = \"linux\"))]'), (118, '    let fd = {'), (119, '        let fd = syscall!(socket(family, libc::SOCK_STREAM, protocol))?;'), (120, '        guard = CallOnDrop(Some(move || drop(syscall!(close(fd)))));'), (122, '        let flags = syscall!(fcntl(fd, libc::F_GETFD))? | libc::FD_CLOEXEC;'), (123, '        syscall!(fcntl(fd, libc::F_SETFD, flags))?;'), (125, '        #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]'), (126, '        {'), (127, '            let payload = &1i32 as *const i32 as *const libc::c_void;'), (128, '            syscall!(setsockopt('), (129, '                fd,'), (130, '                libc::SOL_SOCKET,'), (131, '                libc::SO_NOSIGPIPE,'), (132, '                payload,'), (133, '                std::mem::size_of::<i32>() as libc::socklen_t,'), (134, '            ))?;'), (135, '        }'), (136, '        fd'), (137, '    };'), (140, '    let flags = syscall!(fcntl(fd, libc::F_GETFL))? | libc::O_NONBLOCK;'), (141, '    syscall!(fcntl(fd, libc::F_SETFL, flags))?;'), (144, '    match syscall!(connect(fd, &addr.storage as *const _ as *const _, addr.len)) {'), (152, '    guard.0.take();'), (154, '    Ok(fd)'), (187, '    use std::cmp::Ordering;'), (188, '    use std::os::unix::ffi::OsStrExt;'), (190, '    let addr = unsafe {'), (191, '        let mut addr = mem::zeroed::<libc::sockaddr_un>();'), (192, '        addr.sun_family = libc::AF_UNIX as libc::sa_family_t;'), (194, '        let bytes = path.as_ref().as_os_str().as_bytes();'), (196, '        match (bytes.get(0), bytes.len().cmp(&addr.sun_path.len())) {'), (198, '            (Some(&0), Ordering::Greater) => {'), (199, '                return Err(io::Error::new('), (200, '                    io::ErrorKind::InvalidInput,'), (201, '                    \"path must be no longer than SUN_LEN\",'), (202, '                ));'), (203, '            }'), (204, '            (Some(&0), _) => {}'), (205, '            (_, Ordering::Greater) | (_, Ordering::Equal) => {'), (206, '                return Err(io::Error::new('), (207, '                    io::ErrorKind::InvalidInput,'), (208, '                    \"path must be shorter than SUN_LEN\",'), (209, '                ));'), (210, '            }'), (211, '            _ => {}'), (212, '        }'), (214, '        for (dst, src) in addr.sun_path.iter_mut().zip(bytes) {'), (215, '            *dst = *src as libc::c_char;'), (216, '        }'), (219, '        let base = &addr as *const _ as usize;'), (220, '        let path = &addr.sun_path as *const _ as usize;'), (221, '        let sun_path_offset = path - base;'), (223, '        let mut len = sun_path_offset + bytes.len();'), (224, '        match bytes.get(0) {'), (225, '            Some(&0) | None => {}'), (226, '            Some(_) => len += 1,'), (227, '        }'), (228, '        Addr::from_raw_parts(&addr as *const _ as *const _, len as libc::socklen_t)'), (229, '    };'), (231, '    let fd = connect(addr, libc::AF_UNIX, 0)?;'), (232, '    unsafe { Ok(UnixStream::from_raw_fd(fd)) }'), (266, '    tcp_connect(addr.into())'), (267, '}'), (269, '#[cfg(unix)]'), (270, 'fn tcp_connect(addr: SocketAddr) -> io::Result<TcpStream> {'), (272, '    let fd = connect('), (273, '        Addr::new(addr),'), (274, '        if addr.is_ipv6() {'), (275, '            libc::AF_INET6'), (276, '        } else {'), (277, '            libc::AF_INET'), (278, '        },'), (279, '        libc::IPPROTO_TCP,'), (280, '    )?;'), (281, '    unsafe { Ok(TcpStream::from_raw_fd(fd)) }'), (282, '}'), (284, '#[cfg(windows)]'), (285, 'fn tcp_connect(addr: SocketAddr) -> io::Result<TcpStream> {'), (286, '    use std::net::UdpSocket;'), (287, '    use std::sync::Once;'), (289, '    use winapi::ctypes::{c_int, c_ulong};'), (290, '    use winapi::shared::minwindef::DWORD;'), (291, '    use winapi::shared::ntdef::HANDLE;'), (292, '    use winapi::shared::ws2def::{AF_INET, AF_INET6, IPPROTO_TCP, SOCK_STREAM};'), (293, '    use winapi::um::handleapi::SetHandleInformation;'), (294, '    use winapi::um::winsock2 as sock;'), (296, '    static INIT: Once = Once::new();'), (297, '    INIT.call_once(|| {'), (301, '        let _ = UdpSocket::bind(\"127.0.0.1:34254\");'), (302, '    });'), (304, '    const HANDLE_FLAG_INHERIT: DWORD = 0x00000001;'), (305, '    const WSA_FLAG_OVERLAPPED: DWORD = 0x01;'), (307, '    let family = if addr.is_ipv6() { AF_INET6 } else { AF_INET };'), (308, '    let addr = Addr::new(addr);'), (310, '    unsafe {'), (311, '        let socket = match sock::WSASocketW('), (312, '            family,'), (313, '            SOCK_STREAM,'), (314, '            IPPROTO_TCP as _,'), (315, '            ptr::null_mut(),'), (316, '            0,'), (317, '            WSA_FLAG_OVERLAPPED,'), (318, '        ) {'), (319, '            sock::INVALID_SOCKET => {'), (320, '                return Err(io::Error::from_raw_os_error(sock::WSAGetLastError()))'), (321, '            }'), (322, '            socket => socket,'), (323, '        };'), (326, '        let stream = TcpStream::from_raw_socket(socket as _);'), (329, '        if SetHandleInformation(socket as HANDLE, HANDLE_FLAG_INHERIT, 0) == 0 {'), (330, '            return Err(io::Error::last_os_error());'), (331, '        }'), (334, '        let mut nonblocking = true as c_ulong;'), (335, '        if sock::ioctlsocket(socket, sock::FIONBIO as c_int, &mut nonblocking) != 0 {'), (336, '            return Err(io::Error::last_os_error());'), (337, '        }'), (340, '        match sock::connect(socket, &addr.storage as *const _ as *const _, addr.len) {'), (341, '            0 => {}'), (342, '            _ => match io::Error::from_raw_os_error(sock::WSAGetLastError()) {'), (343, '                err if err.kind() == io::ErrorKind::WouldBlock => {}'), (344, '                err => return Err(err),'), (345, '            },'), (346, '        }'), (348, '        Ok(stream)'), (349, '    }'), (350, '}'), (353, 'struct CallOnDrop<F: FnOnce()>(Option<F>);'), (355, 'impl<F: FnOnce()> Drop for CallOnDrop<F> {'), (356, '    fn drop(&mut self) {'), (357, '        if let Some(f) = self.0.take() {'), (358, '            f();'), (359, '        }'), (360, '    }')]}",
    "num_lines_added": "35",
    "num_lines_deleted": "195",
    "nloc": "51"
  },
  {
    "file_change_id": "188932671318253",
    "hash": "4ba0d0f689440963e38b8adbe7fc2cabc6e573d",
    "old_path": "lib.rs",
    "new_path": "lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -665,6 +665,8 @@ impl<A: Array> SmallVec<A> {\n                 if unspilled {\n                     return;\n                 }\n+            } else {\n+                return;\n             }\n             deallocate(ptr, cap);\n         }\n@@ -2341,4 +2343,18 @@ mod tests {\n         v.extend(it);\n         assert_eq!(v[..], ['a']);\n     }\n+\n+    #[test]\n+    fn grow_spilled_same_size() {\n+        let mut v: SmallVec<[u8; 2]> = SmallVec::new();\n+        v.push(0);\n+        v.push(1);\n+        v.push(2);\n+        assert!(v.spilled());\n+        assert_eq!(v.capacity(), 4);\n+        // grow with the same capacity\n+        v.grow(4);\n+        assert_eq!(v.capacity(), 4);\n+        assert_eq!(v[..], [0, 1, 2]);\n+    }\n }\n",
    "diff_parsed": "{'added': [(668, '            } else {'), (669, '                return;'), (2347, '    #[test]'), (2348, '    fn grow_spilled_same_size() {'), (2349, '        let mut v: SmallVec<[u8; 2]> = SmallVec::new();'), (2350, '        v.push(0);'), (2351, '        v.push(1);'), (2352, '        v.push(2);'), (2353, '        assert!(v.spilled());'), (2354, '        assert_eq!(v.capacity(), 4);'), (2356, '        v.grow(4);'), (2357, '        assert_eq!(v.capacity(), 4);'), (2358, '        assert_eq!(v[..], [0, 1, 2]);'), (2359, '    }')], 'deleted': []}",
    "num_lines_added": "14",
    "num_lines_deleted": "0",
    "nloc": "1813"
  },
  {
    "file_change_id": "150678240090393",
    "hash": "70c87a49451c4dfcb170461ad9c55fe2f104b7b",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -748,7 +748,7 @@ impl<T> SliceDeque<T> {\n             new_head += cap as isize;\n             debug_assert!(new_head >= 0);\n             self.tail_ += cap;\n-        } else if new_head as usize > cap {\n+        } else if new_head as usize >= cap {\n             // cannot panic because new_head >= 0\n             // If the new head is larger than the capacity, we shift the range\n             // by -capacity to move it towards the first mirrored\n@@ -765,6 +765,8 @@ impl<T> SliceDeque<T> {\n \n         debug_assert!(self.tail() <= self.tail_upper_bound());\n         debug_assert!(self.head() <= self.head_upper_bound());\n+\n+        debug_assert!(self.head() != self.capacity());\n     }\n \n     /// Moves the deque head by `x`.\n@@ -5890,4 +5892,21 @@ mod tests {\n             assert_eq!(v.as_ptr() as usize, mem::align_of::<Foo>());\n         }\n     }\n+\n+    #[test]\n+    fn issue_57() {\n+        const C: [i16; 3] = [42; 3];\n+\n+        let mut deque = SliceDeque::new();\n+\n+        for _ in 0..918 {\n+            deque.push_front(C);\n+        }\n+\n+        for _ in 0..237 {\n+            assert_eq!(deque.pop_front(), Some(C));\n+            assert!(!deque.is_empty());\n+            assert_eq!(*deque.back().unwrap(), C);\n+        }\n+    }\n }\n",
    "diff_parsed": "{'added': [(751, '        } else if new_head as usize >= cap {'), (769, '        debug_assert!(self.head() != self.capacity());'), (5896, '    #[test]'), (5897, '    fn issue_57() {'), (5898, '        const C: [i16; 3] = [42; 3];'), (5900, '        let mut deque = SliceDeque::new();'), (5902, '        for _ in 0..918 {'), (5903, '            deque.push_front(C);'), (5904, '        }'), (5906, '        for _ in 0..237 {'), (5907, '            assert_eq!(deque.pop_front(), Some(C));'), (5908, '            assert!(!deque.is_empty());'), (5909, '            assert_eq!(*deque.back().unwrap(), C);'), (5910, '        }'), (5911, '    }')], 'deleted': [(751, '        } else if new_head as usize > cap {')]}",
    "num_lines_added": "15",
    "num_lines_deleted": "1",
    "nloc": "4031"
  },
  {
    "file_change_id": "81780559006586",
    "hash": "11f396ca9accf6ae000db13a44505b57608733c",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -27,7 +27,7 @@ pub struct LateStatic<T> {\n }\n \n unsafe impl<T: Send> core::marker::Send for LateStatic<T> {}\n-unsafe impl<T: Send> core::marker::Sync for LateStatic<T> {}\n+unsafe impl<T: Sync> core::marker::Sync for LateStatic<T> {}\n \n impl<T> LateStatic<T> {\n     /// Construct a LateStatic.\n",
    "diff_parsed": "{'added': [(30, 'unsafe impl<T: Sync> core::marker::Sync for LateStatic<T> {}')], 'deleted': [(30, 'unsafe impl<T: Send> core::marker::Sync for LateStatic<T> {}')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "126"
  },
  {
    "file_change_id": "230337906850694",
    "hash": "26b249075930b46cfafc70b1d18fd0cb35fd231",
    "old_path": "lib.rs",
    "new_path": "lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -771,24 +771,33 @@ impl<A: Array> SmallVec<A> {\n         unsafe {\n             let old_len = self.len();\n             assert!(index <= old_len);\n-            let ptr = self.as_mut_ptr().offset(index as isize);\n+            let mut ptr = self.as_mut_ptr().offset(index as isize);\n+\n+            // Move the trailing elements.\n             ptr::copy(ptr, ptr.offset(lower_size_bound as isize), old_len - index);\n-            for (off, element) in iter.enumerate() {\n-                if off < lower_size_bound {\n-                    ptr::write(ptr.offset(off as isize), element);\n-                    let len = self.len() + 1;\n-                    self.set_len(len);\n-                } else {\n-                    // Iterator provided more elements than the hint.\n-                    assert!(index + off >= index);  // Protect against overflow.\n-                    self.insert(index + off, element);\n+\n+            // In case the iterator panics, don't double-drop the items we just copied above.\n+            self.set_len(index);\n+\n+            let mut num_added = 0;\n+            for element in iter {\n+                let mut cur = ptr.offset(num_added as isize);\n+                if num_added >= lower_size_bound {\n+                    // Iterator provided more elements than the hint.  Move trailing items again.\n+                    self.reserve(1);\n+                    ptr = self.as_mut_ptr().offset(index as isize);\n+                    cur = ptr.offset(num_added as isize);\n+                    ptr::copy(cur, cur.offset(1), old_len - index);\n                 }\n+                ptr::write(cur, element);\n+                num_added += 1;\n             }\n-            let num_added = self.len() - old_len;\n             if num_added < lower_size_bound {\n                 // Iterator provided fewer elements than the hint\n                 ptr::copy(ptr.offset(lower_size_bound as isize), ptr.offset(num_added as isize), old_len - index);\n             }\n+\n+            self.set_len(old_len + num_added);\n         }\n     }\n \n@@ -1645,6 +1654,37 @@ mod tests {\n         assert_eq!(&v.iter().map(|v| *v).collect::<Vec<_>>(), &[0, 5, 6, 1, 2, 3]);\n     }\n \n+    #[test]\n+    // https://github.com/servo/rust-smallvec/issues/96\n+    fn test_insert_many_panic() {\n+        struct PanicOnDoubleDrop {\n+            dropped: Box<bool>\n+        }\n+\n+        impl Drop for PanicOnDoubleDrop {\n+            fn drop(&mut self) {\n+                assert!(!*self.dropped, \"already dropped\");\n+                *self.dropped = true;\n+            }\n+        }\n+\n+        struct BadIter;\n+        impl Iterator for BadIter {\n+            type Item = PanicOnDoubleDrop;\n+            fn size_hint(&self) -> (usize, Option<usize>) { (1, None) }\n+            fn next(&mut self) -> Option<Self::Item> { panic!() }\n+        }\n+\n+        let mut vec: SmallVec<[PanicOnDoubleDrop; 0]> = vec![\n+            PanicOnDoubleDrop { dropped: Box::new(false) },\n+            PanicOnDoubleDrop { dropped: Box::new(false) },\n+        ].into();\n+        let result = ::std::panic::catch_unwind(move || {\n+            vec.insert_many(0, BadIter);\n+        });\n+        assert!(result.is_err());\n+    }\n+\n     #[test]\n     #[should_panic]\n     fn test_invalid_grow() {\n",
    "diff_parsed": "{'added': [(774, '            let mut ptr = self.as_mut_ptr().offset(index as isize);'), (780, '            self.set_len(index);'), (782, '            let mut num_added = 0;'), (783, '            for element in iter {'), (784, '                let mut cur = ptr.offset(num_added as isize);'), (785, '                if num_added >= lower_size_bound {'), (787, '                    self.reserve(1);'), (788, '                    ptr = self.as_mut_ptr().offset(index as isize);'), (789, '                    cur = ptr.offset(num_added as isize);'), (790, '                    ptr::copy(cur, cur.offset(1), old_len - index);'), (792, '                ptr::write(cur, element);'), (793, '                num_added += 1;'), (800, '            self.set_len(old_len + num_added);'), (1657, '    #[test]'), (1659, '    fn test_insert_many_panic() {'), (1660, '        struct PanicOnDoubleDrop {'), (1661, '            dropped: Box<bool>'), (1662, '        }'), (1664, '        impl Drop for PanicOnDoubleDrop {'), (1665, '            fn drop(&mut self) {'), (1666, '                assert!(!*self.dropped, \"already dropped\");'), (1667, '                *self.dropped = true;'), (1668, '            }'), (1669, '        }'), (1671, '        struct BadIter;'), (1672, '        impl Iterator for BadIter {'), (1673, '            type Item = PanicOnDoubleDrop;'), (1674, '            fn size_hint(&self) -> (usize, Option<usize>) { (1, None) }'), (1675, '            fn next(&mut self) -> Option<Self::Item> { panic!() }'), (1676, '        }'), (1678, '        let mut vec: SmallVec<[PanicOnDoubleDrop; 0]> = vec!['), (1679, '            PanicOnDoubleDrop { dropped: Box::new(false) },'), (1680, '            PanicOnDoubleDrop { dropped: Box::new(false) },'), (1681, '        ].into();'), (1682, '        let result = ::std::panic::catch_unwind(move || {'), (1683, '            vec.insert_many(0, BadIter);'), (1684, '        });'), (1685, '        assert!(result.is_err());'), (1686, '    }')], 'deleted': [(774, '            let ptr = self.as_mut_ptr().offset(index as isize);'), (776, '            for (off, element) in iter.enumerate() {'), (777, '                if off < lower_size_bound {'), (778, '                    ptr::write(ptr.offset(off as isize), element);'), (779, '                    let len = self.len() + 1;'), (780, '                    self.set_len(len);'), (781, '                } else {'), (783, '                    assert!(index + off >= index);  // Protect against overflow.'), (784, '                    self.insert(index + off, element);'), (787, '            let num_added = self.len() - old_len;')]}",
    "num_lines_added": "39",
    "num_lines_deleted": "10",
    "nloc": "1552"
  },
  {
    "file_change_id": "117329840245103",
    "hash": "1f4025218c4321ea42ad01d80dd6110def2d86d",
    "old_path": "lib.rs",
    "new_path": "lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -946,19 +946,17 @@ impl<A: Array> SmallVec<A> where A::Item: Clone {\n         if n > A::size() {\n             vec![elem; n].into()\n         } else {\n+            let mut v = SmallVec::<A>::new();\n             unsafe {\n-                let mut arr: A = ::std::mem::uninitialized();\n-                let ptr = arr.ptr_mut();\n+                let (ptr, len_ptr, _) = v.triple_mut();\n+                let mut local_len = SetLenOnDrop::new(len_ptr);\n \n                 for i in 0..n as isize {\n                     ::std::ptr::write(ptr.offset(i), elem.clone());\n-                }\n-\n-                SmallVec {\n-                    capacity: n,\n-                    data: SmallVecData::from_inline(arr),\n+                    local_len.increment_len(1);\n                 }\n             }\n+            v\n         }\n     }\n }\n@@ -1346,6 +1344,33 @@ pub unsafe trait Array {\n     fn ptr_mut(&mut self) -> *mut Self::Item;\n }\n \n+/// Set the length of the vec when the `SetLenOnDrop` value goes out of scope.\n+///\n+/// Copied from https://github.com/rust-lang/rust/pull/36355\n+struct SetLenOnDrop<'a> {\n+    len: &'a mut usize,\n+    local_len: usize,\n+}\n+\n+impl<'a> SetLenOnDrop<'a> {\n+    #[inline]\n+    fn new(len: &'a mut usize) -> Self {\n+        SetLenOnDrop { local_len: *len, len: len }\n+    }\n+\n+    #[inline]\n+    fn increment_len(&mut self, increment: usize) {\n+        self.local_len += increment;\n+    }\n+}\n+\n+impl<'a> Drop for SetLenOnDrop<'a> {\n+    #[inline]\n+    fn drop(&mut self) {\n+        *self.len = self.local_len;\n+    }\n+}\n+\n macro_rules! impl_array(\n     ($($size:expr),+) => {\n         $(\n",
    "diff_parsed": "{'added': [(949, '            let mut v = SmallVec::<A>::new();'), (951, '                let (ptr, len_ptr, _) = v.triple_mut();'), (952, '                let mut local_len = SetLenOnDrop::new(len_ptr);'), (956, '                    local_len.increment_len(1);'), (959, '            v'), (1350, \"struct SetLenOnDrop<'a> {\"), (1351, \"    len: &'a mut usize,\"), (1352, '    local_len: usize,'), (1353, '}'), (1355, \"impl<'a> SetLenOnDrop<'a> {\"), (1356, '    #[inline]'), (1357, \"    fn new(len: &'a mut usize) -> Self {\"), (1358, '        SetLenOnDrop { local_len: *len, len: len }'), (1359, '    }'), (1361, '    #[inline]'), (1362, '    fn increment_len(&mut self, increment: usize) {'), (1363, '        self.local_len += increment;'), (1364, '    }'), (1365, '}'), (1367, \"impl<'a> Drop for SetLenOnDrop<'a> {\"), (1368, '    #[inline]'), (1369, '    fn drop(&mut self) {'), (1370, '        *self.len = self.local_len;'), (1371, '    }'), (1372, '}')], 'deleted': [(950, '                let mut arr: A = ::std::mem::uninitialized();'), (951, '                let ptr = arr.ptr_mut();'), (955, '                }'), (957, '                SmallVec {'), (958, '                    capacity: n,'), (959, '                    data: SmallVecData::from_inline(arr),')]}",
    "num_lines_added": "25",
    "num_lines_deleted": "6",
    "nloc": "1605"
  },
  {
    "file_change_id": "232116381998380",
    "hash": "b03b1588858f0a47ab5909bfa6b4e1b395292b16",
    "old_path": "src/lcell.rs",
    "new_path": "src/lcell.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,7 +1,8 @@\n use std::cell::{Cell, UnsafeCell};\n use std::marker::PhantomData;\n+struct Invariant<Q>(fn(Q) -> Q);\n \n-type Id<'id> = PhantomData<Cell<&'id mut ()>>;\n+type Id<'id> = PhantomData<Invariant<&'id ()>>;\n \n /// Borrowing-owner of zero or more [`LCell`](struct.LCell.html)\n /// instances.\n@@ -169,7 +170,7 @@ impl<'id, T: ?Sized> LCell<'id, T> {\n     }\n }\n \n-// LCellOwner and LCell already automatically implement Send, but not\n+// LCell already automatically implements Send, but not\n // Sync. We can add these implementations though, since it's fine to\n // send a &LCell to another thread, and even mutably borrow the value\n // there, as long as T is Send and Sync.\n@@ -185,7 +186,6 @@ impl<'id, T: ?Sized> LCell<'id, T> {\n // as those of std::sync::RwLock<T>. That's not a coincidence.\n // The way these types let you access T concurrently is the same,\n // even though the locking mechanisms are different.\n-unsafe impl<'id> Sync for LCellOwner<'id> {}\n unsafe impl<'id, T: Send + Sync + ?Sized> Sync for LCell<'id, T> {}\n \n #[cfg(test)]\n",
    "diff_parsed": "{'added': [(3, 'struct Invariant<Q>(fn(Q) -> Q);'), (5, \"type Id<'id> = PhantomData<Invariant<&'id ()>>;\")], 'deleted': [(4, \"type Id<'id> = PhantomData<Cell<&'id mut ()>>;\"), (188, \"unsafe impl<'id> Sync for LCellOwner<'id> {}\")]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "220"
  },
  {
    "file_change_id": "41471655148990",
    "hash": "392a889f02c17edf0df4a9c08c134896b045387",
    "old_path": "futures-util/src/lock/mutex.rs",
    "new_path": "futures-util/src/lock/mutex.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -3,15 +3,16 @@ use futures_core::task::{Context, Poll, Waker};\n use slab::Slab;\n use std::{fmt, mem};\n use std::cell::UnsafeCell;\n+use std::marker::PhantomData;\n use std::ops::{Deref, DerefMut};\n use std::pin::Pin;\n use std::sync::Mutex as StdMutex;\n use std::sync::atomic::{AtomicUsize, Ordering};\n \n /// A futures-aware mutex.\n-/// \n+///\n /// # Fairness\n-/// \n+///\n /// This mutex provides no fairness guarantees. Tasks may not acquire the mutex\n /// in the order that they requested the lock, and it's possible for a single task\n /// which repeatedly takes the lock to starve other tasks, which may be left waiting\n@@ -288,7 +289,7 @@ impl<'a, T: ?Sized> MutexGuard<'a, T> {\n         // Don't run the `drop` method for MutexGuard. The ownership of the underlying\n         // locked state is being moved to the returned MappedMutexGuard.\n         mem::forget(this);\n-        MappedMutexGuard { mutex, value }\n+        MappedMutexGuard { mutex, value, _marker: PhantomData }\n     }\n }\n \n@@ -325,6 +326,7 @@ impl<T: ?Sized> DerefMut for MutexGuard<'_, T> {\n pub struct MappedMutexGuard<'a, T: ?Sized, U: ?Sized> {\n     mutex: &'a Mutex<T>,\n     value: *mut U,\n+    _marker: PhantomData<&'a mut U>,\n }\n \n impl<'a, T: ?Sized, U: ?Sized> MappedMutexGuard<'a, T, U> {\n@@ -354,7 +356,7 @@ impl<'a, T: ?Sized, U: ?Sized> MappedMutexGuard<'a, T, U> {\n         // Don't run the `drop` method for MappedMutexGuard. The ownership of the underlying\n         // locked state is being moved to the returned MappedMutexGuard.\n         mem::forget(this);\n-        MappedMutexGuard { mutex, value }\n+        MappedMutexGuard { mutex, value, _marker: PhantomData }\n     }\n }\n \n@@ -401,8 +403,8 @@ unsafe impl<T: ?Sized> Sync for MutexLockFuture<'_, T> {}\n // lock is essentially spinlock-equivalent (attempt to flip an atomic bool)\n unsafe impl<T: ?Sized + Send> Send for MutexGuard<'_, T> {}\n unsafe impl<T: ?Sized + Sync> Sync for MutexGuard<'_, T> {}\n-unsafe impl<T: ?Sized + Send, U: ?Sized> Send for MappedMutexGuard<'_, T, U> {}\n-unsafe impl<T: ?Sized + Sync, U: ?Sized> Sync for MappedMutexGuard<'_, T, U> {}\n+unsafe impl<T: ?Sized + Send, U: ?Sized + Send> Send for MappedMutexGuard<'_, T, U> {}\n+unsafe impl<T: ?Sized + Sync, U: ?Sized + Sync> Sync for MappedMutexGuard<'_, T, U> {}\n \n #[test]\n fn test_mutex_guard_debug_not_recurse() {\n",
    "diff_parsed": "{'added': [(6, 'use std::marker::PhantomData;'), (292, '        MappedMutexGuard { mutex, value, _marker: PhantomData }'), (329, \"    _marker: PhantomData<&'a mut U>,\"), (359, '        MappedMutexGuard { mutex, value, _marker: PhantomData }'), (406, \"unsafe impl<T: ?Sized + Send, U: ?Sized + Send> Send for MappedMutexGuard<'_, T, U> {}\"), (407, \"unsafe impl<T: ?Sized + Sync, U: ?Sized + Sync> Sync for MappedMutexGuard<'_, T, U> {}\")], 'deleted': [(291, '        MappedMutexGuard { mutex, value }'), (357, '        MappedMutexGuard { mutex, value }'), (404, \"unsafe impl<T: ?Sized + Send, U: ?Sized> Send for MappedMutexGuard<'_, T, U> {}\"), (405, \"unsafe impl<T: ?Sized + Sync, U: ?Sized> Sync for MappedMutexGuard<'_, T, U> {}\")]}",
    "num_lines_added": "6",
    "num_lines_deleted": "4",
    "nloc": "335"
  },
  {
    "file_change_id": "184625902898882",
    "hash": "0e6006de464caa331643f86cd2d9ba3b32b0983",
    "old_path": "src/de.rs",
    "new_path": "src/de.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -70,7 +70,7 @@ where\n     fn read_vec(&mut self) -> Result<Vec<u8>> {\n         let len: u32 = de::Deserialize::deserialize(&mut *self)?;\n         let mut buf = Vec::with_capacity(len as usize);\n-        unsafe { buf.set_len(len as usize) }\n+        buf.resize(len as usize, 0);\n         self.read_size(u64::from(len))?;\n         self.reader.read_exact(&mut buf[..])?;\n         Ok(buf)\n",
    "diff_parsed": "{'added': [(73, '        buf.resize(len as usize, 0);')], 'deleted': [(73, '        unsafe { buf.set_len(len as usize) }')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "452"
  },
  {
    "file_change_id": "95514333302028",
    "hash": "aabf5562f8c6374ab30f615b28e0cff9b5c79e5",
    "old_path": "src/greedy.rs",
    "new_path": "src/greedy.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -15,6 +15,7 @@ use std::ops::RangeBounds;\n /// [`std::io::BufReader`]: https://doc.rust-lang.org/std/io/struct.BufReader.html\n /// [`new`]: ./struct.GreedyAccessReader.html#method.new\n /// [`with_capacity`]: ./struct.GreedyAccessReader.html#method.with_capacity\n+#[derive(Debug, Clone)]\n pub struct GreedyAccessReader<R> {\n     inner: R,\n     buf: Vec<u8>,\n@@ -197,26 +198,14 @@ where\n         }\n \n         let b = self.buf.len();\n-        let buf = unsafe {\n-            // safe because it's within the buffer's limits\n-            // and we won't be reading uninitialized memory\n-            std::slice::from_raw_parts_mut(\n-                self.buf.as_mut_ptr().add(b),\n-                self.buf.capacity() - b)\n-        };\n+        self.buf.resize(self.buf.capacity(), 0);\n+        let buf = &mut self.buf[b..];\n+        let o = self.inner.read(buf)?;\n \n-        match self.inner.read(buf) {\n-            Ok(o) => {\n-                unsafe {\n-                    // reset the size to include the written portion,\n-                    // safe because the extra data is initialized\n-                    self.buf.set_len(b + o);\n-                }\n+        // truncate to exclude non-written portion\n+        self.buf.truncate(b + o);\n \n-                Ok(&self.buf[self.consumed..])\n-            }\n-            Err(e) => Err(e),\n-        }\n+        Ok(&self.buf[self.consumed..])\n     }\n \n     fn consume(&mut self, amt: usize) {\n",
    "diff_parsed": "{'added': [(18, '#[derive(Debug, Clone)]'), (201, '        self.buf.resize(self.buf.capacity(), 0);'), (202, '        let buf = &mut self.buf[b..];'), (203, '        let o = self.inner.read(buf)?;'), (206, '        self.buf.truncate(b + o);'), (208, '        Ok(&self.buf[self.consumed..])')], 'deleted': [(200, '        let buf = unsafe {'), (203, '            std::slice::from_raw_parts_mut('), (204, '                self.buf.as_mut_ptr().add(b),'), (205, '                self.buf.capacity() - b)'), (206, '        };'), (208, '        match self.inner.read(buf) {'), (209, '            Ok(o) => {'), (210, '                unsafe {'), (213, '                    self.buf.set_len(b + o);'), (214, '                }'), (216, '                Ok(&self.buf[self.consumed..])'), (217, '            }'), (218, '            Err(e) => Err(e),'), (219, '        }')]}",
    "num_lines_added": "6",
    "num_lines_deleted": "14",
    "nloc": "214"
  },
  {
    "file_change_id": "132428447265748",
    "hash": "f6d9bc6e8f6ad7f0d949a444a1c1d91d6d837e6",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -126,7 +126,7 @@ impl<T, U> LazyTransform<T, U>\n \n unsafe impl<T, U> Sync for LazyTransform<T, U>\n     where T: Sync + Send,\n-          U: Sync\n+          U: Send + Sync\n {\n }\n \n",
    "diff_parsed": "{'added': [(129, '          U: Send + Sync')], 'deleted': [(129, '          U: Sync')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "184"
  },
  {
    "file_change_id": "270864324623609",
    "hash": "50a50ed90d6ad78d812a40680257d8338843869",
    "old_path": "lib.rs",
    "new_path": "lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -654,6 +654,7 @@ impl<A: Array> SmallVec<A> {\n                 }\n                 self.data = SmallVecData::from_inline(mem::uninitialized());\n                 ptr::copy_nonoverlapping(ptr, self.data.inline_mut().ptr_mut(), len);\n+                self.capacity = len;\n             } else if new_cap != cap {\n                 let mut vec = Vec::with_capacity(new_cap);\n                 let new_alloc = vec.as_mut_ptr();\n@@ -2311,4 +2312,21 @@ mod tests {\n         let decoded: SmallVec<[i32; 2]> = deserialize(&encoded).unwrap();\n         assert_eq!(small_vec, decoded);\n     }\n+\n+    #[test]\n+    fn grow_to_shrink() {\n+        let mut v: SmallVec<[u8; 2]> = SmallVec::new();\n+        v.push(1);\n+        v.push(2);\n+        v.push(3);\n+        assert!(v.spilled());\n+        v.clear();\n+        // Shrink to inline.\n+        v.grow(2);\n+        assert!(!v.spilled());\n+        assert_eq!(v.capacity(), 2);\n+        assert_eq!(v.len(), 0);\n+        v.push(4);\n+        assert_eq!(v[..], [4]);\n+    }\n }\n",
    "diff_parsed": "{'added': [(657, '                self.capacity = len;'), (2316, '    #[test]'), (2317, '    fn grow_to_shrink() {'), (2318, '        let mut v: SmallVec<[u8; 2]> = SmallVec::new();'), (2319, '        v.push(1);'), (2320, '        v.push(2);'), (2321, '        v.push(3);'), (2322, '        assert!(v.spilled());'), (2323, '        v.clear();'), (2325, '        v.grow(2);'), (2326, '        assert!(!v.spilled());'), (2327, '        assert_eq!(v.capacity(), 2);'), (2328, '        assert_eq!(v.len(), 0);'), (2329, '        v.push(4);'), (2330, '        assert_eq!(v[..], [4]);'), (2331, '    }')], 'deleted': []}",
    "num_lines_added": "16",
    "num_lines_deleted": "0",
    "nloc": "1692"
  },
  {
    "file_change_id": "147031710235886",
    "hash": "ea809ba4ae37c4b0de54158e05699f1907c9e83",
    "old_path": "ash/src/util.rs",
    "new_path": "ash/src/util.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -113,15 +113,12 @@ pub fn read_spv<R: io::Read + io::Seek>(x: &mut R) -> io::Result<Vec<u32>> {\n         return Err(io::Error::new(io::ErrorKind::InvalidData, \"input too long\"));\n     }\n     let words = (size / 4) as usize;\n-    let mut result = Vec::<u32>::with_capacity(words);\n+    // https://github.com/MaikKlein/ash/issues/354:\n+    // Zero-initialize the result to prevent read_exact from possibly\n+    // reading uninitialized memory.\n+    let mut result = vec![0u32; words];\n     x.seek(io::SeekFrom::Start(0))?;\n-    unsafe {\n-        x.read_exact(slice::from_raw_parts_mut(\n-            result.as_mut_ptr() as *mut u8,\n-            words * 4,\n-        ))?;\n-        result.set_len(words);\n-    }\n+    x.read_exact(unsafe { slice::from_raw_parts_mut(result.as_mut_ptr() as *mut u8, words * 4) })?;\n     const MAGIC_NUMBER: u32 = 0x0723_0203;\n     if !result.is_empty() && result[0] == MAGIC_NUMBER.swap_bytes() {\n         for word in &mut result {\n",
    "diff_parsed": "{'added': [(119, '    let mut result = vec![0u32; words];'), (121, '    x.read_exact(unsafe { slice::from_raw_parts_mut(result.as_mut_ptr() as *mut u8, words * 4) })?;')], 'deleted': [(116, '    let mut result = Vec::<u32>::with_capacity(words);'), (118, '    unsafe {'), (119, '        x.read_exact(slice::from_raw_parts_mut('), (120, '            result.as_mut_ptr() as *mut u8,'), (121, '            words * 4,'), (122, '        ))?;'), (123, '        result.set_len(words);'), (124, '    }')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "8",
    "nloc": "102"
  },
  {
    "file_change_id": "21532632557294",
    "hash": "9803f31fbd1717d482d848f041044d061fca6da",
    "old_path": "derive-com-impl/src/derive.rs",
    "new_path": "derive-com-impl/src/derive.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -122,6 +122,8 @@ impl<'a> ComImpl<'a> {\n                         return winapi::shared::winerror::E_POINTER;\n                     }\n                     if #( #is_equal_iid )||* {\n+                        let that = &*(this as *const Self);\n+                        that.#refcount.add_ref();\n                         *ppv = this as *mut winapi::ctypes::c_void;\n                         winapi::shared::winerror::S_OK\n                     } else {\n",
    "diff_parsed": "{'added': [(125, '                        let that = &*(this as *const Self);'), (126, '                        that.#refcount.add_ref();')], 'deleted': []}",
    "num_lines_added": "2",
    "num_lines_deleted": "0",
    "nloc": "338"
  },
  {
    "file_change_id": "103819720097446",
    "hash": "cb068895ca2aa236ad8bc858c80b2209cbc4f04",
    "old_path": "src/context.rs",
    "new_path": "src/context.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -48,7 +48,7 @@ pub trait Hotplug<T: UsbContext> {\n \n pub type Registration = c_int;\n \n-pub trait UsbContext: Clone + Sized {\n+pub trait UsbContext: Clone + Sized + Send + Sync {\n     /// Get the raw libusb_context pointer, for advanced use in unsafe code.\n     fn as_raw(&self) -> *mut libusb_context;\n \n",
    "diff_parsed": "{'added': [(51, 'pub trait UsbContext: Clone + Sized + Send + Sync {')], 'deleted': [(51, 'pub trait UsbContext: Clone + Sized {')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "203"
  },
  {
    "file_change_id": "281166303291694",
    "hash": "c66cd3085742c50ae231c77f1bc5b577d0cceb9",
    "old_path": "rust/flatbuffers/src/primitives.rs",
    "new_path": "rust/flatbuffers/src/primitives.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -263,6 +263,14 @@ impl<'a, T: Follow<'a> + 'a> Follow<'a> for SkipFileIdentifier<T> {\n     }\n }\n \n+impl<'a> Follow<'a> for bool {\n+    type Inner = bool;\n+    #[inline(always)]\n+    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+        read_scalar_at::<u8>(buf, loc) != 0\n+    }\n+}\n+\n /// Follow trait impls for primitive types.\n ///\n /// Ideally, these would be implemented as a single impl using trait bounds on\n@@ -280,7 +288,6 @@ macro_rules! impl_follow_for_endian_scalar {\n     };\n }\n \n-impl_follow_for_endian_scalar!(bool);\n impl_follow_for_endian_scalar!(u8);\n impl_follow_for_endian_scalar!(u16);\n impl_follow_for_endian_scalar!(u32);\n",
    "diff_parsed": "{'added': [(266, \"impl<'a> Follow<'a> for bool {\"), (267, '    type Inner = bool;'), (268, '    #[inline(always)]'), (269, \"    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\"), (270, '        read_scalar_at::<u8>(buf, loc) != 0'), (271, '    }'), (272, '}')], 'deleted': [(283, 'impl_follow_for_endian_scalar!(bool);')]}",
    "num_lines_added": "7",
    "num_lines_deleted": "1",
    "nloc": "209"
  },
  {
    "file_change_id": "248033864680989",
    "hash": "34c2b9e51cd7b85a3366104092ca4e5e9fab227",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -89,8 +89,8 @@ impl<T: Sized> Drop for AtomicBox<T> {\n     }\n }\n \n-unsafe impl<T: Sized> Sync for AtomicBox<T> {}\n-unsafe impl<T: Sized> Send for AtomicBox<T> {}\n+unsafe impl<T: Sized + Sync> Sync for AtomicBox<T> {}\n+unsafe impl<T: Sized + Send> Send for AtomicBox<T> {}\n \n #[cfg(test)]\n mod tests {\n",
    "diff_parsed": "{'added': [(92, 'unsafe impl<T: Sized + Sync> Sync for AtomicBox<T> {}'), (93, 'unsafe impl<T: Sized + Send> Send for AtomicBox<T> {}')], 'deleted': [(92, 'unsafe impl<T: Sized> Sync for AtomicBox<T> {}'), (93, 'unsafe impl<T: Sized> Send for AtomicBox<T> {}')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "172"
  },
  {
    "file_change_id": "248538935129077",
    "hash": "ae13bdac8b95966a4fdef3b17aa6d2096799f7c",
    "old_path": "quinn/src/platform/unix.rs",
    "new_path": "quinn/src/platform/unix.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -2,7 +2,7 @@ use std::{\n     io,\n     io::IoSliceMut,\n     mem::{self, MaybeUninit},\n-    net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr, SocketAddrV4, SocketAddrV6},\n+    net::{IpAddr, SocketAddr, SocketAddrV4, SocketAddrV6},\n     os::unix::io::AsRawFd,\n     ptr,\n     task::{Context, Poll},\n@@ -375,8 +375,8 @@ fn prepare_msg(\n                 IpAddr::V4(v4) => {\n                     let pktinfo = libc::in_pktinfo {\n                         ipi_ifindex: 0,\n-                        ipi_spec_dst: unsafe {\n-                            *(v4 as *const Ipv4Addr as *const () as *const libc::in_addr)\n+                        ipi_spec_dst: libc::in_addr {\n+                            s_addr: u32::from_ne_bytes(v4.octets()),\n                         },\n                         ipi_addr: libc::in_addr { s_addr: 0 },\n                     };\n@@ -385,8 +385,8 @@ fn prepare_msg(\n                 IpAddr::V6(v6) => {\n                     let pktinfo = libc::in6_pktinfo {\n                         ipi6_ifindex: 0,\n-                        ipi6_addr: unsafe {\n-                            *(v6 as *const Ipv6Addr as *const () as *const libc::in6_addr)\n+                        ipi6_addr: libc::in6_addr {\n+                            s6_addr: v6.octets(),\n                         },\n                     };\n                     encoder.push(libc::IPPROTO_IPV6, libc::IPV6_PKTINFO, pktinfo);\n",
    "diff_parsed": "{'added': [(5, '    net::{IpAddr, SocketAddr, SocketAddrV4, SocketAddrV6},'), (378, '                        ipi_spec_dst: libc::in_addr {'), (379, '                            s_addr: u32::from_ne_bytes(v4.octets()),'), (388, '                        ipi6_addr: libc::in6_addr {'), (389, '                            s6_addr: v6.octets(),')], 'deleted': [(5, '    net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr, SocketAddrV4, SocketAddrV6},'), (378, '                        ipi_spec_dst: unsafe {'), (379, '                            *(v4 as *const Ipv4Addr as *const () as *const libc::in_addr)'), (388, '                        ipi6_addr: unsafe {'), (389, '                            *(v6 as *const Ipv6Addr as *const () as *const libc::in6_addr)')]}",
    "num_lines_added": "5",
    "num_lines_deleted": "5",
    "nloc": "482"
  },
  {
    "file_change_id": "156715422689911",
    "hash": "cd64316558c7faffc7e3669298e81dc9289ac22",
    "old_path": "quinn/src/platform/unix.rs",
    "new_path": "quinn/src/platform/unix.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -198,9 +198,25 @@ fn send(io: &mio::net::UdpSocket, transmits: &[Transmit]) -> io::Result<usize> {\n     let mut msgs: [libc::mmsghdr; BATCH_SIZE] = unsafe { mem::zeroed() };\n     let mut iovecs: [libc::iovec; BATCH_SIZE] = unsafe { mem::zeroed() };\n     let mut cmsgs = [cmsg::Aligned([0u8; CMSG_LEN]); BATCH_SIZE];\n+    // This assume_init looks a bit weird because one might think it\n+    // assumes the SockAddr data to be initialized, but that call\n+    // refers to the whole array, which itself is made up of MaybeUninit\n+    // containers. Their presence protects the SockAddr inside from\n+    // being assumed as initialized by the assume_init call.\n+    // TODO: Replace this with uninit_array once it becomes MSRV-stable\n+    let mut addrs: [MaybeUninit<socket2::SockAddr>; BATCH_SIZE] =\n+        unsafe { MaybeUninit::uninit().assume_init() };\n     for (i, transmit) in transmits.iter().enumerate().take(BATCH_SIZE) {\n+        let dst_addr = unsafe {\n+            std::ptr::write(\n+                addrs[i].as_mut_ptr(),\n+                socket2::SockAddr::from(transmit.destination),\n+            );\n+            &*addrs[i].as_ptr()\n+        };\n         prepare_msg(\n             transmit,\n+            dst_addr,\n             &mut msgs[i].msg_hdr,\n             &mut iovecs[i],\n             &mut cmsgs[i],\n@@ -233,7 +249,8 @@ fn send(io: &mio::net::UdpSocket, transmits: &[Transmit]) -> io::Result<usize> {\n     let mut ctrl = cmsg::Aligned([0u8; CMSG_LEN]);\n     let mut sent = 0;\n     while sent < transmits.len() {\n-        prepare_msg(&transmits[sent], &mut hdr, &mut iov, &mut ctrl);\n+        let addr = socket2::SockAddr::from(transmits[sent].destination);\n+        prepare_msg(&transmits[sent], &addr, &mut hdr, &mut iov, &mut ctrl);\n         let n = unsafe { libc::sendmsg(io.as_raw_fd(), &hdr, 0) };\n         if n == -1 {\n             let e = io::Error::last_os_error();\n@@ -334,6 +351,7 @@ const CMSG_LEN: usize = 80;\n \n fn prepare_msg(\n     transmit: &Transmit,\n+    dst_addr: &socket2::SockAddr,\n     hdr: &mut libc::msghdr,\n     iov: &mut libc::iovec,\n     ctrl: &mut cmsg::Aligned<[u8; CMSG_LEN]>,\n@@ -341,12 +359,15 @@ fn prepare_msg(\n     iov.iov_base = transmit.contents.as_ptr() as *const _ as *mut _;\n     iov.iov_len = transmit.contents.len();\n \n-    let (name, namelen) = match transmit.destination {\n-        SocketAddr::V4(ref addr) => (addr as *const _ as _, mem::size_of::<libc::sockaddr_in>()),\n-        SocketAddr::V6(ref addr) => (addr as *const _ as _, mem::size_of::<libc::sockaddr_in6>()),\n-    };\n-    hdr.msg_name = name;\n-    hdr.msg_namelen = namelen as _;\n+    // SAFETY: Casting the pointer to a mutable one is legal,\n+    // as sendmsg is guaranteed to not alter the mutable pointer\n+    // as per the POSIX spec. See the section on the sys/socket.h\n+    // header for details. The type is only mutable in the first\n+    // place because it is reused by recvmsg as well.\n+    let name = dst_addr.as_ptr() as *mut libc::c_void;\n+    let namelen = dst_addr.len();\n+    hdr.msg_name = name as *mut _;\n+    hdr.msg_namelen = namelen;\n     hdr.msg_iov = iov;\n     hdr.msg_iovlen = 1;\n \n",
    "diff_parsed": "{'added': [(207, '    let mut addrs: [MaybeUninit<socket2::SockAddr>; BATCH_SIZE] ='), (208, '        unsafe { MaybeUninit::uninit().assume_init() };'), (210, '        let dst_addr = unsafe {'), (211, '            std::ptr::write('), (212, '                addrs[i].as_mut_ptr(),'), (213, '                socket2::SockAddr::from(transmit.destination),'), (214, '            );'), (215, '            &*addrs[i].as_ptr()'), (216, '        };'), (219, '            dst_addr,'), (252, '        let addr = socket2::SockAddr::from(transmits[sent].destination);'), (253, '        prepare_msg(&transmits[sent], &addr, &mut hdr, &mut iov, &mut ctrl);'), (354, '    dst_addr: &socket2::SockAddr,'), (367, '    let name = dst_addr.as_ptr() as *mut libc::c_void;'), (368, '    let namelen = dst_addr.len();'), (369, '    hdr.msg_name = name as *mut _;'), (370, '    hdr.msg_namelen = namelen;')], 'deleted': [(236, '        prepare_msg(&transmits[sent], &mut hdr, &mut iov, &mut ctrl);'), (344, '    let (name, namelen) = match transmit.destination {'), (345, '        SocketAddr::V4(ref addr) => (addr as *const _ as _, mem::size_of::<libc::sockaddr_in>()),'), (346, '        SocketAddr::V6(ref addr) => (addr as *const _ as _, mem::size_of::<libc::sockaddr_in6>()),'), (347, '    };'), (348, '    hdr.msg_name = name;'), (349, '    hdr.msg_namelen = namelen as _;')]}",
    "num_lines_added": "17",
    "num_lines_deleted": "7",
    "nloc": "498"
  },
  {
    "file_change_id": "114072149675424",
    "hash": "1e462c32e7933821ddb26dc49fd4ffa5aeca97b",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -76,9 +76,9 @@ impl<T> Drop for QueueSender<T> {\n     }\n }\n \n-unsafe impl<T> Sync for QueueSender<T> {}\n+unsafe impl<T: Send> Sync for QueueSender<T> {}\n \n-unsafe impl<T> Send for QueueSender<T> {}\n+unsafe impl<T: Send> Send for QueueSender<T> {}\n \n /// A `QueueReceiver` is used to pop previously\n /// pushed items from the queue.\n@@ -181,7 +181,7 @@ impl<T> Drop for QueueReceiver<T> {\n     }\n }\n \n-unsafe impl<T> Send for QueueReceiver<T> {}\n+unsafe impl<T: Send> Send for QueueReceiver<T> {}\n \n pub struct Queue;\n \n",
    "diff_parsed": "{'added': [(79, 'unsafe impl<T: Send> Sync for QueueSender<T> {}'), (81, 'unsafe impl<T: Send> Send for QueueSender<T> {}'), (184, 'unsafe impl<T: Send> Send for QueueReceiver<T> {}')], 'deleted': [(79, 'unsafe impl<T> Sync for QueueSender<T> {}'), (81, 'unsafe impl<T> Send for QueueSender<T> {}'), (184, 'unsafe impl<T> Send for QueueReceiver<T> {}')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "3",
    "nloc": "295"
  },
  {
    "file_change_id": "225654481973054",
    "hash": "416a2d480547f6b88ef6d23aa34b1fea292f65f",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -684,7 +684,7 @@ impl<K: Hash + Eq, V, S: BuildHasher> LruCache<K, V, S> {\n     }\n \n     /// An iterator visiting all entries in most-recently used order. The iterator element type is\n-    /// `(&'a K, &'a V)`.\n+    /// `(&K, &V)`.\n     ///\n     /// # Examples\n     ///\n@@ -700,7 +700,7 @@ impl<K: Hash + Eq, V, S: BuildHasher> LruCache<K, V, S> {\n     ///     println!(\"key: {} val: {}\", key, val);\n     /// }\n     /// ```\n-    pub fn iter<'a>(&'_ self) -> Iter<'a, K, V> {\n+    pub fn iter(&self) -> Iter<'_, K, V> {\n         Iter {\n             len: self.len(),\n             ptr: unsafe { (*self.head).next },\n@@ -710,7 +710,7 @@ impl<K: Hash + Eq, V, S: BuildHasher> LruCache<K, V, S> {\n     }\n \n     /// An iterator visiting all entries in most-recently-used order, giving a mutable reference on\n-    /// V.  The iterator element type is `(&'a K, &'a mut V)`.\n+    /// V.  The iterator element type is `(&K, &mut V)`.\n     ///\n     /// # Examples\n     ///\n@@ -735,7 +735,7 @@ impl<K: Hash + Eq, V, S: BuildHasher> LruCache<K, V, S> {\n     ///     }\n     /// }\n     /// ```\n-    pub fn iter_mut<'a>(&'_ mut self) -> IterMut<'a, K, V> {\n+    pub fn iter_mut(&mut self) -> IterMut<'_, K, V> {\n         IterMut {\n             len: self.len(),\n             ptr: unsafe { (*self.head).next },\n",
    "diff_parsed": "{'added': [(703, \"    pub fn iter(&self) -> Iter<'_, K, V> {\"), (738, \"    pub fn iter_mut(&mut self) -> IterMut<'_, K, V> {\")], 'deleted': [(703, \"    pub fn iter<'a>(&'_ self) -> Iter<'a, K, V> {\"), (738, \"    pub fn iter_mut<'a>(&'_ mut self) -> IterMut<'a, K, V> {\")]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "1065"
  },
  {
    "file_change_id": "114561920173863",
    "hash": "565d508993936821950009ec4c7c1e33301db81",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -159,12 +159,16 @@ macro_rules! impl_arrays {\n         $(\n         impl<T: Random> Random for [T; $s] {\n             fn random() -> Self {\n+                use std::mem::{MaybeUninit, transmute_copy, size_of};\n                 unsafe {\n-                    let mut array: [T; $s] = std::mem::uninitialized();\n-                    for i in 0..$s {\n-                        std::ptr::write(&mut array[i], T::random());\n+                    let mut array: [MaybeUninit<T>; $s] = MaybeUninit::uninit().assume_init();\n+                    for elem in &mut array[..] {\n+                        *elem = MaybeUninit::new(T::random());\n                     }\n-                    array\n+\n+                    // See https://github.com/rust-lang/rust/issues/47966\n+                    debug_assert!(size_of::<[MaybeUninit<T>; $s]>() == size_of::<[T; $s]>());\n+                    transmute_copy::<_, [T; $s]>(&array)\n                 }\n             }\n         }\n",
    "diff_parsed": "{'added': [(162, '                use std::mem::{MaybeUninit, transmute_copy, size_of};'), (164, '                    let mut array: [MaybeUninit<T>; $s] = MaybeUninit::uninit().assume_init();'), (165, '                    for elem in &mut array[..] {'), (166, '                        *elem = MaybeUninit::new(T::random());'), (170, '                    debug_assert!(size_of::<[MaybeUninit<T>; $s]>() == size_of::<[T; $s]>());'), (171, '                    transmute_copy::<_, [T; $s]>(&array)')], 'deleted': [(163, '                    let mut array: [T; $s] = std::mem::uninitialized();'), (164, '                    for i in 0..$s {'), (165, '                        std::ptr::write(&mut array[i], T::random());'), (167, '                    array')]}",
    "num_lines_added": "6",
    "num_lines_deleted": "4",
    "nloc": "217"
  },
  {
    "file_change_id": "232158534616821",
    "hash": "15b282877d1e576de2b337d8162bbf43ed1a0f2",
    "old_path": "syncpool/src/bucket.rs",
    "new_path": "syncpool/src/bucket.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -333,7 +333,7 @@ impl<T> Drop for Bucket2<T> {\n     }\n }\n \n-unsafe impl<T> Send for Bucket2<T> {}\n+unsafe impl<T: Send> Send for Bucket2<T> {}\n \n pub(crate) struct RingBucket<T> {\n     /// The actual data store. Data are stored in heap and not managed by the runtime, so we must\n",
    "diff_parsed": "{'added': [(336, 'unsafe impl<T: Send> Send for Bucket2<T> {}')], 'deleted': [(336, 'unsafe impl<T> Send for Bucket2<T> {}')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "196"
  },
  {
    "file_change_id": "104100910063778",
    "hash": "a34d6e10f6f5654ed01a35288cf683d014ebc9c",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -33,7 +33,7 @@ where\n \n unsafe impl<R> Send for Decoder<R>\n where\n-        R: Read,\n+        R: Read + Send,\n {\n }\n \n",
    "diff_parsed": "{'added': [(36, '        R: Read + Send,')], 'deleted': [(36, '        R: Read,')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "109"
  },
  {
    "file_change_id": "179280840825427",
    "hash": "8e6daabbc6fb14972a9db5fc94f06801b2d41c2",
    "old_path": "metrics-util/src/bucket.rs",
    "new_path": "metrics-util/src/bucket.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -96,8 +96,8 @@ impl<T> Block<T> {\n     }\n }\n \n-unsafe impl<T> Send for Block<T> {}\n-unsafe impl<T> Sync for Block<T> {}\n+unsafe impl<T: Send> Send for Block<T> {}\n+unsafe impl<T: Sync> Sync for Block<T> {}\n \n impl<T> std::fmt::Debug for Block<T> {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n",
    "diff_parsed": "{'added': [(99, 'unsafe impl<T: Send> Send for Block<T> {}'), (100, 'unsafe impl<T: Sync> Sync for Block<T> {}')], 'deleted': [(99, 'unsafe impl<T> Send for Block<T> {}'), (100, 'unsafe impl<T> Sync for Block<T> {}')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "409"
  },
  {
    "file_change_id": "78569255007772",
    "hash": "5ba266a853bc8232993c84fe736cb87241f9506",
    "old_path": "protocols/deflate/src/lib.rs",
    "new_path": "protocols/deflate/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -133,10 +133,7 @@ impl<S> AsyncRead for DeflateOutput<S>\n         loop {\n             // Read from `self.inner` into `self.read_interm` if necessary.\n             if this.read_interm.is_empty() && !this.inner_read_eof {\n-                unsafe {\n-                    this.read_interm.reserve(256);\n-                    this.read_interm.set_len(this.read_interm.capacity());\n-                }\n+                this.read_interm.resize(this.read_interm.capacity() + 256, 0);\n \n                 match AsyncRead::poll_read(Pin::new(&mut this.inner), cx, &mut this.read_interm) {\n                     Poll::Ready(Ok(0)) => {\n",
    "diff_parsed": "{'added': [(136, '                this.read_interm.resize(this.read_interm.capacity() + 256, 0);')], 'deleted': [(136, '                unsafe {'), (137, '                    this.read_interm.reserve(256);'), (138, '                    this.read_interm.set_len(this.read_interm.capacity());'), (139, '                }')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "4",
    "nloc": "188"
  },
  {
    "file_change_id": "160538942802745",
    "hash": "1f3709632dccdfd49cbcb152a2f81b95c0b1a3e",
    "old_path": "src/rayon/map.rs",
    "new_path": "src/rayon/map.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -149,7 +149,7 @@ where\n                 let guard = Arc::new(guard);\n                 sref.iter().map(move |(k, v)| {\n                     let guard = Arc::clone(&guard);\n-                    RefMulti::new(guard, k, v.get())\n+                    unsafe { RefMulti::new(guard, k, v.get()) }\n                 })\n             })\n             .drive_unindexed(consumer)\n@@ -213,7 +213,7 @@ where\n                 let guard = Arc::new(guard);\n                 sref.iter_mut().map(move |(k, v)| {\n                     let guard = Arc::clone(&guard);\n-                    RefMutMulti::new(guard, k, v.get_mut())\n+                    unsafe { RefMutMulti::new(guard, k, v.get_mut()) }\n                 })\n             })\n             .drive_unindexed(consumer)\n",
    "diff_parsed": "{'added': [(152, '                    unsafe { RefMulti::new(guard, k, v.get()) }'), (216, '                    unsafe { RefMutMulti::new(guard, k, v.get_mut()) }')], 'deleted': [(152, '                    RefMulti::new(guard, k, v.get())'), (216, '                    RefMutMulti::new(guard, k, v.get_mut())')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "198"
  },
  {
    "file_change_id": "110824705955354",
    "hash": "b0d2bd20eb40b9cbc2958b981ba2dcd9e6f9396",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -81,8 +81,10 @@ pub struct Singleton<T: 'static> {\n \n // The Singleton need to implement Send & Sync to ensure cross core compile check mechanics\n // this is safe as the inner RWLock ensures cross core safety\n-unsafe impl<T> Sync for Singleton<T> {}\n-unsafe impl<T> Send for Singleton<T> {}\n+// but we need to be conditional on the inner type to prevent interior mutable types beeing used\n+// inside a singleton\n+unsafe impl<T> Sync for Singleton<T> where T: Sync {}\n+unsafe impl<T> Send for Singleton<T> where T: Send {}\n \n impl<T: 'static> Singleton<T> {\n     /// Create a new [Singleton] instance to be used in a static variable. Only ``const fn`` constructors are allowed\n",
    "diff_parsed": "{'added': [(86, 'unsafe impl<T> Sync for Singleton<T> where T: Sync {}'), (87, 'unsafe impl<T> Send for Singleton<T> where T: Send {}')], 'deleted': [(84, 'unsafe impl<T> Sync for Singleton<T> {}'), (85, 'unsafe impl<T> Send for Singleton<T> {}')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "51"
  },
  {
    "file_change_id": "195806979916385",
    "hash": "c8f82d45060c9e936ab49cd3838135208de0924",
    "old_path": "tokio/src/sync/oneshot.rs",
    "new_path": "tokio/src/sync/oneshot.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -839,13 +839,15 @@ impl<T> Receiver<T> {\n         let result = if let Some(inner) = self.inner.as_ref() {\n             let state = State::load(&inner.state, Acquire);\n \n-            if state.is_complete() {\n+            // First, check if the channel has been closed. If the channel is\n+            // closed, return an error.\n+            if state.is_closed() {\n+                Err(TryRecvError::Closed)\n+            } else if state.is_complete() {\n                 match unsafe { inner.consume_value() } {\n                     Some(value) => Ok(value),\n                     None => Err(TryRecvError::Closed),\n                 }\n-            } else if state.is_closed() {\n-                Err(TryRecvError::Closed)\n             } else {\n                 // Not ready, this does not clear `inner`\n                 return Err(TryRecvError::Empty);\n",
    "diff_parsed": "{'added': [(844, '            if state.is_closed() {'), (845, '                Err(TryRecvError::Closed)'), (846, '            } else if state.is_complete() {')], 'deleted': [(842, '            if state.is_complete() {'), (847, '            } else if state.is_closed() {'), (848, '                Err(TryRecvError::Closed)')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "3",
    "nloc": "543"
  },
  {
    "file_change_id": "79857628343793",
    "hash": "0562cbfe79f68e061628e5cf0d29d9f879b6913",
    "old_path": "src/demuxer.rs",
    "new_path": "src/demuxer.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -262,7 +262,7 @@ where\n     events: T,\n }\n \n-unsafe impl<T> Send for Demuxer<T> where T: DemuxerEvents {}\n+unsafe impl<T> Send for Demuxer<T> where T: DemuxerEvents + Send {}\n \n impl<T> Demuxer<T>\n where\n",
    "diff_parsed": "{'added': [(265, 'unsafe impl<T> Send for Demuxer<T> where T: DemuxerEvents + Send {}')], 'deleted': [(265, 'unsafe impl<T> Send for Demuxer<T> where T: DemuxerEvents {}')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "430"
  },
  {
    "file_change_id": "279045770432732",
    "hash": "e7fb2f5b5f95437a37d99b8c430c8adc9045f35",
    "old_path": "src/processing/image.rs",
    "new_path": "src/processing/image.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -157,8 +157,8 @@ impl<T> ImageChunkMut<'_, T> {\n     }\n }\n \n-unsafe impl<T> Send for ImageChunkMut<'_, T> {}\n-unsafe impl<T> Sync for ImageChunkMut<'_, T> {}\n+unsafe impl<T: Send> Send for ImageChunkMut<'_, T> {}\n+unsafe impl<T: Sync> Sync for ImageChunkMut<'_, T> {}\n \n impl<T> Index<(usize, usize)> for ImageChunkMut<'_, T> {\n     type Output = T;\n",
    "diff_parsed": "{'added': [(160, \"unsafe impl<T: Send> Send for ImageChunkMut<'_, T> {}\"), (161, \"unsafe impl<T: Sync> Sync for ImageChunkMut<'_, T> {}\")], 'deleted': [(160, \"unsafe impl<T> Send for ImageChunkMut<'_, T> {}\"), (161, \"unsafe impl<T> Sync for ImageChunkMut<'_, T> {}\")]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "206"
  },
  {
    "file_change_id": "276444871910261",
    "hash": "ef4aa05cdd3b81ae9f8a42acd211e95530b1ab7",
    "old_path": "async-coap/src/arc_guard.rs",
    "new_path": "async-coap/src/arc_guard.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -160,8 +160,8 @@ impl<RC, T> ArcGuard<RC, T> {\n     }\n }\n \n-unsafe impl<RC, T: Send> Send for ArcGuard<RC, T> {}\n-unsafe impl<RC, T: Sync> Sync for ArcGuard<RC, T> {}\n+unsafe impl<RC: Send, T: Send> Send for ArcGuard<RC, T> {}\n+unsafe impl<RC: Sync, T: Sync> Sync for ArcGuard<RC, T> {}\n \n impl<RC, T> Deref for ArcGuard<RC, T> {\n     type Target = T;\n",
    "diff_parsed": "{'added': [(163, 'unsafe impl<RC: Send, T: Send> Send for ArcGuard<RC, T> {}'), (164, 'unsafe impl<RC: Sync, T: Sync> Sync for ArcGuard<RC, T> {}')], 'deleted': [(163, 'unsafe impl<RC, T: Send> Send for ArcGuard<RC, T> {}'), (164, 'unsafe impl<RC, T: Sync> Sync for ArcGuard<RC, T> {}')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "112"
  },
  {
    "file_change_id": "163495032254485",
    "hash": "55dd22f447492e272b75230c3d8108faa10c6fc",
    "old_path": "src/pcap.rs",
    "new_path": "src/pcap.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -19,7 +19,7 @@ pub struct Input<R: Read> {\n     iter: Box<dyn PcapReaderIterator<R>>,\n }\n \n-unsafe impl<R: Read> std::marker::Send for Input<R> {}\n+unsafe impl<R: Read + Send> Send for Input<R> {}\n \n impl<R: Read + 'static> Input<R> {\n     pub fn with_read(\n",
    "diff_parsed": "{'added': [(22, 'unsafe impl<R: Read + Send> Send for Input<R> {}')], 'deleted': [(22, 'unsafe impl<R: Read> std::marker::Send for Input<R> {}')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "152"
  },
  {
    "file_change_id": "239075293568377",
    "hash": "5f8e17b1c144e49d244e4e15b985ffa498c4ede",
    "old_path": "src/ffi/generated.rs",
    "new_path": "src/ffi/generated.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -2,7 +2,7 @@\n \n /// ABI-compatible struct for [`ArrowSchema`](https://arrow.apache.org/docs/format/CDataInterface.html#structure-definitions)\n #[repr(C)]\n-#[derive(Debug, Clone)]\n+#[derive(Debug)]\n pub struct ArrowSchema {\n     pub(super) format: *const ::std::os::raw::c_char,\n     pub(super) name: *const ::std::os::raw::c_char,\n@@ -17,7 +17,7 @@ pub struct ArrowSchema {\n \n /// ABI-compatible struct for [`ArrowArray`](https://arrow.apache.org/docs/format/CDataInterface.html#structure-definitions)\n #[repr(C)]\n-#[derive(Debug, Clone)]\n+#[derive(Debug)]\n pub struct ArrowArray {\n     pub(super) length: i64,\n     pub(super) null_count: i64,\n@@ -33,7 +33,7 @@ pub struct ArrowArray {\n \n /// ABI-compatible struct for [`ArrowArrayStream`](https://arrow.apache.org/docs/format/CStreamInterface.html).\n #[repr(C)]\n-#[derive(Debug, Clone)]\n+#[derive(Debug)]\n pub struct ArrowArrayStream {\n     pub(super) get_schema: ::std::option::Option<\n         unsafe extern \"C\" fn(\n",
    "diff_parsed": "{'added': [(5, '#[derive(Debug)]'), (20, '#[derive(Debug)]'), (36, '#[derive(Debug)]')], 'deleted': [(5, '#[derive(Debug, Clone)]'), (20, '#[derive(Debug, Clone)]'), (36, '#[derive(Debug, Clone)]')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "3",
    "nloc": "48"
  },
  {
    "file_change_id": "172909470768061",
    "hash": "7c7757c772fb709c61b1442bcc1e1fbee97bf4a8",
    "old_path": "lucet-runtime/lucet-runtime-internals/src/instance.rs",
    "new_path": "lucet-runtime/lucet-runtime-internals/src/instance.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -14,7 +14,6 @@ use crate::error::Error;\n #[cfg(feature = \"concurrent_testpoints\")]\n use crate::lock_testpoints::LockTestpoints;\n use crate::module::{self, FunctionHandle, Global, GlobalValue, Module, TrapCode};\n-use crate::region::RegionInternal;\n use crate::sysdeps::HOST_PAGE_SIZE_EXPECTED;\n use crate::val::{UntypedRetVal, Val};\n use crate::vmctx::Vmctx;\n@@ -27,6 +26,7 @@ use std::cell::{BorrowError, BorrowMutError, Ref, RefCell, RefMut, UnsafeCell};\n use std::convert::TryFrom;\n use std::marker::PhantomData;\n use std::mem;\n+use std::mem::ManuallyDrop;\n use std::ops::{Deref, DerefMut};\n use std::ptr::{self, NonNull};\n use std::sync::Arc;\n@@ -147,20 +147,29 @@ impl Drop for InstanceHandle {\n             unsafe {\n                 let inst = self.inst.as_mut();\n \n-                // Grab a handle to the region to ensure it outlives `inst`.\n+                // The `inst.alloc` field manages the memory of the instance\n+                // itself. Note, though, that this field is in a `ManuallyDrop`\n+                // so it won't get dropped automatically in `drop_in_place`.\n+                // This is the point where we take over that precise drop.\n                 //\n-                // This ensures that the region won't be dropped by `inst` being\n-                // dropped, which could result in `inst` being unmapped by the\n-                // Region *during* drop of the Instance's fields.\n-                let region: Arc<dyn RegionInternal> = inst.alloc().region.clone();\n+                // By using `take` here we're basically calling `ptr::read`\n+                // which \"duplicates\" the `alloc` since the `alloc` local\n+                // variable here is the exact same as `inst.alloc`. All we do\n+                // with `inst`, though, is call `drop_in_place`, which\n+                // invalidates every other field in `inst`.\n+                let alloc: Alloc = ManuallyDrop::take(&mut inst.alloc);\n \n                 // drop the actual instance\n                 std::ptr::drop_in_place(inst);\n \n-                // and now we can drop what may be the last Arc<Region>. If it is\n-                // it can safely do what it needs with memory; we're not running\n-                // destructors on it anymore.\n-                mem::drop(region);\n+                // Now that we're 100% done with the instance, destructors and\n+                // all, we can release the memory of the instance back to the\n+                // original allocator from whence it came (be it mmap or uffd\n+                // based). This will run the \"official\" destructor for `Alloc`\n+                // which internally does the release. Note that after this\n+                // operation the `inst` pointer is invalid and can no longer be\n+                // used.\n+                drop(alloc);\n             }\n         }\n     }\n@@ -233,8 +242,12 @@ pub struct Instance {\n     /// Conditionally-present helpers to force permutations of possible races in testing.\n     pub lock_testpoints: Arc<LockTestpoints>,\n \n-    /// The memory allocated for this instance\n-    alloc: Alloc,\n+    /// The memory allocated for this instance.\n+    ///\n+    /// Note that this is in a `ManuallyDrop` because this manages the memory of\n+    /// this `Instance` itself. To have precise control over this memory we\n+    /// handle this in `Drop for InstanceHandle`.\n+    alloc: ManuallyDrop<Alloc>,\n \n     /// Handler run for signals that do not arise from a known WebAssembly trap, or that involve\n     /// memory outside of the current instance.\n@@ -1055,7 +1068,7 @@ impl Instance {\n             kill_state,\n             #[cfg(feature = \"concurrent_testpoints\")]\n             lock_testpoints,\n-            alloc,\n+            alloc: ManuallyDrop::new(alloc),\n             fatal_handler: default_fatal_handler,\n             c_fatal_handler: None,\n             signal_handler: Box::new(signal_handler_none) as Box<SignalHandler>,\n",
    "diff_parsed": "{'added': [(29, 'use std::mem::ManuallyDrop;'), (160, '                let alloc: Alloc = ManuallyDrop::take(&mut inst.alloc);'), (172, '                drop(alloc);'), (250, '    alloc: ManuallyDrop<Alloc>,'), (1071, '            alloc: ManuallyDrop::new(alloc),')], 'deleted': [(17, 'use crate::region::RegionInternal;'), (155, '                let region: Arc<dyn RegionInternal> = inst.alloc().region.clone();'), (163, '                mem::drop(region);'), (237, '    alloc: Alloc,'), (1058, '            alloc,')]}",
    "num_lines_added": "5",
    "num_lines_deleted": "5",
    "nloc": "975"
  },
  {
    "file_change_id": "122211172634369",
    "hash": "9e9f1fb44114078c000c78c72e691eeb9e7ac260",
    "old_path": "src/buffer.rs",
    "new_path": "src/buffer.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -192,7 +192,9 @@ impl From<Buffer> for Vec<u8> {\n         let len = buffer.copy_to(&mut slice);\n \n         unsafe {\n-            Vec::from_raw_parts(slice.as_mut_ptr(), len, slice.len())\n+            let vec = Vec::from_raw_parts(slice.as_mut_ptr(), len, slice.len());\n+            mem::forget(slice);\n+            vec\n         }\n     }\n }\n@@ -291,4 +293,17 @@ mod tests {\n         buffer.copy_to(&mut out);\n         assert!(&out == b\"hello world\");\n     }\n+\n+    #[test]\n+    fn vec_from_buffer() {\n+        let mut buffer = Buffer::new();\n+        let bytes = b\"hello world\";\n+        buffer.push(bytes);\n+\n+        assert!(buffer.len() == bytes.len());\n+\n+        let vec = Vec::from(buffer);\n+\n+        assert!(&vec == bytes);\n+    }\n }\n",
    "diff_parsed": "{'added': [(195, '            let vec = Vec::from_raw_parts(slice.as_mut_ptr(), len, slice.len());'), (196, '            mem::forget(slice);'), (197, '            vec'), (297, '    #[test]'), (298, '    fn vec_from_buffer() {'), (299, '        let mut buffer = Buffer::new();'), (300, '        let bytes = b\"hello world\";'), (301, '        buffer.push(bytes);'), (303, '        assert!(buffer.len() == bytes.len());'), (305, '        let vec = Vec::from(buffer);'), (307, '        assert!(&vec == bytes);'), (308, '    }')], 'deleted': [(195, '            Vec::from_raw_parts(slice.as_mut_ptr(), len, slice.len())')]}",
    "num_lines_added": "12",
    "num_lines_deleted": "1",
    "nloc": "212"
  },
  {
    "file_change_id": "248247403394184",
    "hash": "a90cf79fcac7c8b56ee5301752938aa1d2e4260",
    "old_path": "core/src/eval/misc.rs",
    "new_path": "core/src/eval/misc.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -126,9 +126,9 @@ pub fn jump(state: &mut Machine) -> Control {\n pub fn jumpi(state: &mut Machine) -> Control {\n \tpop_u256!(state, dest);\n \tpop!(state, value);\n-\tlet dest = as_usize_or_fail!(dest, ExitError::InvalidJump);\n \n \tif value != H256::zero() {\n+\t\tlet dest = as_usize_or_fail!(dest, ExitError::InvalidJump);\n \t\tif state.valids.is_valid(dest) {\n \t\t\tControl::Jump(dest)\n \t\t} else {\n",
    "diff_parsed": "{'added': [(131, '\\t\\tlet dest = as_usize_or_fail!(dest, ExitError::InvalidJump);')], 'deleted': [(129, '\\tlet dest = as_usize_or_fail!(dest, ExitError::InvalidJump);')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "184"
  },
  {
    "file_change_id": "81512297366861",
    "hash": "14ee7a6f775c5018e71521b52b3c24de8a82c90",
    "old_path": "src/unistd.rs",
    "new_path": "src/unistd.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1540,8 +1540,7 @@ pub fn getgrouplist(user: &CStr, group: Gid) -> Result<Vec<Gid>> {\n         Ok(None) | Err(_) => <c_int>::max_value(),\n     };\n     use std::cmp::min;\n-    let mut ngroups = min(ngroups_max, 8);\n-    let mut groups = Vec::<Gid>::with_capacity(ngroups as usize);\n+    let mut groups = Vec::<Gid>::with_capacity(min(ngroups_max, 8) as usize);\n     cfg_if! {\n         if #[cfg(any(target_os = \"ios\", target_os = \"macos\"))] {\n             type getgrouplist_group_t = c_int;\n@@ -1551,6 +1550,7 @@ pub fn getgrouplist(user: &CStr, group: Gid) -> Result<Vec<Gid>> {\n     }\n     let gid: gid_t = group.into();\n     loop {\n+        let mut ngroups = groups.capacity() as i32;\n         let ret = unsafe {\n             libc::getgrouplist(user.as_ptr(),\n                                gid as getgrouplist_group_t,\n@@ -1567,8 +1567,16 @@ pub fn getgrouplist(user: &CStr, group: Gid) -> Result<Vec<Gid>> {\n             // BSD systems will still fill the groups buffer with as many\n             // groups as possible, but Linux manpages do not mention this\n             // behavior.\n-            reserve_double_buffer_size(&mut groups, ngroups_max as usize)\n-                .map_err(|_| Errno::EINVAL)?;\n+            // Linux stores the number of groups found in ngroups.  We can\n+            // use that to resize the buffer exactly.\n+            cfg_if! {\n+                if #[cfg(target_os = \"linux\")] {\n+                    groups.reserve_exact(ngroups as usize);\n+                } else {\n+                    reserve_double_buffer_size(&mut groups, ngroups_max as usize)\n+                        .map_err(|_| Errno::EINVAL)?;       \n+                }\n+            }            \n         }\n     }\n }\n",
    "diff_parsed": "{'added': [(1543, '    let mut groups = Vec::<Gid>::with_capacity(min(ngroups_max, 8) as usize);'), (1553, '        let mut ngroups = groups.capacity() as i32;'), (1572, '            cfg_if! {'), (1573, '                if #[cfg(target_os = \"linux\")] {'), (1574, '                    groups.reserve_exact(ngroups as usize);'), (1575, '                } else {'), (1576, '                    reserve_double_buffer_size(&mut groups, ngroups_max as usize)'), (1577, '                        .map_err(|_| Errno::EINVAL)?;'), (1578, '                }'), (1579, '            }')], 'deleted': [(1543, '    let mut ngroups = min(ngroups_max, 8);'), (1544, '    let mut groups = Vec::<Gid>::with_capacity(ngroups as usize);'), (1570, '            reserve_double_buffer_size(&mut groups, ngroups_max as usize)'), (1571, '                .map_err(|_| Errno::EINVAL)?;')]}",
    "num_lines_added": "10",
    "num_lines_deleted": "4",
    "nloc": "1615"
  }
]