[
  {
    "file_change_id": "85796880631308",
    "hash": "8bfc20506cc5e098fe6eb3d1cafe3bea791215ce",
    "old_path": "lettre/src/smtp/client/mod.rs",
    "new_path": "lettre/src/smtp/client/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -51,7 +51,15 @@ impl ClientCodec {\n                     match self.escape_count {\n                         0 => self.escape_count = if *byte == b'\\r' { 1 } else { 0 },\n                         1 => self.escape_count = if *byte == b'\\n' { 2 } else { 0 },\n-                        2 => self.escape_count = if *byte == b'.' { 3 } else { 0 },\n+                        2 => {\n+                            self.escape_count = if *byte == b'.' {\n+                                3\n+                            } else if *byte == b'\\r' {\n+                                1\n+                            } else {\n+                                0\n+                            }\n+                        }\n                         _ => unreachable!(),\n                     }\n                     if self.escape_count == 3 {\n@@ -286,6 +294,7 @@ mod test {\n         let mut buf: Vec<u8> = vec![];\n \n         assert!(codec.encode(b\"test\\r\\n\", &mut buf).is_ok());\n+        assert!(codec.encode(b\"test\\r\\n\\r\\n\", &mut buf).is_ok());\n         assert!(codec.encode(b\".\\r\\n\", &mut buf).is_ok());\n         assert!(codec.encode(b\"\\r\\ntest\", &mut buf).is_ok());\n         assert!(codec.encode(b\"te\\r\\n.\\r\\nst\", &mut buf).is_ok());\n@@ -296,7 +305,7 @@ mod test {\n         assert!(codec.encode(b\"test\", &mut buf).is_ok());\n         assert_eq!(\n             String::from_utf8(buf).unwrap(),\n-            \"test\\r\\n..\\r\\n\\r\\ntestte\\r\\n..\\r\\nsttesttest.test\\n.test\\ntest\"\n+            \"test\\r\\ntest\\r\\n\\r\\n..\\r\\n\\r\\ntestte\\r\\n..\\r\\nsttesttest.test\\n.test\\ntest\"\n         );\n     }\n \n",
    "diff_parsed": "{'added': [(54, '                        2 => {'), (55, \"                            self.escape_count = if *byte == b'.' {\"), (56, '                                3'), (57, \"                            } else if *byte == b'\\\\r' {\"), (58, '                                1'), (59, '                            } else {'), (60, '                                0'), (61, '                            }'), (62, '                        }'), (297, '        assert!(codec.encode(b\"test\\\\r\\\\n\\\\r\\\\n\", &mut buf).is_ok());'), (308, '            \"test\\\\r\\\\ntest\\\\r\\\\n\\\\r\\\\n..\\\\r\\\\n\\\\r\\\\ntestte\\\\r\\\\n..\\\\r\\\\nsttesttest.test\\\\n.test\\\\ntest\"')], 'deleted': [(54, \"                        2 => self.escape_count = if *byte == b'.' { 3 } else { 0 },\"), (299, '            \"test\\\\r\\\\n..\\\\r\\\\n\\\\r\\\\ntestte\\\\r\\\\n..\\\\r\\\\nsttesttest.test\\\\n.test\\\\ntest\"')]}",
    "num_lines_added": "11",
    "num_lines_deleted": "2",
    "nloc": "245"
  },
  {
    "file_change_id": "276377456614640",
    "hash": "34c2b9e",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -89,8 +89,8 @@ impl<T: Sized> Drop for AtomicBox<T> {\n     }\n }\n \n-unsafe impl<T: Sized> Sync for AtomicBox<T> {}\n-unsafe impl<T: Sized> Send for AtomicBox<T> {}\n+unsafe impl<T: Sized + Sync> Sync for AtomicBox<T> {}\n+unsafe impl<T: Sized + Send> Send for AtomicBox<T> {}\n \n #[cfg(test)]\n mod tests {\n",
    "diff_parsed": "{'added': [(92, 'unsafe impl<T: Sized + Sync> Sync for AtomicBox<T> {}'), (93, 'unsafe impl<T: Sized + Send> Send for AtomicBox<T> {}')], 'deleted': [(92, 'unsafe impl<T: Sized> Sync for AtomicBox<T> {}'), (93, 'unsafe impl<T: Sized> Send for AtomicBox<T> {}')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "172"
  },
  {
    "file_change_id": "239407819134116",
    "hash": "886ecc562040bef61faf19438c22285c2d62403a",
    "old_path": "crates/runtime/src/instance.rs",
    "new_path": "crates/runtime/src/instance.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -92,6 +92,10 @@ pub(crate) struct Instance {\n     /// allocation, but some host-defined objects will store their state here.\n     host_state: Box<dyn Any + Send + Sync>,\n \n+    /// Flag to track when the vmctx has been initialized.\n+    /// The pooling allocator may drop an instance before `vmctx` is initialized.\n+    vmctx_initialized: bool,\n+\n     /// Additional context used by compiled wasm code. This field is last, and\n     /// represents a dynamically-sized array that extends beyond the nominal\n     /// end of the struct (similar to a flexible array member).\n@@ -119,6 +123,7 @@ impl Instance {\n             dropped_data: EntitySet::with_capacity(module.passive_data_map.len()),\n             host_state,\n             wasm_data,\n+            vmctx_initialized: false,\n             vmctx: VMContext {\n                 _marker: std::marker::PhantomPinned,\n             },\n@@ -733,13 +738,18 @@ impl Instance {\n     }\n \n     fn drop_globals(&mut self) {\n+        // Dropping globals requires that the vmctx be fully initialized\n+        if !self.vmctx_initialized {\n+            return;\n+        }\n+\n         for (idx, global) in self.module.globals.iter() {\n             let idx = match self.module.defined_global_index(idx) {\n                 Some(idx) => idx,\n                 None => continue,\n             };\n             match global.wasm_ty {\n-                // For now only externref gloabls need to get destroyed\n+                // For now only externref globals need to get destroyed\n                 WasmType::ExternRef => {}\n                 _ => continue,\n             }\n",
    "diff_parsed": "{'added': [(97, '    vmctx_initialized: bool,'), (126, '            vmctx_initialized: false,'), (742, '        if !self.vmctx_initialized {'), (743, '            return;'), (744, '        }')], 'deleted': []}",
    "num_lines_added": "5",
    "num_lines_deleted": "0",
    "nloc": "598"
  },
  {
    "file_change_id": "171033539874534",
    "hash": "886ecc562040bef61faf19438c22285c2d62403a",
    "old_path": "crates/runtime/src/instance/allocator.rs",
    "new_path": "crates/runtime/src/instance/allocator.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -475,6 +475,8 @@ fn initialize_instance(\n }\n \n unsafe fn initialize_vmcontext(instance: &mut Instance, req: InstanceAllocationRequest) {\n+    assert!(!instance.vmctx_initialized);\n+\n     if let Some(store) = req.store.as_raw() {\n         *instance.interrupts() = (*store).vminterrupts();\n         *instance.epoch_ptr() = (*store).epoch_ptr();\n@@ -570,6 +572,9 @@ unsafe fn initialize_vmcontext(instance: &mut Instance, req: InstanceAllocationR\n \n     // Initialize the defined globals\n     initialize_vmcontext_globals(instance);\n+\n+    // Mark the vmctx as initialized\n+    instance.vmctx_initialized = true;\n }\n \n unsafe fn initialize_vmcontext_globals(instance: &Instance) {\n",
    "diff_parsed": "{'added': [(478, '    assert!(!instance.vmctx_initialized);'), (577, '    instance.vmctx_initialized = true;')], 'deleted': []}",
    "num_lines_added": "2",
    "num_lines_deleted": "0",
    "nloc": "570"
  },
  {
    "file_change_id": "48714599526513",
    "hash": "886ecc562040bef61faf19438c22285c2d62403a",
    "old_path": "tests/all/pooling_allocator.rs",
    "new_path": "tests/all/pooling_allocator.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -511,3 +511,61 @@ fn preserve_data_segments() -> Result<()> {\n \n     Ok(())\n }\n+\n+#[test]\n+fn drop_externref_global_during_module_init() -> Result<()> {\n+    struct Limiter;\n+\n+    impl ResourceLimiter for Limiter {\n+        fn memory_growing(&mut self, _: usize, _: usize, _: Option<usize>) -> bool {\n+            false\n+        }\n+\n+        fn table_growing(&mut self, _: u32, _: u32, _: Option<u32>) -> bool {\n+            false\n+        }\n+    }\n+\n+    let mut config = Config::new();\n+    config.wasm_reference_types(true);\n+    config.allocation_strategy(InstanceAllocationStrategy::Pooling {\n+        strategy: PoolingAllocationStrategy::NextAvailable,\n+        module_limits: Default::default(),\n+        instance_limits: InstanceLimits { count: 1 },\n+    });\n+\n+    let engine = Engine::new(&config)?;\n+\n+    let module = Module::new(\n+        &engine,\n+        r#\"\n+            (module\n+                (global i32 (i32.const 1))\n+                (global i32 (i32.const 2))\n+                (global i32 (i32.const 3))\n+                (global i32 (i32.const 4))\n+                (global i32 (i32.const 5))\n+            )\n+        \"#,\n+    )?;\n+\n+    let mut store = Store::new(&engine, Limiter);\n+    drop(Instance::new(&mut store, &module, &[])?);\n+    drop(store);\n+\n+    let module = Module::new(\n+        &engine,\n+        r#\"\n+            (module\n+                (memory 1)\n+                (global (mut externref) (ref.null extern))\n+            )\n+        \"#,\n+    )?;\n+\n+    let mut store = Store::new(&engine, Limiter);\n+    store.limiter(|s| s);\n+    assert!(Instance::new(&mut store, &module, &[]).is_err());\n+\n+    Ok(())\n+}\n",
    "diff_parsed": "{'added': [(515, '#[test]'), (516, 'fn drop_externref_global_during_module_init() -> Result<()> {'), (517, '    struct Limiter;'), (519, '    impl ResourceLimiter for Limiter {'), (520, '        fn memory_growing(&mut self, _: usize, _: usize, _: Option<usize>) -> bool {'), (521, '            false'), (522, '        }'), (524, '        fn table_growing(&mut self, _: u32, _: u32, _: Option<u32>) -> bool {'), (525, '            false'), (526, '        }'), (527, '    }'), (529, '    let mut config = Config::new();'), (530, '    config.wasm_reference_types(true);'), (531, '    config.allocation_strategy(InstanceAllocationStrategy::Pooling {'), (532, '        strategy: PoolingAllocationStrategy::NextAvailable,'), (533, '        module_limits: Default::default(),'), (534, '        instance_limits: InstanceLimits { count: 1 },'), (535, '    });'), (537, '    let engine = Engine::new(&config)?;'), (539, '    let module = Module::new('), (540, '        &engine,'), (541, '        r#\"'), (542, '            (module'), (543, '                (global i32 (i32.const 1))'), (544, '                (global i32 (i32.const 2))'), (545, '                (global i32 (i32.const 3))'), (546, '                (global i32 (i32.const 4))'), (547, '                (global i32 (i32.const 5))'), (548, '            )'), (549, '        \"#,'), (550, '    )?;'), (552, '    let mut store = Store::new(&engine, Limiter);'), (553, '    drop(Instance::new(&mut store, &module, &[])?);'), (554, '    drop(store);'), (556, '    let module = Module::new('), (557, '        &engine,'), (558, '        r#\"'), (559, '            (module'), (560, '                (memory 1)'), (561, '                (global (mut externref) (ref.null extern))'), (562, '            )'), (563, '        \"#,'), (564, '    )?;'), (566, '    let mut store = Store::new(&engine, Limiter);'), (567, '    store.limiter(|s| s);'), (568, '    assert!(Instance::new(&mut store, &module, &[]).is_err());'), (570, '    Ok(())'), (571, '}')], 'deleted': []}",
    "num_lines_added": "48",
    "num_lines_deleted": "0",
    "nloc": "458"
  },
  {
    "file_change_id": "23619786521794",
    "hash": "24c7a5550807ac8a09648b5878f19d14c3a69135",
    "old_path": "src/crypto/scalarmult/curve25519.rs",
    "new_path": "src/crypto/scalarmult/curve25519.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -23,14 +23,20 @@ new_type! {\n \n /// `scalarmult()` multiplies a group element `p`\n /// by an integer `n`. It returns the resulting group element\n-/// `q`.\n+/// `Ok(q)`.\n+/// If the the `GroupElement` is all zero, `scalarmult()` returns `Err(())` since\n+/// the resulting `GroupElement` would be all zero, no matter the `Scalar`.\n pub fn scalarmult(&Scalar(ref n): &Scalar,\n-                  &GroupElement(ref p): &GroupElement) -> GroupElement {\n+                  &GroupElement(ref p): &GroupElement)\n+                  -> Result<GroupElement, ()> {\n     let mut q = [0; GROUPELEMENTBYTES];\n     unsafe {\n-        ffi::crypto_scalarmult_curve25519(&mut q, n, p);\n+        if ffi::crypto_scalarmult_curve25519(&mut q, n, p) != 0 {\n+            Err(())\n+        } else {\n+            Ok(GroupElement(q))\n+        }\n     }\n-    GroupElement(q)\n }\n \n /// `scalarmult_base()` computes the scalar product of a standard\n@@ -47,18 +53,17 @@ pub fn scalarmult_base(&Scalar(ref n): &Scalar) -> GroupElement {\n #[cfg(test)]\n mod test {\n     use super::*;\n+    use randombytes::randombytes_into;\n \n     #[test]\n     fn test_vector_1() {\n         // corresponding to tests/scalarmult.c and tests/scalarmult3.cpp from NaCl\n-        let alicesk = Scalar([0x77,0x07,0x6d,0x0a,0x73,0x18,0xa5,0x7d\n-                             ,0x3c,0x16,0xc1,0x72,0x51,0xb2,0x66,0x45\n-                             ,0xdf,0x4c,0x2f,0x87,0xeb,0xc0,0x99,0x2a\n-                             ,0xb1,0x77,0xfb,0xa5,0x1d,0xb9,0x2c,0x2a]);\n-        let alicepk_expected = [0x85,0x20,0xf0,0x09,0x89,0x30,0xa7,0x54\n-                               ,0x74,0x8b,0x7d,0xdc,0xb4,0x3e,0xf7,0x5a\n-                               ,0x0d,0xbf,0x3a,0x0d,0x26,0x38,0x1a,0xf4\n-                               ,0xeb,0xa4,0xa9,0x8e,0xaa,0x9b,0x4e,0x6a];\n+        let alicesk = Scalar([0x77, 0x07, 0x6d, 0x0a, 0x73, 0x18, 0xa5, 0x7d, 0x3c, 0x16, 0xc1,\n+                              0x72, 0x51, 0xb2, 0x66, 0x45, 0xdf, 0x4c, 0x2f, 0x87, 0xeb, 0xc0,\n+                              0x99, 0x2a, 0xb1, 0x77, 0xfb, 0xa5, 0x1d, 0xb9, 0x2c, 0x2a]);\n+        let alicepk_expected = [0x85, 0x20, 0xf0, 0x09, 0x89, 0x30, 0xa7, 0x54, 0x74, 0x8b, 0x7d,\n+                                0xdc, 0xb4, 0x3e, 0xf7, 0x5a, 0x0d, 0xbf, 0x3a, 0x0d, 0x26, 0x38,\n+                                0x1a, 0xf4, 0xeb, 0xa4, 0xa9, 0x8e, 0xaa, 0x9b, 0x4e, 0x6a];\n         let GroupElement(alicepk) = scalarmult_base(&alicesk);\n         assert!(alicepk == alicepk_expected);\n     }\n@@ -66,14 +71,12 @@ mod test {\n     #[test]\n     fn test_vector_2() {\n         // corresponding to tests/scalarmult2.c and tests/scalarmult4.cpp from NaCl\n-        let bobsk = Scalar([0x5d,0xab,0x08,0x7e,0x62,0x4a,0x8a,0x4b\n-                           ,0x79,0xe1,0x7f,0x8b,0x83,0x80,0x0e,0xe6\n-                           ,0x6f,0x3b,0xb1,0x29,0x26,0x18,0xb6,0xfd\n-                           ,0x1c,0x2f,0x8b,0x27,0xff,0x88,0xe0,0xeb]);\n-        let bobpk_expected = [0xde,0x9e,0xdb,0x7d,0x7b,0x7d,0xc1,0xb4\n-                             ,0xd3,0x5b,0x61,0xc2,0xec,0xe4,0x35,0x37\n-                             ,0x3f,0x83,0x43,0xc8,0x5b,0x78,0x67,0x4d\n-                             ,0xad,0xfc,0x7e,0x14,0x6f,0x88,0x2b,0x4f];\n+        let bobsk = Scalar([0x5d, 0xab, 0x08, 0x7e, 0x62, 0x4a, 0x8a, 0x4b, 0x79, 0xe1, 0x7f,\n+                            0x8b, 0x83, 0x80, 0x0e, 0xe6, 0x6f, 0x3b, 0xb1, 0x29, 0x26, 0x18,\n+                            0xb6, 0xfd, 0x1c, 0x2f, 0x8b, 0x27, 0xff, 0x88, 0xe0, 0xeb]);\n+        let bobpk_expected = [0xde, 0x9e, 0xdb, 0x7d, 0x7b, 0x7d, 0xc1, 0xb4, 0xd3, 0x5b, 0x61,\n+                              0xc2, 0xec, 0xe4, 0x35, 0x37, 0x3f, 0x83, 0x43, 0xc8, 0x5b, 0x78,\n+                              0x67, 0x4d, 0xad, 0xfc, 0x7e, 0x14, 0x6f, 0x88, 0x2b, 0x4f];\n         let GroupElement(bobpk) = scalarmult_base(&bobsk);\n         assert!(bobpk == bobpk_expected);\n     }\n@@ -81,40 +84,46 @@ mod test {\n     #[test]\n     fn test_vector_3() {\n         // corresponding to tests/scalarmult5.c and tests/scalarmult7.cpp from NaCl\n-        let alicesk = Scalar([0x77,0x07,0x6d,0x0a,0x73,0x18,0xa5,0x7d\n-                             ,0x3c,0x16,0xc1,0x72,0x51,0xb2,0x66,0x45\n-                             ,0xdf,0x4c,0x2f,0x87,0xeb,0xc0,0x99,0x2a\n-                             ,0xb1,0x77,0xfb,0xa5,0x1d,0xb9,0x2c,0x2a]);\n-        let bobpk = GroupElement([0xde,0x9e,0xdb,0x7d,0x7b,0x7d,0xc1,0xb4\n-                                 ,0xd3,0x5b,0x61,0xc2,0xec,0xe4,0x35,0x37\n-                                 ,0x3f,0x83,0x43,0xc8,0x5b,0x78,0x67,0x4d\n-                                 ,0xad,0xfc,0x7e,0x14,0x6f,0x88,0x2b,0x4f]);\n-        let k_expected = [0x4a,0x5d,0x9d,0x5b,0xa4,0xce,0x2d,0xe1\n-                         ,0x72,0x8e,0x3b,0xf4,0x80,0x35,0x0f,0x25\n-                         ,0xe0,0x7e,0x21,0xc9,0x47,0xd1,0x9e,0x33\n-                         ,0x76,0xf0,0x9b,0x3c,0x1e,0x16,0x17,0x42];\n-        let GroupElement(k) = scalarmult(&alicesk, &bobpk);\n+        let alicesk = Scalar([0x77, 0x07, 0x6d, 0x0a, 0x73, 0x18, 0xa5, 0x7d, 0x3c, 0x16, 0xc1,\n+                              0x72, 0x51, 0xb2, 0x66, 0x45, 0xdf, 0x4c, 0x2f, 0x87, 0xeb, 0xc0,\n+                              0x99, 0x2a, 0xb1, 0x77, 0xfb, 0xa5, 0x1d, 0xb9, 0x2c, 0x2a]);\n+        let bobpk = GroupElement([0xde, 0x9e, 0xdb, 0x7d, 0x7b, 0x7d, 0xc1, 0xb4, 0xd3, 0x5b,\n+                                  0x61, 0xc2, 0xec, 0xe4, 0x35, 0x37, 0x3f, 0x83, 0x43, 0xc8,\n+                                  0x5b, 0x78, 0x67, 0x4d, 0xad, 0xfc, 0x7e, 0x14, 0x6f, 0x88,\n+                                  0x2b, 0x4f]);\n+        let k_expected = [0x4a, 0x5d, 0x9d, 0x5b, 0xa4, 0xce, 0x2d, 0xe1, 0x72, 0x8e, 0x3b, 0xf4,\n+                          0x80, 0x35, 0x0f, 0x25, 0xe0, 0x7e, 0x21, 0xc9, 0x47, 0xd1, 0x9e, 0x33,\n+                          0x76, 0xf0, 0x9b, 0x3c, 0x1e, 0x16, 0x17, 0x42];\n+        let GroupElement(k) = scalarmult(&alicesk, &bobpk).unwrap();\n         assert!(k == k_expected);\n     }\n \n     #[test]\n     fn test_vector_4() {\n         // corresponding to tests/scalarmult6.c from NaCl\n-        let bobsk = Scalar([0x5d,0xab,0x08,0x7e,0x62,0x4a,0x8a,0x4b\n-                           ,0x79,0xe1,0x7f,0x8b,0x83,0x80,0x0e,0xe6\n-                           ,0x6f,0x3b,0xb1,0x29,0x26,0x18,0xb6,0xfd\n-                           ,0x1c,0x2f,0x8b,0x27,0xff,0x88,0xe0,0xeb]);\n-        let alicepk = GroupElement([0x85,0x20,0xf0,0x09,0x89,0x30,0xa7,0x54\n-                                   ,0x74,0x8b,0x7d,0xdc,0xb4,0x3e,0xf7,0x5a\n-                                   ,0x0d,0xbf,0x3a,0x0d,0x26,0x38,0x1a,0xf4\n-                                   ,0xeb,0xa4,0xa9,0x8e,0xaa,0x9b,0x4e,0x6a]);\n-        let k_expected = [0x4a,0x5d,0x9d,0x5b,0xa4,0xce,0x2d,0xe1\n-                         ,0x72,0x8e,0x3b,0xf4,0x80,0x35,0x0f,0x25\n-                         ,0xe0,0x7e,0x21,0xc9,0x47,0xd1,0x9e,0x33\n-                         ,0x76,0xf0,0x9b,0x3c,0x1e,0x16,0x17,0x42];\n-        let GroupElement(k) = scalarmult(&bobsk, &alicepk);\n+        let bobsk = Scalar([0x5d, 0xab, 0x08, 0x7e, 0x62, 0x4a, 0x8a, 0x4b, 0x79, 0xe1, 0x7f,\n+                            0x8b, 0x83, 0x80, 0x0e, 0xe6, 0x6f, 0x3b, 0xb1, 0x29, 0x26, 0x18,\n+                            0xb6, 0xfd, 0x1c, 0x2f, 0x8b, 0x27, 0xff, 0x88, 0xe0, 0xeb]);\n+        let alicepk = GroupElement([0x85, 0x20, 0xf0, 0x09, 0x89, 0x30, 0xa7, 0x54, 0x74, 0x8b,\n+                                    0x7d, 0xdc, 0xb4, 0x3e, 0xf7, 0x5a, 0x0d, 0xbf, 0x3a, 0x0d,\n+                                    0x26, 0x38, 0x1a, 0xf4, 0xeb, 0xa4, 0xa9, 0x8e, 0xaa, 0x9b,\n+                                    0x4e, 0x6a]);\n+        let k_expected = [0x4a, 0x5d, 0x9d, 0x5b, 0xa4, 0xce, 0x2d, 0xe1, 0x72, 0x8e, 0x3b, 0xf4,\n+                          0x80, 0x35, 0x0f, 0x25, 0xe0, 0x7e, 0x21, 0xc9, 0x47, 0xd1, 0x9e, 0x33,\n+                          0x76, 0xf0, 0x9b, 0x3c, 0x1e, 0x16, 0x17, 0x42];\n+        let GroupElement(k) = scalarmult(&bobsk, &alicepk).unwrap();\n         assert!(k == k_expected);\n     }\n+\n+    #[test]\n+    #[should_panic]\n+    fn test_all_zero() {\n+        let mut sk = [0; SCALARBYTES];\n+        randombytes_into(&mut sk);\n+        let sk = Scalar(sk);\n+        let pk = GroupElement([0; GROUPELEMENTBYTES]);\n+        let _ = scalarmult(&sk, &pk).unwrap();\n+    }\n }\n \n #[cfg(feature = \"benchmarks\")]\n",
    "diff_parsed": "{'added': [(30, '                  &GroupElement(ref p): &GroupElement)'), (31, '                  -> Result<GroupElement, ()> {'), (34, '        if ffi::crypto_scalarmult_curve25519(&mut q, n, p) != 0 {'), (35, '            Err(())'), (36, '        } else {'), (37, '            Ok(GroupElement(q))'), (38, '        }'), (56, '    use randombytes::randombytes_into;'), (61, '        let alicesk = Scalar([0x77, 0x07, 0x6d, 0x0a, 0x73, 0x18, 0xa5, 0x7d, 0x3c, 0x16, 0xc1,'), (62, '                              0x72, 0x51, 0xb2, 0x66, 0x45, 0xdf, 0x4c, 0x2f, 0x87, 0xeb, 0xc0,'), (63, '                              0x99, 0x2a, 0xb1, 0x77, 0xfb, 0xa5, 0x1d, 0xb9, 0x2c, 0x2a]);'), (64, '        let alicepk_expected = [0x85, 0x20, 0xf0, 0x09, 0x89, 0x30, 0xa7, 0x54, 0x74, 0x8b, 0x7d,'), (65, '                                0xdc, 0xb4, 0x3e, 0xf7, 0x5a, 0x0d, 0xbf, 0x3a, 0x0d, 0x26, 0x38,'), (66, '                                0x1a, 0xf4, 0xeb, 0xa4, 0xa9, 0x8e, 0xaa, 0x9b, 0x4e, 0x6a];'), (74, '        let bobsk = Scalar([0x5d, 0xab, 0x08, 0x7e, 0x62, 0x4a, 0x8a, 0x4b, 0x79, 0xe1, 0x7f,'), (75, '                            0x8b, 0x83, 0x80, 0x0e, 0xe6, 0x6f, 0x3b, 0xb1, 0x29, 0x26, 0x18,'), (76, '                            0xb6, 0xfd, 0x1c, 0x2f, 0x8b, 0x27, 0xff, 0x88, 0xe0, 0xeb]);'), (77, '        let bobpk_expected = [0xde, 0x9e, 0xdb, 0x7d, 0x7b, 0x7d, 0xc1, 0xb4, 0xd3, 0x5b, 0x61,'), (78, '                              0xc2, 0xec, 0xe4, 0x35, 0x37, 0x3f, 0x83, 0x43, 0xc8, 0x5b, 0x78,'), (79, '                              0x67, 0x4d, 0xad, 0xfc, 0x7e, 0x14, 0x6f, 0x88, 0x2b, 0x4f];'), (87, '        let alicesk = Scalar([0x77, 0x07, 0x6d, 0x0a, 0x73, 0x18, 0xa5, 0x7d, 0x3c, 0x16, 0xc1,'), (88, '                              0x72, 0x51, 0xb2, 0x66, 0x45, 0xdf, 0x4c, 0x2f, 0x87, 0xeb, 0xc0,'), (89, '                              0x99, 0x2a, 0xb1, 0x77, 0xfb, 0xa5, 0x1d, 0xb9, 0x2c, 0x2a]);'), (90, '        let bobpk = GroupElement([0xde, 0x9e, 0xdb, 0x7d, 0x7b, 0x7d, 0xc1, 0xb4, 0xd3, 0x5b,'), (91, '                                  0x61, 0xc2, 0xec, 0xe4, 0x35, 0x37, 0x3f, 0x83, 0x43, 0xc8,'), (92, '                                  0x5b, 0x78, 0x67, 0x4d, 0xad, 0xfc, 0x7e, 0x14, 0x6f, 0x88,'), (93, '                                  0x2b, 0x4f]);'), (94, '        let k_expected = [0x4a, 0x5d, 0x9d, 0x5b, 0xa4, 0xce, 0x2d, 0xe1, 0x72, 0x8e, 0x3b, 0xf4,'), (95, '                          0x80, 0x35, 0x0f, 0x25, 0xe0, 0x7e, 0x21, 0xc9, 0x47, 0xd1, 0x9e, 0x33,'), (96, '                          0x76, 0xf0, 0x9b, 0x3c, 0x1e, 0x16, 0x17, 0x42];'), (97, '        let GroupElement(k) = scalarmult(&alicesk, &bobpk).unwrap();'), (104, '        let bobsk = Scalar([0x5d, 0xab, 0x08, 0x7e, 0x62, 0x4a, 0x8a, 0x4b, 0x79, 0xe1, 0x7f,'), (105, '                            0x8b, 0x83, 0x80, 0x0e, 0xe6, 0x6f, 0x3b, 0xb1, 0x29, 0x26, 0x18,'), (106, '                            0xb6, 0xfd, 0x1c, 0x2f, 0x8b, 0x27, 0xff, 0x88, 0xe0, 0xeb]);'), (107, '        let alicepk = GroupElement([0x85, 0x20, 0xf0, 0x09, 0x89, 0x30, 0xa7, 0x54, 0x74, 0x8b,'), (108, '                                    0x7d, 0xdc, 0xb4, 0x3e, 0xf7, 0x5a, 0x0d, 0xbf, 0x3a, 0x0d,'), (109, '                                    0x26, 0x38, 0x1a, 0xf4, 0xeb, 0xa4, 0xa9, 0x8e, 0xaa, 0x9b,'), (110, '                                    0x4e, 0x6a]);'), (111, '        let k_expected = [0x4a, 0x5d, 0x9d, 0x5b, 0xa4, 0xce, 0x2d, 0xe1, 0x72, 0x8e, 0x3b, 0xf4,'), (112, '                          0x80, 0x35, 0x0f, 0x25, 0xe0, 0x7e, 0x21, 0xc9, 0x47, 0xd1, 0x9e, 0x33,'), (113, '                          0x76, 0xf0, 0x9b, 0x3c, 0x1e, 0x16, 0x17, 0x42];'), (114, '        let GroupElement(k) = scalarmult(&bobsk, &alicepk).unwrap();'), (118, '    #[test]'), (119, '    #[should_panic]'), (120, '    fn test_all_zero() {'), (121, '        let mut sk = [0; SCALARBYTES];'), (122, '        randombytes_into(&mut sk);'), (123, '        let sk = Scalar(sk);'), (124, '        let pk = GroupElement([0; GROUPELEMENTBYTES]);'), (125, '        let _ = scalarmult(&sk, &pk).unwrap();'), (126, '    }')], 'deleted': [(28, '                  &GroupElement(ref p): &GroupElement) -> GroupElement {'), (31, '        ffi::crypto_scalarmult_curve25519(&mut q, n, p);'), (33, '    GroupElement(q)'), (54, '        let alicesk = Scalar([0x77,0x07,0x6d,0x0a,0x73,0x18,0xa5,0x7d'), (55, '                             ,0x3c,0x16,0xc1,0x72,0x51,0xb2,0x66,0x45'), (56, '                             ,0xdf,0x4c,0x2f,0x87,0xeb,0xc0,0x99,0x2a'), (57, '                             ,0xb1,0x77,0xfb,0xa5,0x1d,0xb9,0x2c,0x2a]);'), (58, '        let alicepk_expected = [0x85,0x20,0xf0,0x09,0x89,0x30,0xa7,0x54'), (59, '                               ,0x74,0x8b,0x7d,0xdc,0xb4,0x3e,0xf7,0x5a'), (60, '                               ,0x0d,0xbf,0x3a,0x0d,0x26,0x38,0x1a,0xf4'), (61, '                               ,0xeb,0xa4,0xa9,0x8e,0xaa,0x9b,0x4e,0x6a];'), (69, '        let bobsk = Scalar([0x5d,0xab,0x08,0x7e,0x62,0x4a,0x8a,0x4b'), (70, '                           ,0x79,0xe1,0x7f,0x8b,0x83,0x80,0x0e,0xe6'), (71, '                           ,0x6f,0x3b,0xb1,0x29,0x26,0x18,0xb6,0xfd'), (72, '                           ,0x1c,0x2f,0x8b,0x27,0xff,0x88,0xe0,0xeb]);'), (73, '        let bobpk_expected = [0xde,0x9e,0xdb,0x7d,0x7b,0x7d,0xc1,0xb4'), (74, '                             ,0xd3,0x5b,0x61,0xc2,0xec,0xe4,0x35,0x37'), (75, '                             ,0x3f,0x83,0x43,0xc8,0x5b,0x78,0x67,0x4d'), (76, '                             ,0xad,0xfc,0x7e,0x14,0x6f,0x88,0x2b,0x4f];'), (84, '        let alicesk = Scalar([0x77,0x07,0x6d,0x0a,0x73,0x18,0xa5,0x7d'), (85, '                             ,0x3c,0x16,0xc1,0x72,0x51,0xb2,0x66,0x45'), (86, '                             ,0xdf,0x4c,0x2f,0x87,0xeb,0xc0,0x99,0x2a'), (87, '                             ,0xb1,0x77,0xfb,0xa5,0x1d,0xb9,0x2c,0x2a]);'), (88, '        let bobpk = GroupElement([0xde,0x9e,0xdb,0x7d,0x7b,0x7d,0xc1,0xb4'), (89, '                                 ,0xd3,0x5b,0x61,0xc2,0xec,0xe4,0x35,0x37'), (90, '                                 ,0x3f,0x83,0x43,0xc8,0x5b,0x78,0x67,0x4d'), (91, '                                 ,0xad,0xfc,0x7e,0x14,0x6f,0x88,0x2b,0x4f]);'), (92, '        let k_expected = [0x4a,0x5d,0x9d,0x5b,0xa4,0xce,0x2d,0xe1'), (93, '                         ,0x72,0x8e,0x3b,0xf4,0x80,0x35,0x0f,0x25'), (94, '                         ,0xe0,0x7e,0x21,0xc9,0x47,0xd1,0x9e,0x33'), (95, '                         ,0x76,0xf0,0x9b,0x3c,0x1e,0x16,0x17,0x42];'), (96, '        let GroupElement(k) = scalarmult(&alicesk, &bobpk);'), (103, '        let bobsk = Scalar([0x5d,0xab,0x08,0x7e,0x62,0x4a,0x8a,0x4b'), (104, '                           ,0x79,0xe1,0x7f,0x8b,0x83,0x80,0x0e,0xe6'), (105, '                           ,0x6f,0x3b,0xb1,0x29,0x26,0x18,0xb6,0xfd'), (106, '                           ,0x1c,0x2f,0x8b,0x27,0xff,0x88,0xe0,0xeb]);'), (107, '        let alicepk = GroupElement([0x85,0x20,0xf0,0x09,0x89,0x30,0xa7,0x54'), (108, '                                   ,0x74,0x8b,0x7d,0xdc,0xb4,0x3e,0xf7,0x5a'), (109, '                                   ,0x0d,0xbf,0x3a,0x0d,0x26,0x38,0x1a,0xf4'), (110, '                                   ,0xeb,0xa4,0xa9,0x8e,0xaa,0x9b,0x4e,0x6a]);'), (111, '        let k_expected = [0x4a,0x5d,0x9d,0x5b,0xa4,0xce,0x2d,0xe1'), (112, '                         ,0x72,0x8e,0x3b,0xf4,0x80,0x35,0x0f,0x25'), (113, '                         ,0xe0,0x7e,0x21,0xc9,0x47,0xd1,0x9e,0x33'), (114, '                         ,0x76,0xf0,0x9b,0x3c,0x1e,0x16,0x17,0x42];'), (115, '        let GroupElement(k) = scalarmult(&bobsk, &alicepk);')]}",
    "num_lines_added": "51",
    "num_lines_deleted": "45",
    "nloc": "122"
  },
  {
    "file_change_id": "279962467645712",
    "hash": "ac30e169ae51b262bc8cf7026469851ce39b23c6",
    "old_path": "src/inner_connection.rs",
    "new_path": "src/inner_connection.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,4 +1,4 @@\n-use std::ffi::CString;\n+use std::ffi::CStr;\n use std::os::raw::{c_char, c_int};\n #[cfg(feature = \"load_extension\")]\n use std::path::Path;\n@@ -8,7 +8,7 @@ use std::sync::atomic::{AtomicBool, Ordering};\n use std::sync::{Arc, Mutex};\n \n use super::ffi;\n-use super::{str_for_sqlite, str_to_cstring};\n+use super::str_for_sqlite;\n use super::{Connection, InterruptHandle, OpenFlags, Result};\n use crate::error::{error_from_handle, error_from_sqlite_code, Error};\n use crate::raw_statement::RawStatement;\n@@ -51,9 +51,9 @@ impl InnerConnection {\n     }\n \n     pub fn open_with_flags(\n-        c_path: &CString,\n+        c_path: &CStr,\n         flags: OpenFlags,\n-        vfs: Option<&CString>,\n+        vfs: Option<&CStr>,\n     ) -> Result<InnerConnection> {\n         #[cfg(not(feature = \"bundled\"))]\n         ensure_valid_sqlite_version();\n@@ -171,7 +171,8 @@ impl InnerConnection {\n     }\n \n     pub fn execute_batch(&mut self, sql: &str) -> Result<()> {\n-        let c_sql = str_to_cstring(sql)?;\n+        // use CString instead of SmallCString because it's probably big.\n+        let c_sql = std::ffi::CString::new(sql)?;\n         unsafe {\n             let r = ffi::sqlite3_exec(\n                 self.db(),\n@@ -196,7 +197,7 @@ impl InnerConnection {\n         unsafe {\n             let mut errmsg: *mut c_char = ptr::null_mut();\n             let r = if let Some(entry_point) = entry_point {\n-                let c_entry = str_to_cstring(entry_point)?;\n+                let c_entry = crate::str_to_cstring(entry_point)?;\n                 ffi::sqlite3_load_extension(\n                     self.db,\n                     dylib_str.as_ptr(),\n",
    "diff_parsed": "{'added': [(1, 'use std::ffi::CStr;'), (11, 'use super::str_for_sqlite;'), (54, '        c_path: &CStr,'), (56, '        vfs: Option<&CStr>,'), (175, '        let c_sql = std::ffi::CString::new(sql)?;'), (200, '                let c_entry = crate::str_to_cstring(entry_point)?;')], 'deleted': [(1, 'use std::ffi::CString;'), (11, 'use super::{str_for_sqlite, str_to_cstring};'), (54, '        c_path: &CString,'), (56, '        vfs: Option<&CString>,'), (174, '        let c_sql = str_to_cstring(sql)?;'), (199, '                let c_entry = str_to_cstring(entry_point)?;')]}",
    "num_lines_added": "6",
    "num_lines_deleted": "6",
    "nloc": "402"
  },
  {
    "file_change_id": "121385162690762",
    "hash": "ac30e169ae51b262bc8cf7026469851ce39b23c6",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -129,6 +129,7 @@ mod version;\n pub mod vtab;\n \n pub(crate) mod util;\n+pub(crate) use util::SmallCString;\n \n // Number of cached prepared statements we'll hold on to.\n const STATEMENT_CACHE_DEFAULT_CAPACITY: usize = 16;\n@@ -233,8 +234,8 @@ unsafe fn errmsg_to_string(errmsg: *const c_char) -> String {\n     String::from_utf8_lossy(c_slice).into_owned()\n }\n \n-fn str_to_cstring(s: &str) -> Result<CString> {\n-    Ok(CString::new(s)?)\n+fn str_to_cstring(s: &str) -> Result<SmallCString> {\n+    Ok(SmallCString::new(s)?)\n }\n \n /// Returns `Ok((string ptr, len as c_int, SQLITE_STATIC | SQLITE_TRANSIENT))`\n@@ -301,7 +302,7 @@ pub enum DatabaseName<'a> {\n     feature = \"modern_sqlite\"\n ))]\n impl DatabaseName<'_> {\n-    fn to_cstring(&self) -> Result<CString> {\n+    fn to_cstring(&self) -> Result<util::SmallCString> {\n         use self::DatabaseName::{Attached, Main, Temp};\n         match *self {\n             Main => str_to_cstring(\"main\"),\n",
    "diff_parsed": "{'added': [(132, 'pub(crate) use util::SmallCString;'), (237, 'fn str_to_cstring(s: &str) -> Result<SmallCString> {'), (238, '    Ok(SmallCString::new(s)?)'), (305, '    fn to_cstring(&self) -> Result<util::SmallCString> {')], 'deleted': [(236, 'fn str_to_cstring(s: &str) -> Result<CString> {'), (237, '    Ok(CString::new(s)?)'), (304, '    fn to_cstring(&self) -> Result<CString> {')]}",
    "num_lines_added": "4",
    "num_lines_deleted": "3",
    "nloc": "1416"
  },
  {
    "file_change_id": "82567508953865",
    "hash": "ac30e169ae51b262bc8cf7026469851ce39b23c6",
    "old_path": "src/session.rs",
    "new_path": "src/session.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -102,10 +102,11 @@ impl Session<'_> {\n     /// Attach a table. `None` means all tables.\n     pub fn attach(&mut self, table: Option<&str>) -> Result<()> {\n         let table = if let Some(table) = table {\n-            str_to_cstring(table)?.as_ptr()\n+            Some(str_to_cstring(table)?)\n         } else {\n-            ptr::null()\n+            None\n         };\n+        let table = table.as_ref().map(|s| s.as_ptr()).unwrap_or(ptr::null());\n         unsafe { check!(ffi::sqlite3session_attach(self.s, table)) };\n         Ok(())\n     }\n@@ -156,7 +157,8 @@ impl Session<'_> {\n     /// Load the difference between tables.\n     pub fn diff(&mut self, from: DatabaseName<'_>, table: &str) -> Result<()> {\n         let from = from.to_cstring()?;\n-        let table = str_to_cstring(table)?.as_ptr();\n+        let table = str_to_cstring(table)?;\n+        let table = table.as_ptr();\n         unsafe {\n             let mut errmsg = ptr::null_mut();\n             let r =\n",
    "diff_parsed": "{'added': [(105, '            Some(str_to_cstring(table)?)'), (107, '            None'), (109, '        let table = table.as_ref().map(|s| s.as_ptr()).unwrap_or(ptr::null());'), (160, '        let table = str_to_cstring(table)?;'), (161, '        let table = table.as_ptr();')], 'deleted': [(105, '            str_to_cstring(table)?.as_ptr()'), (107, '            ptr::null()'), (159, '        let table = str_to_cstring(table)?.as_ptr();')]}",
    "num_lines_added": "5",
    "num_lines_deleted": "3",
    "nloc": "818"
  },
  {
    "file_change_id": "265029568563639",
    "hash": "7ab8a264980d23c2ed64e72f4636f38b7381eb39",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -178,7 +178,7 @@ pub fn time_remaining(timeout_point: std::time::Instant) -> std::time::Duration\n /// Creates a future for `job` and runs `job`. The result of `job` will be set as result into the\n /// future. The parameter passed to `job` is a function that returns if the future is still waiting\n /// so that `job` can check for cancellation.\n-pub fn async_with_state<T: 'static, U: 'static, F: FnOnce(Future<T, U>) + Send + 'static>(job: F, shared_state: U) -> Future<T, U> {\n+pub fn async_with_state<T: 'static + Send, U: 'static + Send, F: FnOnce(Future<T, U>) + Send + 'static>(job: F, shared_state: U) -> Future<T, U> {\n \tuse std::clone::Clone;\n \t\n \t// Create future and spawn job\n@@ -192,7 +192,7 @@ pub fn async_with_state<T: 'static, U: 'static, F: FnOnce(Future<T, U>) + Send +\n /// Creates a future for `job` and runs `job`. The result of `job` will be set as result into the\n /// future. The parameter passed to `job` is a function that returns if the future is still waiting\n /// so that `job` can check for cancellation.\n-pub fn async<T: 'static, F: FnOnce(Future<T, ()>) + Send + 'static>(job: F) -> Future<T, ()> {\n+pub fn async<T: 'static + Send, F: FnOnce(Future<T, ()>) + Send + 'static>(job: F) -> Future<T, ()> {\n \tasync_with_state(job, ())\n }\n \n",
    "diff_parsed": "{'added': [(181, \"pub fn async_with_state<T: 'static + Send, U: 'static + Send, F: FnOnce(Future<T, U>) + Send + 'static>(job: F, shared_state: U) -> Future<T, U> {\"), (195, \"pub fn async<T: 'static + Send, F: FnOnce(Future<T, ()>) + Send + 'static>(job: F) -> Future<T, ()> {\")], 'deleted': [(181, \"pub fn async_with_state<T: 'static, U: 'static, F: FnOnce(Future<T, U>) + Send + 'static>(job: F, shared_state: U) -> Future<T, U> {\"), (195, \"pub fn async<T: 'static, F: FnOnce(Future<T, ()>) + Send + 'static>(job: F) -> Future<T, ()> {\")]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "193"
  },
  {
    "file_change_id": "35664439883993",
    "hash": "c7919199a0f6d1ce0e3c33499d1b37f862c990e4",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -162,7 +162,7 @@ impl<T, U> Clone for Future<T, U> {\n \t\tFuture(self.0.clone())\n \t}\n }\n-unsafe impl<T, U> Send for Future<T, U> {}\n+unsafe impl<T: Send, U: Send> Send for Future<T, U> {}\n unsafe impl<T, U> Sync for Future<T, U> {}\n \n \n",
    "diff_parsed": "{'added': [(165, 'unsafe impl<T: Send, U: Send> Send for Future<T, U> {}')], 'deleted': [(165, 'unsafe impl<T, U> Send for Future<T, U> {}')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "193"
  },
  {
    "file_change_id": "70602414388617",
    "hash": "2ef3628dac35aeba0a97d5fb3a57746b4e1d62b3",
    "old_path": "src/functions.rs",
    "new_path": "src/functions.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -12,6 +12,8 @@\n //! use regex::Regex;\n //! use rusqlite::functions::FunctionFlags;\n //! use rusqlite::{Connection, Error, Result, NO_PARAMS};\n+//! use std::sync::Arc;\n+//! type BoxError = Box<dyn std::error::Error + Send + Sync + 'static>;\n //!\n //! fn add_regexp_function(db: &Connection) -> Result<()> {\n //!     db.create_scalar_function(\n@@ -20,34 +22,19 @@\n //!         FunctionFlags::SQLITE_UTF8 | FunctionFlags::SQLITE_DETERMINISTIC,\n //!         move |ctx| {\n //!             assert_eq!(ctx.len(), 2, \"called with unexpected number of arguments\");\n-//!\n-//!             let saved_re: Option<&Regex> = ctx.get_aux(0)?;\n-//!             let new_re = match saved_re {\n-//!                 None => {\n-//!                     let s = ctx.get::<String>(0)?;\n-//!                     match Regex::new(&s) {\n-//!                         Ok(r) => Some(r),\n-//!                         Err(err) => return Err(Error::UserFunctionError(Box::new(err))),\n-//!                     }\n-//!                 }\n-//!                 Some(_) => None,\n-//!             };\n-//!\n+//!             let regexp: Arc<Regex> = ctx\n+//!                 .get_or_create_aux(0, |vr| -> Result<_, BoxError> {\n+//!                     Ok(Regex::new(vr.as_str()?)?)\n+//!                 })?;\n //!             let is_match = {\n-//!                 let re = saved_re.unwrap_or_else(|| new_re.as_ref().unwrap());\n-//!\n //!                 let text = ctx\n //!                     .get_raw(1)\n //!                     .as_str()\n //!                     .map_err(|e| Error::UserFunctionError(e.into()))?;\n //!\n-//!                 re.is_match(text)\n+//!                 regexp.is_match(text)\n //!             };\n //!\n-//!             if let Some(re) = new_re {\n-//!                 ctx.set_aux(0, re);\n-//!             }\n-//!\n //!             Ok(is_match)\n //!         },\n //!     )\n@@ -67,11 +54,12 @@\n //!     Ok(())\n //! }\n //! ```\n-use std::any::TypeId;\n+use std::any::Any;\n use std::os::raw::{c_int, c_void};\n use std::panic::{catch_unwind, RefUnwindSafe, UnwindSafe};\n use std::ptr;\n use std::slice;\n+use std::sync::Arc;\n \n use crate::ffi;\n use crate::ffi::sqlite3_context;\n@@ -121,6 +109,7 @@ unsafe extern \"C\" fn free_boxed_value<T>(p: *mut c_void) {\n pub struct Context<'a> {\n     ctx: *mut sqlite3_context,\n     args: &'a [*mut sqlite3_value],\n+    // conn: PhantomData<&'conn mut Connection>,\n }\n \n impl Context<'_> {\n@@ -174,47 +163,60 @@ impl Context<'_> {\n         unsafe { ValueRef::from_value(arg) }\n     }\n \n+    pub fn get_or_create_aux<T, E, F>(&self, arg: c_int, func: F) -> Result<Arc<T>>\n+    where\n+        T: Send + Sync + 'static,\n+        E: Into<Box<dyn std::error::Error + Send + Sync + 'static>>,\n+        F: FnOnce(ValueRef<'_>) -> Result<T, E>,\n+    {\n+        if let Some(v) = self.get_aux(arg)? {\n+            Ok(v)\n+        } else {\n+            let vr = self.get_raw(arg as usize);\n+            self.set_aux(\n+                arg,\n+                func(vr).map_err(|e| Error::UserFunctionError(e.into()))?,\n+            )\n+        }\n+    }\n+\n     /// Sets the auxilliary data associated with a particular parameter. See\n     /// https://www.sqlite.org/c3ref/get_auxdata.html for a discussion of\n     /// this feature, or the unit tests of this module for an example.\n-    pub fn set_aux<T: 'static>(&self, arg: c_int, value: T) {\n-        let boxed = Box::into_raw(Box::new(AuxData {\n-            id: TypeId::of::<T>(),\n-            value,\n-        }));\n+    pub fn set_aux<T: Send + Sync + 'static>(&self, arg: c_int, value: T) -> Result<Arc<T>> {\n+        let orig: Arc<T> = Arc::new(value);\n+        let inner: AuxInner = orig.clone();\n+        let outer = Box::new(inner);\n+        let raw: *mut AuxInner = Box::into_raw(outer);\n         unsafe {\n             ffi::sqlite3_set_auxdata(\n                 self.ctx,\n                 arg,\n-                boxed as *mut c_void,\n-                Some(free_boxed_value::<AuxData<T>>),\n+                raw as *mut _,\n+                Some(free_boxed_value::<AuxInner>),\n             )\n         };\n+        Ok(orig)\n     }\n \n-    /// Gets the auxilliary data that was associated with a given parameter\n-    /// via `set_aux`. Returns `Ok(None)` if no data has been associated,\n-    /// and .\n-    pub fn get_aux<T: 'static>(&self, arg: c_int) -> Result<Option<&T>> {\n-        let p = unsafe { ffi::sqlite3_get_auxdata(self.ctx, arg) as *const AuxData<T> };\n+    /// Gets the auxilliary data that was associated with a given parameter via\n+    /// `set_aux`. Returns `Ok(None)` if no data has been associated, and\n+    /// Ok(Some(v)) if it has. Returns an error if the requested type does not\n+    /// match.\n+    pub fn get_aux<T: Send + Sync + 'static>(&self, arg: c_int) -> Result<Option<Arc<T>>> {\n+        let p = unsafe { ffi::sqlite3_get_auxdata(self.ctx, arg) as *const AuxInner };\n         if p.is_null() {\n             Ok(None)\n         } else {\n-            let id = unsafe { (*p).id };\n-            if TypeId::of::<T>() != id {\n-                Err(Error::GetAuxWrongType)\n-            } else {\n-                Ok(Some(unsafe { &(*p).value }))\n-            }\n+            let v: AuxInner = AuxInner::clone(unsafe { &*p });\n+            v.downcast::<T>()\n+                .map(Some)\n+                .map_err(|_| Error::GetAuxWrongType)\n         }\n     }\n }\n \n-#[repr(C)]\n-struct AuxData<T: 'static> {\n-    id: TypeId,\n-    value: T,\n-}\n+type AuxInner = Arc<dyn Any + Send + Sync + 'static>;\n \n /// `feature = \"functions\"` Aggregate is the callback interface for user-defined\n /// aggregate function.\n@@ -776,34 +778,21 @@ mod test {\n     // expression multiple times within one query.\n     fn regexp_with_auxilliary(ctx: &Context<'_>) -> Result<bool> {\n         assert_eq!(ctx.len(), 2, \"called with unexpected number of arguments\");\n-\n-        let saved_re: Option<&Regex> = ctx.get_aux(0)?;\n-        let new_re = match saved_re {\n-            None => {\n-                let s = ctx.get::<String>(0)?;\n-                match Regex::new(&s) {\n-                    Ok(r) => Some(r),\n-                    Err(err) => return Err(Error::UserFunctionError(Box::new(err))),\n-                }\n-            }\n-            Some(_) => None,\n-        };\n+        type BoxError = Box<dyn std::error::Error + Send + Sync + 'static>;\n+        let regexp: std::sync::Arc<Regex> = ctx\n+            .get_or_create_aux(0, |vr| -> Result<_, BoxError> {\n+                Ok(Regex::new(vr.as_str()?)?)\n+            })?;\n \n         let is_match = {\n-            let re = saved_re.unwrap_or_else(|| new_re.as_ref().unwrap());\n-\n             let text = ctx\n                 .get_raw(1)\n                 .as_str()\n                 .map_err(|e| Error::UserFunctionError(e.into()))?;\n \n-            re.is_match(text)\n+            regexp.is_match(text)\n         };\n \n-        if let Some(re) = new_re {\n-            ctx.set_aux(0, re);\n-        }\n-\n         Ok(is_match)\n     }\n \n@@ -878,10 +867,10 @@ mod test {\n         let db = Connection::open_in_memory().unwrap();\n         db.create_scalar_function(\"example\", 2, FunctionFlags::default(), |ctx| {\n             if !ctx.get::<bool>(1)? {\n-                ctx.set_aux::<i64>(0, 100);\n+                ctx.set_aux::<i64>(0, 100)?;\n             } else {\n                 assert_eq!(ctx.get_aux::<String>(0), Err(Error::GetAuxWrongType));\n-                assert_eq!(ctx.get_aux::<i64>(0), Ok(Some(&100)));\n+                assert_eq!(*ctx.get_aux::<i64>(0).unwrap().unwrap(), 100);\n             }\n             Ok(true)\n         })\n",
    "diff_parsed": "{'added': [(57, 'use std::any::Any;'), (62, 'use std::sync::Arc;'), (166, '    pub fn get_or_create_aux<T, E, F>(&self, arg: c_int, func: F) -> Result<Arc<T>>'), (167, '    where'), (168, \"        T: Send + Sync + 'static,\"), (169, \"        E: Into<Box<dyn std::error::Error + Send + Sync + 'static>>,\"), (170, \"        F: FnOnce(ValueRef<'_>) -> Result<T, E>,\"), (171, '    {'), (172, '        if let Some(v) = self.get_aux(arg)? {'), (173, '            Ok(v)'), (174, '        } else {'), (175, '            let vr = self.get_raw(arg as usize);'), (176, '            self.set_aux('), (177, '                arg,'), (178, '                func(vr).map_err(|e| Error::UserFunctionError(e.into()))?,'), (179, '            )'), (180, '        }'), (181, '    }'), (186, \"    pub fn set_aux<T: Send + Sync + 'static>(&self, arg: c_int, value: T) -> Result<Arc<T>> {\"), (187, '        let orig: Arc<T> = Arc::new(value);'), (188, '        let inner: AuxInner = orig.clone();'), (189, '        let outer = Box::new(inner);'), (190, '        let raw: *mut AuxInner = Box::into_raw(outer);'), (195, '                raw as *mut _,'), (196, '                Some(free_boxed_value::<AuxInner>),'), (199, '        Ok(orig)'), (206, \"    pub fn get_aux<T: Send + Sync + 'static>(&self, arg: c_int) -> Result<Option<Arc<T>>> {\"), (207, '        let p = unsafe { ffi::sqlite3_get_auxdata(self.ctx, arg) as *const AuxInner };'), (211, '            let v: AuxInner = AuxInner::clone(unsafe { &*p });'), (212, '            v.downcast::<T>()'), (213, '                .map(Some)'), (214, '                .map_err(|_| Error::GetAuxWrongType)'), (219, \"type AuxInner = Arc<dyn Any + Send + Sync + 'static>;\"), (781, \"        type BoxError = Box<dyn std::error::Error + Send + Sync + 'static>;\"), (782, '        let regexp: std::sync::Arc<Regex> = ctx'), (783, '            .get_or_create_aux(0, |vr| -> Result<_, BoxError> {'), (784, '                Ok(Regex::new(vr.as_str()?)?)'), (785, '            })?;'), (793, '            regexp.is_match(text)'), (870, '                ctx.set_aux::<i64>(0, 100)?;'), (873, '                assert_eq!(*ctx.get_aux::<i64>(0).unwrap().unwrap(), 100);')], 'deleted': [(70, 'use std::any::TypeId;'), (180, \"    pub fn set_aux<T: 'static>(&self, arg: c_int, value: T) {\"), (181, '        let boxed = Box::into_raw(Box::new(AuxData {'), (182, '            id: TypeId::of::<T>(),'), (183, '            value,'), (184, '        }));'), (189, '                boxed as *mut c_void,'), (190, '                Some(free_boxed_value::<AuxData<T>>),'), (198, \"    pub fn get_aux<T: 'static>(&self, arg: c_int) -> Result<Option<&T>> {\"), (199, '        let p = unsafe { ffi::sqlite3_get_auxdata(self.ctx, arg) as *const AuxData<T> };'), (203, '            let id = unsafe { (*p).id };'), (204, '            if TypeId::of::<T>() != id {'), (205, '                Err(Error::GetAuxWrongType)'), (206, '            } else {'), (207, '                Ok(Some(unsafe { &(*p).value }))'), (208, '            }'), (213, '#[repr(C)]'), (214, \"struct AuxData<T: 'static> {\"), (215, '    id: TypeId,'), (216, '    value: T,'), (217, '}'), (780, '        let saved_re: Option<&Regex> = ctx.get_aux(0)?;'), (781, '        let new_re = match saved_re {'), (782, '            None => {'), (783, '                let s = ctx.get::<String>(0)?;'), (784, '                match Regex::new(&s) {'), (785, '                    Ok(r) => Some(r),'), (786, '                    Err(err) => return Err(Error::UserFunctionError(Box::new(err))),'), (787, '                }'), (788, '            }'), (789, '            Some(_) => None,'), (790, '        };'), (793, '            let re = saved_re.unwrap_or_else(|| new_re.as_ref().unwrap());'), (800, '            re.is_match(text)'), (803, '        if let Some(re) = new_re {'), (804, '            ctx.set_aux(0, re);'), (805, '        }'), (881, '                ctx.set_aux::<i64>(0, 100);'), (884, '                assert_eq!(ctx.get_aux::<i64>(0), Ok(Some(&100)));')]}",
    "num_lines_added": "41",
    "num_lines_deleted": "39",
    "nloc": "842"
  },
  {
    "file_change_id": "122421615380699",
    "hash": "bf2b2df9c9e218e35e5a38ce3d03cffb7c363956",
    "old_path": "src/less.rs",
    "new_path": "src/less.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -4,7 +4,9 @@ use std::ffi::OsStr;\n use std::process::Command;\n \n pub fn retrieve_less_version(less_path: &dyn AsRef<OsStr>) -> Option<usize> {\n-    let cmd = Command::new(less_path).arg(\"--version\").output().ok()?;\n+    let resolved_path = grep_cli::resolve_binary(less_path.as_ref()).ok()?;\n+\n+    let cmd = Command::new(resolved_path).arg(\"--version\").output().ok()?;\n     parse_less_version(&cmd.stdout)\n }\n \n",
    "diff_parsed": "{'added': [(7, '    let resolved_path = grep_cli::resolve_binary(less_path.as_ref()).ok()?;'), (9, '    let cmd = Command::new(resolved_path).arg(\"--version\").output().ok()?;')], 'deleted': [(7, '    let cmd = Command::new(less_path).arg(\"--version\").output().ok()?;')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "1",
    "nloc": "66"
  },
  {
    "file_change_id": "61587867288476",
    "hash": "bf2b2df9c9e218e35e5a38ce3d03cffb7c363956",
    "old_path": "src/output.rs",
    "new_path": "src/output.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -63,7 +63,14 @@ impl OutputType {\n             return Err(ErrorKind::InvalidPagerValueBat.into());\n         }\n \n-        let mut p = Command::new(&pager.bin);\n+        let resolved_path = match grep_cli::resolve_binary(&pager.bin) {\n+            Ok(path) => path,\n+            Err(_) => {\n+                return Ok(OutputType::stdout());\n+            }\n+        };\n+\n+        let mut p = Command::new(resolved_path);\n         let args = pager.args;\n \n         if pager.kind == PagerKind::Less {\n",
    "diff_parsed": "{'added': [(66, '        let resolved_path = match grep_cli::resolve_binary(&pager.bin) {'), (67, '            Ok(path) => path,'), (68, '            Err(_) => {'), (69, '                return Ok(OutputType::stdout());'), (70, '            }'), (71, '        };'), (73, '        let mut p = Command::new(resolved_path);')], 'deleted': [(66, '        let mut p = Command::new(&pager.bin);')]}",
    "num_lines_added": "7",
    "num_lines_deleted": "1",
    "nloc": "124"
  },
  {
    "file_change_id": "50970978129304",
    "hash": "a34d6e1",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -33,7 +33,7 @@ where\n \n unsafe impl<R> Send for Decoder<R>\n where\n-        R: Read,\n+        R: Read + Send,\n {\n }\n \n",
    "diff_parsed": "{'added': [(36, '        R: Read + Send,')], 'deleted': [(36, '        R: Read,')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "109"
  },
  {
    "file_change_id": "14572481817291",
    "hash": "92f40b4a2c671553dfa96feacff0265206c44ce5",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -377,8 +377,8 @@ where\n     _marker: marker::PhantomData<S>,\n }\n \n-unsafe impl<T, S> Send for Unordered<T, S> where S: Sentinel {}\n-unsafe impl<T, S> Sync for Unordered<T, S> where S: Sentinel {}\n+unsafe impl<T, S> Send for Unordered<T, S> where S: Send + Sentinel {}\n+unsafe impl<T, S> Sync for Unordered<T, S> where S: Sync + Sentinel {}\n \n impl<T, S> Unpin for Unordered<T, S> where S: Sentinel {}\n \n",
    "diff_parsed": "{'added': [(380, 'unsafe impl<T, S> Send for Unordered<T, S> where S: Send + Sentinel {}'), (381, 'unsafe impl<T, S> Sync for Unordered<T, S> where S: Sync + Sentinel {}')], 'deleted': [(380, 'unsafe impl<T, S> Send for Unordered<T, S> where S: Sentinel {}'), (381, 'unsafe impl<T, S> Sync for Unordered<T, S> where S: Sentinel {}')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "419"
  },
  {
    "file_change_id": "73221939388068",
    "hash": "92f40b4a2c671553dfa96feacff0265206c44ce5",
    "old_path": "src/pin_slab.rs",
    "new_path": "src/pin_slab.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -40,8 +40,8 @@ pub struct PinSlab<T> {\n     next: usize,\n }\n \n-unsafe impl<T> Send for PinSlab<T> {}\n-unsafe impl<T> Sync for PinSlab<T> {}\n+unsafe impl<T> Send for PinSlab<T> where T: Send {}\n+unsafe impl<T> Sync for PinSlab<T> where T: Sync {}\n \n enum Entry<T> {\n     // Each slot is pre-allocated with entries of `None`.\n",
    "diff_parsed": "{'added': [(43, 'unsafe impl<T> Send for PinSlab<T> where T: Send {}'), (44, 'unsafe impl<T> Sync for PinSlab<T> where T: Sync {}')], 'deleted': [(43, 'unsafe impl<T> Send for PinSlab<T> {}'), (44, 'unsafe impl<T> Sync for PinSlab<T> {}')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "207"
  },
  {
    "file_change_id": "116375983580527",
    "hash": "b0d2bd20eb40b9cbc2958b981ba2dcd9e6f9396e",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -81,8 +81,10 @@ pub struct Singleton<T: 'static> {\n \n // The Singleton need to implement Send & Sync to ensure cross core compile check mechanics\n // this is safe as the inner RWLock ensures cross core safety\n-unsafe impl<T> Sync for Singleton<T> {}\n-unsafe impl<T> Send for Singleton<T> {}\n+// but we need to be conditional on the inner type to prevent interior mutable types beeing used\n+// inside a singleton\n+unsafe impl<T> Sync for Singleton<T> where T: Sync {}\n+unsafe impl<T> Send for Singleton<T> where T: Send {}\n \n impl<T: 'static> Singleton<T> {\n     /// Create a new [Singleton] instance to be used in a static variable. Only ``const fn`` constructors are allowed\n",
    "diff_parsed": "{'added': [(86, 'unsafe impl<T> Sync for Singleton<T> where T: Sync {}'), (87, 'unsafe impl<T> Send for Singleton<T> where T: Send {}')], 'deleted': [(84, 'unsafe impl<T> Sync for Singleton<T> {}'), (85, 'unsafe impl<T> Send for Singleton<T> {}')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "51"
  },
  {
    "file_change_id": "46113973317980",
    "hash": "0a1da873ddb29bca926bad8301f8d7ab8aa97c52",
    "old_path": "src/config.rs",
    "new_path": "src/config.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -130,13 +130,13 @@ impl From<ExpanderConfig> for u8 {\n ///     .unwrap();\n /// ```\n #[must_use = \"Configuration changes are not applied unless committed\"]\n-pub struct Configurator<'e, EI: ExpanderInterface> {\n+pub struct Configurator<'e, EI: ExpanderInterface + Send> {\n     expander: &'e mut Expander<EI>,\n     expander_config_dirty: bool,\n     banks: [BankConfig; 7],\n }\n \n-impl<'e, EI: ExpanderInterface> Configurator<'e, EI> {\n+impl<'e, EI: ExpanderInterface + Send> Configurator<'e, EI> {\n     pub(crate) fn new(expander: &'e mut Expander<EI>) -> Self {\n         Self {\n             expander,\n",
    "diff_parsed": "{'added': [(133, \"pub struct Configurator<'e, EI: ExpanderInterface + Send> {\"), (139, \"impl<'e, EI: ExpanderInterface + Send> Configurator<'e, EI> {\")], 'deleted': [(133, \"pub struct Configurator<'e, EI: ExpanderInterface> {\"), (139, \"impl<'e, EI: ExpanderInterface> Configurator<'e, EI> {\")]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "237"
  },
  {
    "file_change_id": "194194989623038",
    "hash": "0a1da873ddb29bca926bad8301f8d7ab8aa97c52",
    "old_path": "src/expander/immediate.rs",
    "new_path": "src/expander/immediate.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -14,23 +14,12 @@ use registers::valid_port;\n pub struct ImmediateIO<M, EI>(M, PhantomData<EI>)\n where\n     M: IOMutex<Expander<EI>>,\n-    EI: ExpanderInterface;\n-\n-// Unsafety: This is only needed because the presence of PhantomData<EI> causes the struct to no\n-// longer be Sync, because EI is often not Sync since it owns a global resource (e.g. SPI device).\n-// However, the EI is actually owned by the Expander which is in the mutex which normally\n-// re-instates Sync-ness. PhantomData is there to shut up the unused type parameter error.\n-unsafe impl<M, EI> Sync for ImmediateIO<M, EI>\n-where\n-    M: IOMutex<Expander<EI>>,\n-    EI: ExpanderInterface,\n-{\n-}\n+    EI: ExpanderInterface + Send;\n \n impl<M, EI> ImmediateIO<M, EI>\n where\n     M: IOMutex<Expander<EI>>,\n-    EI: ExpanderInterface,\n+    EI: ExpanderInterface + Send,\n {\n     pub(crate) fn new(expander: Expander<EI>) -> Self {\n         ImmediateIO(M::new(expander), PhantomData)\n@@ -54,7 +43,7 @@ where\n impl<M, EI> ExpanderIO for ImmediateIO<M, EI>\n where\n     M: IOMutex<Expander<EI>>,\n-    EI: ExpanderInterface,\n+    EI: ExpanderInterface + Send,\n {\n     fn write_port(&self, port: u8, bit: bool) {\n         self.0.lock(|ex| ex.write_port(port, bit).unwrap())\n",
    "diff_parsed": "{'added': [(17, '    EI: ExpanderInterface + Send;'), (22, '    EI: ExpanderInterface + Send,'), (46, '    EI: ExpanderInterface + Send,')], 'deleted': [(17, '    EI: ExpanderInterface;'), (23, 'unsafe impl<M, EI> Sync for ImmediateIO<M, EI>'), (24, 'where'), (25, '    M: IOMutex<Expander<EI>>,'), (26, '    EI: ExpanderInterface,'), (27, '{'), (28, '}'), (33, '    EI: ExpanderInterface,'), (57, '    EI: ExpanderInterface,')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "9",
    "nloc": "73"
  },
  {
    "file_change_id": "237280844019781",
    "hash": "0a1da873ddb29bca926bad8301f8d7ab8aa97c52",
    "old_path": "src/expander/mod.rs",
    "new_path": "src/expander/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -18,7 +18,7 @@ pub struct Expander<EI: ExpanderInterface> {\n     pub(crate) config: ExpanderConfig,\n }\n \n-impl<EI: ExpanderInterface> Expander<EI> {\n+impl<EI: ExpanderInterface + Send> Expander<EI> {\n     /// Create a new `Expander`.\n     ///\n     /// Takes ownership of the `ExpanderInterface` which it should use to communicate with the\n",
    "diff_parsed": "{'added': [(21, 'impl<EI: ExpanderInterface + Send> Expander<EI> {')], 'deleted': [(21, 'impl<EI: ExpanderInterface> Expander<EI> {')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "239"
  },
  {
    "file_change_id": "259531154026438",
    "hash": "0a1da873ddb29bca926bad8301f8d7ab8aa97c52",
    "old_path": "src/expander/transactional.rs",
    "new_path": "src/expander/transactional.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -48,7 +48,7 @@ pub enum Strategy {\n pub struct TransactionalIO<M, EI>\n where\n     M: IOMutex<Expander<EI>>,\n-    EI: ExpanderInterface,\n+    EI: ExpanderInterface + Send,\n {\n     expander: M,\n     issued: AtomicUsize,\n@@ -58,21 +58,10 @@ where\n     _ei: PhantomData<EI>,\n }\n \n-// NOTE(unsafe): This is only needed because the presence of PhantomData<EI> causes the struct to\n-// no longer be Sync, because EI is often not Sync since it owns a global resource (e.g. SPI\n-// device).  However, the EI is actually owned by the Expander which is in the mutex which normally\n-// re-instates Sync-ness. PhantomData is there to shut up the unused type parameter error.\n-unsafe impl<M, EI> Sync for TransactionalIO<M, EI>\n-where\n-    M: IOMutex<Expander<EI>>,\n-    EI: ExpanderInterface,\n-{\n-}\n-\n impl<M, EI> TransactionalIO<M, EI>\n where\n     M: IOMutex<Expander<EI>>,\n-    EI: ExpanderInterface,\n+    EI: ExpanderInterface + Send,\n {\n     pub(crate) fn new(expander: Expander<EI>) -> Self {\n         TransactionalIO {\n@@ -160,7 +149,7 @@ where\n impl<M, EI> ExpanderIO for TransactionalIO<M, EI>\n where\n     M: IOMutex<Expander<EI>>,\n-    EI: ExpanderInterface,\n+    EI: ExpanderInterface + Send,\n {\n     fn write_port(&self, port: u8, bit: bool) {\n         let or_bit = 1 << port;\n",
    "diff_parsed": "{'added': [(51, '    EI: ExpanderInterface + Send,'), (64, '    EI: ExpanderInterface + Send,'), (152, '    EI: ExpanderInterface + Send,')], 'deleted': [(51, '    EI: ExpanderInterface,'), (65, 'unsafe impl<M, EI> Sync for TransactionalIO<M, EI>'), (66, 'where'), (67, '    M: IOMutex<Expander<EI>>,'), (68, '    EI: ExpanderInterface,'), (69, '{'), (70, '}'), (75, '    EI: ExpanderInterface,'), (163, '    EI: ExpanderInterface,')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "9",
    "nloc": "375"
  },
  {
    "file_change_id": "137778134136830",
    "hash": "0a1da873ddb29bca926bad8301f8d7ab8aa97c52",
    "old_path": "src/interface.rs",
    "new_path": "src/interface.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -121,9 +121,8 @@ pub(crate) mod test_spy {\n \n     use super::ExpanderInterface;\n     use registers::RegisterAddress;\n-    use std::cell::RefCell;\n     use std::fmt;\n-    use std::rc::Rc;\n+    use std::sync::{Arc, Mutex};\n \n     #[derive(Clone, Copy, Debug, PartialEq)]\n     pub enum TestRegister {\n@@ -134,15 +133,15 @@ pub(crate) mod test_spy {\n     }\n \n     pub struct TestSpyInterface {\n-        registers: Rc<RefCell<Vec<TestRegister>>>,\n-        reads: Rc<RefCell<Vec<u8>>>,\n+        registers: Arc<Mutex<Vec<TestRegister>>>,\n+        reads: Arc<Mutex<Vec<u8>>>,\n     }\n \n     impl TestSpyInterface {\n         pub fn new() -> Self {\n             let mut new = Self {\n-                registers: Rc::new(RefCell::new(Vec::new())),\n-                reads: Rc::new(RefCell::new(Vec::new())),\n+                registers: Arc::new(Mutex::new(Vec::new())),\n+                reads: Arc::new(Mutex::new(Vec::new())),\n             };\n             new.reset();\n             new\n@@ -151,8 +150,8 @@ pub(crate) mod test_spy {\n         pub fn reset(&mut self) {\n             use self::TestRegister::*;\n \n-            self.reads.borrow_mut().clear();\n-            let mut regs = self.registers.borrow_mut();\n+            self.reads.lock().unwrap().clear();\n+            let mut regs = self.registers.lock().unwrap();\n             regs.clear();\n             regs.resize(0x60, Forbidden);\n \n@@ -179,21 +178,21 @@ pub(crate) mod test_spy {\n         }\n \n         pub fn get(&self, addr: u8) -> TestRegister {\n-            self.registers.borrow()[addr as usize]\n+            self.registers.lock().unwrap()[addr as usize]\n         }\n \n         pub fn set(&mut self, addr: u8, val: TestRegister) {\n-            self.registers.borrow_mut()[addr as usize] = val;\n+            self.registers.lock().unwrap()[addr as usize] = val;\n         }\n \n         pub fn reads(&self) -> Vec<u8> {\n-            self.reads.borrow().clone()\n+            self.reads.lock().unwrap().clone()\n         }\n     }\n \n     impl ExpanderInterface for TestSpyInterface {\n         fn write_register(&mut self, addr: RegisterAddress, value: u8) -> Result<(), ()> {\n-            let mut regs = self.registers.borrow_mut();\n+            let mut regs = self.registers.lock().unwrap();\n             let enc_addr = u8::from(addr);\n             assert!(enc_addr <= 0x5F);\n             match regs[enc_addr as usize] {\n@@ -204,8 +203,8 @@ pub(crate) mod test_spy {\n             Ok(())\n         }\n         fn read_register(&mut self, addr: RegisterAddress) -> Result<u8, ()> {\n-            self.reads.borrow_mut().push(addr.into());\n-            let regs = self.registers.borrow();\n+            self.reads.lock().unwrap().push(addr.into());\n+            let regs = self.registers.lock().unwrap();\n             let enc_addr = u8::from(addr);\n             assert!(enc_addr <= 0x5F);\n             match regs[enc_addr as usize] {\n@@ -240,14 +239,14 @@ pub(crate) mod test_spy {\n     }\n \n     pub struct SemanticTestSpyInterface {\n-        ports: Rc<RefCell<Vec<TestPort>>>,\n+        ports: Arc<Mutex<Vec<TestPort>>>,\n     }\n \n     impl SemanticTestSpyInterface {\n         pub fn new(init: Vec<bool>) -> Self {\n             assert!(init.len() == 32 - 4);\n             Self {\n-                ports: Rc::new(RefCell::new(\n+                ports: Arc::new(Mutex::new(\n                     init.into_iter()\n                         .map(|b| TestPort::Reset(b))\n                         .collect::<Vec<_>>(),\n@@ -264,7 +263,8 @@ pub(crate) mod test_spy {\n         pub fn peek_all(&self) -> Vec<TestPort> {\n             use self::TestPort::*;\n             self.ports\n-                .borrow()\n+                .lock()\n+                .unwrap()\n                 .iter()\n                 .cloned()\n                 .map(|v| match v {\n@@ -277,7 +277,8 @@ pub(crate) mod test_spy {\n         pub fn peek_bits(&self) -> Vec<bool> {\n             use self::TestPort::*;\n             self.ports\n-                .borrow()\n+                .lock()\n+                .unwrap()\n                 .iter()\n                 .cloned()\n                 .map(|v| match v {\n@@ -289,7 +290,7 @@ pub(crate) mod test_spy {\n         fn write_port(&self, port: u8, bit: bool) {\n             use self::TestPort::*;\n             let idx = port as usize - 4;\n-            let slot_ref = &mut self.ports.borrow_mut()[idx];\n+            let slot_ref = &mut self.ports.lock().unwrap()[idx];\n             *slot_ref = match slot_ref {\n                 Reset(_) | BlindWrite(_) => BlindWrite(bit),\n                 Read(_) | ReadWrite(_) => ReadWrite(bit),\n@@ -299,7 +300,7 @@ pub(crate) mod test_spy {\n         fn read_port(&self, port: u8) -> bool {\n             use self::TestPort::*;\n             let idx = port as usize - 4;\n-            let slot_ref = &mut self.ports.borrow_mut()[idx];\n+            let slot_ref = &mut self.ports.lock().unwrap()[idx];\n             let (upd, ret) = match slot_ref {\n                 Reset(b) | Read(b) => (Read(*b), *b),\n                 ReadWrite(b) => (ReadWrite(*b), *b),\n@@ -316,7 +317,8 @@ pub(crate) mod test_spy {\n                 f,\n                 \"[ {} ]\",\n                 self.ports\n-                    .borrow()\n+                    .lock()\n+                    .unwrap()\n                     .iter()\n                     .map(|&v| format!(\"{:?}\", v))\n                     .collect::<Vec<_>>()\n",
    "diff_parsed": "{'added': [(125, '    use std::sync::{Arc, Mutex};'), (136, '        registers: Arc<Mutex<Vec<TestRegister>>>,'), (137, '        reads: Arc<Mutex<Vec<u8>>>,'), (143, '                registers: Arc::new(Mutex::new(Vec::new())),'), (144, '                reads: Arc::new(Mutex::new(Vec::new())),'), (153, '            self.reads.lock().unwrap().clear();'), (154, '            let mut regs = self.registers.lock().unwrap();'), (181, '            self.registers.lock().unwrap()[addr as usize]'), (185, '            self.registers.lock().unwrap()[addr as usize] = val;'), (189, '            self.reads.lock().unwrap().clone()'), (195, '            let mut regs = self.registers.lock().unwrap();'), (206, '            self.reads.lock().unwrap().push(addr.into());'), (207, '            let regs = self.registers.lock().unwrap();'), (242, '        ports: Arc<Mutex<Vec<TestPort>>>,'), (249, '                ports: Arc::new(Mutex::new('), (266, '                .lock()'), (267, '                .unwrap()'), (280, '                .lock()'), (281, '                .unwrap()'), (293, '            let slot_ref = &mut self.ports.lock().unwrap()[idx];'), (303, '            let slot_ref = &mut self.ports.lock().unwrap()[idx];'), (320, '                    .lock()'), (321, '                    .unwrap()')], 'deleted': [(124, '    use std::cell::RefCell;'), (126, '    use std::rc::Rc;'), (137, '        registers: Rc<RefCell<Vec<TestRegister>>>,'), (138, '        reads: Rc<RefCell<Vec<u8>>>,'), (144, '                registers: Rc::new(RefCell::new(Vec::new())),'), (145, '                reads: Rc::new(RefCell::new(Vec::new())),'), (154, '            self.reads.borrow_mut().clear();'), (155, '            let mut regs = self.registers.borrow_mut();'), (182, '            self.registers.borrow()[addr as usize]'), (186, '            self.registers.borrow_mut()[addr as usize] = val;'), (190, '            self.reads.borrow().clone()'), (196, '            let mut regs = self.registers.borrow_mut();'), (207, '            self.reads.borrow_mut().push(addr.into());'), (208, '            let regs = self.registers.borrow();'), (243, '        ports: Rc<RefCell<Vec<TestPort>>>,'), (250, '                ports: Rc::new(RefCell::new('), (267, '                .borrow()'), (280, '                .borrow()'), (292, '            let slot_ref = &mut self.ports.borrow_mut()[idx];'), (302, '            let slot_ref = &mut self.ports.borrow_mut()[idx];'), (319, '                    .borrow()')]}",
    "num_lines_added": "23",
    "num_lines_deleted": "21",
    "nloc": "312"
  },
  {
    "file_change_id": "138733568062557",
    "hash": "2820cf12f2e08645fd6d1f15b4a90a54d6082a81",
    "old_path": "src/keyed.rs",
    "new_path": "src/keyed.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -14,7 +14,7 @@ use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::marker::PhantomData;\n use std::mem::size_of;\n \n-use misc::{Flatten, LinearBuckets, SerializationFormat, vec_resize, vec_with_size};\n+use misc::{Flatten, LinearBuckets, SerializationFormat, vec_with_size};\n use task::{BackEnd, Op, KeyedRawStorage};\n use service::{Service, PrivateAccess};\n use indexing::*;\n@@ -448,12 +448,12 @@ impl KeyedRawStorage for KeyedEnumStorage {\n         match self.values.entry(key) {\n             Occupied(mut e) => {\n                 let mut vec = e.get_mut();\n-                vec_resize(&mut vec, value as usize + 1, 0);\n+                vec.resize(value as usize + 1, 0);\n                 vec[value as usize] += 1;\n             }\n             Vacant(e) => {\n                 let mut vec = Vec::new();\n-                vec_resize(&mut vec, value as usize + 1, 0);\n+                vec.resize(value as usize + 1, 0);\n                 vec[value as usize] = 1;\n                 e.insert(vec);\n             }\n",
    "diff_parsed": "{'added': [(17, 'use misc::{Flatten, LinearBuckets, SerializationFormat, vec_with_size};'), (451, '                vec.resize(value as usize + 1, 0);'), (456, '                vec.resize(value as usize + 1, 0);')], 'deleted': [(17, 'use misc::{Flatten, LinearBuckets, SerializationFormat, vec_resize, vec_with_size};'), (451, '                vec_resize(&mut vec, value as usize + 1, 0);'), (456, '                vec_resize(&mut vec, value as usize + 1, 0);')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "3",
    "nloc": "284"
  },
  {
    "file_change_id": "271533125439235",
    "hash": "2820cf12f2e08645fd6d1f15b4a90a54d6082a81",
    "old_path": "src/misc.rs",
    "new_path": "src/misc.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -108,44 +108,10 @@ impl LinearBuckets {\n     }\n }\n \n-/// Partial reimplementation of `Vec::resize`, until this method has\n-/// reached the stable version of Rust.\n-pub fn vec_resize<T>(vec: &mut Vec<T>, min_len: usize, value: T)\n-    where T: Clone\n-{\n-    let len = vec.len();\n-    if min_len <= len {\n-        return;\n-    }\n-    let delta = min_len - len;\n-    vec.reserve(delta);\n-    unsafe {\n-        let mut ptr = vec.as_mut_ptr().offset(len as isize);\n-        // Write all elements except the last one\n-        for i in 1..delta {\n-            ptr::write(ptr, value.clone());\n-            ptr = ptr.offset(1);\n-            // Increment the length in every step in case clone() panics\n-            vec.set_len(len + i);\n-        }\n-\n-        // We can write the last element directly without cloning needlessly\n-        ptr::write(ptr, value);\n-        vec.set_len(len + delta);\n-    }\n-}\n-\n pub fn vec_with_size<T>(size: usize, value: T) -> Vec<T>\n     where T: Clone\n {\n     let mut vec = Vec::with_capacity(size);\n-    unsafe {\n-        // Resize. In future versions of Rust, we should\n-        // be able to use `vec.resize`.\n-        vec.set_len(size);\n-        for i in 0 .. size {\n-            vec[i] = value.clone();\n-        }\n-    }\n+    vec.resize(size, value);\n     vec\n }\n",
    "diff_parsed": "{'added': [(115, '    vec.resize(size, value);')], 'deleted': [(113, 'pub fn vec_resize<T>(vec: &mut Vec<T>, min_len: usize, value: T)'), (114, '    where T: Clone'), (115, '{'), (116, '    let len = vec.len();'), (117, '    if min_len <= len {'), (118, '        return;'), (119, '    }'), (120, '    let delta = min_len - len;'), (121, '    vec.reserve(delta);'), (122, '    unsafe {'), (123, '        let mut ptr = vec.as_mut_ptr().offset(len as isize);'), (125, '        for i in 1..delta {'), (126, '            ptr::write(ptr, value.clone());'), (127, '            ptr = ptr.offset(1);'), (129, '            vec.set_len(len + i);'), (130, '        }'), (133, '        ptr::write(ptr, value);'), (134, '        vec.set_len(len + delta);'), (135, '    }'), (136, '}'), (142, '    unsafe {'), (145, '        vec.set_len(size);'), (146, '        for i in 0 .. size {'), (147, '            vec[i] = value.clone();'), (148, '        }'), (149, '    }')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "26",
    "nloc": "70"
  },
  {
    "file_change_id": "182534044665746",
    "hash": "2820cf12f2e08645fd6d1f15b4a90a54d6082a81",
    "old_path": "src/plain.rs",
    "new_path": "src/plain.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -13,7 +13,7 @@ use std::marker::PhantomData;\n use std::mem::size_of;\n use std::sync::atomic::{AtomicBool, Ordering};\n \n-use misc::{Flatten, LinearBuckets, SerializationFormat, vec_resize, vec_with_size};\n+use misc::{Flatten, LinearBuckets, SerializationFormat, vec_with_size};\n use task::{BackEnd, Op, PlainRawStorage};\n use service::{Service, PrivateAccess};\n use indexing::*;\n@@ -409,7 +409,7 @@ struct EnumStorage {\n \n impl PlainRawStorage for EnumStorage {\n     fn store(&mut self, value: u32) {\n-        vec_resize(&mut self.values, value as usize + 1, 0);\n+        self.values.resize(value as usize + 1, 0);\n         self.values[value as usize] += 1;\n     }\n     fn to_json(&self, format: &SerializationFormat) -> Json {\n",
    "diff_parsed": "{'added': [(16, 'use misc::{Flatten, LinearBuckets, SerializationFormat, vec_with_size};'), (412, '        self.values.resize(value as usize + 1, 0);')], 'deleted': [(16, 'use misc::{Flatten, LinearBuckets, SerializationFormat, vec_resize, vec_with_size};'), (412, '        vec_resize(&mut self.values, value as usize + 1, 0);')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "230"
  },
  {
    "file_change_id": "263761662823596",
    "hash": "71b2f5187b0cbace3f8b6ff53432ff2ca0defcf0",
    "old_path": "src/functions.rs",
    "new_path": "src/functions.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -67,6 +67,7 @@\n //!     Ok(())\n //! }\n //! ```\n+use std::any::TypeId;\n use std::os::raw::{c_int, c_void};\n use std::panic::{catch_unwind, RefUnwindSafe, UnwindSafe};\n use std::ptr;\n@@ -177,13 +178,16 @@ impl Context<'_> {\n     /// https://www.sqlite.org/c3ref/get_auxdata.html for a discussion of\n     /// this feature, or the unit tests of this module for an example.\n     pub fn set_aux<T: 'static>(&self, arg: c_int, value: T) {\n-        let boxed = Box::into_raw(Box::new((std::any::TypeId::of::<T>(), value)));\n+        let boxed = Box::into_raw(Box::new(AuxData {\n+            id: TypeId::of::<T>(),\n+            value,\n+        }));\n         unsafe {\n             ffi::sqlite3_set_auxdata(\n                 self.ctx,\n                 arg,\n                 boxed as *mut c_void,\n-                Some(free_boxed_value::<(std::any::TypeId, T)>),\n+                Some(free_boxed_value::<AuxData<T>>),\n             )\n         };\n     }\n@@ -192,20 +196,26 @@ impl Context<'_> {\n     /// via `set_aux`. Returns `Ok(None)` if no data has been associated,\n     /// and .\n     pub fn get_aux<T: 'static>(&self, arg: c_int) -> Result<Option<&T>> {\n-        let p = unsafe { ffi::sqlite3_get_auxdata(self.ctx, arg) as *mut (std::any::TypeId, T) };\n+        let p = unsafe { ffi::sqlite3_get_auxdata(self.ctx, arg) as *const AuxData<T> };\n         if p.is_null() {\n             Ok(None)\n         } else {\n-            let id_val = unsafe { &*p };\n-            if std::any::TypeId::of::<T>() != id_val.0 {\n+            let id = unsafe { (*p).id };\n+            if TypeId::of::<T>() != id {\n                 Err(Error::GetAuxWrongType)\n             } else {\n-                Ok(Some(&id_val.1))\n+                Ok(Some(unsafe { &(*p).value }))\n             }\n         }\n     }\n }\n \n+#[repr(C)]\n+struct AuxData<T: 'static> {\n+    id: TypeId,\n+    value: T,\n+}\n+\n /// `feature = \"functions\"` Aggregate is the callback interface for user-defined\n /// aggregate function.\n ///\n",
    "diff_parsed": "{'added': [(70, 'use std::any::TypeId;'), (181, '        let boxed = Box::into_raw(Box::new(AuxData {'), (182, '            id: TypeId::of::<T>(),'), (183, '            value,'), (184, '        }));'), (190, '                Some(free_boxed_value::<AuxData<T>>),'), (199, '        let p = unsafe { ffi::sqlite3_get_auxdata(self.ctx, arg) as *const AuxData<T> };'), (203, '            let id = unsafe { (*p).id };'), (204, '            if TypeId::of::<T>() != id {'), (207, '                Ok(Some(unsafe { &(*p).value }))'), (213, '#[repr(C)]'), (214, \"struct AuxData<T: 'static> {\"), (215, '    id: TypeId,'), (216, '    value: T,'), (217, '}')], 'deleted': [(180, '        let boxed = Box::into_raw(Box::new((std::any::TypeId::of::<T>(), value)));'), (186, '                Some(free_boxed_value::<(std::any::TypeId, T)>),'), (195, '        let p = unsafe { ffi::sqlite3_get_auxdata(self.ctx, arg) as *mut (std::any::TypeId, T) };'), (199, '            let id_val = unsafe { &*p };'), (200, '            if std::any::TypeId::of::<T>() != id_val.0 {'), (203, '                Ok(Some(&id_val.1))')]}",
    "num_lines_added": "15",
    "num_lines_deleted": "6",
    "nloc": "904"
  },
  {
    "file_change_id": "258744445778315",
    "hash": "d2ce1ac753afc059e32798bac3383b81a6d04456",
    "old_path": "cranelift/wasm/src/environ/dummy.rs",
    "new_path": "cranelift/wasm/src/environ/dummy.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -688,8 +688,8 @@ impl<'data> ModuleEnvironment<'data> for DummyEnvironment {\n                 WasmType::FuncRef | WasmType::ExternRef | WasmType::ExnRef => reference_type,\n             })\n         };\n-        sig.params.extend(wasm.params.iter().map(&mut cvt));\n-        sig.returns.extend(wasm.returns.iter().map(&mut cvt));\n+        sig.params.extend(wasm.params().iter().map(&mut cvt));\n+        sig.returns.extend(wasm.returns().iter().map(&mut cvt));\n         self.info.signatures.push(sig);\n         Ok(())\n     }\n",
    "diff_parsed": "{'added': [(691, '        sig.params.extend(wasm.params().iter().map(&mut cvt));'), (692, '        sig.returns.extend(wasm.returns().iter().map(&mut cvt));')], 'deleted': [(691, '        sig.params.extend(wasm.params.iter().map(&mut cvt));'), (692, '        sig.returns.extend(wasm.returns.iter().map(&mut cvt));')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "762"
  },
  {
    "file_change_id": "77074324209346",
    "hash": "d2ce1ac753afc059e32798bac3383b81a6d04456",
    "old_path": "crates/cranelift/src/compiler.rs",
    "new_path": "crates/cranelift/src/compiler.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -465,7 +465,7 @@ impl Compiler {\n \n         // Compute the size of the values vector. The vmctx and caller vmctx are passed separately.\n         let value_size = mem::size_of::<u128>();\n-        let values_vec_len = (value_size * cmp::max(ty.params.len(), ty.returns.len())) as u32;\n+        let values_vec_len = (value_size * cmp::max(ty.params().len(), ty.returns().len())) as u32;\n \n         let mut context = Context::new();\n         context.func =\n@@ -486,7 +486,7 @@ impl Compiler {\n \n         let values_vec_ptr_val = builder.ins().stack_addr(pointer_type, ss, 0);\n         let mflags = MemFlags::trusted();\n-        for i in 0..ty.params.len() {\n+        for i in 0..ty.params().len() {\n             let val = builder.func.dfg.block_params(block0)[i + 2];\n             builder\n                 .ins()\n@@ -508,7 +508,7 @@ impl Compiler {\n \n         let mflags = MemFlags::trusted();\n         let mut results = Vec::new();\n-        for (i, r) in ty.returns.iter().enumerate() {\n+        for (i, r) in ty.returns().iter().enumerate() {\n             let load = builder.ins().load(\n                 value_type(isa, *r),\n                 mflags,\n",
    "diff_parsed": "{'added': [(468, '        let values_vec_len = (value_size * cmp::max(ty.params().len(), ty.returns().len())) as u32;'), (489, '        for i in 0..ty.params().len() {'), (511, '        for (i, r) in ty.returns().iter().enumerate() {')], 'deleted': [(468, '        let values_vec_len = (value_size * cmp::max(ty.params.len(), ty.returns.len())) as u32;'), (489, '        for i in 0..ty.params.len() {'), (511, '        for (i, r) in ty.returns.iter().enumerate() {')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "3",
    "nloc": "715"
  },
  {
    "file_change_id": "266704844732564",
    "hash": "d2ce1ac753afc059e32798bac3383b81a6d04456",
    "old_path": "crates/cranelift/src/lib.rs",
    "new_path": "crates/cranelift/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -220,8 +220,8 @@ fn wasmtime_call_conv(isa: &dyn TargetIsa) -> CallConv {\n /// above.\n fn push_types(isa: &dyn TargetIsa, sig: &mut ir::Signature, wasm: &WasmFuncType) {\n     let cvt = |ty: &WasmType| ir::AbiParam::new(value_type(isa, *ty));\n-    sig.params.extend(wasm.params.iter().map(&cvt));\n-    sig.returns.extend(wasm.returns.iter().map(&cvt));\n+    sig.params.extend(wasm.params().iter().map(&cvt));\n+    sig.returns.extend(wasm.returns().iter().map(&cvt));\n }\n \n /// Returns the corresponding cranelift type for the provided wasm type.\n",
    "diff_parsed": "{'added': [(223, '    sig.params.extend(wasm.params().iter().map(&cvt));'), (224, '    sig.returns.extend(wasm.returns().iter().map(&cvt));')], 'deleted': [(223, '    sig.params.extend(wasm.params.iter().map(&cvt));'), (224, '    sig.returns.extend(wasm.returns.iter().map(&cvt));')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "117"
  },
  {
    "file_change_id": "104201891098682",
    "hash": "d2ce1ac753afc059e32798bac3383b81a6d04456",
    "old_path": "crates/environ/src/module_environ.rs",
    "new_path": "crates/environ/src/module_environ.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -608,7 +608,7 @@ impl<'data> ModuleEnvironment<'data> {\n                         .funcs\n                         .push(FunctionMetadata {\n                             locals: locals.into_boxed_slice(),\n-                            params: sig.params.iter().cloned().map(|i| i.into()).collect(),\n+                            params: sig.params().iter().cloned().map(|i| i.into()).collect(),\n                         });\n                 }\n                 body.allow_memarg64(self.features.memory64);\n",
    "diff_parsed": "{'added': [(611, '                            params: sig.params().iter().cloned().map(|i| i.into()).collect(),')], 'deleted': [(611, '                            params: sig.params.iter().cloned().map(|i| i.into()).collect(),')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "1059"
  },
  {
    "file_change_id": "224845469763451",
    "hash": "d2ce1ac753afc059e32798bac3383b81a6d04456",
    "old_path": "crates/fuzzing/src/generators/table_ops.rs",
    "new_path": "crates/fuzzing/src/generators/table_ops.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -18,7 +18,7 @@ pub struct TableOps {\n \n const NUM_PARAMS_RANGE: Range<u8> = 1..10;\n const TABLE_SIZE_RANGE: Range<u32> = 1..100;\n-const MAX_OPS: usize = 1000;\n+const MAX_OPS: usize = 100;\n \n impl TableOps {\n     /// Get the number of parameters this module's \"run\" function takes.\n@@ -49,9 +49,46 @@ impl TableOps {\n     pub fn to_wasm_binary(&self) -> Vec<u8> {\n         let mut module = Module::new();\n \n+        // Encode the types for all functions that we are using.\n+        let mut types = TypeSection::new();\n+\n+        // 0: \"gc\"\n+        types.function(\n+            vec![],\n+            // Return a bunch of stuff from `gc` so that we exercise GCing when\n+            // there is return pointer space allocated on the stack. This is\n+            // especially important because the x64 backend currently\n+            // dynamically adjusts the stack pointer for each call that uses\n+            // return pointers rather than statically allocating space in the\n+            // stack frame.\n+            vec![ValType::ExternRef, ValType::ExternRef, ValType::ExternRef],\n+        );\n+\n+        // 1: \"run\"\n+        let mut params: Vec<ValType> = Vec::with_capacity(self.num_params() as usize);\n+        for _i in 0..self.num_params() {\n+            params.push(ValType::ExternRef);\n+        }\n+        let results = vec![];\n+        types.function(params, results);\n+\n+        // 2: `take_refs`\n+        types.function(\n+            vec![ValType::ExternRef, ValType::ExternRef, ValType::ExternRef],\n+            vec![],\n+        );\n+\n+        // 3: `make_refs`\n+        types.function(\n+            vec![],\n+            vec![ValType::ExternRef, ValType::ExternRef, ValType::ExternRef],\n+        );\n+\n         // Import the GC function.\n         let mut imports = ImportSection::new();\n         imports.import(\"\", Some(\"gc\"), EntityType::Function(0));\n+        imports.import(\"\", Some(\"take_refs\"), EntityType::Function(2));\n+        imports.import(\"\", Some(\"make_refs\"), EntityType::Function(3));\n \n         // Define our table.\n         let mut tables = TableSection::new();\n@@ -61,32 +98,24 @@ impl TableOps {\n             maximum: None,\n         });\n \n-        // Encode the types for all functions that we are using.\n-        let mut types = TypeSection::new();\n-        types.function(vec![], vec![]); // 0: \"gc\"\n-        let mut params: Vec<ValType> = Vec::with_capacity(self.num_params() as usize);\n-        for _i in 0..self.num_params() {\n-            params.push(ValType::ExternRef);\n-        }\n-        let results = vec![];\n-        types.function(params, results); // 1: \"run\"\n-\n         // Define the \"run\" function export.\n         let mut functions = FunctionSection::new();\n         functions.function(1);\n \n         let mut exports = ExportSection::new();\n-        exports.export(\"run\", Export::Function(1));\n+        exports.export(\"run\", Export::Function(3));\n \n-        let mut params: Vec<(u32, ValType)> = Vec::with_capacity(self.num_params() as usize);\n-        for _i in 0..self.num_params() {\n-            params.push((0, ValType::ExternRef));\n-        }\n-        let mut func = Function::new(params);\n+        // Give ourselves one scratch local that we can use in various `TableOp`\n+        // implementations.\n+        let mut func = Function::new(vec![(1, ValType::ExternRef)]);\n \n+        func.instruction(Instruction::Loop(wasm_encoder::BlockType::Empty));\n         for op in self.ops.iter().take(MAX_OPS) {\n-            op.insert(&mut func);\n+            op.insert(&mut func, self.num_params() as u32, self.table_size());\n         }\n+        func.instruction(Instruction::Br(0));\n+        func.instruction(Instruction::End);\n+        func.instruction(Instruction::End);\n \n         let mut code = CodeSection::new();\n         code.function(&func);\n@@ -105,7 +134,7 @@ impl TableOps {\n \n #[derive(Arbitrary, Debug)]\n pub(crate) enum TableOp {\n-    // `(call 0)`\n+    // `call $gc; drop; drop; drop;`\n     Gc,\n     // `(drop (table.get x))`\n     Get(i32),\n@@ -113,30 +142,102 @@ pub(crate) enum TableOp {\n     SetFromParam(i32, u32),\n     // `(table.set x (table.get y))`\n     SetFromGet(i32, i32),\n+    // `call $make_refs; table.set x; table.set y; table.set z`\n+    SetFromMake(i32, i32, i32),\n+    // `call $make_refs; drop; drop; drop;`\n+    Make,\n+    // `local.get x; local.get y; local.get z; call $take_refs`\n+    TakeFromParams(u32, u32, u32),\n+    // `table.get x; table.get y; table.get z; call $take_refs`\n+    TakeFromGet(i32, i32, i32),\n+    // `call $make_refs; call $take_refs`\n+    TakeFromMake,\n+    // `call $gc; call $take_refs`\n+    TakeFromGc,\n }\n \n impl TableOp {\n-    fn insert(&self, func: &mut Function) {\n+    fn insert(&self, func: &mut Function, num_params: u32, table_size: u32) {\n+        assert!(num_params > 0);\n+        assert!(table_size > 0);\n+\n+        // Add one to make sure that out of bounds table accesses are possible,\n+        // but still rare.\n+        let table_mod = table_size as i32 + 1;\n+\n         match self {\n             Self::Gc => {\n                 func.instruction(Instruction::Call(0));\n+                func.instruction(Instruction::Drop);\n+                func.instruction(Instruction::Drop);\n+                func.instruction(Instruction::Drop);\n             }\n             Self::Get(x) => {\n-                func.instruction(Instruction::I32Const(*x));\n+                func.instruction(Instruction::I32Const(*x % table_mod));\n                 func.instruction(Instruction::TableGet { table: 0 });\n                 func.instruction(Instruction::Drop);\n             }\n             Self::SetFromParam(x, y) => {\n-                func.instruction(Instruction::I32Const(*x));\n-                func.instruction(Instruction::LocalGet(*y));\n+                func.instruction(Instruction::I32Const(*x % table_mod));\n+                func.instruction(Instruction::LocalGet(*y % num_params));\n                 func.instruction(Instruction::TableSet { table: 0 });\n             }\n             Self::SetFromGet(x, y) => {\n-                func.instruction(Instruction::I32Const(*x));\n-                func.instruction(Instruction::I32Const(*y));\n+                func.instruction(Instruction::I32Const(*x % table_mod));\n+                func.instruction(Instruction::I32Const(*y % table_mod));\n                 func.instruction(Instruction::TableGet { table: 0 });\n                 func.instruction(Instruction::TableSet { table: 0 });\n             }\n+            Self::SetFromMake(x, y, z) => {\n+                func.instruction(Instruction::Call(2));\n+\n+                func.instruction(Instruction::LocalSet(num_params));\n+                func.instruction(Instruction::I32Const(*x % table_mod));\n+                func.instruction(Instruction::LocalGet(num_params));\n+                func.instruction(Instruction::TableSet { table: 0 });\n+\n+                func.instruction(Instruction::LocalSet(num_params));\n+                func.instruction(Instruction::I32Const(*y % table_mod));\n+                func.instruction(Instruction::LocalGet(num_params));\n+                func.instruction(Instruction::TableSet { table: 0 });\n+\n+                func.instruction(Instruction::LocalSet(num_params));\n+                func.instruction(Instruction::I32Const(*z % table_mod));\n+                func.instruction(Instruction::LocalGet(num_params));\n+                func.instruction(Instruction::TableSet { table: 0 });\n+            }\n+            TableOp::Make => {\n+                func.instruction(Instruction::Call(2));\n+                func.instruction(Instruction::Drop);\n+                func.instruction(Instruction::Drop);\n+                func.instruction(Instruction::Drop);\n+            }\n+            TableOp::TakeFromParams(x, y, z) => {\n+                func.instruction(Instruction::LocalGet(x % num_params));\n+                func.instruction(Instruction::LocalGet(y % num_params));\n+                func.instruction(Instruction::LocalGet(z % num_params));\n+                func.instruction(Instruction::Call(1));\n+            }\n+            TableOp::TakeFromGet(x, y, z) => {\n+                func.instruction(Instruction::I32Const(*x % table_mod));\n+                func.instruction(Instruction::TableGet { table: 0 });\n+\n+                func.instruction(Instruction::I32Const(*y % table_mod));\n+                func.instruction(Instruction::TableGet { table: 0 });\n+\n+                func.instruction(Instruction::I32Const(*z % table_mod));\n+                func.instruction(Instruction::TableGet { table: 0 });\n+\n+                func.instruction(Instruction::Call(1));\n+            }\n+            TableOp::TakeFromMake => {\n+                func.instruction(Instruction::Call(2));\n+                func.instruction(Instruction::Call(1));\n+            }\n+            Self::TakeFromGc => {\n+                func.instruction(Instruction::Call(0));\n+                func.instruction(Instruction::Call(1));\n+            }\n         }\n     }\n }\n@@ -148,38 +249,95 @@ mod tests {\n     #[test]\n     fn test_wat_string() {\n         let ops = TableOps {\n-            num_params: 2,\n-            table_size: 10,\n+            num_params: 5,\n+            table_size: 20,\n             ops: vec![\n                 TableOp::Gc,\n                 TableOp::Get(0),\n                 TableOp::SetFromParam(1, 2),\n                 TableOp::SetFromGet(3, 4),\n+                TableOp::SetFromMake(5, 6, 7),\n+                TableOp::Make,\n+                TableOp::TakeFromParams(8, 9, 10),\n+                TableOp::TakeFromGet(11, 12, 13),\n+                TableOp::TakeFromMake,\n             ],\n         };\n \n         let expected = r#\"\n (module\n   (type (;0;) (func))\n-  (type (;1;) (func (param externref externref)))\n+  (type (;1;) (func (param externref externref externref externref externref)))\n+  (type (;2;) (func (param externref externref externref)))\n+  (type (;3;) (func (result externref externref externref)))\n   (import \"\" \"gc\" (func (;0;) (type 0)))\n-  (func (;1;) (type 1) (param externref externref)\n-    call 0\n-    i32.const 0\n-    table.get 0\n-    drop\n-    i32.const 1\n-    local.get 2\n-    table.set 0\n-    i32.const 3\n-    i32.const 4\n-    table.get 0\n-    table.set 0)\n-  (table (;0;) 10 externref)\n-  (export \"run\" (func 1)))\n+  (import \"\" \"take_refs\" (func (;1;) (type 2)))\n+  (import \"\" \"make_refs\" (func (;2;) (type 3)))\n+  (func (;3;) (type 1) (param externref externref externref externref externref)\n+    (local externref i32)\n+    i32.const 100\n+    local.set 6\n+    loop  ;; label = @1\n+      call 0\n+      i32.const 0\n+      table.get 0\n+      drop\n+      i32.const 1\n+      local.get 2\n+      table.set 0\n+      i32.const 3\n+      i32.const 4\n+      table.get 0\n+      table.set 0\n+      call 2\n+      local.set 5\n+      i32.const 5\n+      local.get 5\n+      table.set 0\n+      local.set 5\n+      i32.const 6\n+      local.get 5\n+      table.set 0\n+      local.set 5\n+      i32.const 7\n+      local.get 5\n+      table.set 0\n+      call 2\n+      drop\n+      drop\n+      drop\n+      local.get 3\n+      local.get 4\n+      local.get 0\n+      call 1\n+      i32.const 11\n+      table.get 0\n+      i32.const 12\n+      table.get 0\n+      i32.const 13\n+      table.get 0\n+      call 1\n+      call 2\n+      call 1\n+      local.get 6\n+      i32.const -1\n+      i32.add\n+      local.tee 6\n+      br_if 0 (;@1;)\n+    end)\n+  (table (;0;) 20 externref)\n+  (export \"run\" (func 3)))\n \"#;\n+        eprintln!(\"expected WAT = {}\", expected);\n+\n         let actual = ops.to_wasm_binary();\n+        if let Err(e) = wasmparser::validate(&actual) {\n+            panic!(\"TableOps should generate valid Wasm; got error: {}\", e);\n+        }\n+\n         let actual = wasmprinter::print_bytes(&actual).unwrap();\n+        eprintln!(\"actual WAT = {}\", actual);\n+\n         assert_eq!(actual.trim(), expected.trim());\n     }\n }\n",
    "diff_parsed": "{'added': [(21, 'const MAX_OPS: usize = 100;'), (53, '        let mut types = TypeSection::new();'), (56, '        types.function('), (57, '            vec![],'), (64, '            vec![ValType::ExternRef, ValType::ExternRef, ValType::ExternRef],'), (65, '        );'), (68, '        let mut params: Vec<ValType> = Vec::with_capacity(self.num_params() as usize);'), (69, '        for _i in 0..self.num_params() {'), (70, '            params.push(ValType::ExternRef);'), (71, '        }'), (72, '        let results = vec![];'), (73, '        types.function(params, results);'), (76, '        types.function('), (77, '            vec![ValType::ExternRef, ValType::ExternRef, ValType::ExternRef],'), (78, '            vec![],'), (79, '        );'), (82, '        types.function('), (83, '            vec![],'), (84, '            vec![ValType::ExternRef, ValType::ExternRef, ValType::ExternRef],'), (85, '        );'), (90, '        imports.import(\"\", Some(\"take_refs\"), EntityType::Function(2));'), (91, '        imports.import(\"\", Some(\"make_refs\"), EntityType::Function(3));'), (106, '        exports.export(\"run\", Export::Function(3));'), (110, '        let mut func = Function::new(vec![(1, ValType::ExternRef)]);'), (112, '        func.instruction(Instruction::Loop(wasm_encoder::BlockType::Empty));'), (114, '            op.insert(&mut func, self.num_params() as u32, self.table_size());'), (116, '        func.instruction(Instruction::Br(0));'), (117, '        func.instruction(Instruction::End);'), (118, '        func.instruction(Instruction::End);'), (146, '    SetFromMake(i32, i32, i32),'), (148, '    Make,'), (150, '    TakeFromParams(u32, u32, u32),'), (152, '    TakeFromGet(i32, i32, i32),'), (154, '    TakeFromMake,'), (156, '    TakeFromGc,'), (160, '    fn insert(&self, func: &mut Function, num_params: u32, table_size: u32) {'), (161, '        assert!(num_params > 0);'), (162, '        assert!(table_size > 0);'), (166, '        let table_mod = table_size as i32 + 1;'), (171, '                func.instruction(Instruction::Drop);'), (172, '                func.instruction(Instruction::Drop);'), (173, '                func.instruction(Instruction::Drop);'), (176, '                func.instruction(Instruction::I32Const(*x % table_mod));'), (181, '                func.instruction(Instruction::I32Const(*x % table_mod));'), (182, '                func.instruction(Instruction::LocalGet(*y % num_params));'), (186, '                func.instruction(Instruction::I32Const(*x % table_mod));'), (187, '                func.instruction(Instruction::I32Const(*y % table_mod));'), (191, '            Self::SetFromMake(x, y, z) => {'), (192, '                func.instruction(Instruction::Call(2));'), (194, '                func.instruction(Instruction::LocalSet(num_params));'), (195, '                func.instruction(Instruction::I32Const(*x % table_mod));'), (196, '                func.instruction(Instruction::LocalGet(num_params));'), (197, '                func.instruction(Instruction::TableSet { table: 0 });'), (199, '                func.instruction(Instruction::LocalSet(num_params));'), (200, '                func.instruction(Instruction::I32Const(*y % table_mod));'), (201, '                func.instruction(Instruction::LocalGet(num_params));'), (202, '                func.instruction(Instruction::TableSet { table: 0 });'), (204, '                func.instruction(Instruction::LocalSet(num_params));'), (205, '                func.instruction(Instruction::I32Const(*z % table_mod));'), (206, '                func.instruction(Instruction::LocalGet(num_params));'), (207, '                func.instruction(Instruction::TableSet { table: 0 });'), (208, '            }'), (209, '            TableOp::Make => {'), (210, '                func.instruction(Instruction::Call(2));'), (211, '                func.instruction(Instruction::Drop);'), (212, '                func.instruction(Instruction::Drop);'), (213, '                func.instruction(Instruction::Drop);'), (214, '            }'), (215, '            TableOp::TakeFromParams(x, y, z) => {'), (216, '                func.instruction(Instruction::LocalGet(x % num_params));'), (217, '                func.instruction(Instruction::LocalGet(y % num_params));'), (218, '                func.instruction(Instruction::LocalGet(z % num_params));'), (219, '                func.instruction(Instruction::Call(1));'), (220, '            }'), (221, '            TableOp::TakeFromGet(x, y, z) => {'), (222, '                func.instruction(Instruction::I32Const(*x % table_mod));'), (223, '                func.instruction(Instruction::TableGet { table: 0 });'), (225, '                func.instruction(Instruction::I32Const(*y % table_mod));'), (226, '                func.instruction(Instruction::TableGet { table: 0 });'), (228, '                func.instruction(Instruction::I32Const(*z % table_mod));'), (229, '                func.instruction(Instruction::TableGet { table: 0 });'), (231, '                func.instruction(Instruction::Call(1));'), (232, '            }'), (233, '            TableOp::TakeFromMake => {'), (234, '                func.instruction(Instruction::Call(2));'), (235, '                func.instruction(Instruction::Call(1));'), (236, '            }'), (237, '            Self::TakeFromGc => {'), (238, '                func.instruction(Instruction::Call(0));'), (239, '                func.instruction(Instruction::Call(1));'), (240, '            }'), (252, '            num_params: 5,'), (253, '            table_size: 20,'), (259, '                TableOp::SetFromMake(5, 6, 7),'), (260, '                TableOp::Make,'), (261, '                TableOp::TakeFromParams(8, 9, 10),'), (262, '                TableOp::TakeFromGet(11, 12, 13),'), (263, '                TableOp::TakeFromMake,'), (270, '  (type (;1;) (func (param externref externref externref externref externref)))'), (271, '  (type (;2;) (func (param externref externref externref)))'), (272, '  (type (;3;) (func (result externref externref externref)))'), (274, '  (import \"\" \"take_refs\" (func (;1;) (type 2)))'), (275, '  (import \"\" \"make_refs\" (func (;2;) (type 3)))'), (276, '  (func (;3;) (type 1) (param externref externref externref externref externref)'), (277, '    (local externref i32)'), (278, '    i32.const 100'), (279, '    local.set 6'), (280, '    loop  ;; label = @1'), (281, '      call 0'), (282, '      i32.const 0'), (283, '      table.get 0'), (284, '      drop'), (285, '      i32.const 1'), (286, '      local.get 2'), (287, '      table.set 0'), (288, '      i32.const 3'), (289, '      i32.const 4'), (290, '      table.get 0'), (291, '      table.set 0'), (292, '      call 2'), (293, '      local.set 5'), (294, '      i32.const 5'), (295, '      local.get 5'), (296, '      table.set 0'), (297, '      local.set 5'), (298, '      i32.const 6'), (299, '      local.get 5'), (300, '      table.set 0'), (301, '      local.set 5'), (302, '      i32.const 7'), (303, '      local.get 5'), (304, '      table.set 0'), (305, '      call 2'), (306, '      drop'), (307, '      drop'), (308, '      drop'), (309, '      local.get 3'), (310, '      local.get 4'), (311, '      local.get 0'), (312, '      call 1'), (313, '      i32.const 11'), (314, '      table.get 0'), (315, '      i32.const 12'), (316, '      table.get 0'), (317, '      i32.const 13'), (318, '      table.get 0'), (319, '      call 1'), (320, '      call 2'), (321, '      call 1'), (322, '      local.get 6'), (323, '      i32.const -1'), (324, '      i32.add'), (325, '      local.tee 6'), (326, '      br_if 0 (;@1;)'), (327, '    end)'), (328, '  (table (;0;) 20 externref)'), (329, '  (export \"run\" (func 3)))'), (331, '        eprintln!(\"expected WAT = {}\", expected);'), (334, '        if let Err(e) = wasmparser::validate(&actual) {'), (335, '            panic!(\"TableOps should generate valid Wasm; got error: {}\", e);'), (336, '        }'), (339, '        eprintln!(\"actual WAT = {}\", actual);')], 'deleted': [(21, 'const MAX_OPS: usize = 1000;'), (65, '        let mut types = TypeSection::new();'), (66, '        types.function(vec![], vec![]); // 0: \"gc\"'), (67, '        let mut params: Vec<ValType> = Vec::with_capacity(self.num_params() as usize);'), (68, '        for _i in 0..self.num_params() {'), (69, '            params.push(ValType::ExternRef);'), (70, '        }'), (71, '        let results = vec![];'), (72, '        types.function(params, results); // 1: \"run\"'), (79, '        exports.export(\"run\", Export::Function(1));'), (81, '        let mut params: Vec<(u32, ValType)> = Vec::with_capacity(self.num_params() as usize);'), (82, '        for _i in 0..self.num_params() {'), (83, '            params.push((0, ValType::ExternRef));'), (84, '        }'), (85, '        let mut func = Function::new(params);'), (88, '            op.insert(&mut func);'), (119, '    fn insert(&self, func: &mut Function) {'), (125, '                func.instruction(Instruction::I32Const(*x));'), (130, '                func.instruction(Instruction::I32Const(*x));'), (131, '                func.instruction(Instruction::LocalGet(*y));'), (135, '                func.instruction(Instruction::I32Const(*x));'), (136, '                func.instruction(Instruction::I32Const(*y));'), (151, '            num_params: 2,'), (152, '            table_size: 10,'), (164, '  (type (;1;) (func (param externref externref)))'), (166, '  (func (;1;) (type 1) (param externref externref)'), (167, '    call 0'), (168, '    i32.const 0'), (169, '    table.get 0'), (170, '    drop'), (171, '    i32.const 1'), (172, '    local.get 2'), (173, '    table.set 0'), (174, '    i32.const 3'), (175, '    i32.const 4'), (176, '    table.get 0'), (177, '    table.set 0)'), (178, '  (table (;0;) 10 externref)'), (179, '  (export \"run\" (func 1)))')]}",
    "num_lines_added": "162",
    "num_lines_deleted": "39",
    "nloc": "263"
  },
  {
    "file_change_id": "176630609615521",
    "hash": "d2ce1ac753afc059e32798bac3383b81a6d04456",
    "old_path": "crates/fuzzing/src/oracles.rs",
    "new_path": "crates/fuzzing/src/oracles.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -514,16 +514,17 @@ pub fn table_ops(\n ) {\n     let _ = env_logger::try_init();\n \n+    let expected_drops = Arc::new(AtomicUsize::new(ops.num_params() as usize));\n     let num_dropped = Arc::new(AtomicUsize::new(0));\n \n     {\n         let mut config = fuzz_config.to_wasmtime();\n         config.wasm_reference_types(true);\n+        config.consume_fuel(true);\n+\n         let engine = Engine::new(&config).unwrap();\n         let mut store = create_store(&engine);\n-        if fuzz_config.consume_fuel {\n-            store.add_fuel(u64::max_value()).unwrap();\n-        }\n+        store.add_fuel(100).unwrap();\n \n         let wasm = ops.to_wasm_binary();\n         log_wasm(&wasm);\n@@ -532,18 +533,104 @@ pub fn table_ops(\n             Err(_) => return,\n         };\n \n+        let mut linker = Linker::new(&engine);\n+\n         // To avoid timeouts, limit the number of explicit GCs we perform per\n         // test case.\n         const MAX_GCS: usize = 5;\n \n         let num_gcs = AtomicUsize::new(0);\n-        let gc = Func::wrap(&mut store, move |mut caller: Caller<'_, StoreLimits>| {\n-            if num_gcs.fetch_add(1, SeqCst) < MAX_GCS {\n-                caller.gc();\n-            }\n-        });\n+        linker\n+            .define(\n+                \"\",\n+                \"gc\",\n+                // NB: use `Func::new` so that this can still compile on the old x86\n+                // backend, where `IntoFunc` isn't implemented for multi-value\n+                // returns.\n+                Func::new(\n+                    &mut store,\n+                    FuncType::new(\n+                        vec![],\n+                        vec![ValType::ExternRef, ValType::ExternRef, ValType::ExternRef],\n+                    ),\n+                    {\n+                        let num_dropped = num_dropped.clone();\n+                        let expected_drops = expected_drops.clone();\n+                        move |mut caller: Caller<'_, StoreLimits>, _params, results| {\n+                            if num_gcs.fetch_add(1, SeqCst) < MAX_GCS {\n+                                caller.gc();\n+                            }\n+\n+                            expected_drops.fetch_add(3, SeqCst);\n+                            results[0] =\n+                                Some(ExternRef::new(CountDrops(num_dropped.clone()))).into();\n+                            results[1] =\n+                                Some(ExternRef::new(CountDrops(num_dropped.clone()))).into();\n+                            results[2] =\n+                                Some(ExternRef::new(CountDrops(num_dropped.clone()))).into();\n+                            Ok(())\n+                        }\n+                    },\n+                ),\n+            )\n+            .unwrap();\n+\n+        linker\n+            .func_wrap(\"\", \"take_refs\", {\n+                let expected_drops = expected_drops.clone();\n+                move |a: Option<ExternRef>, b: Option<ExternRef>, c: Option<ExternRef>| {\n+                    // Do the assertion on each ref's inner data, even though it\n+                    // all points to the same atomic, so that if we happen to\n+                    // run into a use-after-free bug with one of these refs we\n+                    // are more likely to trigger a segfault.\n+                    if let Some(a) = a {\n+                        let a = a.data().downcast_ref::<CountDrops>().unwrap();\n+                        assert!(a.0.load(SeqCst) <= expected_drops.load(SeqCst));\n+                    }\n+                    if let Some(b) = b {\n+                        let b = b.data().downcast_ref::<CountDrops>().unwrap();\n+                        assert!(b.0.load(SeqCst) <= expected_drops.load(SeqCst));\n+                    }\n+                    if let Some(c) = c {\n+                        let c = c.data().downcast_ref::<CountDrops>().unwrap();\n+                        assert!(c.0.load(SeqCst) <= expected_drops.load(SeqCst));\n+                    }\n+                }\n+            })\n+            .unwrap();\n+\n+        linker\n+            .define(\n+                \"\",\n+                \"make_refs\",\n+                // NB: use `Func::new` so that this can still compile on the old\n+                // x86 backend, where `IntoFunc` isn't implemented for\n+                // multi-value returns.\n+                Func::new(\n+                    &mut store,\n+                    FuncType::new(\n+                        vec![],\n+                        vec![ValType::ExternRef, ValType::ExternRef, ValType::ExternRef],\n+                    ),\n+                    {\n+                        let num_dropped = num_dropped.clone();\n+                        let expected_drops = expected_drops.clone();\n+                        move |_caller, _params, results| {\n+                            expected_drops.fetch_add(3, SeqCst);\n+                            results[0] =\n+                                Some(ExternRef::new(CountDrops(num_dropped.clone()))).into();\n+                            results[1] =\n+                                Some(ExternRef::new(CountDrops(num_dropped.clone()))).into();\n+                            results[2] =\n+                                Some(ExternRef::new(CountDrops(num_dropped.clone()))).into();\n+                            Ok(())\n+                        }\n+                    },\n+                ),\n+            )\n+            .unwrap();\n \n-        let instance = Instance::new(&mut store, &module, &[gc.into()]).unwrap();\n+        let instance = linker.instantiate(&mut store, &module).unwrap();\n         let run = instance.get_func(&mut store, \"run\").unwrap();\n \n         let args: Vec<_> = (0..ops.num_params())\n@@ -552,7 +639,7 @@ pub fn table_ops(\n         let _ = run.call(&mut store, &args);\n     }\n \n-    assert_eq!(num_dropped.load(SeqCst), ops.num_params() as usize);\n+    assert_eq!(num_dropped.load(SeqCst), expected_drops.load(SeqCst));\n     return;\n \n     struct CountDrops(Arc<AtomicUsize>);\n",
    "diff_parsed": "{'added': [(517, '    let expected_drops = Arc::new(AtomicUsize::new(ops.num_params() as usize));'), (523, '        config.consume_fuel(true);'), (527, '        store.add_fuel(100).unwrap();'), (536, '        let mut linker = Linker::new(&engine);'), (543, '        linker'), (544, '            .define('), (545, '                \"\",'), (546, '                \"gc\",'), (550, '                Func::new('), (551, '                    &mut store,'), (552, '                    FuncType::new('), (553, '                        vec![],'), (554, '                        vec![ValType::ExternRef, ValType::ExternRef, ValType::ExternRef],'), (555, '                    ),'), (556, '                    {'), (557, '                        let num_dropped = num_dropped.clone();'), (558, '                        let expected_drops = expected_drops.clone();'), (559, \"                        move |mut caller: Caller<'_, StoreLimits>, _params, results| {\"), (560, '                            if num_gcs.fetch_add(1, SeqCst) < MAX_GCS {'), (561, '                                caller.gc();'), (562, '                            }'), (564, '                            expected_drops.fetch_add(3, SeqCst);'), (565, '                            results[0] ='), (566, '                                Some(ExternRef::new(CountDrops(num_dropped.clone()))).into();'), (567, '                            results[1] ='), (568, '                                Some(ExternRef::new(CountDrops(num_dropped.clone()))).into();'), (569, '                            results[2] ='), (570, '                                Some(ExternRef::new(CountDrops(num_dropped.clone()))).into();'), (571, '                            Ok(())'), (572, '                        }'), (573, '                    },'), (574, '                ),'), (575, '            )'), (576, '            .unwrap();'), (578, '        linker'), (579, '            .func_wrap(\"\", \"take_refs\", {'), (580, '                let expected_drops = expected_drops.clone();'), (581, '                move |a: Option<ExternRef>, b: Option<ExternRef>, c: Option<ExternRef>| {'), (586, '                    if let Some(a) = a {'), (587, '                        let a = a.data().downcast_ref::<CountDrops>().unwrap();'), (588, '                        assert!(a.0.load(SeqCst) <= expected_drops.load(SeqCst));'), (589, '                    }'), (590, '                    if let Some(b) = b {'), (591, '                        let b = b.data().downcast_ref::<CountDrops>().unwrap();'), (592, '                        assert!(b.0.load(SeqCst) <= expected_drops.load(SeqCst));'), (593, '                    }'), (594, '                    if let Some(c) = c {'), (595, '                        let c = c.data().downcast_ref::<CountDrops>().unwrap();'), (596, '                        assert!(c.0.load(SeqCst) <= expected_drops.load(SeqCst));'), (597, '                    }'), (598, '                }'), (599, '            })'), (600, '            .unwrap();'), (602, '        linker'), (603, '            .define('), (604, '                \"\",'), (605, '                \"make_refs\",'), (609, '                Func::new('), (610, '                    &mut store,'), (611, '                    FuncType::new('), (612, '                        vec![],'), (613, '                        vec![ValType::ExternRef, ValType::ExternRef, ValType::ExternRef],'), (614, '                    ),'), (615, '                    {'), (616, '                        let num_dropped = num_dropped.clone();'), (617, '                        let expected_drops = expected_drops.clone();'), (618, '                        move |_caller, _params, results| {'), (619, '                            expected_drops.fetch_add(3, SeqCst);'), (620, '                            results[0] ='), (621, '                                Some(ExternRef::new(CountDrops(num_dropped.clone()))).into();'), (622, '                            results[1] ='), (623, '                                Some(ExternRef::new(CountDrops(num_dropped.clone()))).into();'), (624, '                            results[2] ='), (625, '                                Some(ExternRef::new(CountDrops(num_dropped.clone()))).into();'), (626, '                            Ok(())'), (627, '                        }'), (628, '                    },'), (629, '                ),'), (630, '            )'), (631, '            .unwrap();'), (633, '        let instance = linker.instantiate(&mut store, &module).unwrap();'), (642, '    assert_eq!(num_dropped.load(SeqCst), expected_drops.load(SeqCst));')], 'deleted': [(524, '        if fuzz_config.consume_fuel {'), (525, '            store.add_fuel(u64::max_value()).unwrap();'), (526, '        }'), (540, \"        let gc = Func::wrap(&mut store, move |mut caller: Caller<'_, StoreLimits>| {\"), (541, '            if num_gcs.fetch_add(1, SeqCst) < MAX_GCS {'), (542, '                caller.gc();'), (543, '            }'), (544, '        });'), (546, '        let instance = Instance::new(&mut store, &module, &[gc.into()]).unwrap();'), (555, '    assert_eq!(num_dropped.load(SeqCst), ops.num_params() as usize);')]}",
    "num_lines_added": "82",
    "num_lines_deleted": "10",
    "nloc": "721"
  },
  {
    "file_change_id": "70275699673559",
    "hash": "d2ce1ac753afc059e32798bac3383b81a6d04456",
    "old_path": "crates/runtime/src/externref.rs",
    "new_path": "crates/runtime/src/externref.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -489,7 +489,7 @@ type TableElem = UnsafeCell<Option<VMExternRef>>;\n ///\n /// Under the covers, this is a simple bump allocator that allows duplicate\n /// entries. Deduplication happens at GC time.\n-#[repr(C)] // `alloc` must be the first member, it's accessed from JIT code\n+#[repr(C)] // `alloc` must be the first member, it's accessed from JIT code.\n pub struct VMExternRefActivationsTable {\n     /// Structures used to perform fast bump allocation of storage of externref\n     /// values.\n@@ -521,9 +521,14 @@ pub struct VMExternRefActivationsTable {\n     /// inside-a-Wasm-frame roots, and doing a GC could lead to freeing one of\n     /// those missed roots, and use after free.\n     stack_canary: Option<usize>,\n+\n+    /// A debug-only field for asserting that we are in a region of code where\n+    /// GC is okay to preform.\n+    #[cfg(debug_assertions)]\n+    gc_okay: bool,\n }\n \n-#[repr(C)] // this is accessed from JTI code\n+#[repr(C)] // This is accessed from JIT code.\n struct VMExternRefTableAlloc {\n     /// Bump-allocation finger within the `chunk`.\n     ///\n@@ -573,6 +578,8 @@ impl VMExternRefActivationsTable {\n             over_approximated_stack_roots: HashSet::with_capacity(Self::CHUNK_SIZE),\n             precise_stack_roots: HashSet::with_capacity(Self::CHUNK_SIZE),\n             stack_canary: None,\n+            #[cfg(debug_assertions)]\n+            gc_okay: true,\n         }\n     }\n \n@@ -581,6 +588,14 @@ impl VMExternRefActivationsTable {\n         (0..size).map(|_| UnsafeCell::new(None)).collect()\n     }\n \n+    /// Get the available capacity in the bump allocation chunk.\n+    #[inline]\n+    pub fn bump_capacity_remaining(&self) -> usize {\n+        let end = self.alloc.end.as_ptr() as usize;\n+        let next = unsafe { *self.alloc.next.get() };\n+        end - next.as_ptr() as usize\n+    }\n+\n     /// Try and insert a `VMExternRef` into this table.\n     ///\n     /// This is a fast path that only succeeds when the bump chunk has the\n@@ -624,6 +639,9 @@ impl VMExternRefActivationsTable {\n         externref: VMExternRef,\n         module_info_lookup: &dyn ModuleInfoLookup,\n     ) {\n+        #[cfg(debug_assertions)]\n+        assert!(self.gc_okay);\n+\n         if let Err(externref) = self.try_insert(externref) {\n             self.gc_and_insert_slow(externref, module_info_lookup);\n         }\n@@ -644,6 +662,20 @@ impl VMExternRefActivationsTable {\n             .insert(VMExternRefWithTraits(externref));\n     }\n \n+    /// Insert a reference into the table, without ever performing GC.\n+    #[inline]\n+    pub fn insert_without_gc(&mut self, externref: VMExternRef) {\n+        if let Err(externref) = self.try_insert(externref) {\n+            self.insert_slow_without_gc(externref);\n+        }\n+    }\n+\n+    #[inline(never)]\n+    fn insert_slow_without_gc(&mut self, externref: VMExternRef) {\n+        self.over_approximated_stack_roots\n+            .insert(VMExternRefWithTraits(externref));\n+    }\n+\n     fn num_filled_in_bump_chunk(&self) -> usize {\n         let next = unsafe { *self.alloc.next.get() };\n         let bytes_unused = (self.alloc.end.as_ptr() as usize) - (next.as_ptr() as usize);\n@@ -742,6 +774,24 @@ impl VMExternRefActivationsTable {\n     pub fn set_stack_canary(&mut self, canary: Option<usize>) {\n         self.stack_canary = canary;\n     }\n+\n+    /// Set whether it is okay to GC or not right now.\n+    ///\n+    /// This is provided as a helper for enabling various debug-only assertions\n+    /// and checking places where the `wasmtime-runtime` user expects there not\n+    /// to be any GCs.\n+    #[inline]\n+    pub fn set_gc_okay(&mut self, okay: bool) -> bool {\n+        #[cfg(debug_assertions)]\n+        {\n+            return std::mem::replace(&mut self.gc_okay, okay);\n+        }\n+        #[cfg(not(debug_assertions))]\n+        {\n+            let _ = okay;\n+            return true;\n+        }\n+    }\n }\n \n /// Used by the runtime to lookup information about a module given a\n@@ -807,6 +857,9 @@ pub unsafe fn gc(\n ) {\n     log::debug!(\"start GC\");\n \n+    #[cfg(debug_assertions)]\n+    assert!(externref_activations_table.gc_okay);\n+\n     debug_assert!({\n         // This set is only non-empty within this function. It is built up when\n         // walking the stack and interpreting stack maps, and then drained back\n",
    "diff_parsed": "{'added': [(492, \"#[repr(C)] // `alloc` must be the first member, it's accessed from JIT code.\"), (527, '    #[cfg(debug_assertions)]'), (528, '    gc_okay: bool,'), (531, '#[repr(C)] // This is accessed from JIT code.'), (581, '            #[cfg(debug_assertions)]'), (582, '            gc_okay: true,'), (592, '    #[inline]'), (593, '    pub fn bump_capacity_remaining(&self) -> usize {'), (594, '        let end = self.alloc.end.as_ptr() as usize;'), (595, '        let next = unsafe { *self.alloc.next.get() };'), (596, '        end - next.as_ptr() as usize'), (597, '    }'), (642, '        #[cfg(debug_assertions)]'), (643, '        assert!(self.gc_okay);'), (666, '    #[inline]'), (667, '    pub fn insert_without_gc(&mut self, externref: VMExternRef) {'), (668, '        if let Err(externref) = self.try_insert(externref) {'), (669, '            self.insert_slow_without_gc(externref);'), (670, '        }'), (671, '    }'), (673, '    #[inline(never)]'), (674, '    fn insert_slow_without_gc(&mut self, externref: VMExternRef) {'), (675, '        self.over_approximated_stack_roots'), (676, '            .insert(VMExternRefWithTraits(externref));'), (677, '    }'), (783, '    #[inline]'), (784, '    pub fn set_gc_okay(&mut self, okay: bool) -> bool {'), (785, '        #[cfg(debug_assertions)]'), (786, '        {'), (787, '            return std::mem::replace(&mut self.gc_okay, okay);'), (788, '        }'), (789, '        #[cfg(not(debug_assertions))]'), (790, '        {'), (791, '            let _ = okay;'), (792, '            return true;'), (793, '        }'), (794, '    }'), (860, '    #[cfg(debug_assertions)]'), (861, '    assert!(externref_activations_table.gc_okay);')], 'deleted': [(492, \"#[repr(C)] // `alloc` must be the first member, it's accessed from JIT code\"), (526, '#[repr(C)] // this is accessed from JTI code')]}",
    "num_lines_added": "39",
    "num_lines_deleted": "2",
    "nloc": "559"
  },
  {
    "file_change_id": "113895633629685",
    "hash": "d2ce1ac753afc059e32798bac3383b81a6d04456",
    "old_path": "crates/types/src/lib.rs",
    "new_path": "crates/types/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -71,29 +71,66 @@ impl From<WasmType> for wasmparser::Type {\n /// WebAssembly function type -- equivalent of `wasmparser`'s FuncType.\n #[derive(Debug, Clone, Eq, PartialEq, Hash, Serialize, Deserialize)]\n pub struct WasmFuncType {\n+    params: Box<[WasmType]>,\n+    externref_params_count: usize,\n+    returns: Box<[WasmType]>,\n+    externref_returns_count: usize,\n+}\n+\n+impl WasmFuncType {\n+    #[inline]\n+    pub fn new(params: Box<[WasmType]>, returns: Box<[WasmType]>) -> Self {\n+        let externref_params_count = params.iter().filter(|p| **p == WasmType::ExternRef).count();\n+        let externref_returns_count = params.iter().filter(|r| **r == WasmType::ExternRef).count();\n+        WasmFuncType {\n+            params,\n+            externref_params_count,\n+            returns,\n+            externref_returns_count,\n+        }\n+    }\n+\n     /// Function params types.\n-    pub params: Box<[WasmType]>,\n+    #[inline]\n+    pub fn params(&self) -> &[WasmType] {\n+        &self.params\n+    }\n+\n+    /// How many `externref`s are in this function's params?\n+    #[inline]\n+    pub fn externref_params_count(&self) -> usize {\n+        self.externref_params_count\n+    }\n+\n     /// Returns params types.\n-    pub returns: Box<[WasmType]>,\n+    #[inline]\n+    pub fn returns(&self) -> &[WasmType] {\n+        &self.returns\n+    }\n+\n+    /// How many `externref`s are in this function's returns?\n+    #[inline]\n+    pub fn externref_returns_count(&self) -> usize {\n+        self.externref_returns_count\n+    }\n }\n \n impl TryFrom<wasmparser::FuncType> for WasmFuncType {\n     type Error = WasmError;\n     fn try_from(ty: wasmparser::FuncType) -> Result<Self, Self::Error> {\n-        Ok(Self {\n-            params: ty\n-                .params\n-                .into_vec()\n-                .into_iter()\n-                .map(WasmType::try_from)\n-                .collect::<Result<_, Self::Error>>()?,\n-            returns: ty\n-                .returns\n-                .into_vec()\n-                .into_iter()\n-                .map(WasmType::try_from)\n-                .collect::<Result<_, Self::Error>>()?,\n-        })\n+        let params = ty\n+            .params\n+            .into_vec()\n+            .into_iter()\n+            .map(WasmType::try_from)\n+            .collect::<Result<_, Self::Error>>()?;\n+        let returns = ty\n+            .returns\n+            .into_vec()\n+            .into_iter()\n+            .map(WasmType::try_from)\n+            .collect::<Result<_, Self::Error>>()?;\n+        Ok(Self::new(params, returns))\n     }\n }\n \n",
    "diff_parsed": "{'added': [(74, '    params: Box<[WasmType]>,'), (75, '    externref_params_count: usize,'), (76, '    returns: Box<[WasmType]>,'), (77, '    externref_returns_count: usize,'), (78, '}'), (80, 'impl WasmFuncType {'), (81, '    #[inline]'), (82, '    pub fn new(params: Box<[WasmType]>, returns: Box<[WasmType]>) -> Self {'), (83, '        let externref_params_count = params.iter().filter(|p| **p == WasmType::ExternRef).count();'), (84, '        let externref_returns_count = params.iter().filter(|r| **r == WasmType::ExternRef).count();'), (85, '        WasmFuncType {'), (86, '            params,'), (87, '            externref_params_count,'), (88, '            returns,'), (89, '            externref_returns_count,'), (90, '        }'), (91, '    }'), (94, '    #[inline]'), (95, '    pub fn params(&self) -> &[WasmType] {'), (96, '        &self.params'), (97, '    }'), (100, '    #[inline]'), (101, '    pub fn externref_params_count(&self) -> usize {'), (102, '        self.externref_params_count'), (103, '    }'), (106, '    #[inline]'), (107, '    pub fn returns(&self) -> &[WasmType] {'), (108, '        &self.returns'), (109, '    }'), (112, '    #[inline]'), (113, '    pub fn externref_returns_count(&self) -> usize {'), (114, '        self.externref_returns_count'), (115, '    }'), (121, '        let params = ty'), (122, '            .params'), (123, '            .into_vec()'), (124, '            .into_iter()'), (125, '            .map(WasmType::try_from)'), (126, '            .collect::<Result<_, Self::Error>>()?;'), (127, '        let returns = ty'), (128, '            .returns'), (129, '            .into_vec()'), (130, '            .into_iter()'), (131, '            .map(WasmType::try_from)'), (132, '            .collect::<Result<_, Self::Error>>()?;'), (133, '        Ok(Self::new(params, returns))')], 'deleted': [(75, '    pub params: Box<[WasmType]>,'), (77, '    pub returns: Box<[WasmType]>,'), (83, '        Ok(Self {'), (84, '            params: ty'), (85, '                .params'), (86, '                .into_vec()'), (87, '                .into_iter()'), (88, '                .map(WasmType::try_from)'), (89, '                .collect::<Result<_, Self::Error>>()?,'), (90, '            returns: ty'), (91, '                .returns'), (92, '                .into_vec()'), (93, '                .into_iter()'), (94, '                .map(WasmType::try_from)'), (95, '                .collect::<Result<_, Self::Error>>()?,'), (96, '        })')]}",
    "num_lines_added": "46",
    "num_lines_deleted": "16",
    "nloc": "247"
  },
  {
    "file_change_id": "249905507253294",
    "hash": "d2ce1ac753afc059e32798bac3383b81a6d04456",
    "old_path": "crates/wasmtime/src/func.rs",
    "new_path": "crates/wasmtime/src/func.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -774,6 +774,21 @@ impl Func {\n \n             let mut values_vec = vec![0; max(params.len(), ty.results().len())];\n \n+            // Whenever we pass `externref`s from host code to Wasm code, they\n+            // go into the `VMExternRefActivationsTable`. But the table might be\n+            // at capacity already, so check for that. If it is at capacity\n+            // (unlikely) then do a GC to free up space. This is necessary\n+            // because otherwise we would either keep filling up the bump chunk\n+            // and making it larger and larger or we would always take the slow\n+            // path when inserting references into the table.\n+            if ty.as_wasm_func_type().externref_params_count()\n+                > store\n+                    .externref_activations_table()\n+                    .bump_capacity_remaining()\n+            {\n+                store.gc();\n+            }\n+\n             // Store the argument values into `values_vec`.\n             let param_tys = ty.params();\n             for ((arg, slot), ty) in params.iter().cloned().zip(&mut values_vec).zip(param_tys) {\n@@ -788,7 +803,7 @@ impl Func {\n                     bail!(\"cross-`Store` values are not currently supported\");\n                 }\n                 unsafe {\n-                    arg.write_value_to(store, slot);\n+                    arg.write_value_without_gc(store, slot);\n                 }\n             }\n \n@@ -871,6 +886,17 @@ impl Func {\n         let (params, results) = val_vec.split_at_mut(nparams);\n         func(caller.sub_caller(), params, results)?;\n \n+        // See the comment in `Func::call_impl`'s `write_params` function.\n+        if ty.as_wasm_func_type().externref_returns_count()\n+            > caller\n+                .store\n+                .0\n+                .externref_activations_table()\n+                .bump_capacity_remaining()\n+        {\n+            caller.store.gc();\n+        }\n+\n         // Unlike our arguments we need to dynamically check that the return\n         // values produced are correct. There could be a bug in `func` that\n         // produces the wrong number, wrong types, or wrong stores of\n@@ -887,7 +913,7 @@ impl Func {\n                 ));\n             }\n             unsafe {\n-                ret.write_value_to(caller.store.0, values_vec.add(i));\n+                ret.write_value_without_gc(caller.store.0, values_vec.add(i));\n             }\n         }\n \n",
    "diff_parsed": "{'added': [(784, '            if ty.as_wasm_func_type().externref_params_count()'), (785, '                > store'), (786, '                    .externref_activations_table()'), (787, '                    .bump_capacity_remaining()'), (788, '            {'), (789, '                store.gc();'), (790, '            }'), (806, '                    arg.write_value_without_gc(store, slot);'), (890, '        if ty.as_wasm_func_type().externref_returns_count()'), (891, '            > caller'), (892, '                .store'), (893, '                .0'), (894, '                .externref_activations_table()'), (895, '                .bump_capacity_remaining()'), (896, '        {'), (897, '            caller.store.gc();'), (898, '        }'), (916, '                ret.write_value_without_gc(caller.store.0, values_vec.add(i));')], 'deleted': [(791, '                    arg.write_value_to(store, slot);'), (890, '                ret.write_value_to(caller.store.0, values_vec.add(i));')]}",
    "num_lines_added": "18",
    "num_lines_deleted": "2",
    "nloc": "994"
  },
  {
    "file_change_id": "27657304237962",
    "hash": "d2ce1ac753afc059e32798bac3383b81a6d04456",
    "old_path": "crates/wasmtime/src/func/typed.rs",
    "new_path": "crates/wasmtime/src/func/typed.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,5 +1,5 @@\n use super::{invoke_wasm_and_catch_traps, HostAbi};\n-use crate::store::StoreOpaque;\n+use crate::store::{AutoAssertNoGc, StoreOpaque};\n use crate::{AsContextMut, ExternRef, Func, StoreContextMut, Trap, ValType};\n use anyhow::{bail, Result};\n use std::marker;\n@@ -115,15 +115,33 @@ where\n         store: &mut StoreContextMut<'_, T>,\n         params: Params,\n     ) -> Result<Results, Trap> {\n+        // See the comment in `Func::call_impl`'s `write_params` function.\n+        if params.externrefs_count()\n+            > store\n+                .0\n+                .externref_activations_table()\n+                .bump_capacity_remaining()\n+        {\n+            store.gc();\n+        }\n+\n         // Validate that all runtime values flowing into this store indeed\n         // belong within this store, otherwise it would be unsafe for store\n         // values to cross each other.\n-        let params = match params.into_abi(store.0) {\n-            Some(abi) => abi,\n-            None => {\n-                return Err(Trap::new(\n-                    \"attempt to pass cross-`Store` value to Wasm as function argument\",\n-                ))\n+\n+        let params = {\n+            // GC is not safe here, since we move refs into the activations\n+            // table but don't hold a strong reference onto them until we enter\n+            // the Wasm frame and they get referenced from the stack maps.\n+            let mut store = AutoAssertNoGc::new(&mut **store.as_context_mut().0);\n+\n+            match params.into_abi(&mut store) {\n+                Some(abi) => abi,\n+                None => {\n+                    return Err(Trap::new(\n+                        \"attempt to pass cross-`Store` value to Wasm as function argument\",\n+                    ))\n+                }\n             }\n         };\n \n@@ -183,6 +201,8 @@ pub unsafe trait WasmTy: Send {\n     #[doc(hidden)]\n     fn compatible_with_store(&self, store: &StoreOpaque) -> bool;\n     #[doc(hidden)]\n+    fn is_externref(&self) -> bool;\n+    #[doc(hidden)]\n     fn into_abi(self, store: &mut StoreOpaque) -> Self::Abi;\n     #[doc(hidden)]\n     unsafe fn from_abi(abi: Self::Abi, store: &mut StoreOpaque) -> Self;\n@@ -201,6 +221,10 @@ macro_rules! primitives {\n                 true\n             }\n             #[inline]\n+            fn is_externref(&self) -> bool {\n+                false\n+            }\n+            #[inline]\n             fn into_abi(self, _store: &mut StoreOpaque) -> Self::Abi {\n                 self\n             }\n@@ -234,12 +258,46 @@ unsafe impl WasmTy for Option<ExternRef> {\n         true\n     }\n \n+    #[inline]\n+    fn is_externref(&self) -> bool {\n+        true\n+    }\n+\n     #[inline]\n     fn into_abi(self, store: &mut StoreOpaque) -> Self::Abi {\n         if let Some(x) = self {\n             let abi = x.inner.as_raw();\n             unsafe {\n-                store.insert_vmexternref(x.inner);\n+                // NB: We _must not_ trigger a GC when passing refs from host\n+                // code into Wasm (e.g. returned from a host function or passed\n+                // as arguments to a Wasm function). After insertion into the\n+                // table, this reference is no longer rooted. If multiple\n+                // references are being sent from the host into Wasm and we\n+                // allowed GCs during insertion, then the following events could\n+                // happen:\n+                //\n+                // * Reference A is inserted into the activations\n+                //   table. This does not trigger a GC, but does fill the table\n+                //   to capacity.\n+                //\n+                // * The caller's reference to A is removed. Now the only\n+                //   reference to A is from the activations table.\n+                //\n+                // * Reference B is inserted into the activations table. Because\n+                //   the table is at capacity, a GC is triggered.\n+                //\n+                // * A is reclaimed because the only reference keeping it alive\n+                //   was the activation table's reference (it isn't inside any\n+                //   Wasm frames on the stack yet, so stack scanning and stack\n+                //   maps don't increment its reference count).\n+                //\n+                // * We transfer control to Wasm, giving it A and B. Wasm uses\n+                //   A. That's a use after free.\n+                //\n+                // In conclusion, to prevent uses after free, we cannot GC\n+                // during this insertion.\n+                let mut store = AutoAssertNoGc::new(store);\n+                store.insert_vmexternref_without_gc(x.inner);\n             }\n             abi\n         } else {\n@@ -276,6 +334,11 @@ unsafe impl WasmTy for Option<Func> {\n         }\n     }\n \n+    #[inline]\n+    fn is_externref(&self) -> bool {\n+        false\n+    }\n+\n     #[inline]\n     fn into_abi(self, store: &mut StoreOpaque) -> Self::Abi {\n         if let Some(f) = self {\n@@ -299,10 +362,16 @@ unsafe impl WasmTy for Option<Func> {\n pub unsafe trait WasmParams: Send {\n     #[doc(hidden)]\n     type Abi: Copy;\n+\n     #[doc(hidden)]\n     fn typecheck(params: impl ExactSizeIterator<Item = crate::ValType>) -> Result<()>;\n+\n+    #[doc(hidden)]\n+    fn externrefs_count(&self) -> usize;\n+\n     #[doc(hidden)]\n     fn into_abi(self, store: &mut StoreOpaque) -> Option<Self::Abi>;\n+\n     #[doc(hidden)]\n     unsafe fn invoke<R: WasmResults>(\n         func: *const VMFunctionBody,\n@@ -323,10 +392,17 @@ where\n     fn typecheck(params: impl ExactSizeIterator<Item = crate::ValType>) -> Result<()> {\n         <(T,) as WasmParams>::typecheck(params)\n     }\n+\n+    #[inline]\n+    fn externrefs_count(&self) -> usize {\n+        T::is_externref(self) as usize\n+    }\n+\n     #[inline]\n     fn into_abi(self, store: &mut StoreOpaque) -> Option<Self::Abi> {\n         <(T,) as WasmParams>::into_abi((self,), store)\n     }\n+\n     unsafe fn invoke<R: WasmResults>(\n         func: *const VMFunctionBody,\n         vmctx1: *mut VMContext,\n@@ -365,6 +441,15 @@ macro_rules! impl_wasm_params {\n                 }\n             }\n \n+            #[inline]\n+            fn externrefs_count(&self) -> usize {\n+                let ($(ref $t,)*) = self;\n+                0 $(\n+                    + $t.is_externref() as usize\n+                )*\n+            }\n+\n+\n             #[inline]\n             fn into_abi(self, _store: &mut StoreOpaque) -> Option<Self::Abi> {\n                 let ($($t,)*) = self;\n",
    "diff_parsed": "{'added': [(2, 'use crate::store::{AutoAssertNoGc, StoreOpaque};'), (119, '        if params.externrefs_count()'), (120, '            > store'), (121, '                .0'), (122, '                .externref_activations_table()'), (123, '                .bump_capacity_remaining()'), (124, '        {'), (125, '            store.gc();'), (126, '        }'), (132, '        let params = {'), (136, '            let mut store = AutoAssertNoGc::new(&mut **store.as_context_mut().0);'), (138, '            match params.into_abi(&mut store) {'), (139, '                Some(abi) => abi,'), (140, '                None => {'), (141, '                    return Err(Trap::new('), (142, '                        \"attempt to pass cross-`Store` value to Wasm as function argument\",'), (143, '                    ))'), (144, '                }'), (204, '    fn is_externref(&self) -> bool;'), (205, '    #[doc(hidden)]'), (224, '            fn is_externref(&self) -> bool {'), (225, '                false'), (226, '            }'), (227, '            #[inline]'), (261, '    #[inline]'), (262, '    fn is_externref(&self) -> bool {'), (263, '        true'), (264, '    }'), (299, '                let mut store = AutoAssertNoGc::new(store);'), (300, '                store.insert_vmexternref_without_gc(x.inner);'), (337, '    #[inline]'), (338, '    fn is_externref(&self) -> bool {'), (339, '        false'), (340, '    }'), (369, '    #[doc(hidden)]'), (370, '    fn externrefs_count(&self) -> usize;'), (396, '    #[inline]'), (397, '    fn externrefs_count(&self) -> usize {'), (398, '        T::is_externref(self) as usize'), (399, '    }'), (444, '            #[inline]'), (445, '            fn externrefs_count(&self) -> usize {'), (446, '                let ($(ref $t,)*) = self;'), (447, '                0 $('), (448, '                    + $t.is_externref() as usize'), (449, '                )*'), (450, '            }')], 'deleted': [(2, 'use crate::store::StoreOpaque;'), (121, '        let params = match params.into_abi(store.0) {'), (122, '            Some(abi) => abi,'), (123, '            None => {'), (124, '                return Err(Trap::new('), (125, '                    \"attempt to pass cross-`Store` value to Wasm as function argument\",'), (126, '                ))'), (242, '                store.insert_vmexternref(x.inner);')]}",
    "num_lines_added": "47",
    "num_lines_deleted": "8",
    "nloc": "391"
  },
  {
    "file_change_id": "265224512579618",
    "hash": "d2ce1ac753afc059e32798bac3383b81a6d04456",
    "old_path": "crates/wasmtime/src/store.rs",
    "new_path": "crates/wasmtime/src/store.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -290,6 +290,67 @@ unsafe impl Send for AsyncState {}\n #[cfg(feature = \"async\")]\n unsafe impl Sync for AsyncState {}\n \n+/// An RAII type to automatically mark a region of code as unsafe for GC.\n+pub(crate) struct AutoAssertNoGc<T>\n+where\n+    T: std::ops::DerefMut<Target = StoreOpaque>,\n+{\n+    #[cfg(debug_assertions)]\n+    prev_okay: bool,\n+    store: T,\n+}\n+\n+impl<T> AutoAssertNoGc<T>\n+where\n+    T: std::ops::DerefMut<Target = StoreOpaque>,\n+{\n+    pub fn new(mut store: T) -> Self {\n+        #[cfg(debug_assertions)]\n+        {\n+            let prev_okay = store.externref_activations_table.set_gc_okay(false);\n+            return AutoAssertNoGc { store, prev_okay };\n+        }\n+        #[cfg(not(debug_assertions))]\n+        {\n+            return AutoAssertNoGc { store };\n+        }\n+    }\n+}\n+\n+impl<T> std::ops::Deref for AutoAssertNoGc<T>\n+where\n+    T: std::ops::DerefMut<Target = StoreOpaque>,\n+{\n+    type Target = T;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.store\n+    }\n+}\n+\n+impl<T> std::ops::DerefMut for AutoAssertNoGc<T>\n+where\n+    T: std::ops::DerefMut<Target = StoreOpaque>,\n+{\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.store\n+    }\n+}\n+\n+impl<T> Drop for AutoAssertNoGc<T>\n+where\n+    T: std::ops::DerefMut<Target = StoreOpaque>,\n+{\n+    fn drop(&mut self) {\n+        #[cfg(debug_assertions)]\n+        {\n+            self.store\n+                .externref_activations_table\n+                .set_gc_okay(self.prev_okay);\n+        }\n+    }\n+}\n+\n /// Used to associate instances with the store.\n ///\n /// This is needed to track if the instance was allocated explicitly with the on-demand\n@@ -1039,9 +1100,8 @@ impl StoreOpaque {\n         &*self.interrupts as *const VMInterrupts as *mut VMInterrupts\n     }\n \n-    pub unsafe fn insert_vmexternref(&mut self, r: VMExternRef) {\n-        self.externref_activations_table\n-            .insert_with_gc(r, &self.modules)\n+    pub unsafe fn insert_vmexternref_without_gc(&mut self, r: VMExternRef) {\n+        self.externref_activations_table.insert_without_gc(r);\n     }\n \n     #[inline]\n",
    "diff_parsed": "{'added': [(294, 'pub(crate) struct AutoAssertNoGc<T>'), (295, 'where'), (296, '    T: std::ops::DerefMut<Target = StoreOpaque>,'), (297, '{'), (298, '    #[cfg(debug_assertions)]'), (299, '    prev_okay: bool,'), (300, '    store: T,'), (301, '}'), (303, 'impl<T> AutoAssertNoGc<T>'), (304, 'where'), (305, '    T: std::ops::DerefMut<Target = StoreOpaque>,'), (306, '{'), (307, '    pub fn new(mut store: T) -> Self {'), (308, '        #[cfg(debug_assertions)]'), (309, '        {'), (310, '            let prev_okay = store.externref_activations_table.set_gc_okay(false);'), (311, '            return AutoAssertNoGc { store, prev_okay };'), (312, '        }'), (313, '        #[cfg(not(debug_assertions))]'), (314, '        {'), (315, '            return AutoAssertNoGc { store };'), (316, '        }'), (317, '    }'), (318, '}'), (320, 'impl<T> std::ops::Deref for AutoAssertNoGc<T>'), (321, 'where'), (322, '    T: std::ops::DerefMut<Target = StoreOpaque>,'), (323, '{'), (324, '    type Target = T;'), (326, '    fn deref(&self) -> &Self::Target {'), (327, '        &self.store'), (328, '    }'), (329, '}'), (331, 'impl<T> std::ops::DerefMut for AutoAssertNoGc<T>'), (332, 'where'), (333, '    T: std::ops::DerefMut<Target = StoreOpaque>,'), (334, '{'), (335, '    fn deref_mut(&mut self) -> &mut Self::Target {'), (336, '        &mut self.store'), (337, '    }'), (338, '}'), (340, 'impl<T> Drop for AutoAssertNoGc<T>'), (341, 'where'), (342, '    T: std::ops::DerefMut<Target = StoreOpaque>,'), (343, '{'), (344, '    fn drop(&mut self) {'), (345, '        #[cfg(debug_assertions)]'), (346, '        {'), (347, '            self.store'), (348, '                .externref_activations_table'), (349, '                .set_gc_okay(self.prev_okay);'), (350, '        }'), (351, '    }'), (352, '}'), (1103, '    pub unsafe fn insert_vmexternref_without_gc(&mut self, r: VMExternRef) {'), (1104, '        self.externref_activations_table.insert_without_gc(r);')], 'deleted': [(1042, '    pub unsafe fn insert_vmexternref(&mut self, r: VMExternRef) {'), (1043, '        self.externref_activations_table'), (1044, '            .insert_with_gc(r, &self.modules)')]}",
    "num_lines_added": "56",
    "num_lines_deleted": "3",
    "nloc": "852"
  },
  {
    "file_change_id": "31489565923584",
    "hash": "d2ce1ac753afc059e32798bac3383b81a6d04456",
    "old_path": "crates/wasmtime/src/types.rs",
    "new_path": "crates/wasmtime/src/types.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -230,21 +230,21 @@ impl FuncType {\n         results: impl IntoIterator<Item = ValType>,\n     ) -> FuncType {\n         FuncType {\n-            sig: WasmFuncType {\n-                params: params.into_iter().map(|t| t.to_wasm_type()).collect(),\n-                returns: results.into_iter().map(|t| t.to_wasm_type()).collect(),\n-            },\n+            sig: WasmFuncType::new(\n+                params.into_iter().map(|t| t.to_wasm_type()).collect(),\n+                results.into_iter().map(|t| t.to_wasm_type()).collect(),\n+            ),\n         }\n     }\n \n     /// Returns the list of parameter types for this function.\n     pub fn params(&self) -> impl ExactSizeIterator<Item = ValType> + '_ {\n-        self.sig.params.iter().map(ValType::from_wasm_type)\n+        self.sig.params().iter().map(ValType::from_wasm_type)\n     }\n \n     /// Returns the list of result types for this function.\n     pub fn results(&self) -> impl ExactSizeIterator<Item = ValType> + '_ {\n-        self.sig.returns.iter().map(ValType::from_wasm_type)\n+        self.sig.returns().iter().map(ValType::from_wasm_type)\n     }\n \n     pub(crate) fn as_wasm_func_type(&self) -> &WasmFuncType {\n",
    "diff_parsed": "{'added': [(233, '            sig: WasmFuncType::new('), (234, '                params.into_iter().map(|t| t.to_wasm_type()).collect(),'), (235, '                results.into_iter().map(|t| t.to_wasm_type()).collect(),'), (236, '            ),'), (242, '        self.sig.params().iter().map(ValType::from_wasm_type)'), (247, '        self.sig.returns().iter().map(ValType::from_wasm_type)')], 'deleted': [(233, '            sig: WasmFuncType {'), (234, '                params: params.into_iter().map(|t| t.to_wasm_type()).collect(),'), (235, '                returns: results.into_iter().map(|t| t.to_wasm_type()).collect(),'), (236, '            },'), (242, '        self.sig.params.iter().map(ValType::from_wasm_type)'), (247, '        self.sig.returns.iter().map(ValType::from_wasm_type)')]}",
    "num_lines_added": "6",
    "num_lines_deleted": "6",
    "nloc": "472"
  },
  {
    "file_change_id": "140512921033153",
    "hash": "d2ce1ac753afc059e32798bac3383b81a6d04456",
    "old_path": "crates/wasmtime/src/values.rs",
    "new_path": "crates/wasmtime/src/values.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -93,17 +93,17 @@ impl Val {\n         }\n     }\n \n-    pub(crate) unsafe fn write_value_to(&self, store: &mut StoreOpaque, p: *mut u128) {\n-        match self {\n-            Val::I32(i) => ptr::write(p as *mut i32, *i),\n-            Val::I64(i) => ptr::write(p as *mut i64, *i),\n-            Val::F32(u) => ptr::write(p as *mut u32, *u),\n-            Val::F64(u) => ptr::write(p as *mut u64, *u),\n-            Val::V128(b) => ptr::write(p as *mut u128, *b),\n+    pub(crate) unsafe fn write_value_without_gc(&self, store: &mut StoreOpaque, p: *mut u128) {\n+        match *self {\n+            Val::I32(i) => ptr::write(p as *mut i32, i),\n+            Val::I64(i) => ptr::write(p as *mut i64, i),\n+            Val::F32(u) => ptr::write(p as *mut u32, u),\n+            Val::F64(u) => ptr::write(p as *mut u64, u),\n+            Val::V128(b) => ptr::write(p as *mut u128, b),\n             Val::ExternRef(None) => ptr::write(p, 0),\n-            Val::ExternRef(Some(x)) => {\n+            Val::ExternRef(Some(ref x)) => {\n                 let externref_ptr = x.inner.as_raw();\n-                store.insert_vmexternref(x.inner.clone());\n+                store.insert_vmexternref_without_gc(x.clone().inner);\n                 ptr::write(p as *mut *mut u8, externref_ptr)\n             }\n             Val::FuncRef(f) => ptr::write(\n",
    "diff_parsed": "{'added': [(96, '    pub(crate) unsafe fn write_value_without_gc(&self, store: &mut StoreOpaque, p: *mut u128) {'), (97, '        match *self {'), (98, '            Val::I32(i) => ptr::write(p as *mut i32, i),'), (99, '            Val::I64(i) => ptr::write(p as *mut i64, i),'), (100, '            Val::F32(u) => ptr::write(p as *mut u32, u),'), (101, '            Val::F64(u) => ptr::write(p as *mut u64, u),'), (102, '            Val::V128(b) => ptr::write(p as *mut u128, b),'), (104, '            Val::ExternRef(Some(ref x)) => {'), (106, '                store.insert_vmexternref_without_gc(x.clone().inner);')], 'deleted': [(96, '    pub(crate) unsafe fn write_value_to(&self, store: &mut StoreOpaque, p: *mut u128) {'), (97, '        match self {'), (98, '            Val::I32(i) => ptr::write(p as *mut i32, *i),'), (99, '            Val::I64(i) => ptr::write(p as *mut i64, *i),'), (100, '            Val::F32(u) => ptr::write(p as *mut u32, *u),'), (101, '            Val::F64(u) => ptr::write(p as *mut u64, *u),'), (102, '            Val::V128(b) => ptr::write(p as *mut u128, *b),'), (104, '            Val::ExternRef(Some(x)) => {'), (106, '                store.insert_vmexternref(x.inner.clone());')]}",
    "num_lines_added": "9",
    "num_lines_deleted": "9",
    "nloc": "232"
  },
  {
    "file_change_id": "157039742032158",
    "hash": "d2ce1ac753afc059e32798bac3383b81a6d04456",
    "old_path": "tests/all/gc.rs",
    "new_path": "tests/all/gc.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -424,3 +424,56 @@ fn global_init_no_leak() -> anyhow::Result<()> {\n \n     Ok(())\n }\n+\n+#[test]\n+fn no_gc_middle_of_args() -> anyhow::Result<()> {\n+    let (mut store, module) = ref_types_module(\n+        r#\"\n+            (module\n+                (import \"\" \"return_some\" (func $return (result externref externref externref)))\n+                (import \"\" \"take_some\" (func $take (param externref externref externref)))\n+                (func (export \"run\")\n+                    (local i32)\n+                    i32.const 1000\n+                    local.set 0\n+                    loop\n+                        call $return\n+                        call $take\n+                        local.get 0\n+                        i32.const -1\n+                        i32.add\n+                        local.tee 0\n+                        br_if 0\n+                    end\n+                )\n+            )\n+        \"#,\n+    )?;\n+\n+    let mut linker = Linker::new(store.engine());\n+    linker.func_wrap(\"\", \"return_some\", || {\n+        (\n+            Some(ExternRef::new(\"a\".to_string())),\n+            Some(ExternRef::new(\"b\".to_string())),\n+            Some(ExternRef::new(\"c\".to_string())),\n+        )\n+    })?;\n+    linker.func_wrap(\n+        \"\",\n+        \"take_some\",\n+        |a: Option<ExternRef>, b: Option<ExternRef>, c: Option<ExternRef>| {\n+            let a = a.unwrap();\n+            let b = b.unwrap();\n+            let c = c.unwrap();\n+            assert_eq!(a.data().downcast_ref::<String>().unwrap(), \"a\");\n+            assert_eq!(b.data().downcast_ref::<String>().unwrap(), \"b\");\n+            assert_eq!(c.data().downcast_ref::<String>().unwrap(), \"c\");\n+        },\n+    )?;\n+\n+    let instance = linker.instantiate(&mut store, &module)?;\n+    let func = instance.get_typed_func::<(), (), _>(&mut store, \"run\")?;\n+    func.call(&mut store, ())?;\n+\n+    Ok(())\n+}\n",
    "diff_parsed": "{'added': [(428, '#[test]'), (429, 'fn no_gc_middle_of_args() -> anyhow::Result<()> {'), (430, '    let (mut store, module) = ref_types_module('), (431, '        r#\"'), (432, '            (module'), (433, '                (import \"\" \"return_some\" (func $return (result externref externref externref)))'), (434, '                (import \"\" \"take_some\" (func $take (param externref externref externref)))'), (435, '                (func (export \"run\")'), (436, '                    (local i32)'), (437, '                    i32.const 1000'), (438, '                    local.set 0'), (439, '                    loop'), (440, '                        call $return'), (441, '                        call $take'), (442, '                        local.get 0'), (443, '                        i32.const -1'), (444, '                        i32.add'), (445, '                        local.tee 0'), (446, '                        br_if 0'), (447, '                    end'), (448, '                )'), (449, '            )'), (450, '        \"#,'), (451, '    )?;'), (453, '    let mut linker = Linker::new(store.engine());'), (454, '    linker.func_wrap(\"\", \"return_some\", || {'), (455, '        ('), (456, '            Some(ExternRef::new(\"a\".to_string())),'), (457, '            Some(ExternRef::new(\"b\".to_string())),'), (458, '            Some(ExternRef::new(\"c\".to_string())),'), (459, '        )'), (460, '    })?;'), (461, '    linker.func_wrap('), (462, '        \"\",'), (463, '        \"take_some\",'), (464, '        |a: Option<ExternRef>, b: Option<ExternRef>, c: Option<ExternRef>| {'), (465, '            let a = a.unwrap();'), (466, '            let b = b.unwrap();'), (467, '            let c = c.unwrap();'), (468, '            assert_eq!(a.data().downcast_ref::<String>().unwrap(), \"a\");'), (469, '            assert_eq!(b.data().downcast_ref::<String>().unwrap(), \"b\");'), (470, '            assert_eq!(c.data().downcast_ref::<String>().unwrap(), \"c\");'), (471, '        },'), (472, '    )?;'), (474, '    let instance = linker.instantiate(&mut store, &module)?;'), (475, '    let func = instance.get_typed_func::<(), (), _>(&mut store, \"run\")?;'), (476, '    func.call(&mut store, ())?;'), (478, '    Ok(())'), (479, '}')], 'deleted': []}",
    "num_lines_added": "49",
    "num_lines_deleted": "0",
    "nloc": "405"
  },
  {
    "file_change_id": "82531178689666",
    "hash": "11ba23a9766a5079918cd9f515bc100bc8164b50",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -7,7 +7,7 @@\n         unused_variables, non_shorthand_field_patterns,\n         unreachable_code, unused_parens)]\n \n-#![no_std]\n+#![cfg_attr(not(feature = \"std\"), no_std)]\n \n #[macro_use]\n mod field;\n",
    "diff_parsed": "{'added': [(10, '#![cfg_attr(not(feature = \"std\"), no_std)]')], 'deleted': [(10, '#![no_std]')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "489"
  },
  {
    "file_change_id": "38841808529288",
    "hash": "11ba23a9766a5079918cd9f515bc100bc8164b50",
    "old_path": "src/scalar.rs",
    "new_path": "src/scalar.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,4 +1,5 @@\n use core::ops::{Add, AddAssign, Mul, MulAssign};\n+use subtle::Choice;\n \n const SECP256K1_N_0: u32 = 0xD0364141;\n const SECP256K1_N_1: u32 = 0xBFD25E8C;\n@@ -69,21 +70,21 @@ impl Scalar {\n \n     #[must_use]\n     fn check_overflow(&self) -> bool {\n-        let mut yes: bool = false;\n-        let mut no: bool = false;\n-        no = no || (self.0[7] < SECP256K1_N_7); /* No need for a > check. */\n-        no = no || (self.0[6] < SECP256K1_N_6); /* No need for a > check. */\n-        no = no || (self.0[5] < SECP256K1_N_5); /* No need for a > check. */\n-        no = no || (self.0[4] < SECP256K1_N_4);\n-        yes = yes || ((self.0[4] > SECP256K1_N_4) && !no);\n-        no = no || ((self.0[3] < SECP256K1_N_3) && !yes);\n-        yes = yes || ((self.0[3] > SECP256K1_N_3) && !no);\n-        no = no || ((self.0[2] < SECP256K1_N_2) && !yes);\n-        yes = yes || ((self.0[2] > SECP256K1_N_2) && !no);\n-        no = no || ((self.0[1] < SECP256K1_N_1) && !yes);\n-        yes = yes || ((self.0[1] > SECP256K1_N_1) && !no);\n-        yes = yes || ((self.0[0] >= SECP256K1_N_0) && !no);\n-        return yes;\n+        let mut yes: Choice = 0.into();\n+        let mut no: Choice = 0.into();\n+        no |= Choice::from((self.0[7] < SECP256K1_N_7) as u8); /* No need for a > check. */\n+        no |= Choice::from((self.0[6] < SECP256K1_N_6) as u8); /* No need for a > check. */\n+        no |= Choice::from((self.0[5] < SECP256K1_N_5) as u8); /* No need for a > check. */\n+        no |= Choice::from((self.0[4] < SECP256K1_N_4) as u8);\n+        yes |= Choice::from((self.0[4] > SECP256K1_N_4) as u8) & !no;\n+        no |= Choice::from((self.0[3] < SECP256K1_N_3) as u8) & !yes;\n+        yes |= Choice::from((self.0[3] > SECP256K1_N_3) as u8) & !no;\n+        no |= Choice::from((self.0[2] < SECP256K1_N_2) as u8) & !yes;\n+        yes |= Choice::from((self.0[2] > SECP256K1_N_2) as u8) & !no;\n+        no |= Choice::from((self.0[1] < SECP256K1_N_1) as u8) & !yes;\n+        yes |= Choice::from((self.0[1] > SECP256K1_N_1) as u8) & !no;\n+        yes |= Choice::from((self.0[0] >= SECP256K1_N_0) as u8) & !no;\n+        return yes.into();\n     }\n \n     #[must_use]\n",
    "diff_parsed": "{'added': [(2, 'use subtle::Choice;'), (73, '        let mut yes: Choice = 0.into();'), (74, '        let mut no: Choice = 0.into();'), (75, '        no |= Choice::from((self.0[7] < SECP256K1_N_7) as u8); /* No need for a > check. */'), (76, '        no |= Choice::from((self.0[6] < SECP256K1_N_6) as u8); /* No need for a > check. */'), (77, '        no |= Choice::from((self.0[5] < SECP256K1_N_5) as u8); /* No need for a > check. */'), (78, '        no |= Choice::from((self.0[4] < SECP256K1_N_4) as u8);'), (79, '        yes |= Choice::from((self.0[4] > SECP256K1_N_4) as u8) & !no;'), (80, '        no |= Choice::from((self.0[3] < SECP256K1_N_3) as u8) & !yes;'), (81, '        yes |= Choice::from((self.0[3] > SECP256K1_N_3) as u8) & !no;'), (82, '        no |= Choice::from((self.0[2] < SECP256K1_N_2) as u8) & !yes;'), (83, '        yes |= Choice::from((self.0[2] > SECP256K1_N_2) as u8) & !no;'), (84, '        no |= Choice::from((self.0[1] < SECP256K1_N_1) as u8) & !yes;'), (85, '        yes |= Choice::from((self.0[1] > SECP256K1_N_1) as u8) & !no;'), (86, '        yes |= Choice::from((self.0[0] >= SECP256K1_N_0) as u8) & !no;'), (87, '        return yes.into();')], 'deleted': [(72, '        let mut yes: bool = false;'), (73, '        let mut no: bool = false;'), (74, '        no = no || (self.0[7] < SECP256K1_N_7); /* No need for a > check. */'), (75, '        no = no || (self.0[6] < SECP256K1_N_6); /* No need for a > check. */'), (76, '        no = no || (self.0[5] < SECP256K1_N_5); /* No need for a > check. */'), (77, '        no = no || (self.0[4] < SECP256K1_N_4);'), (78, '        yes = yes || ((self.0[4] > SECP256K1_N_4) && !no);'), (79, '        no = no || ((self.0[3] < SECP256K1_N_3) && !yes);'), (80, '        yes = yes || ((self.0[3] > SECP256K1_N_3) && !no);'), (81, '        no = no || ((self.0[2] < SECP256K1_N_2) && !yes);'), (82, '        yes = yes || ((self.0[2] > SECP256K1_N_2) && !no);'), (83, '        no = no || ((self.0[1] < SECP256K1_N_1) && !yes);'), (84, '        yes = yes || ((self.0[1] > SECP256K1_N_1) && !no);'), (85, '        yes = yes || ((self.0[0] >= SECP256K1_N_0) && !no);'), (86, '        return yes;')]}",
    "num_lines_added": "16",
    "num_lines_deleted": "15",
    "nloc": "859"
  },
  {
    "file_change_id": "59914611601202",
    "hash": "2a4d53809e3000f40085f2b229b6b1a33759881d",
    "old_path": "src/stack.rs",
    "new_path": "src/stack.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -53,7 +53,8 @@ impl<T: ?Sized, D: ::DataBuf> StackA<T, D> {\n         mem::size_of::<&T>() / mem::size_of::<usize>() - 1\n     }\n \n-    fn push_inner(&mut self, fat_ptr: &T) -> Result<&mut [usize], ()> {\n+\t/// Returns the metadata and data slots\n+    fn push_inner(&mut self, fat_ptr: &T) -> Result<(&mut [usize],&mut [usize]), ()> {\n         let bytes = mem::size_of_val(fat_ptr);\n         let words = super::round_to_words(bytes) + Self::meta_words();\n         // Check if there is sufficient space for the new item\n@@ -71,7 +72,7 @@ impl<T: ?Sized, D: ::DataBuf> StackA<T, D> {\n             meta.clone_from_slice(&ptr_words[1..]);\n \n             // Increment offset and return\n-            Ok(rv)\n+            Ok( (meta, rv) )\n         } else {\n             Err(())\n         }\n@@ -94,7 +95,7 @@ impl<T: ?Sized, D: ::DataBuf> StackA<T, D> {\n         );\n \n         match self.push_inner(f(&v)) {\n-            Ok(d) => {\n+            Ok((_,d)) => {\n                 // SAFE: Destination address is valid\n                 unsafe {\n                     ptr::write(d.as_mut_ptr() as *mut U, v);\n@@ -143,7 +144,7 @@ impl<T: ?Sized, D: ::DataBuf> StackA<T, D> {\n impl<D: ::DataBuf> StackA<str, D> {\n     /// Push the contents of a string slice as an item onto the stack\n     pub fn push_str(&mut self, v: &str) -> Result<(), ()> {\n-        self.push_inner(v).map(|d| unsafe {\n+        self.push_inner(v).map(|(_,d)| unsafe {\n             ptr::copy(v.as_bytes().as_ptr(), d.as_mut_ptr() as *mut u8, v.len());\n         })\n     }\n@@ -151,12 +152,24 @@ impl<D: ::DataBuf> StackA<str, D> {\n impl<D: ::DataBuf, T: Clone> StackA<[T], D> {\n     /// Pushes a set of items (cloning out of the input slice)\n     pub fn push_cloned(&mut self, v: &[T]) -> Result<(), ()> {\n-        self.push_inner(&v).map(|d| unsafe {\n-            let mut ptr = d.as_mut_ptr() as *mut T;\n-            for val in v {\n-                ptr::write(ptr, val.clone());\n-                ptr = ptr.offset(1);\n-            }\n-        })\n+        let (meta,d) = self.push_inner(&v)?;\n+\t\t// Prepare the slot with zeros (as if it's an empty slice)\n+\t\t// The length is updated as each item is written\n+\t\t// - This ensures that there's no drop issues during write\n+\t\tmeta[0] = 0;\n+\t\tfor v in d.iter_mut() {\n+\t\t\t*v = 0;\n+\t\t}\n+\n+\t\tunsafe {\n+\t\t\tlet mut ptr = d.as_mut_ptr() as *mut T;\n+\t\t\tfor val in v {\n+\t\t\t\tptr::write(ptr, val.clone());\n+\t\t\t\tmeta[0] += 1;\n+\t\t\t\tptr = ptr.offset(1);\n+\t\t\t}\n+\t\t}\n+\n+\t\tOk( () )\n     }\n }\n",
    "diff_parsed": "{'added': [(57, '    fn push_inner(&mut self, fat_ptr: &T) -> Result<(&mut [usize],&mut [usize]), ()> {'), (75, '            Ok( (meta, rv) )'), (98, '            Ok((_,d)) => {'), (147, '        self.push_inner(v).map(|(_,d)| unsafe {'), (155, '        let (meta,d) = self.push_inner(&v)?;'), (159, '\\t\\tmeta[0] = 0;'), (160, '\\t\\tfor v in d.iter_mut() {'), (161, '\\t\\t\\t*v = 0;'), (162, '\\t\\t}'), (164, '\\t\\tunsafe {'), (165, '\\t\\t\\tlet mut ptr = d.as_mut_ptr() as *mut T;'), (166, '\\t\\t\\tfor val in v {'), (167, '\\t\\t\\t\\tptr::write(ptr, val.clone());'), (168, '\\t\\t\\t\\tmeta[0] += 1;'), (169, '\\t\\t\\t\\tptr = ptr.offset(1);'), (170, '\\t\\t\\t}'), (171, '\\t\\t}'), (173, '\\t\\tOk( () )')], 'deleted': [(56, '    fn push_inner(&mut self, fat_ptr: &T) -> Result<&mut [usize], ()> {'), (74, '            Ok(rv)'), (97, '            Ok(d) => {'), (146, '        self.push_inner(v).map(|d| unsafe {'), (154, '        self.push_inner(&v).map(|d| unsafe {'), (155, '            let mut ptr = d.as_mut_ptr() as *mut T;'), (156, '            for val in v {'), (157, '                ptr::write(ptr, val.clone());'), (158, '                ptr = ptr.offset(1);'), (159, '            }'), (160, '        })')]}",
    "num_lines_added": "18",
    "num_lines_deleted": "11",
    "nloc": "123"
  },
  {
    "file_change_id": "201035522523631",
    "hash": "2a4d53809e3000f40085f2b229b6b1a33759881d",
    "old_path": "tests/stack.rs",
    "new_path": "tests/stack.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -114,3 +114,34 @@ fn destructors() {\n     drop(stack);\n     assert_eq!(v.get(), 2 + 3);\n }\n+\n+#[test]\n+fn slice_push_panic_safety() {\n+\tuse std::sync::atomic::{AtomicUsize,Ordering};\n+\tstatic COUNT: AtomicUsize = AtomicUsize::new(0);\n+\tstruct Sentinel(bool);\n+\timpl Clone for Sentinel {\n+\t\tfn clone(&self) -> Self {\n+\t\t\tif self.0 {\n+\t\t\t\tpanic!();\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tSentinel(self.0)\n+\t\t\t}\n+\t\t}\n+\t}\n+\timpl Drop for Sentinel {\n+\t\tfn drop(&mut self) {\n+\t\t\tCOUNT.fetch_add(1, Ordering::SeqCst);\n+\t\t}\n+\t}\n+\tlet input = [Sentinel(false), Sentinel(true)];\n+\n+\n+\tlet _ = ::std::panic::catch_unwind(::std::panic::AssertUnwindSafe(|| {\n+\t\tlet mut stack = ::stack_dst::StackA::<[Sentinel], [usize; 8]>::new();\n+\t\tlet _ = stack.push_cloned(&input);\n+\t\t}));\n+\tassert_eq!(COUNT.load(Ordering::SeqCst), 1);\n+}\n+\n",
    "diff_parsed": "{'added': [(118, '#[test]'), (119, 'fn slice_push_panic_safety() {'), (120, '\\tuse std::sync::atomic::{AtomicUsize,Ordering};'), (121, '\\tstatic COUNT: AtomicUsize = AtomicUsize::new(0);'), (122, '\\tstruct Sentinel(bool);'), (123, '\\timpl Clone for Sentinel {'), (124, '\\t\\tfn clone(&self) -> Self {'), (125, '\\t\\t\\tif self.0 {'), (126, '\\t\\t\\t\\tpanic!();'), (127, '\\t\\t\\t}'), (128, '\\t\\t\\telse {'), (129, '\\t\\t\\t\\tSentinel(self.0)'), (130, '\\t\\t\\t}'), (131, '\\t\\t}'), (132, '\\t}'), (133, '\\timpl Drop for Sentinel {'), (134, '\\t\\tfn drop(&mut self) {'), (135, '\\t\\t\\tCOUNT.fetch_add(1, Ordering::SeqCst);'), (136, '\\t\\t}'), (137, '\\t}'), (138, '\\tlet input = [Sentinel(false), Sentinel(true)];'), (141, '\\tlet _ = ::std::panic::catch_unwind(::std::panic::AssertUnwindSafe(|| {'), (142, '\\t\\tlet mut stack = ::stack_dst::StackA::<[Sentinel], [usize; 8]>::new();'), (143, '\\t\\tlet _ = stack.push_cloned(&input);'), (144, '\\t\\t}));'), (145, '\\tassert_eq!(COUNT.load(Ordering::SeqCst), 1);'), (146, '}')], 'deleted': []}",
    "num_lines_added": "27",
    "num_lines_deleted": "0",
    "nloc": "119"
  },
  {
    "file_change_id": "2727197405810",
    "hash": "5ba218ac29df4786b002d7d12b47fa0c04a331f2",
    "old_path": "nanorand/src/gen.rs",
    "new_path": "nanorand/src/gen.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -101,44 +101,44 @@ impl<R: RNG> RandomRange<R> for usize {\n \n impl<R: RNG> RandomGen<R> for u32 {\n \tfn random(r: &mut R) -> Self {\n-\t\t(r.generate::<u64>() >> 32) as u32\n+\t\tr.generate::<u64>() as u32\n \t}\n }\n \n impl<R: RNG> RandomRange<R> for u32 {\n \tfn random_range(r: &mut R, lower: u32, upper: u32) -> Self {\n-\t\t(r.generate_range::<u64>(lower as u64, upper as u64) >> 32) as u32\n+\t\tr.generate_range::<u64>(lower as u64, upper as u64) as u32\n \t}\n }\n \n impl<R: RNG> RandomGen<R> for u16 {\n \tfn random(r: &mut R) -> Self {\n-\t\t(r.generate::<u64>() >> 16) as u16\n+\t\tr.generate::<u64>() as u16\n \t}\n }\n \n impl<R: RNG> RandomRange<R> for u16 {\n \tfn random_range(r: &mut R, lower: u16, upper: u16) -> Self {\n-\t\t(r.generate_range::<u64>(lower as u64, upper as u64) >> 16) as u16\n+\t\tr.generate_range::<u64>(lower as u64, upper as u64) as u16\n \t}\n }\n \n impl<R: RNG> RandomGen<R> for u8 {\n \tfn random(r: &mut R) -> Self {\n-\t\t(r.generate::<u64>() >> 8) as u8\n+\t\tr.generate::<u64>() as u8\n \t}\n }\n \n impl<R: RNG> RandomRange<R> for u8 {\n \tfn random_range(r: &mut R, lower: u8, upper: u8) -> Self {\n-\t\t(r.generate_range::<u64>(lower as u64, upper as u64) >> 8) as u8\n+\t\tr.generate_range::<u64>(lower as u64, upper as u64) as u8\n \t}\n }\n \n impl<R: RNG> RandomRange<R> for char {\n \tfn random_range(r: &mut R, lower: char, upper: char) -> Self {\n \t\tloop {\n-\t\t\tlet ret = (r.generate_range::<u64>(lower as u64, upper as u64) >> 32) as u32;\n+\t\t\tlet ret = r.generate_range::<u64>(lower as u64, upper as u64) as u32;\n \t\t\tif let Some(c) = core::char::from_u32(ret) {\n \t\t\t\tbreak c;\n \t\t\t}\n",
    "diff_parsed": "{'added': [(104, '\\t\\tr.generate::<u64>() as u32'), (110, '\\t\\tr.generate_range::<u64>(lower as u64, upper as u64) as u32'), (116, '\\t\\tr.generate::<u64>() as u16'), (122, '\\t\\tr.generate_range::<u64>(lower as u64, upper as u64) as u16'), (128, '\\t\\tr.generate::<u64>() as u8'), (134, '\\t\\tr.generate_range::<u64>(lower as u64, upper as u64) as u8'), (141, '\\t\\t\\tlet ret = r.generate_range::<u64>(lower as u64, upper as u64) as u32;')], 'deleted': [(104, '\\t\\t(r.generate::<u64>() >> 32) as u32'), (110, '\\t\\t(r.generate_range::<u64>(lower as u64, upper as u64) >> 32) as u32'), (116, '\\t\\t(r.generate::<u64>() >> 16) as u16'), (122, '\\t\\t(r.generate_range::<u64>(lower as u64, upper as u64) >> 16) as u16'), (128, '\\t\\t(r.generate::<u64>() >> 8) as u8'), (134, '\\t\\t(r.generate_range::<u64>(lower as u64, upper as u64) >> 8) as u8'), (141, '\\t\\t\\tlet ret = (r.generate_range::<u64>(lower as u64, upper as u64) >> 32) as u32;')]}",
    "num_lines_added": "7",
    "num_lines_deleted": "7",
    "nloc": "127"
  },
  {
    "file_change_id": "279751823512983",
    "hash": "7fd282aef7787577c385aed88cb25d004b85f494",
    "old_path": "pulse-binding/src/context/ext_device_manager.rs",
    "new_path": "pulse-binding/src/context/ext_device_manager.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -15,6 +15,7 @@\n \n //! Routines for controlling module-device-manager.\n \n+use std;\n use capi;\n use std::ffi::{CStr, CString};\n use std::borrow::Cow;\n@@ -308,13 +309,15 @@ extern \"C\"\n fn read_list_cb_proxy(_: *mut ContextInternal, i: *const InfoInternal, eol: i32,\n     userdata: *mut c_void)\n {\n-    match callback_for_list_instance::<dyn FnMut(ListResult<&Info>)>(eol, userdata) {\n-        ListInstanceCallback::Entry(callback) => {\n-            assert!(!i.is_null());\n-            let obj = Info::new_from_raw(i);\n-            callback(ListResult::Item(&obj));\n-        },\n-        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },\n-        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },\n-    }\n+    let _ = std::panic::catch_unwind(|| {\n+        match callback_for_list_instance::<dyn FnMut(ListResult<&Info>)>(eol, userdata) {\n+            ListInstanceCallback::Entry(callback) => {\n+                assert!(!i.is_null());\n+                let obj = Info::new_from_raw(i);\n+                (callback)(ListResult::Item(&obj));\n+            },\n+            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },\n+            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },\n+        }\n+    });\n }\n",
    "diff_parsed": "{'added': [(18, 'use std;'), (312, '    let _ = std::panic::catch_unwind(|| {'), (313, '        match callback_for_list_instance::<dyn FnMut(ListResult<&Info>)>(eol, userdata) {'), (314, '            ListInstanceCallback::Entry(callback) => {'), (315, '                assert!(!i.is_null());'), (316, '                let obj = Info::new_from_raw(i);'), (317, '                (callback)(ListResult::Item(&obj));'), (318, '            },'), (319, '            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },'), (320, '            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },'), (321, '        }'), (322, '    });')], 'deleted': [(311, '    match callback_for_list_instance::<dyn FnMut(ListResult<&Info>)>(eol, userdata) {'), (312, '        ListInstanceCallback::Entry(callback) => {'), (313, '            assert!(!i.is_null());'), (314, '            let obj = Info::new_from_raw(i);'), (315, '            callback(ListResult::Item(&obj));'), (316, '        },'), (317, '        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },'), (318, '        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },'), (319, '    }')]}",
    "num_lines_added": "12",
    "num_lines_deleted": "9",
    "nloc": "272"
  },
  {
    "file_change_id": "219297349290373",
    "hash": "7fd282aef7787577c385aed88cb25d004b85f494",
    "old_path": "pulse-binding/src/context/ext_device_restore.rs",
    "new_path": "pulse-binding/src/context/ext_device_restore.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -208,8 +208,10 @@ extern \"C\"\n fn ext_subscribe_cb_proxy(_: *mut ContextInternal, type_: ::def::Device, index: u32,\n     userdata: *mut c_void)\n {\n-    let callback = SubscribeCb::get_callback(userdata);\n-    callback(type_, index);\n+    let _ = std::panic::catch_unwind(|| {\n+        let callback = SubscribeCb::get_callback(userdata);\n+        (callback)(type_, index);\n+    });\n }\n \n /// Proxy for read list callbacks.\n@@ -218,13 +220,15 @@ extern \"C\"\n fn read_list_cb_proxy(_: *mut ContextInternal, i: *const InfoInternal, eol: i32,\n     userdata: *mut c_void)\n {\n-    match callback_for_list_instance::<dyn FnMut(ListResult<&Info>)>(eol, userdata) {\n-        ListInstanceCallback::Entry(callback) => {\n-            assert!(!i.is_null());\n-            let obj = Info::new_from_raw(i);\n-            callback(ListResult::Item(&obj));\n-        },\n-        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },\n-        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },\n-    }\n+    let _ = std::panic::catch_unwind(|| {\n+        match callback_for_list_instance::<dyn FnMut(ListResult<&Info>)>(eol, userdata) {\n+            ListInstanceCallback::Entry(callback) => {\n+                assert!(!i.is_null());\n+                let obj = Info::new_from_raw(i);\n+                (callback)(ListResult::Item(&obj));\n+            },\n+            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },\n+            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },\n+        }\n+    });\n }\n",
    "diff_parsed": "{'added': [(211, '    let _ = std::panic::catch_unwind(|| {'), (212, '        let callback = SubscribeCb::get_callback(userdata);'), (213, '        (callback)(type_, index);'), (214, '    });'), (223, '    let _ = std::panic::catch_unwind(|| {'), (224, '        match callback_for_list_instance::<dyn FnMut(ListResult<&Info>)>(eol, userdata) {'), (225, '            ListInstanceCallback::Entry(callback) => {'), (226, '                assert!(!i.is_null());'), (227, '                let obj = Info::new_from_raw(i);'), (228, '                (callback)(ListResult::Item(&obj));'), (229, '            },'), (230, '            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },'), (231, '            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },'), (232, '        }'), (233, '    });')], 'deleted': [(211, '    let callback = SubscribeCb::get_callback(userdata);'), (212, '    callback(type_, index);'), (221, '    match callback_for_list_instance::<dyn FnMut(ListResult<&Info>)>(eol, userdata) {'), (222, '        ListInstanceCallback::Entry(callback) => {'), (223, '            assert!(!i.is_null());'), (224, '            let obj = Info::new_from_raw(i);'), (225, '            callback(ListResult::Item(&obj));'), (226, '        },'), (227, '        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },'), (228, '        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },'), (229, '    }')]}",
    "num_lines_added": "15",
    "num_lines_deleted": "11",
    "nloc": "165"
  },
  {
    "file_change_id": "126339495411168",
    "hash": "7fd282aef7787577c385aed88cb25d004b85f494",
    "old_path": "pulse-binding/src/context/ext_stream_restore.rs",
    "new_path": "pulse-binding/src/context/ext_stream_restore.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -214,13 +214,15 @@ extern \"C\"\n fn read_list_cb_proxy(_: *mut ContextInternal, i: *const InfoInternal, eol: i32,\n     userdata: *mut c_void)\n {\n-    match callback_for_list_instance::<dyn FnMut(ListResult<&Info>)>(eol, userdata) {\n-        ListInstanceCallback::Entry(callback) => {\n-            assert!(!i.is_null());\n-            let obj = Info::new_from_raw(i);\n-            callback(ListResult::Item(&obj));\n-        },\n-        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },\n-        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },\n-    }\n+    let _ = std::panic::catch_unwind(|| {\n+        match callback_for_list_instance::<dyn FnMut(ListResult<&Info>)>(eol, userdata) {\n+            ListInstanceCallback::Entry(callback) => {\n+                assert!(!i.is_null());\n+                let obj = Info::new_from_raw(i);\n+                (callback)(ListResult::Item(&obj));\n+            },\n+            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },\n+            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },\n+        }\n+    });\n }\n",
    "diff_parsed": "{'added': [(217, '    let _ = std::panic::catch_unwind(|| {'), (218, '        match callback_for_list_instance::<dyn FnMut(ListResult<&Info>)>(eol, userdata) {'), (219, '            ListInstanceCallback::Entry(callback) => {'), (220, '                assert!(!i.is_null());'), (221, '                let obj = Info::new_from_raw(i);'), (222, '                (callback)(ListResult::Item(&obj));'), (223, '            },'), (224, '            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },'), (225, '            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },'), (226, '        }'), (227, '    });')], 'deleted': [(217, '    match callback_for_list_instance::<dyn FnMut(ListResult<&Info>)>(eol, userdata) {'), (218, '        ListInstanceCallback::Entry(callback) => {'), (219, '            assert!(!i.is_null());'), (220, '            let obj = Info::new_from_raw(i);'), (221, '            callback(ListResult::Item(&obj));'), (222, '        },'), (223, '        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },'), (224, '        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },'), (225, '    }')]}",
    "num_lines_added": "11",
    "num_lines_deleted": "9",
    "nloc": "188"
  },
  {
    "file_change_id": "110380108251506",
    "hash": "7fd282aef7787577c385aed88cb25d004b85f494",
    "old_path": "pulse-binding/src/context/introspect.rs",
    "new_path": "pulse-binding/src/context/introspect.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -652,15 +652,17 @@ extern \"C\"\n fn get_sink_info_list_cb_proxy(_: *mut ContextInternal, i: *const SinkInfoInternal, eol: i32,\n     userdata: *mut c_void)\n {\n-    match callback_for_list_instance::<dyn FnMut(ListResult<&SinkInfo>)>(eol, userdata) {\n-        ListInstanceCallback::Entry(callback) => {\n-            assert!(!i.is_null());\n-            let obj = SinkInfo::new_from_raw(i);\n-            callback(ListResult::Item(&obj));\n-        },\n-        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },\n-        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },\n-    }\n+    let _ = std::panic::catch_unwind(|| {\n+        match callback_for_list_instance::<dyn FnMut(ListResult<&SinkInfo>)>(eol, userdata) {\n+            ListInstanceCallback::Entry(callback) => {\n+                assert!(!i.is_null());\n+                let obj = SinkInfo::new_from_raw(i);\n+                (callback)(ListResult::Item(&obj));\n+            },\n+            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },\n+            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },\n+        }\n+    });\n }\n \n ////////////////////////////////////////////////////////////////////////////////////////////////////\n@@ -1036,15 +1038,17 @@ extern \"C\"\n fn get_source_info_list_cb_proxy(_: *mut ContextInternal, i: *const SourceInfoInternal, eol: i32,\n     userdata: *mut c_void)\n {\n-    match callback_for_list_instance::<dyn FnMut(ListResult<&SourceInfo>)>(eol, userdata) {\n-        ListInstanceCallback::Entry(callback) => {\n-            assert!(!i.is_null());\n-            let obj = SourceInfo::new_from_raw(i);\n-            callback(ListResult::Item(&obj));\n-        },\n-        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },\n-        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },\n-    }\n+    let _ = std::panic::catch_unwind(|| {\n+        match callback_for_list_instance::<dyn FnMut(ListResult<&SourceInfo>)>(eol, userdata) {\n+            ListInstanceCallback::Entry(callback) => {\n+                assert!(!i.is_null());\n+                let obj = SourceInfo::new_from_raw(i);\n+                (callback)(ListResult::Item(&obj));\n+            },\n+            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },\n+            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },\n+        }\n+    });\n }\n \n ////////////////////////////////////////////////////////////////////////////////////////////////////\n@@ -1136,12 +1140,14 @@ extern \"C\"\n fn get_server_info_cb_proxy(_: *mut ContextInternal, i: *const ServerInfoInternal,\n     userdata: *mut c_void)\n {\n-    assert!(!i.is_null());\n-    let obj = ServerInfo::new_from_raw(i);\n-\n-    // Note, destroys closure callback after use - restoring outer box means it gets dropped\n-    let mut callback = ::callbacks::get_su_callback::<dyn FnMut(&ServerInfo)>(userdata);\n-    callback(&obj);\n+    let _ = std::panic::catch_unwind(|| {\n+        assert!(!i.is_null());\n+        let obj = ServerInfo::new_from_raw(i);\n+\n+        // Note, destroys closure callback after use - restoring outer box means it gets dropped\n+        let mut callback = ::callbacks::get_su_callback::<dyn FnMut(&ServerInfo)>(userdata);\n+        (callback)(&obj);\n+    });\n }\n \n ////////////////////////////////////////////////////////////////////////////////////////////////////\n@@ -1262,24 +1268,28 @@ extern \"C\"\n fn mod_info_list_cb_proxy(_: *mut ContextInternal, i: *const ModuleInfoInternal, eol: i32,\n     userdata: *mut c_void)\n {\n-    match callback_for_list_instance::<dyn FnMut(ListResult<&ModuleInfo>)>(eol, userdata) {\n-        ListInstanceCallback::Entry(callback) => {\n-            assert!(!i.is_null());\n-            let obj = ModuleInfo::new_from_raw(i);\n-            callback(ListResult::Item(&obj));\n-        },\n-        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },\n-        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },\n-    }\n+    let _ = std::panic::catch_unwind(|| {\n+        match callback_for_list_instance::<dyn FnMut(ListResult<&ModuleInfo>)>(eol, userdata) {\n+            ListInstanceCallback::Entry(callback) => {\n+                assert!(!i.is_null());\n+                let obj = ModuleInfo::new_from_raw(i);\n+                (callback)(ListResult::Item(&obj));\n+            },\n+            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },\n+            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },\n+        }\n+    });\n }\n \n /// Proxy for context index callbacks.\n /// Warning: This is for single-use cases only! It destroys the actual closure callback.\n extern \"C\"\n fn context_index_cb_proxy(_: *mut ContextInternal, index: u32, userdata: *mut c_void) {\n-    // Note, destroys closure callback after use - restoring outer box means it gets dropped\n-    let mut callback = ::callbacks::get_su_callback::<dyn FnMut(u32)>(userdata);\n-    callback(index);\n+    let _ = std::panic::catch_unwind(|| {\n+        // Note, destroys closure callback after use - restoring outer box means it gets dropped\n+        let mut callback = ::callbacks::get_su_callback::<dyn FnMut(u32)>(userdata);\n+        (callback)(index);\n+    });\n }\n \n ////////////////////////////////////////////////////////////////////////////////////////////////////\n@@ -1380,15 +1390,17 @@ extern \"C\"\n fn get_client_info_list_cb_proxy(_: *mut ContextInternal, i: *const ClientInfoInternal, eol: i32,\n     userdata: *mut c_void)\n {\n-    match callback_for_list_instance::<dyn FnMut(ListResult<&ClientInfo>)>(eol, userdata) {\n-        ListInstanceCallback::Entry(callback) => {\n-            assert!(!i.is_null());\n-            let obj = ClientInfo::new_from_raw(i);\n-            callback(ListResult::Item(&obj));\n-        },\n-        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },\n-        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },\n-    }\n+    let _ = std::panic::catch_unwind(|| {\n+        match callback_for_list_instance::<dyn FnMut(ListResult<&ClientInfo>)>(eol, userdata) {\n+            ListInstanceCallback::Entry(callback) => {\n+                assert!(!i.is_null());\n+                let obj = ClientInfo::new_from_raw(i);\n+                (callback)(ListResult::Item(&obj));\n+            },\n+            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },\n+            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },\n+        }\n+    });\n }\n \n ////////////////////////////////////////////////////////////////////////////////////////////////////\n@@ -1690,15 +1702,17 @@ extern \"C\"\n fn get_card_info_list_cb_proxy(_: *mut ContextInternal, i: *const CardInfoInternal, eol: i32,\n     userdata: *mut c_void)\n {\n-    match callback_for_list_instance::<dyn FnMut(ListResult<&CardInfo>)>(eol, userdata) {\n-        ListInstanceCallback::Entry(callback) => {\n-            assert!(!i.is_null());\n-            let obj = CardInfo::new_from_raw(i);\n-            callback(ListResult::Item(&obj));\n-        },\n-        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },\n-        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },\n-    }\n+    let _ = std::panic::catch_unwind(|| {\n+        match callback_for_list_instance::<dyn FnMut(ListResult<&CardInfo>)>(eol, userdata) {\n+            ListInstanceCallback::Entry(callback) => {\n+                assert!(!i.is_null());\n+                let obj = CardInfo::new_from_raw(i);\n+                (callback)(ListResult::Item(&obj));\n+            },\n+            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },\n+            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },\n+        }\n+    });\n }\n \n ////////////////////////////////////////////////////////////////////////////////////////////////////\n@@ -1919,15 +1933,17 @@ extern \"C\"\n fn get_sink_input_info_list_cb_proxy(_: *mut ContextInternal, i: *const SinkInputInfoInternal,\n     eol: i32, userdata: *mut c_void)\n {\n-    match callback_for_list_instance::<dyn FnMut(ListResult<&SinkInputInfo>)>(eol, userdata) {\n-        ListInstanceCallback::Entry(callback) => {\n-            assert!(!i.is_null());\n-            let obj = SinkInputInfo::new_from_raw(i);\n-            callback(ListResult::Item(&obj));\n-        },\n-        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },\n-        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },\n-    }\n+    let _ = std::panic::catch_unwind(|| {\n+        match callback_for_list_instance::<dyn FnMut(ListResult<&SinkInputInfo>)>(eol, userdata) {\n+            ListInstanceCallback::Entry(callback) => {\n+                assert!(!i.is_null());\n+                let obj = SinkInputInfo::new_from_raw(i);\n+                (callback)(ListResult::Item(&obj));\n+            },\n+            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },\n+            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },\n+        }\n+    });\n }\n \n ////////////////////////////////////////////////////////////////////////////////////////////////////\n@@ -2148,15 +2164,17 @@ extern \"C\"\n fn get_source_output_info_list_cb_proxy(_: *mut ContextInternal, i: *const SourceOutputInfoInternal,\n     eol: i32, userdata: *mut c_void)\n {\n-    match callback_for_list_instance::<dyn FnMut(ListResult<&SourceOutputInfo>)>(eol, userdata) {\n-        ListInstanceCallback::Entry(callback) => {\n-            assert!(!i.is_null());\n-            let obj = SourceOutputInfo::new_from_raw(i);\n-            callback(ListResult::Item(&obj));\n-        },\n-        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },\n-        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },\n-    }\n+    let _ = std::panic::catch_unwind(|| {\n+        match callback_for_list_instance::<dyn FnMut(ListResult<&SourceOutputInfo>)>(eol, userdata) {\n+            ListInstanceCallback::Entry(callback) => {\n+                assert!(!i.is_null());\n+                let obj = SourceOutputInfo::new_from_raw(i);\n+                (callback)(ListResult::Item(&obj));\n+            },\n+            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },\n+            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },\n+        }\n+    });\n }\n \n ////////////////////////////////////////////////////////////////////////////////////////////////////\n@@ -2182,10 +2200,12 @@ impl Introspector {\n /// Warning: This is for single-use cases only! It destroys the actual closure callback.\n extern \"C\"\n fn get_stat_info_cb_proxy(_: *mut ContextInternal, i: *const StatInfo, userdata: *mut c_void) {\n-    assert!(!i.is_null());\n-    // Note, destroys closure callback after use - restoring outer box means it gets dropped\n-    let mut callback = ::callbacks::get_su_callback::<dyn FnMut(&StatInfo)>(userdata);\n-    callback(unsafe { i.as_ref().unwrap() });\n+    let _ = std::panic::catch_unwind(|| {\n+        assert!(!i.is_null());\n+        // Note, destroys closure callback after use - restoring outer box means it gets dropped\n+        let mut callback = ::callbacks::get_su_callback::<dyn FnMut(&StatInfo)>(userdata);\n+        (callback)(unsafe { i.as_ref().unwrap() });\n+    });\n }\n \n ////////////////////////////////////////////////////////////////////////////////////////////////////\n@@ -2301,13 +2321,15 @@ extern \"C\"\n fn get_sample_info_list_cb_proxy(_: *mut ContextInternal, i: *const SampleInfoInternal, eol: i32,\n     userdata: *mut c_void)\n {\n-    match callback_for_list_instance::<dyn FnMut(ListResult<&SampleInfo>)>(eol, userdata) {\n-        ListInstanceCallback::Entry(callback) => {\n-            assert!(!i.is_null());\n-            let obj = SampleInfo::new_from_raw(i);\n-            callback(ListResult::Item(&obj));\n-        },\n-        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },\n-        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },\n-    }\n+    let _ = std::panic::catch_unwind(|| {\n+        match callback_for_list_instance::<dyn FnMut(ListResult<&SampleInfo>)>(eol, userdata) {\n+            ListInstanceCallback::Entry(callback) => {\n+                assert!(!i.is_null());\n+                let obj = SampleInfo::new_from_raw(i);\n+                (callback)(ListResult::Item(&obj));\n+            },\n+            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },\n+            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },\n+        }\n+    });\n }\n",
    "diff_parsed": "{'added': [(655, '    let _ = std::panic::catch_unwind(|| {'), (656, '        match callback_for_list_instance::<dyn FnMut(ListResult<&SinkInfo>)>(eol, userdata) {'), (657, '            ListInstanceCallback::Entry(callback) => {'), (658, '                assert!(!i.is_null());'), (659, '                let obj = SinkInfo::new_from_raw(i);'), (660, '                (callback)(ListResult::Item(&obj));'), (661, '            },'), (662, '            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },'), (663, '            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },'), (664, '        }'), (665, '    });'), (1041, '    let _ = std::panic::catch_unwind(|| {'), (1042, '        match callback_for_list_instance::<dyn FnMut(ListResult<&SourceInfo>)>(eol, userdata) {'), (1043, '            ListInstanceCallback::Entry(callback) => {'), (1044, '                assert!(!i.is_null());'), (1045, '                let obj = SourceInfo::new_from_raw(i);'), (1046, '                (callback)(ListResult::Item(&obj));'), (1047, '            },'), (1048, '            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },'), (1049, '            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },'), (1050, '        }'), (1051, '    });'), (1143, '    let _ = std::panic::catch_unwind(|| {'), (1144, '        assert!(!i.is_null());'), (1145, '        let obj = ServerInfo::new_from_raw(i);'), (1148, '        let mut callback = ::callbacks::get_su_callback::<dyn FnMut(&ServerInfo)>(userdata);'), (1149, '        (callback)(&obj);'), (1150, '    });'), (1271, '    let _ = std::panic::catch_unwind(|| {'), (1272, '        match callback_for_list_instance::<dyn FnMut(ListResult<&ModuleInfo>)>(eol, userdata) {'), (1273, '            ListInstanceCallback::Entry(callback) => {'), (1274, '                assert!(!i.is_null());'), (1275, '                let obj = ModuleInfo::new_from_raw(i);'), (1276, '                (callback)(ListResult::Item(&obj));'), (1277, '            },'), (1278, '            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },'), (1279, '            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },'), (1280, '        }'), (1281, '    });'), (1288, '    let _ = std::panic::catch_unwind(|| {'), (1290, '        let mut callback = ::callbacks::get_su_callback::<dyn FnMut(u32)>(userdata);'), (1291, '        (callback)(index);'), (1292, '    });'), (1393, '    let _ = std::panic::catch_unwind(|| {'), (1394, '        match callback_for_list_instance::<dyn FnMut(ListResult<&ClientInfo>)>(eol, userdata) {'), (1395, '            ListInstanceCallback::Entry(callback) => {'), (1396, '                assert!(!i.is_null());'), (1397, '                let obj = ClientInfo::new_from_raw(i);'), (1398, '                (callback)(ListResult::Item(&obj));'), (1399, '            },'), (1400, '            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },'), (1401, '            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },'), (1402, '        }'), (1403, '    });'), (1705, '    let _ = std::panic::catch_unwind(|| {'), (1706, '        match callback_for_list_instance::<dyn FnMut(ListResult<&CardInfo>)>(eol, userdata) {'), (1707, '            ListInstanceCallback::Entry(callback) => {'), (1708, '                assert!(!i.is_null());'), (1709, '                let obj = CardInfo::new_from_raw(i);'), (1710, '                (callback)(ListResult::Item(&obj));'), (1711, '            },'), (1712, '            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },'), (1713, '            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },'), (1714, '        }'), (1715, '    });'), (1936, '    let _ = std::panic::catch_unwind(|| {'), (1937, '        match callback_for_list_instance::<dyn FnMut(ListResult<&SinkInputInfo>)>(eol, userdata) {'), (1938, '            ListInstanceCallback::Entry(callback) => {'), (1939, '                assert!(!i.is_null());'), (1940, '                let obj = SinkInputInfo::new_from_raw(i);'), (1941, '                (callback)(ListResult::Item(&obj));'), (1942, '            },'), (1943, '            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },'), (1944, '            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },'), (1945, '        }'), (1946, '    });'), (2167, '    let _ = std::panic::catch_unwind(|| {'), (2168, '        match callback_for_list_instance::<dyn FnMut(ListResult<&SourceOutputInfo>)>(eol, userdata) {'), (2169, '            ListInstanceCallback::Entry(callback) => {'), (2170, '                assert!(!i.is_null());'), (2171, '                let obj = SourceOutputInfo::new_from_raw(i);'), (2172, '                (callback)(ListResult::Item(&obj));'), (2173, '            },'), (2174, '            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },'), (2175, '            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },'), (2176, '        }'), (2177, '    });'), (2203, '    let _ = std::panic::catch_unwind(|| {'), (2204, '        assert!(!i.is_null());'), (2206, '        let mut callback = ::callbacks::get_su_callback::<dyn FnMut(&StatInfo)>(userdata);'), (2207, '        (callback)(unsafe { i.as_ref().unwrap() });'), (2208, '    });'), (2324, '    let _ = std::panic::catch_unwind(|| {'), (2325, '        match callback_for_list_instance::<dyn FnMut(ListResult<&SampleInfo>)>(eol, userdata) {'), (2326, '            ListInstanceCallback::Entry(callback) => {'), (2327, '                assert!(!i.is_null());'), (2328, '                let obj = SampleInfo::new_from_raw(i);'), (2329, '                (callback)(ListResult::Item(&obj));'), (2330, '            },'), (2331, '            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },'), (2332, '            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },'), (2333, '        }'), (2334, '    });')], 'deleted': [(655, '    match callback_for_list_instance::<dyn FnMut(ListResult<&SinkInfo>)>(eol, userdata) {'), (656, '        ListInstanceCallback::Entry(callback) => {'), (657, '            assert!(!i.is_null());'), (658, '            let obj = SinkInfo::new_from_raw(i);'), (659, '            callback(ListResult::Item(&obj));'), (660, '        },'), (661, '        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },'), (662, '        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },'), (663, '    }'), (1039, '    match callback_for_list_instance::<dyn FnMut(ListResult<&SourceInfo>)>(eol, userdata) {'), (1040, '        ListInstanceCallback::Entry(callback) => {'), (1041, '            assert!(!i.is_null());'), (1042, '            let obj = SourceInfo::new_from_raw(i);'), (1043, '            callback(ListResult::Item(&obj));'), (1044, '        },'), (1045, '        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },'), (1046, '        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },'), (1047, '    }'), (1139, '    assert!(!i.is_null());'), (1140, '    let obj = ServerInfo::new_from_raw(i);'), (1143, '    let mut callback = ::callbacks::get_su_callback::<dyn FnMut(&ServerInfo)>(userdata);'), (1144, '    callback(&obj);'), (1265, '    match callback_for_list_instance::<dyn FnMut(ListResult<&ModuleInfo>)>(eol, userdata) {'), (1266, '        ListInstanceCallback::Entry(callback) => {'), (1267, '            assert!(!i.is_null());'), (1268, '            let obj = ModuleInfo::new_from_raw(i);'), (1269, '            callback(ListResult::Item(&obj));'), (1270, '        },'), (1271, '        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },'), (1272, '        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },'), (1273, '    }'), (1281, '    let mut callback = ::callbacks::get_su_callback::<dyn FnMut(u32)>(userdata);'), (1282, '    callback(index);'), (1383, '    match callback_for_list_instance::<dyn FnMut(ListResult<&ClientInfo>)>(eol, userdata) {'), (1384, '        ListInstanceCallback::Entry(callback) => {'), (1385, '            assert!(!i.is_null());'), (1386, '            let obj = ClientInfo::new_from_raw(i);'), (1387, '            callback(ListResult::Item(&obj));'), (1388, '        },'), (1389, '        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },'), (1390, '        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },'), (1391, '    }'), (1693, '    match callback_for_list_instance::<dyn FnMut(ListResult<&CardInfo>)>(eol, userdata) {'), (1694, '        ListInstanceCallback::Entry(callback) => {'), (1695, '            assert!(!i.is_null());'), (1696, '            let obj = CardInfo::new_from_raw(i);'), (1697, '            callback(ListResult::Item(&obj));'), (1698, '        },'), (1699, '        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },'), (1700, '        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },'), (1701, '    }'), (1922, '    match callback_for_list_instance::<dyn FnMut(ListResult<&SinkInputInfo>)>(eol, userdata) {'), (1923, '        ListInstanceCallback::Entry(callback) => {'), (1924, '            assert!(!i.is_null());'), (1925, '            let obj = SinkInputInfo::new_from_raw(i);'), (1926, '            callback(ListResult::Item(&obj));'), (1927, '        },'), (1928, '        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },'), (1929, '        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },'), (1930, '    }'), (2151, '    match callback_for_list_instance::<dyn FnMut(ListResult<&SourceOutputInfo>)>(eol, userdata) {'), (2152, '        ListInstanceCallback::Entry(callback) => {'), (2153, '            assert!(!i.is_null());'), (2154, '            let obj = SourceOutputInfo::new_from_raw(i);'), (2155, '            callback(ListResult::Item(&obj));'), (2156, '        },'), (2157, '        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },'), (2158, '        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },'), (2159, '    }'), (2185, '    assert!(!i.is_null());'), (2187, '    let mut callback = ::callbacks::get_su_callback::<dyn FnMut(&StatInfo)>(userdata);'), (2188, '    callback(unsafe { i.as_ref().unwrap() });'), (2304, '    match callback_for_list_instance::<dyn FnMut(ListResult<&SampleInfo>)>(eol, userdata) {'), (2305, '        ListInstanceCallback::Entry(callback) => {'), (2306, '            assert!(!i.is_null());'), (2307, '            let obj = SampleInfo::new_from_raw(i);'), (2308, '            callback(ListResult::Item(&obj));'), (2309, '        },'), (2310, '        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },'), (2311, '        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },'), (2312, '    }')]}",
    "num_lines_added": "103",
    "num_lines_deleted": "81",
    "nloc": "1761"
  },
  {
    "file_change_id": "6675477981828",
    "hash": "7fd282aef7787577c385aed88cb25d004b85f494",
    "old_path": "pulse-binding/src/context/mod.rs",
    "new_path": "pulse-binding/src/context/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -599,21 +599,25 @@ impl Drop for Context {\n /// Warning: This is for single-use cases only! It destroys the actual closure callback.\n extern \"C\"\n fn success_cb_proxy(_: *mut ContextInternal, success: i32, userdata: *mut c_void) {\n-    assert!(!userdata.is_null());\n-    // Note, destroys closure callback after use - restoring outer box means it gets dropped\n-    let mut callback = unsafe { Box::from_raw(userdata as *mut Box<dyn FnMut(bool)>) };\n     let success_actual = match success { 0 => false, _ => true };\n-    callback(success_actual);\n+    let _ = std::panic::catch_unwind(|| {\n+        assert!(!userdata.is_null());\n+        // Note, destroys closure callback after use - restoring outer box means it gets dropped\n+        let mut callback = unsafe { Box::from_raw(userdata as *mut Box<dyn FnMut(bool)>) };\n+        (callback)(success_actual);\n+    });\n }\n \n /// Proxy for notification callbacks (single use).\n /// Warning: This is for single-use cases only! It destroys the actual closure callback.\n extern \"C\"\n fn notify_cb_proxy_single(_: *mut ContextInternal, userdata: *mut c_void) {\n-    assert!(!userdata.is_null());\n-    // Note, destroys closure callback after use - restoring outer box means it gets dropped\n-    let mut callback = unsafe { Box::from_raw(userdata as *mut Box<dyn FnMut()>) };\n-    callback();\n+    let _ = std::panic::catch_unwind(|| {\n+        assert!(!userdata.is_null());\n+        // Note, destroys closure callback after use - restoring outer box means it gets dropped\n+        let mut callback = unsafe { Box::from_raw(userdata as *mut Box<dyn FnMut()>) };\n+        (callback)();\n+    });\n }\n \n /// Proxy for notification callbacks (multi use).\n@@ -621,8 +625,10 @@ fn notify_cb_proxy_single(_: *mut ContextInternal, userdata: *mut c_void) {\n /// must be accomplished separately to avoid a memory leak.\n extern \"C\"\n fn notify_cb_proxy_multi(_: *mut ContextInternal, userdata: *mut c_void) {\n-    let callback = NotifyCb::get_callback(userdata);\n-    callback();\n+    let _ = std::panic::catch_unwind(|| {\n+        let callback = NotifyCb::get_callback(userdata);\n+        (callback)();\n+    });\n }\n \n /// Proxy for event callbacks.\n@@ -632,24 +638,28 @@ extern \"C\"\n fn event_cb_proxy(_: *mut ContextInternal, name: *const c_char,\n     proplist: *mut ::proplist::ProplistInternal, userdata: *mut c_void)\n {\n-    assert!(!name.is_null());\n-    let n = {\n-        let tmp = unsafe { CStr::from_ptr(name) };\n-        tmp.to_string_lossy().into_owned()\n-    };\n-    let pl = Proplist::from_raw_weak(proplist);\n-\n-    let callback = EventCb::get_callback(userdata);\n-    callback(n, pl);\n+    let _ = std::panic::catch_unwind(|| {\n+        assert!(!name.is_null());\n+        let n = {\n+            let tmp = unsafe { CStr::from_ptr(name) };\n+            tmp.to_string_lossy().into_owned()\n+        };\n+        let pl = Proplist::from_raw_weak(proplist);\n+\n+        let callback = EventCb::get_callback(userdata);\n+        (callback)(n, pl);\n+    });\n }\n \n /// Proxy for extension test callbacks.\n /// Warning: This is for single-use cases only! It destroys the actual closure callback.\n extern \"C\"\n fn ext_test_cb_proxy(_: *mut ContextInternal, version: u32, userdata: *mut c_void) {\n-    // Note, destroys closure callback after use - restoring outer box means it gets dropped\n-    let mut callback = ::callbacks::get_su_callback::<dyn FnMut(u32)>(userdata);\n-    callback(version);\n+    let _ = std::panic::catch_unwind(|| {\n+        // Note, destroys closure callback after use - restoring outer box means it gets dropped\n+        let mut callback = ::callbacks::get_su_callback::<dyn FnMut(u32)>(userdata);\n+        (callback)(version);\n+    });\n }\n \n /// Proxy for extension subscribe callbacks.\n@@ -657,6 +667,8 @@ fn ext_test_cb_proxy(_: *mut ContextInternal, version: u32, userdata: *mut c_voi\n /// must be accomplished separately to avoid a memory leak.\n extern \"C\"\n fn ext_subscribe_cb_proxy(_: *mut ContextInternal, userdata: *mut c_void) {\n-    let callback = ExtSubscribeCb::get_callback(userdata);\n-    callback();\n+    let _ = std::panic::catch_unwind(|| {\n+        let callback = ExtSubscribeCb::get_callback(userdata);\n+        (callback)();\n+    });\n }\n",
    "diff_parsed": "{'added': [(603, '    let _ = std::panic::catch_unwind(|| {'), (604, '        assert!(!userdata.is_null());'), (606, '        let mut callback = unsafe { Box::from_raw(userdata as *mut Box<dyn FnMut(bool)>) };'), (607, '        (callback)(success_actual);'), (608, '    });'), (615, '    let _ = std::panic::catch_unwind(|| {'), (616, '        assert!(!userdata.is_null());'), (618, '        let mut callback = unsafe { Box::from_raw(userdata as *mut Box<dyn FnMut()>) };'), (619, '        (callback)();'), (620, '    });'), (628, '    let _ = std::panic::catch_unwind(|| {'), (629, '        let callback = NotifyCb::get_callback(userdata);'), (630, '        (callback)();'), (631, '    });'), (641, '    let _ = std::panic::catch_unwind(|| {'), (642, '        assert!(!name.is_null());'), (643, '        let n = {'), (644, '            let tmp = unsafe { CStr::from_ptr(name) };'), (645, '            tmp.to_string_lossy().into_owned()'), (646, '        };'), (647, '        let pl = Proplist::from_raw_weak(proplist);'), (649, '        let callback = EventCb::get_callback(userdata);'), (650, '        (callback)(n, pl);'), (651, '    });'), (658, '    let _ = std::panic::catch_unwind(|| {'), (660, '        let mut callback = ::callbacks::get_su_callback::<dyn FnMut(u32)>(userdata);'), (661, '        (callback)(version);'), (662, '    });'), (670, '    let _ = std::panic::catch_unwind(|| {'), (671, '        let callback = ExtSubscribeCb::get_callback(userdata);'), (672, '        (callback)();'), (673, '    });')], 'deleted': [(602, '    assert!(!userdata.is_null());'), (604, '    let mut callback = unsafe { Box::from_raw(userdata as *mut Box<dyn FnMut(bool)>) };'), (606, '    callback(success_actual);'), (613, '    assert!(!userdata.is_null());'), (615, '    let mut callback = unsafe { Box::from_raw(userdata as *mut Box<dyn FnMut()>) };'), (616, '    callback();'), (624, '    let callback = NotifyCb::get_callback(userdata);'), (625, '    callback();'), (635, '    assert!(!name.is_null());'), (636, '    let n = {'), (637, '        let tmp = unsafe { CStr::from_ptr(name) };'), (638, '        tmp.to_string_lossy().into_owned()'), (639, '    };'), (640, '    let pl = Proplist::from_raw_weak(proplist);'), (642, '    let callback = EventCb::get_callback(userdata);'), (643, '    callback(n, pl);'), (651, '    let mut callback = ::callbacks::get_su_callback::<dyn FnMut(u32)>(userdata);'), (652, '    callback(version);'), (660, '    let callback = ExtSubscribeCb::get_callback(userdata);'), (661, '    callback();')]}",
    "num_lines_added": "32",
    "num_lines_deleted": "20",
    "nloc": "434"
  },
  {
    "file_change_id": "146758113252909",
    "hash": "7fd282aef7787577c385aed88cb25d004b85f494",
    "old_path": "pulse-binding/src/context/scache.rs",
    "new_path": "pulse-binding/src/context/scache.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -62,6 +62,7 @@\n //! [`::context::Context::play_sample`]: ../struct.Context.html#method.play_sample\n //! [`::context::Context::remove_sample`]: ../struct.Context.html#method.remove_sample\n \n+use std;\n use capi;\n use std::os::raw::{c_char, c_void};\n use std::ffi::CString;\n@@ -187,8 +188,9 @@ impl Context {\n extern \"C\"\n fn play_sample_success_cb_proxy(_: *mut ContextInternal, index: u32, userdata: *mut c_void) {\n     let index_actual = match index { ::def::INVALID_INDEX => Err(()), i => Ok(i) };\n-\n-    // Note, destroys closure callback after use - restoring outer box means it gets dropped\n-    let mut callback = ::callbacks::get_su_callback::<dyn FnMut(Result<u32, ()>)>(userdata);\n-    callback(index_actual);\n+    let _ = std::panic::catch_unwind(|| {\n+        // Note, destroys closure callback after use - restoring outer box means it gets dropped\n+        let mut callback = ::callbacks::get_su_callback::<dyn FnMut(Result<u32, ()>)>(userdata);\n+        (callback)(index_actual);\n+    });\n }\n",
    "diff_parsed": "{'added': [(65, 'use std;'), (191, '    let _ = std::panic::catch_unwind(|| {'), (193, '        let mut callback = ::callbacks::get_su_callback::<dyn FnMut(Result<u32, ()>)>(userdata);'), (194, '        (callback)(index_actual);'), (195, '    });')], 'deleted': [(192, '    let mut callback = ::callbacks::get_su_callback::<dyn FnMut(Result<u32, ()>)>(userdata);'), (193, '    callback(index_actual);')]}",
    "num_lines_added": "5",
    "num_lines_deleted": "2",
    "nloc": "90"
  },
  {
    "file_change_id": "218089879179644",
    "hash": "7fd282aef7787577c385aed88cb25d004b85f494",
    "old_path": "pulse-binding/src/context/subscribe.rs",
    "new_path": "pulse-binding/src/context/subscribe.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -56,6 +56,7 @@\n //! [`::context::Context::set_subscribe_callback`]: ../struct.Context.html#method.set_subscribe_callback\n //! [`subscription_masks`]: subscription_masks/index.html\n \n+use std;\n use capi;\n use std::os::raw::c_void;\n use super::{ContextInternal, Context};\n@@ -211,8 +212,10 @@ impl Context {\n /// must be accomplished separately to avoid a memory leak.\n extern \"C\"\n fn cb_proxy(_: *mut ContextInternal, et: EventType, index: u32, userdata: *mut c_void) {\n-    let facility = get_facility(et);\n-    let operation = get_operation(et);\n-    let callback = Callback::get_callback(userdata);\n-    callback(facility, operation, index);\n+    let _ = std::panic::catch_unwind(|| {\n+        let facility = get_facility(et);\n+        let operation = get_operation(et);\n+        let callback = Callback::get_callback(userdata);\n+        (callback)(facility, operation, index);\n+    });\n }\n",
    "diff_parsed": "{'added': [(59, 'use std;'), (215, '    let _ = std::panic::catch_unwind(|| {'), (216, '        let facility = get_facility(et);'), (217, '        let operation = get_operation(et);'), (218, '        let callback = Callback::get_callback(userdata);'), (219, '        (callback)(facility, operation, index);'), (220, '    });')], 'deleted': [(214, '    let facility = get_facility(et);'), (215, '    let operation = get_operation(et);'), (216, '    let callback = Callback::get_callback(userdata);'), (217, '    callback(facility, operation, index);')]}",
    "num_lines_added": "7",
    "num_lines_deleted": "4",
    "nloc": "122"
  },
  {
    "file_change_id": "169821688701106",
    "hash": "7fd282aef7787577c385aed88cb25d004b85f494",
    "old_path": "pulse-binding/src/mainloop/api.rs",
    "new_path": "pulse-binding/src/mainloop/api.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -378,7 +378,9 @@ impl<'a> From<&'a MainloopApi> for *const ApiInternal {\n /// Warning: This is for single-use cases only! It destroys the actual closure callback.\n extern \"C\"\n fn once_cb_proxy(_: *const ApiInternal, userdata: *mut c_void) {\n-    // Note, destroys closure callback after use - restoring outer box means it gets dropped\n-    let mut callback = ::callbacks::get_su_callback::<dyn FnMut()>(userdata);\n-    callback();\n+    let _ = std::panic::catch_unwind(|| {\n+        // Note, destroys closure callback after use - restoring outer box means it gets dropped\n+        let mut callback = ::callbacks::get_su_callback::<dyn FnMut()>(userdata);\n+        (callback)();\n+    });\n }\n",
    "diff_parsed": "{'added': [(381, '    let _ = std::panic::catch_unwind(|| {'), (383, '        let mut callback = ::callbacks::get_su_callback::<dyn FnMut()>(userdata);'), (384, '        (callback)();'), (385, '    });')], 'deleted': [(382, '    let mut callback = ::callbacks::get_su_callback::<dyn FnMut()>(userdata);'), (383, '    callback();')]}",
    "num_lines_added": "4",
    "num_lines_deleted": "2",
    "nloc": "273"
  },
  {
    "file_change_id": "37597071055933",
    "hash": "7fd282aef7787577c385aed88cb25d004b85f494",
    "old_path": "pulse-binding/src/mainloop/events/deferred.rs",
    "new_path": "pulse-binding/src/mainloop/events/deferred.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -15,6 +15,7 @@\n \n //! Main loop deferred events.\n \n+use std;\n use std::os::raw::c_void;\n use std::rc::Rc;\n use super::super::api::{MainloopApi, MainloopInnerType};\n@@ -104,6 +105,8 @@ impl<T> Drop for DeferEvent<T>\n pub(crate)\n extern \"C\"\n fn event_cb_proxy(_: *const MainloopApi, e: *mut DeferEventInternal, userdata: *mut c_void) {\n-    let callback = EventCb::get_callback(userdata);\n-    callback(e);\n+    let _ = std::panic::catch_unwind(|| {\n+        let callback = EventCb::get_callback(userdata);\n+        (callback)(e);\n+    });\n }\n",
    "diff_parsed": "{'added': [(18, 'use std;'), (108, '    let _ = std::panic::catch_unwind(|| {'), (109, '        let callback = EventCb::get_callback(userdata);'), (110, '        (callback)(e);'), (111, '    });')], 'deleted': [(107, '    let callback = EventCb::get_callback(userdata);'), (108, '    callback(e);')]}",
    "num_lines_added": "5",
    "num_lines_deleted": "2",
    "nloc": "70"
  },
  {
    "file_change_id": "179011270164090",
    "hash": "7fd282aef7787577c385aed88cb25d004b85f494",
    "old_path": "pulse-binding/src/mainloop/events/io.rs",
    "new_path": "pulse-binding/src/mainloop/events/io.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -15,6 +15,7 @@\n \n //! Main loop IO events.\n \n+use std;\n use capi;\n use std::os::raw::c_void;\n use std::rc::Rc;\n@@ -116,6 +117,8 @@ extern \"C\"\n fn event_cb_proxy(_: *const MainloopApi, e: *mut IoEventInternal, fd: i32, events: IoEventFlagSet,\n     userdata: *mut c_void)\n {\n-    let callback = EventCb::get_callback(userdata);\n-    callback(e, fd, events);\n+    let _ = std::panic::catch_unwind(|| {\n+        let callback = EventCb::get_callback(userdata);\n+        (callback)(e, fd, events);\n+    });\n }\n",
    "diff_parsed": "{'added': [(18, 'use std;'), (120, '    let _ = std::panic::catch_unwind(|| {'), (121, '        let callback = EventCb::get_callback(userdata);'), (122, '        (callback)(e, fd, events);'), (123, '    });')], 'deleted': [(119, '    let callback = EventCb::get_callback(userdata);'), (120, '    callback(e, fd, events);')]}",
    "num_lines_added": "5",
    "num_lines_deleted": "2",
    "nloc": "77"
  },
  {
    "file_change_id": "17231880821551",
    "hash": "7fd282aef7787577c385aed88cb25d004b85f494",
    "old_path": "pulse-binding/src/mainloop/events/timer.rs",
    "new_path": "pulse-binding/src/mainloop/events/timer.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -24,6 +24,7 @@\n //! Note that time events created with one form of time value can be freely restarted with the other\n //! form of time value.\n \n+use std;\n use std::os::raw::c_void;\n use std::rc::Rc;\n use libc::timeval;\n@@ -130,6 +131,8 @@ extern \"C\"\n fn event_cb_proxy(_: *const MainloopApi, e: *mut TimeEventInternal, _: *const timeval,\n     userdata: *mut c_void)\n {\n-    let callback = EventCb::get_callback(userdata);\n-    callback(e);\n+    let _ = std::panic::catch_unwind(|| {\n+        let callback = EventCb::get_callback(userdata);\n+        (callback)(e);\n+    });\n }\n",
    "diff_parsed": "{'added': [(27, 'use std;'), (134, '    let _ = std::panic::catch_unwind(|| {'), (135, '        let callback = EventCb::get_callback(userdata);'), (136, '        (callback)(e);'), (137, '    });')], 'deleted': [(133, '    let callback = EventCb::get_callback(userdata);'), (134, '    callback(e);')]}",
    "num_lines_added": "5",
    "num_lines_deleted": "2",
    "nloc": "81"
  },
  {
    "file_change_id": "164535869738643",
    "hash": "7fd282aef7787577c385aed88cb25d004b85f494",
    "old_path": "pulse-binding/src/mainloop/signal.rs",
    "new_path": "pulse-binding/src/mainloop/signal.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -23,6 +23,7 @@\n //! support for UNIX signals. However, you may hook signal support into an abstract main loop via\n //! the routines defined herein.\n \n+use std;\n use capi;\n use std::os::raw::c_void;\n use std::ptr::null_mut;\n@@ -89,6 +90,8 @@ extern \"C\"\n fn signal_cb_proxy(_api: *const ApiInternal, _e: *mut EventInternal, sig: i32,\n     userdata: *mut c_void)\n {\n-    let callback = SignalCb::get_callback(userdata);\n-    callback(sig);\n+    let _ = std::panic::catch_unwind(|| {\n+        let callback = SignalCb::get_callback(userdata);\n+        (callback)(sig);\n+    });\n }\n",
    "diff_parsed": "{'added': [(26, 'use std;'), (93, '    let _ = std::panic::catch_unwind(|| {'), (94, '        let callback = SignalCb::get_callback(userdata);'), (95, '        (callback)(sig);'), (96, '    });')], 'deleted': [(92, '    let callback = SignalCb::get_callback(userdata);'), (93, '    callback(sig);')]}",
    "num_lines_added": "5",
    "num_lines_deleted": "2",
    "nloc": "51"
  },
  {
    "file_change_id": "125986077641854",
    "hash": "7fd282aef7787577c385aed88cb25d004b85f494",
    "old_path": "pulse-binding/src/operation.rs",
    "new_path": "pulse-binding/src/operation.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -15,6 +15,7 @@\n \n //! Asynchronous operations.\n \n+use std;\n use capi;\n use std::os::raw::c_void;\n use std::ptr::null_mut;\n@@ -115,6 +116,8 @@ impl<ClosureProto: ?Sized> Drop for Operation<ClosureProto> {\n /// must be accomplished separately to avoid a memory leak.\n extern \"C\"\n fn notify_cb_proxy(_: *mut OperationInternal, userdata: *mut c_void) {\n-    let callback = NotifyCb::get_callback(userdata);\n-    callback();\n+    let _ = std::panic::catch_unwind(|| {\n+        let callback = NotifyCb::get_callback(userdata);\n+        (callback)();\n+    });\n }\n",
    "diff_parsed": "{'added': [(18, 'use std;'), (119, '    let _ = std::panic::catch_unwind(|| {'), (120, '        let callback = NotifyCb::get_callback(userdata);'), (121, '        (callback)();'), (122, '    });')], 'deleted': [(118, '    let callback = NotifyCb::get_callback(userdata);'), (119, '    callback();')]}",
    "num_lines_added": "5",
    "num_lines_deleted": "2",
    "nloc": "58"
  },
  {
    "file_change_id": "167207547207874",
    "hash": "7fd282aef7787577c385aed88cb25d004b85f494",
    "old_path": "pulse-binding/src/stream.rs",
    "new_path": "pulse-binding/src/stream.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1663,10 +1663,12 @@ impl Drop for Stream {\n /// Warning: This is for single-use cases only! It destroys the actual closure callback.\n extern \"C\"\n fn success_cb_proxy(_: *mut StreamInternal, success: i32, userdata: *mut c_void) {\n-    // Note, destroys closure callback after use - restoring outer box means it gets dropped\n-    let mut callback = ::callbacks::get_su_callback::<dyn FnMut(bool)>(userdata);\n     let success_actual = match success { 0 => false, _ => true };\n-    callback(success_actual);\n+    let _ = std::panic::catch_unwind(|| {\n+        // Note, destroys closure callback after use - restoring outer box means it gets dropped\n+        let mut callback = ::callbacks::get_su_callback::<dyn FnMut(bool)>(userdata);\n+        (callback)(success_actual);\n+    });\n }\n \n /// Proxy for request callbacks.\n@@ -1674,8 +1676,10 @@ fn success_cb_proxy(_: *mut StreamInternal, success: i32, userdata: *mut c_void)\n /// must be accomplished separately to avoid a memory leak.\n extern \"C\"\n fn request_cb_proxy(_: *mut StreamInternal, nbytes: usize, userdata: *mut c_void) {\n-    let callback = RequestCb::get_callback(userdata);\n-    callback(nbytes);\n+    let _ = std::panic::catch_unwind(|| {\n+        let callback = RequestCb::get_callback(userdata);\n+        (callback)(nbytes);\n+    });\n }\n \n /// Proxy for notify callbacks.\n@@ -1683,8 +1687,10 @@ fn request_cb_proxy(_: *mut StreamInternal, nbytes: usize, userdata: *mut c_void\n /// must be accomplished separately to avoid a memory leak.\n extern \"C\"\n fn notify_cb_proxy(_: *mut StreamInternal, userdata: *mut c_void) {\n-    let callback = NotifyCb::get_callback(userdata);\n-    callback();\n+    let _ = std::panic::catch_unwind(|| {\n+        let callback = NotifyCb::get_callback(userdata);\n+        (callback)();\n+    });\n }\n \n /// Proxy for event callbacks.\n@@ -1694,13 +1700,15 @@ extern \"C\"\n fn event_cb_proxy(_: *mut StreamInternal, name: *const c_char,\n     proplist: *mut ::proplist::ProplistInternal, userdata: *mut c_void)\n {\n-    assert!(!name.is_null());\n-    let n = {\n-        let tmp = unsafe { CStr::from_ptr(name) };\n-        tmp.to_string_lossy().into_owned()\n-    };\n-    let pl = Proplist::from_raw_weak(proplist);\n-\n-    let callback = EventCb::get_callback(userdata);\n-    callback(n, pl);\n+    let _ = std::panic::catch_unwind(|| {\n+        assert!(!name.is_null());\n+        let n = {\n+            let tmp = unsafe { CStr::from_ptr(name) };\n+            tmp.to_string_lossy().into_owned()\n+        };\n+        let pl = Proplist::from_raw_weak(proplist);\n+\n+        let callback = EventCb::get_callback(userdata);\n+        (callback)(n, pl);\n+    });\n }\n",
    "diff_parsed": "{'added': [(1667, '    let _ = std::panic::catch_unwind(|| {'), (1669, '        let mut callback = ::callbacks::get_su_callback::<dyn FnMut(bool)>(userdata);'), (1670, '        (callback)(success_actual);'), (1671, '    });'), (1679, '    let _ = std::panic::catch_unwind(|| {'), (1680, '        let callback = RequestCb::get_callback(userdata);'), (1681, '        (callback)(nbytes);'), (1682, '    });'), (1690, '    let _ = std::panic::catch_unwind(|| {'), (1691, '        let callback = NotifyCb::get_callback(userdata);'), (1692, '        (callback)();'), (1693, '    });'), (1703, '    let _ = std::panic::catch_unwind(|| {'), (1704, '        assert!(!name.is_null());'), (1705, '        let n = {'), (1706, '            let tmp = unsafe { CStr::from_ptr(name) };'), (1707, '            tmp.to_string_lossy().into_owned()'), (1708, '        };'), (1709, '        let pl = Proplist::from_raw_weak(proplist);'), (1711, '        let callback = EventCb::get_callback(userdata);'), (1712, '        (callback)(n, pl);'), (1713, '    });')], 'deleted': [(1667, '    let mut callback = ::callbacks::get_su_callback::<dyn FnMut(bool)>(userdata);'), (1669, '    callback(success_actual);'), (1677, '    let callback = RequestCb::get_callback(userdata);'), (1678, '    callback(nbytes);'), (1686, '    let callback = NotifyCb::get_callback(userdata);'), (1687, '    callback();'), (1697, '    assert!(!name.is_null());'), (1698, '    let n = {'), (1699, '        let tmp = unsafe { CStr::from_ptr(name) };'), (1700, '        tmp.to_string_lossy().into_owned()'), (1701, '    };'), (1702, '    let pl = Proplist::from_raw_weak(proplist);'), (1704, '    let callback = EventCb::get_callback(userdata);'), (1705, '    callback(n, pl);')]}",
    "num_lines_added": "22",
    "num_lines_deleted": "14",
    "nloc": "963"
  },
  {
    "file_change_id": "138452656664832",
    "hash": "f01846bd443aaf92fdd5ac20f461beac3f6ee3fd",
    "old_path": "src/bat_utils/less.rs",
    "new_path": "src/bat_utils/less.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,8 +1,12 @@\n use std::process::Command;\n \n pub fn retrieve_less_version() -> Option<usize> {\n-    let cmd = Command::new(\"less\").arg(\"--version\").output().ok()?;\n-    parse_less_version(&cmd.stdout)\n+    if let Ok(less_path) = grep_cli::resolve_binary(\"less\") {\n+        let cmd = Command::new(less_path).arg(\"--version\").output().ok()?;\n+        parse_less_version(&cmd.stdout)\n+    } else {\n+        None\n+    }\n }\n \n fn parse_less_version(output: &[u8]) -> Option<usize> {\n",
    "diff_parsed": "{'added': [(4, '    if let Ok(less_path) = grep_cli::resolve_binary(\"less\") {'), (5, '        let cmd = Command::new(less_path).arg(\"--version\").output().ok()?;'), (6, '        parse_less_version(&cmd.stdout)'), (7, '    } else {'), (8, '        None'), (9, '    }')], 'deleted': [(4, '    let cmd = Command::new(\"less\").arg(\"--version\").output().ok()?;'), (5, '    parse_less_version(&cmd.stdout)')]}",
    "num_lines_added": "6",
    "num_lines_deleted": "2",
    "nloc": "56"
  },
  {
    "file_change_id": "271442578170969",
    "hash": "f01846bd443aaf92fdd5ac20f461beac3f6ee3fd",
    "old_path": "src/bat_utils/output.rs",
    "new_path": "src/bat_utils/output.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -77,78 +77,35 @@ impl OutputType {\n         let pagerflags =\n             shell_words::split(&pager).chain_err(|| \"Could not parse pager command.\")?;\n \n-        match pagerflags.split_first() {\n+        Ok(match pagerflags.split_first() {\n             Some((pager_name, args)) => {\n                 let pager_path = PathBuf::from(pager_name);\n \n                 let is_less = pager_path.file_stem() == Some(&OsString::from(\"less\"));\n \n-                let mut process = if is_less {\n-                    let mut p = Command::new(&pager_path);\n-                    if args.is_empty() || replace_arguments_to_less {\n-                        p.args(vec![\"--RAW-CONTROL-CHARS\"]);\n-\n-                        // Passing '--no-init' fixes a bug with '--quit-if-one-screen' in older\n-                        // versions of 'less'. Unfortunately, it also breaks mouse-wheel support.\n-                        //\n-                        // See: http://www.greenwoodsoftware.com/less/news.530.html\n-                        //\n-                        // For newer versions (530 or 558 on Windows), we omit '--no-init' as it\n-                        // is not needed anymore.\n-                        match retrieve_less_version() {\n-                            None => {\n-                                p.arg(\"--no-init\");\n-                            }\n-                            Some(version)\n-                                if (version < 530 || (cfg!(windows) && version < 558)) =>\n-                            {\n-                                p.arg(\"--no-init\");\n-                            }\n-                            _ => {}\n-                        }\n-\n-                        if quit_if_one_screen {\n-                            p.arg(\"--quit-if-one-screen\");\n-                        }\n-                    } else {\n-                        p.args(args);\n-                    }\n-                    p.env(\"LESSCHARSET\", \"UTF-8\");\n-                    p\n+                let process = if is_less {\n+                    _make_process_from_less_path(\n+                        pager_path,\n+                        args,\n+                        replace_arguments_to_less,\n+                        quit_if_one_screen,\n+                        config,\n+                    )\n                 } else {\n-                    if pager_path.file_stem() == Some(&OsString::from(\"delta\")) {\n-                        eprintln!(\n-                            \"\\\n-It looks like you have set delta as the value of $PAGER. \\\n-This would result in a non-terminating recursion. \\\n-delta is not an appropriate value for $PAGER \\\n-(but it is an appropriate value for $GIT_PAGER).\"\n-                        );\n-                        std::process::exit(1);\n-                    }\n-                    let mut p = Command::new(&pager_path);\n-                    p.args(args);\n-                    p\n+                    _make_process_from_pager_path(pager_path, args)\n                 };\n-                if is_less && config.navigate {\n-                    if let Ok(hist_file) =\n-                        navigate::copy_less_hist_file_and_append_navigate_regexp(config)\n-                    {\n-                        process.env(\"LESSHISTFILE\", hist_file);\n-                        if config.show_themes {\n-                            process.arg(\"+n\");\n-                        }\n-                    }\n+                if let Some(mut process) = process {\n+                    process\n+                        .stdin(Stdio::piped())\n+                        .spawn()\n+                        .map(OutputType::Pager)\n+                        .unwrap_or_else(|_| OutputType::stdout())\n+                } else {\n+                    OutputType::stdout()\n                 }\n-                Ok(process\n-                    .env(\"LESSANSIENDCHARS\", \"mK\")\n-                    .stdin(Stdio::piped())\n-                    .spawn()\n-                    .map(OutputType::Pager)\n-                    .unwrap_or_else(|_| OutputType::stdout()))\n             }\n-            None => Ok(OutputType::stdout()),\n-        }\n+            None => OutputType::stdout(),\n+        })\n     }\n \n     fn stdout() -> Self {\n@@ -166,6 +123,78 @@ delta is not an appropriate value for $PAGER \\\n     }\n }\n \n+fn _make_process_from_less_path(\n+    less_path: PathBuf,\n+    args: &[String],\n+    replace_arguments_to_less: bool,\n+    quit_if_one_screen: bool,\n+    config: &config::Config,\n+) -> Option<Command> {\n+    if let Ok(less_path) = grep_cli::resolve_binary(less_path) {\n+        let mut p = Command::new(&less_path);\n+        if args.is_empty() || replace_arguments_to_less {\n+            p.args(vec![\"--RAW-CONTROL-CHARS\"]);\n+\n+            // Passing '--no-init' fixes a bug with '--quit-if-one-screen' in older\n+            // versions of 'less'. Unfortunately, it also breaks mouse-wheel support.\n+            //\n+            // See: http://www.greenwoodsoftware.com/less/news.530.html\n+            //\n+            // For newer versions (530 or 558 on Windows), we omit '--no-init' as it\n+            // is not needed anymore.\n+            match retrieve_less_version() {\n+                None => {\n+                    p.arg(\"--no-init\");\n+                }\n+                Some(version) if (version < 530 || (cfg!(windows) && version < 558)) => {\n+                    p.arg(\"--no-init\");\n+                }\n+                _ => {}\n+            }\n+\n+            if quit_if_one_screen {\n+                p.arg(\"--quit-if-one-screen\");\n+            }\n+        } else {\n+            p.args(args);\n+        }\n+        p.env(\"LESSCHARSET\", \"UTF-8\");\n+        p.env(\"LESSANSIENDCHARS\", \"mK\");\n+        if config.navigate {\n+            if let Ok(hist_file) = navigate::copy_less_hist_file_and_append_navigate_regexp(config)\n+            {\n+                p.env(\"LESSHISTFILE\", hist_file);\n+                if config.show_themes {\n+                    p.arg(\"+n\");\n+                }\n+            }\n+        }\n+        Some(p)\n+    } else {\n+        None\n+    }\n+}\n+\n+fn _make_process_from_pager_path(pager_path: PathBuf, args: &[String]) -> Option<Command> {\n+    if pager_path.file_stem() == Some(&OsString::from(\"delta\")) {\n+        eprintln!(\n+            \"\\\n+It looks like you have set delta as the value of $PAGER. \\\n+This would result in a non-terminating recursion. \\\n+delta is not an appropriate value for $PAGER \\\n+(but it is an appropriate value for $GIT_PAGER).\"\n+        );\n+        std::process::exit(1);\n+    }\n+    if let Ok(pager_path) = grep_cli::resolve_binary(pager_path) {\n+        let mut p = Command::new(&pager_path);\n+        p.args(args);\n+        Some(p)\n+    } else {\n+        None\n+    }\n+}\n+\n impl Drop for OutputType {\n     fn drop(&mut self) {\n         if let OutputType::Pager(ref mut command) = *self {\n",
    "diff_parsed": "{'added': [(80, '        Ok(match pagerflags.split_first() {'), (86, '                let process = if is_less {'), (87, '                    _make_process_from_less_path('), (88, '                        pager_path,'), (89, '                        args,'), (90, '                        replace_arguments_to_less,'), (91, '                        quit_if_one_screen,'), (92, '                        config,'), (93, '                    )'), (95, '                    _make_process_from_pager_path(pager_path, args)'), (97, '                if let Some(mut process) = process {'), (98, '                    process'), (99, '                        .stdin(Stdio::piped())'), (100, '                        .spawn()'), (101, '                        .map(OutputType::Pager)'), (102, '                        .unwrap_or_else(|_| OutputType::stdout())'), (103, '                } else {'), (104, '                    OutputType::stdout()'), (107, '            None => OutputType::stdout(),'), (108, '        })'), (126, 'fn _make_process_from_less_path('), (127, '    less_path: PathBuf,'), (128, '    args: &[String],'), (129, '    replace_arguments_to_less: bool,'), (130, '    quit_if_one_screen: bool,'), (131, '    config: &config::Config,'), (132, ') -> Option<Command> {'), (133, '    if let Ok(less_path) = grep_cli::resolve_binary(less_path) {'), (134, '        let mut p = Command::new(&less_path);'), (135, '        if args.is_empty() || replace_arguments_to_less {'), (136, '            p.args(vec![\"--RAW-CONTROL-CHARS\"]);'), (145, '            match retrieve_less_version() {'), (146, '                None => {'), (147, '                    p.arg(\"--no-init\");'), (148, '                }'), (149, '                Some(version) if (version < 530 || (cfg!(windows) && version < 558)) => {'), (150, '                    p.arg(\"--no-init\");'), (151, '                }'), (152, '                _ => {}'), (153, '            }'), (155, '            if quit_if_one_screen {'), (156, '                p.arg(\"--quit-if-one-screen\");'), (157, '            }'), (158, '        } else {'), (159, '            p.args(args);'), (160, '        }'), (161, '        p.env(\"LESSCHARSET\", \"UTF-8\");'), (162, '        p.env(\"LESSANSIENDCHARS\", \"mK\");'), (163, '        if config.navigate {'), (164, '            if let Ok(hist_file) = navigate::copy_less_hist_file_and_append_navigate_regexp(config)'), (165, '            {'), (166, '                p.env(\"LESSHISTFILE\", hist_file);'), (167, '                if config.show_themes {'), (168, '                    p.arg(\"+n\");'), (169, '                }'), (170, '            }'), (171, '        }'), (172, '        Some(p)'), (173, '    } else {'), (174, '        None'), (175, '    }'), (176, '}'), (178, 'fn _make_process_from_pager_path(pager_path: PathBuf, args: &[String]) -> Option<Command> {'), (179, '    if pager_path.file_stem() == Some(&OsString::from(\"delta\")) {'), (180, '        eprintln!('), (181, '            \"\\\\'), (182, 'It looks like you have set delta as the value of $PAGER. \\\\'), (183, 'This would result in a non-terminating recursion. \\\\'), (184, 'delta is not an appropriate value for $PAGER \\\\'), (185, '(but it is an appropriate value for $GIT_PAGER).\"'), (186, '        );'), (187, '        std::process::exit(1);'), (188, '    }'), (189, '    if let Ok(pager_path) = grep_cli::resolve_binary(pager_path) {'), (190, '        let mut p = Command::new(&pager_path);'), (191, '        p.args(args);'), (192, '        Some(p)'), (193, '    } else {'), (194, '        None'), (195, '    }'), (196, '}')], 'deleted': [(80, '        match pagerflags.split_first() {'), (86, '                let mut process = if is_less {'), (87, '                    let mut p = Command::new(&pager_path);'), (88, '                    if args.is_empty() || replace_arguments_to_less {'), (89, '                        p.args(vec![\"--RAW-CONTROL-CHARS\"]);'), (98, '                        match retrieve_less_version() {'), (99, '                            None => {'), (100, '                                p.arg(\"--no-init\");'), (101, '                            }'), (102, '                            Some(version)'), (103, '                                if (version < 530 || (cfg!(windows) && version < 558)) =>'), (104, '                            {'), (105, '                                p.arg(\"--no-init\");'), (106, '                            }'), (107, '                            _ => {}'), (108, '                        }'), (110, '                        if quit_if_one_screen {'), (111, '                            p.arg(\"--quit-if-one-screen\");'), (112, '                        }'), (113, '                    } else {'), (114, '                        p.args(args);'), (115, '                    }'), (116, '                    p.env(\"LESSCHARSET\", \"UTF-8\");'), (117, '                    p'), (119, '                    if pager_path.file_stem() == Some(&OsString::from(\"delta\")) {'), (120, '                        eprintln!('), (121, '                            \"\\\\'), (122, 'It looks like you have set delta as the value of $PAGER. \\\\'), (123, 'This would result in a non-terminating recursion. \\\\'), (124, 'delta is not an appropriate value for $PAGER \\\\'), (125, '(but it is an appropriate value for $GIT_PAGER).\"'), (126, '                        );'), (127, '                        std::process::exit(1);'), (128, '                    }'), (129, '                    let mut p = Command::new(&pager_path);'), (130, '                    p.args(args);'), (131, '                    p'), (133, '                if is_less && config.navigate {'), (134, '                    if let Ok(hist_file) ='), (135, '                        navigate::copy_less_hist_file_and_append_navigate_regexp(config)'), (136, '                    {'), (137, '                        process.env(\"LESSHISTFILE\", hist_file);'), (138, '                        if config.show_themes {'), (139, '                            process.arg(\"+n\");'), (140, '                        }'), (141, '                    }'), (143, '                Ok(process'), (144, '                    .env(\"LESSANSIENDCHARS\", \"mK\")'), (145, '                    .stdin(Stdio::piped())'), (146, '                    .spawn()'), (147, '                    .map(OutputType::Pager)'), (148, '                    .unwrap_or_else(|_| OutputType::stdout()))'), (150, '            None => Ok(OutputType::stdout()),'), (151, '        }')]}",
    "num_lines_added": "81",
    "num_lines_deleted": "54",
    "nloc": "169"
  },
  {
    "file_change_id": "1714861554375",
    "hash": "f01846bd443aaf92fdd5ac20f461beac3f6ee3fd",
    "old_path": "src/main.rs",
    "new_path": "src/main.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -132,7 +132,11 @@ You can also use delta to diff two files: `delta file_A file_B`.\"\n     let diff_command = \"git\";\n     let minus_file = minus_file.unwrap_or_else(die);\n     let plus_file = plus_file.unwrap_or_else(die);\n-    let mut diff_process = process::Command::new(PathBuf::from(diff_command))\n+    let diff_command_path = match grep_cli::resolve_binary(PathBuf::from(diff_command)) {\n+        Ok(path) => path,\n+        Err(_) => return config.error_exit_code,\n+    };\n+    let mut diff_process = process::Command::new(diff_command_path)\n         .args(&[\"diff\", \"--no-index\"])\n         .args(&[minus_file, plus_file])\n         .stdout(process::Stdio::piped())\n",
    "diff_parsed": "{'added': [(135, '    let diff_command_path = match grep_cli::resolve_binary(PathBuf::from(diff_command)) {'), (136, '        Ok(path) => path,'), (137, '        Err(_) => return config.error_exit_code,'), (138, '    };'), (139, '    let mut diff_process = process::Command::new(diff_command_path)')], 'deleted': [(135, '    let mut diff_process = process::Command::new(PathBuf::from(diff_command))')]}",
    "num_lines_added": "5",
    "num_lines_deleted": "1",
    "nloc": "564"
  },
  {
    "file_change_id": "208073945757665",
    "hash": "8f28ec275e412dd3af4f3cda460605512faf332c",
    "old_path": "src/subframe.rs",
    "new_path": "src/subframe.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -254,12 +254,25 @@ fn decode_residual<R: ReadBytes>(input: &mut Bitstream<R>,\n     // most 2^16 - 1 samples in the block. No values have been marked as\n     // invalid by the specification though.\n     let n_partitions = 1u32 << order;\n-    let n_samples = block_size >> order;\n+    let n_samples_per_partition = block_size >> order;\n+\n+    // The partitions together must fill the block. If the block size is not a\n+    // multiple of 2^order; if we shifted off some bits, then we would not fill\n+    // the entire block. Such a partition order is invalid for this block size.\n+    if block_size & (n_partitions - 1) as u16 != 0 {\n+        return fmt_err(\"invalid partition order\")\n+    }\n+\n+    // NOTE: the check above checks that block_size is a multiple of n_partitions\n+    // (this works because n_partitions is a power of 2). The check below is\n+    // equivalent but more expensive.\n+    debug_assert_eq!(n_partitions * n_samples_per_partition as u32, block_size as u32);\n+\n     let n_warm_up = block_size - buffer.len() as u16;\n \n     // The partition size must be at least as big as the number of warm-up\n     // samples, otherwise the size of the first partition is negative.\n-    if n_warm_up > n_samples {\n+    if n_warm_up > n_samples_per_partition {\n         return fmt_err(\"invalid residual\");\n     }\n \n@@ -267,22 +280,22 @@ fn decode_residual<R: ReadBytes>(input: &mut Bitstream<R>,\n     match partition_type {\n         RicePartitionType::Rice => {\n             let mut start = 0;\n-            let mut len = n_samples - n_warm_up;\n+            let mut len = n_samples_per_partition - n_warm_up;\n             for _ in 0..n_partitions {\n                 let slice = &mut buffer[start..start + len as usize];\n                 try!(decode_rice_partition(input, slice));\n                 start = start + len as usize;\n-                len = n_samples;\n+                len = n_samples_per_partition;\n             }\n         }\n         RicePartitionType::Rice2 => {\n             let mut start = 0;\n-            let mut len = n_samples - n_warm_up;\n+            let mut len = n_samples_per_partition - n_warm_up;\n             for _ in 0..n_partitions {\n                 let slice = &mut buffer[start..start + len as usize];\n                 try!(decode_rice2_partition(input, slice));\n                 start = start + len as usize;\n-                len = n_samples;\n+                len = n_samples_per_partition;\n             }\n         }\n     }\n",
    "diff_parsed": "{'added': [(257, '    let n_samples_per_partition = block_size >> order;'), (262, '    if block_size & (n_partitions - 1) as u16 != 0 {'), (263, '        return fmt_err(\"invalid partition order\")'), (264, '    }'), (269, '    debug_assert_eq!(n_partitions * n_samples_per_partition as u32, block_size as u32);'), (275, '    if n_warm_up > n_samples_per_partition {'), (283, '            let mut len = n_samples_per_partition - n_warm_up;'), (288, '                len = n_samples_per_partition;'), (293, '            let mut len = n_samples_per_partition - n_warm_up;'), (298, '                len = n_samples_per_partition;')], 'deleted': [(257, '    let n_samples = block_size >> order;'), (262, '    if n_warm_up > n_samples {'), (270, '            let mut len = n_samples - n_warm_up;'), (275, '                len = n_samples;'), (280, '            let mut len = n_samples - n_warm_up;'), (285, '                len = n_samples;')]}",
    "num_lines_added": "10",
    "num_lines_deleted": "6",
    "nloc": "373"
  },
  {
    "file_change_id": "215913547525403",
    "hash": "3c6b57fe1b2cc87e7ebecde43dd836ffb1c4ea5c",
    "old_path": "src/vtab/array.rs",
    "new_path": "src/vtab/array.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -33,8 +33,8 @@ use std::rc::Rc;\n use crate::ffi;\n use crate::types::{ToSql, ToSqlOutput, Value};\n use crate::vtab::{\n-    eponymous_only_module, Context, IndexConstraintOp, IndexInfo, Module, VTab, VTabConnection,\n-    VTabCursor, Values,\n+    eponymous_only_module, Context, IndexConstraintOp, IndexInfo, VTab, VTabConnection, VTabCursor,\n+    Values,\n };\n use crate::{Connection, Result};\n \n@@ -57,11 +57,7 @@ impl ToSql for Array {\n /// `feature = \"array\"` Register the \"rarray\" module.\n pub fn load_module(conn: &Connection) -> Result<()> {\n     let aux: Option<()> = None;\n-    conn.create_module(\"rarray\", &ARRAY_MODULE, aux)\n-}\n-\n-lazy_static::lazy_static! {\n-    static ref ARRAY_MODULE: Module<ArrayTab> = eponymous_only_module::<ArrayTab>(1);\n+    conn.create_module(\"rarray\", eponymous_only_module::<ArrayTab>(), aux)\n }\n \n // Column numbers\n",
    "diff_parsed": "{'added': [(36, '    eponymous_only_module, Context, IndexConstraintOp, IndexInfo, VTab, VTabConnection, VTabCursor,'), (37, '    Values,'), (60, '    conn.create_module(\"rarray\", eponymous_only_module::<ArrayTab>(), aux)')], 'deleted': [(36, '    eponymous_only_module, Context, IndexConstraintOp, IndexInfo, Module, VTab, VTabConnection,'), (37, '    VTabCursor, Values,'), (60, '    conn.create_module(\"rarray\", &ARRAY_MODULE, aux)'), (61, '}'), (63, 'lazy_static::lazy_static! {'), (64, '    static ref ARRAY_MODULE: Module<ArrayTab> = eponymous_only_module::<ArrayTab>(1);')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "6",
    "nloc": "177"
  },
  {
    "file_change_id": "104178483787113",
    "hash": "3c6b57fe1b2cc87e7ebecde43dd836ffb1c4ea5c",
    "old_path": "src/vtab/csvtab.rs",
    "new_path": "src/vtab/csvtab.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -30,7 +30,7 @@ use crate::ffi;\n use crate::types::Null;\n use crate::vtab::{\n     dequote, escape_double_quote, parse_boolean, read_only_module, Context, CreateVTab, IndexInfo,\n-    Module, VTab, VTabConnection, VTabCursor, Values,\n+    VTab, VTabConnection, VTabCursor, Values,\n };\n use crate::{Connection, Error, Result};\n \n@@ -47,11 +47,7 @@ use crate::{Connection, Error, Result};\n /// ```\n pub fn load_module(conn: &Connection) -> Result<()> {\n     let aux: Option<()> = None;\n-    conn.create_module(\"csv\", &CSV_MODULE, aux)\n-}\n-\n-lazy_static::lazy_static! {\n-    static ref CSV_MODULE: Module<CSVTab> = read_only_module::<CSVTab>(1);\n+    conn.create_module(\"csv\", read_only_module::<CSVTab>(), aux)\n }\n \n /// An instance of the CSV virtual table\n",
    "diff_parsed": "{'added': [(33, '    VTab, VTabConnection, VTabCursor, Values,'), (50, '    conn.create_module(\"csv\", read_only_module::<CSVTab>(), aux)')], 'deleted': [(33, '    Module, VTab, VTabConnection, VTabCursor, Values,'), (50, '    conn.create_module(\"csv\", &CSV_MODULE, aux)'), (51, '}'), (53, 'lazy_static::lazy_static! {'), (54, '    static ref CSV_MODULE: Module<CSVTab> = read_only_module::<CSVTab>(1);')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "5",
    "nloc": "341"
  },
  {
    "file_change_id": "225183744089567",
    "hash": "3c6b57fe1b2cc87e7ebecde43dd836ffb1c4ea5c",
    "old_path": "src/vtab/mod.rs",
    "new_path": "src/vtab/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -60,7 +60,7 @@ use crate::{str_to_cstring, Connection, Error, InnerConnection, Result};\n /// `feature = \"vtab\"` Virtual table module\n ///\n /// (See [SQLite doc](https://sqlite.org/c3ref/module.html))\n-#[repr(C)]\n+#[repr(transparent)]\n pub struct Module<T: VTab> {\n     base: ffi::sqlite3_module,\n     phantom: PhantomData<T>,\n@@ -69,47 +69,55 @@ pub struct Module<T: VTab> {\n unsafe impl<T: VTab> Send for Module<T> {}\n unsafe impl<T: VTab> Sync for Module<T> {}\n \n-// Used as a trailing initializer for sqlite3_module -- this way we avoid having\n-// the build fail if buildtime_bindgen is on\n-fn zeroed_module() -> ffi::sqlite3_module {\n-    // This is safe, as bindgen-generated structs are allowed to be zeroed.\n-    unsafe { std::mem::MaybeUninit::zeroed().assume_init() }\n+union ModuleZeroHack {\n+    bytes: [u8; std::mem::size_of::<ffi::sqlite3_module>()],\n+    module: ffi::sqlite3_module,\n }\n \n+// Used as a trailing initializer for sqlite3_module -- this way we avoid having\n+// the build fail if buildtime_bindgen is on. This is safe, as bindgen-generated\n+// structs are allowed to be zeroed.\n+const ZERO_MODULE: ffi::sqlite3_module = unsafe {\n+    ModuleZeroHack {\n+        bytes: [0u8; std::mem::size_of::<ffi::sqlite3_module>()],\n+    }\n+    .module\n+};\n+\n /// `feature = \"vtab\"` Create a read-only virtual table implementation.\n ///\n /// Step 2 of [Creating New Virtual Table Implementations](https://sqlite.org/vtab.html#creating_new_virtual_table_implementations).\n-pub fn read_only_module<T: CreateVTab>(version: c_int) -> Module<T> {\n+pub fn read_only_module<T: CreateVTab>() -> &'static Module<T> {\n     // The xConnect and xCreate methods do the same thing, but they must be\n     // different so that the virtual table is not an eponymous virtual table.\n-    let ffi_module = ffi::sqlite3_module {\n-        iVersion: version,\n-        xCreate: Some(rust_create::<T>),\n-        xConnect: Some(rust_connect::<T>),\n-        xBestIndex: Some(rust_best_index::<T>),\n-        xDisconnect: Some(rust_disconnect::<T>),\n-        xDestroy: Some(rust_destroy::<T>),\n-        xOpen: Some(rust_open::<T>),\n-        xClose: Some(rust_close::<T::Cursor>),\n-        xFilter: Some(rust_filter::<T::Cursor>),\n-        xNext: Some(rust_next::<T::Cursor>),\n-        xEof: Some(rust_eof::<T::Cursor>),\n-        xColumn: Some(rust_column::<T::Cursor>),\n-        xRowid: Some(rust_rowid::<T::Cursor>),\n-        xUpdate: None,\n-        xBegin: None,\n-        xSync: None,\n-        xCommit: None,\n-        xRollback: None,\n-        xFindFunction: None,\n-        xRename: None,\n-        xSavepoint: None,\n-        xRelease: None,\n-        xRollbackTo: None,\n-        ..zeroed_module()\n-    };\n-    Module {\n-        base: ffi_module,\n+    &Module {\n+        base: ffi::sqlite3_module {\n+            // We don't use V3\n+            iVersion: 2, // We don't use V2 or V3 features in read_only_module types\n+            xCreate: Some(rust_create::<T>),\n+            xConnect: Some(rust_connect::<T>),\n+            xBestIndex: Some(rust_best_index::<T>),\n+            xDisconnect: Some(rust_disconnect::<T>),\n+            xDestroy: Some(rust_destroy::<T>),\n+            xOpen: Some(rust_open::<T>),\n+            xClose: Some(rust_close::<T::Cursor>),\n+            xFilter: Some(rust_filter::<T::Cursor>),\n+            xNext: Some(rust_next::<T::Cursor>),\n+            xEof: Some(rust_eof::<T::Cursor>),\n+            xColumn: Some(rust_column::<T::Cursor>),\n+            xRowid: Some(rust_rowid::<T::Cursor>),\n+            xUpdate: None,\n+            xBegin: None,\n+            xSync: None,\n+            xCommit: None,\n+            xRollback: None,\n+            xFindFunction: None,\n+            xRename: None,\n+            xSavepoint: None,\n+            xRelease: None,\n+            xRollbackTo: None,\n+            ..ZERO_MODULE\n+        },\n         phantom: PhantomData::<T>,\n     }\n }\n@@ -117,38 +125,38 @@ pub fn read_only_module<T: CreateVTab>(version: c_int) -> Module<T> {\n /// `feature = \"vtab\"` Create an eponymous only virtual table implementation.\n ///\n /// Step 2 of [Creating New Virtual Table Implementations](https://sqlite.org/vtab.html#creating_new_virtual_table_implementations).\n-pub fn eponymous_only_module<T: VTab>(version: c_int) -> Module<T> {\n+pub fn eponymous_only_module<T: VTab>() -> &'static Module<T> {\n     // A virtual table is eponymous if its xCreate method is the exact same function\n     // as the xConnect method For eponymous-only virtual tables, the xCreate\n     // method is NULL\n-    let ffi_module = ffi::sqlite3_module {\n-        iVersion: version,\n-        xCreate: None,\n-        xConnect: Some(rust_connect::<T>),\n-        xBestIndex: Some(rust_best_index::<T>),\n-        xDisconnect: Some(rust_disconnect::<T>),\n-        xDestroy: None,\n-        xOpen: Some(rust_open::<T>),\n-        xClose: Some(rust_close::<T::Cursor>),\n-        xFilter: Some(rust_filter::<T::Cursor>),\n-        xNext: Some(rust_next::<T::Cursor>),\n-        xEof: Some(rust_eof::<T::Cursor>),\n-        xColumn: Some(rust_column::<T::Cursor>),\n-        xRowid: Some(rust_rowid::<T::Cursor>),\n-        xUpdate: None,\n-        xBegin: None,\n-        xSync: None,\n-        xCommit: None,\n-        xRollback: None,\n-        xFindFunction: None,\n-        xRename: None,\n-        xSavepoint: None,\n-        xRelease: None,\n-        xRollbackTo: None,\n-        ..zeroed_module()\n-    };\n-    Module {\n-        base: ffi_module,\n+    &Module {\n+        base: ffi::sqlite3_module {\n+            // We don't use V3\n+            iVersion: 2,\n+            xCreate: None,\n+            xConnect: Some(rust_connect::<T>),\n+            xBestIndex: Some(rust_best_index::<T>),\n+            xDisconnect: Some(rust_disconnect::<T>),\n+            xDestroy: None,\n+            xOpen: Some(rust_open::<T>),\n+            xClose: Some(rust_close::<T::Cursor>),\n+            xFilter: Some(rust_filter::<T::Cursor>),\n+            xNext: Some(rust_next::<T::Cursor>),\n+            xEof: Some(rust_eof::<T::Cursor>),\n+            xColumn: Some(rust_column::<T::Cursor>),\n+            xRowid: Some(rust_rowid::<T::Cursor>),\n+            xUpdate: None,\n+            xBegin: None,\n+            xSync: None,\n+            xCommit: None,\n+            xRollback: None,\n+            xFindFunction: None,\n+            xRename: None,\n+            xSavepoint: None,\n+            xRelease: None,\n+            xRollbackTo: None,\n+            ..ZERO_MODULE\n+        },\n         phantom: PhantomData::<T>,\n     }\n }\n@@ -583,11 +591,12 @@ impl<'a> Iterator for ValueIter<'a> {\n impl Connection {\n     /// `feature = \"vtab\"` Register a virtual table implementation.\n     ///\n-    /// Step 3 of [Creating New Virtual Table Implementations](https://sqlite.org/vtab.html#creating_new_virtual_table_implementations).\n+    /// Step 3 of [Creating New Virtual Table\n+    /// Implementations](https://sqlite.org/vtab.html#creating_new_virtual_table_implementations).\n     pub fn create_module<T: VTab>(\n         &self,\n         module_name: &str,\n-        module: &Module<T>,\n+        module: &'static Module<T>,\n         aux: Option<T::Aux>,\n     ) -> Result<()> {\n         self.db.borrow_mut().create_module(module_name, module, aux)\n@@ -598,7 +607,7 @@ impl InnerConnection {\n     fn create_module<T: VTab>(\n         &mut self,\n         module_name: &str,\n-        module: &Module<T>,\n+        module: &'static Module<T>,\n         aux: Option<T::Aux>,\n     ) -> Result<()> {\n         let c_name = str_to_cstring(module_name)?;\n",
    "diff_parsed": "{'added': [(63, '#[repr(transparent)]'), (72, 'union ModuleZeroHack {'), (73, '    bytes: [u8; std::mem::size_of::<ffi::sqlite3_module>()],'), (74, '    module: ffi::sqlite3_module,'), (80, 'const ZERO_MODULE: ffi::sqlite3_module = unsafe {'), (81, '    ModuleZeroHack {'), (82, '        bytes: [0u8; std::mem::size_of::<ffi::sqlite3_module>()],'), (83, '    }'), (84, '    .module'), (85, '};'), (90, \"pub fn read_only_module<T: CreateVTab>() -> &'static Module<T> {\"), (93, '    &Module {'), (94, '        base: ffi::sqlite3_module {'), (96, \"            iVersion: 2, // We don't use V2 or V3 features in read_only_module types\"), (97, '            xCreate: Some(rust_create::<T>),'), (98, '            xConnect: Some(rust_connect::<T>),'), (99, '            xBestIndex: Some(rust_best_index::<T>),'), (100, '            xDisconnect: Some(rust_disconnect::<T>),'), (101, '            xDestroy: Some(rust_destroy::<T>),'), (102, '            xOpen: Some(rust_open::<T>),'), (103, '            xClose: Some(rust_close::<T::Cursor>),'), (104, '            xFilter: Some(rust_filter::<T::Cursor>),'), (105, '            xNext: Some(rust_next::<T::Cursor>),'), (106, '            xEof: Some(rust_eof::<T::Cursor>),'), (107, '            xColumn: Some(rust_column::<T::Cursor>),'), (108, '            xRowid: Some(rust_rowid::<T::Cursor>),'), (109, '            xUpdate: None,'), (110, '            xBegin: None,'), (111, '            xSync: None,'), (112, '            xCommit: None,'), (113, '            xRollback: None,'), (114, '            xFindFunction: None,'), (115, '            xRename: None,'), (116, '            xSavepoint: None,'), (117, '            xRelease: None,'), (118, '            xRollbackTo: None,'), (119, '            ..ZERO_MODULE'), (120, '        },'), (128, \"pub fn eponymous_only_module<T: VTab>() -> &'static Module<T> {\"), (132, '    &Module {'), (133, '        base: ffi::sqlite3_module {'), (135, '            iVersion: 2,'), (136, '            xCreate: None,'), (137, '            xConnect: Some(rust_connect::<T>),'), (138, '            xBestIndex: Some(rust_best_index::<T>),'), (139, '            xDisconnect: Some(rust_disconnect::<T>),'), (140, '            xDestroy: None,'), (141, '            xOpen: Some(rust_open::<T>),'), (142, '            xClose: Some(rust_close::<T::Cursor>),'), (143, '            xFilter: Some(rust_filter::<T::Cursor>),'), (144, '            xNext: Some(rust_next::<T::Cursor>),'), (145, '            xEof: Some(rust_eof::<T::Cursor>),'), (146, '            xColumn: Some(rust_column::<T::Cursor>),'), (147, '            xRowid: Some(rust_rowid::<T::Cursor>),'), (148, '            xUpdate: None,'), (149, '            xBegin: None,'), (150, '            xSync: None,'), (151, '            xCommit: None,'), (152, '            xRollback: None,'), (153, '            xFindFunction: None,'), (154, '            xRename: None,'), (155, '            xSavepoint: None,'), (156, '            xRelease: None,'), (157, '            xRollbackTo: None,'), (158, '            ..ZERO_MODULE'), (159, '        },'), (599, \"        module: &'static Module<T>,\"), (610, \"        module: &'static Module<T>,\")], 'deleted': [(63, '#[repr(C)]'), (74, 'fn zeroed_module() -> ffi::sqlite3_module {'), (76, '    unsafe { std::mem::MaybeUninit::zeroed().assume_init() }'), (82, 'pub fn read_only_module<T: CreateVTab>(version: c_int) -> Module<T> {'), (85, '    let ffi_module = ffi::sqlite3_module {'), (86, '        iVersion: version,'), (87, '        xCreate: Some(rust_create::<T>),'), (88, '        xConnect: Some(rust_connect::<T>),'), (89, '        xBestIndex: Some(rust_best_index::<T>),'), (90, '        xDisconnect: Some(rust_disconnect::<T>),'), (91, '        xDestroy: Some(rust_destroy::<T>),'), (92, '        xOpen: Some(rust_open::<T>),'), (93, '        xClose: Some(rust_close::<T::Cursor>),'), (94, '        xFilter: Some(rust_filter::<T::Cursor>),'), (95, '        xNext: Some(rust_next::<T::Cursor>),'), (96, '        xEof: Some(rust_eof::<T::Cursor>),'), (97, '        xColumn: Some(rust_column::<T::Cursor>),'), (98, '        xRowid: Some(rust_rowid::<T::Cursor>),'), (99, '        xUpdate: None,'), (100, '        xBegin: None,'), (101, '        xSync: None,'), (102, '        xCommit: None,'), (103, '        xRollback: None,'), (104, '        xFindFunction: None,'), (105, '        xRename: None,'), (106, '        xSavepoint: None,'), (107, '        xRelease: None,'), (108, '        xRollbackTo: None,'), (109, '        ..zeroed_module()'), (110, '    };'), (111, '    Module {'), (112, '        base: ffi_module,'), (120, 'pub fn eponymous_only_module<T: VTab>(version: c_int) -> Module<T> {'), (124, '    let ffi_module = ffi::sqlite3_module {'), (125, '        iVersion: version,'), (126, '        xCreate: None,'), (127, '        xConnect: Some(rust_connect::<T>),'), (128, '        xBestIndex: Some(rust_best_index::<T>),'), (129, '        xDisconnect: Some(rust_disconnect::<T>),'), (130, '        xDestroy: None,'), (131, '        xOpen: Some(rust_open::<T>),'), (132, '        xClose: Some(rust_close::<T::Cursor>),'), (133, '        xFilter: Some(rust_filter::<T::Cursor>),'), (134, '        xNext: Some(rust_next::<T::Cursor>),'), (135, '        xEof: Some(rust_eof::<T::Cursor>),'), (136, '        xColumn: Some(rust_column::<T::Cursor>),'), (137, '        xRowid: Some(rust_rowid::<T::Cursor>),'), (138, '        xUpdate: None,'), (139, '        xBegin: None,'), (140, '        xSync: None,'), (141, '        xCommit: None,'), (142, '        xRollback: None,'), (143, '        xFindFunction: None,'), (144, '        xRename: None,'), (145, '        xSavepoint: None,'), (146, '        xRelease: None,'), (147, '        xRollbackTo: None,'), (148, '        ..zeroed_module()'), (149, '    };'), (150, '    Module {'), (151, '        base: ffi_module,'), (590, '        module: &Module<T>,'), (601, '        module: &Module<T>,')]}",
    "num_lines_added": "68",
    "num_lines_deleted": "63",
    "nloc": "861"
  },
  {
    "file_change_id": "188252198752791",
    "hash": "3c6b57fe1b2cc87e7ebecde43dd836ffb1c4ea5c",
    "old_path": "src/vtab/series.rs",
    "new_path": "src/vtab/series.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -9,19 +9,15 @@ use std::os::raw::c_int;\n use crate::ffi;\n use crate::types::Type;\n use crate::vtab::{\n-    eponymous_only_module, Context, IndexConstraintOp, IndexInfo, Module, VTab, VTabConnection,\n-    VTabCursor, Values,\n+    eponymous_only_module, Context, IndexConstraintOp, IndexInfo, VTab, VTabConnection, VTabCursor,\n+    Values,\n };\n use crate::{Connection, Result};\n \n /// `feature = \"series\"` Register the \"generate_series\" module.\n pub fn load_module(conn: &Connection) -> Result<()> {\n     let aux: Option<()> = None;\n-    conn.create_module(\"generate_series\", &SERIES_MODULE, aux)\n-}\n-\n-lazy_static::lazy_static! {\n-    static ref SERIES_MODULE: Module<SeriesTab> = eponymous_only_module::<SeriesTab>(1);\n+    conn.create_module(\"generate_series\", eponymous_only_module::<SeriesTab>(), aux)\n }\n \n // Column numbers\n",
    "diff_parsed": "{'added': [(12, '    eponymous_only_module, Context, IndexConstraintOp, IndexInfo, VTab, VTabConnection, VTabCursor,'), (13, '    Values,'), (20, '    conn.create_module(\"generate_series\", eponymous_only_module::<SeriesTab>(), aux)')], 'deleted': [(12, '    eponymous_only_module, Context, IndexConstraintOp, IndexInfo, Module, VTab, VTabConnection,'), (13, '    VTabCursor, Values,'), (20, '    conn.create_module(\"generate_series\", &SERIES_MODULE, aux)'), (21, '}'), (23, 'lazy_static::lazy_static! {'), (24, '    static ref SERIES_MODULE: Module<SeriesTab> = eponymous_only_module::<SeriesTab>(1);')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "6",
    "nloc": "237"
  },
  {
    "file_change_id": "105692029886552",
    "hash": "3c6b57fe1b2cc87e7ebecde43dd836ffb1c4ea5c",
    "old_path": "tests/vtab.rs",
    "new_path": "tests/vtab.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -11,7 +11,7 @@ fn test_dummy_module() {\n     use rusqlite::{version_number, Connection, Result};\n     use std::os::raw::c_int;\n \n-    let module = eponymous_only_module::<DummyTab>(1);\n+    let module = eponymous_only_module::<DummyTab>();\n \n     #[repr(C)]\n     struct DummyTab {\n@@ -19,7 +19,7 @@ fn test_dummy_module() {\n         base: sqlite3_vtab,\n     }\n \n-    impl VTab for DummyTab {\n+    unsafe impl VTab for DummyTab {\n         type Aux = ();\n         type Cursor = DummyTabCursor;\n \n@@ -53,7 +53,7 @@ fn test_dummy_module() {\n         row_id: i64,\n     }\n \n-    impl VTabCursor for DummyTabCursor {\n+    unsafe impl VTabCursor for DummyTabCursor {\n         fn filter(\n             &mut self,\n             _idx_num: c_int,\n",
    "diff_parsed": "{'added': [(14, '    let module = eponymous_only_module::<DummyTab>();'), (22, '    unsafe impl VTab for DummyTab {'), (56, '    unsafe impl VTabCursor for DummyTabCursor {')], 'deleted': [(14, '    let module = eponymous_only_module::<DummyTab>(1);'), (22, '    impl VTab for DummyTab {'), (56, '    impl VTabCursor for DummyTabCursor {')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "3",
    "nloc": "79"
  },
  {
    "file_change_id": "216043639287823",
    "hash": "01940637dd8f3bfeeee3faf9639fa9ae52f19f4d",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -79,7 +79,7 @@ macro_rules! array {\n         #[allow(unsafe_code)]\n         fn create_arr<T>(mut callback: impl FnMut(usize) -> T) -> [T; COUNT] {\n             let mut arr = $crate::__core::mem::MaybeUninit::uninit();\n-            let mut vec = $crate::__ArrayVec::<T>::new(arr.as_mut_ptr() as *mut T);\n+            let mut vec = $crate::__ArrayVec::<T>::new((&mut arr).as_mut_ptr() as *mut T);\n             unsafe {\n                 // Loop invariant: vec[..vec.length] is valid\n                 for i in 0..COUNT {\n@@ -90,8 +90,8 @@ macro_rules! array {\n                     //\n                     // The value is set before writing the value to avoid need to perform\n                     // addition by 1.\n-                    *vec.length() = i;\n-                    $crate::__core::ptr::write(vec.start().add(i), callback(i));\n+                    *(&mut vec).length() = i;\n+                    $crate::__core::ptr::write((&vec).start().add(i), callback(i));\n                 }\n                 // Loop escaped without panicking, avoid dropping elements.\n                 $crate::__core::mem::forget(vec);\n",
    "diff_parsed": "{'added': [(82, '            let mut vec = $crate::__ArrayVec::<T>::new((&mut arr).as_mut_ptr() as *mut T);'), (93, '                    *(&mut vec).length() = i;'), (94, '                    $crate::__core::ptr::write((&vec).start().add(i), callback(i));')], 'deleted': [(82, '            let mut vec = $crate::__ArrayVec::<T>::new(arr.as_mut_ptr() as *mut T);'), (93, '                    *vec.length() = i;'), (94, '                    $crate::__core::ptr::write(vec.start().add(i), callback(i));')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "3",
    "nloc": "59"
  },
  {
    "file_change_id": "74075940571272",
    "hash": "01940637dd8f3bfeeee3faf9639fa9ae52f19f4d",
    "old_path": "tests/test.rs",
    "new_path": "tests/test.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -108,3 +108,16 @@ fn array_of_void_panic_safety() {\n     }\n     internal(|| -> ! { panic!() });\n }\n+\n+#[test]\n+fn malicious_length() {\n+    trait Evil {\n+        fn length(&self) -> *mut usize;\n+    }\n+    impl<T> Evil for T {\n+        fn length(&self) -> *mut usize {\n+            42 as *mut usize\n+        }\n+    }\n+    assert_eq!(array![1; 3], [1, 1, 1]);\n+}\n",
    "diff_parsed": "{'added': [(112, '#[test]'), (113, 'fn malicious_length() {'), (114, '    trait Evil {'), (115, '        fn length(&self) -> *mut usize;'), (116, '    }'), (117, '    impl<T> Evil for T {'), (118, '        fn length(&self) -> *mut usize {'), (119, '            42 as *mut usize'), (120, '        }'), (121, '    }'), (122, '    assert_eq!(array![1; 3], [1, 1, 1]);'), (123, '}')], 'deleted': []}",
    "num_lines_added": "12",
    "num_lines_deleted": "0",
    "nloc": "107"
  },
  {
    "file_change_id": "253253553344978",
    "hash": "f7d120a3b724d06a7b623d0a4306acf8f78cb4f0",
    "old_path": "benches/lib.rs",
    "new_path": "benches/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -89,7 +89,8 @@ fn scoped_yield_bench(b: &mut Bencher) {\n             i += 1;\n             match v {\n                 Some(x) => {\n-                    assert_eq!(x, i);\n+                    dbg!(x, i);\n+                    // assert_eq!(x, i);\n                 }\n                 None => {\n                     // for elegant exit\n",
    "diff_parsed": "{'added': [(92, '                    dbg!(x, i);')], 'deleted': [(92, '                    assert_eq!(x, i);')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "147"
  },
  {
    "file_change_id": "118308321494506",
    "hash": "f7d120a3b724d06a7b623d0a4306acf8f78cb4f0",
    "old_path": "examples/pipe.rs",
    "new_path": "examples/pipe.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -2,7 +2,7 @@ use generator::*;\n \n fn main() {\n     // fn square<'a, T: Iterator<Item = u32> + 'a>(input: T) -> impl Iterator<Item = u32> + 'a {\n-    fn square<'a, T: Iterator<Item = u32> + 'a>(input: T) -> Generator<'a, (), u32> {\n+    fn square<'a, T: Iterator<Item = u32> + Send + 'a>(input: T) -> Generator<'a, (), u32> {\n         Gn::new_scoped(|mut s| {\n             for i in input {\n                 s.yield_with(i * i);\n@@ -12,7 +12,7 @@ fn main() {\n     }\n \n     // fn sum<'a, T: Iterator<Item = u32> + 'a>(input: T) -> impl Iterator<Item = u32> + 'a {\n-    fn sum<'a, T: Iterator<Item = u32> + 'a>(input: T) -> Generator<'a, (), u32> {\n+    fn sum<'a, T: Iterator<Item = u32> + Send + 'a>(input: T) -> Generator<'a, (), u32> {\n         Gn::new_scoped(|mut s| {\n             let mut acc = 0;\n             for i in input {\n",
    "diff_parsed": "{'added': [(5, \"    fn square<'a, T: Iterator<Item = u32> + Send + 'a>(input: T) -> Generator<'a, (), u32> {\"), (15, \"    fn sum<'a, T: Iterator<Item = u32> + Send + 'a>(input: T) -> Generator<'a, (), u32> {\")], 'deleted': [(5, \"    fn square<'a, T: Iterator<Item = u32> + 'a>(input: T) -> Generator<'a, (), u32> {\"), (15, \"    fn sum<'a, T: Iterator<Item = u32> + 'a>(input: T) -> Generator<'a, (), u32> {\")]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "26"
  },
  {
    "file_change_id": "4367368675291",
    "hash": "f7d120a3b724d06a7b623d0a4306acf8f78cb4f0",
    "old_path": "src/detail/aarch64_unix.rs",
    "new_path": "src/detail/aarch64_unix.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -42,9 +42,10 @@ pub fn initialize_call_frame(\n     const X19: usize = 19 - 19;\n     const X20: usize = 20 - 19;\n     const X21: usize = 21 - 19;\n-    const FP: usize  = 29 - 19;\n-    const LR: usize  = 30 - 19;\n-    const SP: usize  = 31 - 19;\n+\n+    const FP: usize = 29 - 19;\n+    const LR: usize = 30 - 19;\n+    const SP: usize = 31 - 19;\n     \n     let sp = align_down(stack.end());\n \n@@ -56,7 +57,7 @@ pub fn initialize_call_frame(\n \n     // Aarch64 current stack frame pointer\n     regs.gpr[FP] = sp as usize;\n-    \n+\n     regs.gpr[LR] = bootstrap_green_task as usize;\n \n     // setup the init stack\n",
    "diff_parsed": "{'added': [(46, '    const FP: usize = 29 - 19;'), (47, '    const LR: usize = 30 - 19;'), (48, '    const SP: usize = 31 - 19;')], 'deleted': [(45, '    const FP: usize  = 29 - 19;'), (46, '    const LR: usize  = 30 - 19;'), (47, '    const SP: usize  = 31 - 19;')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "3",
    "nloc": "47"
  },
  {
    "file_change_id": "112913808961089",
    "hash": "f7d120a3b724d06a7b623d0a4306acf8f78cb4f0",
    "old_path": "src/gen_impl.rs",
    "new_path": "src/gen_impl.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -19,14 +19,52 @@ use crate::yield_::yield_now;\n // windows has a minimal size as 0x4a8!!!!\n pub const DEFAULT_STACK_SIZE: usize = 0x1000;\n \n-/// the generator type\n-pub struct Generator<'a, A, T> {\n+/// the generator obj type, the functor passed to it must be Send\n+pub struct GeneratorObj<'a, A, T, const LOCAL: bool> {\n     gen: StackBox<GeneratorImpl<'a, A, T>>,\n }\n \n-unsafe impl<A, T> Send for Generator<'static, A, T> {}\n+/// the generator type, the functor passed to it must be Send\n+pub type Generator<'a, A, T> = GeneratorObj<'a, A, T, false>;\n+\n+// only when A, T and Functor are all sendable, the generator could be send\n+unsafe impl<A: Send, T: Send> Send for Generator<'static, A, T> {}\n \n impl<'a, A, T> Generator<'a, A, T> {\n+    /// init a heap based generator with scoped closure\n+    pub fn scoped_init<F: FnOnce(Scope<'a, A, T>) -> T + Send + 'a>(&mut self, f: F)\n+    where\n+        T: Send + 'a,\n+        A: Send + 'a,\n+    {\n+        self.gen.scoped_init(f);\n+    }\n+\n+    /// init a heap based generator\n+    // it's can be used to re-init a 'done' generator before it's get dropped\n+    pub fn init_code<F: FnOnce() -> T + Send + 'a>(&mut self, f: F)\n+    where\n+        T: Send + 'a,\n+    {\n+        self.gen.init_code(f);\n+    }\n+}\n+\n+/// the local generator type, can't Send\n+pub type LocalGenerator<'a, A, T> = GeneratorObj<'a, A, T, true>;\n+\n+impl<'a, A, T> LocalGenerator<'a, A, T> {\n+    /// init a heap based generator with scoped closure\n+    pub fn scoped_init<F: FnOnce(Scope<'a, A, T>) -> T + 'a>(&mut self, f: F)\n+    where\n+        T: 'a,\n+        A: 'a,\n+    {\n+        self.gen.scoped_init(f);\n+    }\n+}\n+\n+impl<'a, A, T, const LOCAL: bool> GeneratorObj<'a, A, T, LOCAL> {\n     /// Constructs a Generator from a raw pointer.\n     ///\n     /// # Safety\n@@ -36,7 +74,7 @@ impl<'a, A, T> Generator<'a, A, T> {\n     /// function is called twice on the same raw pointer.\n     #[inline]\n     pub unsafe fn from_raw(raw: *mut usize) -> Self {\n-        Generator {\n+        GeneratorObj {\n             gen: StackBox::from_raw(raw as *mut GeneratorImpl<'a, A, T>),\n         }\n     }\n@@ -55,24 +93,6 @@ impl<'a, A, T> Generator<'a, A, T> {\n         self.gen.prefetch();\n     }\n \n-    /// init a heap based generator with scoped closure\n-    pub fn scoped_init<F: FnOnce(Scope<'a, A, T>) -> T + 'a>(&mut self, f: F)\n-    where\n-        T: 'a,\n-        A: 'a,\n-    {\n-        self.gen.scoped_init(f);\n-    }\n-\n-    /// init a heap based generator\n-    // it's can be used to re-init a 'done' generator before it's get dropped\n-    pub fn init_code<F: FnOnce() -> T + 'a>(&mut self, f: F)\n-    where\n-        T: 'a,\n-    {\n-        self.gen.init_code(f);\n-    }\n-\n     /// prepare the para that passed into generator before send\n     #[inline]\n     pub fn set_para(&mut self, para: A) {\n@@ -136,23 +156,24 @@ impl<'a, A, T> Generator<'a, A, T> {\n     }\n }\n \n-impl<'a, T> Iterator for Generator<'a, (), T> {\n+impl<'a, T, const LOCAL: bool> Iterator for GeneratorObj<'a, (), T, LOCAL> {\n     type Item = T;\n     fn next(&mut self) -> Option<T> {\n         self.resume()\n     }\n }\n \n-impl<'a, A, T> fmt::Debug for Generator<'a, A, T> {\n+impl<'a, A, T, const LOCAL: bool> fmt::Debug for GeneratorObj<'a, A, T, LOCAL> {\n     #[cfg(nightly)]\n     #[allow(unused_unsafe)]\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         use std::intrinsics::type_name;\n         write!(\n             f,\n-            \"Generator<{}, Output={}> {{ ... }}\",\n+            \"Generator<{}, Output={}, Local={}> {{ ... }}\",\n             unsafe { type_name::<A>() },\n-            unsafe { type_name::<T>() }\n+            unsafe { type_name::<T>() },\n+            LOCAL\n         )\n     }\n \n@@ -170,16 +191,38 @@ pub struct Gn<A = ()> {\n impl<A> Gn<A> {\n     /// create a scoped generator with default stack size\n     pub fn new_scoped<'a, T, F>(f: F) -> Generator<'a, A, T>\n+    where\n+        F: FnOnce(Scope<A, T>) -> T + Send + 'a,\n+        T: Send+ 'a,\n+        A: Send + 'a,\n+    {\n+        Self::new_scoped_opt(DEFAULT_STACK_SIZE, f)\n+    }\n+\n+    /// create a scoped local generator with default stack size\n+    pub fn new_scoped_local<'a, T, F>(f: F) -> LocalGenerator<'a, A, T>\n     where\n         F: FnOnce(Scope<A, T>) -> T + 'a,\n         T: 'a,\n         A: 'a,\n     {\n-        Self::new_scoped_opt(DEFAULT_STACK_SIZE, f)\n+        Self::new_scoped_opt_local(DEFAULT_STACK_SIZE, f)\n     }\n \n     /// create a scoped generator with specified stack size\n     pub fn new_scoped_opt<'a, T, F>(size: usize, f: F) -> Generator<'a, A, T>\n+    where\n+        F: FnOnce(Scope<A, T>) -> T + Send + 'a,\n+        T: Send + 'a,\n+        A: Send + 'a,\n+    {\n+        let mut gen = GeneratorImpl::<A, T>::new(Stack::new(size));\n+        gen.scoped_init(f);\n+        Generator { gen }\n+    }\n+\n+    /// create a scoped local generator with specified stack size\n+    pub fn new_scoped_opt_local<'a, T, F>(size: usize, f: F) -> LocalGenerator<'a, A, T>\n     where\n         F: FnOnce(Scope<A, T>) -> T + 'a,\n         T: 'a,\n@@ -187,7 +230,7 @@ impl<A> Gn<A> {\n     {\n         let mut gen = GeneratorImpl::<A, T>::new(Stack::new(size));\n         gen.scoped_init(f);\n-        Generator { gen }\n+        LocalGenerator { gen }\n     }\n }\n \n@@ -197,7 +240,7 @@ impl<A: Any> Gn<A> {\n     #[deprecated(since = \"0.6.18\", note = \"please use `scope` version instead\")]\n     pub fn new<'a, T: Any, F>(f: F) -> Generator<'a, A, T>\n     where\n-        F: FnOnce() -> T + 'a,\n+        F: FnOnce() -> T + Send + 'a,\n     {\n         Self::new_opt(DEFAULT_STACK_SIZE, f)\n     }\n@@ -206,7 +249,7 @@ impl<A: Any> Gn<A> {\n     // the `may` library use this API so we can't deprecated it yet.\n     pub fn new_opt<'a, T: Any, F>(size: usize, f: F) -> Generator<'a, A, T>\n     where\n-        F: FnOnce() -> T + 'a,\n+        F: FnOnce() -> T + Send + 'a,\n     {\n         let mut gen = GeneratorImpl::<A, T>::new(Stack::new(size));\n         gen.init_context();\n",
    "diff_parsed": "{'added': [(23, \"pub struct GeneratorObj<'a, A, T, const LOCAL: bool> {\"), (28, \"pub type Generator<'a, A, T> = GeneratorObj<'a, A, T, false>;\"), (31, \"unsafe impl<A: Send, T: Send> Send for Generator<'static, A, T> {}\"), (35, \"    pub fn scoped_init<F: FnOnce(Scope<'a, A, T>) -> T + Send + 'a>(&mut self, f: F)\"), (36, '    where'), (37, \"        T: Send + 'a,\"), (38, \"        A: Send + 'a,\"), (39, '    {'), (40, '        self.gen.scoped_init(f);'), (41, '    }'), (45, \"    pub fn init_code<F: FnOnce() -> T + Send + 'a>(&mut self, f: F)\"), (46, '    where'), (47, \"        T: Send + 'a,\"), (48, '    {'), (49, '        self.gen.init_code(f);'), (50, '    }'), (51, '}'), (54, \"pub type LocalGenerator<'a, A, T> = GeneratorObj<'a, A, T, true>;\"), (56, \"impl<'a, A, T> LocalGenerator<'a, A, T> {\"), (58, \"    pub fn scoped_init<F: FnOnce(Scope<'a, A, T>) -> T + 'a>(&mut self, f: F)\"), (59, '    where'), (60, \"        T: 'a,\"), (61, \"        A: 'a,\"), (62, '    {'), (63, '        self.gen.scoped_init(f);'), (64, '    }'), (65, '}'), (67, \"impl<'a, A, T, const LOCAL: bool> GeneratorObj<'a, A, T, LOCAL> {\"), (77, '        GeneratorObj {'), (159, \"impl<'a, T, const LOCAL: bool> Iterator for GeneratorObj<'a, (), T, LOCAL> {\"), (166, \"impl<'a, A, T, const LOCAL: bool> fmt::Debug for GeneratorObj<'a, A, T, LOCAL> {\"), (173, '            \"Generator<{}, Output={}, Local={}> {{ ... }}\",'), (175, '            unsafe { type_name::<T>() },'), (176, '            LOCAL'), (194, '    where'), (195, \"        F: FnOnce(Scope<A, T>) -> T + Send + 'a,\"), (196, \"        T: Send+ 'a,\"), (197, \"        A: Send + 'a,\"), (198, '    {'), (199, '        Self::new_scoped_opt(DEFAULT_STACK_SIZE, f)'), (200, '    }'), (203, \"    pub fn new_scoped_local<'a, T, F>(f: F) -> LocalGenerator<'a, A, T>\"), (209, '        Self::new_scoped_opt_local(DEFAULT_STACK_SIZE, f)'), (214, '    where'), (215, \"        F: FnOnce(Scope<A, T>) -> T + Send + 'a,\"), (216, \"        T: Send + 'a,\"), (217, \"        A: Send + 'a,\"), (218, '    {'), (219, '        let mut gen = GeneratorImpl::<A, T>::new(Stack::new(size));'), (220, '        gen.scoped_init(f);'), (221, '        Generator { gen }'), (222, '    }'), (225, \"    pub fn new_scoped_opt_local<'a, T, F>(size: usize, f: F) -> LocalGenerator<'a, A, T>\"), (233, '        LocalGenerator { gen }'), (243, \"        F: FnOnce() -> T + Send + 'a,\"), (252, \"        F: FnOnce() -> T + Send + 'a,\")], 'deleted': [(23, \"pub struct Generator<'a, A, T> {\"), (27, \"unsafe impl<A, T> Send for Generator<'static, A, T> {}\"), (39, '        Generator {'), (59, \"    pub fn scoped_init<F: FnOnce(Scope<'a, A, T>) -> T + 'a>(&mut self, f: F)\"), (60, '    where'), (61, \"        T: 'a,\"), (62, \"        A: 'a,\"), (63, '    {'), (64, '        self.gen.scoped_init(f);'), (65, '    }'), (69, \"    pub fn init_code<F: FnOnce() -> T + 'a>(&mut self, f: F)\"), (70, '    where'), (71, \"        T: 'a,\"), (72, '    {'), (73, '        self.gen.init_code(f);'), (74, '    }'), (139, \"impl<'a, T> Iterator for Generator<'a, (), T> {\"), (146, \"impl<'a, A, T> fmt::Debug for Generator<'a, A, T> {\"), (153, '            \"Generator<{}, Output={}> {{ ... }}\",'), (155, '            unsafe { type_name::<T>() }'), (178, '        Self::new_scoped_opt(DEFAULT_STACK_SIZE, f)'), (190, '        Generator { gen }'), (200, \"        F: FnOnce() -> T + 'a,\"), (209, \"        F: FnOnce() -> T + 'a,\")]}",
    "num_lines_added": "56",
    "num_lines_deleted": "24",
    "nloc": "413"
  },
  {
    "file_change_id": "239691036184306",
    "hash": "f7d120a3b724d06a7b623d0a4306acf8f78cb4f0",
    "old_path": "tests/lib.rs",
    "new_path": "tests/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -125,9 +125,9 @@ fn test_scoped() {\n     let x = Rc::new(RefCell::new(10));\n \n     let x1 = x.clone();\n-    let mut g = Gn::<()>::new(move || {\n+    let mut g = Gn::<()>::new_scoped_local(move |mut s| {\n         *x1.borrow_mut() = 20;\n-        yield_with(());\n+        s.yield_with(());\n         *x1.borrow_mut() = 5;\n     });\n \n@@ -221,8 +221,7 @@ fn test_ill_drop() {\n fn test_loop_drop() {\n     let mut x = 10u32;\n     {\n-        // rust 1.17 can't deduce the output type!\n-        let mut g: Generator<_, ()> = Gn::<()>::new(|| {\n+        let mut g = Gn::<()>::new(|| {\n             x = 5;\n             loop {\n                 yield_with(());\n",
    "diff_parsed": "{'added': [(128, '    let mut g = Gn::<()>::new_scoped_local(move |mut s| {'), (130, '        s.yield_with(());'), (224, '        let mut g = Gn::<()>::new(|| {')], 'deleted': [(128, '    let mut g = Gn::<()>::new(move || {'), (130, '        yield_with(());'), (225, '        let mut g: Generator<_, ()> = Gn::<()>::new(|| {')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "3",
    "nloc": "371"
  },
  {
    "file_change_id": "253283239989772",
    "hash": "e965d8298f421e9c89fe98b1300b8361e948c324",
    "old_path": "None",
    "new_path": "actix-http/src/h1/chunked.rs",
    "change_type": "ModificationType.ADD",
    "diff": "@@ -0,0 +1,432 @@\n+use std::{io, task::Poll};\n+\n+use bytes::{Buf as _, Bytes, BytesMut};\n+\n+macro_rules! byte (\n+    ($rdr:ident) => ({\n+        if $rdr.len() > 0 {\n+            let b = $rdr[0];\n+            $rdr.advance(1);\n+            b\n+        } else {\n+            return Poll::Pending\n+        }\n+    })\n+);\n+\n+#[derive(Debug, PartialEq, Clone)]\n+pub(super) enum ChunkedState {\n+    Size,\n+    SizeLws,\n+    Extension,\n+    SizeLf,\n+    Body,\n+    BodyCr,\n+    BodyLf,\n+    EndCr,\n+    EndLf,\n+    End,\n+}\n+\n+impl ChunkedState {\n+    pub(super) fn step(\n+        &self,\n+        body: &mut BytesMut,\n+        size: &mut u64,\n+        buf: &mut Option<Bytes>,\n+    ) -> Poll<Result<ChunkedState, io::Error>> {\n+        use self::ChunkedState::*;\n+        match *self {\n+            Size => ChunkedState::read_size(body, size),\n+            SizeLws => ChunkedState::read_size_lws(body),\n+            Extension => ChunkedState::read_extension(body),\n+            SizeLf => ChunkedState::read_size_lf(body, size),\n+            Body => ChunkedState::read_body(body, size, buf),\n+            BodyCr => ChunkedState::read_body_cr(body),\n+            BodyLf => ChunkedState::read_body_lf(body),\n+            EndCr => ChunkedState::read_end_cr(body),\n+            EndLf => ChunkedState::read_end_lf(body),\n+            End => Poll::Ready(Ok(ChunkedState::End)),\n+        }\n+    }\n+\n+    fn read_size(\n+        rdr: &mut BytesMut,\n+        size: &mut u64,\n+    ) -> Poll<Result<ChunkedState, io::Error>> {\n+        let radix = 16;\n+\n+        let rem = match byte!(rdr) {\n+            b @ b'0'..=b'9' => b - b'0',\n+            b @ b'a'..=b'f' => b + 10 - b'a',\n+            b @ b'A'..=b'F' => b + 10 - b'A',\n+            b'\\t' | b' ' => return Poll::Ready(Ok(ChunkedState::SizeLws)),\n+            b';' => return Poll::Ready(Ok(ChunkedState::Extension)),\n+            b'\\r' => return Poll::Ready(Ok(ChunkedState::SizeLf)),\n+            _ => {\n+                return Poll::Ready(Err(io::Error::new(\n+                    io::ErrorKind::InvalidInput,\n+                    \"Invalid chunk size line: Invalid Size\",\n+                )));\n+            }\n+        };\n+\n+        match size.checked_mul(radix) {\n+            Some(n) => {\n+                *size = n as u64;\n+                *size += rem as u64;\n+\n+                Poll::Ready(Ok(ChunkedState::Size))\n+            }\n+            None => {\n+                log::debug!(\"chunk size would overflow u64\");\n+                Poll::Ready(Err(io::Error::new(\n+                    io::ErrorKind::InvalidInput,\n+                    \"Invalid chunk size line: Size is too big\",\n+                )))\n+            }\n+        }\n+    }\n+\n+    fn read_size_lws(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {\n+        match byte!(rdr) {\n+            // LWS can follow the chunk size, but no more digits can come\n+            b'\\t' | b' ' => Poll::Ready(Ok(ChunkedState::SizeLws)),\n+            b';' => Poll::Ready(Ok(ChunkedState::Extension)),\n+            b'\\r' => Poll::Ready(Ok(ChunkedState::SizeLf)),\n+            _ => Poll::Ready(Err(io::Error::new(\n+                io::ErrorKind::InvalidInput,\n+                \"Invalid chunk size linear white space\",\n+            ))),\n+        }\n+    }\n+    fn read_extension(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {\n+        match byte!(rdr) {\n+            b'\\r' => Poll::Ready(Ok(ChunkedState::SizeLf)),\n+            // strictly 0x20 (space) should be disallowed but we don't parse quoted strings here\n+            0x00..=0x08 | 0x0a..=0x1f | 0x7f => Poll::Ready(Err(io::Error::new(\n+                io::ErrorKind::InvalidInput,\n+                \"Invalid character in chunk extension\",\n+            ))),\n+            _ => Poll::Ready(Ok(ChunkedState::Extension)), // no supported extensions\n+        }\n+    }\n+    fn read_size_lf(\n+        rdr: &mut BytesMut,\n+        size: &mut u64,\n+    ) -> Poll<Result<ChunkedState, io::Error>> {\n+        match byte!(rdr) {\n+            b'\\n' if *size > 0 => Poll::Ready(Ok(ChunkedState::Body)),\n+            b'\\n' if *size == 0 => Poll::Ready(Ok(ChunkedState::EndCr)),\n+            _ => Poll::Ready(Err(io::Error::new(\n+                io::ErrorKind::InvalidInput,\n+                \"Invalid chunk size LF\",\n+            ))),\n+        }\n+    }\n+\n+    fn read_body(\n+        rdr: &mut BytesMut,\n+        rem: &mut u64,\n+        buf: &mut Option<Bytes>,\n+    ) -> Poll<Result<ChunkedState, io::Error>> {\n+        log::trace!(\"Chunked read, remaining={:?}\", rem);\n+\n+        let len = rdr.len() as u64;\n+        if len == 0 {\n+            Poll::Ready(Ok(ChunkedState::Body))\n+        } else {\n+            let slice;\n+            if *rem > len {\n+                slice = rdr.split().freeze();\n+                *rem -= len;\n+            } else {\n+                slice = rdr.split_to(*rem as usize).freeze();\n+                *rem = 0;\n+            }\n+            *buf = Some(slice);\n+            if *rem > 0 {\n+                Poll::Ready(Ok(ChunkedState::Body))\n+            } else {\n+                Poll::Ready(Ok(ChunkedState::BodyCr))\n+            }\n+        }\n+    }\n+\n+    fn read_body_cr(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {\n+        match byte!(rdr) {\n+            b'\\r' => Poll::Ready(Ok(ChunkedState::BodyLf)),\n+            _ => Poll::Ready(Err(io::Error::new(\n+                io::ErrorKind::InvalidInput,\n+                \"Invalid chunk body CR\",\n+            ))),\n+        }\n+    }\n+    fn read_body_lf(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {\n+        match byte!(rdr) {\n+            b'\\n' => Poll::Ready(Ok(ChunkedState::Size)),\n+            _ => Poll::Ready(Err(io::Error::new(\n+                io::ErrorKind::InvalidInput,\n+                \"Invalid chunk body LF\",\n+            ))),\n+        }\n+    }\n+    fn read_end_cr(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {\n+        match byte!(rdr) {\n+            b'\\r' => Poll::Ready(Ok(ChunkedState::EndLf)),\n+            _ => Poll::Ready(Err(io::Error::new(\n+                io::ErrorKind::InvalidInput,\n+                \"Invalid chunk end CR\",\n+            ))),\n+        }\n+    }\n+    fn read_end_lf(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {\n+        match byte!(rdr) {\n+            b'\\n' => Poll::Ready(Ok(ChunkedState::End)),\n+            _ => Poll::Ready(Err(io::Error::new(\n+                io::ErrorKind::InvalidInput,\n+                \"Invalid chunk end LF\",\n+            ))),\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use actix_codec::Decoder as _;\n+    use bytes::{Bytes, BytesMut};\n+    use http::Method;\n+\n+    use crate::{\n+        error::ParseError,\n+        h1::decoder::{MessageDecoder, PayloadItem},\n+        HttpMessage as _, Request,\n+    };\n+\n+    macro_rules! parse_ready {\n+        ($e:expr) => {{\n+            match MessageDecoder::<Request>::default().decode($e) {\n+                Ok(Some((msg, _))) => msg,\n+                Ok(_) => unreachable!(\"Eof during parsing http request\"),\n+                Err(err) => unreachable!(\"Error during parsing http request: {:?}\", err),\n+            }\n+        }};\n+    }\n+\n+    macro_rules! expect_parse_err {\n+        ($e:expr) => {{\n+            match MessageDecoder::<Request>::default().decode($e) {\n+                Err(err) => match err {\n+                    ParseError::Io(_) => unreachable!(\"Parse error expected\"),\n+                    _ => {}\n+                },\n+                _ => unreachable!(\"Error expected\"),\n+            }\n+        }};\n+    }\n+\n+    #[test]\n+    fn test_parse_chunked_payload_chunk_extension() {\n+        let mut buf = BytesMut::from(\n+            \"GET /test HTTP/1.1\\r\\n\\\n+            transfer-encoding: chunked\\r\\n\\\n+            \\r\\n\",\n+        );\n+\n+        let mut reader = MessageDecoder::<Request>::default();\n+        let (msg, pl) = reader.decode(&mut buf).unwrap().unwrap();\n+        let mut pl = pl.unwrap();\n+        assert!(msg.chunked().unwrap());\n+\n+        buf.extend(b\"4;test\\r\\ndata\\r\\n4\\r\\nline\\r\\n0\\r\\n\\r\\n\"); // test: test\\r\\n\\r\\n\")\n+        let chunk = pl.decode(&mut buf).unwrap().unwrap().chunk();\n+        assert_eq!(chunk, Bytes::from_static(b\"data\"));\n+        let chunk = pl.decode(&mut buf).unwrap().unwrap().chunk();\n+        assert_eq!(chunk, Bytes::from_static(b\"line\"));\n+        let msg = pl.decode(&mut buf).unwrap().unwrap();\n+        assert!(msg.eof());\n+    }\n+\n+    #[test]\n+    fn test_request_chunked() {\n+        let mut buf = BytesMut::from(\n+            \"GET /test HTTP/1.1\\r\\n\\\n+             transfer-encoding: chunked\\r\\n\\r\\n\",\n+        );\n+        let req = parse_ready!(&mut buf);\n+\n+        if let Ok(val) = req.chunked() {\n+            assert!(val);\n+        } else {\n+            unreachable!(\"Error\");\n+        }\n+\n+        // intentional typo in \"chunked\"\n+        let mut buf = BytesMut::from(\n+            \"GET /test HTTP/1.1\\r\\n\\\n+             transfer-encoding: chnked\\r\\n\\r\\n\",\n+        );\n+        expect_parse_err!(&mut buf);\n+    }\n+\n+    #[test]\n+    fn test_http_request_chunked_payload() {\n+        let mut buf = BytesMut::from(\n+            \"GET /test HTTP/1.1\\r\\n\\\n+             transfer-encoding: chunked\\r\\n\\r\\n\",\n+        );\n+        let mut reader = MessageDecoder::<Request>::default();\n+        let (req, pl) = reader.decode(&mut buf).unwrap().unwrap();\n+        let mut pl = pl.unwrap();\n+        assert!(req.chunked().unwrap());\n+\n+        buf.extend(b\"4\\r\\ndata\\r\\n4\\r\\nline\\r\\n0\\r\\n\\r\\n\");\n+        assert_eq!(\n+            pl.decode(&mut buf).unwrap().unwrap().chunk().as_ref(),\n+            b\"data\"\n+        );\n+        assert_eq!(\n+            pl.decode(&mut buf).unwrap().unwrap().chunk().as_ref(),\n+            b\"line\"\n+        );\n+        assert!(pl.decode(&mut buf).unwrap().unwrap().eof());\n+    }\n+\n+    #[test]\n+    fn test_http_request_chunked_payload_and_next_message() {\n+        let mut buf = BytesMut::from(\n+            \"GET /test HTTP/1.1\\r\\n\\\n+             transfer-encoding: chunked\\r\\n\\r\\n\",\n+        );\n+        let mut reader = MessageDecoder::<Request>::default();\n+        let (req, pl) = reader.decode(&mut buf).unwrap().unwrap();\n+        let mut pl = pl.unwrap();\n+        assert!(req.chunked().unwrap());\n+\n+        buf.extend(\n+            b\"4\\r\\ndata\\r\\n4\\r\\nline\\r\\n0\\r\\n\\r\\n\\\n+              POST /test2 HTTP/1.1\\r\\n\\\n+              transfer-encoding: chunked\\r\\n\\r\\n\"\n+                .iter(),\n+        );\n+        let msg = pl.decode(&mut buf).unwrap().unwrap();\n+        assert_eq!(msg.chunk().as_ref(), b\"data\");\n+        let msg = pl.decode(&mut buf).unwrap().unwrap();\n+        assert_eq!(msg.chunk().as_ref(), b\"line\");\n+        let msg = pl.decode(&mut buf).unwrap().unwrap();\n+        assert!(msg.eof());\n+\n+        let (req, _) = reader.decode(&mut buf).unwrap().unwrap();\n+        assert!(req.chunked().unwrap());\n+        assert_eq!(*req.method(), Method::POST);\n+        assert!(req.chunked().unwrap());\n+    }\n+\n+    #[test]\n+    fn test_http_request_chunked_payload_chunks() {\n+        let mut buf = BytesMut::from(\n+            \"GET /test HTTP/1.1\\r\\n\\\n+             transfer-encoding: chunked\\r\\n\\r\\n\",\n+        );\n+\n+        let mut reader = MessageDecoder::<Request>::default();\n+        let (req, pl) = reader.decode(&mut buf).unwrap().unwrap();\n+        let mut pl = pl.unwrap();\n+        assert!(req.chunked().unwrap());\n+\n+        buf.extend(b\"4\\r\\n1111\\r\\n\");\n+        let msg = pl.decode(&mut buf).unwrap().unwrap();\n+        assert_eq!(msg.chunk().as_ref(), b\"1111\");\n+\n+        buf.extend(b\"4\\r\\ndata\\r\");\n+        let msg = pl.decode(&mut buf).unwrap().unwrap();\n+        assert_eq!(msg.chunk().as_ref(), b\"data\");\n+\n+        buf.extend(b\"\\n4\");\n+        assert!(pl.decode(&mut buf).unwrap().is_none());\n+\n+        buf.extend(b\"\\r\");\n+        assert!(pl.decode(&mut buf).unwrap().is_none());\n+        buf.extend(b\"\\n\");\n+        assert!(pl.decode(&mut buf).unwrap().is_none());\n+\n+        buf.extend(b\"li\");\n+        let msg = pl.decode(&mut buf).unwrap().unwrap();\n+        assert_eq!(msg.chunk().as_ref(), b\"li\");\n+\n+        //trailers\n+        //buf.feed_data(\"test: test\\r\\n\");\n+        //not_ready!(reader.parse(&mut buf, &mut readbuf));\n+\n+        buf.extend(b\"ne\\r\\n0\\r\\n\");\n+        let msg = pl.decode(&mut buf).unwrap().unwrap();\n+        assert_eq!(msg.chunk().as_ref(), b\"ne\");\n+        assert!(pl.decode(&mut buf).unwrap().is_none());\n+\n+        buf.extend(b\"\\r\\n\");\n+        assert!(pl.decode(&mut buf).unwrap().unwrap().eof());\n+    }\n+\n+    #[test]\n+    fn chunk_extension_quoted() {\n+        let mut buf = BytesMut::from(\n+            \"GET /test HTTP/1.1\\r\\n\\\n+            Host: localhost:8080\\r\\n\\\n+            Transfer-Encoding: chunked\\r\\n\\\n+            \\r\\n\\\n+            2;hello=b;one=\\\"1 2 3\\\"\\r\\n\\\n+            xx\",\n+        );\n+\n+        let mut reader = MessageDecoder::<Request>::default();\n+        let (_msg, pl) = reader.decode(&mut buf).unwrap().unwrap();\n+        let mut pl = pl.unwrap();\n+\n+        let chunk = pl.decode(&mut buf).unwrap().unwrap();\n+        assert_eq!(chunk, PayloadItem::Chunk(Bytes::from_static(b\"xx\")));\n+    }\n+\n+    #[test]\n+    fn hrs_chunk_extension_invalid() {\n+        let mut buf = BytesMut::from(\n+            \"GET / HTTP/1.1\\r\\n\\\n+            Host: localhost:8080\\r\\n\\\n+            Transfer-Encoding: chunked\\r\\n\\\n+            \\r\\n\\\n+            2;x\\nx\\r\\n\\\n+            4c\\r\\n\\\n+            0\\r\\n\",\n+        );\n+\n+        let mut reader = MessageDecoder::<Request>::default();\n+        let (_msg, pl) = reader.decode(&mut buf).unwrap().unwrap();\n+        let mut pl = pl.unwrap();\n+\n+        let err = pl.decode(&mut buf).unwrap_err();\n+        assert!(err\n+            .to_string()\n+            .contains(\"Invalid character in chunk extension\"));\n+    }\n+\n+    #[test]\n+    fn hrs_chunk_size_overflow() {\n+        let mut buf = BytesMut::from(\n+            \"GET / HTTP/1.1\\r\\n\\\n+            Host: example.com\\r\\n\\\n+            Transfer-Encoding: chunked\\r\\n\\\n+            \\r\\n\\\n+            f0000000000000003\\r\\n\\\n+            abc\\r\\n\\\n+            0\\r\\n\",\n+        );\n+\n+        let mut reader = MessageDecoder::<Request>::default();\n+        let (_msg, pl) = reader.decode(&mut buf).unwrap().unwrap();\n+        let mut pl = pl.unwrap();\n+\n+        let err = pl.decode(&mut buf).unwrap_err();\n+        assert!(err\n+            .to_string()\n+            .contains(\"Invalid chunk size line: Size is too big\"));\n+    }\n+}\n",
    "diff_parsed": "{'added': [(1, 'use std::{io, task::Poll};'), (3, 'use bytes::{Buf as _, Bytes, BytesMut};'), (5, 'macro_rules! byte ('), (6, '    ($rdr:ident) => ({'), (7, '        if $rdr.len() > 0 {'), (8, '            let b = $rdr[0];'), (9, '            $rdr.advance(1);'), (10, '            b'), (11, '        } else {'), (12, '            return Poll::Pending'), (13, '        }'), (14, '    })'), (15, ');'), (17, '#[derive(Debug, PartialEq, Clone)]'), (18, 'pub(super) enum ChunkedState {'), (19, '    Size,'), (20, '    SizeLws,'), (21, '    Extension,'), (22, '    SizeLf,'), (23, '    Body,'), (24, '    BodyCr,'), (25, '    BodyLf,'), (26, '    EndCr,'), (27, '    EndLf,'), (28, '    End,'), (29, '}'), (31, 'impl ChunkedState {'), (32, '    pub(super) fn step('), (33, '        &self,'), (34, '        body: &mut BytesMut,'), (35, '        size: &mut u64,'), (36, '        buf: &mut Option<Bytes>,'), (37, '    ) -> Poll<Result<ChunkedState, io::Error>> {'), (38, '        use self::ChunkedState::*;'), (39, '        match *self {'), (40, '            Size => ChunkedState::read_size(body, size),'), (41, '            SizeLws => ChunkedState::read_size_lws(body),'), (42, '            Extension => ChunkedState::read_extension(body),'), (43, '            SizeLf => ChunkedState::read_size_lf(body, size),'), (44, '            Body => ChunkedState::read_body(body, size, buf),'), (45, '            BodyCr => ChunkedState::read_body_cr(body),'), (46, '            BodyLf => ChunkedState::read_body_lf(body),'), (47, '            EndCr => ChunkedState::read_end_cr(body),'), (48, '            EndLf => ChunkedState::read_end_lf(body),'), (49, '            End => Poll::Ready(Ok(ChunkedState::End)),'), (50, '        }'), (51, '    }'), (53, '    fn read_size('), (54, '        rdr: &mut BytesMut,'), (55, '        size: &mut u64,'), (56, '    ) -> Poll<Result<ChunkedState, io::Error>> {'), (57, '        let radix = 16;'), (59, '        let rem = match byte!(rdr) {'), (60, \"            b @ b'0'..=b'9' => b - b'0',\"), (61, \"            b @ b'a'..=b'f' => b + 10 - b'a',\"), (62, \"            b @ b'A'..=b'F' => b + 10 - b'A',\"), (63, \"            b'\\\\t' | b' ' => return Poll::Ready(Ok(ChunkedState::SizeLws)),\"), (64, \"            b';' => return Poll::Ready(Ok(ChunkedState::Extension)),\"), (65, \"            b'\\\\r' => return Poll::Ready(Ok(ChunkedState::SizeLf)),\"), (66, '            _ => {'), (67, '                return Poll::Ready(Err(io::Error::new('), (68, '                    io::ErrorKind::InvalidInput,'), (69, '                    \"Invalid chunk size line: Invalid Size\",'), (70, '                )));'), (71, '            }'), (72, '        };'), (74, '        match size.checked_mul(radix) {'), (75, '            Some(n) => {'), (76, '                *size = n as u64;'), (77, '                *size += rem as u64;'), (79, '                Poll::Ready(Ok(ChunkedState::Size))'), (80, '            }'), (81, '            None => {'), (82, '                log::debug!(\"chunk size would overflow u64\");'), (83, '                Poll::Ready(Err(io::Error::new('), (84, '                    io::ErrorKind::InvalidInput,'), (85, '                    \"Invalid chunk size line: Size is too big\",'), (86, '                )))'), (87, '            }'), (88, '        }'), (89, '    }'), (91, '    fn read_size_lws(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {'), (92, '        match byte!(rdr) {'), (94, \"            b'\\\\t' | b' ' => Poll::Ready(Ok(ChunkedState::SizeLws)),\"), (95, \"            b';' => Poll::Ready(Ok(ChunkedState::Extension)),\"), (96, \"            b'\\\\r' => Poll::Ready(Ok(ChunkedState::SizeLf)),\"), (97, '            _ => Poll::Ready(Err(io::Error::new('), (98, '                io::ErrorKind::InvalidInput,'), (99, '                \"Invalid chunk size linear white space\",'), (100, '            ))),'), (101, '        }'), (102, '    }'), (103, '    fn read_extension(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {'), (104, '        match byte!(rdr) {'), (105, \"            b'\\\\r' => Poll::Ready(Ok(ChunkedState::SizeLf)),\"), (107, '            0x00..=0x08 | 0x0a..=0x1f | 0x7f => Poll::Ready(Err(io::Error::new('), (108, '                io::ErrorKind::InvalidInput,'), (109, '                \"Invalid character in chunk extension\",'), (110, '            ))),'), (111, '            _ => Poll::Ready(Ok(ChunkedState::Extension)), // no supported extensions'), (112, '        }'), (113, '    }'), (114, '    fn read_size_lf('), (115, '        rdr: &mut BytesMut,'), (116, '        size: &mut u64,'), (117, '    ) -> Poll<Result<ChunkedState, io::Error>> {'), (118, '        match byte!(rdr) {'), (119, \"            b'\\\\n' if *size > 0 => Poll::Ready(Ok(ChunkedState::Body)),\"), (120, \"            b'\\\\n' if *size == 0 => Poll::Ready(Ok(ChunkedState::EndCr)),\"), (121, '            _ => Poll::Ready(Err(io::Error::new('), (122, '                io::ErrorKind::InvalidInput,'), (123, '                \"Invalid chunk size LF\",'), (124, '            ))),'), (125, '        }'), (126, '    }'), (128, '    fn read_body('), (129, '        rdr: &mut BytesMut,'), (130, '        rem: &mut u64,'), (131, '        buf: &mut Option<Bytes>,'), (132, '    ) -> Poll<Result<ChunkedState, io::Error>> {'), (133, '        log::trace!(\"Chunked read, remaining={:?}\", rem);'), (135, '        let len = rdr.len() as u64;'), (136, '        if len == 0 {'), (137, '            Poll::Ready(Ok(ChunkedState::Body))'), (138, '        } else {'), (139, '            let slice;'), (140, '            if *rem > len {'), (141, '                slice = rdr.split().freeze();'), (142, '                *rem -= len;'), (143, '            } else {'), (144, '                slice = rdr.split_to(*rem as usize).freeze();'), (145, '                *rem = 0;'), (146, '            }'), (147, '            *buf = Some(slice);'), (148, '            if *rem > 0 {'), (149, '                Poll::Ready(Ok(ChunkedState::Body))'), (150, '            } else {'), (151, '                Poll::Ready(Ok(ChunkedState::BodyCr))'), (152, '            }'), (153, '        }'), (154, '    }'), (156, '    fn read_body_cr(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {'), (157, '        match byte!(rdr) {'), (158, \"            b'\\\\r' => Poll::Ready(Ok(ChunkedState::BodyLf)),\"), (159, '            _ => Poll::Ready(Err(io::Error::new('), (160, '                io::ErrorKind::InvalidInput,'), (161, '                \"Invalid chunk body CR\",'), (162, '            ))),'), (163, '        }'), (164, '    }'), (165, '    fn read_body_lf(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {'), (166, '        match byte!(rdr) {'), (167, \"            b'\\\\n' => Poll::Ready(Ok(ChunkedState::Size)),\"), (168, '            _ => Poll::Ready(Err(io::Error::new('), (169, '                io::ErrorKind::InvalidInput,'), (170, '                \"Invalid chunk body LF\",'), (171, '            ))),'), (172, '        }'), (173, '    }'), (174, '    fn read_end_cr(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {'), (175, '        match byte!(rdr) {'), (176, \"            b'\\\\r' => Poll::Ready(Ok(ChunkedState::EndLf)),\"), (177, '            _ => Poll::Ready(Err(io::Error::new('), (178, '                io::ErrorKind::InvalidInput,'), (179, '                \"Invalid chunk end CR\",'), (180, '            ))),'), (181, '        }'), (182, '    }'), (183, '    fn read_end_lf(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {'), (184, '        match byte!(rdr) {'), (185, \"            b'\\\\n' => Poll::Ready(Ok(ChunkedState::End)),\"), (186, '            _ => Poll::Ready(Err(io::Error::new('), (187, '                io::ErrorKind::InvalidInput,'), (188, '                \"Invalid chunk end LF\",'), (189, '            ))),'), (190, '        }'), (191, '    }'), (192, '}'), (194, '#[cfg(test)]'), (195, 'mod tests {'), (196, '    use actix_codec::Decoder as _;'), (197, '    use bytes::{Bytes, BytesMut};'), (198, '    use http::Method;'), (200, '    use crate::{'), (201, '        error::ParseError,'), (202, '        h1::decoder::{MessageDecoder, PayloadItem},'), (203, '        HttpMessage as _, Request,'), (204, '    };'), (206, '    macro_rules! parse_ready {'), (207, '        ($e:expr) => {{'), (208, '            match MessageDecoder::<Request>::default().decode($e) {'), (209, '                Ok(Some((msg, _))) => msg,'), (210, '                Ok(_) => unreachable!(\"Eof during parsing http request\"),'), (211, '                Err(err) => unreachable!(\"Error during parsing http request: {:?}\", err),'), (212, '            }'), (213, '        }};'), (214, '    }'), (216, '    macro_rules! expect_parse_err {'), (217, '        ($e:expr) => {{'), (218, '            match MessageDecoder::<Request>::default().decode($e) {'), (219, '                Err(err) => match err {'), (220, '                    ParseError::Io(_) => unreachable!(\"Parse error expected\"),'), (221, '                    _ => {}'), (222, '                },'), (223, '                _ => unreachable!(\"Error expected\"),'), (224, '            }'), (225, '        }};'), (226, '    }'), (228, '    #[test]'), (229, '    fn test_parse_chunked_payload_chunk_extension() {'), (230, '        let mut buf = BytesMut::from('), (231, '            \"GET /test HTTP/1.1\\\\r\\\\n\\\\'), (232, '            transfer-encoding: chunked\\\\r\\\\n\\\\'), (233, '            \\\\r\\\\n\",'), (234, '        );'), (236, '        let mut reader = MessageDecoder::<Request>::default();'), (237, '        let (msg, pl) = reader.decode(&mut buf).unwrap().unwrap();'), (238, '        let mut pl = pl.unwrap();'), (239, '        assert!(msg.chunked().unwrap());'), (241, '        buf.extend(b\"4;test\\\\r\\\\ndata\\\\r\\\\n4\\\\r\\\\nline\\\\r\\\\n0\\\\r\\\\n\\\\r\\\\n\"); // test: test\\\\r\\\\n\\\\r\\\\n\")'), (242, '        let chunk = pl.decode(&mut buf).unwrap().unwrap().chunk();'), (243, '        assert_eq!(chunk, Bytes::from_static(b\"data\"));'), (244, '        let chunk = pl.decode(&mut buf).unwrap().unwrap().chunk();'), (245, '        assert_eq!(chunk, Bytes::from_static(b\"line\"));'), (246, '        let msg = pl.decode(&mut buf).unwrap().unwrap();'), (247, '        assert!(msg.eof());'), (248, '    }'), (250, '    #[test]'), (251, '    fn test_request_chunked() {'), (252, '        let mut buf = BytesMut::from('), (253, '            \"GET /test HTTP/1.1\\\\r\\\\n\\\\'), (254, '             transfer-encoding: chunked\\\\r\\\\n\\\\r\\\\n\",'), (255, '        );'), (256, '        let req = parse_ready!(&mut buf);'), (258, '        if let Ok(val) = req.chunked() {'), (259, '            assert!(val);'), (260, '        } else {'), (261, '            unreachable!(\"Error\");'), (262, '        }'), (265, '        let mut buf = BytesMut::from('), (266, '            \"GET /test HTTP/1.1\\\\r\\\\n\\\\'), (267, '             transfer-encoding: chnked\\\\r\\\\n\\\\r\\\\n\",'), (268, '        );'), (269, '        expect_parse_err!(&mut buf);'), (270, '    }'), (272, '    #[test]'), (273, '    fn test_http_request_chunked_payload() {'), (274, '        let mut buf = BytesMut::from('), (275, '            \"GET /test HTTP/1.1\\\\r\\\\n\\\\'), (276, '             transfer-encoding: chunked\\\\r\\\\n\\\\r\\\\n\",'), (277, '        );'), (278, '        let mut reader = MessageDecoder::<Request>::default();'), (279, '        let (req, pl) = reader.decode(&mut buf).unwrap().unwrap();'), (280, '        let mut pl = pl.unwrap();'), (281, '        assert!(req.chunked().unwrap());'), (283, '        buf.extend(b\"4\\\\r\\\\ndata\\\\r\\\\n4\\\\r\\\\nline\\\\r\\\\n0\\\\r\\\\n\\\\r\\\\n\");'), (284, '        assert_eq!('), (285, '            pl.decode(&mut buf).unwrap().unwrap().chunk().as_ref(),'), (286, '            b\"data\"'), (287, '        );'), (288, '        assert_eq!('), (289, '            pl.decode(&mut buf).unwrap().unwrap().chunk().as_ref(),'), (290, '            b\"line\"'), (291, '        );'), (292, '        assert!(pl.decode(&mut buf).unwrap().unwrap().eof());'), (293, '    }'), (295, '    #[test]'), (296, '    fn test_http_request_chunked_payload_and_next_message() {'), (297, '        let mut buf = BytesMut::from('), (298, '            \"GET /test HTTP/1.1\\\\r\\\\n\\\\'), (299, '             transfer-encoding: chunked\\\\r\\\\n\\\\r\\\\n\",'), (300, '        );'), (301, '        let mut reader = MessageDecoder::<Request>::default();'), (302, '        let (req, pl) = reader.decode(&mut buf).unwrap().unwrap();'), (303, '        let mut pl = pl.unwrap();'), (304, '        assert!(req.chunked().unwrap());'), (306, '        buf.extend('), (307, '            b\"4\\\\r\\\\ndata\\\\r\\\\n4\\\\r\\\\nline\\\\r\\\\n0\\\\r\\\\n\\\\r\\\\n\\\\'), (308, '              POST /test2 HTTP/1.1\\\\r\\\\n\\\\'), (309, '              transfer-encoding: chunked\\\\r\\\\n\\\\r\\\\n\"'), (310, '                .iter(),'), (311, '        );'), (312, '        let msg = pl.decode(&mut buf).unwrap().unwrap();'), (313, '        assert_eq!(msg.chunk().as_ref(), b\"data\");'), (314, '        let msg = pl.decode(&mut buf).unwrap().unwrap();'), (315, '        assert_eq!(msg.chunk().as_ref(), b\"line\");'), (316, '        let msg = pl.decode(&mut buf).unwrap().unwrap();'), (317, '        assert!(msg.eof());'), (319, '        let (req, _) = reader.decode(&mut buf).unwrap().unwrap();'), (320, '        assert!(req.chunked().unwrap());'), (321, '        assert_eq!(*req.method(), Method::POST);'), (322, '        assert!(req.chunked().unwrap());'), (323, '    }'), (325, '    #[test]'), (326, '    fn test_http_request_chunked_payload_chunks() {'), (327, '        let mut buf = BytesMut::from('), (328, '            \"GET /test HTTP/1.1\\\\r\\\\n\\\\'), (329, '             transfer-encoding: chunked\\\\r\\\\n\\\\r\\\\n\",'), (330, '        );'), (332, '        let mut reader = MessageDecoder::<Request>::default();'), (333, '        let (req, pl) = reader.decode(&mut buf).unwrap().unwrap();'), (334, '        let mut pl = pl.unwrap();'), (335, '        assert!(req.chunked().unwrap());'), (337, '        buf.extend(b\"4\\\\r\\\\n1111\\\\r\\\\n\");'), (338, '        let msg = pl.decode(&mut buf).unwrap().unwrap();'), (339, '        assert_eq!(msg.chunk().as_ref(), b\"1111\");'), (341, '        buf.extend(b\"4\\\\r\\\\ndata\\\\r\");'), (342, '        let msg = pl.decode(&mut buf).unwrap().unwrap();'), (343, '        assert_eq!(msg.chunk().as_ref(), b\"data\");'), (345, '        buf.extend(b\"\\\\n4\");'), (346, '        assert!(pl.decode(&mut buf).unwrap().is_none());'), (348, '        buf.extend(b\"\\\\r\");'), (349, '        assert!(pl.decode(&mut buf).unwrap().is_none());'), (350, '        buf.extend(b\"\\\\n\");'), (351, '        assert!(pl.decode(&mut buf).unwrap().is_none());'), (353, '        buf.extend(b\"li\");'), (354, '        let msg = pl.decode(&mut buf).unwrap().unwrap();'), (355, '        assert_eq!(msg.chunk().as_ref(), b\"li\");'), (361, '        buf.extend(b\"ne\\\\r\\\\n0\\\\r\\\\n\");'), (362, '        let msg = pl.decode(&mut buf).unwrap().unwrap();'), (363, '        assert_eq!(msg.chunk().as_ref(), b\"ne\");'), (364, '        assert!(pl.decode(&mut buf).unwrap().is_none());'), (366, '        buf.extend(b\"\\\\r\\\\n\");'), (367, '        assert!(pl.decode(&mut buf).unwrap().unwrap().eof());'), (368, '    }'), (370, '    #[test]'), (371, '    fn chunk_extension_quoted() {'), (372, '        let mut buf = BytesMut::from('), (373, '            \"GET /test HTTP/1.1\\\\r\\\\n\\\\'), (374, '            Host: localhost:8080\\\\r\\\\n\\\\'), (375, '            Transfer-Encoding: chunked\\\\r\\\\n\\\\'), (376, '            \\\\r\\\\n\\\\'), (377, '            2;hello=b;one=\\\\\"1 2 3\\\\\"\\\\r\\\\n\\\\'), (378, '            xx\",'), (379, '        );'), (381, '        let mut reader = MessageDecoder::<Request>::default();'), (382, '        let (_msg, pl) = reader.decode(&mut buf).unwrap().unwrap();'), (383, '        let mut pl = pl.unwrap();'), (385, '        let chunk = pl.decode(&mut buf).unwrap().unwrap();'), (386, '        assert_eq!(chunk, PayloadItem::Chunk(Bytes::from_static(b\"xx\")));'), (387, '    }'), (389, '    #[test]'), (390, '    fn hrs_chunk_extension_invalid() {'), (391, '        let mut buf = BytesMut::from('), (392, '            \"GET / HTTP/1.1\\\\r\\\\n\\\\'), (393, '            Host: localhost:8080\\\\r\\\\n\\\\'), (394, '            Transfer-Encoding: chunked\\\\r\\\\n\\\\'), (395, '            \\\\r\\\\n\\\\'), (396, '            2;x\\\\nx\\\\r\\\\n\\\\'), (397, '            4c\\\\r\\\\n\\\\'), (398, '            0\\\\r\\\\n\",'), (399, '        );'), (401, '        let mut reader = MessageDecoder::<Request>::default();'), (402, '        let (_msg, pl) = reader.decode(&mut buf).unwrap().unwrap();'), (403, '        let mut pl = pl.unwrap();'), (405, '        let err = pl.decode(&mut buf).unwrap_err();'), (406, '        assert!(err'), (407, '            .to_string()'), (408, '            .contains(\"Invalid character in chunk extension\"));'), (409, '    }'), (411, '    #[test]'), (412, '    fn hrs_chunk_size_overflow() {'), (413, '        let mut buf = BytesMut::from('), (414, '            \"GET / HTTP/1.1\\\\r\\\\n\\\\'), (415, '            Host: example.com\\\\r\\\\n\\\\'), (416, '            Transfer-Encoding: chunked\\\\r\\\\n\\\\'), (417, '            \\\\r\\\\n\\\\'), (418, '            f0000000000000003\\\\r\\\\n\\\\'), (419, '            abc\\\\r\\\\n\\\\'), (420, '            0\\\\r\\\\n\",'), (421, '        );'), (423, '        let mut reader = MessageDecoder::<Request>::default();'), (424, '        let (_msg, pl) = reader.decode(&mut buf).unwrap().unwrap();'), (425, '        let mut pl = pl.unwrap();'), (427, '        let err = pl.decode(&mut buf).unwrap_err();'), (428, '        assert!(err'), (429, '            .to_string()'), (430, '            .contains(\"Invalid chunk size line: Size is too big\"));'), (431, '    }'), (432, '}')], 'deleted': []}",
    "num_lines_added": "380",
    "num_lines_deleted": "0",
    "nloc": "380"
  },
  {
    "file_change_id": "170888625211590",
    "hash": "e965d8298f421e9c89fe98b1300b8361e948c324",
    "old_path": "actix-http/src/h1/decoder.rs",
    "new_path": "actix-http/src/h1/decoder.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,18 +1,18 @@\n-use std::convert::TryFrom;\n-use std::io;\n-use std::marker::PhantomData;\n-use std::task::Poll;\n+use std::{convert::TryFrom, io, marker::PhantomData, task::Poll};\n \n use actix_codec::Decoder;\n-use bytes::{Buf, Bytes, BytesMut};\n+use bytes::{Bytes, BytesMut};\n use http::header::{HeaderName, HeaderValue};\n use http::{header, Method, StatusCode, Uri, Version};\n use log::{debug, error, trace};\n \n-use crate::error::ParseError;\n-use crate::header::HeaderMap;\n-use crate::message::{ConnectionType, ResponseHead};\n-use crate::request::Request;\n+use super::chunked::ChunkedState;\n+use crate::{\n+    error::ParseError,\n+    header::HeaderMap,\n+    message::{ConnectionType, ResponseHead},\n+    request::Request,\n+};\n \n pub(crate) const MAX_BUFFER_SIZE: usize = 131_072;\n const MAX_HEADERS: usize = 96;\n@@ -67,6 +67,7 @@ pub(crate) trait MessageType: Sized {\n         let mut has_upgrade_websocket = false;\n         let mut expect = false;\n         let mut chunked = false;\n+        let mut seen_te = false;\n         let mut content_length = None;\n \n         {\n@@ -85,8 +86,17 @@ pub(crate) trait MessageType: Sized {\n                 };\n \n                 match name {\n-                    header::CONTENT_LENGTH => {\n-                        if let Ok(s) = value.to_str() {\n+                    header::CONTENT_LENGTH if content_length.is_some() => {\n+                        debug!(\"multiple Content-Length\");\n+                        return Err(ParseError::Header);\n+                    }\n+\n+                    header::CONTENT_LENGTH => match value.to_str() {\n+                        Ok(s) if s.trim().starts_with('+') => {\n+                            debug!(\"illegal Content-Length: {:?}\", s);\n+                            return Err(ParseError::Header);\n+                        }\n+                        Ok(s) => {\n                             if let Ok(len) = s.parse::<u64>() {\n                                 if len != 0 {\n                                     content_length = Some(len);\n@@ -95,15 +105,31 @@ pub(crate) trait MessageType: Sized {\n                                 debug!(\"illegal Content-Length: {:?}\", s);\n                                 return Err(ParseError::Header);\n                             }\n-                        } else {\n+                        }\n+                        Err(_) => {\n                             debug!(\"illegal Content-Length: {:?}\", value);\n                             return Err(ParseError::Header);\n                         }\n-                    }\n+                    },\n+\n                     // transfer-encoding\n+                    header::TRANSFER_ENCODING if seen_te => {\n+                        debug!(\"multiple Transfer-Encoding not allowed\");\n+                        return Err(ParseError::Header);\n+                    }\n+\n                     header::TRANSFER_ENCODING => {\n+                        seen_te = true;\n+\n                         if let Ok(s) = value.to_str().map(str::trim) {\n-                            chunked = s.eq_ignore_ascii_case(\"chunked\");\n+                            if s.eq_ignore_ascii_case(\"chunked\") {\n+                                chunked = true;\n+                            } else if s.eq_ignore_ascii_case(\"identity\") {\n+                                // allow silently since multiple TE headers are already checked\n+                            } else {\n+                                debug!(\"illegal Transfer-Encoding: {:?}\", s);\n+                                return Err(ParseError::Header);\n+                            }\n                         } else {\n                             return Err(ParseError::Header);\n                         }\n@@ -408,20 +434,6 @@ enum Kind {\n     Eof,\n }\n \n-#[derive(Debug, PartialEq, Clone)]\n-enum ChunkedState {\n-    Size,\n-    SizeLws,\n-    Extension,\n-    SizeLf,\n-    Body,\n-    BodyCr,\n-    BodyLf,\n-    EndCr,\n-    EndLf,\n-    End,\n-}\n-\n impl Decoder for PayloadDecoder {\n     type Item = PayloadItem;\n     type Error = io::Error;\n@@ -451,19 +463,23 @@ impl Decoder for PayloadDecoder {\n             Kind::Chunked(ref mut state, ref mut size) => {\n                 loop {\n                     let mut buf = None;\n+\n                     // advances the chunked state\n                     *state = match state.step(src, size, &mut buf) {\n                         Poll::Pending => return Ok(None),\n                         Poll::Ready(Ok(state)) => state,\n                         Poll::Ready(Err(e)) => return Err(e),\n                     };\n+\n                     if *state == ChunkedState::End {\n                         trace!(\"End of chunked stream\");\n                         return Ok(Some(PayloadItem::Eof));\n                     }\n+\n                     if let Some(buf) = buf {\n                         return Ok(Some(PayloadItem::Chunk(buf)));\n                     }\n+\n                     if src.is_empty() {\n                         return Ok(None);\n                     }\n@@ -480,201 +496,40 @@ impl Decoder for PayloadDecoder {\n     }\n }\n \n-macro_rules! byte (\n-    ($rdr:ident) => ({\n-        if $rdr.len() > 0 {\n-            let b = $rdr[0];\n-            $rdr.advance(1);\n-            b\n-        } else {\n-            return Poll::Pending\n-        }\n-    })\n-);\n-\n-impl ChunkedState {\n-    fn step(\n-        &self,\n-        body: &mut BytesMut,\n-        size: &mut u64,\n-        buf: &mut Option<Bytes>,\n-    ) -> Poll<Result<ChunkedState, io::Error>> {\n-        use self::ChunkedState::*;\n-        match *self {\n-            Size => ChunkedState::read_size(body, size),\n-            SizeLws => ChunkedState::read_size_lws(body),\n-            Extension => ChunkedState::read_extension(body),\n-            SizeLf => ChunkedState::read_size_lf(body, size),\n-            Body => ChunkedState::read_body(body, size, buf),\n-            BodyCr => ChunkedState::read_body_cr(body),\n-            BodyLf => ChunkedState::read_body_lf(body),\n-            EndCr => ChunkedState::read_end_cr(body),\n-            EndLf => ChunkedState::read_end_lf(body),\n-            End => Poll::Ready(Ok(ChunkedState::End)),\n-        }\n-    }\n-\n-    fn read_size(\n-        rdr: &mut BytesMut,\n-        size: &mut u64,\n-    ) -> Poll<Result<ChunkedState, io::Error>> {\n-        let radix = 16;\n-        match byte!(rdr) {\n-            b @ b'0'..=b'9' => {\n-                *size *= radix;\n-                *size += u64::from(b - b'0');\n-            }\n-            b @ b'a'..=b'f' => {\n-                *size *= radix;\n-                *size += u64::from(b + 10 - b'a');\n-            }\n-            b @ b'A'..=b'F' => {\n-                *size *= radix;\n-                *size += u64::from(b + 10 - b'A');\n-            }\n-            b'\\t' | b' ' => return Poll::Ready(Ok(ChunkedState::SizeLws)),\n-            b';' => return Poll::Ready(Ok(ChunkedState::Extension)),\n-            b'\\r' => return Poll::Ready(Ok(ChunkedState::SizeLf)),\n-            _ => {\n-                return Poll::Ready(Err(io::Error::new(\n-                    io::ErrorKind::InvalidInput,\n-                    \"Invalid chunk size line: Invalid Size\",\n-                )));\n-            }\n-        }\n-        Poll::Ready(Ok(ChunkedState::Size))\n-    }\n-\n-    fn read_size_lws(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {\n-        trace!(\"read_size_lws\");\n-        match byte!(rdr) {\n-            // LWS can follow the chunk size, but no more digits can come\n-            b'\\t' | b' ' => Poll::Ready(Ok(ChunkedState::SizeLws)),\n-            b';' => Poll::Ready(Ok(ChunkedState::Extension)),\n-            b'\\r' => Poll::Ready(Ok(ChunkedState::SizeLf)),\n-            _ => Poll::Ready(Err(io::Error::new(\n-                io::ErrorKind::InvalidInput,\n-                \"Invalid chunk size linear white space\",\n-            ))),\n-        }\n-    }\n-    fn read_extension(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {\n-        match byte!(rdr) {\n-            b'\\r' => Poll::Ready(Ok(ChunkedState::SizeLf)),\n-            _ => Poll::Ready(Ok(ChunkedState::Extension)), // no supported extensions\n-        }\n-    }\n-    fn read_size_lf(\n-        rdr: &mut BytesMut,\n-        size: &mut u64,\n-    ) -> Poll<Result<ChunkedState, io::Error>> {\n-        match byte!(rdr) {\n-            b'\\n' if *size > 0 => Poll::Ready(Ok(ChunkedState::Body)),\n-            b'\\n' if *size == 0 => Poll::Ready(Ok(ChunkedState::EndCr)),\n-            _ => Poll::Ready(Err(io::Error::new(\n-                io::ErrorKind::InvalidInput,\n-                \"Invalid chunk size LF\",\n-            ))),\n-        }\n-    }\n-\n-    fn read_body(\n-        rdr: &mut BytesMut,\n-        rem: &mut u64,\n-        buf: &mut Option<Bytes>,\n-    ) -> Poll<Result<ChunkedState, io::Error>> {\n-        trace!(\"Chunked read, remaining={:?}\", rem);\n-\n-        let len = rdr.len() as u64;\n-        if len == 0 {\n-            Poll::Ready(Ok(ChunkedState::Body))\n-        } else {\n-            let slice;\n-            if *rem > len {\n-                slice = rdr.split().freeze();\n-                *rem -= len;\n-            } else {\n-                slice = rdr.split_to(*rem as usize).freeze();\n-                *rem = 0;\n-            }\n-            *buf = Some(slice);\n-            if *rem > 0 {\n-                Poll::Ready(Ok(ChunkedState::Body))\n-            } else {\n-                Poll::Ready(Ok(ChunkedState::BodyCr))\n-            }\n-        }\n-    }\n-\n-    fn read_body_cr(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {\n-        match byte!(rdr) {\n-            b'\\r' => Poll::Ready(Ok(ChunkedState::BodyLf)),\n-            _ => Poll::Ready(Err(io::Error::new(\n-                io::ErrorKind::InvalidInput,\n-                \"Invalid chunk body CR\",\n-            ))),\n-        }\n-    }\n-    fn read_body_lf(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {\n-        match byte!(rdr) {\n-            b'\\n' => Poll::Ready(Ok(ChunkedState::Size)),\n-            _ => Poll::Ready(Err(io::Error::new(\n-                io::ErrorKind::InvalidInput,\n-                \"Invalid chunk body LF\",\n-            ))),\n-        }\n-    }\n-    fn read_end_cr(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {\n-        match byte!(rdr) {\n-            b'\\r' => Poll::Ready(Ok(ChunkedState::EndLf)),\n-            _ => Poll::Ready(Err(io::Error::new(\n-                io::ErrorKind::InvalidInput,\n-                \"Invalid chunk end CR\",\n-            ))),\n-        }\n-    }\n-    fn read_end_lf(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {\n-        match byte!(rdr) {\n-            b'\\n' => Poll::Ready(Ok(ChunkedState::End)),\n-            _ => Poll::Ready(Err(io::Error::new(\n-                io::ErrorKind::InvalidInput,\n-                \"Invalid chunk end LF\",\n-            ))),\n-        }\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use bytes::{Bytes, BytesMut};\n     use http::{Method, Version};\n \n     use super::*;\n-    use crate::error::ParseError;\n-    use crate::http::header::{HeaderName, SET_COOKIE};\n-    use crate::HttpMessage;\n+    use crate::{\n+        error::ParseError,\n+        http::header::{HeaderName, SET_COOKIE},\n+        HttpMessage as _,\n+    };\n \n     impl PayloadType {\n-        fn unwrap(self) -> PayloadDecoder {\n+        pub(crate) fn unwrap(self) -> PayloadDecoder {\n             match self {\n                 PayloadType::Payload(pl) => pl,\n                 _ => panic!(),\n             }\n         }\n \n-        fn is_unhandled(&self) -> bool {\n+        pub(crate) fn is_unhandled(&self) -> bool {\n             matches!(self, PayloadType::Stream(_))\n         }\n     }\n \n     impl PayloadItem {\n-        fn chunk(self) -> Bytes {\n+        pub(crate) fn chunk(self) -> Bytes {\n             match self {\n                 PayloadItem::Chunk(chunk) => chunk,\n                 _ => panic!(\"error\"),\n             }\n         }\n-        fn eof(&self) -> bool {\n+\n+        pub(crate) fn eof(&self) -> bool {\n             matches!(*self, PayloadItem::Eof)\n         }\n     }\n@@ -967,34 +822,6 @@ mod tests {\n         assert!(req.upgrade());\n     }\n \n-    #[test]\n-    fn test_request_chunked() {\n-        let mut buf = BytesMut::from(\n-            \"GET /test HTTP/1.1\\r\\n\\\n-             transfer-encoding: chunked\\r\\n\\r\\n\",\n-        );\n-        let req = parse_ready!(&mut buf);\n-\n-        if let Ok(val) = req.chunked() {\n-            assert!(val);\n-        } else {\n-            unreachable!(\"Error\");\n-        }\n-\n-        // intentional typo in \"chunked\"\n-        let mut buf = BytesMut::from(\n-            \"GET /test HTTP/1.1\\r\\n\\\n-             transfer-encoding: chnked\\r\\n\\r\\n\",\n-        );\n-        let req = parse_ready!(&mut buf);\n-\n-        if let Ok(val) = req.chunked() {\n-            assert!(!val);\n-        } else {\n-            unreachable!(\"Error\");\n-        }\n-    }\n-\n     #[test]\n     fn test_headers_content_length_err_1() {\n         let mut buf = BytesMut::from(\n@@ -1113,134 +940,94 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_http_request_chunked_payload() {\n-        let mut buf = BytesMut::from(\n-            \"GET /test HTTP/1.1\\r\\n\\\n-             transfer-encoding: chunked\\r\\n\\r\\n\",\n-        );\n-        let mut reader = MessageDecoder::<Request>::default();\n-        let (req, pl) = reader.decode(&mut buf).unwrap().unwrap();\n+    fn test_response_http10_read_until_eof() {\n+        let mut buf = BytesMut::from(\"HTTP/1.0 200 Ok\\r\\n\\r\\ntest data\");\n+\n+        let mut reader = MessageDecoder::<ResponseHead>::default();\n+        let (_msg, pl) = reader.decode(&mut buf).unwrap().unwrap();\n         let mut pl = pl.unwrap();\n-        assert!(req.chunked().unwrap());\n \n-        buf.extend(b\"4\\r\\ndata\\r\\n4\\r\\nline\\r\\n0\\r\\n\\r\\n\");\n-        assert_eq!(\n-            pl.decode(&mut buf).unwrap().unwrap().chunk().as_ref(),\n-            b\"data\"\n-        );\n-        assert_eq!(\n-            pl.decode(&mut buf).unwrap().unwrap().chunk().as_ref(),\n-            b\"line\"\n-        );\n-        assert!(pl.decode(&mut buf).unwrap().unwrap().eof());\n+        let chunk = pl.decode(&mut buf).unwrap().unwrap();\n+        assert_eq!(chunk, PayloadItem::Chunk(Bytes::from_static(b\"test data\")));\n     }\n \n     #[test]\n-    fn test_http_request_chunked_payload_and_next_message() {\n+    fn hrs_multiple_content_length() {\n         let mut buf = BytesMut::from(\n-            \"GET /test HTTP/1.1\\r\\n\\\n-             transfer-encoding: chunked\\r\\n\\r\\n\",\n+            \"GET / HTTP/1.1\\r\\n\\\n+            Host: example.com\\r\\n\\\n+            Content-Length: 4\\r\\n\\\n+            Content-Length: 2\\r\\n\\\n+            \\r\\n\\\n+            abcd\",\n         );\n-        let mut reader = MessageDecoder::<Request>::default();\n-        let (req, pl) = reader.decode(&mut buf).unwrap().unwrap();\n-        let mut pl = pl.unwrap();\n-        assert!(req.chunked().unwrap());\n \n-        buf.extend(\n-            b\"4\\r\\ndata\\r\\n4\\r\\nline\\r\\n0\\r\\n\\r\\n\\\n-              POST /test2 HTTP/1.1\\r\\n\\\n-              transfer-encoding: chunked\\r\\n\\r\\n\"\n-                .iter(),\n-        );\n-        let msg = pl.decode(&mut buf).unwrap().unwrap();\n-        assert_eq!(msg.chunk().as_ref(), b\"data\");\n-        let msg = pl.decode(&mut buf).unwrap().unwrap();\n-        assert_eq!(msg.chunk().as_ref(), b\"line\");\n-        let msg = pl.decode(&mut buf).unwrap().unwrap();\n-        assert!(msg.eof());\n-\n-        let (req, _) = reader.decode(&mut buf).unwrap().unwrap();\n-        assert!(req.chunked().unwrap());\n-        assert_eq!(*req.method(), Method::POST);\n-        assert!(req.chunked().unwrap());\n+        expect_parse_err!(&mut buf);\n     }\n \n     #[test]\n-    fn test_http_request_chunked_payload_chunks() {\n+    fn hrs_content_length_plus() {\n         let mut buf = BytesMut::from(\n-            \"GET /test HTTP/1.1\\r\\n\\\n-             transfer-encoding: chunked\\r\\n\\r\\n\",\n+            \"GET / HTTP/1.1\\r\\n\\\n+            Host: example.com\\r\\n\\\n+            Content-Length: +3\\r\\n\\\n+            \\r\\n\\\n+            000\",\n         );\n \n-        let mut reader = MessageDecoder::<Request>::default();\n-        let (req, pl) = reader.decode(&mut buf).unwrap().unwrap();\n-        let mut pl = pl.unwrap();\n-        assert!(req.chunked().unwrap());\n-\n-        buf.extend(b\"4\\r\\n1111\\r\\n\");\n-        let msg = pl.decode(&mut buf).unwrap().unwrap();\n-        assert_eq!(msg.chunk().as_ref(), b\"1111\");\n-\n-        buf.extend(b\"4\\r\\ndata\\r\");\n-        let msg = pl.decode(&mut buf).unwrap().unwrap();\n-        assert_eq!(msg.chunk().as_ref(), b\"data\");\n-\n-        buf.extend(b\"\\n4\");\n-        assert!(pl.decode(&mut buf).unwrap().is_none());\n-\n-        buf.extend(b\"\\r\");\n-        assert!(pl.decode(&mut buf).unwrap().is_none());\n-        buf.extend(b\"\\n\");\n-        assert!(pl.decode(&mut buf).unwrap().is_none());\n-\n-        buf.extend(b\"li\");\n-        let msg = pl.decode(&mut buf).unwrap().unwrap();\n-        assert_eq!(msg.chunk().as_ref(), b\"li\");\n-\n-        //trailers\n-        //buf.feed_data(\"test: test\\r\\n\");\n-        //not_ready!(reader.parse(&mut buf, &mut readbuf));\n+        expect_parse_err!(&mut buf);\n+    }\n \n-        buf.extend(b\"ne\\r\\n0\\r\\n\");\n-        let msg = pl.decode(&mut buf).unwrap().unwrap();\n-        assert_eq!(msg.chunk().as_ref(), b\"ne\");\n-        assert!(pl.decode(&mut buf).unwrap().is_none());\n+    #[test]\n+    fn hrs_unknown_transfer_encoding() {\n+        let mut buf = BytesMut::from(\n+            \"GET / HTTP/1.1\\r\\n\\\n+            Host: example.com\\r\\n\\\n+            Transfer-Encoding: JUNK\\r\\n\\\n+            Transfer-Encoding: chunked\\r\\n\\\n+            \\r\\n\\\n+            5\\r\\n\\\n+            hello\\r\\n\\\n+            0\",\n+        );\n \n-        buf.extend(b\"\\r\\n\");\n-        assert!(pl.decode(&mut buf).unwrap().unwrap().eof());\n+        expect_parse_err!(&mut buf);\n     }\n \n     #[test]\n-    fn test_parse_chunked_payload_chunk_extension() {\n+    fn hrs_multiple_transfer_encoding() {\n         let mut buf = BytesMut::from(\n-            \"GET /test HTTP/1.1\\r\\n\\\n-            transfer-encoding: chunked\\r\\n\\\n-            \\r\\n\",\n+            \"GET / HTTP/1.1\\r\\n\\\n+            Host: example.com\\r\\n\\\n+            Content-Length: 51\\r\\n\\\n+            Transfer-Encoding: identity\\r\\n\\\n+            Transfer-Encoding: chunked\\r\\n\\\n+            \\r\\n\\\n+            0\\r\\n\\\n+            \\r\\n\\\n+            GET /forbidden HTTP/1.1\\r\\n\\\n+            Host: example.com\\r\\n\\r\\n\",\n         );\n \n-        let mut reader = MessageDecoder::<Request>::default();\n-        let (msg, pl) = reader.decode(&mut buf).unwrap().unwrap();\n-        let mut pl = pl.unwrap();\n-        assert!(msg.chunked().unwrap());\n-\n-        buf.extend(b\"4;test\\r\\ndata\\r\\n4\\r\\nline\\r\\n0\\r\\n\\r\\n\"); // test: test\\r\\n\\r\\n\")\n-        let chunk = pl.decode(&mut buf).unwrap().unwrap().chunk();\n-        assert_eq!(chunk, Bytes::from_static(b\"data\"));\n-        let chunk = pl.decode(&mut buf).unwrap().unwrap().chunk();\n-        assert_eq!(chunk, Bytes::from_static(b\"line\"));\n-        let msg = pl.decode(&mut buf).unwrap().unwrap();\n-        assert!(msg.eof());\n+        expect_parse_err!(&mut buf);\n     }\n \n     #[test]\n-    fn test_response_http10_read_until_eof() {\n-        let mut buf = BytesMut::from(\"HTTP/1.0 200 Ok\\r\\n\\r\\ntest data\");\n+    fn transfer_encoding_agrees() {\n+        let mut buf = BytesMut::from(\n+            \"GET /test HTTP/1.1\\r\\n\\\n+            Host: example.com\\r\\n\\\n+            Content-Length: 3\\r\\n\\\n+            Transfer-Encoding: identity\\r\\n\\\n+            \\r\\n\\\n+            0\\r\\n\",\n+        );\n \n-        let mut reader = MessageDecoder::<ResponseHead>::default();\n+        let mut reader = MessageDecoder::<Request>::default();\n         let (_msg, pl) = reader.decode(&mut buf).unwrap().unwrap();\n         let mut pl = pl.unwrap();\n \n         let chunk = pl.decode(&mut buf).unwrap().unwrap();\n-        assert_eq!(chunk, PayloadItem::Chunk(Bytes::from_static(b\"test data\")));\n+        assert_eq!(chunk, PayloadItem::Chunk(Bytes::from_static(b\"0\\r\\n\")));\n     }\n }\n",
    "diff_parsed": "{'added': [(1, 'use std::{convert::TryFrom, io, marker::PhantomData, task::Poll};'), (4, 'use bytes::{Bytes, BytesMut};'), (9, 'use super::chunked::ChunkedState;'), (10, 'use crate::{'), (11, '    error::ParseError,'), (12, '    header::HeaderMap,'), (13, '    message::{ConnectionType, ResponseHead},'), (14, '    request::Request,'), (15, '};'), (70, '        let mut seen_te = false;'), (89, '                    header::CONTENT_LENGTH if content_length.is_some() => {'), (90, '                        debug!(\"multiple Content-Length\");'), (91, '                        return Err(ParseError::Header);'), (92, '                    }'), (94, '                    header::CONTENT_LENGTH => match value.to_str() {'), (95, \"                        Ok(s) if s.trim().starts_with('+') => {\"), (96, '                            debug!(\"illegal Content-Length: {:?}\", s);'), (97, '                            return Err(ParseError::Header);'), (98, '                        }'), (99, '                        Ok(s) => {'), (108, '                        }'), (109, '                        Err(_) => {'), (113, '                    },'), (116, '                    header::TRANSFER_ENCODING if seen_te => {'), (117, '                        debug!(\"multiple Transfer-Encoding not allowed\");'), (118, '                        return Err(ParseError::Header);'), (119, '                    }'), (122, '                        seen_te = true;'), (125, '                            if s.eq_ignore_ascii_case(\"chunked\") {'), (126, '                                chunked = true;'), (127, '                            } else if s.eq_ignore_ascii_case(\"identity\") {'), (129, '                            } else {'), (130, '                                debug!(\"illegal Transfer-Encoding: {:?}\", s);'), (131, '                                return Err(ParseError::Header);'), (132, '                            }'), (505, '    use crate::{'), (506, '        error::ParseError,'), (507, '        http::header::{HeaderName, SET_COOKIE},'), (508, '        HttpMessage as _,'), (509, '    };'), (512, '        pub(crate) fn unwrap(self) -> PayloadDecoder {'), (519, '        pub(crate) fn is_unhandled(&self) -> bool {'), (525, '        pub(crate) fn chunk(self) -> Bytes {'), (532, '        pub(crate) fn eof(&self) -> bool {'), (943, '    fn test_response_http10_read_until_eof() {'), (944, '        let mut buf = BytesMut::from(\"HTTP/1.0 200 Ok\\\\r\\\\n\\\\r\\\\ntest data\");'), (946, '        let mut reader = MessageDecoder::<ResponseHead>::default();'), (947, '        let (_msg, pl) = reader.decode(&mut buf).unwrap().unwrap();'), (950, '        let chunk = pl.decode(&mut buf).unwrap().unwrap();'), (951, '        assert_eq!(chunk, PayloadItem::Chunk(Bytes::from_static(b\"test data\")));'), (955, '    fn hrs_multiple_content_length() {'), (957, '            \"GET / HTTP/1.1\\\\r\\\\n\\\\'), (958, '            Host: example.com\\\\r\\\\n\\\\'), (959, '            Content-Length: 4\\\\r\\\\n\\\\'), (960, '            Content-Length: 2\\\\r\\\\n\\\\'), (961, '            \\\\r\\\\n\\\\'), (962, '            abcd\",'), (965, '        expect_parse_err!(&mut buf);'), (969, '    fn hrs_content_length_plus() {'), (971, '            \"GET / HTTP/1.1\\\\r\\\\n\\\\'), (972, '            Host: example.com\\\\r\\\\n\\\\'), (973, '            Content-Length: +3\\\\r\\\\n\\\\'), (974, '            \\\\r\\\\n\\\\'), (975, '            000\",'), (978, '        expect_parse_err!(&mut buf);'), (979, '    }'), (981, '    #[test]'), (982, '    fn hrs_unknown_transfer_encoding() {'), (983, '        let mut buf = BytesMut::from('), (984, '            \"GET / HTTP/1.1\\\\r\\\\n\\\\'), (985, '            Host: example.com\\\\r\\\\n\\\\'), (986, '            Transfer-Encoding: JUNK\\\\r\\\\n\\\\'), (987, '            Transfer-Encoding: chunked\\\\r\\\\n\\\\'), (988, '            \\\\r\\\\n\\\\'), (989, '            5\\\\r\\\\n\\\\'), (990, '            hello\\\\r\\\\n\\\\'), (991, '            0\",'), (992, '        );'), (994, '        expect_parse_err!(&mut buf);'), (998, '    fn hrs_multiple_transfer_encoding() {'), (1000, '            \"GET / HTTP/1.1\\\\r\\\\n\\\\'), (1001, '            Host: example.com\\\\r\\\\n\\\\'), (1002, '            Content-Length: 51\\\\r\\\\n\\\\'), (1003, '            Transfer-Encoding: identity\\\\r\\\\n\\\\'), (1004, '            Transfer-Encoding: chunked\\\\r\\\\n\\\\'), (1005, '            \\\\r\\\\n\\\\'), (1006, '            0\\\\r\\\\n\\\\'), (1007, '            \\\\r\\\\n\\\\'), (1008, '            GET /forbidden HTTP/1.1\\\\r\\\\n\\\\'), (1009, '            Host: example.com\\\\r\\\\n\\\\r\\\\n\",'), (1012, '        expect_parse_err!(&mut buf);'), (1016, '    fn transfer_encoding_agrees() {'), (1017, '        let mut buf = BytesMut::from('), (1018, '            \"GET /test HTTP/1.1\\\\r\\\\n\\\\'), (1019, '            Host: example.com\\\\r\\\\n\\\\'), (1020, '            Content-Length: 3\\\\r\\\\n\\\\'), (1021, '            Transfer-Encoding: identity\\\\r\\\\n\\\\'), (1022, '            \\\\r\\\\n\\\\'), (1023, '            0\\\\r\\\\n\",'), (1024, '        );'), (1026, '        let mut reader = MessageDecoder::<Request>::default();'), (1031, '        assert_eq!(chunk, PayloadItem::Chunk(Bytes::from_static(b\"0\\\\r\\\\n\")));')], 'deleted': [(1, 'use std::convert::TryFrom;'), (2, 'use std::io;'), (3, 'use std::marker::PhantomData;'), (4, 'use std::task::Poll;'), (7, 'use bytes::{Buf, Bytes, BytesMut};'), (12, 'use crate::error::ParseError;'), (13, 'use crate::header::HeaderMap;'), (14, 'use crate::message::{ConnectionType, ResponseHead};'), (15, 'use crate::request::Request;'), (88, '                    header::CONTENT_LENGTH => {'), (89, '                        if let Ok(s) = value.to_str() {'), (98, '                        } else {'), (102, '                    }'), (106, '                            chunked = s.eq_ignore_ascii_case(\"chunked\");'), (411, '#[derive(Debug, PartialEq, Clone)]'), (412, 'enum ChunkedState {'), (413, '    Size,'), (414, '    SizeLws,'), (415, '    Extension,'), (416, '    SizeLf,'), (417, '    Body,'), (418, '    BodyCr,'), (419, '    BodyLf,'), (420, '    EndCr,'), (421, '    EndLf,'), (422, '    End,'), (423, '}'), (483, 'macro_rules! byte ('), (484, '    ($rdr:ident) => ({'), (485, '        if $rdr.len() > 0 {'), (486, '            let b = $rdr[0];'), (487, '            $rdr.advance(1);'), (488, '            b'), (489, '        } else {'), (490, '            return Poll::Pending'), (491, '        }'), (492, '    })'), (493, ');'), (495, 'impl ChunkedState {'), (496, '    fn step('), (497, '        &self,'), (498, '        body: &mut BytesMut,'), (499, '        size: &mut u64,'), (500, '        buf: &mut Option<Bytes>,'), (501, '    ) -> Poll<Result<ChunkedState, io::Error>> {'), (502, '        use self::ChunkedState::*;'), (503, '        match *self {'), (504, '            Size => ChunkedState::read_size(body, size),'), (505, '            SizeLws => ChunkedState::read_size_lws(body),'), (506, '            Extension => ChunkedState::read_extension(body),'), (507, '            SizeLf => ChunkedState::read_size_lf(body, size),'), (508, '            Body => ChunkedState::read_body(body, size, buf),'), (509, '            BodyCr => ChunkedState::read_body_cr(body),'), (510, '            BodyLf => ChunkedState::read_body_lf(body),'), (511, '            EndCr => ChunkedState::read_end_cr(body),'), (512, '            EndLf => ChunkedState::read_end_lf(body),'), (513, '            End => Poll::Ready(Ok(ChunkedState::End)),'), (514, '        }'), (515, '    }'), (517, '    fn read_size('), (518, '        rdr: &mut BytesMut,'), (519, '        size: &mut u64,'), (520, '    ) -> Poll<Result<ChunkedState, io::Error>> {'), (521, '        let radix = 16;'), (522, '        match byte!(rdr) {'), (523, \"            b @ b'0'..=b'9' => {\"), (524, '                *size *= radix;'), (525, \"                *size += u64::from(b - b'0');\"), (526, '            }'), (527, \"            b @ b'a'..=b'f' => {\"), (528, '                *size *= radix;'), (529, \"                *size += u64::from(b + 10 - b'a');\"), (530, '            }'), (531, \"            b @ b'A'..=b'F' => {\"), (532, '                *size *= radix;'), (533, \"                *size += u64::from(b + 10 - b'A');\"), (534, '            }'), (535, \"            b'\\\\t' | b' ' => return Poll::Ready(Ok(ChunkedState::SizeLws)),\"), (536, \"            b';' => return Poll::Ready(Ok(ChunkedState::Extension)),\"), (537, \"            b'\\\\r' => return Poll::Ready(Ok(ChunkedState::SizeLf)),\"), (538, '            _ => {'), (539, '                return Poll::Ready(Err(io::Error::new('), (540, '                    io::ErrorKind::InvalidInput,'), (541, '                    \"Invalid chunk size line: Invalid Size\",'), (542, '                )));'), (543, '            }'), (544, '        }'), (545, '        Poll::Ready(Ok(ChunkedState::Size))'), (546, '    }'), (548, '    fn read_size_lws(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {'), (549, '        trace!(\"read_size_lws\");'), (550, '        match byte!(rdr) {'), (552, \"            b'\\\\t' | b' ' => Poll::Ready(Ok(ChunkedState::SizeLws)),\"), (553, \"            b';' => Poll::Ready(Ok(ChunkedState::Extension)),\"), (554, \"            b'\\\\r' => Poll::Ready(Ok(ChunkedState::SizeLf)),\"), (555, '            _ => Poll::Ready(Err(io::Error::new('), (556, '                io::ErrorKind::InvalidInput,'), (557, '                \"Invalid chunk size linear white space\",'), (558, '            ))),'), (559, '        }'), (560, '    }'), (561, '    fn read_extension(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {'), (562, '        match byte!(rdr) {'), (563, \"            b'\\\\r' => Poll::Ready(Ok(ChunkedState::SizeLf)),\"), (564, '            _ => Poll::Ready(Ok(ChunkedState::Extension)), // no supported extensions'), (565, '        }'), (566, '    }'), (567, '    fn read_size_lf('), (568, '        rdr: &mut BytesMut,'), (569, '        size: &mut u64,'), (570, '    ) -> Poll<Result<ChunkedState, io::Error>> {'), (571, '        match byte!(rdr) {'), (572, \"            b'\\\\n' if *size > 0 => Poll::Ready(Ok(ChunkedState::Body)),\"), (573, \"            b'\\\\n' if *size == 0 => Poll::Ready(Ok(ChunkedState::EndCr)),\"), (574, '            _ => Poll::Ready(Err(io::Error::new('), (575, '                io::ErrorKind::InvalidInput,'), (576, '                \"Invalid chunk size LF\",'), (577, '            ))),'), (578, '        }'), (579, '    }'), (581, '    fn read_body('), (582, '        rdr: &mut BytesMut,'), (583, '        rem: &mut u64,'), (584, '        buf: &mut Option<Bytes>,'), (585, '    ) -> Poll<Result<ChunkedState, io::Error>> {'), (586, '        trace!(\"Chunked read, remaining={:?}\", rem);'), (588, '        let len = rdr.len() as u64;'), (589, '        if len == 0 {'), (590, '            Poll::Ready(Ok(ChunkedState::Body))'), (591, '        } else {'), (592, '            let slice;'), (593, '            if *rem > len {'), (594, '                slice = rdr.split().freeze();'), (595, '                *rem -= len;'), (596, '            } else {'), (597, '                slice = rdr.split_to(*rem as usize).freeze();'), (598, '                *rem = 0;'), (599, '            }'), (600, '            *buf = Some(slice);'), (601, '            if *rem > 0 {'), (602, '                Poll::Ready(Ok(ChunkedState::Body))'), (603, '            } else {'), (604, '                Poll::Ready(Ok(ChunkedState::BodyCr))'), (605, '            }'), (606, '        }'), (607, '    }'), (609, '    fn read_body_cr(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {'), (610, '        match byte!(rdr) {'), (611, \"            b'\\\\r' => Poll::Ready(Ok(ChunkedState::BodyLf)),\"), (612, '            _ => Poll::Ready(Err(io::Error::new('), (613, '                io::ErrorKind::InvalidInput,'), (614, '                \"Invalid chunk body CR\",'), (615, '            ))),'), (616, '        }'), (617, '    }'), (618, '    fn read_body_lf(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {'), (619, '        match byte!(rdr) {'), (620, \"            b'\\\\n' => Poll::Ready(Ok(ChunkedState::Size)),\"), (621, '            _ => Poll::Ready(Err(io::Error::new('), (622, '                io::ErrorKind::InvalidInput,'), (623, '                \"Invalid chunk body LF\",'), (624, '            ))),'), (625, '        }'), (626, '    }'), (627, '    fn read_end_cr(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {'), (628, '        match byte!(rdr) {'), (629, \"            b'\\\\r' => Poll::Ready(Ok(ChunkedState::EndLf)),\"), (630, '            _ => Poll::Ready(Err(io::Error::new('), (631, '                io::ErrorKind::InvalidInput,'), (632, '                \"Invalid chunk end CR\",'), (633, '            ))),'), (634, '        }'), (635, '    }'), (636, '    fn read_end_lf(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {'), (637, '        match byte!(rdr) {'), (638, \"            b'\\\\n' => Poll::Ready(Ok(ChunkedState::End)),\"), (639, '            _ => Poll::Ready(Err(io::Error::new('), (640, '                io::ErrorKind::InvalidInput,'), (641, '                \"Invalid chunk end LF\",'), (642, '            ))),'), (643, '        }'), (644, '    }'), (645, '}'), (653, '    use crate::error::ParseError;'), (654, '    use crate::http::header::{HeaderName, SET_COOKIE};'), (655, '    use crate::HttpMessage;'), (658, '        fn unwrap(self) -> PayloadDecoder {'), (665, '        fn is_unhandled(&self) -> bool {'), (671, '        fn chunk(self) -> Bytes {'), (677, '        fn eof(&self) -> bool {'), (970, '    #[test]'), (971, '    fn test_request_chunked() {'), (972, '        let mut buf = BytesMut::from('), (973, '            \"GET /test HTTP/1.1\\\\r\\\\n\\\\'), (974, '             transfer-encoding: chunked\\\\r\\\\n\\\\r\\\\n\",'), (975, '        );'), (976, '        let req = parse_ready!(&mut buf);'), (978, '        if let Ok(val) = req.chunked() {'), (979, '            assert!(val);'), (980, '        } else {'), (981, '            unreachable!(\"Error\");'), (982, '        }'), (985, '        let mut buf = BytesMut::from('), (986, '            \"GET /test HTTP/1.1\\\\r\\\\n\\\\'), (987, '             transfer-encoding: chnked\\\\r\\\\n\\\\r\\\\n\",'), (988, '        );'), (989, '        let req = parse_ready!(&mut buf);'), (991, '        if let Ok(val) = req.chunked() {'), (992, '            assert!(!val);'), (993, '        } else {'), (994, '            unreachable!(\"Error\");'), (995, '        }'), (996, '    }'), (1116, '    fn test_http_request_chunked_payload() {'), (1117, '        let mut buf = BytesMut::from('), (1118, '            \"GET /test HTTP/1.1\\\\r\\\\n\\\\'), (1119, '             transfer-encoding: chunked\\\\r\\\\n\\\\r\\\\n\",'), (1120, '        );'), (1121, '        let mut reader = MessageDecoder::<Request>::default();'), (1122, '        let (req, pl) = reader.decode(&mut buf).unwrap().unwrap();'), (1124, '        assert!(req.chunked().unwrap());'), (1126, '        buf.extend(b\"4\\\\r\\\\ndata\\\\r\\\\n4\\\\r\\\\nline\\\\r\\\\n0\\\\r\\\\n\\\\r\\\\n\");'), (1127, '        assert_eq!('), (1128, '            pl.decode(&mut buf).unwrap().unwrap().chunk().as_ref(),'), (1129, '            b\"data\"'), (1130, '        );'), (1131, '        assert_eq!('), (1132, '            pl.decode(&mut buf).unwrap().unwrap().chunk().as_ref(),'), (1133, '            b\"line\"'), (1134, '        );'), (1135, '        assert!(pl.decode(&mut buf).unwrap().unwrap().eof());'), (1139, '    fn test_http_request_chunked_payload_and_next_message() {'), (1141, '            \"GET /test HTTP/1.1\\\\r\\\\n\\\\'), (1142, '             transfer-encoding: chunked\\\\r\\\\n\\\\r\\\\n\",'), (1144, '        let mut reader = MessageDecoder::<Request>::default();'), (1145, '        let (req, pl) = reader.decode(&mut buf).unwrap().unwrap();'), (1146, '        let mut pl = pl.unwrap();'), (1147, '        assert!(req.chunked().unwrap());'), (1149, '        buf.extend('), (1150, '            b\"4\\\\r\\\\ndata\\\\r\\\\n4\\\\r\\\\nline\\\\r\\\\n0\\\\r\\\\n\\\\r\\\\n\\\\'), (1151, '              POST /test2 HTTP/1.1\\\\r\\\\n\\\\'), (1152, '              transfer-encoding: chunked\\\\r\\\\n\\\\r\\\\n\"'), (1153, '                .iter(),'), (1154, '        );'), (1155, '        let msg = pl.decode(&mut buf).unwrap().unwrap();'), (1156, '        assert_eq!(msg.chunk().as_ref(), b\"data\");'), (1157, '        let msg = pl.decode(&mut buf).unwrap().unwrap();'), (1158, '        assert_eq!(msg.chunk().as_ref(), b\"line\");'), (1159, '        let msg = pl.decode(&mut buf).unwrap().unwrap();'), (1160, '        assert!(msg.eof());'), (1162, '        let (req, _) = reader.decode(&mut buf).unwrap().unwrap();'), (1163, '        assert!(req.chunked().unwrap());'), (1164, '        assert_eq!(*req.method(), Method::POST);'), (1165, '        assert!(req.chunked().unwrap());'), (1169, '    fn test_http_request_chunked_payload_chunks() {'), (1171, '            \"GET /test HTTP/1.1\\\\r\\\\n\\\\'), (1172, '             transfer-encoding: chunked\\\\r\\\\n\\\\r\\\\n\",'), (1175, '        let mut reader = MessageDecoder::<Request>::default();'), (1176, '        let (req, pl) = reader.decode(&mut buf).unwrap().unwrap();'), (1177, '        let mut pl = pl.unwrap();'), (1178, '        assert!(req.chunked().unwrap());'), (1180, '        buf.extend(b\"4\\\\r\\\\n1111\\\\r\\\\n\");'), (1181, '        let msg = pl.decode(&mut buf).unwrap().unwrap();'), (1182, '        assert_eq!(msg.chunk().as_ref(), b\"1111\");'), (1184, '        buf.extend(b\"4\\\\r\\\\ndata\\\\r\");'), (1185, '        let msg = pl.decode(&mut buf).unwrap().unwrap();'), (1186, '        assert_eq!(msg.chunk().as_ref(), b\"data\");'), (1188, '        buf.extend(b\"\\\\n4\");'), (1189, '        assert!(pl.decode(&mut buf).unwrap().is_none());'), (1191, '        buf.extend(b\"\\\\r\");'), (1192, '        assert!(pl.decode(&mut buf).unwrap().is_none());'), (1193, '        buf.extend(b\"\\\\n\");'), (1194, '        assert!(pl.decode(&mut buf).unwrap().is_none());'), (1196, '        buf.extend(b\"li\");'), (1197, '        let msg = pl.decode(&mut buf).unwrap().unwrap();'), (1198, '        assert_eq!(msg.chunk().as_ref(), b\"li\");'), (1204, '        buf.extend(b\"ne\\\\r\\\\n0\\\\r\\\\n\");'), (1205, '        let msg = pl.decode(&mut buf).unwrap().unwrap();'), (1206, '        assert_eq!(msg.chunk().as_ref(), b\"ne\");'), (1207, '        assert!(pl.decode(&mut buf).unwrap().is_none());'), (1209, '        buf.extend(b\"\\\\r\\\\n\");'), (1210, '        assert!(pl.decode(&mut buf).unwrap().unwrap().eof());'), (1214, '    fn test_parse_chunked_payload_chunk_extension() {'), (1216, '            \"GET /test HTTP/1.1\\\\r\\\\n\\\\'), (1217, '            transfer-encoding: chunked\\\\r\\\\n\\\\'), (1218, '            \\\\r\\\\n\",'), (1221, '        let mut reader = MessageDecoder::<Request>::default();'), (1222, '        let (msg, pl) = reader.decode(&mut buf).unwrap().unwrap();'), (1223, '        let mut pl = pl.unwrap();'), (1224, '        assert!(msg.chunked().unwrap());'), (1226, '        buf.extend(b\"4;test\\\\r\\\\ndata\\\\r\\\\n4\\\\r\\\\nline\\\\r\\\\n0\\\\r\\\\n\\\\r\\\\n\"); // test: test\\\\r\\\\n\\\\r\\\\n\")'), (1227, '        let chunk = pl.decode(&mut buf).unwrap().unwrap().chunk();'), (1228, '        assert_eq!(chunk, Bytes::from_static(b\"data\"));'), (1229, '        let chunk = pl.decode(&mut buf).unwrap().unwrap().chunk();'), (1230, '        assert_eq!(chunk, Bytes::from_static(b\"line\"));'), (1231, '        let msg = pl.decode(&mut buf).unwrap().unwrap();'), (1232, '        assert!(msg.eof());'), (1236, '    fn test_response_http10_read_until_eof() {'), (1237, '        let mut buf = BytesMut::from(\"HTTP/1.0 200 Ok\\\\r\\\\n\\\\r\\\\ntest data\");'), (1239, '        let mut reader = MessageDecoder::<ResponseHead>::default();'), (1244, '        assert_eq!(chunk, PayloadItem::Chunk(Bytes::from_static(b\"test data\")));')]}",
    "num_lines_added": "102",
    "num_lines_deleted": "301",
    "nloc": "852"
  },
  {
    "file_change_id": "121957706497290",
    "hash": "e965d8298f421e9c89fe98b1300b8361e948c324",
    "old_path": "actix-http/src/h1/encoder.rs",
    "new_path": "actix-http/src/h1/encoder.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -81,6 +81,7 @@ pub(crate) trait MessageType: Sized {\n         match length {\n             BodySize::Stream => {\n                 if chunked {\n+                    skip_len = true;\n                     if camel_case {\n                         dst.put_slice(b\"\\r\\nTransfer-Encoding: chunked\\r\\n\")\n                     } else {\n",
    "diff_parsed": "{'added': [(84, '                    skip_len = true;')], 'deleted': []}",
    "num_lines_added": "1",
    "num_lines_deleted": "0",
    "nloc": "517"
  },
  {
    "file_change_id": "158464381806755",
    "hash": "e965d8298f421e9c89fe98b1300b8361e948c324",
    "old_path": "actix-http/src/h1/mod.rs",
    "new_path": "actix-http/src/h1/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,6 +1,8 @@\n //! HTTP/1 protocol implementation.\n+\n use bytes::{Bytes, BytesMut};\n \n+mod chunked;\n mod client;\n mod codec;\n mod decoder;\n",
    "diff_parsed": "{'added': [(5, 'mod chunked;')], 'deleted': []}",
    "num_lines_added": "1",
    "num_lines_deleted": "0",
    "nloc": "70"
  },
  {
    "file_change_id": "207914854328258",
    "hash": "0b962f218f0cdd796dadfe26c3f09e68f7861b26",
    "old_path": "frame/ethereum/src/lib.rs",
    "new_path": "frame/ethereum/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -190,6 +190,27 @@ pub mod pallet {\n \n \t\tfn validate_unsigned(_source: TransactionSource, call: &Self::Call) -> TransactionValidity {\n \t\t\tif let Call::transact(transaction) = call {\n+\t\t\t\t// We must ensure a transaction can pay the cost of its data bytes.\n+\t\t\t\t// If it can't it should not be included in a block.\n+\t\t\t\tlet mut gasometer = evm::gasometer::Gasometer::new(\n+\t\t\t\t\ttransaction.gas_limit.low_u64(),\n+\t\t\t\t\t<T as pallet_evm::Config>::config(),\n+\t\t\t\t);\n+\t\t\t\tlet transaction_cost = match transaction.action {\n+\t\t\t\t\tTransactionAction::Call(_) => {\n+\t\t\t\t\t\tevm::gasometer::call_transaction_cost(&transaction.input)\n+\t\t\t\t\t}\n+\t\t\t\t\tTransactionAction::Create => {\n+\t\t\t\t\t\tevm::gasometer::create_transaction_cost(&transaction.input)\n+\t\t\t\t\t}\n+\t\t\t\t};\n+\t\t\t\tif gasometer.record_transaction(transaction_cost).is_err() {\n+\t\t\t\t\treturn InvalidTransaction::Custom(\n+\t\t\t\t\t\tTransactionValidationError::InvalidGasLimit as u8,\n+\t\t\t\t\t)\n+\t\t\t\t\t.into();\n+\t\t\t\t}\n+\n \t\t\t\tif let Some(chain_id) = transaction.signature.chain_id() {\n \t\t\t\t\tif chain_id != T::ChainId::get() {\n \t\t\t\t\t\treturn InvalidTransaction::Custom(\n",
    "diff_parsed": "{'added': [(195, '\\t\\t\\t\\tlet mut gasometer = evm::gasometer::Gasometer::new('), (196, '\\t\\t\\t\\t\\ttransaction.gas_limit.low_u64(),'), (197, '\\t\\t\\t\\t\\t<T as pallet_evm::Config>::config(),'), (198, '\\t\\t\\t\\t);'), (199, '\\t\\t\\t\\tlet transaction_cost = match transaction.action {'), (200, '\\t\\t\\t\\t\\tTransactionAction::Call(_) => {'), (201, '\\t\\t\\t\\t\\t\\tevm::gasometer::call_transaction_cost(&transaction.input)'), (202, '\\t\\t\\t\\t\\t}'), (203, '\\t\\t\\t\\t\\tTransactionAction::Create => {'), (204, '\\t\\t\\t\\t\\t\\tevm::gasometer::create_transaction_cost(&transaction.input)'), (205, '\\t\\t\\t\\t\\t}'), (206, '\\t\\t\\t\\t};'), (207, '\\t\\t\\t\\tif gasometer.record_transaction(transaction_cost).is_err() {'), (208, '\\t\\t\\t\\t\\treturn InvalidTransaction::Custom('), (209, '\\t\\t\\t\\t\\t\\tTransactionValidationError::InvalidGasLimit as u8,'), (210, '\\t\\t\\t\\t\\t)'), (211, '\\t\\t\\t\\t\\t.into();'), (212, '\\t\\t\\t\\t}')], 'deleted': []}",
    "num_lines_added": "18",
    "num_lines_deleted": "0",
    "nloc": "436"
  },
  {
    "file_change_id": "66210309191846",
    "hash": "666c2554ea0e1728c35aa41178cf235920db888a",
    "old_path": "cranelift/codegen/src/machinst/vcode.rs",
    "new_path": "cranelift/codegen/src/machinst/vcode.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -17,6 +17,7 @@\n //! See the main module comment in `mod.rs` for more details on the VCode-based\n //! backend pipeline.\n \n+use crate::fx::FxHashMap;\n use crate::ir::{self, types, Constant, ConstantData, SourceLoc};\n use crate::machinst::*;\n use crate::settings;\n@@ -478,6 +479,19 @@ impl<I: VCodeInst> VCode<I> {\n         let mut inst_end_offsets = vec![0; self.insts.len()];\n         let mut label_inst_indices = vec![0; self.num_blocks()];\n \n+        // Map from instruction index to index in\n+        // `safepoint_slots`. We need this because we emit\n+        // instructions out-of-order, while the safepoint_insns /\n+        // safepoint_slots data structures are sorted in instruction\n+        // order.\n+        let mut safepoint_indices: FxHashMap<u32, usize> = FxHashMap::default();\n+        for (safepoint_idx, iix) in self.safepoint_insns.iter().enumerate() {\n+            // Disregard safepoints that ended up having no live refs.\n+            if self.safepoint_slots[safepoint_idx].len() > 0 {\n+                safepoint_indices.insert(*iix, safepoint_idx);\n+            }\n+        }\n+\n         // Construct the final order we emit code in: cold blocks at the end.\n         let mut final_order: SmallVec<[BlockIndex; 16]> = smallvec![];\n         let mut cold_blocks: SmallVec<[BlockIndex; 16]> = smallvec![];\n@@ -493,7 +507,6 @@ impl<I: VCodeInst> VCode<I> {\n         final_order.extend(cold_blocks.clone());\n \n         // Emit blocks.\n-        let mut safepoint_idx = 0;\n         let mut cur_srcloc = None;\n         let mut last_offset = None;\n         let mut start_of_cold_code = None;\n@@ -541,17 +554,11 @@ impl<I: VCodeInst> VCode<I> {\n                 }\n                 state.pre_sourceloc(cur_srcloc.unwrap_or(SourceLoc::default()));\n \n-                if safepoint_idx < self.safepoint_insns.len()\n-                    && self.safepoint_insns[safepoint_idx] == iix\n-                {\n-                    if self.safepoint_slots[safepoint_idx].len() > 0 {\n-                        let stack_map = self.abi.spillslots_to_stack_map(\n-                            &self.safepoint_slots[safepoint_idx][..],\n-                            &state,\n-                        );\n-                        state.pre_safepoint(stack_map);\n-                    }\n-                    safepoint_idx += 1;\n+                if let Some(safepoint_idx) = safepoint_indices.get(&iix) {\n+                    let stack_map = self\n+                        .abi\n+                        .spillslots_to_stack_map(&self.safepoint_slots[*safepoint_idx][..], &state);\n+                    state.pre_safepoint(stack_map);\n                 }\n \n                 self.insts[iix as usize].emit(&mut buffer, &self.emit_info, &mut state);\n",
    "diff_parsed": "{'added': [(20, 'use crate::fx::FxHashMap;'), (487, '        let mut safepoint_indices: FxHashMap<u32, usize> = FxHashMap::default();'), (488, '        for (safepoint_idx, iix) in self.safepoint_insns.iter().enumerate() {'), (490, '            if self.safepoint_slots[safepoint_idx].len() > 0 {'), (491, '                safepoint_indices.insert(*iix, safepoint_idx);'), (492, '            }'), (493, '        }'), (557, '                if let Some(safepoint_idx) = safepoint_indices.get(&iix) {'), (558, '                    let stack_map = self'), (559, '                        .abi'), (560, '                        .spillslots_to_stack_map(&self.safepoint_slots[*safepoint_idx][..], &state);'), (561, '                    state.pre_safepoint(stack_map);')], 'deleted': [(496, '        let mut safepoint_idx = 0;'), (544, '                if safepoint_idx < self.safepoint_insns.len()'), (545, '                    && self.safepoint_insns[safepoint_idx] == iix'), (546, '                {'), (547, '                    if self.safepoint_slots[safepoint_idx].len() > 0 {'), (548, '                        let stack_map = self.abi.spillslots_to_stack_map('), (549, '                            &self.safepoint_slots[safepoint_idx][..],'), (550, '                            &state,'), (551, '                        );'), (552, '                        state.pre_safepoint(stack_map);'), (553, '                    }'), (554, '                    safepoint_idx += 1;')]}",
    "num_lines_added": "12",
    "num_lines_deleted": "12",
    "nloc": "673"
  },
  {
    "file_change_id": "54147604272194",
    "hash": "666c2554ea0e1728c35aa41178cf235920db888a",
    "old_path": "tests/all/funcref.rs",
    "new_path": "tests/all/funcref.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -6,6 +6,7 @@ use wasmtime::*;\n #[test]\n fn pass_funcref_in_and_out_of_wasm() -> anyhow::Result<()> {\n     let (mut store, module) = ref_types_module(\n+        false,\n         r#\"\n             (module\n                 (func (export \"func\") (param funcref) (result funcref)\n@@ -60,7 +61,8 @@ fn pass_funcref_in_and_out_of_wasm() -> anyhow::Result<()> {\n \n     // Passing in a `funcref` from another store fails.\n     {\n-        let (mut other_store, other_module) = ref_types_module(r#\"(module (func (export \"f\")))\"#)?;\n+        let (mut other_store, other_module) =\n+            ref_types_module(false, r#\"(module (func (export \"f\")))\"#)?;\n         let other_store_instance = Instance::new(&mut other_store, &other_module, &[])?;\n         let f = other_store_instance\n             .get_func(&mut other_store, \"f\")\n@@ -77,6 +79,7 @@ fn pass_funcref_in_and_out_of_wasm() -> anyhow::Result<()> {\n #[test]\n fn receive_null_funcref_from_wasm() -> anyhow::Result<()> {\n     let (mut store, module) = ref_types_module(\n+        false,\n         r#\"\n             (module\n                 (func (export \"get-null\") (result funcref)\n",
    "diff_parsed": "{'added': [(9, '        false,'), (64, '        let (mut other_store, other_module) ='), (65, '            ref_types_module(false, r#\"(module (func (export \"f\")))\"#)?;'), (82, '        false,')], 'deleted': [(63, '        let (mut other_store, other_module) = ref_types_module(r#\"(module (func (export \"f\")))\"#)?;')]}",
    "num_lines_added": "4",
    "num_lines_deleted": "1",
    "nloc": "127"
  },
  {
    "file_change_id": "233144283464869",
    "hash": "666c2554ea0e1728c35aa41178cf235920db888a",
    "old_path": "tests/all/gc.rs",
    "new_path": "tests/all/gc.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -14,7 +14,17 @@ impl Drop for SetFlagOnDrop {\n \n #[test]\n fn smoke_test_gc() -> anyhow::Result<()> {\n+    smoke_test_gc_impl(false)\n+}\n+\n+#[test]\n+fn smoke_test_gc_epochs() -> anyhow::Result<()> {\n+    smoke_test_gc_impl(true)\n+}\n+\n+fn smoke_test_gc_impl(use_epochs: bool) -> anyhow::Result<()> {\n     let (mut store, module) = ref_types_module(\n+        use_epochs,\n         r#\"\n             (module\n                 (import \"\" \"\" (func $do_gc))\n@@ -69,6 +79,7 @@ fn smoke_test_gc() -> anyhow::Result<()> {\n #[test]\n fn wasm_dropping_refs() -> anyhow::Result<()> {\n     let (mut store, module) = ref_types_module(\n+        false,\n         r#\"\n             (module\n                 (func (export \"drop_ref\") (param externref)\n@@ -145,7 +156,7 @@ fn many_live_refs() -> anyhow::Result<()> {\n         \",\n     );\n \n-    let (mut store, module) = ref_types_module(&wat)?;\n+    let (mut store, module) = ref_types_module(false, &wat)?;\n \n     let live_refs = Arc::new(AtomicUsize::new(0));\n \n@@ -191,6 +202,7 @@ fn many_live_refs() -> anyhow::Result<()> {\n #[test]\n fn drop_externref_via_table_set() -> anyhow::Result<()> {\n     let (mut store, module) = ref_types_module(\n+        false,\n         r#\"\n             (module\n                 (table $t 1 externref)\n@@ -400,6 +412,7 @@ fn gee_i_sure_hope_refcounting_is_atomic() -> anyhow::Result<()> {\n #[test]\n fn global_init_no_leak() -> anyhow::Result<()> {\n     let (mut store, module) = ref_types_module(\n+        false,\n         r#\"\n             (module\n                 (import \"\" \"\" (global externref))\n@@ -424,6 +437,7 @@ fn global_init_no_leak() -> anyhow::Result<()> {\n #[test]\n fn no_gc_middle_of_args() -> anyhow::Result<()> {\n     let (mut store, module) = ref_types_module(\n+        false,\n         r#\"\n             (module\n                 (import \"\" \"return_some\" (func $return (result externref externref externref)))\n",
    "diff_parsed": "{'added': [(17, '    smoke_test_gc_impl(false)'), (18, '}'), (20, '#[test]'), (21, 'fn smoke_test_gc_epochs() -> anyhow::Result<()> {'), (22, '    smoke_test_gc_impl(true)'), (23, '}'), (25, 'fn smoke_test_gc_impl(use_epochs: bool) -> anyhow::Result<()> {'), (27, '        use_epochs,'), (82, '        false,'), (159, '    let (mut store, module) = ref_types_module(false, &wat)?;'), (205, '        false,'), (415, '        false,'), (440, '        false,')], 'deleted': [(148, '    let (mut store, module) = ref_types_module(&wat)?;')]}",
    "num_lines_added": "13",
    "num_lines_deleted": "1",
    "nloc": "413"
  },
  {
    "file_change_id": "6299424895804",
    "hash": "666c2554ea0e1728c35aa41178cf235920db888a",
    "old_path": "tests/all/main.rs",
    "new_path": "tests/all/main.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -33,6 +33,7 @@ mod wast;\n \n /// A helper to compile a module in a new store with reference types enabled.\n pub(crate) fn ref_types_module(\n+    use_epochs: bool,\n     source: &str,\n ) -> anyhow::Result<(wasmtime::Store<()>, wasmtime::Module)> {\n     use wasmtime::*;\n@@ -41,9 +42,15 @@ pub(crate) fn ref_types_module(\n \n     let mut config = Config::new();\n     config.wasm_reference_types(true);\n+    if use_epochs {\n+        config.epoch_interruption(true);\n+    }\n \n     let engine = Engine::new(&config)?;\n-    let store = Store::new(&engine, ());\n+    let mut store = Store::new(&engine, ());\n+    if use_epochs {\n+        store.set_epoch_deadline(1);\n+    }\n \n     let module = Module::new(&engine, source)?;\n \n",
    "diff_parsed": "{'added': [(36, '    use_epochs: bool,'), (45, '    if use_epochs {'), (46, '        config.epoch_interruption(true);'), (47, '    }'), (50, '    let mut store = Store::new(&engine, ());'), (51, '    if use_epochs {'), (52, '        store.set_epoch_deadline(1);'), (53, '    }')], 'deleted': [(46, '    let store = Store::new(&engine, ());')]}",
    "num_lines_added": "8",
    "num_lines_deleted": "1",
    "nloc": "54"
  },
  {
    "file_change_id": "84443125557376",
    "hash": "2a4d538",
    "old_path": "src/stack.rs",
    "new_path": "src/stack.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -53,7 +53,8 @@ impl<T: ?Sized, D: ::DataBuf> StackA<T, D> {\n         mem::size_of::<&T>() / mem::size_of::<usize>() - 1\n     }\n \n-    fn push_inner(&mut self, fat_ptr: &T) -> Result<&mut [usize], ()> {\n+\t/// Returns the metadata and data slots\n+    fn push_inner(&mut self, fat_ptr: &T) -> Result<(&mut [usize],&mut [usize]), ()> {\n         let bytes = mem::size_of_val(fat_ptr);\n         let words = super::round_to_words(bytes) + Self::meta_words();\n         // Check if there is sufficient space for the new item\n@@ -71,7 +72,7 @@ impl<T: ?Sized, D: ::DataBuf> StackA<T, D> {\n             meta.clone_from_slice(&ptr_words[1..]);\n \n             // Increment offset and return\n-            Ok(rv)\n+            Ok( (meta, rv) )\n         } else {\n             Err(())\n         }\n@@ -94,7 +95,7 @@ impl<T: ?Sized, D: ::DataBuf> StackA<T, D> {\n         );\n \n         match self.push_inner(f(&v)) {\n-            Ok(d) => {\n+            Ok((_,d)) => {\n                 // SAFE: Destination address is valid\n                 unsafe {\n                     ptr::write(d.as_mut_ptr() as *mut U, v);\n@@ -143,7 +144,7 @@ impl<T: ?Sized, D: ::DataBuf> StackA<T, D> {\n impl<D: ::DataBuf> StackA<str, D> {\n     /// Push the contents of a string slice as an item onto the stack\n     pub fn push_str(&mut self, v: &str) -> Result<(), ()> {\n-        self.push_inner(v).map(|d| unsafe {\n+        self.push_inner(v).map(|(_,d)| unsafe {\n             ptr::copy(v.as_bytes().as_ptr(), d.as_mut_ptr() as *mut u8, v.len());\n         })\n     }\n@@ -151,12 +152,24 @@ impl<D: ::DataBuf> StackA<str, D> {\n impl<D: ::DataBuf, T: Clone> StackA<[T], D> {\n     /// Pushes a set of items (cloning out of the input slice)\n     pub fn push_cloned(&mut self, v: &[T]) -> Result<(), ()> {\n-        self.push_inner(&v).map(|d| unsafe {\n-            let mut ptr = d.as_mut_ptr() as *mut T;\n-            for val in v {\n-                ptr::write(ptr, val.clone());\n-                ptr = ptr.offset(1);\n-            }\n-        })\n+        let (meta,d) = self.push_inner(&v)?;\n+\t\t// Prepare the slot with zeros (as if it's an empty slice)\n+\t\t// The length is updated as each item is written\n+\t\t// - This ensures that there's no drop issues during write\n+\t\tmeta[0] = 0;\n+\t\tfor v in d.iter_mut() {\n+\t\t\t*v = 0;\n+\t\t}\n+\n+\t\tunsafe {\n+\t\t\tlet mut ptr = d.as_mut_ptr() as *mut T;\n+\t\t\tfor val in v {\n+\t\t\t\tptr::write(ptr, val.clone());\n+\t\t\t\tmeta[0] += 1;\n+\t\t\t\tptr = ptr.offset(1);\n+\t\t\t}\n+\t\t}\n+\n+\t\tOk( () )\n     }\n }\n",
    "diff_parsed": "{'added': [(57, '    fn push_inner(&mut self, fat_ptr: &T) -> Result<(&mut [usize],&mut [usize]), ()> {'), (75, '            Ok( (meta, rv) )'), (98, '            Ok((_,d)) => {'), (147, '        self.push_inner(v).map(|(_,d)| unsafe {'), (155, '        let (meta,d) = self.push_inner(&v)?;'), (159, '\\t\\tmeta[0] = 0;'), (160, '\\t\\tfor v in d.iter_mut() {'), (161, '\\t\\t\\t*v = 0;'), (162, '\\t\\t}'), (164, '\\t\\tunsafe {'), (165, '\\t\\t\\tlet mut ptr = d.as_mut_ptr() as *mut T;'), (166, '\\t\\t\\tfor val in v {'), (167, '\\t\\t\\t\\tptr::write(ptr, val.clone());'), (168, '\\t\\t\\t\\tmeta[0] += 1;'), (169, '\\t\\t\\t\\tptr = ptr.offset(1);'), (170, '\\t\\t\\t}'), (171, '\\t\\t}'), (173, '\\t\\tOk( () )')], 'deleted': [(56, '    fn push_inner(&mut self, fat_ptr: &T) -> Result<&mut [usize], ()> {'), (74, '            Ok(rv)'), (97, '            Ok(d) => {'), (146, '        self.push_inner(v).map(|d| unsafe {'), (154, '        self.push_inner(&v).map(|d| unsafe {'), (155, '            let mut ptr = d.as_mut_ptr() as *mut T;'), (156, '            for val in v {'), (157, '                ptr::write(ptr, val.clone());'), (158, '                ptr = ptr.offset(1);'), (159, '            }'), (160, '        })')]}",
    "num_lines_added": "18",
    "num_lines_deleted": "11",
    "nloc": "123"
  },
  {
    "file_change_id": "33372523114440",
    "hash": "2a4d538",
    "old_path": "tests/stack.rs",
    "new_path": "tests/stack.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -114,3 +114,34 @@ fn destructors() {\n     drop(stack);\n     assert_eq!(v.get(), 2 + 3);\n }\n+\n+#[test]\n+fn slice_push_panic_safety() {\n+\tuse std::sync::atomic::{AtomicUsize,Ordering};\n+\tstatic COUNT: AtomicUsize = AtomicUsize::new(0);\n+\tstruct Sentinel(bool);\n+\timpl Clone for Sentinel {\n+\t\tfn clone(&self) -> Self {\n+\t\t\tif self.0 {\n+\t\t\t\tpanic!();\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tSentinel(self.0)\n+\t\t\t}\n+\t\t}\n+\t}\n+\timpl Drop for Sentinel {\n+\t\tfn drop(&mut self) {\n+\t\t\tCOUNT.fetch_add(1, Ordering::SeqCst);\n+\t\t}\n+\t}\n+\tlet input = [Sentinel(false), Sentinel(true)];\n+\n+\n+\tlet _ = ::std::panic::catch_unwind(::std::panic::AssertUnwindSafe(|| {\n+\t\tlet mut stack = ::stack_dst::StackA::<[Sentinel], [usize; 8]>::new();\n+\t\tlet _ = stack.push_cloned(&input);\n+\t\t}));\n+\tassert_eq!(COUNT.load(Ordering::SeqCst), 1);\n+}\n+\n",
    "diff_parsed": "{'added': [(118, '#[test]'), (119, 'fn slice_push_panic_safety() {'), (120, '\\tuse std::sync::atomic::{AtomicUsize,Ordering};'), (121, '\\tstatic COUNT: AtomicUsize = AtomicUsize::new(0);'), (122, '\\tstruct Sentinel(bool);'), (123, '\\timpl Clone for Sentinel {'), (124, '\\t\\tfn clone(&self) -> Self {'), (125, '\\t\\t\\tif self.0 {'), (126, '\\t\\t\\t\\tpanic!();'), (127, '\\t\\t\\t}'), (128, '\\t\\t\\telse {'), (129, '\\t\\t\\t\\tSentinel(self.0)'), (130, '\\t\\t\\t}'), (131, '\\t\\t}'), (132, '\\t}'), (133, '\\timpl Drop for Sentinel {'), (134, '\\t\\tfn drop(&mut self) {'), (135, '\\t\\t\\tCOUNT.fetch_add(1, Ordering::SeqCst);'), (136, '\\t\\t}'), (137, '\\t}'), (138, '\\tlet input = [Sentinel(false), Sentinel(true)];'), (141, '\\tlet _ = ::std::panic::catch_unwind(::std::panic::AssertUnwindSafe(|| {'), (142, '\\t\\tlet mut stack = ::stack_dst::StackA::<[Sentinel], [usize; 8]>::new();'), (143, '\\t\\tlet _ = stack.push_cloned(&input);'), (144, '\\t\\t}));'), (145, '\\tassert_eq!(COUNT.load(Ordering::SeqCst), 1);'), (146, '}')], 'deleted': []}",
    "num_lines_added": "27",
    "num_lines_deleted": "0",
    "nloc": "119"
  },
  {
    "file_change_id": "100555313756930",
    "hash": "2327d3b774927fdf48903c0bdc1ca7ec93c7c8d0",
    "old_path": "src/trace.rs",
    "new_path": "src/trace.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -61,7 +61,7 @@ pub unsafe fn config_log(callback: Option<fn(c_int, &str)>) -> Result<()> {\n pub fn log(err_code: c_int, msg: &str) {\n     let msg = CString::new(msg).expect(\"SQLite log messages cannot contain embedded zeroes\");\n     unsafe {\n-        ffi::sqlite3_log(err_code, msg.as_ptr());\n+        ffi::sqlite3_log(err_code, b\"%s\\0\" as *const _ as *const c_char, msg.as_ptr());\n     }\n }\n \n",
    "diff_parsed": "{'added': [(64, '        ffi::sqlite3_log(err_code, b\"%s\\\\0\" as *const _ as *const c_char, msg.as_ptr());')], 'deleted': [(64, '        ffi::sqlite3_log(err_code, msg.as_ptr());')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "135"
  },
  {
    "file_change_id": "130794596646955",
    "hash": "8f93123efef5c1361086688fe4f34c83c89cec02",
    "old_path": "src/proto/h1/role.rs",
    "new_path": "src/proto/h1/role.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -213,6 +213,8 @@ impl Http1Transaction for Server {\n                     if headers::is_chunked_(&value) {\n                         is_te_chunked = true;\n                         decoder = DecodedLength::CHUNKED;\n+                    } else {\n+                        is_te_chunked = false;\n                     }\n                 }\n                 header::CONTENT_LENGTH => {\n@@ -1444,6 +1446,16 @@ mod tests {\n             \"transfer-encoding doesn't end in chunked\",\n         );\n \n+        parse_err(\n+            \"\\\n+             POST / HTTP/1.1\\r\\n\\\n+             transfer-encoding: chunked\\r\\n\\\n+             transfer-encoding: afterlol\\r\\n\\\n+             \\r\\n\\\n+             \",\n+            \"transfer-encoding multiple lines doesn't end in chunked\",\n+        );\n+\n         // http/1.0\n \n         assert_eq!(\n",
    "diff_parsed": "{'added': [(216, '                    } else {'), (217, '                        is_te_chunked = false;'), (1449, '        parse_err('), (1450, '            \"\\\\'), (1451, '             POST / HTTP/1.1\\\\r\\\\n\\\\'), (1452, '             transfer-encoding: chunked\\\\r\\\\n\\\\'), (1453, '             transfer-encoding: afterlol\\\\r\\\\n\\\\'), (1454, '             \\\\r\\\\n\\\\'), (1455, '             \",'), (1456, '            \"transfer-encoding multiple lines doesn\\'t end in chunked\",'), (1457, '        );')], 'deleted': []}",
    "num_lines_added": "11",
    "num_lines_deleted": "0",
    "nloc": "1882"
  },
  {
    "file_change_id": "253409544191593",
    "hash": "d44011a69e0674acfa9c59bd7ad7f0523eb61d42",
    "old_path": "runtime/ops/fs.rs",
    "new_path": "runtime/ops/fs.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1370,7 +1370,8 @@ fn op_symlink_sync(\n   let oldpath = PathBuf::from(&args.oldpath);\n   let newpath = PathBuf::from(&args.newpath);\n \n-  state.borrow_mut::<Permissions>().write.check(&newpath)?;\n+  state.borrow_mut::<Permissions>().write.check_all()?;\n+  state.borrow_mut::<Permissions>().read.check_all()?;\n \n   debug!(\n     \"op_symlink_sync {} {}\",\n@@ -1432,7 +1433,8 @@ async fn op_symlink_async(\n \n   {\n     let mut state = state.borrow_mut();\n-    state.borrow_mut::<Permissions>().write.check(&newpath)?;\n+    state.borrow_mut::<Permissions>().write.check_all()?;\n+    state.borrow_mut::<Permissions>().read.check_all()?;\n   }\n \n   tokio::task::spawn_blocking(move || {\n",
    "diff_parsed": "{'added': [(1373, '  state.borrow_mut::<Permissions>().write.check_all()?;'), (1374, '  state.borrow_mut::<Permissions>().read.check_all()?;'), (1436, '    state.borrow_mut::<Permissions>().write.check_all()?;'), (1437, '    state.borrow_mut::<Permissions>().read.check_all()?;')], 'deleted': [(1373, '  state.borrow_mut::<Permissions>().write.check(&newpath)?;'), (1435, '    state.borrow_mut::<Permissions>().write.check(&newpath)?;')]}",
    "num_lines_added": "4",
    "num_lines_deleted": "2",
    "nloc": "1726"
  },
  {
    "file_change_id": "1696602724433",
    "hash": "1a2efcdbe68e5e7fd0a05836ac32d2cde78a0b2e",
    "old_path": "tests/script.rs",
    "new_path": "tests/script.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -51,6 +51,7 @@ macro_rules! test_cases {\n                 out_json.reverse();\n \n                 let mut results = Vec::new();\n+                let mut state = Value::null();\n                 for (id, mut json) in in_json.into_iter().enumerate() {\n                     let uri = EventOriginUri{\n                         host: \"test\".into(),\n@@ -62,7 +63,6 @@ macro_rules! test_cases {\n                     };\n                     let context = EventContext::new(id as u64, Some(&uri));\n                     let mut meta = Value::from(Object::default());\n-                    let mut state = Value::null();\n                     match script.run(&context, AggrType::Tick, &mut json, &mut state, &mut meta)? {\n                         Return::Drop => (),\n                         Return::EmitEvent{..} => results.push(json),\n@@ -154,6 +154,7 @@ test_cases!(\n     // TODO\n     // const_in_const_lookup,\n     // INSERT\n+    merge_assign_target_state,\n     expr_path,\n     patch_default,\n     patch_default_key,\n@@ -186,7 +187,7 @@ test_cases!(\n     heredoc_quoted_curly,\n     string_interpolation_import,\n     string_interpolation_prefix,\n-    patch_in_place,\n+    patch_assign_target,\n     tuple_pattern,\n     pattern_cmp,\n     pass_args,\n",
    "diff_parsed": "{'added': [(54, '                let mut state = Value::null();'), (157, '    merge_assign_target_state,'), (190, '    patch_assign_target,')], 'deleted': [(65, '                    let mut state = Value::null();'), (189, '    patch_in_place,')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "2",
    "nloc": "179"
  },
  {
    "file_change_id": "70884438090627",
    "hash": "1a2efcdbe68e5e7fd0a05836ac32d2cde78a0b2e",
    "old_path": "tests/script_runtime_error.rs",
    "new_path": "tests/script_runtime_error.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -105,10 +105,10 @@ macro_rules! ignore_cases {\n                 file.read_to_string(&mut err)?;\n                 let _err = err.trim();\n \n+                let mut state = Value::null();\n                 if let Some(mut json) =  in_json.pop() {\n                     let context = EventContext::new(0, None);\n                     let mut meta = Value::object();\n-                    let mut state = Value::null();\n                     let s = script.run(&context, AggrType::Tick, &mut json, &mut state, &mut meta);\n                     if let Err(e) = s {\n                         let mut h = Dumb::new();\n@@ -144,8 +144,8 @@ test_cases!(\n     function_error_n,\n     match_bad_guard_type,\n     match_no_clause_hit,\n-    merge_in_place_new_no_object,\n-    merge_in_place_target_no_object,\n+    merge_assign_target_new_no_object,\n+    merge_assign_target_target_no_object,\n     merge_new_no_object,\n     merge_target_no_object,\n     missing_local,\n",
    "diff_parsed": "{'added': [(108, '                let mut state = Value::null();'), (147, '    merge_assign_target_new_no_object,'), (148, '    merge_assign_target_target_no_object,')], 'deleted': [(111, '                    let mut state = Value::null();'), (147, '    merge_in_place_new_no_object,'), (148, '    merge_in_place_target_no_object,')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "3",
    "nloc": "149"
  },
  {
    "file_change_id": "274807572444984",
    "hash": "1a2efcdbe68e5e7fd0a05836ac32d2cde78a0b2e",
    "old_path": "tremor-script/src/ast.rs",
    "new_path": "tremor-script/src/ast.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -961,10 +961,6 @@ pub enum Expr<'script> {\n     Match(Box<Match<'script, Self>>),\n     /// IfElse style match expression\n     IfElse(Box<IfElse<'script, Self>>),\n-    /// In place patch expression\n-    PatchInPlace(Box<Patch<'script>>),\n-    /// In place merge expression\n-    MergeInPlace(Box<Merge<'script>>),\n     /// Assignment expression\n     Assign {\n         /// Id\n",
    "diff_parsed": "{'added': [], 'deleted': [(965, \"    PatchInPlace(Box<Patch<'script>>),\"), (967, \"    MergeInPlace(Box<Merge<'script>>),\")]}",
    "num_lines_added": "0",
    "num_lines_deleted": "2",
    "nloc": "2420"
  },
  {
    "file_change_id": "262660051178608",
    "hash": "1a2efcdbe68e5e7fd0a05836ac32d2cde78a0b2e",
    "old_path": "tremor-script/src/ast/base_expr.rs",
    "new_path": "tremor-script/src/ast/base_expr.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -248,8 +248,6 @@ impl<'script> BaseExpr for Expr<'script> {\n             Expr::Emit(e) => e.mid(),\n             Expr::Imut(e) => e.mid(),\n             Expr::Match(e) => e.mid(),\n-            Expr::MergeInPlace(e) => e.mid(),\n-            Expr::PatchInPlace(e) => e.mid(),\n             Expr::IfElse(e) => e.mid(),\n         }\n     }\n",
    "diff_parsed": "{'added': [], 'deleted': [(251, '            Expr::MergeInPlace(e) => e.mid(),'), (252, '            Expr::PatchInPlace(e) => e.mid(),')]}",
    "num_lines_added": "0",
    "num_lines_deleted": "2",
    "nloc": "497"
  },
  {
    "file_change_id": "119359508371070",
    "hash": "1a2efcdbe68e5e7fd0a05836ac32d2cde78a0b2e",
    "old_path": "tremor-script/src/ast/raw.rs",
    "new_path": "tremor-script/src/ast/raw.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -18,14 +18,14 @@\n \n use crate::{\n     ast::{\n-        base_expr, eq::AstEq, query, upable::Upable, ArrayPattern, ArrayPredicatePattern,\n-        AssignPattern, BinExpr, BinOpKind, Bytes, BytesPart, ClauseGroup, Comprehension,\n-        ComprehensionCase, Costly, DefaultCase, EmitExpr, EventPath, Expr, ExprPath, Expression,\n-        Field, FnDecl, FnDoc, Helper, Ident, IfElse, ImutExpr, ImutExprInt, Invocable, Invoke,\n-        InvokeAggr, InvokeAggrFn, List, Literal, LocalPath, Match, Merge, MetadataPath, ModDoc,\n-        NodeMetas, Patch, PatchOperation, Path, Pattern, PredicateClause, PredicatePattern, Record,\n-        RecordPattern, Recur, ReservedPath, Script, Segment, StatePath, StrLitElement, StringLit,\n-        TestExpr, TuplePattern, UnaryExpr, UnaryOpKind,\n+        base_expr, query, upable::Upable, ArrayPattern, ArrayPredicatePattern, AssignPattern,\n+        BinExpr, BinOpKind, Bytes, BytesPart, ClauseGroup, Comprehension, ComprehensionCase,\n+        Costly, DefaultCase, EmitExpr, EventPath, Expr, ExprPath, Expression, Field, FnDecl, FnDoc,\n+        Helper, Ident, IfElse, ImutExpr, ImutExprInt, Invocable, Invoke, InvokeAggr, InvokeAggrFn,\n+        List, Literal, LocalPath, Match, Merge, MetadataPath, ModDoc, NodeMetas, Patch,\n+        PatchOperation, Path, Pattern, PredicateClause, PredicatePattern, Record, RecordPattern,\n+        Recur, ReservedPath, Script, Segment, StatePath, StrLitElement, StringLit, TestExpr,\n+        TuplePattern, UnaryExpr, UnaryOpKind,\n     },\n     errors::{\n         err_generic, error_generic, error_missing_effector, error_oops, Error, ErrorKind, Result,\n@@ -646,28 +646,16 @@ impl<'script> Upable<'script> for ExprRaw<'script> {\n                 let path = a.path.up(helper)?;\n                 let mid = helper.add_meta(a.start, a.end);\n                 match a.expr.up(helper)? {\n-                    Expr::Imut(ImutExprInt::Merge(m)) => {\n-                        if path.ast_eq(&m.target) {\n-                            Expr::MergeInPlace(Box::new(*m))\n-                        } else {\n-                            Expr::Assign {\n-                                mid,\n-                                path,\n-                                expr: Box::new(ImutExprInt::Merge(m).into()),\n-                            }\n-                        }\n-                    }\n-                    Expr::Imut(ImutExprInt::Patch(m)) => {\n-                        if path.ast_eq(&m.target) {\n-                            Expr::PatchInPlace(Box::new(*m))\n-                        } else {\n-                            Expr::Assign {\n-                                mid,\n-                                path,\n-                                expr: Box::new(ImutExprInt::Patch(m).into()),\n-                            }\n-                        }\n-                    }\n+                    Expr::Imut(ImutExprInt::Merge(m)) => Expr::Assign {\n+                        mid,\n+                        path,\n+                        expr: Box::new(ImutExprInt::Merge(m).into()),\n+                    },\n+                    Expr::Imut(ImutExprInt::Patch(m)) => Expr::Assign {\n+                        mid,\n+                        path,\n+                        expr: Box::new(ImutExprInt::Patch(m).into()),\n+                    },\n                     expr => Expr::Assign {\n                         mid,\n                         path,\n",
    "diff_parsed": "{'added': [(21, '        base_expr, query, upable::Upable, ArrayPattern, ArrayPredicatePattern, AssignPattern,'), (22, '        BinExpr, BinOpKind, Bytes, BytesPart, ClauseGroup, Comprehension, ComprehensionCase,'), (23, '        Costly, DefaultCase, EmitExpr, EventPath, Expr, ExprPath, Expression, Field, FnDecl, FnDoc,'), (24, '        Helper, Ident, IfElse, ImutExpr, ImutExprInt, Invocable, Invoke, InvokeAggr, InvokeAggrFn,'), (25, '        List, Literal, LocalPath, Match, Merge, MetadataPath, ModDoc, NodeMetas, Patch,'), (26, '        PatchOperation, Path, Pattern, PredicateClause, PredicatePattern, Record, RecordPattern,'), (27, '        Recur, ReservedPath, Script, Segment, StatePath, StrLitElement, StringLit, TestExpr,'), (28, '        TuplePattern, UnaryExpr, UnaryOpKind,'), (649, '                    Expr::Imut(ImutExprInt::Merge(m)) => Expr::Assign {'), (650, '                        mid,'), (651, '                        path,'), (652, '                        expr: Box::new(ImutExprInt::Merge(m).into()),'), (653, '                    },'), (654, '                    Expr::Imut(ImutExprInt::Patch(m)) => Expr::Assign {'), (655, '                        mid,'), (656, '                        path,'), (657, '                        expr: Box::new(ImutExprInt::Patch(m).into()),'), (658, '                    },')], 'deleted': [(21, '        base_expr, eq::AstEq, query, upable::Upable, ArrayPattern, ArrayPredicatePattern,'), (22, '        AssignPattern, BinExpr, BinOpKind, Bytes, BytesPart, ClauseGroup, Comprehension,'), (23, '        ComprehensionCase, Costly, DefaultCase, EmitExpr, EventPath, Expr, ExprPath, Expression,'), (24, '        Field, FnDecl, FnDoc, Helper, Ident, IfElse, ImutExpr, ImutExprInt, Invocable, Invoke,'), (25, '        InvokeAggr, InvokeAggrFn, List, Literal, LocalPath, Match, Merge, MetadataPath, ModDoc,'), (26, '        NodeMetas, Patch, PatchOperation, Path, Pattern, PredicateClause, PredicatePattern, Record,'), (27, '        RecordPattern, Recur, ReservedPath, Script, Segment, StatePath, StrLitElement, StringLit,'), (28, '        TestExpr, TuplePattern, UnaryExpr, UnaryOpKind,'), (649, '                    Expr::Imut(ImutExprInt::Merge(m)) => {'), (650, '                        if path.ast_eq(&m.target) {'), (651, '                            Expr::MergeInPlace(Box::new(*m))'), (652, '                        } else {'), (653, '                            Expr::Assign {'), (654, '                                mid,'), (655, '                                path,'), (656, '                                expr: Box::new(ImutExprInt::Merge(m).into()),'), (657, '                            }'), (658, '                        }'), (659, '                    }'), (660, '                    Expr::Imut(ImutExprInt::Patch(m)) => {'), (661, '                        if path.ast_eq(&m.target) {'), (662, '                            Expr::PatchInPlace(Box::new(*m))'), (663, '                        } else {'), (664, '                            Expr::Assign {'), (665, '                                mid,'), (666, '                                path,'), (667, '                                expr: Box::new(ImutExprInt::Patch(m).into()),'), (668, '                            }'), (669, '                        }'), (670, '                    }')]}",
    "num_lines_added": "18",
    "num_lines_deleted": "30",
    "nloc": "2394"
  },
  {
    "file_change_id": "91559199009874",
    "hash": "1a2efcdbe68e5e7fd0a05836ac32d2cde78a0b2e",
    "old_path": "tremor-script/src/ast/to_static.rs",
    "new_path": "tremor-script/src/ast/to_static.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -159,8 +159,6 @@ impl<'script> Expr<'script> {\n         match self {\n             Expr::Match(e) => Expr::Match(Box::new(e.into_static())),\n             Expr::IfElse(e) => Expr::IfElse(Box::new(e.into_static())),\n-            Expr::PatchInPlace(e) => Expr::PatchInPlace(Box::new(e.into_static())),\n-            Expr::MergeInPlace(e) => Expr::MergeInPlace(Box::new(e.into_static())),\n             Expr::Assign { mid, path, expr } => Expr::Assign {\n                 mid,\n                 path: path.into_static(),\n",
    "diff_parsed": "{'added': [], 'deleted': [(162, '            Expr::PatchInPlace(e) => Expr::PatchInPlace(Box::new(e.into_static())),'), (163, '            Expr::MergeInPlace(e) => Expr::MergeInPlace(Box::new(e.into_static())),')]}",
    "num_lines_added": "0",
    "num_lines_deleted": "2",
    "nloc": "1036"
  },
  {
    "file_change_id": "61887007512540",
    "hash": "1a2efcdbe68e5e7fd0a05836ac32d2cde78a0b2e",
    "old_path": "tremor-script/src/interpreter/expr.rs",
    "new_path": "tremor-script/src/interpreter/expr.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -13,24 +13,23 @@\n // limitations under the License.\n \n use super::{\n-    merge_values, patch_value, resolve, resolve_value, set_local_shadow, test_guard,\n-    test_predicate_expr, Env, ExecOpts, LocalStack, NULL,\n+    resolve, resolve_value, set_local_shadow, test_guard, test_predicate_expr, Env, ExecOpts,\n+    LocalStack, NULL,\n };\n use crate::errors::{\n     error_assign_array, error_assign_to_const, error_bad_key_err, error_invalid_assign_target,\n-    error_need_obj, error_need_obj_err, error_no_clause_hit, Result,\n+    error_need_obj_err, error_no_clause_hit, Result,\n };\n use crate::prelude::*;\n use crate::registry::RECUR_PTR;\n use crate::{\n     ast::{\n         BaseExpr, ClauseGroup, ClausePreCondition, Comprehension, DefaultCase, EmitExpr, EventPath,\n-        Expr, IfElse, ImutExprInt, Match, Merge, Patch, Path, Segment,\n+        Expr, IfElse, ImutExprInt, Match, Path, Segment,\n     },\n     errors::error_oops_err,\n };\n use crate::{stry, Value};\n-use matches::matches;\n use std::mem;\n use std::{\n     borrow::{Borrow, Cow},\n@@ -219,104 +218,6 @@ impl<'script> Expr<'script> {\n         }\n     }\n \n-    fn patch_in_place<'run, 'event>(\n-        opts: ExecOpts,\n-        env: &'run Env<'run, 'event>,\n-        event: &'run Value<'event>,\n-        state: &'run Value<'static>,\n-        meta: &'run Value<'event>,\n-        local: &'run LocalStack<'event>,\n-        expr: &'run Patch<'event>,\n-    ) -> Result<Cow<'run, Value<'event>>> {\n-        // This function is called when we encounter code that consumes a value\n-        // to patch it. So the following code:\n-        // ```tremor\n-        // let event = patch event of insert \"key\" => \"value\" end\n-        // ```\n-        // When executed on it's own would clone the event, add a key and\n-        // overwrite original event.\n-        //\n-        // We optimise this as:\n-        // ```\n-        // patch_in_place event of insert \"key\" => \"value\" end\n-        // ```\n-        //\n-        // This code is generated in impl Upable for ExprRaw where the following\n-        // checks are performed:\n-        //\n-        // 1) the patch is on the RHS of an assignment\n-        // 2) the path of the assigned value and the path of the patched\n-        //    expression are identical.\n-        //\n-        // In turn this guarantees (at compile time):\n-        //\n-        // 1) The target (`expr`) is a path lookup\n-        // 2) The target is not a known constant as otherwise the assignment\n-        //    will complan\n-        // 3) this leave the `expr` to be either a local, the event, the state,\n-        //    metadata or a subkey thereof.\n-        //\n-        // And the following guarantees at run time:\n-        //\n-        // 1) the `expr` is an existing key of the mentioned categories,\n-        //    otherwise `expr.target.run` will error.\n-        // 2) `value` will never be owned (however the resolve function is\n-        //    generic so it needs to return a Cow)\n-\n-        let value: Cow<'run, Value<'event>> =\n-            stry!(expr.target.run(opts, env, event, state, meta, local));\n-        debug_assert!(\n-            !matches!(value, Cow::Owned(_)),\n-            \"We should never see a owned value here as patch_in_place is only ever called on existing data in event, state, meta or local\"\n-        );\n-        let v: &Value<'event> = value.borrow();\n-        // ALLOW: https://github.com/tremor-rs/tremor-runtime/issues/1032\n-        #[allow(mutable_transmutes, clippy::transmute_ptr_to_ptr)]\n-        // ALLOW: https://github.com/tremor-rs/tremor-runtime/issues/1032\n-        let v: &mut Value<'event> = unsafe { mem::transmute(v) };\n-        stry!(patch_value(opts, env, event, state, meta, local, v, expr));\n-        Ok(value)\n-    }\n-\n-    fn merge_in_place<'run, 'event>(\n-        &'run self,\n-        opts: ExecOpts,\n-        env: &'run Env<'run, 'event>,\n-        event: &'run mut Value<'event>,\n-        state: &'run mut Value<'static>,\n-        meta: &'run mut Value<'event>,\n-        local: &'run mut LocalStack<'event>,\n-        expr: &'run Merge<'event>,\n-    ) -> Result<Cow<'run, Value<'event>>> {\n-        // Please see the soundness reasoning in `patch_in_place` for details\n-        // those functions perform the same function just with slighty different\n-        // operations.\n-        let value_cow: Cow<'run, Value<'event>> =\n-            stry!(expr.target.run(opts, env, event, state, meta, local));\n-        debug_assert!(\n-            !matches!(value_cow, Cow::Owned(_)),\n-            \"We should never see a owned value here as merge_in_place is only ever called on existing data in event, state, meta or local\"\n-        );\n-\n-        if value_cow.is_object() {\n-            let value: &Value<'event> = value_cow.borrow();\n-            // ALLOW: https://github.com/tremor-rs/tremor-runtime/issues/1032\n-            #[allow(mutable_transmutes, clippy::transmute_ptr_to_ptr)]\n-            // ALLOW: https://github.com/tremor-rs/tremor-runtime/issues/1032\n-            let value: &mut Value<'event> = unsafe { mem::transmute(value) };\n-            let replacement = stry!(expr.expr.run(opts, env, event, state, meta, local,));\n-\n-            if replacement.is_object() {\n-                stry!(merge_values(self, &expr.expr, value, &replacement));\n-                Ok(value_cow)\n-            } else {\n-                error_need_obj(self, &expr.expr, replacement.value_type(), env.meta)\n-            }\n-        } else {\n-            error_need_obj(self, &expr.target, value_cow.value_type(), env.meta)\n-        }\n-    }\n-\n     // TODO: Quite some overlap with `ImutExprInt::comprehension`\n     fn comprehension<'run, 'event>(\n         &'run self,\n@@ -641,12 +542,6 @@ impl<'script> Expr<'script> {\n             }\n             Expr::Match(ref expr) => self.match_expr(opts, env, event, state, meta, local, expr),\n             Expr::IfElse(ref expr) => self.if_expr(opts, env, event, state, meta, local, expr),\n-            Expr::MergeInPlace(ref expr) => self\n-                .merge_in_place(opts, env, event, state, meta, local, expr)\n-                .map(Cont::Cont),\n-            Expr::PatchInPlace(ref expr) => {\n-                Self::patch_in_place(opts, env, event, state, meta, local, expr).map(Cont::Cont)\n-            }\n             Expr::Comprehension(ref expr) => {\n                 self.comprehension(opts, env, event, state, meta, local, expr)\n             }\n",
    "diff_parsed": "{'added': [(16, '    resolve, resolve_value, set_local_shadow, test_guard, test_predicate_expr, Env, ExecOpts,'), (17, '    LocalStack, NULL,'), (21, '    error_need_obj_err, error_no_clause_hit, Result,'), (28, '        Expr, IfElse, ImutExprInt, Match, Path, Segment,')], 'deleted': [(16, '    merge_values, patch_value, resolve, resolve_value, set_local_shadow, test_guard,'), (17, '    test_predicate_expr, Env, ExecOpts, LocalStack, NULL,'), (21, '    error_need_obj, error_need_obj_err, error_no_clause_hit, Result,'), (28, '        Expr, IfElse, ImutExprInt, Match, Merge, Patch, Path, Segment,'), (33, 'use matches::matches;'), (222, \"    fn patch_in_place<'run, 'event>(\"), (223, '        opts: ExecOpts,'), (224, \"        env: &'run Env<'run, 'event>,\"), (225, \"        event: &'run Value<'event>,\"), (226, \"        state: &'run Value<'static>,\"), (227, \"        meta: &'run Value<'event>,\"), (228, \"        local: &'run LocalStack<'event>,\"), (229, \"        expr: &'run Patch<'event>,\"), (230, \"    ) -> Result<Cow<'run, Value<'event>>> {\"), (266, \"        let value: Cow<'run, Value<'event>> =\"), (267, '            stry!(expr.target.run(opts, env, event, state, meta, local));'), (268, '        debug_assert!('), (269, '            !matches!(value, Cow::Owned(_)),'), (270, '            \"We should never see a owned value here as patch_in_place is only ever called on existing data in event, state, meta or local\"'), (271, '        );'), (272, \"        let v: &Value<'event> = value.borrow();\"), (274, '        #[allow(mutable_transmutes, clippy::transmute_ptr_to_ptr)]'), (276, \"        let v: &mut Value<'event> = unsafe { mem::transmute(v) };\"), (277, '        stry!(patch_value(opts, env, event, state, meta, local, v, expr));'), (278, '        Ok(value)'), (279, '    }'), (281, \"    fn merge_in_place<'run, 'event>(\"), (282, \"        &'run self,\"), (283, '        opts: ExecOpts,'), (284, \"        env: &'run Env<'run, 'event>,\"), (285, \"        event: &'run mut Value<'event>,\"), (286, \"        state: &'run mut Value<'static>,\"), (287, \"        meta: &'run mut Value<'event>,\"), (288, \"        local: &'run mut LocalStack<'event>,\"), (289, \"        expr: &'run Merge<'event>,\"), (290, \"    ) -> Result<Cow<'run, Value<'event>>> {\"), (294, \"        let value_cow: Cow<'run, Value<'event>> =\"), (295, '            stry!(expr.target.run(opts, env, event, state, meta, local));'), (296, '        debug_assert!('), (297, '            !matches!(value_cow, Cow::Owned(_)),'), (298, '            \"We should never see a owned value here as merge_in_place is only ever called on existing data in event, state, meta or local\"'), (299, '        );'), (301, '        if value_cow.is_object() {'), (302, \"            let value: &Value<'event> = value_cow.borrow();\"), (304, '            #[allow(mutable_transmutes, clippy::transmute_ptr_to_ptr)]'), (306, \"            let value: &mut Value<'event> = unsafe { mem::transmute(value) };\"), (307, '            let replacement = stry!(expr.expr.run(opts, env, event, state, meta, local,));'), (309, '            if replacement.is_object() {'), (310, '                stry!(merge_values(self, &expr.expr, value, &replacement));'), (311, '                Ok(value_cow)'), (312, '            } else {'), (313, '                error_need_obj(self, &expr.expr, replacement.value_type(), env.meta)'), (314, '            }'), (315, '        } else {'), (316, '            error_need_obj(self, &expr.target, value_cow.value_type(), env.meta)'), (317, '        }'), (318, '    }'), (644, '            Expr::MergeInPlace(ref expr) => self'), (645, '                .merge_in_place(opts, env, event, state, meta, local, expr)'), (646, '                .map(Cont::Cont),'), (647, '            Expr::PatchInPlace(ref expr) => {'), (648, '                Self::patch_in_place(opts, env, event, state, meta, local, expr).map(Cont::Cont)'), (649, '            }')]}",
    "num_lines_added": "4",
    "num_lines_deleted": "63",
    "nloc": "495"
  },
  {
    "file_change_id": "146640676171840",
    "hash": "ae70b41d4f46641dbc45c7a4f87954aea356283e",
    "old_path": "src/compile.rs",
    "new_path": "src/compile.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -38,6 +38,16 @@ pub struct Compiler {\n     suffix_cache: SuffixCache,\n     utf8_seqs: Option<Utf8Sequences>,\n     byte_classes: ByteClassSet,\n+    // This keeps track of extra bytes allocated while compiling the regex\n+    // program. Currently, this corresponds to two things. First is the heap\n+    // memory allocated by Unicode character classes ('InstRanges'). Second is\n+    // a \"fake\" amount of memory used by empty sub-expressions, so that enough\n+    // empty sub-expressions will ultimately trigger the compiler to bail\n+    // because of a size limit restriction. (That empty sub-expressions don't\n+    // add to heap memory usage is more-or-less an implementation detail.) In\n+    // the second case, if we don't bail, then an excessively large repetition\n+    // on an empty sub-expression can result in the compiler using a very large\n+    // amount of CPU time.\n     extra_inst_bytes: usize,\n }\n \n@@ -260,7 +270,7 @@ impl Compiler {\n \n         self.check_size()?;\n         match *expr.kind() {\n-            Empty => Ok(None),\n+            Empty => self.c_empty(),\n             Literal(hir::Literal::Unicode(c)) => self.c_char(c),\n             Literal(hir::Literal::Byte(b)) => {\n                 assert!(self.compiled.uses_bytes());\n@@ -378,6 +388,19 @@ impl Compiler {\n         }\n     }\n \n+    fn c_empty(&mut self) -> ResultOrEmpty {\n+        // See: https://github.com/rust-lang/regex/security/advisories/GHSA-m5pq-gvj9-9vr8\n+        // See: CVE-2022-24713\n+        //\n+        // Since 'empty' sub-expressions don't increase the size of\n+        // the actual compiled object, we \"fake\" an increase in its\n+        // size so that our 'check_size_limit' routine will eventually\n+        // stop compilation if there are too many empty sub-expressions\n+        // (e.g., via a large repetition).\n+        self.extra_inst_bytes += std::mem::size_of::<Inst>();\n+        Ok(None)\n+    }\n+\n     fn c_capture(&mut self, first_slot: usize, expr: &Hir) -> ResultOrEmpty {\n         if self.num_exprs > 1 || self.compiled.is_dfa {\n             // Don't ever compile Save instructions for regex sets because\n@@ -496,7 +519,7 @@ impl Compiler {\n         let mut exprs = exprs.into_iter();\n         let Patch { mut hole, entry } = loop {\n             match exprs.next() {\n-                None => return Ok(None),\n+                None => return self.c_empty(),\n                 Some(e) => {\n                     if let Some(p) = self.c(e)? {\n                         break p;\n",
    "diff_parsed": "{'added': [(273, '            Empty => self.c_empty(),'), (391, '    fn c_empty(&mut self) -> ResultOrEmpty {'), (400, '        self.extra_inst_bytes += std::mem::size_of::<Inst>();'), (401, '        Ok(None)'), (402, '    }'), (522, '                None => return self.c_empty(),')], 'deleted': [(263, '            Empty => Ok(None),'), (499, '                None => return Ok(None),')]}",
    "num_lines_added": "6",
    "num_lines_deleted": "2",
    "nloc": "990"
  },
  {
    "file_change_id": "3011068054131",
    "hash": "ae70b41d4f46641dbc45c7a4f87954aea356283e",
    "old_path": "tests/test_default.rs",
    "new_path": "tests/test_default.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -150,3 +150,73 @@ fn regex_is_reasonably_small() {\n     assert_eq!(16, size_of::<bytes::Regex>());\n     assert_eq!(16, size_of::<bytes::RegexSet>());\n }\n+\n+// See: https://github.com/rust-lang/regex/security/advisories/GHSA-m5pq-gvj9-9vr8\n+// See: CVE-2022-24713\n+//\n+// We test that our regex compiler will correctly return a \"too big\" error when\n+// we try to use a very large repetition on an *empty* sub-expression.\n+//\n+// At the time this test was written, the regex compiler does not represent\n+// empty sub-expressions with any bytecode instructions. In effect, it's an\n+// \"optimization\" to leave them out, since they would otherwise correspond\n+// to an unconditional JUMP in the regex bytecode (i.e., an unconditional\n+// epsilon transition in the NFA graph). Therefore, an empty sub-expression\n+// represents an interesting case for the compiler's size limits. Since it\n+// doesn't actually contribute any additional memory to the compiled regex\n+// instructions, the size limit machinery never detects it. Instead, it just\n+// dumbly tries to compile the empty sub-expression N times, where N is the\n+// repetition size.\n+//\n+// When N is very large, this will cause the compiler to essentially spin and\n+// do nothing for a decently large amount of time. It causes the regex to take\n+// quite a bit of time to compile, despite the concrete syntax of the regex\n+// being quite small.\n+//\n+// The degree to which this is actually a problem is somewhat of a judgment\n+// call. Some regexes simply take a long time to compile. But in general, you\n+// should be able to reasonably control this by setting lower or higher size\n+// limits on the compiled object size. But this mitigation doesn't work at all\n+// for this case.\n+//\n+// This particular test is somewhat narrow. It merely checks that regex\n+// compilation will, at some point, return a \"too big\" error. Before the\n+// fix landed, this test would eventually fail because the regex would be\n+// successfully compiled (after enough time elapsed). So while this test\n+// doesn't check that we exit in a reasonable amount of time, it does at least\n+// check that we are properly returning an error at some point.\n+#[test]\n+fn big_empty_regex_fails() {\n+    use regex::Regex;\n+\n+    let result = Regex::new(\"(?:){4294967295}\");\n+    assert!(result.is_err());\n+}\n+\n+// Below is a \"billion laughs\" variant of the previous test case.\n+#[test]\n+fn big_empty_reps_chain_regex_fails() {\n+    use regex::Regex;\n+\n+    let result = Regex::new(\"(?:){64}{64}{64}{64}{64}{64}\");\n+    assert!(result.is_err());\n+}\n+\n+// Below is another situation where a zero-length sub-expression can be\n+// introduced.\n+#[test]\n+fn big_zero_reps_regex_fails() {\n+    use regex::Regex;\n+\n+    let result = Regex::new(r\"x{0}{4294967295}\");\n+    assert!(result.is_err());\n+}\n+\n+// Testing another case for completeness.\n+#[test]\n+fn empty_alt_regex_fails() {\n+    use regex::Regex;\n+\n+    let result = Regex::new(r\"(?:|){4294967295}\");\n+    assert!(result.is_err());\n+}\n",
    "diff_parsed": "{'added': [(188, '#[test]'), (189, 'fn big_empty_regex_fails() {'), (190, '    use regex::Regex;'), (192, '    let result = Regex::new(\"(?:){4294967295}\");'), (193, '    assert!(result.is_err());'), (194, '}'), (197, '#[test]'), (198, 'fn big_empty_reps_chain_regex_fails() {'), (199, '    use regex::Regex;'), (201, '    let result = Regex::new(\"(?:){64}{64}{64}{64}{64}{64}\");'), (202, '    assert!(result.is_err());'), (203, '}'), (207, '#[test]'), (208, 'fn big_zero_reps_regex_fails() {'), (209, '    use regex::Regex;'), (211, '    let result = Regex::new(r\"x{0}{4294967295}\");'), (212, '    assert!(result.is_err());'), (213, '}'), (216, '#[test]'), (217, 'fn empty_alt_regex_fails() {'), (218, '    use regex::Regex;'), (220, '    let result = Regex::new(r\"(?:|){4294967295}\");'), (221, '    assert!(result.is_err());'), (222, '}')], 'deleted': []}",
    "num_lines_added": "24",
    "num_lines_deleted": "0",
    "nloc": "145"
  },
  {
    "file_change_id": "22224429939467",
    "hash": "45fd77ee43c38eea4d6f4e2e56c1667a55ec654f",
    "old_path": "src/unlock_notify.rs",
    "new_path": "src/unlock_notify.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -26,12 +26,13 @@ impl UnlockNotification {\n         }\n     }\n \n-    fn fired(&mut self) {\n-        *self.mutex.lock().unwrap() = true;\n+    fn fired(&self) {\n+        let mut flag = self.mutex.lock().unwrap();\n+        *flag = true;\n         self.cond.notify_one();\n     }\n \n-    fn wait(&mut self) {\n+    fn wait(&self) {\n         let mut fired = self.mutex.lock().unwrap();\n         while !*fired {\n             fired = self.cond.wait(fired).unwrap();\n@@ -43,12 +44,9 @@ impl UnlockNotification {\n #[cfg(feature = \"unlock_notify\")]\n unsafe extern \"C\" fn unlock_notify_cb(ap_arg: *mut *mut c_void, n_arg: c_int) {\n     use std::slice::from_raw_parts;\n-    let args = from_raw_parts(ap_arg, n_arg as usize);\n-    for arg in args {\n-        let _ = catch_unwind(|| {\n-            let un: &mut UnlockNotification = &mut *(*arg as *mut UnlockNotification);\n-            un.fired()\n-        });\n+    let args = from_raw_parts(ap_arg as *const &UnlockNotification, n_arg as usize);\n+    for un in args {\n+        let _ = catch_unwind(std::panic::AssertUnwindSafe(|| un.fired()));\n     }\n }\n \n@@ -73,12 +71,12 @@ pub unsafe fn is_locked(db: *mut ffi::sqlite3, rc: c_int) -> bool {\n /// back the current transaction (if any).\n #[cfg(feature = \"unlock_notify\")]\n pub unsafe fn wait_for_unlock_notify(db: *mut ffi::sqlite3) -> c_int {\n-    let mut un = UnlockNotification::new();\n+    let un = UnlockNotification::new();\n     /* Register for an unlock-notify callback. */\n     let rc = ffi::sqlite3_unlock_notify(\n         db,\n         Some(unlock_notify_cb),\n-        &mut un as *mut UnlockNotification as *mut c_void,\n+        &un as *const UnlockNotification as *mut c_void,\n     );\n     debug_assert!(\n         rc == ffi::SQLITE_LOCKED || rc == ffi::SQLITE_LOCKED_SHAREDCACHE || rc == ffi::SQLITE_OK\n",
    "diff_parsed": "{'added': [(29, '    fn fired(&self) {'), (30, '        let mut flag = self.mutex.lock().unwrap();'), (31, '        *flag = true;'), (35, '    fn wait(&self) {'), (47, '    let args = from_raw_parts(ap_arg as *const &UnlockNotification, n_arg as usize);'), (48, '    for un in args {'), (49, '        let _ = catch_unwind(std::panic::AssertUnwindSafe(|| un.fired()));'), (74, '    let un = UnlockNotification::new();'), (79, '        &un as *const UnlockNotification as *mut c_void,')], 'deleted': [(29, '    fn fired(&mut self) {'), (30, '        *self.mutex.lock().unwrap() = true;'), (34, '    fn wait(&mut self) {'), (46, '    let args = from_raw_parts(ap_arg, n_arg as usize);'), (47, '    for arg in args {'), (48, '        let _ = catch_unwind(|| {'), (49, '            let un: &mut UnlockNotification = &mut *(*arg as *mut UnlockNotification);'), (50, '            un.fired()'), (51, '        });'), (76, '    let mut un = UnlockNotification::new();'), (81, '        &mut un as *mut UnlockNotification as *mut c_void,')]}",
    "num_lines_added": "9",
    "num_lines_deleted": "11",
    "nloc": "101"
  },
  {
    "file_change_id": "30935038420108",
    "hash": "e61e045f8c244de978401d186dcfd50838817297",
    "old_path": "src/jit.rs",
    "new_path": "src/jit.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -913,7 +913,7 @@ fn emit_muldivmod<E: UserDefinedError>(jit: &mut JitCompiler, opc: u8, src: u8,\n         X86Instruction::pop(RAX).emit(jit)?;\n     }\n \n-    if size == OperandSize::S32 && opc & ebpf::BPF_ALU_OP_MASK == ebpf::BPF_MUL {\n+    if size == OperandSize::S32 && (mul || sdiv)  {\n         X86Instruction::sign_extend_i32_to_i64(dst, dst).emit(jit)?;\n     }\n     Ok(())\n",
    "diff_parsed": "{'added': [(916, '    if size == OperandSize::S32 && (mul || sdiv)  {')], 'deleted': [(916, '    if size == OperandSize::S32 && opc & ebpf::BPF_ALU_OP_MASK == ebpf::BPF_MUL {')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "1599"
  },
  {
    "file_change_id": "268529761589843",
    "hash": "e61e045f8c244de978401d186dcfd50838817297",
    "old_path": "tests/ubpf_execution.rs",
    "new_path": "tests/ubpf_execution.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -838,6 +838,21 @@ fn test_sdiv32_imm() {\n     );\n }\n \n+#[test]\n+fn test_sdiv32_neg_imm() {\n+    test_interpreter_and_jit_asm!(\n+        \"\n+        lddw r0, 0x10000000c\n+        sdiv32 r0, -4\n+        exit\",\n+        [],\n+        (),\n+        0,\n+        { |_vm, res: Result| { res.unwrap() as i64 == -3 } },\n+        3\n+    );\n+}\n+\n #[test]\n fn test_sdiv32_reg() {\n     test_interpreter_and_jit_asm!(\n@@ -854,6 +869,22 @@ fn test_sdiv32_reg() {\n     );\n }\n \n+#[test]\n+fn test_sdiv32_neg_reg() {\n+    test_interpreter_and_jit_asm!(\n+        \"\n+        lddw r0, 0x10000000c\n+        mov r1, -4\n+        sdiv32 r0, r1\n+        exit\",\n+        [],\n+        (),\n+        0,\n+        { |_vm, res: Result| { res.unwrap() as i64 == -0x3 } },\n+        4\n+    );\n+}\n+\n #[test]\n fn test_div64_imm() {\n     test_interpreter_and_jit_asm!(\n",
    "diff_parsed": "{'added': [(841, '#[test]'), (842, 'fn test_sdiv32_neg_imm() {'), (843, '    test_interpreter_and_jit_asm!('), (844, '        \"'), (845, '        lddw r0, 0x10000000c'), (846, '        sdiv32 r0, -4'), (847, '        exit\",'), (848, '        [],'), (849, '        (),'), (850, '        0,'), (851, '        { |_vm, res: Result| { res.unwrap() as i64 == -3 } },'), (852, '        3'), (853, '    );'), (854, '}'), (872, '#[test]'), (873, 'fn test_sdiv32_neg_reg() {'), (874, '    test_interpreter_and_jit_asm!('), (875, '        \"'), (876, '        lddw r0, 0x10000000c'), (877, '        mov r1, -4'), (878, '        sdiv32 r0, r1'), (879, '        exit\",'), (880, '        [],'), (881, '        (),'), (882, '        0,'), (883, '        { |_vm, res: Result| { res.unwrap() as i64 == -0x3 } },'), (884, '        4'), (885, '    );'), (886, '}')], 'deleted': []}",
    "num_lines_added": "29",
    "num_lines_deleted": "0",
    "nloc": "4211"
  },
  {
    "file_change_id": "253540755897670",
    "hash": "b4e6dc76f4845ab03104187a42ac6d1bbc1e0021",
    "old_path": "src/daemon.rs",
    "new_path": "src/daemon.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -85,6 +85,7 @@ async fn main() -> Result<(), Box<dyn std::error::Error>> {\n     }\n \n     let load_config = || {\n+        seteuid(env::var(\"PKEXEC_UID\").unwrap().parse::<u32>().unwrap()); // Dropping privileges to invoking user.\n         let config_file_path: std::path::PathBuf = if args.is_present(\"config\") {\n             Path::new(args.value_of(\"config\").unwrap()).to_path_buf()\n         } else {\n@@ -114,7 +115,7 @@ async fn main() -> Result<(), Box<dyn std::error::Error>> {\n     };\n \n     let mut hotkeys = load_config();\n-\n+    seteuid(0); // Escalating back to root after reading config file.\n     log::trace!(\"Attempting to find all keyboard file descriptors.\");\n     let keyboard_devices: Vec<Device> =\n         evdev::enumerate().filter(check_device_is_keyboard).collect();\n@@ -399,3 +400,14 @@ pub fn fetch_xdg_config_path() -> std::path::PathBuf {\n     };\n     config_file_path\n }\n+\n+pub fn seteuid(uid: u32) {\n+    let uid = nix::unistd::Uid::from_raw(uid);\n+    match nix::unistd::seteuid(uid) {\n+        Ok(_) => log::debug!(\"Dropping privileges...\"),\n+        Err(e) => {\n+            log::error!(\"Failed to set UID: {:#?}\", e);\n+            exit(1);\n+        }\n+    }\n+}\n",
    "diff_parsed": "{'added': [(88, '        seteuid(env::var(\"PKEXEC_UID\").unwrap().parse::<u32>().unwrap()); // Dropping privileges to invoking user.'), (118, '    seteuid(0); // Escalating back to root after reading config file.'), (404, 'pub fn seteuid(uid: u32) {'), (405, '    let uid = nix::unistd::Uid::from_raw(uid);'), (406, '    match nix::unistd::seteuid(uid) {'), (407, '        Ok(_) => log::debug!(\"Dropping privileges...\"),'), (408, '        Err(e) => {'), (409, '            log::error!(\"Failed to set UID: {:#?}\", e);'), (410, '            exit(1);'), (411, '        }'), (412, '    }'), (413, '}')], 'deleted': []}",
    "num_lines_added": "12",
    "num_lines_deleted": "0",
    "nloc": "356"
  },
  {
    "file_change_id": "176482830117422",
    "hash": "2a36405339c87b16ed6c76e91ad5b76638fbdb0c",
    "old_path": "src/install.rs",
    "new_path": "src/install.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -16,9 +16,11 @@ use anyhow::{bail, Context, Result};\n use lazy_static::lazy_static;\n use nix::mount;\n use regex::Regex;\n-use std::fs::{copy as fscopy, create_dir_all, read_dir, File, OpenOptions};\n+use std::fs::{\n+    copy as fscopy, create_dir_all, read_dir, set_permissions, File, OpenOptions, Permissions,\n+};\n use std::io::{copy, Read, Seek, SeekFrom, Write};\n-use std::os::unix::fs::FileTypeExt;\n+use std::os::unix::fs::{FileTypeExt, PermissionsExt};\n use std::path::{Path, PathBuf};\n \n use crate::blockdev::*;\n@@ -248,7 +250,21 @@ fn write_ignition(\n     // make parent directory\n     let mut config_dest = mountpoint.to_path_buf();\n     config_dest.push(\"ignition\");\n-    create_dir_all(&config_dest).context(\"creating Ignition config directory\")?;\n+    if !config_dest.is_dir() {\n+        create_dir_all(&config_dest).with_context(|| {\n+            format!(\n+                \"creating Ignition config directory {}\",\n+                config_dest.display()\n+            )\n+        })?;\n+        // Ignition data may contain secrets; restrict to root\n+        set_permissions(&config_dest, Permissions::from_mode(0o700)).with_context(|| {\n+            format!(\n+                \"setting file mode for Ignition directory {}\",\n+                config_dest.display()\n+            )\n+        })?;\n+    }\n \n     // do the copy\n     config_dest.push(\"config.ign\");\n@@ -262,6 +278,13 @@ fn write_ignition(\n                 config_dest.display()\n             )\n         })?;\n+    // Ignition config may contain secrets; restrict to root\n+    set_permissions(&config_dest, Permissions::from_mode(0o600)).with_context(|| {\n+        format!(\n+            \"setting file mode for destination Ignition config {}\",\n+            config_dest.display()\n+        )\n+    })?;\n     copy(&mut config_in, &mut config_out).context(\"writing Ignition config\")?;\n \n     Ok(())\n",
    "diff_parsed": "{'added': [(19, 'use std::fs::{'), (20, '    copy as fscopy, create_dir_all, read_dir, set_permissions, File, OpenOptions, Permissions,'), (21, '};'), (23, 'use std::os::unix::fs::{FileTypeExt, PermissionsExt};'), (253, '    if !config_dest.is_dir() {'), (254, '        create_dir_all(&config_dest).with_context(|| {'), (255, '            format!('), (256, '                \"creating Ignition config directory {}\",'), (257, '                config_dest.display()'), (258, '            )'), (259, '        })?;'), (261, '        set_permissions(&config_dest, Permissions::from_mode(0o700)).with_context(|| {'), (262, '            format!('), (263, '                \"setting file mode for Ignition directory {}\",'), (264, '                config_dest.display()'), (265, '            )'), (266, '        })?;'), (267, '    }'), (282, '    set_permissions(&config_dest, Permissions::from_mode(0o600)).with_context(|| {'), (283, '        format!('), (284, '            \"setting file mode for destination Ignition config {}\",'), (285, '            config_dest.display()'), (286, '        )'), (287, '    })?;')], 'deleted': [(19, 'use std::fs::{copy as fscopy, create_dir_all, read_dir, File, OpenOptions};'), (21, 'use std::os::unix::fs::FileTypeExt;'), (251, '    create_dir_all(&config_dest).context(\"creating Ignition config directory\")?;')]}",
    "num_lines_added": "24",
    "num_lines_deleted": "3",
    "nloc": "542"
  },
  {
    "file_change_id": "261395532360057",
    "hash": "e661a4940df78fbb7b52c622ac4ae6a3a7f7d8aa",
    "old_path": "src/daemon.rs",
    "new_path": "src/daemon.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -39,6 +39,7 @@ impl KeyboardState {\n #[tokio::main]\n async fn main() -> Result<(), Box<dyn std::error::Error>> {\n     let args = set_command_line_args().get_matches();\n+    let invoking_uid = env::var(\"PKEXEC_UID\").unwrap().parse::<u32>().unwrap();\n     env::set_var(\"RUST_LOG\", \"swhkd=warn\");\n \n     if args.is_present(\"debug\") {\n@@ -48,7 +49,7 @@ async fn main() -> Result<(), Box<dyn std::error::Error>> {\n     env_logger::init();\n     log::trace!(\"Logger initialized.\");\n \n-    let pidfile: String = String::from(\"/tmp/swhkd.pid\");\n+    let pidfile: String = String::from(format!(\"/etc/swhkd/runtime/swhkd_{}.pid\", invoking_uid));\n     if Path::new(&pidfile).exists() {\n         log::trace!(\"Reading {} file and checking for running instances.\", pidfile);\n         let swhkd_pid = match fs::read_to_string(&pidfile) {\n@@ -85,7 +86,7 @@ async fn main() -> Result<(), Box<dyn std::error::Error>> {\n     }\n \n     let load_config = || {\n-        seteuid(env::var(\"PKEXEC_UID\").unwrap().parse::<u32>().unwrap()); // Dropping privileges to invoking user.\n+        seteuid(invoking_uid); // Dropping privileges to invoking user.\n         let config_file_path: std::path::PathBuf = if args.is_present(\"config\") {\n             Path::new(args.value_of(\"config\").unwrap()).to_path_buf()\n         } else {\n",
    "diff_parsed": "{'added': [(42, '    let invoking_uid = env::var(\"PKEXEC_UID\").unwrap().parse::<u32>().unwrap();'), (52, '    let pidfile: String = String::from(format!(\"/etc/swhkd/runtime/swhkd_{}.pid\", invoking_uid));'), (89, '        seteuid(invoking_uid); // Dropping privileges to invoking user.')], 'deleted': [(51, '    let pidfile: String = String::from(\"/tmp/swhkd.pid\");'), (88, '        seteuid(env::var(\"PKEXEC_UID\").unwrap().parse::<u32>().unwrap()); // Dropping privileges to invoking user.')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "2",
    "nloc": "355"
  },
  {
    "file_change_id": "239716190217388",
    "hash": "c9ef5bd63cad5c0c123344c072b490a1a9bcbe1f",
    "old_path": "src/vtab/array.rs",
    "new_path": "src/vtab/array.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -71,7 +71,7 @@ struct ArrayTab {\n     base: ffi::sqlite3_vtab,\n }\n \n-impl VTab for ArrayTab {\n+unsafe impl VTab for ArrayTab {\n     type Aux = ();\n     type Cursor = ArrayTabCursor;\n \n@@ -149,7 +149,7 @@ impl ArrayTabCursor {\n         }\n     }\n }\n-impl VTabCursor for ArrayTabCursor {\n+unsafe impl VTabCursor for ArrayTabCursor {\n     fn filter(&mut self, idx_num: c_int, _idx_str: Option<&str>, args: &Values<'_>) -> Result<()> {\n         if idx_num > 0 {\n             self.ptr = args.get_array(0)?;\n",
    "diff_parsed": "{'added': [(74, 'unsafe impl VTab for ArrayTab {'), (152, 'unsafe impl VTabCursor for ArrayTabCursor {')], 'deleted': [(74, 'impl VTab for ArrayTab {'), (152, 'impl VTabCursor for ArrayTabCursor {')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "177"
  },
  {
    "file_change_id": "201051564762004",
    "hash": "c9ef5bd63cad5c0c123344c072b490a1a9bcbe1f",
    "old_path": "src/vtab/csvtab.rs",
    "new_path": "src/vtab/csvtab.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -95,7 +95,7 @@ impl CSVTab {\n     }\n }\n \n-impl VTab for CSVTab {\n+unsafe impl VTab for CSVTab {\n     type Aux = ();\n     type Cursor = CSVTabCursor;\n \n@@ -296,7 +296,7 @@ impl CSVTabCursor {\n     }\n }\n \n-impl VTabCursor for CSVTabCursor {\n+unsafe impl VTabCursor for CSVTabCursor {\n     // Only a full table scan is supported.  So `filter` simply rewinds to\n     // the beginning.\n     fn filter(\n",
    "diff_parsed": "{'added': [(98, 'unsafe impl VTab for CSVTab {'), (299, 'unsafe impl VTabCursor for CSVTabCursor {')], 'deleted': [(98, 'impl VTab for CSVTab {'), (299, 'impl VTabCursor for CSVTabCursor {')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "341"
  },
  {
    "file_change_id": "191617855618579",
    "hash": "c9ef5bd63cad5c0c123344c072b490a1a9bcbe1f",
    "old_path": "src/vtab/mod.rs",
    "new_path": "src/vtab/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -189,7 +189,11 @@ impl VTabConnection {\n \n /// `feature = \"vtab\"` Virtual table instance trait.\n ///\n-/// Implementations must be like:\n+/// # Safety\n+///\n+/// The first item in a struct implementing VTab must be\n+/// `rusqlite::sqlite3_vtab`, and the struct must be `#[repr(C)]`.\n+///\n /// ```rust,ignore\n /// #[repr(C)]\n /// struct MyTab {\n@@ -200,7 +204,7 @@ impl VTabConnection {\n /// ```\n ///\n /// (See [SQLite doc](https://sqlite.org/c3ref/vtab.html))\n-pub trait VTab: Sized {\n+pub unsafe trait VTab: Sized {\n     type Aux;\n     type Cursor: VTabCursor;\n \n@@ -465,7 +469,7 @@ impl OrderBy<'_> {\n /// ```\n ///\n /// (See [SQLite doc](https://sqlite.org/c3ref/vtab_cursor.html))\n-pub trait VTabCursor: Sized {\n+pub unsafe trait VTabCursor: Sized {\n     /// Begin a search of a virtual table.\n     /// (See [SQLite doc](https://sqlite.org/vtab.html#the_xfilter_method))\n     fn filter(&mut self, idx_num: c_int, idx_str: Option<&str>, args: &Values<'_>) -> Result<()>;\n",
    "diff_parsed": "{'added': [(207, 'pub unsafe trait VTab: Sized {'), (472, 'pub unsafe trait VTabCursor: Sized {')], 'deleted': [(203, 'pub trait VTab: Sized {'), (468, 'pub trait VTabCursor: Sized {')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "861"
  },
  {
    "file_change_id": "126427080484839",
    "hash": "c9ef5bd63cad5c0c123344c072b490a1a9bcbe1f",
    "old_path": "src/vtab/series.rs",
    "new_path": "src/vtab/series.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -49,7 +49,7 @@ struct SeriesTab {\n     base: ffi::sqlite3_vtab,\n }\n \n-impl VTab for SeriesTab {\n+unsafe impl VTab for SeriesTab {\n     type Aux = ();\n     type Cursor = SeriesTabCursor;\n \n@@ -181,7 +181,7 @@ impl SeriesTabCursor {\n         SeriesTabCursor::default()\n     }\n }\n-impl VTabCursor for SeriesTabCursor {\n+unsafe impl VTabCursor for SeriesTabCursor {\n     fn filter(&mut self, idx_num: c_int, _idx_str: Option<&str>, args: &Values<'_>) -> Result<()> {\n         let idx_num = QueryPlanFlags::from_bits_truncate(idx_num);\n         let mut i = 0;\n",
    "diff_parsed": "{'added': [(52, 'unsafe impl VTab for SeriesTab {'), (184, 'unsafe impl VTabCursor for SeriesTabCursor {')], 'deleted': [(52, 'impl VTab for SeriesTab {'), (184, 'impl VTabCursor for SeriesTabCursor {')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "237"
  },
  {
    "file_change_id": "92745574425821",
    "hash": "da7904c04f82e1cb43cc42eaf6a1dba072b5c921",
    "old_path": "lib/extensions/serve_static.rs",
    "new_path": "lib/extensions/serve_static.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -320,7 +320,7 @@ impl ServeStatic {\n fn process_req(req: Request, cell: &RwLock<ServeStatic>) -> (Response, bool) {\n     let this = cell.read().unwrap();\n \n-    let mut path = format!(\"{}{}\", this.data_dir, req.path.replace(\"/..\", \"\"));\n+    let mut path = safe_path(req.path.to_owned());\n \n     // Add Index.html if path ends with /\n     if path.ends_with('/') {\n@@ -364,6 +364,14 @@ fn get_type(path: &str, types: &[(String, String)]) -> String {\n     \"application/octet-stream\".to_owned()\n }\n \n+#[inline]\n+fn safe_path(mut path: String) -> String {\n+    while path.contains(\"/..\") {\n+        path = path.replace(\"/..\", \"\");\n+    }\n+    path\n+}\n+\n /// Common MIME Types\n ///\n /// Used by Servestatic Extentions\n",
    "diff_parsed": "{'added': [(323, '    let mut path = safe_path(req.path.to_owned());'), (367, '#[inline]'), (368, 'fn safe_path(mut path: String) -> String {'), (369, '    while path.contains(\"/..\") {'), (370, '        path = path.replace(\"/..\", \"\");'), (371, '    }'), (372, '    path'), (373, '}')], 'deleted': [(323, '    let mut path = format!(\"{}{}\", this.data_dir, req.path.replace(\"/..\", \"\"));')]}",
    "num_lines_added": "8",
    "num_lines_deleted": "1",
    "nloc": "202"
  },
  {
    "file_change_id": "209554123423780",
    "hash": "0b620a09605afb815c6d8d8953bbb7a10a8c0575",
    "old_path": "src/server.rs",
    "new_path": "src/server.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -12,7 +12,7 @@ fn main() -> std::io::Result<()> {\n     env::set_var(\"RUST_LOG\", \"swhks=trace\");\n     env_logger::init();\n \n-    let pid_file_path = String::from(\"/tmp/swhks.pid\");\n+    let pid_file_path = String::from(format!(\"/run/user/{}/swhks.pid\", unistd::Uid::current()));\n     let sock_file_path = String::from(format!(\"/run/user/{}/swhkd.sock\", unistd::Uid::current()));\n \n     if Path::new(&pid_file_path).exists() {\n",
    "diff_parsed": "{'added': [(15, '    let pid_file_path = String::from(format!(\"/run/user/{}/swhks.pid\", unistd::Uid::current()));')], 'deleted': [(15, '    let pid_file_path = String::from(\"/tmp/swhks.pid\");')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "82"
  },
  {
    "file_change_id": "231473489100497",
    "hash": "8a93fdc6c9f4eb1d2f2a11b7ff1d12d70bf5a664",
    "old_path": "frame/evm/precompile/modexp/src/lib.rs",
    "new_path": "frame/evm/precompile/modexp/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -47,7 +47,10 @@ fn calculate_gas_cost(\n \t\t\twords += 1;\n \t\t}\n \n-\t\t// TODO: prevent/handle overflow\n+\t\t// Note: can't overflow because we take words to be some u64 value / 8, which is\n+\t\t// necessarily less than sqrt(u64::MAX).\n+\t\t// Additionally, both base_length and mod_length are bounded to 1024, so this has\n+\t\t// an upper bound of roughly (1024 / 8) squared\n \t\twords * words\n \t}\n \n@@ -63,8 +66,17 @@ fn calculate_gas_cost(\n \t\t\tlet bytes: [u8; 32] = [0xFF; 32];\n \t\t\tlet max_256_bit_uint = BigUint::from_bytes_be(&bytes);\n \n+\t\t\t// from the EIP spec:\n+\t\t\t// (8 * (exp_length - 32)) + ((exponent & (2**256 - 1)).bit_length() - 1)\n+\t\t\t//\n+\t\t\t// Notes:\n+\t\t\t// * exp_length is bounded to 1024 and is > 32\n+\t\t\t// * exponent can be zero, so we subtract 1 after adding the other terms (whose sum\n+\t\t\t//   must be > 0)\n+\t\t\t// * the addition can't overflow because the terms are both capped at roughly\n+\t\t\t//   8 * max size of exp_length (1024)\n \t\t\titeration_count =\n-\t\t\t\t(8 * (exp_length - 32)) + ((exponent.bitand(max_256_bit_uint)).bits() - 1);\n+\t\t\t\t(8 * (exp_length - 32)) + exponent.bitand(max_256_bit_uint).bits() - 1;\n \t\t}\n \n \t\tmax(iteration_count, 1)\n@@ -89,7 +101,7 @@ fn calculate_gas_cost(\n // 6) modulus, size as described above\n //\n //\n-// NOTE: input sizes are arbitrarily large (up to 256 bits), with the expectation\n+// NOTE: input sizes are bound to 1024 bytes, with the expectation\n //       that gas limits would be applied before actual computation.\n //\n //       maximum stack size will also prevent abuse.\n@@ -133,7 +145,7 @@ impl Precompile for Modexp {\n \t\tlet mod_len_big = BigUint::from_bytes_be(&buf);\n \t\tif mod_len_big > max_size_big {\n \t\t\treturn Err(PrecompileFailure::Error {\n-\t\t\t\texit_status: ExitError::Other(\"unreasonably large exponent length\".into()),\n+\t\t\t\texit_status: ExitError::Other(\"unreasonably large modulus length\".into()),\n \t\t\t});\n \t\t}\n \n@@ -162,7 +174,6 @@ impl Precompile for Modexp {\n \t\t\tlet exponent = BigUint::from_bytes_be(&input[exp_start..exp_start + exp_len]);\n \n \t\t\t// do our gas accounting\n-\t\t\t// TODO: we could technically avoid reading base first...\n \t\t\tlet gas_cost =\n \t\t\t\tcalculate_gas_cost(base_len as u64, exp_len as u64, mod_len as u64, &exponent);\n \t\t\tif let Some(gas_left) = target_gas {\n@@ -423,4 +434,39 @@ mod tests {\n \t\t\t}\n \t\t}\n \t}\n+\n+\t#[test]\n+\tfn test_zero_exp_with_33_length() {\n+\t\t// This is a regression test which ensures that the 'iteration_count' calculation\n+\t\t// in 'calculate_iteration_count' cannot underflow.\n+\t\t//\n+\t\t// In debug mode, this underflow could cause a panic. Otherwise, it causes N**0 to\n+\t\t// be calculated at more-than-normal expense.\n+\t\t//\n+\t\t// TODO: cite security advisory\n+\n+\t\tlet input = vec![\n+\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t\t0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t\t0, 0, 0, 0, 0, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,\n+\t\t];\n+\n+\t\tlet cost: u64 = 100000;\n+\n+\t\tlet context: Context = Context {\n+\t\t\taddress: Default::default(),\n+\t\t\tcaller: Default::default(),\n+\t\t\tapparent_value: From::from(0),\n+\t\t};\n+\n+\t\tlet precompile_result = Modexp::execute(&input, Some(cost), &context, false)\n+\t\t\t.expect(\"Modexp::execute() returned error\");\n+\n+\t\tassert_eq!(precompile_result.output.len(), 1); // should be same length as mod\n+\t\tlet result = BigUint::from_bytes_be(&precompile_result.output[..]);\n+\t\tlet expected = BigUint::parse_bytes(b\"0\", 10).unwrap();\n+\t\tassert_eq!(result, expected);\n+\t}\n }\n",
    "diff_parsed": "{'added': [(79, '\\t\\t\\t\\t(8 * (exp_length - 32)) + exponent.bitand(max_256_bit_uint).bits() - 1;'), (148, '\\t\\t\\t\\texit_status: ExitError::Other(\"unreasonably large modulus length\".into()),'), (438, '\\t#[test]'), (439, '\\tfn test_zero_exp_with_33_length() {'), (448, '\\t\\tlet input = vec!['), (449, '\\t\\t\\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,'), (450, '\\t\\t\\t0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,'), (451, '\\t\\t\\t0, 0, 0, 0, 0, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,'), (452, '\\t\\t\\t0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,'), (453, '\\t\\t\\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,'), (454, '\\t\\t];'), (456, '\\t\\tlet cost: u64 = 100000;'), (458, '\\t\\tlet context: Context = Context {'), (459, '\\t\\t\\taddress: Default::default(),'), (460, '\\t\\t\\tcaller: Default::default(),'), (461, '\\t\\t\\tapparent_value: From::from(0),'), (462, '\\t\\t};'), (464, '\\t\\tlet precompile_result = Modexp::execute(&input, Some(cost), &context, false)'), (465, '\\t\\t\\t.expect(\"Modexp::execute() returned error\");'), (467, '\\t\\tassert_eq!(precompile_result.output.len(), 1); // should be same length as mod'), (468, '\\t\\tlet result = BigUint::from_bytes_be(&precompile_result.output[..]);'), (469, '\\t\\tlet expected = BigUint::parse_bytes(b\"0\", 10).unwrap();'), (470, '\\t\\tassert_eq!(result, expected);'), (471, '\\t}')], 'deleted': [(67, '\\t\\t\\t\\t(8 * (exp_length - 32)) + ((exponent.bitand(max_256_bit_uint)).bits() - 1);'), (136, '\\t\\t\\t\\texit_status: ExitError::Other(\"unreasonably large exponent length\".into()),')]}",
    "num_lines_added": "24",
    "num_lines_deleted": "2",
    "nloc": "344"
  },
  {
    "file_change_id": "230691526590163",
    "hash": "f70b99dd575fab79d8a942111a6980431f006818",
    "old_path": "src/daemon.rs",
    "new_path": "src/daemon.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -94,11 +94,6 @@ async fn main() -> Result<(), Box<dyn std::error::Error>> {\n \n         log::debug!(\"Using config file path: {:#?}\", config_file_path);\n \n-        if !config_file_path.exists() {\n-            log::error!(\"{:#?} doesn't exist\", config_file_path);\n-            exit(1);\n-        }\n-\n         let hotkeys = match config::load(&config_file_path) {\n             Err(e) => {\n                 log::error!(\"Config Error: {}\", e);\n@@ -319,7 +314,9 @@ async fn main() -> Result<(), Box<dyn std::error::Error>> {\n }\n \n fn sock_send(command: &str) -> std::io::Result<()> {\n-    let mut stream = UnixStream::connect(\"/tmp/swhkd.sock\")?;\n+    let sock_file_path =\n+        String::from(format!(\"/run/user/{}/swhkd.sock\", env::var(\"PKEXEC_UID\").unwrap()));\n+    let mut stream = UnixStream::connect(sock_file_path)?;\n     stream.write_all(command.as_bytes())?;\n     Ok(())\n }\n@@ -402,11 +399,11 @@ pub fn fetch_xdg_config_path() -> std::path::PathBuf {\n }\n \n pub fn seteuid(uid: u32) {\n-    let uid = nix::unistd::Uid::from_raw(uid);\n+    let uid = Uid::from_raw(uid);\n     match nix::unistd::seteuid(uid) {\n         Ok(_) => log::debug!(\"Dropping privileges...\"),\n         Err(e) => {\n-            log::error!(\"Failed to set UID: {:#?}\", e);\n+            log::error!(\"Failed to set EUID: {:#?}\", e);\n             exit(1);\n         }\n     }\n",
    "diff_parsed": "{'added': [(317, '    let sock_file_path ='), (318, '        String::from(format!(\"/run/user/{}/swhkd.sock\", env::var(\"PKEXEC_UID\").unwrap()));'), (319, '    let mut stream = UnixStream::connect(sock_file_path)?;'), (402, '    let uid = Uid::from_raw(uid);'), (406, '            log::error!(\"Failed to set EUID: {:#?}\", e);')], 'deleted': [(97, '        if !config_file_path.exists() {'), (98, '            log::error!(\"{:#?} doesn\\'t exist\", config_file_path);'), (99, '            exit(1);'), (100, '        }'), (322, '    let mut stream = UnixStream::connect(\"/tmp/swhkd.sock\")?;'), (405, '    let uid = nix::unistd::Uid::from_raw(uid);'), (409, '            log::error!(\"Failed to set UID: {:#?}\", e);')]}",
    "num_lines_added": "5",
    "num_lines_deleted": "7",
    "nloc": "354"
  },
  {
    "file_change_id": "120277155620859",
    "hash": "f70b99dd575fab79d8a942111a6980431f006818",
    "old_path": "src/server.rs",
    "new_path": "src/server.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,3 +1,4 @@\n+use nix::unistd;\n use std::io::prelude::*;\n use std::os::unix::net::UnixListener;\n use std::{\n@@ -12,7 +13,7 @@ fn main() -> std::io::Result<()> {\n     env_logger::init();\n \n     let pid_file_path = String::from(\"/tmp/swhks.pid\");\n-    let sock_file_path = String::from(\"/tmp/swhkd.sock\");\n+    let sock_file_path = String::from(format!(\"/run/user/{}/swhkd.sock\", unistd::Uid::current()));\n \n     if Path::new(&pid_file_path).exists() {\n         log::trace!(\"Reading {} file and checking for running instances.\", pid_file_path);\n",
    "diff_parsed": "{'added': [(1, 'use nix::unistd;'), (16, '    let sock_file_path = String::from(format!(\"/run/user/{}/swhkd.sock\", unistd::Uid::current()));')], 'deleted': [(15, '    let sock_file_path = String::from(\"/tmp/swhkd.sock\");')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "1",
    "nloc": "82"
  },
  {
    "file_change_id": "83030822254577",
    "hash": "49b43f277afb1caf5104fcbe02bef581f7444686",
    "old_path": "src/socket.rs",
    "new_path": "src/socket.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -32,7 +32,7 @@ impl Socket {\n     pub fn bind(&self, addr: &SocketAddr) -> io::Result<()> {\n         let (addr, len) = addr2raw(addr);\n         unsafe {\n-            ::cvt(c::bind(self.inner.raw(), addr, len as c::socklen_t)).map(|_| ())\n+            ::cvt(c::bind(self.inner.raw(), addr.as_ptr(), len as c::socklen_t)).map(|_| ())\n         }\n     }\n \n@@ -45,7 +45,7 @@ impl Socket {\n     pub fn connect(&self, addr: &SocketAddr) -> io::Result<()> {\n         let (addr, len) = addr2raw(addr);\n         unsafe {\n-            ::cvt(c::connect(self.inner.raw(), addr, len)).map(|_| ())\n+            ::cvt(c::connect(self.inner.raw(), addr.as_ptr(), len)).map(|_| ())\n         }\n     }\n \n@@ -84,17 +84,130 @@ impl ::IntoInner for Socket {\n     fn into_inner(self) -> sys::Socket { self.inner }\n }\n \n-fn addr2raw(addr: &SocketAddr) -> (*const c::sockaddr, c::socklen_t) {\n-    match *addr {\n-        SocketAddr::V4(ref a) => {\n-            (a as *const _ as *const _, mem::size_of_val(a) as c::socklen_t)\n-        }\n-        SocketAddr::V6(ref a) => {\n-            (a as *const _ as *const _, mem::size_of_val(a) as c::socklen_t)\n-        }\n+/// A type with the same memory layout as `c::sockaddr`. Used in converting Rust level\n+/// SocketAddr* types into their system representation. The benefit of this specific\n+/// type over using `c::sockaddr_storage` is that this type is exactly as large as it\n+/// needs to be and not a lot larger.\n+#[repr(C)]\n+pub(crate) union SocketAddrCRepr {\n+    v4: c::sockaddr_in,\n+    v6: c::sockaddr_in6,\n+}\n+\n+impl SocketAddrCRepr {\n+    pub(crate) fn as_ptr(&self) -> *const c::sockaddr {\n+        self as *const _ as *const c::sockaddr\n     }\n }\n \n+fn addr2raw(addr: &SocketAddr) -> (SocketAddrCRepr, c::socklen_t) {\n+    match addr {\n+        &SocketAddr::V4(ref v4) => addr2raw_v4(v4),\n+        &SocketAddr::V6(ref v6) => addr2raw_v6(v6),\n+    }\n+}\n+\n+#[cfg(unix)]\n+fn addr2raw_v4(addr: &SocketAddrV4) -> (SocketAddrCRepr, c::socklen_t) {\n+    let sin_addr = c::in_addr {\n+        s_addr: u32::from(*addr.ip()).to_be(),\n+    };\n+\n+    let sockaddr = SocketAddrCRepr {\n+        v4: c::sockaddr_in {\n+            sin_family: c::AF_INET as c::sa_family_t,\n+            sin_port: addr.port().to_be(),\n+            sin_addr,\n+            sin_zero: [0; 8],\n+            #[cfg(any(\n+                target_os = \"dragonfly\",\n+                target_os = \"freebsd\",\n+                target_os = \"ios\",\n+                target_os = \"macos\",\n+                target_os = \"netbsd\",\n+                target_os = \"openbsd\"\n+            ))]\n+            sin_len: 0,\n+        },\n+    };\n+    (sockaddr, mem::size_of::<c::sockaddr_in>() as c::socklen_t)\n+}\n+\n+#[cfg(windows)]\n+fn addr2raw_v4(addr: &SocketAddrV4) -> (SocketAddrCRepr, c::socklen_t) {\n+    let sin_addr = unsafe {\n+        let mut s_un = mem::zeroed::<c::in_addr_S_un>();\n+        *s_un.S_addr_mut() = u32::from(*addr.ip()).to_be();\n+        c::IN_ADDR { S_un: s_un }\n+    };\n+\n+    let sockaddr = SocketAddrCRepr {\n+        v4: c::sockaddr_in {\n+            sin_family: c::AF_INET as c::sa_family_t,\n+            sin_port: addr.port().to_be(),\n+            sin_addr,\n+            sin_zero: [0; 8],\n+        },\n+    };\n+    (sockaddr, mem::size_of::<c::sockaddr_in>() as c::socklen_t)\n+}\n+\n+#[cfg(unix)]\n+fn addr2raw_v6(addr: &SocketAddrV6) -> (SocketAddrCRepr, c::socklen_t) {\n+    let sin6_addr = {\n+        let mut sin6_addr = unsafe { mem::zeroed::<c::in6_addr>() };\n+        sin6_addr.s6_addr = addr.ip().octets();\n+        sin6_addr\n+    };\n+\n+    let sockaddr = SocketAddrCRepr {\n+        v6: c::sockaddr_in6 {\n+            sin6_family: c::AF_INET6 as c::sa_family_t,\n+            sin6_port: addr.port().to_be(),\n+            sin6_addr,\n+            sin6_flowinfo: addr.flowinfo(),\n+            sin6_scope_id: addr.scope_id(),\n+            #[cfg(any(\n+                target_os = \"dragonfly\",\n+                target_os = \"freebsd\",\n+                target_os = \"ios\",\n+                target_os = \"macos\",\n+                target_os = \"netbsd\",\n+                target_os = \"openbsd\"\n+            ))]\n+            sin6_len: 0,\n+            #[cfg(any(target_os = \"solaris\", target_os = \"illumos\"))]\n+            __sin6_src_id: 0,\n+        },\n+    };\n+    (sockaddr, mem::size_of::<c::sockaddr_in6>() as c::socklen_t)\n+}\n+\n+#[cfg(windows)]\n+fn addr2raw_v6(addr: &SocketAddrV6) -> (SocketAddrCRepr, c::socklen_t) {\n+    let sin6_addr = unsafe {\n+        let mut u = mem::zeroed::<c::in6_addr_u>();\n+        *u.Byte_mut() = addr.ip().octets();\n+        c::IN6_ADDR { u }\n+    };\n+    let scope_id = unsafe {\n+        let mut u = mem::zeroed::<c::SOCKADDR_IN6_LH_u>();\n+        *u.sin6_scope_id_mut() = addr.scope_id();\n+        u\n+    };\n+\n+    let sockaddr = SocketAddrCRepr {\n+        v6: c::sockaddr_in6 {\n+            sin6_family: c::AF_INET6 as c::sa_family_t,\n+            sin6_port: addr.port().to_be(),\n+            sin6_addr,\n+            sin6_flowinfo: addr.flowinfo(),\n+            u: scope_id,\n+        },\n+    };\n+    (sockaddr, mem::size_of::<c::sockaddr_in6>() as c::socklen_t)\n+}\n+\n fn raw2addr(storage: &c::sockaddr_storage, len: c::socklen_t) -> io::Result<SocketAddr> {\n     match storage.ss_family as c_int {\n         c::AF_INET => {\n",
    "diff_parsed": "{'added': [(35, '            ::cvt(c::bind(self.inner.raw(), addr.as_ptr(), len as c::socklen_t)).map(|_| ())'), (48, '            ::cvt(c::connect(self.inner.raw(), addr.as_ptr(), len)).map(|_| ())'), (91, '#[repr(C)]'), (92, 'pub(crate) union SocketAddrCRepr {'), (93, '    v4: c::sockaddr_in,'), (94, '    v6: c::sockaddr_in6,'), (95, '}'), (97, 'impl SocketAddrCRepr {'), (98, '    pub(crate) fn as_ptr(&self) -> *const c::sockaddr {'), (99, '        self as *const _ as *const c::sockaddr'), (103, 'fn addr2raw(addr: &SocketAddr) -> (SocketAddrCRepr, c::socklen_t) {'), (104, '    match addr {'), (105, '        &SocketAddr::V4(ref v4) => addr2raw_v4(v4),'), (106, '        &SocketAddr::V6(ref v6) => addr2raw_v6(v6),'), (107, '    }'), (108, '}'), (110, '#[cfg(unix)]'), (111, 'fn addr2raw_v4(addr: &SocketAddrV4) -> (SocketAddrCRepr, c::socklen_t) {'), (112, '    let sin_addr = c::in_addr {'), (113, '        s_addr: u32::from(*addr.ip()).to_be(),'), (114, '    };'), (116, '    let sockaddr = SocketAddrCRepr {'), (117, '        v4: c::sockaddr_in {'), (118, '            sin_family: c::AF_INET as c::sa_family_t,'), (119, '            sin_port: addr.port().to_be(),'), (120, '            sin_addr,'), (121, '            sin_zero: [0; 8],'), (122, '            #[cfg(any('), (123, '                target_os = \"dragonfly\",'), (124, '                target_os = \"freebsd\",'), (125, '                target_os = \"ios\",'), (126, '                target_os = \"macos\",'), (127, '                target_os = \"netbsd\",'), (128, '                target_os = \"openbsd\"'), (129, '            ))]'), (130, '            sin_len: 0,'), (131, '        },'), (132, '    };'), (133, '    (sockaddr, mem::size_of::<c::sockaddr_in>() as c::socklen_t)'), (134, '}'), (136, '#[cfg(windows)]'), (137, 'fn addr2raw_v4(addr: &SocketAddrV4) -> (SocketAddrCRepr, c::socklen_t) {'), (138, '    let sin_addr = unsafe {'), (139, '        let mut s_un = mem::zeroed::<c::in_addr_S_un>();'), (140, '        *s_un.S_addr_mut() = u32::from(*addr.ip()).to_be();'), (141, '        c::IN_ADDR { S_un: s_un }'), (142, '    };'), (144, '    let sockaddr = SocketAddrCRepr {'), (145, '        v4: c::sockaddr_in {'), (146, '            sin_family: c::AF_INET as c::sa_family_t,'), (147, '            sin_port: addr.port().to_be(),'), (148, '            sin_addr,'), (149, '            sin_zero: [0; 8],'), (150, '        },'), (151, '    };'), (152, '    (sockaddr, mem::size_of::<c::sockaddr_in>() as c::socklen_t)'), (153, '}'), (155, '#[cfg(unix)]'), (156, 'fn addr2raw_v6(addr: &SocketAddrV6) -> (SocketAddrCRepr, c::socklen_t) {'), (157, '    let sin6_addr = {'), (158, '        let mut sin6_addr = unsafe { mem::zeroed::<c::in6_addr>() };'), (159, '        sin6_addr.s6_addr = addr.ip().octets();'), (160, '        sin6_addr'), (161, '    };'), (163, '    let sockaddr = SocketAddrCRepr {'), (164, '        v6: c::sockaddr_in6 {'), (165, '            sin6_family: c::AF_INET6 as c::sa_family_t,'), (166, '            sin6_port: addr.port().to_be(),'), (167, '            sin6_addr,'), (168, '            sin6_flowinfo: addr.flowinfo(),'), (169, '            sin6_scope_id: addr.scope_id(),'), (170, '            #[cfg(any('), (171, '                target_os = \"dragonfly\",'), (172, '                target_os = \"freebsd\",'), (173, '                target_os = \"ios\",'), (174, '                target_os = \"macos\",'), (175, '                target_os = \"netbsd\",'), (176, '                target_os = \"openbsd\"'), (177, '            ))]'), (178, '            sin6_len: 0,'), (179, '            #[cfg(any(target_os = \"solaris\", target_os = \"illumos\"))]'), (180, '            __sin6_src_id: 0,'), (181, '        },'), (182, '    };'), (183, '    (sockaddr, mem::size_of::<c::sockaddr_in6>() as c::socklen_t)'), (184, '}'), (186, '#[cfg(windows)]'), (187, 'fn addr2raw_v6(addr: &SocketAddrV6) -> (SocketAddrCRepr, c::socklen_t) {'), (188, '    let sin6_addr = unsafe {'), (189, '        let mut u = mem::zeroed::<c::in6_addr_u>();'), (190, '        *u.Byte_mut() = addr.ip().octets();'), (191, '        c::IN6_ADDR { u }'), (192, '    };'), (193, '    let scope_id = unsafe {'), (194, '        let mut u = mem::zeroed::<c::SOCKADDR_IN6_LH_u>();'), (195, '        *u.sin6_scope_id_mut() = addr.scope_id();'), (196, '        u'), (197, '    };'), (199, '    let sockaddr = SocketAddrCRepr {'), (200, '        v6: c::sockaddr_in6 {'), (201, '            sin6_family: c::AF_INET6 as c::sa_family_t,'), (202, '            sin6_port: addr.port().to_be(),'), (203, '            sin6_addr,'), (204, '            sin6_flowinfo: addr.flowinfo(),'), (205, '            u: scope_id,'), (206, '        },'), (207, '    };'), (208, '    (sockaddr, mem::size_of::<c::sockaddr_in6>() as c::socklen_t)'), (209, '}')], 'deleted': [(35, '            ::cvt(c::bind(self.inner.raw(), addr, len as c::socklen_t)).map(|_| ())'), (48, '            ::cvt(c::connect(self.inner.raw(), addr, len)).map(|_| ())'), (87, 'fn addr2raw(addr: &SocketAddr) -> (*const c::sockaddr, c::socklen_t) {'), (88, '    match *addr {'), (89, '        SocketAddr::V4(ref a) => {'), (90, '            (a as *const _ as *const _, mem::size_of_val(a) as c::socklen_t)'), (91, '        }'), (92, '        SocketAddr::V6(ref a) => {'), (93, '            (a as *const _ as *const _, mem::size_of_val(a) as c::socklen_t)'), (94, '        }')]}",
    "num_lines_added": "109",
    "num_lines_deleted": "10",
    "nloc": "214"
  },
  {
    "file_change_id": "268121159312258",
    "hash": "49b43f277afb1caf5104fcbe02bef581f7444686",
    "old_path": "src/sys/windows/mod.rs",
    "new_path": "src/sys/windows/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -34,6 +34,7 @@ pub mod c {\n     pub use winapi::shared::ws2def::SOCKADDR as sockaddr;\n     pub use winapi::shared::ws2def::SOCKADDR_STORAGE as sockaddr_storage;\n     pub use winapi::shared::ws2def::SOCKADDR_IN as sockaddr_in;\n+    pub use winapi::shared::ws2def::ADDRESS_FAMILY as sa_family_t;\n     pub use winapi::shared::ws2ipdef::*;\n     pub use winapi::shared::ws2ipdef::SOCKADDR_IN6_LH as sockaddr_in6;\n     pub use winapi::shared::ws2ipdef::IP_MREQ as ip_mreq;\n",
    "diff_parsed": "{'added': [(37, '    pub use winapi::shared::ws2def::ADDRESS_FAMILY as sa_family_t;')], 'deleted': []}",
    "num_lines_added": "1",
    "num_lines_deleted": "0",
    "nloc": "92"
  },
  {
    "file_change_id": "7693934157709",
    "hash": "d90a02f582c03dfa0fd11c78d608d0974625ae5d",
    "old_path": "src/entry.rs",
    "new_path": "src/entry.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -413,11 +413,8 @@ impl<'a> EntryFields<'a> {\n             None => return Ok(false),\n         };\n \n-        if parent.symlink_metadata().is_err() {\n-            fs::create_dir_all(&parent).map_err(|e| {\n-                TarError::new(&format!(\"failed to create `{}`\", parent.display()), e)\n-            })?;\n-        }\n+        self.ensure_dir_created(&dst, parent)\n+            .map_err(|e| TarError::new(&format!(\"failed to create `{}`\", parent.display()), e))?;\n \n         let canon_target = self.validate_inside_dst(&dst, parent)?;\n \n@@ -761,6 +758,26 @@ impl<'a> EntryFields<'a> {\n         }\n     }\n \n+    fn ensure_dir_created(&self, dst: &Path, dir: &Path) -> io::Result<()> {\n+        let mut ancestor = dir;\n+        let mut dirs_to_create = Vec::new();\n+        while ancestor.symlink_metadata().is_err() {\n+            dirs_to_create.push(ancestor);\n+            if let Some(parent) = ancestor.parent() {\n+                ancestor = parent;\n+            } else {\n+                break;\n+            }\n+        }\n+        for ancestor in dirs_to_create.into_iter().rev() {\n+            if let Some(parent) = ancestor.parent() {\n+                self.validate_inside_dst(dst, parent)?;\n+            }\n+            fs::create_dir(ancestor)?;\n+        }\n+        Ok(())\n+    }\n+\n     fn validate_inside_dst(&self, dst: &Path, file_dst: &Path) -> io::Result<PathBuf> {\n         // Abort if target (canonical) parent is outside of `dst`\n         let canon_parent = file_dst.canonicalize().map_err(|err| {\n",
    "diff_parsed": "{'added': [(416, '        self.ensure_dir_created(&dst, parent)'), (417, '            .map_err(|e| TarError::new(&format!(\"failed to create `{}`\", parent.display()), e))?;'), (761, '    fn ensure_dir_created(&self, dst: &Path, dir: &Path) -> io::Result<()> {'), (762, '        let mut ancestor = dir;'), (763, '        let mut dirs_to_create = Vec::new();'), (764, '        while ancestor.symlink_metadata().is_err() {'), (765, '            dirs_to_create.push(ancestor);'), (766, '            if let Some(parent) = ancestor.parent() {'), (767, '                ancestor = parent;'), (768, '            } else {'), (769, '                break;'), (770, '            }'), (771, '        }'), (772, '        for ancestor in dirs_to_create.into_iter().rev() {'), (773, '            if let Some(parent) = ancestor.parent() {'), (774, '                self.validate_inside_dst(dst, parent)?;'), (775, '            }'), (776, '            fs::create_dir(ancestor)?;'), (777, '        }'), (778, '        Ok(())'), (779, '    }')], 'deleted': [(416, '        if parent.symlink_metadata().is_err() {'), (417, '            fs::create_dir_all(&parent).map_err(|e| {'), (418, '                TarError::new(&format!(\"failed to create `{}`\", parent.display()), e)'), (419, '            })?;'), (420, '        }')]}",
    "num_lines_added": "21",
    "num_lines_deleted": "5",
    "nloc": "602"
  },
  {
    "file_change_id": "3121604933755",
    "hash": "d90a02f582c03dfa0fd11c78d608d0974625ae5d",
    "old_path": "tests/entry.rs",
    "new_path": "tests/entry.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,7 +1,7 @@\n extern crate tar;\n extern crate tempfile;\n \n-use std::fs::File;\n+use std::fs::{create_dir, File};\n use std::io::Read;\n \n use tempfile::Builder;\n@@ -219,6 +219,36 @@ fn modify_link_just_created() {\n     t!(File::open(td.path().join(\"foo/bar\")));\n }\n \n+#[test]\n+#[cfg(not(windows))] // dangling symlinks have weird permissions\n+fn modify_outside_with_relative_symlink() {\n+    let mut ar = tar::Builder::new(Vec::new());\n+\n+    let mut header = tar::Header::new_gnu();\n+    header.set_size(0);\n+    header.set_entry_type(tar::EntryType::Symlink);\n+    t!(header.set_path(\"symlink\"));\n+    t!(header.set_link_name(\"..\"));\n+    header.set_cksum();\n+    t!(ar.append(&header, &[][..]));\n+\n+    let mut header = tar::Header::new_gnu();\n+    header.set_size(0);\n+    header.set_entry_type(tar::EntryType::Regular);\n+    t!(header.set_path(\"symlink/foo/bar\"));\n+    header.set_cksum();\n+    t!(ar.append(&header, &[][..]));\n+\n+    let bytes = t!(ar.into_inner());\n+    let mut ar = tar::Archive::new(&bytes[..]);\n+\n+    let td = t!(Builder::new().prefix(\"tar\").tempdir());\n+    let tar_dir = td.path().join(\"tar\");\n+    create_dir(&tar_dir).unwrap();\n+    assert!(ar.unpack(tar_dir).is_err());\n+    assert!(!td.path().join(\"foo\").exists());\n+}\n+\n #[test]\n fn parent_paths_error() {\n     let mut ar = tar::Builder::new(Vec::new());\n",
    "diff_parsed": "{'added': [(4, 'use std::fs::{create_dir, File};'), (222, '#[test]'), (223, '#[cfg(not(windows))] // dangling symlinks have weird permissions'), (224, 'fn modify_outside_with_relative_symlink() {'), (225, '    let mut ar = tar::Builder::new(Vec::new());'), (227, '    let mut header = tar::Header::new_gnu();'), (228, '    header.set_size(0);'), (229, '    header.set_entry_type(tar::EntryType::Symlink);'), (230, '    t!(header.set_path(\"symlink\"));'), (231, '    t!(header.set_link_name(\"..\"));'), (232, '    header.set_cksum();'), (233, '    t!(ar.append(&header, &[][..]));'), (235, '    let mut header = tar::Header::new_gnu();'), (236, '    header.set_size(0);'), (237, '    header.set_entry_type(tar::EntryType::Regular);'), (238, '    t!(header.set_path(\"symlink/foo/bar\"));'), (239, '    header.set_cksum();'), (240, '    t!(ar.append(&header, &[][..]));'), (242, '    let bytes = t!(ar.into_inner());'), (243, '    let mut ar = tar::Archive::new(&bytes[..]);'), (245, '    let td = t!(Builder::new().prefix(\"tar\").tempdir());'), (246, '    let tar_dir = td.path().join(\"tar\");'), (247, '    create_dir(&tar_dir).unwrap();'), (248, '    assert!(ar.unpack(tar_dir).is_err());'), (249, '    assert!(!td.path().join(\"foo\").exists());'), (250, '}')], 'deleted': [(4, 'use std::fs::File;')]}",
    "num_lines_added": "26",
    "num_lines_deleted": "1",
    "nloc": "306"
  },
  {
    "file_change_id": "140521637780133",
    "hash": "d90a02f582c03dfa0fd11c78d608d0974625ae5d",
    "old_path": "tests/header/mod.rs",
    "new_path": "tests/header/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -154,6 +154,10 @@ fn set_path() {\n     assert!(h.set_path(&medium2).is_err());\n     assert!(h.set_path(\"\\0\").is_err());\n \n+    assert!(h.set_path(\"..\").is_err());\n+    assert!(h.set_path(\"foo/..\").is_err());\n+    assert!(h.set_path(\"foo/../bar\").is_err());\n+\n     h = Header::new_ustar();\n     t!(h.set_path(\"foo\"));\n     assert_eq!(t!(h.path()).to_str(), Some(\"foo\"));\n",
    "diff_parsed": "{'added': [(157, '    assert!(h.set_path(\"..\").is_err());'), (158, '    assert!(h.set_path(\"foo/..\").is_err());'), (159, '    assert!(h.set_path(\"foo/../bar\").is_err());')], 'deleted': []}",
    "num_lines_added": "3",
    "num_lines_deleted": "0",
    "nloc": "202"
  },
  {
    "file_change_id": "245772584568325",
    "hash": "369e55736f9bd29c37b1712afc2923f4028148c6",
    "old_path": "src/vector.rs",
    "new_path": "src/vector.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -49,9 +49,10 @@ pub trait Vector {\n     }\n \n     fn insert(&mut self, index: usize, element: Self::Item) {\n+        let len = self.len();\n+        assert!(index <= len);\n         self.reserve(1);\n         unsafe {\n-            let len = self.len();\n             let ptr = self.as_mut_ptr().uoffset(index);\n             copy(ptr, ptr.uoffset(1), len - index);\n             write(ptr, element);\n",
    "diff_parsed": "{'added': [(52, '        let len = self.len();'), (53, '        assert!(index <= len);')], 'deleted': [(54, '            let len = self.len();')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "1",
    "nloc": "165"
  },
  {
    "file_change_id": "113137087988788",
    "hash": "b8f9011c04f104bb4a20f44e5bce31a1e9b46e64",
    "old_path": "core/lib/src/local/request.rs",
    "new_path": "core/lib/src/local/request.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -476,19 +476,35 @@ impl fmt::Debug for LocalResponse<'_> {\n \n impl<'c> Clone for LocalRequest<'c> {\n     fn clone(&self) -> LocalRequest<'c> {\n+        // Don't alias the existing `Request`. See #1312.\n+        let mut request = Rc::new(self.inner().clone());\n+        let ptr = Rc::get_mut(&mut request).unwrap() as *mut Request<'_>;\n+\n         LocalRequest {\n+            ptr, request,\n             client: self.client,\n-            ptr: self.ptr,\n-            request: self.request.clone(),\n             data: self.data.clone(),\n             uri: self.uri.clone()\n         }\n     }\n }\n \n-// #[cfg(test)]\n+#[cfg(test)]\n mod tests {\n-    // Someday...\n+    use crate::Request;\n+    use crate::local::Client;\n+\n+    #[test]\n+    fn clone_unique_ptr() {\n+        let client = Client::new(crate::ignite()).unwrap();\n+        let r1 = client.get(\"/\");\n+        let r2 = r1.clone();\n+\n+        assert_ne!(\n+            r1.inner() as *const Request<'_>,\n+            r2.inner() as *const Request<'_>\n+        );\n+    }\n \n     // #[test]\n     // #[compile_fail]\n",
    "diff_parsed": "{'added': [(480, '        let mut request = Rc::new(self.inner().clone());'), (481, \"        let ptr = Rc::get_mut(&mut request).unwrap() as *mut Request<'_>;\"), (484, '            ptr, request,'), (492, '#[cfg(test)]'), (494, '    use crate::Request;'), (495, '    use crate::local::Client;'), (497, '    #[test]'), (498, '    fn clone_unique_ptr() {'), (499, '        let client = Client::new(crate::ignite()).unwrap();'), (500, '        let r1 = client.get(\"/\");'), (501, '        let r2 = r1.clone();'), (503, '        assert_ne!('), (504, \"            r1.inner() as *const Request<'_>,\"), (505, \"            r2.inner() as *const Request<'_>\"), (506, '        );'), (507, '    }')], 'deleted': [(481, '            ptr: self.ptr,'), (482, '            request: self.request.clone(),')]}",
    "num_lines_added": "16",
    "num_lines_deleted": "2",
    "nloc": "346"
  },
  {
    "file_change_id": "36579630514932",
    "hash": "b8f9011c04f104bb4a20f44e5bce31a1e9b46e64",
    "old_path": "None",
    "new_path": "core/lib/tests/unsound-local-request-1312.rs",
    "change_type": "ModificationType.ADD",
    "diff": "@@ -0,0 +1,33 @@\n+use rocket::http::Header;\n+use rocket::local::Client;\n+\n+#[test]\n+fn test_local_request_clone_soundness() {\n+    let client = Client::new(rocket::ignite()).unwrap();\n+\n+    // creates two LocalRequest instances that shouldn't share the same req\n+    let r1 = client.get(\"/\").header(Header::new(\"key\", \"val1\"));\n+    let mut r2 = r1.clone();\n+\n+    // save the iterator, which internally holds a slice\n+    let mut iter = r1.inner().headers().get(\"key\");\n+\n+    // insert headers to force header map reallocation.\n+    for i in 0..100 {\n+        r2.add_header(Header::new(i.to_string(), i.to_string()));\n+    }\n+\n+    // Replace the original key/val.\n+    r2.add_header(Header::new(\"key\", \"val2\"));\n+\n+    // Heap massage: so we've got crud to print.\n+    let _: Vec<usize> = vec![0, 0xcafebabe, 31337, 0];\n+\n+    // Ensure we're good.\n+    let s = iter.next().unwrap();\n+    println!(\"{}\", s);\n+\n+    // And that we've got the right data.\n+    assert_eq!(r1.inner().headers().get(\"key\").collect::<Vec<_>>(), vec![\"val1\"]);\n+    assert_eq!(r2.inner().headers().get(\"key\").collect::<Vec<_>>(), vec![\"val1\", \"val2\"]);\n+}\n",
    "diff_parsed": "{'added': [(1, 'use rocket::http::Header;'), (2, 'use rocket::local::Client;'), (4, '#[test]'), (5, 'fn test_local_request_clone_soundness() {'), (6, '    let client = Client::new(rocket::ignite()).unwrap();'), (9, '    let r1 = client.get(\"/\").header(Header::new(\"key\", \"val1\"));'), (10, '    let mut r2 = r1.clone();'), (13, '    let mut iter = r1.inner().headers().get(\"key\");'), (16, '    for i in 0..100 {'), (17, '        r2.add_header(Header::new(i.to_string(), i.to_string()));'), (18, '    }'), (21, '    r2.add_header(Header::new(\"key\", \"val2\"));'), (24, '    let _: Vec<usize> = vec![0, 0xcafebabe, 31337, 0];'), (27, '    let s = iter.next().unwrap();'), (28, '    println!(\"{}\", s);'), (31, '    assert_eq!(r1.inner().headers().get(\"key\").collect::<Vec<_>>(), vec![\"val1\"]);'), (32, '    assert_eq!(r2.inner().headers().get(\"key\").collect::<Vec<_>>(), vec![\"val1\", \"val2\"]);'), (33, '}')], 'deleted': []}",
    "num_lines_added": "18",
    "num_lines_deleted": "0",
    "nloc": "18"
  },
  {
    "file_change_id": "121578795865963",
    "hash": "268301a714934dd067ba33f59f22c5f003aa20f3",
    "old_path": "src/cell.rs",
    "new_path": "src/cell.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -62,7 +62,7 @@ pub struct OnceCell<T, B> {\n /********** impl Send + Sync **********************************************************************/\n \n unsafe impl<T, B> Send for OnceCell<T, B> where T: Send {}\n-unsafe impl<T, B> Sync for OnceCell<T, B> where T: Sync {}\n+unsafe impl<T, B> Sync for OnceCell<T, B> where T: Send + Sync {}\n \n /********** impl inherent *************************************************************************/\n \n",
    "diff_parsed": "{'added': [(65, 'unsafe impl<T, B> Sync for OnceCell<T, B> where T: Send + Sync {}')], 'deleted': [(65, 'unsafe impl<T, B> Sync for OnceCell<T, B> where T: Sync {}')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "252"
  },
  {
    "file_change_id": "36243835198171",
    "hash": "e325e2fce4d9f9f392761e9fb58b418a48cef8bb",
    "old_path": "core/http/src/uri/formatter.rs",
    "new_path": "core/http/src/uri/formatter.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -334,26 +334,42 @@ impl Formatter<'_, Query> {\n     fn with_prefix<F>(&mut self, prefix: &str, f: F) -> fmt::Result\n         where F: FnOnce(&mut Self) -> fmt::Result\n     {\n-        // The `prefix` string is pushed in a `StackVec` for use by recursive\n-        // (nested) calls to `write_raw`. The string is pushed here and then\n-        // popped here. `self.prefixes` is modified nowhere else, and no strings\n-        // leak from the the vector. As a result, it is impossible for a\n-        // `prefix` to be accessed incorrectly as:\n-        //\n-        //   * Rust _guarantees_ it exists for the lifetime of this method\n-        //   * it is only reachable while this method's stack is active because\n-        //     it is popped before this method returns\n-        //   * thus, at any point that it's reachable, it's valid\n-        //\n-        // Said succinctly: this `prefixes` stack shadows a subset of the\n-        // `with_prefix` stack precisely, making it reachable to other code.\n-        let prefix: &'static str = unsafe { std::mem::transmute(prefix) };\n-\n-        self.prefixes.push(prefix);\n-        let result = f(self);\n-        self.prefixes.pop();\n \n-        result\n+        struct PrefixGuard<'f, 'i>(&'f mut Formatter<'i, Query>);\n+\n+        impl<'f, 'i> PrefixGuard<'f, 'i> {\n+            fn new(prefix: &str, f: &'f mut Formatter<'i, Query>) -> Self {\n+                // SAFETY: The `prefix` string is pushed in a `StackVec` for use\n+                // by recursive (nested) calls to `write_raw`. The string is\n+                // pushed in `PrefixGuard` here and then popped in `Drop`.\n+                // `prefixes` is modified nowhere else, and no concrete-lifetime\n+                // strings leak from the the vector. As a result, it is\n+                // impossible for a `prefix` to be accessed incorrectly as:\n+                //\n+                //   * Rust _guarantees_ `prefix` is valid for this method\n+                //   * `prefix` is only reachable while this method's stack is\n+                //     active because it is unconditionally popped before this\n+                //     method returns via `PrefixGuard::drop()`.\n+                //   * should a panic occur in `f()`, `PrefixGuard::drop()` is\n+                //     still called (or the program aborts), ensuring `prefix`\n+                //     is no longer in `prefixes` and thus inaccessible.\n+                //   * thus, at any point `prefix` is reachable, it is valid\n+                //\n+                // Said succinctly: `prefixes` shadows a subset of the\n+                // `with_prefix` stack, making it reachable to other code.\n+                let prefix = unsafe { std::mem::transmute(prefix) };\n+                f.prefixes.push(prefix);\n+                PrefixGuard(f)\n+            }\n+        }\n+\n+        impl Drop for PrefixGuard<'_, '_> {\n+            fn drop(&mut self) {\n+                self.0.prefixes.pop();\n+            }\n+        }\n+\n+        f(&mut PrefixGuard::new(prefix, self).0)\n     }\n \n     /// Writes the named value `value` by prefixing `name` followed by `=` to\n@@ -468,3 +484,54 @@ impl UriArguments<'_> {\n         Origin::new(path, query)\n     }\n }\n+\n+// See https://github.com/SergioBenitez/Rocket/issues/1534.\n+#[cfg(test)]\n+mod prefix_soundness_test {\n+    use crate::uri::{Formatter, Query, UriDisplay};\n+\n+    struct MyValue;\n+\n+    impl UriDisplay<Query> for MyValue {\n+        fn fmt(&self, _f: &mut Formatter<'_, Query>) -> std::fmt::Result {\n+            panic!()\n+        }\n+    }\n+\n+    struct MyDisplay;\n+\n+    impl UriDisplay<Query> for MyDisplay {\n+        fn fmt(&self, formatter: &mut Formatter<'_, Query>) -> std::fmt::Result {\n+            struct Wrapper<'a, 'b>(&'a mut Formatter<'b, Query>);\n+\n+            impl<'a, 'b> Drop for Wrapper<'a, 'b> {\n+                fn drop(&mut self) {\n+                    let _overlap = String::from(\"12345\");\n+                    self.0.write_raw(\"world\").ok();\n+                    assert!(self.0.prefixes.is_empty());\n+                }\n+            }\n+\n+            let wrapper = Wrapper(formatter);\n+            let temporary_string = String::from(\"hello\");\n+\n+            // `write_named_value` will push `temp_string` into a buffer and\n+            // call the formatter for `MyValue`, which panics. At the panic\n+            // point, `formatter` contains an (illegal) static reference to\n+            // `temp_string` in its `prefixes` stack. When unwinding occurs,\n+            // `Wrapper` will be dropped. `Wrapper` holds a reference to\n+            // `Formatter`, thus `Formatter` must be consistent at this point.\n+            let _ = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {\n+                wrapper.0.write_named_value(&temporary_string, MyValue)\n+            }));\n+\n+            Ok(())\n+        }\n+    }\n+\n+    #[test]\n+    fn check_consistency() {\n+        let string = format!(\"{}\", &MyDisplay as &dyn UriDisplay<Query>);\n+        assert_eq!(string, \"world\");\n+    }\n+}\n",
    "diff_parsed": "{'added': [(338, \"        struct PrefixGuard<'f, 'i>(&'f mut Formatter<'i, Query>);\"), (340, \"        impl<'f, 'i> PrefixGuard<'f, 'i> {\"), (341, \"            fn new(prefix: &str, f: &'f mut Formatter<'i, Query>) -> Self {\"), (360, '                let prefix = unsafe { std::mem::transmute(prefix) };'), (361, '                f.prefixes.push(prefix);'), (362, '                PrefixGuard(f)'), (363, '            }'), (364, '        }'), (366, \"        impl Drop for PrefixGuard<'_, '_> {\"), (367, '            fn drop(&mut self) {'), (368, '                self.0.prefixes.pop();'), (369, '            }'), (370, '        }'), (372, '        f(&mut PrefixGuard::new(prefix, self).0)'), (489, '#[cfg(test)]'), (490, 'mod prefix_soundness_test {'), (491, '    use crate::uri::{Formatter, Query, UriDisplay};'), (493, '    struct MyValue;'), (495, '    impl UriDisplay<Query> for MyValue {'), (496, \"        fn fmt(&self, _f: &mut Formatter<'_, Query>) -> std::fmt::Result {\"), (497, '            panic!()'), (498, '        }'), (499, '    }'), (501, '    struct MyDisplay;'), (503, '    impl UriDisplay<Query> for MyDisplay {'), (504, \"        fn fmt(&self, formatter: &mut Formatter<'_, Query>) -> std::fmt::Result {\"), (505, \"            struct Wrapper<'a, 'b>(&'a mut Formatter<'b, Query>);\"), (507, \"            impl<'a, 'b> Drop for Wrapper<'a, 'b> {\"), (508, '                fn drop(&mut self) {'), (509, '                    let _overlap = String::from(\"12345\");'), (510, '                    self.0.write_raw(\"world\").ok();'), (511, '                    assert!(self.0.prefixes.is_empty());'), (512, '                }'), (513, '            }'), (515, '            let wrapper = Wrapper(formatter);'), (516, '            let temporary_string = String::from(\"hello\");'), (524, '            let _ = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {'), (525, '                wrapper.0.write_named_value(&temporary_string, MyValue)'), (526, '            }));'), (528, '            Ok(())'), (529, '        }'), (530, '    }'), (532, '    #[test]'), (533, '    fn check_consistency() {'), (534, '        let string = format!(\"{}\", &MyDisplay as &dyn UriDisplay<Query>);'), (535, '        assert_eq!(string, \"world\");'), (536, '    }'), (537, '}')], 'deleted': [(350, \"        let prefix: &'static str = unsafe { std::mem::transmute(prefix) };\"), (352, '        self.prefixes.push(prefix);'), (353, '        let result = f(self);'), (354, '        self.prefixes.pop();'), (356, '        result')]}",
    "num_lines_added": "48",
    "num_lines_deleted": "5",
    "nloc": "201"
  },
  {
    "file_change_id": "44148363712851",
    "hash": "8783a08e71694b7a5eb4fbc7cd95379b6de0d290",
    "old_path": "src/sync/mutex.rs",
    "new_path": "src/sync/mutex.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -310,6 +310,13 @@ impl<MutexType: RawMutex, T> DerefMut for GenericMutexGuard<'_, MutexType, T> {\n     }\n }\n \n+// Safety: GenericMutexGuard may only be used across threads if the underlying\n+// type is Sync.\n+unsafe impl<MutexType: RawMutex, T: Sync> Sync\n+    for GenericMutexGuard<'_, MutexType, T>\n+{\n+}\n+\n /// A future which resolves when the target mutex has been successfully acquired.\n #[must_use = \"futures do nothing unless polled\"]\n pub struct GenericMutexLockFuture<'a, MutexType: RawMutex, T: 'a> {\n",
    "diff_parsed": "{'added': [(315, 'unsafe impl<MutexType: RawMutex, T: Sync> Sync'), (316, \"    for GenericMutexGuard<'_, MutexType, T>\"), (317, '{'), (318, '}')], 'deleted': []}",
    "num_lines_added": "4",
    "num_lines_deleted": "0",
    "nloc": "353"
  },
  {
    "file_change_id": "190106604866826",
    "hash": "59f2a7311dd6540696bfd0145f5281ce495f4385",
    "old_path": "prost-types/src/lib.rs",
    "new_path": "prost-types/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -26,6 +26,7 @@ pub mod compiler {\n // are defined in both directions.\n \n const NANOS_PER_SECOND: i32 = 1_000_000_000;\n+const NANOS_MAX: i32 = NANOS_PER_SECOND - 1;\n \n impl Duration {\n     /// Normalizes the duration to a canonical format.\n@@ -35,17 +36,42 @@ impl Duration {\n     pub fn normalize(&mut self) {\n         // Make sure nanos is in the range.\n         if self.nanos <= -NANOS_PER_SECOND || self.nanos >= NANOS_PER_SECOND {\n-            self.seconds += (self.nanos / NANOS_PER_SECOND) as i64;\n-            self.nanos %= NANOS_PER_SECOND;\n+            if let Some(seconds) = self\n+                .seconds\n+                .checked_add((self.nanos / NANOS_PER_SECOND) as i64)\n+            {\n+                self.seconds = seconds;\n+                self.nanos %= NANOS_PER_SECOND;\n+            } else if self.nanos < 0 {\n+                // Negative overflow! Set to the least normal value.\n+                self.seconds = i64::MIN;\n+                self.nanos = -NANOS_MAX;\n+            } else {\n+                // Positive overflow! Set to the greatest normal value.\n+                self.seconds = i64::MAX;\n+                self.nanos = NANOS_MAX;\n+            }\n         }\n \n         // nanos should have the same sign as seconds.\n         if self.seconds < 0 && self.nanos > 0 {\n-            self.seconds += 1;\n-            self.nanos -= NANOS_PER_SECOND;\n+            if let Some(seconds) = self.seconds.checked_add(1) {\n+                self.seconds = seconds;\n+                self.nanos -= NANOS_PER_SECOND;\n+            } else {\n+                // Positive overflow! Set to the greatest normal value.\n+                debug_assert_eq!(self.seconds, i64::MAX);\n+                self.nanos = NANOS_MAX;\n+            }\n         } else if self.seconds > 0 && self.nanos < 0 {\n-            self.seconds -= 1;\n-            self.nanos += NANOS_PER_SECOND;\n+            if let Some(seconds) = self.seconds.checked_sub(1) {\n+                self.seconds = seconds;\n+                self.nanos += NANOS_PER_SECOND;\n+            } else {\n+                // Negative overflow! Set to the least normal value.\n+                debug_assert_eq!(self.seconds, i64::MIN);\n+                self.nanos = -NANOS_MAX;\n+            }\n         }\n         // TODO: should this be checked?\n         // debug_assert!(self.seconds >= -315_576_000_000 && self.seconds <= 315_576_000_000,\n@@ -104,14 +130,33 @@ impl Timestamp {\n     pub fn normalize(&mut self) {\n         // Make sure nanos is in the range.\n         if self.nanos <= -NANOS_PER_SECOND || self.nanos >= NANOS_PER_SECOND {\n-            self.seconds += (self.nanos / NANOS_PER_SECOND) as i64;\n-            self.nanos %= NANOS_PER_SECOND;\n+            if let Some(seconds) = self\n+                .seconds\n+                .checked_add((self.nanos / NANOS_PER_SECOND) as i64)\n+            {\n+                self.seconds = seconds;\n+                self.nanos %= NANOS_PER_SECOND;\n+            } else if self.nanos < 0 {\n+                // Negative overflow! Set to the earliest normal value.\n+                self.seconds = i64::MIN;\n+                self.nanos = 0;\n+            } else {\n+                // Positive overflow! Set to the latest normal value.\n+                self.seconds = i64::MAX;\n+                self.nanos = 999_999_999;\n+            }\n         }\n \n         // For Timestamp nanos should be in the range [0, 999999999].\n         if self.nanos < 0 {\n-            self.seconds -= 1;\n-            self.nanos += NANOS_PER_SECOND;\n+            if let Some(seconds) = self.seconds.checked_sub(1) {\n+                self.seconds = seconds;\n+                self.nanos += NANOS_PER_SECOND;\n+            } else {\n+                // Negative overflow! Set to the earliest normal value.\n+                debug_assert_eq!(self.seconds, i64::MIN);\n+                self.nanos = 0;\n+            }\n         }\n \n         // TODO: should this be checked?\n@@ -143,17 +188,56 @@ impl From<std::time::SystemTime> for Timestamp {\n     }\n }\n \n+/// Indicates that a [`Timestamp`] could not be converted to\n+/// [`SystemTime`][std::time::SystemTime] because it is out of range.\n+///\n+/// The range of times that can be represented by `SystemTime` depends on the platform.\n+/// All `Timestamp`s are likely representable on 64-bit Unix-like platforms, but\n+/// other platforms, such as Windows and 32-bit Linux, may not be able to represent\n+/// the full range of `Timestamp`s.\n+#[cfg(feature = \"std\")]\n+#[derive(Debug)]\n+#[non_exhaustive]\n+pub struct TimestampOutOfSystemRangeError {\n+    pub timestamp: Timestamp,\n+}\n+\n+#[cfg(feature = \"std\")]\n+impl core::fmt::Display for TimestampOutOfSystemRangeError {\n+    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n+        write!(\n+            f,\n+            \"{:?} is not representable as a `SystemTime` because it is out of range\",\n+            self\n+        )\n+    }\n+}\n+\n+#[cfg(feature = \"std\")]\n+impl std::error::Error for TimestampOutOfSystemRangeError {}\n+\n #[cfg(feature = \"std\")]\n-impl From<Timestamp> for std::time::SystemTime {\n-    fn from(mut timestamp: Timestamp) -> std::time::SystemTime {\n+impl TryFrom<Timestamp> for std::time::SystemTime {\n+    type Error = TimestampOutOfSystemRangeError;\n+\n+    fn try_from(mut timestamp: Timestamp) -> Result<std::time::SystemTime, Self::Error> {\n+        let orig_timestamp = timestamp.clone();\n         timestamp.normalize();\n+\n         let system_time = if timestamp.seconds >= 0 {\n-            std::time::UNIX_EPOCH + time::Duration::from_secs(timestamp.seconds as u64)\n+            std::time::UNIX_EPOCH.checked_add(time::Duration::from_secs(timestamp.seconds as u64))\n         } else {\n-            std::time::UNIX_EPOCH - time::Duration::from_secs((-timestamp.seconds) as u64)\n+            std::time::UNIX_EPOCH\n+                .checked_sub(time::Duration::from_secs((-timestamp.seconds) as u64))\n         };\n \n-        system_time + time::Duration::from_nanos(timestamp.nanos as u64)\n+        let system_time = system_time.and_then(|system_time| {\n+            system_time.checked_add(time::Duration::from_nanos(timestamp.nanos as u64))\n+        });\n+\n+        system_time.ok_or(TimestampOutOfSystemRangeError {\n+            timestamp: orig_timestamp,\n+        })\n     }\n }\n \n@@ -171,7 +255,19 @@ mod tests {\n         fn check_system_time_roundtrip(\n             system_time in SystemTime::arbitrary(),\n         ) {\n-            prop_assert_eq!(SystemTime::from(Timestamp::from(system_time)), system_time);\n+            prop_assert_eq!(SystemTime::try_from(Timestamp::from(system_time)).unwrap(), system_time);\n+        }\n+\n+        #[test]\n+        fn check_timestamp_roundtrip_via_system_time(\n+            seconds in i64::arbitrary(),\n+            nanos in i32::arbitrary(),\n+        ) {\n+            let mut timestamp = Timestamp { seconds, nanos };\n+            timestamp.normalize();\n+            if let Ok(system_time) = SystemTime::try_from(timestamp.clone()) {\n+                prop_assert_eq!(Timestamp::from(system_time), timestamp);\n+            }\n         }\n     }\n \n@@ -243,4 +339,156 @@ mod tests {\n             }\n         );\n     }\n+\n+    #[test]\n+    fn check_duration_normalize() {\n+        #[rustfmt::skip] // Don't mangle the table formatting.\n+        let cases = [\n+            // --- Table of test cases ---\n+            //        test seconds      test nanos  expected seconds  expected nanos\n+            (line!(),            0,              0,                0,              0),\n+            (line!(),            1,              1,                1,              1),\n+            (line!(),           -1,             -1,               -1,             -1),\n+            (line!(),            0,    999_999_999,                0,    999_999_999),\n+            (line!(),            0,   -999_999_999,                0,   -999_999_999),\n+            (line!(),            0,  1_000_000_000,                1,              0),\n+            (line!(),            0, -1_000_000_000,               -1,              0),\n+            (line!(),            0,  1_000_000_001,                1,              1),\n+            (line!(),            0, -1_000_000_001,               -1,             -1),\n+            (line!(),           -1,              1,                0,   -999_999_999),\n+            (line!(),            1,             -1,                0,    999_999_999),\n+            (line!(),           -1,  1_000_000_000,                0,              0),\n+            (line!(),            1, -1_000_000_000,                0,              0),\n+            (line!(), i64::MIN    ,              0,     i64::MIN    ,              0),\n+            (line!(), i64::MIN + 1,              0,     i64::MIN + 1,              0),\n+            (line!(), i64::MIN    ,              1,     i64::MIN + 1,   -999_999_999),\n+            (line!(), i64::MIN    ,  1_000_000_000,     i64::MIN + 1,              0),\n+            (line!(), i64::MIN    , -1_000_000_000,     i64::MIN    ,   -999_999_999),\n+            (line!(), i64::MIN + 1, -1_000_000_000,     i64::MIN    ,              0),\n+            (line!(), i64::MIN + 2, -1_000_000_000,     i64::MIN + 1,              0),\n+            (line!(), i64::MIN    , -1_999_999_998,     i64::MIN    ,   -999_999_999),\n+            (line!(), i64::MIN + 1, -1_999_999_998,     i64::MIN    ,   -999_999_998),\n+            (line!(), i64::MIN + 2, -1_999_999_998,     i64::MIN + 1,   -999_999_998),\n+            (line!(), i64::MIN    , -1_999_999_999,     i64::MIN    ,   -999_999_999),\n+            (line!(), i64::MIN + 1, -1_999_999_999,     i64::MIN    ,   -999_999_999),\n+            (line!(), i64::MIN + 2, -1_999_999_999,     i64::MIN + 1,   -999_999_999),\n+            (line!(), i64::MIN    , -2_000_000_000,     i64::MIN    ,   -999_999_999),\n+            (line!(), i64::MIN + 1, -2_000_000_000,     i64::MIN    ,   -999_999_999),\n+            (line!(), i64::MIN + 2, -2_000_000_000,     i64::MIN    ,              0),\n+            (line!(), i64::MIN    ,   -999_999_998,     i64::MIN    ,   -999_999_998),\n+            (line!(), i64::MIN + 1,   -999_999_998,     i64::MIN + 1,   -999_999_998),\n+            (line!(), i64::MAX    ,              0,     i64::MAX    ,              0),\n+            (line!(), i64::MAX - 1,              0,     i64::MAX - 1,              0),\n+            (line!(), i64::MAX    ,             -1,     i64::MAX - 1,    999_999_999),\n+            (line!(), i64::MAX    ,  1_000_000_000,     i64::MAX    ,    999_999_999),\n+            (line!(), i64::MAX - 1,  1_000_000_000,     i64::MAX    ,              0),\n+            (line!(), i64::MAX - 2,  1_000_000_000,     i64::MAX - 1,              0),\n+            (line!(), i64::MAX    ,  1_999_999_998,     i64::MAX    ,    999_999_999),\n+            (line!(), i64::MAX - 1,  1_999_999_998,     i64::MAX    ,    999_999_998),\n+            (line!(), i64::MAX - 2,  1_999_999_998,     i64::MAX - 1,    999_999_998),\n+            (line!(), i64::MAX    ,  1_999_999_999,     i64::MAX    ,    999_999_999),\n+            (line!(), i64::MAX - 1,  1_999_999_999,     i64::MAX    ,    999_999_999),\n+            (line!(), i64::MAX - 2,  1_999_999_999,     i64::MAX - 1,    999_999_999),\n+            (line!(), i64::MAX    ,  2_000_000_000,     i64::MAX    ,    999_999_999),\n+            (line!(), i64::MAX - 1,  2_000_000_000,     i64::MAX    ,    999_999_999),\n+            (line!(), i64::MAX - 2,  2_000_000_000,     i64::MAX    ,              0),\n+            (line!(), i64::MAX    ,    999_999_998,     i64::MAX    ,    999_999_998),\n+            (line!(), i64::MAX - 1,    999_999_998,     i64::MAX - 1,    999_999_998),\n+        ];\n+\n+        for case in cases.iter() {\n+            let mut test_duration = crate::Duration {\n+                seconds: case.1,\n+                nanos: case.2,\n+            };\n+            test_duration.normalize();\n+\n+            assert_eq!(\n+                test_duration,\n+                crate::Duration {\n+                    seconds: case.3,\n+                    nanos: case.4,\n+                },\n+                \"test case on line {} doesn't match\",\n+                case.0,\n+            );\n+        }\n+    }\n+\n+    #[cfg(feature = \"std\")]\n+    #[test]\n+    fn check_timestamp_normalize() {\n+        // Make sure that `Timestamp::normalize` behaves correctly on and near overflow.\n+        #[rustfmt::skip] // Don't mangle the table formatting.\n+        let cases = [\n+            // --- Table of test cases ---\n+            //        test seconds      test nanos  expected seconds  expected nanos\n+            (line!(),            0,              0,                0,              0),\n+            (line!(),            1,              1,                1,              1),\n+            (line!(),           -1,             -1,               -2,    999_999_999),\n+            (line!(),            0,    999_999_999,                0,    999_999_999),\n+            (line!(),            0,   -999_999_999,               -1,              1),\n+            (line!(),            0,  1_000_000_000,                1,              0),\n+            (line!(),            0, -1_000_000_000,               -1,              0),\n+            (line!(),            0,  1_000_000_001,                1,              1),\n+            (line!(),            0, -1_000_000_001,               -2,    999_999_999),\n+            (line!(),           -1,              1,               -1,              1),\n+            (line!(),            1,             -1,                0,    999_999_999),\n+            (line!(),           -1,  1_000_000_000,                0,              0),\n+            (line!(),            1, -1_000_000_000,                0,              0),\n+            (line!(), i64::MIN    ,              0,     i64::MIN    ,              0),\n+            (line!(), i64::MIN + 1,              0,     i64::MIN + 1,              0),\n+            (line!(), i64::MIN    ,              1,     i64::MIN    ,              1),\n+            (line!(), i64::MIN    ,  1_000_000_000,     i64::MIN + 1,              0),\n+            (line!(), i64::MIN    , -1_000_000_000,     i64::MIN    ,              0),\n+            (line!(), i64::MIN + 1, -1_000_000_000,     i64::MIN    ,              0),\n+            (line!(), i64::MIN + 2, -1_000_000_000,     i64::MIN + 1,              0),\n+            (line!(), i64::MIN    , -1_999_999_998,     i64::MIN    ,              0),\n+            (line!(), i64::MIN + 1, -1_999_999_998,     i64::MIN    ,              0),\n+            (line!(), i64::MIN + 2, -1_999_999_998,     i64::MIN    ,              2),\n+            (line!(), i64::MIN    , -1_999_999_999,     i64::MIN    ,              0),\n+            (line!(), i64::MIN + 1, -1_999_999_999,     i64::MIN    ,              0),\n+            (line!(), i64::MIN + 2, -1_999_999_999,     i64::MIN    ,              1),\n+            (line!(), i64::MIN    , -2_000_000_000,     i64::MIN    ,              0),\n+            (line!(), i64::MIN + 1, -2_000_000_000,     i64::MIN    ,              0),\n+            (line!(), i64::MIN + 2, -2_000_000_000,     i64::MIN    ,              0),\n+            (line!(), i64::MIN    ,   -999_999_998,     i64::MIN    ,              0),\n+            (line!(), i64::MIN + 1,   -999_999_998,     i64::MIN    ,              2),\n+            (line!(), i64::MAX    ,              0,     i64::MAX    ,              0),\n+            (line!(), i64::MAX - 1,              0,     i64::MAX - 1,              0),\n+            (line!(), i64::MAX    ,             -1,     i64::MAX - 1,    999_999_999),\n+            (line!(), i64::MAX    ,  1_000_000_000,     i64::MAX    ,    999_999_999),\n+            (line!(), i64::MAX - 1,  1_000_000_000,     i64::MAX    ,              0),\n+            (line!(), i64::MAX - 2,  1_000_000_000,     i64::MAX - 1,              0),\n+            (line!(), i64::MAX    ,  1_999_999_998,     i64::MAX    ,    999_999_999),\n+            (line!(), i64::MAX - 1,  1_999_999_998,     i64::MAX    ,    999_999_998),\n+            (line!(), i64::MAX - 2,  1_999_999_998,     i64::MAX - 1,    999_999_998),\n+            (line!(), i64::MAX    ,  1_999_999_999,     i64::MAX    ,    999_999_999),\n+            (line!(), i64::MAX - 1,  1_999_999_999,     i64::MAX    ,    999_999_999),\n+            (line!(), i64::MAX - 2,  1_999_999_999,     i64::MAX - 1,    999_999_999),\n+            (line!(), i64::MAX    ,  2_000_000_000,     i64::MAX    ,    999_999_999),\n+            (line!(), i64::MAX - 1,  2_000_000_000,     i64::MAX    ,    999_999_999),\n+            (line!(), i64::MAX - 2,  2_000_000_000,     i64::MAX    ,              0),\n+            (line!(), i64::MAX    ,    999_999_998,     i64::MAX    ,    999_999_998),\n+            (line!(), i64::MAX - 1,    999_999_998,     i64::MAX - 1,    999_999_998),\n+        ];\n+\n+        for case in cases.iter() {\n+            let mut test_timestamp = crate::Timestamp {\n+                seconds: case.1,\n+                nanos: case.2,\n+            };\n+            test_timestamp.normalize();\n+\n+            assert_eq!(\n+                test_timestamp,\n+                crate::Timestamp {\n+                    seconds: case.3,\n+                    nanos: case.4,\n+                },\n+                \"test case on line {} doesn't match\",\n+                case.0,\n+            );\n+        }\n+    }\n }\n",
    "diff_parsed": "{'added': [(29, 'const NANOS_MAX: i32 = NANOS_PER_SECOND - 1;'), (39, '            if let Some(seconds) = self'), (40, '                .seconds'), (41, '                .checked_add((self.nanos / NANOS_PER_SECOND) as i64)'), (42, '            {'), (43, '                self.seconds = seconds;'), (44, '                self.nanos %= NANOS_PER_SECOND;'), (45, '            } else if self.nanos < 0 {'), (47, '                self.seconds = i64::MIN;'), (48, '                self.nanos = -NANOS_MAX;'), (49, '            } else {'), (51, '                self.seconds = i64::MAX;'), (52, '                self.nanos = NANOS_MAX;'), (53, '            }'), (58, '            if let Some(seconds) = self.seconds.checked_add(1) {'), (59, '                self.seconds = seconds;'), (60, '                self.nanos -= NANOS_PER_SECOND;'), (61, '            } else {'), (63, '                debug_assert_eq!(self.seconds, i64::MAX);'), (64, '                self.nanos = NANOS_MAX;'), (65, '            }'), (67, '            if let Some(seconds) = self.seconds.checked_sub(1) {'), (68, '                self.seconds = seconds;'), (69, '                self.nanos += NANOS_PER_SECOND;'), (70, '            } else {'), (72, '                debug_assert_eq!(self.seconds, i64::MIN);'), (73, '                self.nanos = -NANOS_MAX;'), (74, '            }'), (133, '            if let Some(seconds) = self'), (134, '                .seconds'), (135, '                .checked_add((self.nanos / NANOS_PER_SECOND) as i64)'), (136, '            {'), (137, '                self.seconds = seconds;'), (138, '                self.nanos %= NANOS_PER_SECOND;'), (139, '            } else if self.nanos < 0 {'), (141, '                self.seconds = i64::MIN;'), (142, '                self.nanos = 0;'), (143, '            } else {'), (145, '                self.seconds = i64::MAX;'), (146, '                self.nanos = 999_999_999;'), (147, '            }'), (152, '            if let Some(seconds) = self.seconds.checked_sub(1) {'), (153, '                self.seconds = seconds;'), (154, '                self.nanos += NANOS_PER_SECOND;'), (155, '            } else {'), (157, '                debug_assert_eq!(self.seconds, i64::MIN);'), (158, '                self.nanos = 0;'), (159, '            }'), (198, '#[cfg(feature = \"std\")]'), (199, '#[derive(Debug)]'), (200, '#[non_exhaustive]'), (201, 'pub struct TimestampOutOfSystemRangeError {'), (202, '    pub timestamp: Timestamp,'), (203, '}'), (205, '#[cfg(feature = \"std\")]'), (206, 'impl core::fmt::Display for TimestampOutOfSystemRangeError {'), (207, \"    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\"), (208, '        write!('), (209, '            f,'), (210, '            \"{:?} is not representable as a `SystemTime` because it is out of range\",'), (211, '            self'), (212, '        )'), (213, '    }'), (214, '}'), (216, '#[cfg(feature = \"std\")]'), (217, 'impl std::error::Error for TimestampOutOfSystemRangeError {}'), (220, 'impl TryFrom<Timestamp> for std::time::SystemTime {'), (221, '    type Error = TimestampOutOfSystemRangeError;'), (223, '    fn try_from(mut timestamp: Timestamp) -> Result<std::time::SystemTime, Self::Error> {'), (224, '        let orig_timestamp = timestamp.clone();'), (228, '            std::time::UNIX_EPOCH.checked_add(time::Duration::from_secs(timestamp.seconds as u64))'), (230, '            std::time::UNIX_EPOCH'), (231, '                .checked_sub(time::Duration::from_secs((-timestamp.seconds) as u64))'), (234, '        let system_time = system_time.and_then(|system_time| {'), (235, '            system_time.checked_add(time::Duration::from_nanos(timestamp.nanos as u64))'), (236, '        });'), (238, '        system_time.ok_or(TimestampOutOfSystemRangeError {'), (239, '            timestamp: orig_timestamp,'), (240, '        })'), (258, '            prop_assert_eq!(SystemTime::try_from(Timestamp::from(system_time)).unwrap(), system_time);'), (259, '        }'), (261, '        #[test]'), (262, '        fn check_timestamp_roundtrip_via_system_time('), (263, '            seconds in i64::arbitrary(),'), (264, '            nanos in i32::arbitrary(),'), (265, '        ) {'), (266, '            let mut timestamp = Timestamp { seconds, nanos };'), (267, '            timestamp.normalize();'), (268, '            if let Ok(system_time) = SystemTime::try_from(timestamp.clone()) {'), (269, '                prop_assert_eq!(Timestamp::from(system_time), timestamp);'), (270, '            }'), (343, '    #[test]'), (344, '    fn check_duration_normalize() {'), (345, \"        #[rustfmt::skip] // Don't mangle the table formatting.\"), (346, '        let cases = ['), (349, '            (line!(),            0,              0,                0,              0),'), (350, '            (line!(),            1,              1,                1,              1),'), (351, '            (line!(),           -1,             -1,               -1,             -1),'), (352, '            (line!(),            0,    999_999_999,                0,    999_999_999),'), (353, '            (line!(),            0,   -999_999_999,                0,   -999_999_999),'), (354, '            (line!(),            0,  1_000_000_000,                1,              0),'), (355, '            (line!(),            0, -1_000_000_000,               -1,              0),'), (356, '            (line!(),            0,  1_000_000_001,                1,              1),'), (357, '            (line!(),            0, -1_000_000_001,               -1,             -1),'), (358, '            (line!(),           -1,              1,                0,   -999_999_999),'), (359, '            (line!(),            1,             -1,                0,    999_999_999),'), (360, '            (line!(),           -1,  1_000_000_000,                0,              0),'), (361, '            (line!(),            1, -1_000_000_000,                0,              0),'), (362, '            (line!(), i64::MIN    ,              0,     i64::MIN    ,              0),'), (363, '            (line!(), i64::MIN + 1,              0,     i64::MIN + 1,              0),'), (364, '            (line!(), i64::MIN    ,              1,     i64::MIN + 1,   -999_999_999),'), (365, '            (line!(), i64::MIN    ,  1_000_000_000,     i64::MIN + 1,              0),'), (366, '            (line!(), i64::MIN    , -1_000_000_000,     i64::MIN    ,   -999_999_999),'), (367, '            (line!(), i64::MIN + 1, -1_000_000_000,     i64::MIN    ,              0),'), (368, '            (line!(), i64::MIN + 2, -1_000_000_000,     i64::MIN + 1,              0),'), (369, '            (line!(), i64::MIN    , -1_999_999_998,     i64::MIN    ,   -999_999_999),'), (370, '            (line!(), i64::MIN + 1, -1_999_999_998,     i64::MIN    ,   -999_999_998),'), (371, '            (line!(), i64::MIN + 2, -1_999_999_998,     i64::MIN + 1,   -999_999_998),'), (372, '            (line!(), i64::MIN    , -1_999_999_999,     i64::MIN    ,   -999_999_999),'), (373, '            (line!(), i64::MIN + 1, -1_999_999_999,     i64::MIN    ,   -999_999_999),'), (374, '            (line!(), i64::MIN + 2, -1_999_999_999,     i64::MIN + 1,   -999_999_999),'), (375, '            (line!(), i64::MIN    , -2_000_000_000,     i64::MIN    ,   -999_999_999),'), (376, '            (line!(), i64::MIN + 1, -2_000_000_000,     i64::MIN    ,   -999_999_999),'), (377, '            (line!(), i64::MIN + 2, -2_000_000_000,     i64::MIN    ,              0),'), (378, '            (line!(), i64::MIN    ,   -999_999_998,     i64::MIN    ,   -999_999_998),'), (379, '            (line!(), i64::MIN + 1,   -999_999_998,     i64::MIN + 1,   -999_999_998),'), (380, '            (line!(), i64::MAX    ,              0,     i64::MAX    ,              0),'), (381, '            (line!(), i64::MAX - 1,              0,     i64::MAX - 1,              0),'), (382, '            (line!(), i64::MAX    ,             -1,     i64::MAX - 1,    999_999_999),'), (383, '            (line!(), i64::MAX    ,  1_000_000_000,     i64::MAX    ,    999_999_999),'), (384, '            (line!(), i64::MAX - 1,  1_000_000_000,     i64::MAX    ,              0),'), (385, '            (line!(), i64::MAX - 2,  1_000_000_000,     i64::MAX - 1,              0),'), (386, '            (line!(), i64::MAX    ,  1_999_999_998,     i64::MAX    ,    999_999_999),'), (387, '            (line!(), i64::MAX - 1,  1_999_999_998,     i64::MAX    ,    999_999_998),'), (388, '            (line!(), i64::MAX - 2,  1_999_999_998,     i64::MAX - 1,    999_999_998),'), (389, '            (line!(), i64::MAX    ,  1_999_999_999,     i64::MAX    ,    999_999_999),'), (390, '            (line!(), i64::MAX - 1,  1_999_999_999,     i64::MAX    ,    999_999_999),'), (391, '            (line!(), i64::MAX - 2,  1_999_999_999,     i64::MAX - 1,    999_999_999),'), (392, '            (line!(), i64::MAX    ,  2_000_000_000,     i64::MAX    ,    999_999_999),'), (393, '            (line!(), i64::MAX - 1,  2_000_000_000,     i64::MAX    ,    999_999_999),'), (394, '            (line!(), i64::MAX - 2,  2_000_000_000,     i64::MAX    ,              0),'), (395, '            (line!(), i64::MAX    ,    999_999_998,     i64::MAX    ,    999_999_998),'), (396, '            (line!(), i64::MAX - 1,    999_999_998,     i64::MAX - 1,    999_999_998),'), (397, '        ];'), (399, '        for case in cases.iter() {'), (400, '            let mut test_duration = crate::Duration {'), (401, '                seconds: case.1,'), (402, '                nanos: case.2,'), (403, '            };'), (404, '            test_duration.normalize();'), (406, '            assert_eq!('), (407, '                test_duration,'), (408, '                crate::Duration {'), (409, '                    seconds: case.3,'), (410, '                    nanos: case.4,'), (411, '                },'), (412, '                \"test case on line {} doesn\\'t match\",'), (413, '                case.0,'), (414, '            );'), (415, '        }'), (416, '    }'), (418, '    #[cfg(feature = \"std\")]'), (419, '    #[test]'), (420, '    fn check_timestamp_normalize() {'), (422, \"        #[rustfmt::skip] // Don't mangle the table formatting.\"), (423, '        let cases = ['), (426, '            (line!(),            0,              0,                0,              0),'), (427, '            (line!(),            1,              1,                1,              1),'), (428, '            (line!(),           -1,             -1,               -2,    999_999_999),'), (429, '            (line!(),            0,    999_999_999,                0,    999_999_999),'), (430, '            (line!(),            0,   -999_999_999,               -1,              1),'), (431, '            (line!(),            0,  1_000_000_000,                1,              0),'), (432, '            (line!(),            0, -1_000_000_000,               -1,              0),'), (433, '            (line!(),            0,  1_000_000_001,                1,              1),'), (434, '            (line!(),            0, -1_000_000_001,               -2,    999_999_999),'), (435, '            (line!(),           -1,              1,               -1,              1),'), (436, '            (line!(),            1,             -1,                0,    999_999_999),'), (437, '            (line!(),           -1,  1_000_000_000,                0,              0),'), (438, '            (line!(),            1, -1_000_000_000,                0,              0),'), (439, '            (line!(), i64::MIN    ,              0,     i64::MIN    ,              0),'), (440, '            (line!(), i64::MIN + 1,              0,     i64::MIN + 1,              0),'), (441, '            (line!(), i64::MIN    ,              1,     i64::MIN    ,              1),'), (442, '            (line!(), i64::MIN    ,  1_000_000_000,     i64::MIN + 1,              0),'), (443, '            (line!(), i64::MIN    , -1_000_000_000,     i64::MIN    ,              0),'), (444, '            (line!(), i64::MIN + 1, -1_000_000_000,     i64::MIN    ,              0),'), (445, '            (line!(), i64::MIN + 2, -1_000_000_000,     i64::MIN + 1,              0),'), (446, '            (line!(), i64::MIN    , -1_999_999_998,     i64::MIN    ,              0),'), (447, '            (line!(), i64::MIN + 1, -1_999_999_998,     i64::MIN    ,              0),'), (448, '            (line!(), i64::MIN + 2, -1_999_999_998,     i64::MIN    ,              2),'), (449, '            (line!(), i64::MIN    , -1_999_999_999,     i64::MIN    ,              0),'), (450, '            (line!(), i64::MIN + 1, -1_999_999_999,     i64::MIN    ,              0),'), (451, '            (line!(), i64::MIN + 2, -1_999_999_999,     i64::MIN    ,              1),'), (452, '            (line!(), i64::MIN    , -2_000_000_000,     i64::MIN    ,              0),'), (453, '            (line!(), i64::MIN + 1, -2_000_000_000,     i64::MIN    ,              0),'), (454, '            (line!(), i64::MIN + 2, -2_000_000_000,     i64::MIN    ,              0),'), (455, '            (line!(), i64::MIN    ,   -999_999_998,     i64::MIN    ,              0),'), (456, '            (line!(), i64::MIN + 1,   -999_999_998,     i64::MIN    ,              2),'), (457, '            (line!(), i64::MAX    ,              0,     i64::MAX    ,              0),'), (458, '            (line!(), i64::MAX - 1,              0,     i64::MAX - 1,              0),'), (459, '            (line!(), i64::MAX    ,             -1,     i64::MAX - 1,    999_999_999),'), (460, '            (line!(), i64::MAX    ,  1_000_000_000,     i64::MAX    ,    999_999_999),'), (461, '            (line!(), i64::MAX - 1,  1_000_000_000,     i64::MAX    ,              0),'), (462, '            (line!(), i64::MAX - 2,  1_000_000_000,     i64::MAX - 1,              0),'), (463, '            (line!(), i64::MAX    ,  1_999_999_998,     i64::MAX    ,    999_999_999),'), (464, '            (line!(), i64::MAX - 1,  1_999_999_998,     i64::MAX    ,    999_999_998),'), (465, '            (line!(), i64::MAX - 2,  1_999_999_998,     i64::MAX - 1,    999_999_998),'), (466, '            (line!(), i64::MAX    ,  1_999_999_999,     i64::MAX    ,    999_999_999),'), (467, '            (line!(), i64::MAX - 1,  1_999_999_999,     i64::MAX    ,    999_999_999),'), (468, '            (line!(), i64::MAX - 2,  1_999_999_999,     i64::MAX - 1,    999_999_999),'), (469, '            (line!(), i64::MAX    ,  2_000_000_000,     i64::MAX    ,    999_999_999),'), (470, '            (line!(), i64::MAX - 1,  2_000_000_000,     i64::MAX    ,    999_999_999),'), (471, '            (line!(), i64::MAX - 2,  2_000_000_000,     i64::MAX    ,              0),'), (472, '            (line!(), i64::MAX    ,    999_999_998,     i64::MAX    ,    999_999_998),'), (473, '            (line!(), i64::MAX - 1,    999_999_998,     i64::MAX - 1,    999_999_998),'), (474, '        ];'), (476, '        for case in cases.iter() {'), (477, '            let mut test_timestamp = crate::Timestamp {'), (478, '                seconds: case.1,'), (479, '                nanos: case.2,'), (480, '            };'), (481, '            test_timestamp.normalize();'), (483, '            assert_eq!('), (484, '                test_timestamp,'), (485, '                crate::Timestamp {'), (486, '                    seconds: case.3,'), (487, '                    nanos: case.4,'), (488, '                },'), (489, '                \"test case on line {} doesn\\'t match\",'), (490, '                case.0,'), (491, '            );'), (492, '        }'), (493, '    }')], 'deleted': [(38, '            self.seconds += (self.nanos / NANOS_PER_SECOND) as i64;'), (39, '            self.nanos %= NANOS_PER_SECOND;'), (44, '            self.seconds += 1;'), (45, '            self.nanos -= NANOS_PER_SECOND;'), (47, '            self.seconds -= 1;'), (48, '            self.nanos += NANOS_PER_SECOND;'), (107, '            self.seconds += (self.nanos / NANOS_PER_SECOND) as i64;'), (108, '            self.nanos %= NANOS_PER_SECOND;'), (113, '            self.seconds -= 1;'), (114, '            self.nanos += NANOS_PER_SECOND;'), (147, 'impl From<Timestamp> for std::time::SystemTime {'), (148, '    fn from(mut timestamp: Timestamp) -> std::time::SystemTime {'), (151, '            std::time::UNIX_EPOCH + time::Duration::from_secs(timestamp.seconds as u64)'), (153, '            std::time::UNIX_EPOCH - time::Duration::from_secs((-timestamp.seconds) as u64)'), (156, '        system_time + time::Duration::from_nanos(timestamp.nanos as u64)'), (174, '            prop_assert_eq!(SystemTime::from(Timestamp::from(system_time)), system_time);')]}",
    "num_lines_added": "232",
    "num_lines_deleted": "16",
    "nloc": "421"
  },
  {
    "file_change_id": "204657470124655",
    "hash": "85593a484173c574027d7897b980f729bb1f454f",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1041,14 +1041,24 @@ impl<A: Array> SmallVec<A> {\n                 let mut cur = ptr.add(num_added);\n                 if num_added >= lower_size_bound {\n                     // Iterator provided more elements than the hint.  Move trailing items again.\n+\n+                    // `reserve` needs `len` to be accurate.\n+                    self.set_len(old_len + num_added);\n+                    let guard_len = guard.len;\n+                    guard.len = 0; // in case `reserve` panics, don't double-free in guard.drop().\n+\n+                    // Grow the vector by 1.\n                     self.reserve(1);\n+\n                     let start = self.as_mut_ptr();\n                     ptr = start.add(index);\n                     cur = ptr.add(num_added);\n                     ptr::copy(cur, cur.add(1), old_len - index);\n \n+                    // Restore the guard.\n+                    self.set_len(0);\n                     guard.start = start;\n-                    guard.len += 1;\n+                    guard.len = guard_len + 1;\n                     guard.skip.end += 1;\n                 }\n                 ptr::write(cur, element);\n",
    "diff_parsed": "{'added': [(1046, '                    self.set_len(old_len + num_added);'), (1047, '                    let guard_len = guard.len;'), (1048, \"                    guard.len = 0; // in case `reserve` panics, don't double-free in guard.drop().\"), (1059, '                    self.set_len(0);'), (1061, '                    guard.len = guard_len + 1;')], 'deleted': [(1051, '                    guard.len += 1;')]}",
    "num_lines_added": "5",
    "num_lines_deleted": "1",
    "nloc": "1495"
  },
  {
    "file_change_id": "41680908949537",
    "hash": "85593a484173c574027d7897b980f729bb1f454f",
    "old_path": "src/tests.rs",
    "new_path": "src/tests.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -905,3 +905,18 @@ fn empty_macro() {\n fn zero_size_items() {\n     SmallVec::<[(); 0]>::new().push(());\n }\n+\n+#[test]\n+fn test_insert_many_overflow() {\n+    let mut v: SmallVec<[u8; 0]> = SmallVec::new();\n+\n+    // Spill on heap\n+    v.push(123);\n+\n+    // Prepare an iterator with small lower bound\n+    let iter = (0u8..=255).filter(|n| n % 2 == 0);\n+    assert_eq!(iter.size_hint().0, 0);\n+\n+    // Triggering the bug\n+    v.insert_many(0, iter);\n+}\n",
    "diff_parsed": "{'added': [(909, '#[test]'), (910, 'fn test_insert_many_overflow() {'), (911, '    let mut v: SmallVec<[u8; 0]> = SmallVec::new();'), (914, '    v.push(123);'), (917, '    let iter = (0u8..=255).filter(|n| n % 2 == 0);'), (918, '    assert_eq!(iter.size_hint().0, 0);'), (921, '    v.insert_many(0, iter);'), (922, '}')], 'deleted': []}",
    "num_lines_added": "8",
    "num_lines_deleted": "0",
    "nloc": "770"
  },
  {
    "file_change_id": "38634314853563",
    "hash": "18abedadaa77646cce6f2ca2149c0119a2e4f428",
    "old_path": "None",
    "new_path": "src/array_iter.rs",
    "change_type": "ModificationType.ADD",
    "diff": "@@ -0,0 +1,75 @@\n+// Copyright 2018-2021 Theodore Cipicchio\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Consuming iterator for static arrays.\n+\n+use super::Array;\n+use core::{mem::ManuallyDrop, ptr, slice};\n+\n+/// Consuming iterator for static arrays.\n+pub struct ArrayIter<T>\n+where\n+    T: Array,\n+{\n+    /// Source array being consumed.\n+    source: ManuallyDrop<T>,\n+    /// Index of the next element to yield.\n+    index: usize,\n+}\n+\n+impl<T> ArrayIter<T>\n+where\n+    T: Array,\n+{\n+    /// Creates a new iterator consuming all elements in the given array.\n+    pub fn new(source: T) -> Self {\n+        Self {\n+            source: ManuallyDrop::new(source),\n+            index: 0,\n+        }\n+    }\n+}\n+\n+impl<T> Iterator for ArrayIter<T>\n+where\n+    T: Array,\n+{\n+    type Item = T::Item;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let source = self.source.as_slice();\n+        let index = self.index;\n+        if index < source.len() {\n+            self.index = index + 1;\n+\n+            Some(unsafe { ptr::read(&source[index]) })\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl<T> Drop for ArrayIter<T>\n+where\n+    T: Array,\n+{\n+    fn drop(&mut self) {\n+        // Drop all unconsumed elements.\n+        let source = self.source.as_mut_slice();\n+        let remaining_len = source.len() - self.index;\n+        unsafe {\n+            // The Rust compiler and standard library try to prevent cases\n+            // where the length of an allocation is larger than `isize::MAX`\n+            // (see the `pointer::offset` safety documentation), so casting\n+            // the source array length to an `isize` should be okay.\n+            let start = source.as_mut_ptr().offset(self.index as isize);\n+            let remaining = slice::from_raw_parts_mut(start, remaining_len);\n+            ptr::drop_in_place(remaining);\n+        }\n+    }\n+}\n",
    "diff_parsed": "{'added': [(11, 'use super::Array;'), (12, 'use core::{mem::ManuallyDrop, ptr, slice};'), (15, 'pub struct ArrayIter<T>'), (16, 'where'), (17, '    T: Array,'), (18, '{'), (20, '    source: ManuallyDrop<T>,'), (22, '    index: usize,'), (23, '}'), (25, 'impl<T> ArrayIter<T>'), (26, 'where'), (27, '    T: Array,'), (28, '{'), (30, '    pub fn new(source: T) -> Self {'), (31, '        Self {'), (32, '            source: ManuallyDrop::new(source),'), (33, '            index: 0,'), (34, '        }'), (35, '    }'), (36, '}'), (38, 'impl<T> Iterator for ArrayIter<T>'), (39, 'where'), (40, '    T: Array,'), (41, '{'), (42, '    type Item = T::Item;'), (44, '    fn next(&mut self) -> Option<Self::Item> {'), (45, '        let source = self.source.as_slice();'), (46, '        let index = self.index;'), (47, '        if index < source.len() {'), (48, '            self.index = index + 1;'), (50, '            Some(unsafe { ptr::read(&source[index]) })'), (51, '        } else {'), (52, '            None'), (53, '        }'), (54, '    }'), (55, '}'), (57, 'impl<T> Drop for ArrayIter<T>'), (58, 'where'), (59, '    T: Array,'), (60, '{'), (61, '    fn drop(&mut self) {'), (63, '        let source = self.source.as_mut_slice();'), (64, '        let remaining_len = source.len() - self.index;'), (65, '        unsafe {'), (70, '            let start = source.as_mut_ptr().offset(self.index as isize);'), (71, '            let remaining = slice::from_raw_parts_mut(start, remaining_len);'), (72, '            ptr::drop_in_place(remaining);'), (73, '        }'), (74, '    }'), (75, '}')], 'deleted': []}",
    "num_lines_added": "50",
    "num_lines_deleted": "0",
    "nloc": "50"
  },
  {
    "file_change_id": "161158527203035",
    "hash": "18abedadaa77646cce6f2ca2149c0119a2e4f428",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -820,5 +820,8 @@ pub use scratchpad::*;\n pub use traits::*;\n pub use utility::*;\n \n+mod array_iter;\n+pub(crate) use array_iter::*;\n+\n #[cfg(test)]\n mod tests;\n",
    "diff_parsed": "{'added': [(823, 'mod array_iter;'), (824, 'pub(crate) use array_iter::*;')], 'deleted': []}",
    "num_lines_added": "2",
    "num_lines_deleted": "0",
    "nloc": "53"
  },
  {
    "file_change_id": "231355604065651",
    "hash": "18abedadaa77646cce6f2ca2149c0119a2e4f428",
    "old_path": "src/tests.rs",
    "new_path": "src/tests.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -18,6 +18,9 @@ use core::mem::MaybeUninit;\n #[cfg(any(feature = \"std\", feature = \"alloc\", feature = \"unstable\"))]\n use super::{Box, Vec};\n \n+#[cfg(feature = \"std\")]\n+use std::panic::{self, AssertUnwindSafe};\n+\n // Struct that increments a counter each time it is dropped (used for testing\n // for accidental drops due to incorrect moving of values in unsafe code).\n #[derive(Clone, Debug)]\n@@ -1152,6 +1155,209 @@ fn slice_move_source_collection_boxed_slice_test() {\n     assert_eq!(drop_count.get(), 3);\n }\n \n+/// Verifies array implementations of `SliceMoveSource` do not drop elements\n+/// that have already been moved out of the source during panic unwinds.\n+#[test]\n+#[cfg(feature = \"std\")]\n+fn slice_move_source_array_panic_unwind_test() {\n+    let drop_count = Cell::new(0);\n+    let data = [\n+        DropCounter::new(&drop_count),\n+        DropCounter::new(&drop_count),\n+        DropCounter::new(&drop_count),\n+    ];\n+\n+    let mut move_count = 0;\n+    panic::catch_unwind(AssertUnwindSafe(|| {\n+        data.move_elements(|x| {\n+            move_count += 1;\n+            if move_count == 2 {\n+                panic!();\n+            }\n+\n+            drop(x);\n+        });\n+    }))\n+    .unwrap_or(());\n+\n+    assert_eq!(drop_count.get(), 3);\n+}\n+\n+/// Verifies boxed slice implementations of `SliceMoveSource` do not drop\n+/// elements that have already been moved out of the source during panic\n+/// unwinds.\n+#[test]\n+#[cfg(feature = \"std\")]\n+fn slice_move_source_boxed_slice_panic_unwind_test() {\n+    let drop_count = Cell::new(0);\n+    let data = vec![\n+        DropCounter::new(&drop_count),\n+        DropCounter::new(&drop_count),\n+        DropCounter::new(&drop_count),\n+    ]\n+    .into_boxed_slice();\n+\n+    let mut move_count = 0;\n+    panic::catch_unwind(AssertUnwindSafe(|| {\n+        data.move_elements(|x| {\n+            move_count += 1;\n+            if move_count == 2 {\n+                panic!();\n+            }\n+\n+            drop(x);\n+        });\n+    }))\n+    .unwrap_or(());\n+\n+    assert_eq!(drop_count.get(), 3);\n+}\n+\n+/// Verifies vector implementations of `SliceMoveSource` do not drop elements\n+/// that have already been moved out of the source during panic unwinds.\n+#[test]\n+#[cfg(feature = \"std\")]\n+fn slice_move_source_vec_panic_unwind_test() {\n+    let drop_count = Cell::new(0);\n+    let data = vec![\n+        DropCounter::new(&drop_count),\n+        DropCounter::new(&drop_count),\n+        DropCounter::new(&drop_count),\n+    ];\n+\n+    let mut move_count = 0;\n+    panic::catch_unwind(AssertUnwindSafe(|| {\n+        data.move_elements(|x| {\n+            move_count += 1;\n+            if move_count == 2 {\n+                panic!();\n+            }\n+\n+            drop(x);\n+        });\n+    }))\n+    .unwrap_or(());\n+\n+    assert_eq!(drop_count.get(), 3);\n+}\n+\n+/// Verifies array implementations of `SliceMoveSourceCollection` do not drop\n+/// elements that have already been moved out of the collection during panic\n+/// unwinds.\n+#[test]\n+#[cfg(feature = \"std\")]\n+fn slice_move_source_collection_array_panic_unwind_test() {\n+    let drop_count = Cell::new(0);\n+    let data = [\n+        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],\n+        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],\n+        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],\n+    ];\n+\n+    let mut move_count = 0;\n+    panic::catch_unwind(AssertUnwindSafe(|| {\n+        data.move_all_elements(|x| {\n+            move_count += 1;\n+            if move_count == 3 {\n+                panic!();\n+            }\n+\n+            drop(x);\n+        });\n+    }))\n+    .unwrap_or(());\n+\n+    assert_eq!(drop_count.get(), 6);\n+}\n+\n+/// Verifies boxed slice implementations of `SliceMoveSourceCollection` do not\n+/// drop elements that have already been moved out of the collection during\n+/// panic unwinds.\n+#[test]\n+#[cfg(feature = \"std\")]\n+fn slice_move_source_collection_boxed_slice_panic_unwind_test() {\n+    let drop_count = Cell::new(0);\n+    let data = vec![\n+        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],\n+        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],\n+        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],\n+    ]\n+    .into_boxed_slice();\n+\n+    let mut move_count = 0;\n+    panic::catch_unwind(AssertUnwindSafe(|| {\n+        data.move_all_elements(|x| {\n+            move_count += 1;\n+            if move_count == 3 {\n+                panic!();\n+            }\n+\n+            drop(x);\n+        });\n+    }))\n+    .unwrap_or(());\n+\n+    assert_eq!(drop_count.get(), 6);\n+}\n+\n+/// Verifies vector implementations of `SliceMoveSourceCollection` do not drop\n+/// elements that have already been moved out of the collection during panic\n+/// unwinds.\n+#[test]\n+#[cfg(feature = \"std\")]\n+fn slice_move_source_collection_vec_panic_unwind_test() {\n+    let drop_count = Cell::new(0);\n+    let data = vec![\n+        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],\n+        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],\n+        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],\n+    ];\n+\n+    let mut move_count = 0;\n+    panic::catch_unwind(AssertUnwindSafe(|| {\n+        data.move_all_elements(|x| {\n+            move_count += 1;\n+            if move_count == 3 {\n+                panic!();\n+            }\n+\n+            drop(x);\n+        });\n+    }))\n+    .unwrap_or(());\n+\n+    assert_eq!(drop_count.get(), 6);\n+}\n+\n+/// Verifies tuple implementations of `SliceMoveSourceCollection` do not drop\n+/// elements that have already been moved out of the collection during panic\n+/// unwinds.\n+#[test]\n+#[cfg(feature = \"std\")]\n+fn slice_move_source_collection_tuple_panic_unwind_test() {\n+    let drop_count = Cell::new(0);\n+    let data = (\n+        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],\n+        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],\n+        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],\n+    );\n+\n+    let mut move_count = 0;\n+    panic::catch_unwind(AssertUnwindSafe(|| {\n+        data.move_all_elements(|x| {\n+            move_count += 1;\n+            if move_count == 3 {\n+                panic!();\n+            }\n+\n+            drop(x);\n+        });\n+    }))\n+    .unwrap_or(());\n+\n+    assert_eq!(drop_count.get(), 6);\n+}\n+\n /// Verifies ZST allocations work properly.\n #[test]\n fn zst_test() {\n",
    "diff_parsed": "{'added': [(21, '#[cfg(feature = \"std\")]'), (22, 'use std::panic::{self, AssertUnwindSafe};'), (1160, '#[test]'), (1161, '#[cfg(feature = \"std\")]'), (1162, 'fn slice_move_source_array_panic_unwind_test() {'), (1163, '    let drop_count = Cell::new(0);'), (1164, '    let data = ['), (1165, '        DropCounter::new(&drop_count),'), (1166, '        DropCounter::new(&drop_count),'), (1167, '        DropCounter::new(&drop_count),'), (1168, '    ];'), (1170, '    let mut move_count = 0;'), (1171, '    panic::catch_unwind(AssertUnwindSafe(|| {'), (1172, '        data.move_elements(|x| {'), (1173, '            move_count += 1;'), (1174, '            if move_count == 2 {'), (1175, '                panic!();'), (1176, '            }'), (1178, '            drop(x);'), (1179, '        });'), (1180, '    }))'), (1181, '    .unwrap_or(());'), (1183, '    assert_eq!(drop_count.get(), 3);'), (1184, '}'), (1189, '#[test]'), (1190, '#[cfg(feature = \"std\")]'), (1191, 'fn slice_move_source_boxed_slice_panic_unwind_test() {'), (1192, '    let drop_count = Cell::new(0);'), (1193, '    let data = vec!['), (1194, '        DropCounter::new(&drop_count),'), (1195, '        DropCounter::new(&drop_count),'), (1196, '        DropCounter::new(&drop_count),'), (1197, '    ]'), (1198, '    .into_boxed_slice();'), (1200, '    let mut move_count = 0;'), (1201, '    panic::catch_unwind(AssertUnwindSafe(|| {'), (1202, '        data.move_elements(|x| {'), (1203, '            move_count += 1;'), (1204, '            if move_count == 2 {'), (1205, '                panic!();'), (1206, '            }'), (1208, '            drop(x);'), (1209, '        });'), (1210, '    }))'), (1211, '    .unwrap_or(());'), (1213, '    assert_eq!(drop_count.get(), 3);'), (1214, '}'), (1218, '#[test]'), (1219, '#[cfg(feature = \"std\")]'), (1220, 'fn slice_move_source_vec_panic_unwind_test() {'), (1221, '    let drop_count = Cell::new(0);'), (1222, '    let data = vec!['), (1223, '        DropCounter::new(&drop_count),'), (1224, '        DropCounter::new(&drop_count),'), (1225, '        DropCounter::new(&drop_count),'), (1226, '    ];'), (1228, '    let mut move_count = 0;'), (1229, '    panic::catch_unwind(AssertUnwindSafe(|| {'), (1230, '        data.move_elements(|x| {'), (1231, '            move_count += 1;'), (1232, '            if move_count == 2 {'), (1233, '                panic!();'), (1234, '            }'), (1236, '            drop(x);'), (1237, '        });'), (1238, '    }))'), (1239, '    .unwrap_or(());'), (1241, '    assert_eq!(drop_count.get(), 3);'), (1242, '}'), (1247, '#[test]'), (1248, '#[cfg(feature = \"std\")]'), (1249, 'fn slice_move_source_collection_array_panic_unwind_test() {'), (1250, '    let drop_count = Cell::new(0);'), (1251, '    let data = ['), (1252, '        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],'), (1253, '        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],'), (1254, '        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],'), (1255, '    ];'), (1257, '    let mut move_count = 0;'), (1258, '    panic::catch_unwind(AssertUnwindSafe(|| {'), (1259, '        data.move_all_elements(|x| {'), (1260, '            move_count += 1;'), (1261, '            if move_count == 3 {'), (1262, '                panic!();'), (1263, '            }'), (1265, '            drop(x);'), (1266, '        });'), (1267, '    }))'), (1268, '    .unwrap_or(());'), (1270, '    assert_eq!(drop_count.get(), 6);'), (1271, '}'), (1276, '#[test]'), (1277, '#[cfg(feature = \"std\")]'), (1278, 'fn slice_move_source_collection_boxed_slice_panic_unwind_test() {'), (1279, '    let drop_count = Cell::new(0);'), (1280, '    let data = vec!['), (1281, '        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],'), (1282, '        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],'), (1283, '        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],'), (1284, '    ]'), (1285, '    .into_boxed_slice();'), (1287, '    let mut move_count = 0;'), (1288, '    panic::catch_unwind(AssertUnwindSafe(|| {'), (1289, '        data.move_all_elements(|x| {'), (1290, '            move_count += 1;'), (1291, '            if move_count == 3 {'), (1292, '                panic!();'), (1293, '            }'), (1295, '            drop(x);'), (1296, '        });'), (1297, '    }))'), (1298, '    .unwrap_or(());'), (1300, '    assert_eq!(drop_count.get(), 6);'), (1301, '}'), (1306, '#[test]'), (1307, '#[cfg(feature = \"std\")]'), (1308, 'fn slice_move_source_collection_vec_panic_unwind_test() {'), (1309, '    let drop_count = Cell::new(0);'), (1310, '    let data = vec!['), (1311, '        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],'), (1312, '        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],'), (1313, '        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],'), (1314, '    ];'), (1316, '    let mut move_count = 0;'), (1317, '    panic::catch_unwind(AssertUnwindSafe(|| {'), (1318, '        data.move_all_elements(|x| {'), (1319, '            move_count += 1;'), (1320, '            if move_count == 3 {'), (1321, '                panic!();'), (1322, '            }'), (1324, '            drop(x);'), (1325, '        });'), (1326, '    }))'), (1327, '    .unwrap_or(());'), (1329, '    assert_eq!(drop_count.get(), 6);'), (1330, '}'), (1335, '#[test]'), (1336, '#[cfg(feature = \"std\")]'), (1337, 'fn slice_move_source_collection_tuple_panic_unwind_test() {'), (1338, '    let drop_count = Cell::new(0);'), (1339, '    let data = ('), (1340, '        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],'), (1341, '        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],'), (1342, '        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],'), (1343, '    );'), (1345, '    let mut move_count = 0;'), (1346, '    panic::catch_unwind(AssertUnwindSafe(|| {'), (1347, '        data.move_all_elements(|x| {'), (1348, '            move_count += 1;'), (1349, '            if move_count == 3 {'), (1350, '                panic!();'), (1351, '            }'), (1353, '            drop(x);'), (1354, '        });'), (1355, '    }))'), (1356, '    .unwrap_or(());'), (1358, '    assert_eq!(drop_count.get(), 6);'), (1359, '}')], 'deleted': []}",
    "num_lines_added": "158",
    "num_lines_deleted": "0",
    "nloc": "1074"
  },
  {
    "file_change_id": "277622649088366",
    "hash": "18abedadaa77646cce6f2ca2149c0119a2e4f428",
    "old_path": "src/traits.rs",
    "new_path": "src/traits.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -12,18 +12,16 @@ use core::ptr;\n use core::slice;\n use core::str;\n \n-use super::CacheAligned;\n+use super::{ArrayIter, CacheAligned};\n+use core::mem::size_of;\n #[cfg(any(stable_maybe_uninit, feature = \"unstable\"))]\n use core::mem::MaybeUninit;\n-use core::mem::{forget, size_of};\n \n #[cfg(feature = \"std\")]\n use std::ffi::CStr;\n \n #[cfg(any(feature = \"std\", feature = \"alloc\", feature = \"unstable\"))]\n use super::{Box, Vec};\n-#[cfg(any(feature = \"std\", feature = \"alloc\", feature = \"unstable\"))]\n-use core::mem::ManuallyDrop;\n \n /// Trait for types that can be safely used as the backing data type for\n /// storage of arbitrary data.\n@@ -868,12 +866,8 @@ where\n     where\n         F: FnMut(<T as Array>::Item),\n     {\n-        unsafe {\n-            for item in self.as_slice() {\n-                f(ptr::read(item))\n-            }\n-\n-            forget(self);\n+        for item in ArrayIter::new(self) {\n+            f(item);\n         }\n     }\n }\n@@ -888,7 +882,7 @@ where\n         F: FnMut(<T as SliceLike>::Element),\n     {\n         for item in self.as_element_slice() {\n-            f(*item)\n+            f(*item);\n         }\n     }\n }\n@@ -902,14 +896,13 @@ where\n     where\n         F: FnMut(<T as SliceLike>::Element),\n     {\n-        unsafe {\n-            for item in self.as_element_slice() {\n-                f(ptr::read(item));\n-            }\n-\n+        let boxed_slice = unsafe {\n             Box::from_raw((*Box::into_raw(self)).as_element_slice_mut()\n-                as *mut [<T as SliceLike>::Element]\n-                as *mut [ManuallyDrop<<T as SliceLike>::Element>]);\n+                as *mut [T::Element])\n+        };\n+\n+        for item in boxed_slice.into_vec() {\n+            f(item);\n         }\n     }\n }\n@@ -1138,12 +1131,8 @@ where\n     where\n         F: FnMut(<T as SliceLike>::Element),\n     {\n-        unsafe {\n-            for source in self.as_slice() {\n-                ptr::read(source).move_elements(&mut f);\n-            }\n-\n-            forget(self);\n+        for source in ArrayIter::new(self) {\n+            source.move_elements(&mut f);\n         }\n     }\n }\n@@ -1176,12 +1165,8 @@ where\n     where\n         F: FnMut(<T as SliceLike>::Element),\n     {\n-        unsafe {\n-            for source in &*self {\n-                ptr::read(source).move_elements(&mut f);\n-            }\n-\n-            Box::from_raw(Box::into_raw(self) as *mut [ManuallyDrop<U>]);\n+        for source in self.into_vec() {\n+            source.move_elements(&mut f);\n         }\n     }\n }\n",
    "diff_parsed": "{'added': [(15, 'use super::{ArrayIter, CacheAligned};'), (16, 'use core::mem::size_of;'), (869, '        for item in ArrayIter::new(self) {'), (870, '            f(item);'), (885, '            f(*item);'), (899, '        let boxed_slice = unsafe {'), (901, '                as *mut [T::Element])'), (902, '        };'), (904, '        for item in boxed_slice.into_vec() {'), (905, '            f(item);'), (1134, '        for source in ArrayIter::new(self) {'), (1135, '            source.move_elements(&mut f);'), (1168, '        for source in self.into_vec() {'), (1169, '            source.move_elements(&mut f);')], 'deleted': [(15, 'use super::CacheAligned;'), (18, 'use core::mem::{forget, size_of};'), (25, '#[cfg(any(feature = \"std\", feature = \"alloc\", feature = \"unstable\"))]'), (26, 'use core::mem::ManuallyDrop;'), (871, '        unsafe {'), (872, '            for item in self.as_slice() {'), (873, '                f(ptr::read(item))'), (874, '            }'), (876, '            forget(self);'), (891, '            f(*item)'), (905, '        unsafe {'), (906, '            for item in self.as_element_slice() {'), (907, '                f(ptr::read(item));'), (908, '            }'), (911, '                as *mut [<T as SliceLike>::Element]'), (912, '                as *mut [ManuallyDrop<<T as SliceLike>::Element>]);'), (1141, '        unsafe {'), (1142, '            for source in self.as_slice() {'), (1143, '                ptr::read(source).move_elements(&mut f);'), (1144, '            }'), (1146, '            forget(self);'), (1179, '        unsafe {'), (1180, '            for source in &*self {'), (1181, '                ptr::read(source).move_elements(&mut f);'), (1182, '            }'), (1184, '            Box::from_raw(Box::into_raw(self) as *mut [ManuallyDrop<U>]);')]}",
    "num_lines_added": "14",
    "num_lines_deleted": "26",
    "nloc": "769"
  },
  {
    "file_change_id": "223217532484110",
    "hash": "6b83f9d0708337a9f8b709c1624a8587021ceba2",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -224,11 +224,13 @@ impl<T> Arena<T> {\n         &'a mut self,\n         selected: I,\n     ) -> Option<(&mut T, ArenaSplit<'a, T>)> {\n-        if let Some(value) = self.get_mut(selected.borrow()) {\n+        let selected = selected.borrow();\n+\n+        if let Some(value) = self.get_mut(selected) {\n             Some((\n                 unsafe { (value as *mut T).as_mut().unwrap() },\n                 ArenaSplit {\n-                    selected: selected.borrow().clone(),\n+                    selected: selected.clone(),\n                     arena: self,\n                     __type: Default::default(),\n                 },\n@@ -421,6 +423,7 @@ impl<T> Into<Vec<T>> for Arena<T> {\n #[cfg(test)]\n mod tests {\n     use super::*;\n+    use std::cell::Cell;\n \n     fn setup_arena() -> (Arena<String>, Idx, Idx, Idx, Idx) {\n         let mut arena = Arena::new();\n@@ -707,4 +710,54 @@ mod tests {\n \n         assert_eq!(format!(\"{:?}\", john), \"Removed Idx ( 0 )\");\n     }\n+\n+    #[test]\n+    fn compare_should_work_for_idx() {\n+        let mut arena = Arena::new();\n+        let left = arena.alloc(1);\n+        let right = left.clone();\n+\n+        assert!(left.borrow() == right.borrow());\n+    }\n+\n+    #[test]\n+    fn splitting_should_be_safe() {\n+        // A bug described here (https://github.com/bennetthardwick/nano-arena/issues/1) meant that\n+        // multiple mutable references could be handed out.\n+\n+        struct ToggleIdx {\n+            first: Idx,\n+            second: Idx,\n+            state: Cell<bool>,\n+        }\n+\n+        impl Borrow<Idx> for ToggleIdx {\n+            fn borrow(&self) -> &Idx {\n+                self.state.set(!self.state.get());\n+\n+                if self.state.get() {\n+                    &self.first\n+                } else {\n+                    &self.second\n+                }\n+            }\n+        }\n+\n+        let mut arena = Arena::new();\n+\n+        let first = arena.alloc(1);\n+        let second = arena.alloc(2);\n+\n+        let toggle_idx = ToggleIdx {\n+            first: first.clone(),\n+            second: second.clone(),\n+            state: Cell::new(false),\n+        };\n+\n+        let (first_mut_ref, mut split_arena) = arena.split_at(toggle_idx).unwrap();\n+        let second_mut_ref = split_arena.get_mut(&first);\n+\n+        drop(first_mut_ref);\n+        assert!(second_mut_ref.is_none());\n+    }\n }\n",
    "diff_parsed": "{'added': [(227, '        let selected = selected.borrow();'), (229, '        if let Some(value) = self.get_mut(selected) {'), (233, '                    selected: selected.clone(),'), (426, '    use std::cell::Cell;'), (714, '    #[test]'), (715, '    fn compare_should_work_for_idx() {'), (716, '        let mut arena = Arena::new();'), (717, '        let left = arena.alloc(1);'), (718, '        let right = left.clone();'), (720, '        assert!(left.borrow() == right.borrow());'), (721, '    }'), (723, '    #[test]'), (724, '    fn splitting_should_be_safe() {'), (728, '        struct ToggleIdx {'), (729, '            first: Idx,'), (730, '            second: Idx,'), (731, '            state: Cell<bool>,'), (732, '        }'), (734, '        impl Borrow<Idx> for ToggleIdx {'), (735, '            fn borrow(&self) -> &Idx {'), (736, '                self.state.set(!self.state.get());'), (738, '                if self.state.get() {'), (739, '                    &self.first'), (740, '                } else {'), (741, '                    &self.second'), (742, '                }'), (743, '            }'), (744, '        }'), (746, '        let mut arena = Arena::new();'), (748, '        let first = arena.alloc(1);'), (749, '        let second = arena.alloc(2);'), (751, '        let toggle_idx = ToggleIdx {'), (752, '            first: first.clone(),'), (753, '            second: second.clone(),'), (754, '            state: Cell::new(false),'), (755, '        };'), (757, '        let (first_mut_ref, mut split_arena) = arena.split_at(toggle_idx).unwrap();'), (758, '        let second_mut_ref = split_arena.get_mut(&first);'), (760, '        drop(first_mut_ref);'), (761, '        assert!(second_mut_ref.is_none());'), (762, '    }')], 'deleted': [(227, '        if let Some(value) = self.get_mut(selected.borrow()) {'), (231, '                    selected: selected.borrow().clone(),')]}",
    "num_lines_added": "41",
    "num_lines_deleted": "2",
    "nloc": "633"
  },
  {
    "file_change_id": "119192690608373",
    "hash": "dfeb84bfce2be11327749c152b3c8f4ea4304e12",
    "old_path": "src/access.rs",
    "new_path": "src/access.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,3 +1,5 @@\n+#![deny(unsafe_code)]\n+\n //! Abstracting over accessing parts of stored value.\n //!\n //! Sometimes, there's a big globalish data structure (like a configuration for the whole program).\n@@ -205,39 +207,20 @@ where\n \n #[doc(hidden)]\n #[derive(Copy, Clone, Debug)]\n-pub struct MapGuard<G, T> {\n-    _guard: G,\n-    value: *const T,\n-}\n-\n-// Why these are safe:\n-// * The *const T is actually used just as a &const T with 'self lifetime (which can't be done in\n-//   Rust). So if the reference is Send/Sync, so is the raw pointer.\n-unsafe impl<G, T> Send for MapGuard<G, T>\n-where\n-    G: Send,\n-    for<'a> &'a T: Send,\n-{\n+pub struct MapGuard<G, F, T, R> {\n+    guard: G,\n+    projection: F,\n+    _t: PhantomData<fn(&T) -> &R>,\n }\n \n-unsafe impl<G, T> Sync for MapGuard<G, T>\n+impl<G, F, T, R> Deref for MapGuard<G, F, T, R>\n where\n-    G: Sync,\n-    for<'a> &'a T: Sync,\n+    G: Deref<Target = T>,\n+    F: Fn(&T) -> &R,\n {\n-}\n-\n-impl<G, T> Deref for MapGuard<G, T> {\n-    type Target = T;\n-    fn deref(&self) -> &T {\n-        // Why this is safe:\n-        // * The pointer is originally converted from a reference. It's not null, it's aligned,\n-        //   it's the right type, etc.\n-        // * The pointee couldn't have gone away \u2012 the guard keeps the original reference alive, so\n-        //   must the new one still be alive too. Moving the guard is fine, we assume the RefCnt is\n-        //   Pin (because it's Arc or Rc or something like that \u2012 when that one moves, the data it\n-        //   points to stay at the same place).\n-        unsafe { &*self.value }\n+    type Target = R;\n+    fn deref(&self) -> &R {\n+        (self.projection)(&self.guard)\n     }\n }\n \n@@ -266,7 +249,7 @@ impl<A, T, F> Map<A, T, F> {\n     ///   *cheap* (like only taking reference).\n     pub fn new<R>(access: A, projection: F) -> Self\n     where\n-        F: Fn(&T) -> &R,\n+        F: Fn(&T) -> &R + Clone,\n     {\n         Map {\n             access,\n@@ -276,18 +259,18 @@ impl<A, T, F> Map<A, T, F> {\n     }\n }\n \n-impl<A, T, F, R> Access<R> for Map<A, T, F>\n+impl<A, F, T, R> Access<R> for Map<A, T, F>\n where\n     A: Access<T>,\n-    F: Fn(&T) -> &R,\n+    F: Fn(&T) -> &R + Clone,\n {\n-    type Guard = MapGuard<A::Guard, R>;\n+    type Guard = MapGuard<A::Guard, F, T, R>;\n     fn load(&self) -> Self::Guard {\n         let guard = self.access.load();\n-        let value: *const _ = (self.projection)(&guard);\n         MapGuard {\n-            _guard: guard,\n-            value,\n+            guard,\n+            projection: self.projection.clone(),\n+            _t: PhantomData,\n         }\n     }\n }\n",
    "diff_parsed": "{'added': [(1, '#![deny(unsafe_code)]'), (210, 'pub struct MapGuard<G, F, T, R> {'), (211, '    guard: G,'), (212, '    projection: F,'), (213, '    _t: PhantomData<fn(&T) -> &R>,'), (216, 'impl<G, F, T, R> Deref for MapGuard<G, F, T, R>'), (218, '    G: Deref<Target = T>,'), (219, '    F: Fn(&T) -> &R,'), (221, '    type Target = R;'), (222, '    fn deref(&self) -> &R {'), (223, '        (self.projection)(&self.guard)'), (252, '        F: Fn(&T) -> &R + Clone,'), (262, 'impl<A, F, T, R> Access<R> for Map<A, T, F>'), (265, '    F: Fn(&T) -> &R + Clone,'), (267, '    type Guard = MapGuard<A::Guard, F, T, R>;'), (271, '            guard,'), (272, '            projection: self.projection.clone(),'), (273, '            _t: PhantomData,')], 'deleted': [(208, 'pub struct MapGuard<G, T> {'), (209, '    _guard: G,'), (210, '    value: *const T,'), (211, '}'), (216, 'unsafe impl<G, T> Send for MapGuard<G, T>'), (217, 'where'), (218, '    G: Send,'), (219, \"    for<'a> &'a T: Send,\"), (220, '{'), (223, 'unsafe impl<G, T> Sync for MapGuard<G, T>'), (225, '    G: Sync,'), (226, \"    for<'a> &'a T: Sync,\"), (228, '}'), (230, 'impl<G, T> Deref for MapGuard<G, T> {'), (231, '    type Target = T;'), (232, '    fn deref(&self) -> &T {'), (240, '        unsafe { &*self.value }'), (269, '        F: Fn(&T) -> &R,'), (279, 'impl<A, T, F, R> Access<R> for Map<A, T, F>'), (282, '    F: Fn(&T) -> &R,'), (284, '    type Guard = MapGuard<A::Guard, R>;'), (287, '        let value: *const _ = (self.projection)(&guard);'), (289, '            _guard: guard,'), (290, '            value,')]}",
    "num_lines_added": "18",
    "num_lines_deleted": "24",
    "nloc": "253"
  },
  {
    "file_change_id": "183013015100195",
    "hash": "dfeb84bfce2be11327749c152b3c8f4ea4304e12",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -660,7 +660,7 @@ impl<T: RefCnt, S: Strategy<T>> ArcSwapAny<T, S> {\n     /// ```\n     pub fn map<I, R, F>(&self, f: F) -> Map<&Self, I, F>\n     where\n-        F: Fn(&I) -> &R,\n+        F: Fn(&I) -> &R + Clone,\n         Self: Access<I>,\n     {\n         Map::new(self, f)\n",
    "diff_parsed": "{'added': [(663, '        F: Fn(&I) -> &R + Clone,')], 'deleted': [(663, '        F: Fn(&I) -> &R,')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "598"
  },
  {
    "file_change_id": "39605958652818",
    "hash": "340f893dbc9db3e43c6315b05eff4b0b150220d2",
    "old_path": "nanorand/src/tls.rs",
    "new_path": "nanorand/src/tls.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,32 +1,27 @@\n-use crate::WyRand;\n-use std::{\n-\tcell::UnsafeCell,\n-\tops::{Deref, DerefMut},\n-\trc::Rc,\n-};\n+use crate::{Rng, WyRand};\n+use std::{cell::RefCell, rc::Rc};\n \n thread_local! {\n-\tstatic WYRAND: Rc<UnsafeCell<WyRand>> = Rc::new(UnsafeCell::new(WyRand::new()));\n+\tstatic WYRAND: Rc<RefCell<WyRand>> = Rc::new(RefCell::new(WyRand::new()));\n }\n \n+#[derive(Clone)]\n #[doc(hidden)]\n-pub struct TlsWyRand(Rc<UnsafeCell<WyRand>>);\n+pub struct TlsWyRand(Rc<RefCell<WyRand>>);\n \n-impl Deref for TlsWyRand {\n-\ttype Target = WyRand;\n+impl Rng for TlsWyRand {\n+\ttype Output = [u8; 8];\n \n-\t/// Safety: [`TlsWyRand`] is neither [Send] nor [Sync], and thus,\n-\t/// there will always be a thread-local [`WyRand`] when there is a [`TlsWyRand`]\n-\tfn deref(&self) -> &Self::Target {\n-\t\tunsafe { &*self.0.get() }\n+\tfn rand(&mut self) -> Self::Output {\n+\t\tself.0.borrow_mut().rand()\n+\t}\n+\n+\tfn rand_with_seed(seed: &[u8]) -> Self::Output {\n+\t\tWyRand::rand_with_seed(seed)\n \t}\n-}\n \n-impl DerefMut for TlsWyRand {\n-\t/// Safety: [`TlsWyRand`] is neither [Send] nor [Sync], and thus,\n-\t/// there will always be a thread-local [`WyRand`] when there is a [`TlsWyRand`]\n-\tfn deref_mut(&mut self) -> &mut Self::Target {\n-\t\tunsafe { &mut *(*self.0).get() }\n+\tfn reseed(&mut self, new_seed: &[u8]) {\n+\t\tself.0.borrow_mut().reseed(new_seed)\n \t}\n }\n \n",
    "diff_parsed": "{'added': [(1, 'use crate::{Rng, WyRand};'), (2, 'use std::{cell::RefCell, rc::Rc};'), (5, '\\tstatic WYRAND: Rc<RefCell<WyRand>> = Rc::new(RefCell::new(WyRand::new()));'), (8, '#[derive(Clone)]'), (10, 'pub struct TlsWyRand(Rc<RefCell<WyRand>>);'), (12, 'impl Rng for TlsWyRand {'), (13, '\\ttype Output = [u8; 8];'), (15, '\\tfn rand(&mut self) -> Self::Output {'), (16, '\\t\\tself.0.borrow_mut().rand()'), (17, '\\t}'), (19, '\\tfn rand_with_seed(seed: &[u8]) -> Self::Output {'), (20, '\\t\\tWyRand::rand_with_seed(seed)'), (23, '\\tfn reseed(&mut self, new_seed: &[u8]) {'), (24, '\\t\\tself.0.borrow_mut().reseed(new_seed)')], 'deleted': [(1, 'use crate::WyRand;'), (2, 'use std::{'), (3, '\\tcell::UnsafeCell,'), (4, '\\tops::{Deref, DerefMut},'), (5, '\\trc::Rc,'), (6, '};'), (9, '\\tstatic WYRAND: Rc<UnsafeCell<WyRand>> = Rc::new(UnsafeCell::new(WyRand::new()));'), (13, 'pub struct TlsWyRand(Rc<UnsafeCell<WyRand>>);'), (15, 'impl Deref for TlsWyRand {'), (16, '\\ttype Target = WyRand;'), (20, '\\tfn deref(&self) -> &Self::Target {'), (21, '\\t\\tunsafe { &*self.0.get() }'), (23, '}'), (25, 'impl DerefMut for TlsWyRand {'), (28, '\\tfn deref_mut(&mut self) -> &mut Self::Target {'), (29, '\\t\\tunsafe { &mut *(*self.0).get() }')]}",
    "num_lines_added": "14",
    "num_lines_deleted": "16",
    "nloc": "23"
  },
  {
    "file_change_id": "186035882032733",
    "hash": "1660818b60832fdf58b982a37d81f5ef10abe0be",
    "old_path": "build/cg/struct.rs",
    "new_path": "build/cg/struct.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1459,27 +1459,71 @@ impl CodeGen {\n                     if let Some(doc) = doc {\n                         doc.emit(out, 1)?;\n                     }\n-                    writeln!(out, \"    pub fn {}(&self{}) -> &str {{\", name, params)?;\n+                    // String returned from X may not be valid utf-8.\n+                    // To overcome this, we provide two methods:\n+                    //   - one that returns Result<&str, Utf8Error>\n+                    //   - one that returns &[u8]\n+                    // see rust-xcb#96\n+                    writeln!(\n+                        out,\n+                        \"{}pub fn {}(&self{}) -> Result<&str, std::str::Utf8Error> {{\",\n+                        cg::ind(1),\n+                        name,\n+                        params\n+                    )?;\n \n-                    writeln!(out, \"        unsafe {{\")?;\n+                    writeln!(out, \"{}unsafe {{\", cg::ind(2))?;\n                     writeln!(\n                         out,\n-                        \"            let offset = {};\",\n+                        \"{}let offset = {};\",\n+                        cg::ind(3),\n                         self.build_rs_expr(wire_off, \"self.\", \"()\", fields)\n                     )?;\n                     writeln!(\n                         out,\n-                        \"            let len = {} as _;\",\n+                        \"{}let len = {} as _;\",\n+                        cg::ind(3),\n                         self.build_rs_expr(len_expr, \"self.\", \"()\", fields)\n                     )?;\n-                    writeln!(out, \"            let ptr = self.wire_ptr().add(offset);\",)?;\n+                    writeln!(out, \"{}let ptr = self.wire_ptr().add(offset);\", cg::ind(3))?;\n                     writeln!(\n                         out,\n-                        \"            let utf8 = std::slice::from_raw_parts(ptr, len);\",\n+                        \"{}let raw = std::slice::from_raw_parts(ptr, len);\",\n+                        cg::ind(3)\n                     )?;\n-                    writeln!(out, \"            std::str::from_utf8(utf8).unwrap()\")?;\n-                    writeln!(out, \"        }}\")?;\n-                    writeln!(out, \"    }}\")?;\n+                    writeln!(out, \"{}std::str::from_utf8(raw)\", cg::ind(3))?;\n+                    writeln!(out, \"{}}}\", cg::ind(2))?;\n+                    writeln!(out, \"{}}}\", cg::ind(1))?;\n+\n+                    writeln!(out)?;\n+                    if let Some(doc) = doc {\n+                        doc.emit(out, 1)?;\n+                    }\n+                    writeln!(\n+                        out,\n+                        \"{}pub fn {}_raw(&self{}) -> &[u8] {{\",\n+                        cg::ind(1),\n+                        name,\n+                        params\n+                    )?;\n+\n+                    writeln!(out, \"{}unsafe {{\", cg::ind(2))?;\n+                    writeln!(\n+                        out,\n+                        \"{}let offset = {};\",\n+                        cg::ind(3),\n+                        self.build_rs_expr(wire_off, \"self.\", \"()\", fields)\n+                    )?;\n+                    writeln!(\n+                        out,\n+                        \"{}let len = {} as _;\",\n+                        cg::ind(3),\n+                        self.build_rs_expr(len_expr, \"self.\", \"()\", fields)\n+                    )?;\n+                    writeln!(out, \"{}let ptr = self.wire_ptr().add(offset);\", cg::ind(3))?;\n+                    writeln!(out, \"{}std::slice::from_raw_parts(ptr, len)\", cg::ind(3))?;\n+                    writeln!(out, \"{}}}\", cg::ind(2))?;\n+                    writeln!(out, \"{}}}\", cg::ind(1))?;\n                 }\n                 Field::List {\n                     name,\n",
    "diff_parsed": "{'added': [(1467, '                    writeln!('), (1468, '                        out,'), (1469, '                        \"{}pub fn {}(&self{}) -> Result<&str, std::str::Utf8Error> {{\",'), (1470, '                        cg::ind(1),'), (1471, '                        name,'), (1472, '                        params'), (1473, '                    )?;'), (1475, '                    writeln!(out, \"{}unsafe {{\", cg::ind(2))?;'), (1478, '                        \"{}let offset = {};\",'), (1479, '                        cg::ind(3),'), (1484, '                        \"{}let len = {} as _;\",'), (1485, '                        cg::ind(3),'), (1488, '                    writeln!(out, \"{}let ptr = self.wire_ptr().add(offset);\", cg::ind(3))?;'), (1491, '                        \"{}let raw = std::slice::from_raw_parts(ptr, len);\",'), (1492, '                        cg::ind(3)'), (1494, '                    writeln!(out, \"{}std::str::from_utf8(raw)\", cg::ind(3))?;'), (1495, '                    writeln!(out, \"{}}}\", cg::ind(2))?;'), (1496, '                    writeln!(out, \"{}}}\", cg::ind(1))?;'), (1498, '                    writeln!(out)?;'), (1499, '                    if let Some(doc) = doc {'), (1500, '                        doc.emit(out, 1)?;'), (1501, '                    }'), (1502, '                    writeln!('), (1503, '                        out,'), (1504, '                        \"{}pub fn {}_raw(&self{}) -> &[u8] {{\",'), (1505, '                        cg::ind(1),'), (1506, '                        name,'), (1507, '                        params'), (1508, '                    )?;'), (1510, '                    writeln!(out, \"{}unsafe {{\", cg::ind(2))?;'), (1511, '                    writeln!('), (1512, '                        out,'), (1513, '                        \"{}let offset = {};\",'), (1514, '                        cg::ind(3),'), (1515, '                        self.build_rs_expr(wire_off, \"self.\", \"()\", fields)'), (1516, '                    )?;'), (1517, '                    writeln!('), (1518, '                        out,'), (1519, '                        \"{}let len = {} as _;\",'), (1520, '                        cg::ind(3),'), (1521, '                        self.build_rs_expr(len_expr, \"self.\", \"()\", fields)'), (1522, '                    )?;'), (1523, '                    writeln!(out, \"{}let ptr = self.wire_ptr().add(offset);\", cg::ind(3))?;'), (1524, '                    writeln!(out, \"{}std::slice::from_raw_parts(ptr, len)\", cg::ind(3))?;'), (1525, '                    writeln!(out, \"{}}}\", cg::ind(2))?;'), (1526, '                    writeln!(out, \"{}}}\", cg::ind(1))?;')], 'deleted': [(1462, '                    writeln!(out, \"    pub fn {}(&self{}) -> &str {{\", name, params)?;'), (1464, '                    writeln!(out, \"        unsafe {{\")?;'), (1467, '                        \"            let offset = {};\",'), (1472, '                        \"            let len = {} as _;\",'), (1475, '                    writeln!(out, \"            let ptr = self.wire_ptr().add(offset);\",)?;'), (1478, '                        \"            let utf8 = std::slice::from_raw_parts(ptr, len);\",'), (1480, '                    writeln!(out, \"            std::str::from_utf8(utf8).unwrap()\")?;'), (1481, '                    writeln!(out, \"        }}\")?;'), (1482, '                    writeln!(out, \"    }}\")?;')]}",
    "num_lines_added": "46",
    "num_lines_deleted": "9",
    "nloc": "1818"
  },
  {
    "file_change_id": "28571218207488",
    "hash": "6299af0ab17f070a78b75367e14b9101c29ce475",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -134,8 +134,7 @@ impl<'a> Record<'a> {\n             return Err(Error::RecordTooShort(len));\n         }\n \n-        data.reserve(len - 5);\n-        unsafe { data.set_len(len) };\n+        data.resize(len, 0);\n         input.read_exact(&mut data[5..len])?;\n \n         let data_offset = misc::read_dec_5(&data[12..17])?;\n",
    "diff_parsed": "{'added': [(137, '        data.resize(len, 0);')], 'deleted': [(137, '        data.reserve(len - 5);'), (138, '        unsafe { data.set_len(len) };')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "2",
    "nloc": "1048"
  },
  {
    "file_change_id": "75320440089332",
    "hash": "0867ad5c15fa52b7af3fc840ee7a1e256c469942",
    "old_path": "src/proto/h1/role.rs",
    "new_path": "src/proto/h1/role.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -780,31 +780,44 @@ impl Client {\n \n impl Client {\n     fn set_length(head: &mut RequestHead, body: Option<BodyLength>) -> Encoder {\n-        if let Some(body) = body {\n-            let can_chunked = head.version == Version::HTTP_11\n-                && (head.subject.0 != Method::HEAD)\n-                && (head.subject.0 != Method::GET)\n-                && (head.subject.0 != Method::CONNECT);\n-            set_length(&mut head.headers, body, can_chunked)\n+        let body = if let Some(body) = body {\n+            body\n         } else {\n             head.headers.remove(header::TRANSFER_ENCODING);\n-            Encoder::length(0)\n-        }\n-    }\n-}\n+            return Encoder::length(0)\n+        };\n+\n+        // HTTP/1.0 doesn't know about chunked\n+        let can_chunked = head.version == Version::HTTP_11;\n+        let headers = &mut head.headers;\n+\n+        // If the user already set specific headers, we should respect them, regardless\n+        // of what the Payload knows about itself. They set them for a reason.\n \n-fn set_length(headers: &mut HeaderMap, body: BodyLength, can_chunked: bool) -> Encoder {\n-    // If the user already set specific headers, we should respect them, regardless\n-    // of what the Payload knows about itself. They set them for a reason.\n+        // Because of the borrow checker, we can't check the for an existing\n+        // Content-Length header while holding an `Entry` for the Transfer-Encoding\n+        // header, so unfortunately, we must do the check here, first.\n \n-    // Because of the borrow checker, we can't check the for an existing\n-    // Content-Length header while holding an `Entry` for the Transfer-Encoding\n-    // header, so unfortunately, we must do the check here, first.\n+        let existing_con_len = headers::content_length_parse_all(headers);\n+        let mut should_remove_con_len = false;\n \n-    let existing_con_len = headers::content_length_parse_all(headers);\n-    let mut should_remove_con_len = false;\n+        if !can_chunked {\n+            // Chunked isn't legal, so if it is set, we need to remove it.\n+            if headers.remove(header::TRANSFER_ENCODING).is_some() {\n+                trace!(\"removing illegal transfer-encoding header\");\n+            }\n+\n+            return if let Some(len) = existing_con_len {\n+                Encoder::length(len)\n+            } else if let BodyLength::Known(len) = body {\n+                set_content_length(headers, len)\n+            } else {\n+                // HTTP/1.0 client requests without a content-length\n+                // cannot have any body at all.\n+                Encoder::length(0)\n+            };\n+        }\n \n-    if can_chunked {\n         // If the user set a transfer-encoding, respect that. Let's just\n         // make sure `chunked` is the final encoding.\n         let encoder = match headers.entry(header::TRANSFER_ENCODING)\n@@ -840,9 +853,22 @@ fn set_length(headers: &mut HeaderMap, body: BodyLength, can_chunked: bool) -> E\n                 if let Some(len) = existing_con_len {\n                     Some(Encoder::length(len))\n                 } else if let BodyLength::Unknown = body {\n-                    should_remove_con_len = true;\n-                    te.insert(HeaderValue::from_static(\"chunked\"));\n-                    Some(Encoder::chunked())\n+                    // GET, HEAD, and CONNECT almost never have bodies.\n+                    //\n+                    // So instead of sending a \"chunked\" body with a 0-chunk,\n+                    // assume no body here. If you *must* send a body,\n+                    // set the headers explicitly.\n+                    match head.subject.0 {\n+                        Method::GET |\n+                        Method::HEAD |\n+                        Method::CONNECT => {\n+                            Some(Encoder::length(0))\n+                        },\n+                        _ => {\n+                            te.insert(HeaderValue::from_static(\"chunked\"));\n+                            Some(Encoder::chunked())\n+                        },\n+                    }\n                 } else {\n                     None\n                 }\n@@ -868,27 +894,6 @@ fn set_length(headers: &mut HeaderMap, body: BodyLength, can_chunked: bool) -> E\n         };\n \n         set_content_length(headers, len)\n-    } else {\n-        // Chunked isn't legal, so if it is set, we need to remove it.\n-        // Also, if it *is* set, then we shouldn't replace with a length,\n-        // since the user tried to imply there isn't a length.\n-        let encoder = if headers.remove(header::TRANSFER_ENCODING).is_some() {\n-            trace!(\"removing illegal transfer-encoding header\");\n-            should_remove_con_len = true;\n-            Encoder::close_delimited()\n-        } else if let Some(len) = existing_con_len {\n-            Encoder::length(len)\n-        } else if let BodyLength::Known(len) = body {\n-            set_content_length(headers, len)\n-        } else {\n-            Encoder::close_delimited()\n-        };\n-\n-        if should_remove_con_len && existing_con_len.is_some() {\n-            headers.remove(header::CONTENT_LENGTH);\n-        }\n-\n-        encoder\n     }\n }\n \n",
    "diff_parsed": "{'added': [(783, '        let body = if let Some(body) = body {'), (784, '            body'), (787, '            return Encoder::length(0)'), (788, '        };'), (791, '        let can_chunked = head.version == Version::HTTP_11;'), (792, '        let headers = &mut head.headers;'), (801, '        let existing_con_len = headers::content_length_parse_all(headers);'), (802, '        let mut should_remove_con_len = false;'), (804, '        if !can_chunked {'), (806, '            if headers.remove(header::TRANSFER_ENCODING).is_some() {'), (807, '                trace!(\"removing illegal transfer-encoding header\");'), (808, '            }'), (810, '            return if let Some(len) = existing_con_len {'), (811, '                Encoder::length(len)'), (812, '            } else if let BodyLength::Known(len) = body {'), (813, '                set_content_length(headers, len)'), (814, '            } else {'), (817, '                Encoder::length(0)'), (818, '            };'), (819, '        }'), (861, '                    match head.subject.0 {'), (862, '                        Method::GET |'), (863, '                        Method::HEAD |'), (864, '                        Method::CONNECT => {'), (865, '                            Some(Encoder::length(0))'), (866, '                        },'), (867, '                        _ => {'), (868, '                            te.insert(HeaderValue::from_static(\"chunked\"));'), (869, '                            Some(Encoder::chunked())'), (870, '                        },'), (871, '                    }')], 'deleted': [(783, '        if let Some(body) = body {'), (784, '            let can_chunked = head.version == Version::HTTP_11'), (785, '                && (head.subject.0 != Method::HEAD)'), (786, '                && (head.subject.0 != Method::GET)'), (787, '                && (head.subject.0 != Method::CONNECT);'), (788, '            set_length(&mut head.headers, body, can_chunked)'), (791, '            Encoder::length(0)'), (792, '        }'), (793, '    }'), (794, '}'), (796, 'fn set_length(headers: &mut HeaderMap, body: BodyLength, can_chunked: bool) -> Encoder {'), (804, '    let existing_con_len = headers::content_length_parse_all(headers);'), (805, '    let mut should_remove_con_len = false;'), (807, '    if can_chunked {'), (843, '                    should_remove_con_len = true;'), (844, '                    te.insert(HeaderValue::from_static(\"chunked\"));'), (845, '                    Some(Encoder::chunked())'), (871, '    } else {'), (875, '        let encoder = if headers.remove(header::TRANSFER_ENCODING).is_some() {'), (876, '            trace!(\"removing illegal transfer-encoding header\");'), (877, '            should_remove_con_len = true;'), (878, '            Encoder::close_delimited()'), (879, '        } else if let Some(len) = existing_con_len {'), (880, '            Encoder::length(len)'), (881, '        } else if let BodyLength::Known(len) = body {'), (882, '            set_content_length(headers, len)'), (883, '        } else {'), (884, '            Encoder::close_delimited()'), (885, '        };'), (887, '        if should_remove_con_len && existing_con_len.is_some() {'), (888, '            headers.remove(header::CONTENT_LENGTH);'), (889, '        }'), (891, '        encoder')]}",
    "num_lines_added": "31",
    "num_lines_deleted": "33",
    "nloc": "1341"
  },
  {
    "file_change_id": "68621860399858",
    "hash": "0867ad5c15fa52b7af3fc840ee7a1e256c469942",
    "old_path": "tests/client.rs",
    "new_path": "tests/client.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -353,7 +353,7 @@ test! {\n }\n \n test! {\n-    name: client_get_implicitly_empty,\n+    name: client_get_req_body_implicitly_empty,\n \n     server:\n         expected: \"GET / HTTP/1.1\\r\\nhost: {addr}\\r\\n\\r\\n\",\n@@ -367,9 +367,153 @@ test! {\n         },\n         response:\n             status: OK,\n+            headers: {},\n+            body: None,\n+}\n+\n+test! {\n+    name: client_get_req_body_chunked,\n+\n+    server:\n+        expected: \"\\\n+            GET / HTTP/1.1\\r\\n\\\n+            transfer-encoding: chunked\\r\\n\\\n+            host: {addr}\\r\\n\\\n+            \\r\\n\\\n+            5\\r\\n\\\n+            hello\\r\\n\\\n+            0\\r\\n\\r\\n\\\n+            \",\n+        reply: REPLY_OK,\n+\n+    client:\n+        request: {\n+            method: GET,\n+            url: \"http://{addr}/\",\n             headers: {\n-                \"Content-Length\" => \"0\",\n+                \"transfer-encoding\" => \"chunked\",\n+            },\n+            body: \"hello\", // not Body::empty\n+        },\n+        response:\n+            status: OK,\n+            headers: {},\n+            body: None,\n+}\n+\n+test! {\n+    name: client_get_req_body_chunked_http10,\n+\n+    server:\n+        expected: \"\\\n+            GET / HTTP/1.0\\r\\n\\\n+            host: {addr}\\r\\n\\\n+            content-length: 5\\r\\n\\\n+            \\r\\n\\\n+            hello\\\n+            \",\n+        reply: \"HTTP/1.0 200 OK\\r\\ncontent-length: 0\\r\\n\\r\\n\",\n+\n+    client:\n+        request: {\n+            method: GET,\n+            url: \"http://{addr}/\",\n+            headers: {\n+                \"transfer-encoding\" => \"chunked\",\n+            },\n+            version: HTTP_10,\n+            body: \"hello\",\n+        },\n+        response:\n+            status: OK,\n+            headers: {},\n+            body: None,\n+}\n+\n+test! {\n+    name: client_get_req_body_sized,\n+\n+    server:\n+        expected: \"\\\n+            GET / HTTP/1.1\\r\\n\\\n+            content-length: 5\\r\\n\\\n+            host: {addr}\\r\\n\\\n+            \\r\\n\\\n+            hello\\\n+            \",\n+        reply: REPLY_OK,\n+\n+    client:\n+        request: {\n+            method: GET,\n+            url: \"http://{addr}/\",\n+            headers: {\n+                \"Content-Length\" => \"5\",\n+            },\n+            body: (Body::wrap_stream(Body::from(\"hello\"))),\n+        },\n+        response:\n+            status: OK,\n+            headers: {},\n+            body: None,\n+}\n+\n+test! {\n+    name: client_get_req_body_unknown,\n+\n+    server:\n+        expected: \"\\\n+            GET / HTTP/1.1\\r\\n\\\n+            host: {addr}\\r\\n\\\n+            \\r\\n\\\n+            \",\n+        reply: REPLY_OK,\n+\n+    client:\n+        request: {\n+            method: GET,\n+            url: \"http://{addr}/\",\n+            // wrap_steam means we don't know the content-length,\n+            // but we're wrapping a non-empty stream.\n+            //\n+            // But since the headers cannot tell us, and the method typically\n+            // doesn't have a body, the body must be ignored.\n+            body: (Body::wrap_stream(Body::from(\"hello\"))),\n+        },\n+        response:\n+            status: OK,\n+            headers: {},\n+            body: None,\n+}\n+\n+test! {\n+    name: client_get_req_body_unknown_http10,\n+\n+    server:\n+        expected: \"\\\n+            GET / HTTP/1.0\\r\\n\\\n+            host: {addr}\\r\\n\\\n+            \\r\\n\\\n+            \",\n+        reply: \"HTTP/1.0 200 OK\\r\\ncontent-length: 0\\r\\n\\r\\n\",\n+\n+    client:\n+        request: {\n+            method: GET,\n+            url: \"http://{addr}/\",\n+            headers: {\n+                \"transfer-encoding\" => \"chunked\",\n             },\n+            version: HTTP_10,\n+            // wrap_steam means we don't know the content-length,\n+            // but we're wrapping a non-empty stream.\n+            //\n+            // But since the headers cannot tell us, the body must be ignored.\n+            body: (Body::wrap_stream(Body::from(\"hello\"))),\n+        },\n+        response:\n+            status: OK,\n+            headers: {},\n             body: None,\n }\n \n@@ -431,6 +575,33 @@ test! {\n             body: None,\n }\n \n+test! {\n+    name: client_post_unknown,\n+\n+    server:\n+        expected: \"\\\n+            POST /chunks HTTP/1.1\\r\\n\\\n+            host: {addr}\\r\\n\\\n+            transfer-encoding: chunked\\r\\n\\\n+            \\r\\n\\\n+            B\\r\\n\\\n+            foo bar baz\\r\\n\\\n+            0\\r\\n\\r\\n\\\n+            \",\n+        reply: REPLY_OK,\n+\n+    client:\n+        request: {\n+            method: POST,\n+            url: \"http://{addr}/chunks\",\n+            body: (Body::wrap_stream(Body::from(\"foo bar baz\"))),\n+        },\n+        response:\n+            status: OK,\n+            headers: {},\n+            body: None,\n+}\n+\n test! {\n     name: client_post_empty,\n \n",
    "diff_parsed": "{'added': [(356, '    name: client_get_req_body_implicitly_empty,'), (370, '            headers: {},'), (371, '            body: None,'), (372, '}'), (374, 'test! {'), (375, '    name: client_get_req_body_chunked,'), (377, '    server:'), (378, '        expected: \"\\\\'), (379, '            GET / HTTP/1.1\\\\r\\\\n\\\\'), (380, '            transfer-encoding: chunked\\\\r\\\\n\\\\'), (381, '            host: {addr}\\\\r\\\\n\\\\'), (382, '            \\\\r\\\\n\\\\'), (383, '            5\\\\r\\\\n\\\\'), (384, '            hello\\\\r\\\\n\\\\'), (385, '            0\\\\r\\\\n\\\\r\\\\n\\\\'), (386, '            \",'), (387, '        reply: REPLY_OK,'), (389, '    client:'), (390, '        request: {'), (391, '            method: GET,'), (392, '            url: \"http://{addr}/\",'), (394, '                \"transfer-encoding\" => \"chunked\",'), (395, '            },'), (396, '            body: \"hello\", // not Body::empty'), (397, '        },'), (398, '        response:'), (399, '            status: OK,'), (400, '            headers: {},'), (401, '            body: None,'), (402, '}'), (404, 'test! {'), (405, '    name: client_get_req_body_chunked_http10,'), (407, '    server:'), (408, '        expected: \"\\\\'), (409, '            GET / HTTP/1.0\\\\r\\\\n\\\\'), (410, '            host: {addr}\\\\r\\\\n\\\\'), (411, '            content-length: 5\\\\r\\\\n\\\\'), (412, '            \\\\r\\\\n\\\\'), (413, '            hello\\\\'), (414, '            \",'), (415, '        reply: \"HTTP/1.0 200 OK\\\\r\\\\ncontent-length: 0\\\\r\\\\n\\\\r\\\\n\",'), (417, '    client:'), (418, '        request: {'), (419, '            method: GET,'), (420, '            url: \"http://{addr}/\",'), (421, '            headers: {'), (422, '                \"transfer-encoding\" => \"chunked\",'), (423, '            },'), (424, '            version: HTTP_10,'), (425, '            body: \"hello\",'), (426, '        },'), (427, '        response:'), (428, '            status: OK,'), (429, '            headers: {},'), (430, '            body: None,'), (431, '}'), (433, 'test! {'), (434, '    name: client_get_req_body_sized,'), (436, '    server:'), (437, '        expected: \"\\\\'), (438, '            GET / HTTP/1.1\\\\r\\\\n\\\\'), (439, '            content-length: 5\\\\r\\\\n\\\\'), (440, '            host: {addr}\\\\r\\\\n\\\\'), (441, '            \\\\r\\\\n\\\\'), (442, '            hello\\\\'), (443, '            \",'), (444, '        reply: REPLY_OK,'), (446, '    client:'), (447, '        request: {'), (448, '            method: GET,'), (449, '            url: \"http://{addr}/\",'), (450, '            headers: {'), (451, '                \"Content-Length\" => \"5\",'), (452, '            },'), (453, '            body: (Body::wrap_stream(Body::from(\"hello\"))),'), (454, '        },'), (455, '        response:'), (456, '            status: OK,'), (457, '            headers: {},'), (458, '            body: None,'), (459, '}'), (461, 'test! {'), (462, '    name: client_get_req_body_unknown,'), (464, '    server:'), (465, '        expected: \"\\\\'), (466, '            GET / HTTP/1.1\\\\r\\\\n\\\\'), (467, '            host: {addr}\\\\r\\\\n\\\\'), (468, '            \\\\r\\\\n\\\\'), (469, '            \",'), (470, '        reply: REPLY_OK,'), (472, '    client:'), (473, '        request: {'), (474, '            method: GET,'), (475, '            url: \"http://{addr}/\",'), (481, '            body: (Body::wrap_stream(Body::from(\"hello\"))),'), (482, '        },'), (483, '        response:'), (484, '            status: OK,'), (485, '            headers: {},'), (486, '            body: None,'), (487, '}'), (489, 'test! {'), (490, '    name: client_get_req_body_unknown_http10,'), (492, '    server:'), (493, '        expected: \"\\\\'), (494, '            GET / HTTP/1.0\\\\r\\\\n\\\\'), (495, '            host: {addr}\\\\r\\\\n\\\\'), (496, '            \\\\r\\\\n\\\\'), (497, '            \",'), (498, '        reply: \"HTTP/1.0 200 OK\\\\r\\\\ncontent-length: 0\\\\r\\\\n\\\\r\\\\n\",'), (500, '    client:'), (501, '        request: {'), (502, '            method: GET,'), (503, '            url: \"http://{addr}/\",'), (504, '            headers: {'), (505, '                \"transfer-encoding\" => \"chunked\",'), (507, '            version: HTTP_10,'), (512, '            body: (Body::wrap_stream(Body::from(\"hello\"))),'), (513, '        },'), (514, '        response:'), (515, '            status: OK,'), (516, '            headers: {},'), (578, 'test! {'), (579, '    name: client_post_unknown,'), (581, '    server:'), (582, '        expected: \"\\\\'), (583, '            POST /chunks HTTP/1.1\\\\r\\\\n\\\\'), (584, '            host: {addr}\\\\r\\\\n\\\\'), (585, '            transfer-encoding: chunked\\\\r\\\\n\\\\'), (586, '            \\\\r\\\\n\\\\'), (587, '            B\\\\r\\\\n\\\\'), (588, '            foo bar baz\\\\r\\\\n\\\\'), (589, '            0\\\\r\\\\n\\\\r\\\\n\\\\'), (590, '            \",'), (591, '        reply: REPLY_OK,'), (593, '    client:'), (594, '        request: {'), (595, '            method: POST,'), (596, '            url: \"http://{addr}/chunks\",'), (597, '            body: (Body::wrap_stream(Body::from(\"foo bar baz\"))),'), (598, '        },'), (599, '        response:'), (600, '            status: OK,'), (601, '            headers: {},'), (602, '            body: None,'), (603, '}')], 'deleted': [(356, '    name: client_get_implicitly_empty,'), (371, '                \"Content-Length\" => \"0\",')]}",
    "num_lines_added": "146",
    "num_lines_deleted": "2",
    "nloc": "1942"
  },
  {
    "file_change_id": "81907049805017",
    "hash": "6dd7ca0d50f2464df708975cdafcfaeeb6d41c66",
    "old_path": "src/aref.rs",
    "new_path": "src/aref.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -516,7 +516,7 @@ impl<'a, U: ?Sized> ARefs<'a, U> {\n     /// assert_eq!(*aref.map(|s| &s[1]), 5);\n     /// ```\n     #[inline]\n-    pub fn map<V: ?Sized, F: FnOnce(&U) -> &V>(self, f: F) -> ARefs<'a, V> { ARefs(self.0.map(f)) }\n+    pub fn map<V: ?Sized + Send, F: FnOnce(&U) -> &V>(self, f: F) -> ARefs<'a, V> { ARefs(self.0.map(f)) }\n \n     /// Like map, but with Result passthrough.\n     ///\n@@ -528,11 +528,11 @@ impl<'a, U: ?Sized> ARefs<'a, U> {\n     /// assert_eq!(aref.try_map(|s| s.get(9).ok_or(())), Err(()));\n     /// ```\n     #[inline]\n-    pub fn try_map<E, V: ?Sized, F: FnOnce(&U) -> Result<&V, E>>(self, f: F) -> Result<ARefs<'a, V>, E> {\n+    pub fn try_map<E, V: ?Sized + Send, F: FnOnce(&U) -> Result<&V, E>>(self, f: F) -> Result<ARefs<'a, V>, E> {\n         self.0.try_map(f).map(|z| ARefs(z))\n     }\n \n-    /// Removes the type information that this struct is Send + Sync.\n+    /// Removes the type information that this struct is Send.\n     #[inline]\n     pub fn into_aref(self) -> ARef<'a, U> { self.0 }\n }\n@@ -564,7 +564,7 @@ impl<'a, U: ?Sized> ARefss<'a, U> {\n     /// assert_eq!(*aref.map(|s| &s[1]), 5);\n     /// ```\n     #[inline]\n-    pub fn map<V: ?Sized, F: FnOnce(&U) -> &V>(self, f: F) -> ARefss<'a, V> { ARefss(self.0.map(f)) }\n+    pub fn map<V: ?Sized + Send + Sync, F: FnOnce(&U) -> &V>(self, f: F) -> ARefss<'a, V> { ARefss(self.0.map(f)) }\n \n     /// Like map, but with Result passthrough.\n     ///\n@@ -576,7 +576,7 @@ impl<'a, U: ?Sized> ARefss<'a, U> {\n     /// assert_eq!(aref.try_map(|s| s.get(9).ok_or(())), Err(()));\n     /// ```\n     #[inline]\n-    pub fn try_map<E, V: ?Sized, F: FnOnce(&U) -> Result<&V, E>>(self, f: F) -> Result<ARefss<'a, V>, E> {\n+    pub fn try_map<E, V: ?Sized + Send + Sync, F: FnOnce(&U) -> Result<&V, E>>(self, f: F) -> Result<ARefss<'a, V>, E> {\n         self.0.try_map(f).map(|z| ARefss(z))\n     }\n \n",
    "diff_parsed": "{'added': [(519, \"    pub fn map<V: ?Sized + Send, F: FnOnce(&U) -> &V>(self, f: F) -> ARefs<'a, V> { ARefs(self.0.map(f)) }\"), (531, \"    pub fn try_map<E, V: ?Sized + Send, F: FnOnce(&U) -> Result<&V, E>>(self, f: F) -> Result<ARefs<'a, V>, E> {\"), (567, \"    pub fn map<V: ?Sized + Send + Sync, F: FnOnce(&U) -> &V>(self, f: F) -> ARefss<'a, V> { ARefss(self.0.map(f)) }\"), (579, \"    pub fn try_map<E, V: ?Sized + Send + Sync, F: FnOnce(&U) -> Result<&V, E>>(self, f: F) -> Result<ARefss<'a, V>, E> {\")], 'deleted': [(519, \"    pub fn map<V: ?Sized, F: FnOnce(&U) -> &V>(self, f: F) -> ARefs<'a, V> { ARefs(self.0.map(f)) }\"), (531, \"    pub fn try_map<E, V: ?Sized, F: FnOnce(&U) -> Result<&V, E>>(self, f: F) -> Result<ARefs<'a, V>, E> {\"), (567, \"    pub fn map<V: ?Sized, F: FnOnce(&U) -> &V>(self, f: F) -> ARefss<'a, V> { ARefss(self.0.map(f)) }\"), (579, \"    pub fn try_map<E, V: ?Sized, F: FnOnce(&U) -> Result<&V, E>>(self, f: F) -> Result<ARefss<'a, V>, E> {\")]}",
    "num_lines_added": "4",
    "num_lines_deleted": "4",
    "nloc": "532"
  },
  {
    "file_change_id": "29766184450755",
    "hash": "dbc7ab1c739667eb26aace1b9a6795192ed4a805",
    "old_path": "src/der/value.rs",
    "new_path": "src/der/value.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -12,13 +12,10 @@ impl DerValue {\n \tpub fn deserialize<'a>(mut source: impl Iterator<Item = &'a u8>, len: impl Into<usize>)\n \t\t-> Result<Self, Asn1DerError>\n \t{\n-\t\t// Create buffer\n-\t\tlet len = len.into();\n-\t\tlet mut data_buf = vec![0u8; len];\n-\t\t\n-\t\t// Copy data into buffer\n-\t\tfor b in data_buf.iter_mut() {\n-\t\t\t*b = *source.next().ok_or(Asn1DerError::LengthMismatch)?;\n+\t\t// Create buffer and fill it with `len` bytes\n+\t\tlet mut data_buf = Vec::new();\n+\t\tfor _ in 0..len.into() {\n+\t\t\tdata_buf.push(*source.next().ok_or(Asn1DerError::LengthMismatch)?);\n \t\t}\n \t\tOk(data_buf.into())\n \t}\n",
    "diff_parsed": "{'added': [(16, '\\t\\tlet mut data_buf = Vec::new();'), (17, '\\t\\tfor _ in 0..len.into() {'), (18, '\\t\\t\\tdata_buf.push(*source.next().ok_or(Asn1DerError::LengthMismatch)?);')], 'deleted': [(16, '\\t\\tlet len = len.into();'), (17, '\\t\\tlet mut data_buf = vec![0u8; len];'), (20, '\\t\\tfor b in data_buf.iter_mut() {'), (21, '\\t\\t\\t*b = *source.next().ok_or(Asn1DerError::LengthMismatch)?;')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "4",
    "nloc": "40"
  },
  {
    "file_change_id": "85483986723751",
    "hash": "dbc7ab1c739667eb26aace1b9a6795192ed4a805",
    "old_path": "tests/der.rs",
    "new_path": "tests/der.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -63,6 +63,8 @@ fn test_err() {\n \t\t// Incomplete value\n \t\t(b\"\\x0c\\x09\\x54\\x65\\x73\\x74\\x6F\\x6C\\x6F\\x70\".as_ref(), Asn1DerError::LengthMismatch),\n \t\t// Complex length > 2^64 - 1\n-\t\t(b\"\\x77\\x89\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\".as_ref(), Asn1DerError::Unsupported)\n+\t\t(b\"\\x77\\x89\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\".as_ref(), Asn1DerError::Unsupported),\n+\t\t// Excessive length announcement\n+\t\t(b\"\\x9d\\xf7\\x9d\\x9d\\x9d\\x9d\\x9d\\x9d\\x9d\\x9d\\x9d\\x9d\\x9d\\x9d\\x9d\\x43\\x9d\\x01\\x00\\x00\\x00\\x9d\\x9d\\x9d\\x9d\\x9d\\x9d\\x9d\\x9d\".as_ref(), Asn1DerError::LengthMismatch)\n \t].iter().for_each(test);\n }\n\\ No newline at end of file\n",
    "diff_parsed": "{'added': [(66, '\\t\\t(b\"\\\\x77\\\\x89\\\\x01\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\".as_ref(), Asn1DerError::Unsupported),'), (68, '\\t\\t(b\"\\\\x9d\\\\xf7\\\\x9d\\\\x9d\\\\x9d\\\\x9d\\\\x9d\\\\x9d\\\\x9d\\\\x9d\\\\x9d\\\\x9d\\\\x9d\\\\x9d\\\\x9d\\\\x43\\\\x9d\\\\x01\\\\x00\\\\x00\\\\x00\\\\x9d\\\\x9d\\\\x9d\\\\x9d\\\\x9d\\\\x9d\\\\x9d\\\\x9d\".as_ref(), Asn1DerError::LengthMismatch)')], 'deleted': [(66, '\\t\\t(b\"\\\\x77\\\\x89\\\\x01\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\".as_ref(), Asn1DerError::Unsupported)')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "1",
    "nloc": "46"
  },
  {
    "file_change_id": "223289116624393",
    "hash": "3199bd8623d05341b4047f53e143ae67d7d9f064",
    "old_path": "buttplug/src/util/future.rs",
    "new_path": "buttplug/src/util/future.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -85,9 +85,9 @@ pub struct ButtplugFutureStateShared<T> {\n   state: Arc<Mutex<ButtplugFutureState<T>>>,\n }\n \n-unsafe impl<T> Sync for ButtplugFutureStateShared<T> {\n+unsafe impl<T: Sync> Sync for ButtplugFutureStateShared<T> {\n }\n-unsafe impl<T> Send for ButtplugFutureStateShared<T> {\n+unsafe impl<T: Send> Send for ButtplugFutureStateShared<T> {\n }\n \n impl<T> ButtplugFutureStateShared<T> {\n",
    "diff_parsed": "{'added': [(88, 'unsafe impl<T: Sync> Sync for ButtplugFutureStateShared<T> {'), (90, 'unsafe impl<T: Send> Send for ButtplugFutureStateShared<T> {')], 'deleted': [(88, 'unsafe impl<T> Sync for ButtplugFutureStateShared<T> {'), (90, 'unsafe impl<T> Send for ButtplugFutureStateShared<T> {')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "95"
  },
  {
    "file_change_id": "32055837066654",
    "hash": "2928a87a0c9f86c46ba70f8c8058d9b7b10a241d",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -146,8 +146,8 @@ impl<T> Clone for Intern<T> {\n /// because we never free the data pointed to by an `Intern`.\n impl<T> Copy for Intern<T> {}\n \n-unsafe impl<T> Send for Intern<T> {}\n-unsafe impl<T> Sync for Intern<T> {}\n+unsafe impl<T: Send> Send for Intern<T> {}\n+unsafe impl<T: Sync> Sync for Intern<T> {}\n \n impl<T: Eq + Hash + Send + 'static> Intern<T> {\n     fn get_mutex() -> &'static Mutex<HashSet<Box<T>>> {\n",
    "diff_parsed": "{'added': [(149, 'unsafe impl<T: Send> Send for Intern<T> {}'), (150, 'unsafe impl<T: Sync> Sync for Intern<T> {}')], 'deleted': [(149, 'unsafe impl<T> Send for Intern<T> {}'), (150, 'unsafe impl<T> Sync for Intern<T> {}')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "724"
  },
  {
    "file_change_id": "7181450227808",
    "hash": "8e970aaa60471a845a309c0fe82ebe59779341ca",
    "old_path": "src/generic.rs",
    "new_path": "src/generic.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -527,5 +527,6 @@ where\n     }\n }\n \n+// Safety: Same bounds as `std::borrow::Cow`.\n unsafe impl<T: Beef + Sync + ?Sized, U: Capacity> Sync for Cow<'_, T, U> {}\n-unsafe impl<T: Beef + Send + ?Sized, U: Capacity> Send for Cow<'_, T, U> {}\n+unsafe impl<T: Beef + Send + Sync + ?Sized, U: Capacity> Send for Cow<'_, T, U> {}\n",
    "diff_parsed": "{'added': [(532, \"unsafe impl<T: Beef + Send + Sync + ?Sized, U: Capacity> Send for Cow<'_, T, U> {}\")], 'deleted': [(531, \"unsafe impl<T: Beef + Send + ?Sized, U: Capacity> Send for Cow<'_, T, U> {}\")]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "419"
  },
  {
    "file_change_id": "177645884391944",
    "hash": "cdff034e6d93cdfdafd13d8c6956e22fa5a57b79",
    "old_path": "crates/xdv/src/lib.rs",
    "new_path": "crates/xdv/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -221,10 +221,9 @@ impl<T: XdvEvents> XdvParser<T> {\n     {\n         const BUF_SIZE: usize = 4096;\n         let mut parser = Self::new(events);\n-        let mut buf = Vec::with_capacity(BUF_SIZE);\n-        unsafe {\n-            buf.set_len(BUF_SIZE);\n-        }\n+        // Note that it is unsound to pass uninitialized data to a read() call,\n+        // even though it *should* never cause problems ...\n+        let mut buf = vec![0; BUF_SIZE];\n         let mut n_saved_bytes = 0;\n \n         loop {\n",
    "diff_parsed": "{'added': [(226, '        let mut buf = vec![0; BUF_SIZE];')], 'deleted': [(224, '        let mut buf = Vec::with_capacity(BUF_SIZE);'), (225, '        unsafe {'), (226, '            buf.set_len(BUF_SIZE);'), (227, '        }')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "4",
    "nloc": "869"
  },
  {
    "file_change_id": "38071644224003",
    "hash": "599313b39c249ee89144c69eb09da0f56d579922",
    "old_path": "src/read.rs",
    "new_path": "src/read.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -17,12 +17,9 @@ impl<R: io::Read> IoReader<R> {\n \n impl<R: io::Read> BufReadExact for IoReader<R> {\n     fn buf_read_exact(&mut self, len: usize) -> io::Result<&[u8]> {\n-        unsafe {\n-            self.buf.reserve(len);\n-            let slice = self.buf.get_unchecked_mut(..len);\n-            self.rdr.read_exact(slice)?;\n-            Ok(slice)\n-        }\n+        self.buf.resize(len, 0);\n+        self.rdr.read_exact(self.buf.as_mut_slice())?;\n+        Ok(self.buf.as_slice())\n     }\n }\n \n",
    "diff_parsed": "{'added': [(20, '        self.buf.resize(len, 0);'), (21, '        self.rdr.read_exact(self.buf.as_mut_slice())?;'), (22, '        Ok(self.buf.as_slice())')], 'deleted': [(20, '        unsafe {'), (21, '            self.buf.reserve(len);'), (22, '            let slice = self.buf.get_unchecked_mut(..len);'), (23, '            self.rdr.read_exact(slice)?;'), (24, '            Ok(slice)'), (25, '        }')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "6",
    "nloc": "39"
  },
  {
    "file_change_id": "898269493666",
    "hash": "291fca7dbfb2e3fe235180b41ce9e845ef0b2895",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -319,14 +319,9 @@ impl<A> State<A> {\n         let start_ptr = self.tip.as_mut_ptr()\n                                 .offset(self.tip.len_items() as isize);\n \n-        let padding = start_ptr as usize % alignment;\n-\n-        debug_assert!(padding < alignment);\n-        debug_assert_eq!(padding, 0);\n-\n+        let padding = (alignment - (start_ptr as usize % alignment)) % alignment;\n         let start_ptr = start_ptr.offset(AlignedVec::<A>::bytes_to_items(padding) as isize);\n-\n-        let new_used = self.tip.len_items() + padding + AlignedVec::<A>::bytes_to_items(size);\n+        let new_used = self.tip.len_items() + AlignedVec::<A>::bytes_to_items(padding + size);\n \n         if new_used <= self.tip.capacity_items() {\n             self.tip.set_len_items(new_used);\n",
    "diff_parsed": "{'added': [(322, '        let padding = (alignment - (start_ptr as usize % alignment)) % alignment;'), (324, '        let new_used = self.tip.len_items() + AlignedVec::<A>::bytes_to_items(padding + size);')], 'deleted': [(322, '        let padding = start_ptr as usize % alignment;'), (324, '        debug_assert!(padding < alignment);'), (325, '        debug_assert_eq!(padding, 0);'), (329, '        let new_used = self.tip.len_items() + padding + AlignedVec::<A>::bytes_to_items(size);')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "4",
    "nloc": "448"
  },
  {
    "file_change_id": "239940022885768",
    "hash": "936ab41a87d2b4876e09efc43864faf591dc0c2c",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -712,16 +712,13 @@ impl VendorInfo {\n     /// Return vendor identification as human readable string.\n     pub fn as_string<'a>(&'a self) -> &'a str {\n         let brand_string_start = self as *const VendorInfo as *const u8;\n-        unsafe {\n+        let slice = unsafe {\n             // Safety: VendorInfo is laid out with repr(C) and exactly\n             // 12 byte long without any padding.\n-            let slice: &'a [u8] =\n-                slice::from_raw_parts(brand_string_start, size_of::<VendorInfo>());\n-            // Safety: The field is specified to be ASCII, and the only safe\n-            // way to construct VendorInfo is from real CPUID data or the\n-            // Default implementation.\n-            str::from_utf8_unchecked(slice)\n-        }\n+            slice::from_raw_parts(brand_string_start, size_of::<VendorInfo>())\n+        };\n+\n+        str::from_utf8(slice).unwrap_or(\"InvalidVendorString\")\n     }\n }\n \n@@ -4193,15 +4190,11 @@ pub struct SoCVendorBrand {\n impl SoCVendorBrand {\n     pub fn as_string<'a>(&'a self) -> &'a str {\n         let brand_string_start = self as *const SoCVendorBrand as *const u8;\n-        unsafe {\n+        let slice = unsafe {\n             // Safety: SoCVendorBrand is laid out with repr(C).\n-            let slice: &'a [u8] =\n-                slice::from_raw_parts(brand_string_start, size_of::<SoCVendorBrand>());\n-            // Safety: The field is specified to be ASCII, and the only safe\n-            // way to construct SoCVendorBrand is from real CPUID data or the\n-            // Default implementation.\n-            str::from_utf8_unchecked(slice)\n-        }\n+            slice::from_raw_parts(brand_string_start, size_of::<SoCVendorBrand>())\n+        };\n+        str::from_utf8(slice).unwrap_or(\"InvalidSoCVendorString\")\n     }\n }\n \n@@ -4329,10 +4322,7 @@ impl ExtendedFunctionInfo {\n             // Brand terminated at nul byte or end, whichever comes first.\n             let slice = slice.split(|&x| x == 0).next().unwrap();\n \n-            // Safety: Field is specified to be ASCII, and the only safe way\n-            // to construct ExtendedFunctionInfo is from real CPUID data\n-            // or the Default implementation.\n-            Some(unsafe { str::from_utf8_unchecked(slice) })\n+            str::from_utf8(slice).ok()\n         } else {\n             None\n         }\n",
    "diff_parsed": "{'added': [(715, '        let slice = unsafe {'), (718, '            slice::from_raw_parts(brand_string_start, size_of::<VendorInfo>())'), (719, '        };'), (721, '        str::from_utf8(slice).unwrap_or(\"InvalidVendorString\")'), (4193, '        let slice = unsafe {'), (4195, '            slice::from_raw_parts(brand_string_start, size_of::<SoCVendorBrand>())'), (4196, '        };'), (4197, '        str::from_utf8(slice).unwrap_or(\"InvalidSoCVendorString\")'), (4325, '            str::from_utf8(slice).ok()')], 'deleted': [(715, '        unsafe {'), (718, \"            let slice: &'a [u8] =\"), (719, '                slice::from_raw_parts(brand_string_start, size_of::<VendorInfo>());'), (723, '            str::from_utf8_unchecked(slice)'), (724, '        }'), (4196, '        unsafe {'), (4198, \"            let slice: &'a [u8] =\"), (4199, '                slice::from_raw_parts(brand_string_start, size_of::<SoCVendorBrand>());'), (4203, '            str::from_utf8_unchecked(slice)'), (4204, '        }'), (4335, '            Some(unsafe { str::from_utf8_unchecked(slice) })')]}",
    "num_lines_added": "9",
    "num_lines_deleted": "11",
    "nloc": "3679"
  },
  {
    "file_change_id": "42274229217206",
    "hash": "229d1a8d41b0023420e7815578fa0b39c0d5c2e4",
    "old_path": "crates/cli/src/decompress.rs",
    "new_path": "crates/cli/src/decompress.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,7 +1,7 @@\n use std::ffi::{OsStr, OsString};\n use std::fs::File;\n use std::io;\n-use std::path::Path;\n+use std::path::{Path, PathBuf};\n use std::process::Command;\n \n use globset::{Glob, GlobSet, GlobSetBuilder};\n@@ -24,7 +24,7 @@ struct DecompressionCommand {\n     /// The glob that matches this command.\n     glob: String,\n     /// The command or binary name.\n-    bin: OsString,\n+    bin: PathBuf,\n     /// The arguments to invoke with the command.\n     args: Vec<OsString>,\n }\n@@ -83,23 +83,60 @@ impl DecompressionMatcherBuilder {\n     ///\n     /// The syntax for the glob is documented in the\n     /// [`globset` crate](https://docs.rs/globset/#syntax).\n+    ///\n+    /// The `program` given is resolved with respect to `PATH` and turned\n+    /// into an absolute path internally before being executed by the current\n+    /// platform. Notably, on Windows, this avoids a security problem where\n+    /// passing a relative path to `CreateProcess` will automatically search\n+    /// the current directory for a matching program. If the program could\n+    /// not be resolved, then it is silently ignored and the association is\n+    /// dropped. For this reason, callers should prefer `try_associate`.\n     pub fn associate<P, I, A>(\n         &mut self,\n         glob: &str,\n         program: P,\n         args: I,\n     ) -> &mut DecompressionMatcherBuilder\n+    where\n+        P: AsRef<OsStr>,\n+        I: IntoIterator<Item = A>,\n+        A: AsRef<OsStr>,\n+    {\n+        let _ = self.try_associate(glob, program, args);\n+        self\n+    }\n+\n+    /// Associates a glob with a command to decompress files matching the glob.\n+    ///\n+    /// If multiple globs match the same file, then the most recently added\n+    /// glob takes precedence.\n+    ///\n+    /// The syntax for the glob is documented in the\n+    /// [`globset` crate](https://docs.rs/globset/#syntax).\n+    ///\n+    /// The `program` given is resolved with respect to `PATH` and turned\n+    /// into an absolute path internally before being executed by the current\n+    /// platform. Notably, on Windows, this avoids a security problem where\n+    /// passing a relative path to `CreateProcess` will automatically search\n+    /// the current directory for a matching program. If the program could not\n+    /// be resolved, then an error is returned.\n+    pub fn try_associate<P, I, A>(\n+        &mut self,\n+        glob: &str,\n+        program: P,\n+        args: I,\n+    ) -> Result<&mut DecompressionMatcherBuilder, CommandError>\n     where\n         P: AsRef<OsStr>,\n         I: IntoIterator<Item = A>,\n         A: AsRef<OsStr>,\n     {\n         let glob = glob.to_string();\n-        let bin = program.as_ref().to_os_string();\n+        let bin = resolve_binary(Path::new(program.as_ref()))?;\n         let args =\n             args.into_iter().map(|a| a.as_ref().to_os_string()).collect();\n         self.commands.push(DecompressionCommand { glob, bin, args });\n-        self\n+        Ok(self)\n     }\n }\n \n@@ -340,6 +377,70 @@ impl io::Read for DecompressionReader {\n     }\n }\n \n+/// Resolves a path to a program to a path by searching for the program in\n+/// `PATH`.\n+///\n+/// If the program could not be resolved, then an error is returned.\n+///\n+/// The purpose of doing this instead of passing the path to the program\n+/// directly to Command::new is that Command::new will hand relative paths\n+/// to CreateProcess on Windows, which will implicitly search the current\n+/// working directory for the executable. This could be undesirable for\n+/// security reasons. e.g., running ripgrep with the -z/--search-zip flag on an\n+/// untrusted directory tree could result in arbitrary programs executing on\n+/// Windows.\n+///\n+/// Note that this could still return a relative path if PATH contains a\n+/// relative path. We permit this since it is assumed that the user has set\n+/// this explicitly, and thus, desires this behavior.\n+///\n+/// On non-Windows, this is a no-op.\n+pub fn resolve_binary<P: AsRef<Path>>(\n+    prog: P,\n+) -> Result<PathBuf, CommandError> {\n+    use std::env;\n+\n+    fn is_exe(path: &Path) -> bool {\n+        let md = match path.metadata() {\n+            Err(_) => return false,\n+            Ok(md) => md,\n+        };\n+        !md.is_dir()\n+    }\n+\n+    let prog = prog.as_ref();\n+    if !cfg!(windows) || prog.is_absolute() {\n+        return Ok(prog.to_path_buf());\n+    }\n+    let syspaths = match env::var_os(\"PATH\") {\n+        Some(syspaths) => syspaths,\n+        None => {\n+            let msg = \"system PATH environment variable not found\";\n+            return Err(CommandError::io(io::Error::new(\n+                io::ErrorKind::Other,\n+                msg,\n+            )));\n+        }\n+    };\n+    for syspath in env::split_paths(&syspaths) {\n+        if syspath.as_os_str().is_empty() {\n+            continue;\n+        }\n+        let abs_prog = syspath.join(prog);\n+        if is_exe(&abs_prog) {\n+            return Ok(abs_prog.to_path_buf());\n+        }\n+        if abs_prog.extension().is_none() {\n+            let abs_prog = abs_prog.with_extension(\"exe\");\n+            if is_exe(&abs_prog) {\n+                return Ok(abs_prog.to_path_buf());\n+            }\n+        }\n+    }\n+    let msg = format!(\"{}: could not find executable in PATH\", prog.display());\n+    return Err(CommandError::io(io::Error::new(io::ErrorKind::Other, msg)));\n+}\n+\n fn default_decompression_commands() -> Vec<DecompressionCommand> {\n     const ARGS_GZIP: &[&str] = &[\"gzip\", \"-d\", \"-c\"];\n     const ARGS_BZIP: &[&str] = &[\"bzip2\", \"-d\", \"-c\"];\n@@ -350,29 +451,36 @@ fn default_decompression_commands() -> Vec<DecompressionCommand> {\n     const ARGS_ZSTD: &[&str] = &[\"zstd\", \"-q\", \"-d\", \"-c\"];\n     const ARGS_UNCOMPRESS: &[&str] = &[\"uncompress\", \"-c\"];\n \n-    fn cmd(glob: &str, args: &[&str]) -> DecompressionCommand {\n-        DecompressionCommand {\n+    fn add(glob: &str, args: &[&str], cmds: &mut Vec<DecompressionCommand>) {\n+        let bin = match resolve_binary(Path::new(args[0])) {\n+            Ok(bin) => bin,\n+            Err(err) => {\n+                debug!(\"{}\", err);\n+                return;\n+            }\n+        };\n+        cmds.push(DecompressionCommand {\n             glob: glob.to_string(),\n-            bin: OsStr::new(&args[0]).to_os_string(),\n+            bin,\n             args: args\n                 .iter()\n                 .skip(1)\n                 .map(|s| OsStr::new(s).to_os_string())\n                 .collect(),\n-        }\n+        });\n     }\n-    vec![\n-        cmd(\"*.gz\", ARGS_GZIP),\n-        cmd(\"*.tgz\", ARGS_GZIP),\n-        cmd(\"*.bz2\", ARGS_BZIP),\n-        cmd(\"*.tbz2\", ARGS_BZIP),\n-        cmd(\"*.xz\", ARGS_XZ),\n-        cmd(\"*.txz\", ARGS_XZ),\n-        cmd(\"*.lz4\", ARGS_LZ4),\n-        cmd(\"*.lzma\", ARGS_LZMA),\n-        cmd(\"*.br\", ARGS_BROTLI),\n-        cmd(\"*.zst\", ARGS_ZSTD),\n-        cmd(\"*.zstd\", ARGS_ZSTD),\n-        cmd(\"*.Z\", ARGS_UNCOMPRESS),\n-    ]\n+    let mut cmds = vec![];\n+    add(\"*.gz\", ARGS_GZIP, &mut cmds);\n+    add(\"*.tgz\", ARGS_GZIP, &mut cmds);\n+    add(\"*.bz2\", ARGS_BZIP, &mut cmds);\n+    add(\"*.tbz2\", ARGS_BZIP, &mut cmds);\n+    add(\"*.xz\", ARGS_XZ, &mut cmds);\n+    add(\"*.txz\", ARGS_XZ, &mut cmds);\n+    add(\"*.lz4\", ARGS_LZ4, &mut cmds);\n+    add(\"*.lzma\", ARGS_LZMA, &mut cmds);\n+    add(\"*.br\", ARGS_BROTLI, &mut cmds);\n+    add(\"*.zst\", ARGS_ZSTD, &mut cmds);\n+    add(\"*.zstd\", ARGS_ZSTD, &mut cmds);\n+    add(\"*.Z\", ARGS_UNCOMPRESS, &mut cmds);\n+    cmds\n }\n",
    "diff_parsed": "{'added': [(4, 'use std::path::{Path, PathBuf};'), (27, '    bin: PathBuf,'), (100, '    where'), (101, '        P: AsRef<OsStr>,'), (102, '        I: IntoIterator<Item = A>,'), (103, '        A: AsRef<OsStr>,'), (104, '    {'), (105, '        let _ = self.try_associate(glob, program, args);'), (106, '        self'), (107, '    }'), (123, '    pub fn try_associate<P, I, A>('), (124, '        &mut self,'), (125, '        glob: &str,'), (126, '        program: P,'), (127, '        args: I,'), (128, '    ) -> Result<&mut DecompressionMatcherBuilder, CommandError>'), (135, '        let bin = resolve_binary(Path::new(program.as_ref()))?;'), (139, '        Ok(self)'), (398, 'pub fn resolve_binary<P: AsRef<Path>>('), (399, '    prog: P,'), (400, ') -> Result<PathBuf, CommandError> {'), (401, '    use std::env;'), (403, '    fn is_exe(path: &Path) -> bool {'), (404, '        let md = match path.metadata() {'), (405, '            Err(_) => return false,'), (406, '            Ok(md) => md,'), (407, '        };'), (408, '        !md.is_dir()'), (409, '    }'), (411, '    let prog = prog.as_ref();'), (412, '    if !cfg!(windows) || prog.is_absolute() {'), (413, '        return Ok(prog.to_path_buf());'), (414, '    }'), (415, '    let syspaths = match env::var_os(\"PATH\") {'), (416, '        Some(syspaths) => syspaths,'), (417, '        None => {'), (418, '            let msg = \"system PATH environment variable not found\";'), (419, '            return Err(CommandError::io(io::Error::new('), (420, '                io::ErrorKind::Other,'), (421, '                msg,'), (422, '            )));'), (423, '        }'), (424, '    };'), (425, '    for syspath in env::split_paths(&syspaths) {'), (426, '        if syspath.as_os_str().is_empty() {'), (427, '            continue;'), (428, '        }'), (429, '        let abs_prog = syspath.join(prog);'), (430, '        if is_exe(&abs_prog) {'), (431, '            return Ok(abs_prog.to_path_buf());'), (432, '        }'), (433, '        if abs_prog.extension().is_none() {'), (434, '            let abs_prog = abs_prog.with_extension(\"exe\");'), (435, '            if is_exe(&abs_prog) {'), (436, '                return Ok(abs_prog.to_path_buf());'), (437, '            }'), (438, '        }'), (439, '    }'), (440, '    let msg = format!(\"{}: could not find executable in PATH\", prog.display());'), (441, '    return Err(CommandError::io(io::Error::new(io::ErrorKind::Other, msg)));'), (442, '}'), (454, '    fn add(glob: &str, args: &[&str], cmds: &mut Vec<DecompressionCommand>) {'), (455, '        let bin = match resolve_binary(Path::new(args[0])) {'), (456, '            Ok(bin) => bin,'), (457, '            Err(err) => {'), (458, '                debug!(\"{}\", err);'), (459, '                return;'), (460, '            }'), (461, '        };'), (462, '        cmds.push(DecompressionCommand {'), (464, '            bin,'), (470, '        });'), (472, '    let mut cmds = vec![];'), (473, '    add(\"*.gz\", ARGS_GZIP, &mut cmds);'), (474, '    add(\"*.tgz\", ARGS_GZIP, &mut cmds);'), (475, '    add(\"*.bz2\", ARGS_BZIP, &mut cmds);'), (476, '    add(\"*.tbz2\", ARGS_BZIP, &mut cmds);'), (477, '    add(\"*.xz\", ARGS_XZ, &mut cmds);'), (478, '    add(\"*.txz\", ARGS_XZ, &mut cmds);'), (479, '    add(\"*.lz4\", ARGS_LZ4, &mut cmds);'), (480, '    add(\"*.lzma\", ARGS_LZMA, &mut cmds);'), (481, '    add(\"*.br\", ARGS_BROTLI, &mut cmds);'), (482, '    add(\"*.zst\", ARGS_ZSTD, &mut cmds);'), (483, '    add(\"*.zstd\", ARGS_ZSTD, &mut cmds);'), (484, '    add(\"*.Z\", ARGS_UNCOMPRESS, &mut cmds);'), (485, '    cmds')], 'deleted': [(4, 'use std::path::Path;'), (27, '    bin: OsString,'), (98, '        let bin = program.as_ref().to_os_string();'), (102, '        self'), (353, '    fn cmd(glob: &str, args: &[&str]) -> DecompressionCommand {'), (354, '        DecompressionCommand {'), (356, '            bin: OsStr::new(&args[0]).to_os_string(),'), (362, '        }'), (364, '    vec!['), (365, '        cmd(\"*.gz\", ARGS_GZIP),'), (366, '        cmd(\"*.tgz\", ARGS_GZIP),'), (367, '        cmd(\"*.bz2\", ARGS_BZIP),'), (368, '        cmd(\"*.tbz2\", ARGS_BZIP),'), (369, '        cmd(\"*.xz\", ARGS_XZ),'), (370, '        cmd(\"*.txz\", ARGS_XZ),'), (371, '        cmd(\"*.lz4\", ARGS_LZ4),'), (372, '        cmd(\"*.lzma\", ARGS_LZMA),'), (373, '        cmd(\"*.br\", ARGS_BROTLI),'), (374, '        cmd(\"*.zst\", ARGS_ZSTD),'), (375, '        cmd(\"*.zstd\", ARGS_ZSTD),'), (376, '        cmd(\"*.Z\", ARGS_UNCOMPRESS),'), (377, '    ]')]}",
    "num_lines_added": "86",
    "num_lines_deleted": "22",
    "nloc": "272"
  },
  {
    "file_change_id": "279243974087772",
    "hash": "229d1a8d41b0023420e7815578fa0b39c0d5c2e4",
    "old_path": "crates/cli/src/lib.rs",
    "new_path": "crates/cli/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -179,8 +179,8 @@ mod process;\n mod wtr;\n \n pub use decompress::{\n-    DecompressionMatcher, DecompressionMatcherBuilder, DecompressionReader,\n-    DecompressionReaderBuilder,\n+    resolve_binary, DecompressionMatcher, DecompressionMatcherBuilder,\n+    DecompressionReader, DecompressionReaderBuilder,\n };\n pub use escape::{escape, escape_os, unescape, unescape_os};\n pub use human::{parse_human_readable_size, ParseSizeError};\n",
    "diff_parsed": "{'added': [(182, '    resolve_binary, DecompressionMatcher, DecompressionMatcherBuilder,'), (183, '    DecompressionReader, DecompressionReaderBuilder,')], 'deleted': [(182, '    DecompressionMatcher, DecompressionMatcherBuilder, DecompressionReader,'), (183, '    DecompressionReaderBuilder,')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "62"
  },
  {
    "file_change_id": "2407413868346",
    "hash": "229d1a8d41b0023420e7815578fa0b39c0d5c2e4",
    "old_path": "crates/core/args.rs",
    "new_path": "crates/core/args.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -290,7 +290,7 @@ impl Args {\n         let mut builder = SearchWorkerBuilder::new();\n         builder\n             .json_stats(matches.is_present(\"json\"))\n-            .preprocessor(matches.preprocessor())\n+            .preprocessor(matches.preprocessor())?\n             .preprocessor_globs(matches.preprocessor_globs()?)\n             .search_zip(matches.is_present(\"search-zip\"))\n             .binary_detection_implicit(matches.binary_detection_implicit())\n",
    "diff_parsed": "{'added': [(293, '            .preprocessor(matches.preprocessor())?')], 'deleted': [(293, '            .preprocessor(matches.preprocessor())')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "1324"
  },
  {
    "file_change_id": "172803635276269",
    "hash": "229d1a8d41b0023420e7815578fa0b39c0d5c2e4",
    "old_path": "crates/core/search.rs",
    "new_path": "crates/core/search.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -115,9 +115,14 @@ impl SearchWorkerBuilder {\n     pub fn preprocessor(\n         &mut self,\n         cmd: Option<PathBuf>,\n-    ) -> &mut SearchWorkerBuilder {\n-        self.config.preprocessor = cmd;\n-        self\n+    ) -> crate::Result<&mut SearchWorkerBuilder> {\n+        if let Some(ref prog) = cmd {\n+            let bin = cli::resolve_binary(prog)?;\n+            self.config.preprocessor = Some(bin);\n+        } else {\n+            self.config.preprocessor = None;\n+        }\n+        Ok(self)\n     }\n \n     /// Set the globs for determining which files should be run through the\n",
    "diff_parsed": "{'added': [(118, '    ) -> crate::Result<&mut SearchWorkerBuilder> {'), (119, '        if let Some(ref prog) = cmd {'), (120, '            let bin = cli::resolve_binary(prog)?;'), (121, '            self.config.preprocessor = Some(bin);'), (122, '        } else {'), (123, '            self.config.preprocessor = None;'), (124, '        }'), (125, '        Ok(self)')], 'deleted': [(118, '    ) -> &mut SearchWorkerBuilder {'), (119, '        self.config.preprocessor = cmd;'), (120, '        self')]}",
    "num_lines_added": "8",
    "num_lines_deleted": "3",
    "nloc": "394"
  },
  {
    "file_change_id": "28899663185500",
    "hash": "26a296b871976d7d46325ce004207b8a6e27c94",
    "old_path": "src/digests.rs",
    "new_path": "src/digests.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -321,7 +321,9 @@ impl<'a, T: TryFrom<u64>> MultihashRefGeneric<'a, T> {\n             return Err(DecodeError::BadInputLength);\n         }\n \n-        let (_code, bytes) = varint_decode::u64(&input).map_err(|_| DecodeError::BadInputLength)?;\n+        let (code, bytes) = varint_decode::u64(&input).map_err(|_| DecodeError::BadInputLength)?;\n+        // Make sure it's a code that is part of the codec table\n+        T::try_from(code).map_err(|_| DecodeError::UnknownCode)?;\n \n         let (hash_len, bytes) =\n             varint_decode::u64(&bytes).map_err(|_| DecodeError::BadInputLength)?;\n",
    "diff_parsed": "{'added': [(324, '        let (code, bytes) = varint_decode::u64(&input).map_err(|_| DecodeError::BadInputLength)?;'), (326, '        T::try_from(code).map_err(|_| DecodeError::UnknownCode)?;')], 'deleted': [(324, '        let (_code, bytes) = varint_decode::u64(&input).map_err(|_| DecodeError::BadInputLength)?;')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "1",
    "nloc": "246"
  },
  {
    "file_change_id": "171954827537286",
    "hash": "26a296b871976d7d46325ce004207b8a6e27c94",
    "old_path": "tests/lib.rs",
    "new_path": "tests/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -286,6 +286,14 @@ fn multihash_ref_errors() {\n         MultihashRef::from_slice(&[identity_code, identity_length, 1, 2, 3, 4]).is_err(),\n         \"Should error on wrong hash length\"\n     );\n+\n+    let unsupported_code = 0x04;\n+    let hash_length = 3;\n+    assert_eq!(\n+        MultihashRef::from_slice(&[unsupported_code, hash_length, 1, 2, 3]),\n+        Err(DecodeError::UnknownCode),\n+        \"Should error on codes that are not part of the code table\"\n+    );\n }\n \n #[test]\n",
    "diff_parsed": "{'added': [(290, '    let unsupported_code = 0x04;'), (291, '    let hash_length = 3;'), (292, '    assert_eq!('), (293, '        MultihashRef::from_slice(&[unsupported_code, hash_length, 1, 2, 3]),'), (294, '        Err(DecodeError::UnknownCode),'), (295, '        \"Should error on codes that are not part of the code table\"'), (296, '    );')], 'deleted': []}",
    "num_lines_added": "7",
    "num_lines_deleted": "0",
    "nloc": "291"
  },
  {
    "file_change_id": "94178796167205",
    "hash": "e7e291709240bd83ca35a12b85d87f074002be7",
    "old_path": "src/algorithm/mod.rs",
    "new_path": "src/algorithm/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -3,7 +3,7 @@ extern crate libc;\n use array::Array;\n use defines::{AfError, BinaryOp};\n use error::HANDLE_ERROR;\n-use self::libc::{c_int, uint8_t, c_uint, c_double};\n+use self::libc::{c_int, c_uint, c_double};\n use util::{AfArray, MutAfArray, MutDouble, MutUint};\n use util::{HasAfEnum, Scanable, RealNumber};\n \n@@ -44,9 +44,9 @@ extern {\n     fn af_sort_by_key(out_keys: MutAfArray, out_vals: MutAfArray,\n                       in_keys: AfArray, in_vals: AfArray, dim: c_uint, ascend: c_int) -> c_int;\n \n-    fn af_scan(out: MutAfArray, inp: AfArray, dim: c_int, op: uint8_t, inclusive: c_int) -> c_int;\n+    fn af_scan(out: MutAfArray, inp: AfArray, dim: c_int, op: c_uint, inclusive: c_int) -> c_int;\n     fn af_scan_by_key(out: MutAfArray, key: AfArray, inp: AfArray,\n-                      dim: c_int, op: uint8_t, inclusive: c_int) -> c_int;\n+                      dim: c_int, op: c_uint, inclusive: c_int) -> c_int;\n }\n \n macro_rules! dim_reduce_func_def {\n@@ -922,7 +922,7 @@ pub fn scan<T>(input: &Array<T>, dim: i32,\n     let mut temp : i64 = 0;\n     unsafe {\n         let err_val = af_scan(&mut temp as MutAfArray, input.get() as AfArray,\n-                              dim as c_int, op as uint8_t, inclusive as c_int);\n+                              dim as c_int, op as c_uint, inclusive as c_int);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n@@ -953,7 +953,7 @@ pub fn scan_by_key<K, V>(key: &Array<K>, input: &Array<V>,\n     unsafe {\n         let err_val = af_scan_by_key(&mut temp as MutAfArray, key.get() as AfArray,\n                                      input.get() as AfArray, dim as c_int,\n-                                     op as uint8_t, inclusive as c_int);\n+                                     op as c_uint, inclusive as c_int);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n",
    "diff_parsed": "{'added': [(6, 'use self::libc::{c_int, c_uint, c_double};'), (47, '    fn af_scan(out: MutAfArray, inp: AfArray, dim: c_int, op: c_uint, inclusive: c_int) -> c_int;'), (49, '                      dim: c_int, op: c_uint, inclusive: c_int) -> c_int;'), (925, '                              dim as c_int, op as c_uint, inclusive as c_int);'), (956, '                                     op as c_uint, inclusive as c_int);')], 'deleted': [(6, 'use self::libc::{c_int, uint8_t, c_uint, c_double};'), (47, '    fn af_scan(out: MutAfArray, inp: AfArray, dim: c_int, op: uint8_t, inclusive: c_int) -> c_int;'), (49, '                      dim: c_int, op: uint8_t, inclusive: c_int) -> c_int;'), (925, '                              dim as c_int, op as uint8_t, inclusive as c_int);'), (956, '                                     op as uint8_t, inclusive as c_int);')]}",
    "num_lines_added": "5",
    "num_lines_deleted": "5",
    "nloc": "743"
  },
  {
    "file_change_id": "201971519069370",
    "hash": "e7e291709240bd83ca35a12b85d87f074002be7",
    "old_path": "src/array.rs",
    "new_path": "src/array.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -4,7 +4,7 @@ use dim4::Dim4;\n use defines::{AfError, DType, Backend};\n use error::HANDLE_ERROR;\n use util::{AfArray, DimT, HasAfEnum, MutAfArray, MutVoidPtr};\n-use self::libc::{uint8_t, c_void, c_int, c_uint, c_longlong, c_char};\n+use self::libc::{c_void, c_int, c_uint, c_longlong, c_char};\n use std::marker::PhantomData;\n use std::ffi::CString;\n \n@@ -16,13 +16,13 @@ use std::ffi::CString;\n #[allow(dead_code)]\n extern {\n     fn af_create_array(out: MutAfArray, data: *const c_void,\n-                       ndims: c_uint, dims: *const DimT, aftype: uint8_t) -> c_int;\n+                       ndims: c_uint, dims: *const DimT, aftype: c_uint) -> c_int;\n \n-    fn af_create_handle(out: MutAfArray, ndims: c_uint, dims: *const DimT, aftype: uint8_t) -> c_int;\n+    fn af_create_handle(out: MutAfArray, ndims: c_uint, dims: *const DimT, aftype: c_uint) -> c_int;\n \n     fn af_get_elements(out: MutAfArray, arr: AfArray) -> c_int;\n \n-    fn af_get_type(out: *mut c_int, arr: AfArray) -> c_int;\n+    fn af_get_type(out: *mut c_uint, arr: AfArray) -> c_int;\n \n     fn af_get_dims(dim0: *mut c_longlong, dim1: *mut c_longlong, dim2: *mut c_longlong,\n                    dim3: *mut c_longlong, arr: AfArray) -> c_int;\n@@ -75,15 +75,15 @@ extern {\n \n     fn af_print_array_gen(exp: *const c_char, arr: AfArray, precision: c_int) -> c_int;\n \n-    fn af_cast(out: MutAfArray, arr: AfArray, aftype: uint8_t) -> c_int;\n+    fn af_cast(out: MutAfArray, arr: AfArray, aftype: c_uint) -> c_int;\n \n-    fn af_get_backend_id(backend: *mut c_int, input: AfArray) -> c_int;\n+    fn af_get_backend_id(backend: *mut c_uint, input: AfArray) -> c_int;\n \n     fn af_get_device_id(device: *mut c_int, input: AfArray) -> c_int;\n \n     fn af_create_strided_array(arr: MutAfArray, data: *const c_void, offset: DimT,\n                                ndims: c_uint, dims: *const DimT, strides: *const DimT,\n-                               aftype: uint8_t, stype: uint8_t) -> c_int;\n+                               aftype: c_uint, stype: c_uint) -> c_int;\n \n     fn af_get_strides(s0: *mut DimT, s1: *mut DimT, s2: *mut DimT, s3: *mut DimT,\n                       arr: AfArray) -> c_int;\n@@ -155,7 +155,7 @@ impl<T> Array<T> where T: HasAfEnum {\n                                           slice.as_ptr() as *const c_void,\n                                           dims.ndims() as c_uint,\n                                           dims.get().as_ptr() as * const c_longlong,\n-                                          aftype as uint8_t);\n+                                          aftype as c_uint);\n             HANDLE_ERROR(AfError::from(err_val));\n         }\n         temp.into()\n@@ -176,7 +176,7 @@ impl<T> Array<T> where T: HasAfEnum {\n                                                   dims.ndims() as c_uint,\n                                                   dims.get().as_ptr() as * const c_longlong,\n                                                   strides.get().as_ptr() as * const c_longlong,\n-                                                  aftype as uint8_t, 1);\n+                                                  aftype as c_uint, 1 as c_uint);\n             HANDLE_ERROR(AfError::from(err_val));\n         }\n         temp.into()\n@@ -198,7 +198,7 @@ impl<T> Array<T> where T: HasAfEnum {\n             let err_val = af_create_handle(&mut temp as MutAfArray,\n                                            dims.ndims() as c_uint,\n                                            dims.get().as_ptr() as * const c_longlong,\n-                                           aftype as uint8_t);\n+                                           aftype as c_uint);\n             HANDLE_ERROR(AfError::from(err_val));\n             temp.into()\n         }\n@@ -212,8 +212,8 @@ impl<T> Array<T> where T: HasAfEnum {\n     /// was active when Array was created.\n     pub fn get_backend(&self) -> Backend {\n         unsafe {\n-            let mut ret_val: i32 = 0;\n-            let err_val = af_get_backend_id(&mut ret_val as *mut c_int, self.handle as AfArray);\n+            let mut ret_val: u32 = 0;\n+            let err_val = af_get_backend_id(&mut ret_val as *mut c_uint, self.handle as AfArray);\n             HANDLE_ERROR(AfError::from(err_val));\n             match (err_val, ret_val) {\n                 (0, 1) => Backend::CPU,\n@@ -251,8 +251,8 @@ impl<T> Array<T> where T: HasAfEnum {\n     /// Returns the Array data type\n     pub fn get_type(&self) -> DType {\n         unsafe {\n-            let mut ret_val: i32 = 0;\n-            let err_val = af_get_type(&mut ret_val as *mut c_int, self.handle as AfArray);\n+            let mut ret_val: u32 = 0;\n+            let err_val = af_get_type(&mut ret_val as *mut c_uint, self.handle as AfArray);\n             HANDLE_ERROR(AfError::from(err_val));\n             DType::from(ret_val)\n         }\n@@ -364,7 +364,7 @@ impl<T> Array<T> where T: HasAfEnum {\n         let trgt_type = O::get_af_dtype();\n         let mut temp: i64 = 0;\n         unsafe {\n-            let err_val = af_cast(&mut temp as MutAfArray, self.handle as AfArray, trgt_type as uint8_t);\n+            let err_val = af_cast(&mut temp as MutAfArray, self.handle as AfArray, trgt_type as c_uint);\n             HANDLE_ERROR(AfError::from(err_val));\n         }\n         temp.into()\n",
    "diff_parsed": "{'added': [(7, 'use self::libc::{c_void, c_int, c_uint, c_longlong, c_char};'), (19, '                       ndims: c_uint, dims: *const DimT, aftype: c_uint) -> c_int;'), (21, '    fn af_create_handle(out: MutAfArray, ndims: c_uint, dims: *const DimT, aftype: c_uint) -> c_int;'), (25, '    fn af_get_type(out: *mut c_uint, arr: AfArray) -> c_int;'), (78, '    fn af_cast(out: MutAfArray, arr: AfArray, aftype: c_uint) -> c_int;'), (80, '    fn af_get_backend_id(backend: *mut c_uint, input: AfArray) -> c_int;'), (86, '                               aftype: c_uint, stype: c_uint) -> c_int;'), (158, '                                          aftype as c_uint);'), (179, '                                                  aftype as c_uint, 1 as c_uint);'), (201, '                                           aftype as c_uint);'), (215, '            let mut ret_val: u32 = 0;'), (216, '            let err_val = af_get_backend_id(&mut ret_val as *mut c_uint, self.handle as AfArray);'), (254, '            let mut ret_val: u32 = 0;'), (255, '            let err_val = af_get_type(&mut ret_val as *mut c_uint, self.handle as AfArray);'), (367, '            let err_val = af_cast(&mut temp as MutAfArray, self.handle as AfArray, trgt_type as c_uint);')], 'deleted': [(7, 'use self::libc::{uint8_t, c_void, c_int, c_uint, c_longlong, c_char};'), (19, '                       ndims: c_uint, dims: *const DimT, aftype: uint8_t) -> c_int;'), (21, '    fn af_create_handle(out: MutAfArray, ndims: c_uint, dims: *const DimT, aftype: uint8_t) -> c_int;'), (25, '    fn af_get_type(out: *mut c_int, arr: AfArray) -> c_int;'), (78, '    fn af_cast(out: MutAfArray, arr: AfArray, aftype: uint8_t) -> c_int;'), (80, '    fn af_get_backend_id(backend: *mut c_int, input: AfArray) -> c_int;'), (86, '                               aftype: uint8_t, stype: uint8_t) -> c_int;'), (158, '                                          aftype as uint8_t);'), (179, '                                                  aftype as uint8_t, 1);'), (201, '                                           aftype as uint8_t);'), (215, '            let mut ret_val: i32 = 0;'), (216, '            let err_val = af_get_backend_id(&mut ret_val as *mut c_int, self.handle as AfArray);'), (254, '            let mut ret_val: i32 = 0;'), (255, '            let err_val = af_get_type(&mut ret_val as *mut c_int, self.handle as AfArray);'), (367, '            let err_val = af_cast(&mut temp as MutAfArray, self.handle as AfArray, trgt_type as uint8_t);')]}",
    "num_lines_added": "15",
    "num_lines_deleted": "15",
    "nloc": "354"
  },
  {
    "file_change_id": "154081950931425",
    "hash": "e7e291709240bd83ca35a12b85d87f074002be7",
    "old_path": "src/data/mod.rs",
    "new_path": "src/data/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -5,7 +5,7 @@ use array::Array;\n use dim4::Dim4;\n use defines::{AfError};\n use error::HANDLE_ERROR;\n-use self::libc::{uint8_t, c_int, c_uint, c_double};\n+use self::libc::{c_int, c_uint, c_double};\n use self::num::Complex;\n use util::{AfArray, DimT, HasAfEnum, Intl, MutAfArray, Uintl};\n use std::vec::Vec;\n@@ -25,12 +25,12 @@ extern {\n                          ndims: c_uint, dims: *const DimT) -> c_int;\n \n     fn af_range(out: MutAfArray, ndims: c_uint, dims: *const DimT,\n-                seq_dims: c_int, afdtype: uint8_t) -> c_int;\n+                seq_dims: c_int, afdtype: c_uint) -> c_int;\n \n     fn af_iota(out: MutAfArray, ndims: c_uint, dims: *const DimT,\n-               t_ndims: c_uint, tdims: *const DimT, afdtype: uint8_t) -> c_int;\n+               t_ndims: c_uint, tdims: *const DimT, afdtype: c_uint) -> c_int;\n \n-    fn af_identity(out: MutAfArray, ndims: c_uint, dims: *const DimT, afdtype: uint8_t) -> c_int;\n+    fn af_identity(out: MutAfArray, ndims: c_uint, dims: *const DimT, afdtype: c_uint) -> c_int;\n     fn af_diag_create(out: MutAfArray, arr: AfArray, num: c_int) -> c_int;\n     fn af_diag_extract(out: MutAfArray, arr: AfArray, num: c_int) -> c_int;\n     fn af_join(out: MutAfArray, dim: c_int, first: AfArray, second: AfArray) -> c_int;\n@@ -243,7 +243,7 @@ pub fn range<T: HasAfEnum>(dims: Dim4, seq_dim: i32) -> Array<T> {\n     unsafe {\n         let err_val = af_range(&mut temp as MutAfArray,\n                               dims.ndims() as c_uint, dims.get().as_ptr() as *const DimT,\n-                              seq_dim as c_int, aftype as uint8_t);\n+                              seq_dim as c_int, aftype as c_uint);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n@@ -269,7 +269,7 @@ pub fn iota<T: HasAfEnum>(dims: Dim4, tdims: Dim4) -> Array<T> {\n         let err_val =af_iota(&mut temp as MutAfArray,\n                              dims.ndims() as c_uint, dims.get().as_ptr() as *const DimT,\n                              tdims.ndims() as c_uint, tdims.get().as_ptr() as *const DimT,\n-                             aftype as uint8_t);\n+                             aftype as c_uint);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n@@ -291,7 +291,7 @@ pub fn identity<T: HasAfEnum>(dims: Dim4) -> Array<T> {\n     unsafe {\n         let err_val = af_identity(&mut temp as MutAfArray,\n                                   dims.ndims() as c_uint, dims.get().as_ptr() as *const DimT,\n-                                  aftype as uint8_t);\n+                                  aftype as c_uint);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n",
    "diff_parsed": "{'added': [(8, 'use self::libc::{c_int, c_uint, c_double};'), (28, '                seq_dims: c_int, afdtype: c_uint) -> c_int;'), (31, '               t_ndims: c_uint, tdims: *const DimT, afdtype: c_uint) -> c_int;'), (33, '    fn af_identity(out: MutAfArray, ndims: c_uint, dims: *const DimT, afdtype: c_uint) -> c_int;'), (246, '                              seq_dim as c_int, aftype as c_uint);'), (272, '                             aftype as c_uint);'), (294, '                                  aftype as c_uint);')], 'deleted': [(8, 'use self::libc::{uint8_t, c_int, c_uint, c_double};'), (28, '                seq_dims: c_int, afdtype: uint8_t) -> c_int;'), (31, '               t_ndims: c_uint, tdims: *const DimT, afdtype: uint8_t) -> c_int;'), (33, '    fn af_identity(out: MutAfArray, ndims: c_uint, dims: *const DimT, afdtype: uint8_t) -> c_int;'), (246, '                              seq_dim as c_int, aftype as uint8_t);'), (272, '                             aftype as uint8_t);'), (294, '                                  aftype as uint8_t);')]}",
    "num_lines_added": "7",
    "num_lines_deleted": "7",
    "nloc": "368"
  },
  {
    "file_change_id": "57102623043329",
    "hash": "e7e291709240bd83ca35a12b85d87f074002be7",
    "old_path": "src/defines.rs",
    "new_path": "src/defines.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -6,7 +6,7 @@ use std::fmt::Error as FmtError;\n use self::num::Complex;\n \n /// Error codes\n-#[repr(C)]\n+#[repr(i32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum AfError {\n     /// The function returned successfully\n@@ -53,7 +53,7 @@ pub enum AfError {\n }\n \n /// Compute/Acceleration Backend\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum Backend {\n     /// Default backend order: OpenCL -> CUDA -> CPU\n@@ -109,7 +109,7 @@ impl Error for AfError {\n }\n \n /// Types of Array data type\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum DType {\n     /// 32 bit float\n@@ -139,7 +139,7 @@ pub enum DType {\n }\n \n /// Dictates the interpolation method to be used by a function\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum InterpType {\n     /// Nearest Neighbor interpolation method\n@@ -165,7 +165,7 @@ pub enum InterpType {\n }\n \n /// Helps determine how to pad kernels along borders\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum BorderType {\n     /// Pad using zeros\n@@ -175,7 +175,7 @@ pub enum BorderType {\n }\n \n /// Used by `regions` function to identify type of connectivity\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum Connectivity {\n     /// North-East-South-West (N-E-S-W) connectivity from given pixel/point\n@@ -185,7 +185,7 @@ pub enum Connectivity {\n }\n \n /// Helps determine the size of output of convolution\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum ConvMode {\n     /// Default convolution mode where output size is same as input size\n@@ -195,7 +195,7 @@ pub enum ConvMode {\n }\n \n /// Helps determine if convolution is in Spatial or Frequency domain\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum ConvDomain {\n     /// ArrayFire chooses whether the convolution will be in spatial domain or frequency domain\n@@ -207,7 +207,7 @@ pub enum ConvDomain {\n }\n \n /// Error metric used by `matchTemplate` function\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum MatchType {\n     /// Sum of Absolute Differences\n@@ -231,7 +231,7 @@ pub enum MatchType {\n }\n \n /// Identify the color space of given image(Array)\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum ColorSpace {\n     /// Grayscale color space\n@@ -243,7 +243,7 @@ pub enum ColorSpace {\n }\n \n /// Helps determine the type of a Matrix\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum MatProp {\n     /// Default (no-op)\n@@ -272,7 +272,7 @@ pub enum MatProp {\n \n /// Norm type\n #[allow(non_camel_case_types)]\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum NormType {\n     /// Treats input as a vector and return sum of absolute values\n@@ -294,7 +294,7 @@ pub enum NormType {\n }\n \n /// Dictates what color map is used for Image rendering\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum ColorMap {\n     /// Default color map is grayscale range [0-1]\n@@ -314,7 +314,7 @@ pub enum ColorMap {\n }\n \n /// YCbCr Standards\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum YCCStd {\n     /// ITU-R BT.601 (formerly CCIR 601) standard\n@@ -326,7 +326,7 @@ pub enum YCCStd {\n }\n \n /// Homography type\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum HomographyType {\n     /// RANdom SAmple Consensus algorithm\n@@ -336,7 +336,7 @@ pub enum HomographyType {\n }\n \n /// Plotting markers\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum MarkerType {\n     /// No marker\n@@ -358,7 +358,7 @@ pub enum MarkerType {\n }\n \n /// Image moment types\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum MomentType {\n     /// Central moment of order (0 + 0)\n@@ -374,7 +374,7 @@ pub enum MomentType {\n }\n \n /// Sparse storage format type\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum SparseFormat {\n     /// Dense format\n@@ -388,7 +388,7 @@ pub enum SparseFormat {\n }\n \n /// Binary operation types for generalized scan functions\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum BinaryOp {\n     /// Addition operation\n@@ -402,7 +402,7 @@ pub enum BinaryOp {\n }\n \n /// Random engine types\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum RandomEngineType {\n     ///Philox variant with N=4, W=32 and Rounds=10\n@@ -452,7 +452,7 @@ pub enum Scalar {\n }\n \n /// Canny edge detector threshold operations types\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum CannyThresholdType {\n     /// User has to define canny thresholds manually\n@@ -462,7 +462,7 @@ pub enum CannyThresholdType {\n }\n \n /// Anisotropic diffusion flux equation types\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum DiffusionEq {\n     /// Quadratic flux function\n@@ -474,7 +474,7 @@ pub enum DiffusionEq {\n }\n \n /// Diffusion equation types\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum FluxFn {\n     /// Quadratic flux function\n@@ -486,7 +486,7 @@ pub enum FluxFn {\n }\n \n /// topk function ordering\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum TopkFn {\n     /// Top k min values\n",
    "diff_parsed": "{'added': [(9, '#[repr(i32)]'), (56, '#[repr(u32)]'), (112, '#[repr(u32)]'), (142, '#[repr(u32)]'), (168, '#[repr(u32)]'), (178, '#[repr(u32)]'), (188, '#[repr(u32)]'), (198, '#[repr(u32)]'), (210, '#[repr(u32)]'), (234, '#[repr(u32)]'), (246, '#[repr(u32)]'), (275, '#[repr(u32)]'), (297, '#[repr(u32)]'), (317, '#[repr(u32)]'), (329, '#[repr(u32)]'), (339, '#[repr(u32)]'), (361, '#[repr(u32)]'), (377, '#[repr(u32)]'), (391, '#[repr(u32)]'), (405, '#[repr(u32)]'), (455, '#[repr(u32)]'), (465, '#[repr(u32)]'), (477, '#[repr(u32)]'), (489, '#[repr(u32)]')], 'deleted': [(9, '#[repr(C)]'), (56, '#[repr(C)]'), (112, '#[repr(C)]'), (142, '#[repr(C)]'), (168, '#[repr(C)]'), (178, '#[repr(C)]'), (188, '#[repr(C)]'), (198, '#[repr(C)]'), (210, '#[repr(C)]'), (234, '#[repr(C)]'), (246, '#[repr(C)]'), (275, '#[repr(C)]'), (297, '#[repr(C)]'), (317, '#[repr(C)]'), (329, '#[repr(C)]'), (339, '#[repr(C)]'), (361, '#[repr(C)]'), (377, '#[repr(C)]'), (391, '#[repr(C)]'), (405, '#[repr(C)]'), (455, '#[repr(C)]'), (465, '#[repr(C)]'), (477, '#[repr(C)]'), (489, '#[repr(C)]')]}",
    "num_lines_added": "24",
    "num_lines_deleted": "24",
    "nloc": "290"
  },
  {
    "file_change_id": "120321395549918",
    "hash": "e7e291709240bd83ca35a12b85d87f074002be7",
    "old_path": "src/image/mod.rs",
    "new_path": "src/image/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -7,7 +7,7 @@ use error::HANDLE_ERROR;\n use util::{AfArray, DimT, MutAfArray};\n use util::{FloatingPoint, HasAfEnum, RealNumber, ImageNativeType, ImageFilterType};\n use util::{RealFloating, EdgeComputable, MomentsComputable, GrayRGBConvertible};\n-use self::libc::{uint8_t, c_uint, c_int, c_float, c_double, c_char};\n+use self::libc::{c_uint, c_int, c_float, c_double, c_char};\n use std::ffi::CString;\n \n // unused functions from image.h header\n@@ -17,7 +17,7 @@ use std::ffi::CString;\n \n #[allow(dead_code)]\n extern {\n-    fn af_cast(out: MutAfArray, arr: AfArray, aftype: uint8_t) -> c_int;\n+    fn af_cast(out: MutAfArray, arr: AfArray, aftype: c_uint) -> c_int;\n     fn af_gradient(dx: MutAfArray, dy: MutAfArray, arr: AfArray) -> c_int;\n     fn af_load_image(out: MutAfArray, filename: *const c_char, iscolor: c_int) -> c_int;\n     fn af_save_image(filename: *const c_char, input: AfArray) -> c_int;\n@@ -25,22 +25,22 @@ extern {\n     fn af_save_image_native(filename: *const c_char, input: AfArray) -> c_int;\n \n     fn af_resize(out: MutAfArray, input: AfArray,\n-                 odim0: DimT, odim1: DimT, method: uint8_t) -> c_int;\n+                 odim0: DimT, odim1: DimT, method: c_uint) -> c_int;\n \n     fn af_transform(out: MutAfArray, input: AfArray, trans: AfArray,\n-                    odim0: DimT, odim1: DimT, method: uint8_t, is_inverse: c_int) -> c_int;\n+                    odim0: DimT, odim1: DimT, method: c_uint, is_inverse: c_int) -> c_int;\n \n     fn af_rotate(out: MutAfArray, input: AfArray, theta: c_float, crop: c_int,\n-                 method: uint8_t) -> c_int;\n+                 method: c_uint) -> c_int;\n \n     fn af_translate(out: MutAfArray, input: AfArray, trans0: c_float, trans1: c_float,\n-                    odim0: DimT, odim1: DimT, method: uint8_t) -> c_int;\n+                    odim0: DimT, odim1: DimT, method: c_uint) -> c_int;\n \n     fn af_scale(out: MutAfArray, input: AfArray, scale0: c_float, scale1: c_float,\n-                odim0: DimT, odim1: DimT, method: uint8_t) -> c_int;\n+                odim0: DimT, odim1: DimT, method: c_uint) -> c_int;\n \n     fn af_skew(out: MutAfArray, input: AfArray, skew0: c_float, skew1: c_float,\n-               odim0: DimT, odim1: DimT, method: uint8_t, is_inverse: c_int) -> c_int;\n+               odim0: DimT, odim1: DimT, method: c_uint, is_inverse: c_int) -> c_int;\n \n     fn af_histogram(out: MutAfArray, input: AfArray, nbins: c_uint,\n                     minval: c_double, maxval: c_double) -> c_int;\n@@ -49,7 +49,7 @@ extern {\n     fn af_dilate3(out: MutAfArray, input: AfArray, mask: AfArray) -> c_int;\n     fn af_erode(out: MutAfArray, input: AfArray, mask: AfArray) -> c_int;\n     fn af_erode3(out: MutAfArray, input: AfArray, mask: AfArray) -> c_int;\n-    fn af_regions(out: MutAfArray, input: AfArray, conn: uint8_t, aftype: uint8_t) -> c_int;\n+    fn af_regions(out: MutAfArray, input: AfArray, conn: c_uint, aftype: c_uint) -> c_int;\n     fn af_sobel_operator(dx: MutAfArray, dy: MutAfArray, i: AfArray, ksize: c_uint) -> c_int;\n     fn af_rgb2gray(out: MutAfArray, input: AfArray, r: c_float, g: c_float, b: c_float) -> c_int;\n     fn af_gray2rgb(out: MutAfArray, input: AfArray, r: c_float, g: c_float, b: c_float) -> c_int;\n@@ -64,21 +64,21 @@ extern {\n                      ch_sig: c_float, iter: c_uint, iscolor: c_int) -> c_int;\n \n     fn af_medfilt(out: MutAfArray, input: AfArray,\n-                  wlen: DimT, wwid: DimT, etype: uint8_t) -> c_int;\n+                  wlen: DimT, wwid: DimT, etype: c_uint) -> c_int;\n \n-    fn af_medfilt1(out: MutAfArray, input: AfArray, wlen: DimT, etype: uint8_t) -> c_int;\n+    fn af_medfilt1(out: MutAfArray, input: AfArray, wlen: DimT, etype: c_uint) -> c_int;\n \n     fn af_minfilt(out: MutAfArray, input: AfArray,\n-                  wlen: DimT, wwid: DimT, etype: uint8_t) -> c_int;\n+                  wlen: DimT, wwid: DimT, etype: c_uint) -> c_int;\n \n     fn af_maxfilt(out: MutAfArray, input: AfArray,\n-                  wlen: DimT, wwid: DimT, etype: uint8_t) -> c_int;\n+                  wlen: DimT, wwid: DimT, etype: c_uint) -> c_int;\n \n     fn af_gaussian_kernel(out: MutAfArray, rows: c_int, cols: c_int,\n                           sigma_r: c_double, sigma_c: c_double) -> c_int;\n \n     fn af_color_space(out: MutAfArray, input: AfArray,\n-                      tospace: uint8_t, fromspace: uint8_t) -> c_int;\n+                      tospace: c_uint, fromspace: c_uint) -> c_int;\n \n     fn af_unwrap(out: MutAfArray, input: AfArray, wx: DimT, wy: DimT, sx: DimT, sy: DimT,\n                  px: DimT, py: DimT, is_column: c_int) -> c_int;\n@@ -162,7 +162,7 @@ pub fn load_image<T>(filename: String, is_color: bool) -> Array<T>\n         let mut temp: i64 = 0;\n         let err1 = af_load_image(&mut temp as MutAfArray, cstr_param.as_ptr(), is_color as c_int);\n         HANDLE_ERROR(AfError::from(err1));\n-        let err2 = af_cast(&mut img as MutAfArray, temp as AfArray, trgt_type as uint8_t);\n+        let err2 = af_cast(&mut img as MutAfArray, temp as AfArray, trgt_type as c_uint);\n         HANDLE_ERROR(AfError::from(err2));\n     }\n     img.into()\n@@ -200,7 +200,7 @@ pub fn load_image_native<T>(filename: String) -> Array<T>\n         let mut temp: i64 = 0;\n         let err1 = af_load_image_native(&mut temp as MutAfArray, cstr_param.as_ptr());\n         HANDLE_ERROR(AfError::from(err1));\n-        let err2 = af_cast(&mut img as MutAfArray, temp as AfArray, trgt_type as uint8_t);\n+        let err2 = af_cast(&mut img as MutAfArray, temp as AfArray, trgt_type as c_uint);\n         HANDLE_ERROR(AfError::from(err2));\n     }\n     img.into()\n@@ -283,7 +283,7 @@ pub fn resize<T:HasAfEnum>(input: &Array<T>,\n     let mut temp: i64 = 0;\n     unsafe {\n         let err_val = af_resize(&mut temp as MutAfArray, input.get() as AfArray,\n-                                odim0 as DimT, odim1 as DimT, method as uint8_t);\n+                                odim0 as DimT, odim1 as DimT, method as c_uint);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n@@ -327,7 +327,7 @@ pub fn transform<T:HasAfEnum>(input: &Array<T>, trans: &Array<f32>,\n         let err_val = af_transform(&mut temp as MutAfArray,\n                                    input.get() as AfArray, trans.get() as AfArray,\n                                    odim0 as DimT, odim1 as DimT,\n-                                   method as uint8_t, is_inverse as c_int);\n+                                   method as c_uint, is_inverse as c_int);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n@@ -368,7 +368,7 @@ pub fn rotate<T:HasAfEnum>(input: &Array<T>, theta: f64, crop: bool,\n     let mut temp: i64 = 0;\n     unsafe {\n         let err_val = af_rotate(&mut temp as MutAfArray, input.get() as AfArray,\n-                                theta as c_float, crop as c_int, method as uint8_t);\n+                                theta as c_float, crop as c_int, method as c_uint);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n@@ -410,7 +410,7 @@ pub fn translate<T:HasAfEnum>(input: &Array<T>, trans0: f32, trans1: f32,\n                                    input.get() as AfArray,\n                                    trans0 as c_float, trans1 as c_float,\n                                    odim0 as DimT, odim1 as DimT,\n-                                   method as uint8_t);\n+                                   method as c_uint);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n@@ -443,7 +443,7 @@ pub fn scale<T:HasAfEnum>(input: &Array<T>, scale0: f32, scale1: f32,\n                                input.get() as AfArray,\n                                scale0 as c_float, scale1 as c_float,\n                                odim0 as DimT, odim1 as DimT,\n-                               method as uint8_t);\n+                               method as c_uint);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n@@ -484,7 +484,7 @@ pub fn skew<T:HasAfEnum>(input: &Array<T>,\n         let err_val = af_skew(&mut temp as MutAfArray, input.get() as AfArray,\n                               skew0 as c_float, skew1 as c_float,\n                               odim0 as DimT, odim1 as DimT,\n-                              method as uint8_t, is_inverse as c_int);\n+                              method as c_uint, is_inverse as c_int);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n@@ -737,7 +737,7 @@ macro_rules! filt_func_def {\n             let mut temp: i64 = 0;\n             unsafe {\n                 let err_val = $ffi_name(&mut temp as MutAfArray, input.get() as AfArray,\n-                                        wlen as DimT, wwid as DimT, etype as uint8_t);\n+                                        wlen as DimT, wwid as DimT, etype as c_uint);\n                 HANDLE_ERROR(AfError::from(err_val));\n             }\n             temp.into()\n@@ -825,7 +825,7 @@ pub fn color_space<T>(input: &Array<T>,\n     let mut temp: i64 = 0;\n     unsafe {\n         let err_val = af_color_space(&mut temp as MutAfArray, input.get() as AfArray,\n-                                     tospace as uint8_t, fromspace as uint8_t);\n+                                     tospace as c_uint, fromspace as c_uint);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n@@ -856,7 +856,7 @@ pub fn regions<OutType>(input: &Array<bool>, conn: Connectivity) -> Array<OutTyp\n     let mut temp: i64 = 0;\n     unsafe {\n         let err_val = af_regions(&mut temp as MutAfArray, input.get() as AfArray,\n-                                 conn as uint8_t, otype as uint8_t);\n+                                 conn as c_uint, otype as c_uint);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n@@ -1291,7 +1291,7 @@ pub fn medfilt1<T>(input: &Array<T>, wlen: u64, etype: BorderType) -> Array<T>\n     let mut temp: i64 = 0;\n     unsafe {\n         let err_val = af_medfilt1(&mut temp as MutAfArray, input.get() as AfArray,\n-                                  wlen as DimT, etype as uint8_t);\n+                                  wlen as DimT, etype as c_uint);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n",
    "diff_parsed": "{'added': [(10, 'use self::libc::{c_uint, c_int, c_float, c_double, c_char};'), (20, '    fn af_cast(out: MutAfArray, arr: AfArray, aftype: c_uint) -> c_int;'), (28, '                 odim0: DimT, odim1: DimT, method: c_uint) -> c_int;'), (31, '                    odim0: DimT, odim1: DimT, method: c_uint, is_inverse: c_int) -> c_int;'), (34, '                 method: c_uint) -> c_int;'), (37, '                    odim0: DimT, odim1: DimT, method: c_uint) -> c_int;'), (40, '                odim0: DimT, odim1: DimT, method: c_uint) -> c_int;'), (43, '               odim0: DimT, odim1: DimT, method: c_uint, is_inverse: c_int) -> c_int;'), (52, '    fn af_regions(out: MutAfArray, input: AfArray, conn: c_uint, aftype: c_uint) -> c_int;'), (67, '                  wlen: DimT, wwid: DimT, etype: c_uint) -> c_int;'), (69, '    fn af_medfilt1(out: MutAfArray, input: AfArray, wlen: DimT, etype: c_uint) -> c_int;'), (72, '                  wlen: DimT, wwid: DimT, etype: c_uint) -> c_int;'), (75, '                  wlen: DimT, wwid: DimT, etype: c_uint) -> c_int;'), (81, '                      tospace: c_uint, fromspace: c_uint) -> c_int;'), (165, '        let err2 = af_cast(&mut img as MutAfArray, temp as AfArray, trgt_type as c_uint);'), (203, '        let err2 = af_cast(&mut img as MutAfArray, temp as AfArray, trgt_type as c_uint);'), (286, '                                odim0 as DimT, odim1 as DimT, method as c_uint);'), (330, '                                   method as c_uint, is_inverse as c_int);'), (371, '                                theta as c_float, crop as c_int, method as c_uint);'), (413, '                                   method as c_uint);'), (446, '                               method as c_uint);'), (487, '                              method as c_uint, is_inverse as c_int);'), (740, '                                        wlen as DimT, wwid as DimT, etype as c_uint);'), (828, '                                     tospace as c_uint, fromspace as c_uint);'), (859, '                                 conn as c_uint, otype as c_uint);'), (1294, '                                  wlen as DimT, etype as c_uint);')], 'deleted': [(10, 'use self::libc::{uint8_t, c_uint, c_int, c_float, c_double, c_char};'), (20, '    fn af_cast(out: MutAfArray, arr: AfArray, aftype: uint8_t) -> c_int;'), (28, '                 odim0: DimT, odim1: DimT, method: uint8_t) -> c_int;'), (31, '                    odim0: DimT, odim1: DimT, method: uint8_t, is_inverse: c_int) -> c_int;'), (34, '                 method: uint8_t) -> c_int;'), (37, '                    odim0: DimT, odim1: DimT, method: uint8_t) -> c_int;'), (40, '                odim0: DimT, odim1: DimT, method: uint8_t) -> c_int;'), (43, '               odim0: DimT, odim1: DimT, method: uint8_t, is_inverse: c_int) -> c_int;'), (52, '    fn af_regions(out: MutAfArray, input: AfArray, conn: uint8_t, aftype: uint8_t) -> c_int;'), (67, '                  wlen: DimT, wwid: DimT, etype: uint8_t) -> c_int;'), (69, '    fn af_medfilt1(out: MutAfArray, input: AfArray, wlen: DimT, etype: uint8_t) -> c_int;'), (72, '                  wlen: DimT, wwid: DimT, etype: uint8_t) -> c_int;'), (75, '                  wlen: DimT, wwid: DimT, etype: uint8_t) -> c_int;'), (81, '                      tospace: uint8_t, fromspace: uint8_t) -> c_int;'), (165, '        let err2 = af_cast(&mut img as MutAfArray, temp as AfArray, trgt_type as uint8_t);'), (203, '        let err2 = af_cast(&mut img as MutAfArray, temp as AfArray, trgt_type as uint8_t);'), (286, '                                odim0 as DimT, odim1 as DimT, method as uint8_t);'), (330, '                                   method as uint8_t, is_inverse as c_int);'), (371, '                                theta as c_float, crop as c_int, method as uint8_t);'), (413, '                                   method as uint8_t);'), (446, '                               method as uint8_t);'), (487, '                              method as uint8_t, is_inverse as c_int);'), (740, '                                        wlen as DimT, wwid as DimT, etype as uint8_t);'), (828, '                                     tospace as uint8_t, fromspace as uint8_t);'), (859, '                                 conn as uint8_t, otype as uint8_t);'), (1294, '                                  wlen as DimT, etype as uint8_t);')]}",
    "num_lines_added": "26",
    "num_lines_deleted": "26",
    "nloc": "596"
  },
  {
    "file_change_id": "208470013017860",
    "hash": "e7e291709240bd83ca35a12b85d87f074002be7",
    "old_path": "src/lapack/mod.rs",
    "new_path": "src/lapack/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -5,7 +5,7 @@ use defines::{AfError, MatProp, NormType};\n use error::HANDLE_ERROR;\n use util::{AfArray, MutAfArray, MutDouble, to_u32};\n use util::{FloatingPoint, HasAfEnum};\n-use self::libc::{uint8_t, c_int, c_uint, c_double};\n+use self::libc::{c_int, c_uint, c_double};\n \n #[allow(dead_code)]\n extern {\n@@ -22,7 +22,7 @@ extern {\n     fn af_inverse(out: MutAfArray, input: AfArray, options: c_uint) -> c_int;\n     fn af_rank(rank: *mut c_uint, input: AfArray, tol: c_double) -> c_int;\n     fn af_det(det_real: MutDouble, det_imag: MutDouble, input: AfArray) -> c_int;\n-    fn af_norm(out: MutDouble, input: AfArray, ntype: uint8_t, p: c_double, q: c_double) -> c_int;\n+    fn af_norm(out: MutDouble, input: AfArray, ntype: c_uint, p: c_double, q: c_double) -> c_int;\n     fn af_is_lapack_available(out: *mut c_int) -> c_int;\n }\n \n@@ -416,7 +416,7 @@ pub fn norm<T>(input: &Array<T>, ntype: NormType, p: f64, q: f64) -> f64\n     let mut out: f64 = 0.0;\n     unsafe {\n         let err_val = af_norm(&mut out as MutDouble, input.get() as AfArray,\n-                              ntype as uint8_t,\n+                              ntype as c_uint,\n                               p as c_double, q as c_double);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n",
    "diff_parsed": "{'added': [(8, 'use self::libc::{c_int, c_uint, c_double};'), (25, '    fn af_norm(out: MutDouble, input: AfArray, ntype: c_uint, p: c_double, q: c_double) -> c_int;'), (419, '                              ntype as c_uint,')], 'deleted': [(8, 'use self::libc::{uint8_t, c_int, c_uint, c_double};'), (25, '    fn af_norm(out: MutDouble, input: AfArray, ntype: uint8_t, p: c_double, q: c_double) -> c_int;'), (419, '                              ntype as uint8_t,')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "3",
    "nloc": "217"
  },
  {
    "file_change_id": "164649245536867",
    "hash": "e7e291709240bd83ca35a12b85d87f074002be7",
    "old_path": "src/random/mod.rs",
    "new_path": "src/random/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -4,7 +4,7 @@ use array::Array;\n use dim4::Dim4;\n use defines::{AfError, RandomEngineType};\n use error::HANDLE_ERROR;\n-use self::libc::{uint8_t, c_int, c_uint};\n+use self::libc::{c_int, c_uint};\n use util::{FloatingPoint, HasAfEnum};\n use util::{DimT, MutAfArray, MutRandEngine, RandEngine, Uintl};\n \n@@ -13,24 +13,24 @@ extern {\n     fn af_set_seed(seed: Uintl) -> c_int;\n     fn af_get_seed(seed: *mut Uintl) -> c_int;\n \n-    fn af_randu(out: MutAfArray, ndims: c_uint, dims: *const DimT, afdtype: uint8_t) -> c_int;\n-    fn af_randn(out: MutAfArray, ndims: c_uint, dims: *const DimT, afdtype: uint8_t) -> c_int;\n+    fn af_randu(out: MutAfArray, ndims: c_uint, dims: *const DimT, afdtype: c_uint) -> c_int;\n+    fn af_randn(out: MutAfArray, ndims: c_uint, dims: *const DimT, afdtype: c_uint) -> c_int;\n \n-    fn af_create_random_engine(engine: MutRandEngine, rtype: uint8_t, seed: Uintl) -> c_int;\n+    fn af_create_random_engine(engine: MutRandEngine, rtype: c_uint, seed: Uintl) -> c_int;\n     fn af_retain_random_engine(engine: MutRandEngine, inputEngine: RandEngine) -> c_int;\n-    fn af_random_engine_set_type(engine: MutRandEngine, rtpye: uint8_t) -> c_int;\n-    fn af_random_engine_get_type(rtype: *mut uint8_t, engine: RandEngine) -> c_int;\n+    fn af_random_engine_set_type(engine: MutRandEngine, rtpye: c_uint) -> c_int;\n+    fn af_random_engine_get_type(rtype: *mut c_uint, engine: RandEngine) -> c_int;\n     fn af_random_engine_set_seed(engine: MutRandEngine, seed: Uintl) -> c_int;\n     fn af_random_engine_get_seed(seed: *mut Uintl, engine: RandEngine) -> c_int;\n     fn af_release_random_engine(engine: RandEngine) -> c_int;\n \n     fn af_get_default_random_engine(engine: MutRandEngine) -> c_int;\n-    fn af_set_default_random_engine_type(rtype: uint8_t) -> c_int;\n+    fn af_set_default_random_engine_type(rtype: c_uint) -> c_int;\n \n     fn af_random_uniform(out: MutAfArray, ndims: c_uint, dims: *const DimT,\n-                         aftype: uint8_t, engine: RandEngine) -> c_int;\n+                         aftype: c_uint, engine: RandEngine) -> c_int;\n     fn af_random_normal(out: MutAfArray, ndims: c_uint, dims: *const DimT,\n-                        aftype: uint8_t, engine: RandEngine) -> c_int;\n+                        aftype: c_uint, engine: RandEngine) -> c_int;\n }\n \n /// Set seed for random number generation\n@@ -71,7 +71,7 @@ macro_rules! data_gen_def {\n             unsafe {\n                 let err_val = $ffi_name(&mut temp as MutAfArray,\n                                         dims.ndims() as c_uint, dims.get().as_ptr() as *const DimT,\n-                                        aftype as uint8_t);\n+                                        aftype as c_uint);\n                 HANDLE_ERROR(AfError::from(err_val));\n             }\n             temp.into()\n@@ -112,7 +112,7 @@ impl RandomEngine {\n     pub fn new(rengine: RandomEngineType, seed: Option<u64>) -> RandomEngine {\n         let mut temp: i64 = 0;\n         unsafe {\n-            let err_val = af_create_random_engine(&mut temp as MutRandEngine, rengine as uint8_t,\n+            let err_val = af_create_random_engine(&mut temp as MutRandEngine, rengine as c_uint,\n                                                   match seed {Some(s) => s, None => 0} as Uintl);\n             HANDLE_ERROR(AfError::from(err_val));\n         }\n@@ -121,20 +121,20 @@ impl RandomEngine {\n \n     /// Get random engine type\n     pub fn get_type(&self) -> RandomEngineType {\n-        let mut temp: u8 = 0;\n+        let mut temp: u32 = 0;\n         unsafe {\n-            let err_val = af_random_engine_get_type(&mut temp as *mut uint8_t,\n+            let err_val = af_random_engine_get_type(&mut temp as *mut c_uint,\n                                                     self.handle as RandEngine);\n             HANDLE_ERROR(AfError::from(err_val));\n         }\n-        RandomEngineType::from(temp as i32)\n+        RandomEngineType::from(temp)\n     }\n \n     /// Get random engine type\n     pub fn set_type(&mut self, engine_type: RandomEngineType) {\n         unsafe {\n             let err_val = af_random_engine_set_type(&mut self.handle as MutRandEngine,\n-                                                    engine_type as uint8_t);\n+                                                    engine_type as c_uint);\n             HANDLE_ERROR(AfError::from(err_val));\n         }\n     }\n@@ -206,7 +206,7 @@ pub fn get_default_random_engine() -> RandomEngine {\n /// - `rtype` can take one of the values of enum [RandomEngineType](./enum.RandomEngineType.html)\n pub fn set_default_random_engine_type(rtype: RandomEngineType) {\n     unsafe {\n-        let err_val = af_set_default_random_engine_type(rtype as uint8_t);\n+        let err_val = af_set_default_random_engine_type(rtype as c_uint);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n }\n@@ -228,7 +228,7 @@ where T: HasAfEnum {\n     unsafe {\n         let err_val = af_random_uniform(&mut temp as MutAfArray,\n                                         dims.ndims() as c_uint, dims.get().as_ptr() as *const DimT,\n-                                        aftype as uint8_t, engine.get() as RandEngine);\n+                                        aftype as c_uint, engine.get() as RandEngine);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n@@ -252,7 +252,7 @@ pub fn random_normal<T>(dims: Dim4, engine: &RandomEngine) -> Array<T>\n     unsafe {\n         let err_val = af_random_normal(&mut temp as MutAfArray,\n                                        dims.ndims() as c_uint, dims.get().as_ptr() as *const DimT,\n-                                       aftype as uint8_t, engine.get() as RandEngine);\n+                                       aftype as c_uint, engine.get() as RandEngine);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n",
    "diff_parsed": "{'added': [(7, 'use self::libc::{c_int, c_uint};'), (16, '    fn af_randu(out: MutAfArray, ndims: c_uint, dims: *const DimT, afdtype: c_uint) -> c_int;'), (17, '    fn af_randn(out: MutAfArray, ndims: c_uint, dims: *const DimT, afdtype: c_uint) -> c_int;'), (19, '    fn af_create_random_engine(engine: MutRandEngine, rtype: c_uint, seed: Uintl) -> c_int;'), (21, '    fn af_random_engine_set_type(engine: MutRandEngine, rtpye: c_uint) -> c_int;'), (22, '    fn af_random_engine_get_type(rtype: *mut c_uint, engine: RandEngine) -> c_int;'), (28, '    fn af_set_default_random_engine_type(rtype: c_uint) -> c_int;'), (31, '                         aftype: c_uint, engine: RandEngine) -> c_int;'), (33, '                        aftype: c_uint, engine: RandEngine) -> c_int;'), (74, '                                        aftype as c_uint);'), (115, '            let err_val = af_create_random_engine(&mut temp as MutRandEngine, rengine as c_uint,'), (124, '        let mut temp: u32 = 0;'), (126, '            let err_val = af_random_engine_get_type(&mut temp as *mut c_uint,'), (130, '        RandomEngineType::from(temp)'), (137, '                                                    engine_type as c_uint);'), (209, '        let err_val = af_set_default_random_engine_type(rtype as c_uint);'), (231, '                                        aftype as c_uint, engine.get() as RandEngine);'), (255, '                                       aftype as c_uint, engine.get() as RandEngine);')], 'deleted': [(7, 'use self::libc::{uint8_t, c_int, c_uint};'), (16, '    fn af_randu(out: MutAfArray, ndims: c_uint, dims: *const DimT, afdtype: uint8_t) -> c_int;'), (17, '    fn af_randn(out: MutAfArray, ndims: c_uint, dims: *const DimT, afdtype: uint8_t) -> c_int;'), (19, '    fn af_create_random_engine(engine: MutRandEngine, rtype: uint8_t, seed: Uintl) -> c_int;'), (21, '    fn af_random_engine_set_type(engine: MutRandEngine, rtpye: uint8_t) -> c_int;'), (22, '    fn af_random_engine_get_type(rtype: *mut uint8_t, engine: RandEngine) -> c_int;'), (28, '    fn af_set_default_random_engine_type(rtype: uint8_t) -> c_int;'), (31, '                         aftype: uint8_t, engine: RandEngine) -> c_int;'), (33, '                        aftype: uint8_t, engine: RandEngine) -> c_int;'), (74, '                                        aftype as uint8_t);'), (115, '            let err_val = af_create_random_engine(&mut temp as MutRandEngine, rengine as uint8_t,'), (124, '        let mut temp: u8 = 0;'), (126, '            let err_val = af_random_engine_get_type(&mut temp as *mut uint8_t,'), (130, '        RandomEngineType::from(temp as i32)'), (137, '                                                    engine_type as uint8_t);'), (209, '        let err_val = af_set_default_random_engine_type(rtype as uint8_t);'), (231, '                                        aftype as uint8_t, engine.get() as RandEngine);'), (255, '                                       aftype as uint8_t, engine.get() as RandEngine);')]}",
    "num_lines_added": "18",
    "num_lines_deleted": "18",
    "nloc": "178"
  },
  {
    "file_change_id": "30661467046364",
    "hash": "e7e291709240bd83ca35a12b85d87f074002be7",
    "old_path": "src/signal/mod.rs",
    "new_path": "src/signal/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -5,7 +5,7 @@ use array::Array;\n use defines::{AfError, ConvDomain, ConvMode, InterpType};\n use error::HANDLE_ERROR;\n use self::num::Complex;\n-use self::libc::{uint8_t, c_int, c_float, c_double, c_longlong, size_t};\n+use self::libc::{c_uint, c_int, c_float, c_double, c_longlong, size_t};\n use util::{ComplexFloating, FloatingPoint, HasAfEnum, RealFloating};\n use util::{AfArray, MutAfArray};\n \n@@ -55,13 +55,13 @@ extern {\n     fn af_fft2_c2r(out: MutAfArray, input: AfArray, nfac: c_double, is_odd: c_int) -> c_int;\n     fn af_fft3_c2r(out: MutAfArray, input: AfArray, nfac: c_double, is_odd: c_int) -> c_int;\n \n-    fn af_convolve1(out: MutAfArray, s: AfArray, f: AfArray, m: uint8_t, d: uint8_t) -> c_int;\n-    fn af_convolve2(out: MutAfArray, s: AfArray, f: AfArray, m: uint8_t, d: uint8_t) -> c_int;\n-    fn af_convolve3(out: MutAfArray, s: AfArray, f: AfArray, m: uint8_t, d: uint8_t) -> c_int;\n-    fn af_convolve2_sep(o: MutAfArray, c: AfArray, r: AfArray, s: AfArray, m: uint8_t) -> c_int;\n-    fn af_fft_convolve1(out: MutAfArray, s: AfArray, f: AfArray, m: uint8_t) -> c_int;\n-    fn af_fft_convolve2(out: MutAfArray, s: AfArray, f: AfArray, m: uint8_t) -> c_int;\n-    fn af_fft_convolve3(out: MutAfArray, s: AfArray, f: AfArray, m: uint8_t) -> c_int;\n+    fn af_convolve1(out: MutAfArray, s: AfArray, f: AfArray, m: c_uint, d: c_uint) -> c_int;\n+    fn af_convolve2(out: MutAfArray, s: AfArray, f: AfArray, m: c_uint, d: c_uint) -> c_int;\n+    fn af_convolve3(out: MutAfArray, s: AfArray, f: AfArray, m: c_uint, d: c_uint) -> c_int;\n+    fn af_convolve2_sep(o: MutAfArray, c: AfArray, r: AfArray, s: AfArray, m: c_uint) -> c_int;\n+    fn af_fft_convolve1(out: MutAfArray, s: AfArray, f: AfArray, m: c_uint) -> c_int;\n+    fn af_fft_convolve2(out: MutAfArray, s: AfArray, f: AfArray, m: c_uint) -> c_int;\n+    fn af_fft_convolve3(out: MutAfArray, s: AfArray, f: AfArray, m: c_uint) -> c_int;\n     fn af_fir(out: MutAfArray, b: AfArray, x: AfArray) -> c_int;\n     fn af_iir(out: MutAfArray, b: AfArray, a: AfArray, x: AfArray) -> c_int;\n }\n@@ -337,7 +337,7 @@ macro_rules! conv_func_def {\n             unsafe {\n                 let err_val = $ffi_name(&mut temp as MutAfArray,\n                                         signal.get() as AfArray, filter.get() as AfArray,\n-                                        mode as uint8_t, domain as uint8_t);\n+                                        mode as c_uint, domain as c_uint);\n                 HANDLE_ERROR(AfError::from(err_val));\n             }\n             temp.into()\n@@ -371,7 +371,7 @@ pub fn convolve2_sep<T, F>(cfilt: &Array<F>, rfilt: &Array<F>, signal: &Array<T>\n     unsafe {\n         let err_val = af_convolve2_sep(&mut temp as MutAfArray,\n                                        cfilt.get() as AfArray, rfilt.get() as AfArray,\n-                                       signal.get() as AfArray, mode as uint8_t);\n+                                       signal.get() as AfArray, mode as c_uint);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n@@ -400,7 +400,7 @@ macro_rules! fft_conv_func_def {\n             let mut temp: i64 = 0;\n             unsafe {\n                 let err_val = $ffi_name(&mut temp as MutAfArray, signal.get() as AfArray,\n-                                        filter.get() as AfArray, mode as uint8_t);\n+                                        filter.get() as AfArray, mode as c_uint);\n                 HANDLE_ERROR(AfError::from(err_val));\n             }\n             temp.into()\n",
    "diff_parsed": "{'added': [(8, 'use self::libc::{c_uint, c_int, c_float, c_double, c_longlong, size_t};'), (58, '    fn af_convolve1(out: MutAfArray, s: AfArray, f: AfArray, m: c_uint, d: c_uint) -> c_int;'), (59, '    fn af_convolve2(out: MutAfArray, s: AfArray, f: AfArray, m: c_uint, d: c_uint) -> c_int;'), (60, '    fn af_convolve3(out: MutAfArray, s: AfArray, f: AfArray, m: c_uint, d: c_uint) -> c_int;'), (61, '    fn af_convolve2_sep(o: MutAfArray, c: AfArray, r: AfArray, s: AfArray, m: c_uint) -> c_int;'), (62, '    fn af_fft_convolve1(out: MutAfArray, s: AfArray, f: AfArray, m: c_uint) -> c_int;'), (63, '    fn af_fft_convolve2(out: MutAfArray, s: AfArray, f: AfArray, m: c_uint) -> c_int;'), (64, '    fn af_fft_convolve3(out: MutAfArray, s: AfArray, f: AfArray, m: c_uint) -> c_int;'), (340, '                                        mode as c_uint, domain as c_uint);'), (374, '                                       signal.get() as AfArray, mode as c_uint);'), (403, '                                        filter.get() as AfArray, mode as c_uint);')], 'deleted': [(8, 'use self::libc::{uint8_t, c_int, c_float, c_double, c_longlong, size_t};'), (58, '    fn af_convolve1(out: MutAfArray, s: AfArray, f: AfArray, m: uint8_t, d: uint8_t) -> c_int;'), (59, '    fn af_convolve2(out: MutAfArray, s: AfArray, f: AfArray, m: uint8_t, d: uint8_t) -> c_int;'), (60, '    fn af_convolve3(out: MutAfArray, s: AfArray, f: AfArray, m: uint8_t, d: uint8_t) -> c_int;'), (61, '    fn af_convolve2_sep(o: MutAfArray, c: AfArray, r: AfArray, s: AfArray, m: uint8_t) -> c_int;'), (62, '    fn af_fft_convolve1(out: MutAfArray, s: AfArray, f: AfArray, m: uint8_t) -> c_int;'), (63, '    fn af_fft_convolve2(out: MutAfArray, s: AfArray, f: AfArray, m: uint8_t) -> c_int;'), (64, '    fn af_fft_convolve3(out: MutAfArray, s: AfArray, f: AfArray, m: uint8_t) -> c_int;'), (340, '                                        mode as uint8_t, domain as uint8_t);'), (374, '                                       signal.get() as AfArray, mode as uint8_t);'), (403, '                                        filter.get() as AfArray, mode as uint8_t);')]}",
    "num_lines_added": "11",
    "num_lines_deleted": "11",
    "nloc": "385"
  },
  {
    "file_change_id": "255639641168771",
    "hash": "e7e291709240bd83ca35a12b85d87f074002be7",
    "old_path": "src/sparse/mod.rs",
    "new_path": "src/sparse/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -3,26 +3,26 @@ extern crate libc;\n use array::Array;\n use defines::{AfError, SparseFormat};\n use error::HANDLE_ERROR;\n-use self::libc::{uint8_t, c_void, c_int};\n+use self::libc::{c_uint, c_void, c_int};\n use util::{AfArray, DimT, MutAfArray, MutDimT};\n use util::{FloatingPoint, HasAfEnum};\n \n #[allow(dead_code)]\n extern {\n     fn af_create_sparse_array(out: MutAfArray, nRows: DimT, nCols: DimT, vals: AfArray,\n-                              rowIdx: AfArray, colIdx: AfArray, stype: uint8_t) -> c_int;\n+                              rowIdx: AfArray, colIdx: AfArray, stype: c_uint) -> c_int;\n \n     fn af_create_sparse_array_from_ptr(out: MutAfArray, nRows: DimT, nCols: DimT, nNZ: DimT,\n                                        values: *const c_void, rowIdx: *const c_int, colIdx: *const c_int,\n-                                       aftype: uint8_t, stype: uint8_t, src: uint8_t) -> c_int;\n+                                       aftype: c_uint, stype: c_uint, src: c_uint) -> c_int;\n \n-    fn af_create_sparse_array_from_dense(out: MutAfArray, dense: AfArray, stype: uint8_t) -> c_int;\n+    fn af_create_sparse_array_from_dense(out: MutAfArray, dense: AfArray, stype: c_uint) -> c_int;\n \n-    fn af_sparse_convert_to(out: MutAfArray, input: AfArray, dstStrge: uint8_t) -> c_int;\n+    fn af_sparse_convert_to(out: MutAfArray, input: AfArray, dstStrge: c_uint) -> c_int;\n \n     fn af_sparse_to_dense(out: MutAfArray, sparse: AfArray) -> c_int;\n \n-    fn af_sparse_get_info(vals: MutAfArray, rIdx: MutAfArray, cIdx: MutAfArray, stype: *mut uint8_t,\n+    fn af_sparse_get_info(vals: MutAfArray, rIdx: MutAfArray, cIdx: MutAfArray, stype: *mut c_uint,\n                           input: AfArray) -> c_int;\n \n     fn af_sparse_get_values(out: MutAfArray, input: AfArray) -> c_int;\n@@ -33,7 +33,7 @@ extern {\n \n     fn af_sparse_get_nnz(out: MutDimT, input: AfArray) -> c_int;\n \n-    fn af_sparse_get_storage(out: *mut uint8_t, input: AfArray) -> c_int;\n+    fn af_sparse_get_storage(out: *mut c_uint, input: AfArray) -> c_int;\n }\n \n /// Create sprase matrix from arrays\n@@ -69,7 +69,7 @@ pub fn sparse<T>(rows: u64, cols: u64,\n     unsafe {\n         let err_val = af_create_sparse_array(&mut temp as MutAfArray, rows as DimT, cols as DimT,\n                                              values.get() as AfArray, row_indices.get() as AfArray,\n-                                             col_indices.get() as AfArray, format as uint8_t);\n+                                             col_indices.get() as AfArray, format as c_uint);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n@@ -112,7 +112,7 @@ pub fn sparse_from_host<T>(rows: u64, cols: u64, nzz: u64,\n                                                       values.as_ptr() as *const c_void,\n                                                       row_indices.as_ptr() as *const c_int,\n                                                       col_indices.as_ptr() as *const c_int,\n-                                                      aftype as uint8_t, format as uint8_t, 1);\n+                                                      aftype as c_uint, format as c_uint, 1);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n@@ -134,7 +134,7 @@ pub fn sparse_from_dense<T>(dense: &Array<T>, format: SparseFormat) -> Array<T>\n     let mut temp : i64 = 0;\n     unsafe {\n         let err_val = af_create_sparse_array_from_dense(&mut temp as MutAfArray, dense.get() as AfArray,\n-                                                        format as uint8_t);\n+                                                        format as c_uint);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n@@ -157,7 +157,7 @@ pub fn sparse_convert_to<T>(input: &Array<T>, format: SparseFormat) -> Array<T>\n     unsafe {\n         let err_val = af_sparse_convert_to(&mut temp as MutAfArray,\n                                            input.get() as AfArray,\n-                                           format as uint8_t);\n+                                           format as c_uint);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n@@ -196,17 +196,17 @@ pub fn sparse_to_dense<T>(input: &Array<T>) -> Array<T>\n pub fn sparse_get_info<T>(input: &Array<T>) -> (Array<T>, Array<i32>, Array<i32>, SparseFormat)\n     where T: HasAfEnum + FloatingPoint\n {\n-    let mut val : i64 = 0;\n-    let mut row : i64 = 0;\n-    let mut col : i64 = 0;\n-    let mut stype : u8 = 0;\n+    let mut val  : i64 = 0;\n+    let mut row  : i64 = 0;\n+    let mut col  : i64 = 0;\n+    let mut stype: u32 = 0;\n     unsafe {\n         let err_val = af_sparse_get_info(&mut val as MutAfArray, &mut row as MutAfArray,\n-                                         &mut col as MutAfArray, &mut stype as *mut uint8_t,\n+                                         &mut col as MutAfArray, &mut stype as *mut c_uint,\n                                          input.get() as AfArray);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n-    (val.into(), row.into(), col.into(), SparseFormat::from(stype as i32))\n+    (val.into(), row.into(), col.into(), SparseFormat::from(stype))\n }\n \n /// Get values of sparse Array\n@@ -297,10 +297,10 @@ pub fn sparse_get_nnz<T:HasAfEnum>(input: &Array<T>) -> i64 {\n ///\n /// Sparse array format\n pub fn sparse_get_format<T:HasAfEnum>(input: &Array<T>) -> SparseFormat {\n-    let mut stype : u8 = 0;\n+    let mut stype : u32 = 0;\n     unsafe {\n-        let err_val = af_sparse_get_storage(&mut stype as *mut uint8_t, input.get() as AfArray);\n+        let err_val = af_sparse_get_storage(&mut stype as *mut c_uint, input.get() as AfArray);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n-    SparseFormat::from(stype as i32)\n+    SparseFormat::from(stype)\n }\n",
    "diff_parsed": "{'added': [(6, 'use self::libc::{c_uint, c_void, c_int};'), (13, '                              rowIdx: AfArray, colIdx: AfArray, stype: c_uint) -> c_int;'), (17, '                                       aftype: c_uint, stype: c_uint, src: c_uint) -> c_int;'), (19, '    fn af_create_sparse_array_from_dense(out: MutAfArray, dense: AfArray, stype: c_uint) -> c_int;'), (21, '    fn af_sparse_convert_to(out: MutAfArray, input: AfArray, dstStrge: c_uint) -> c_int;'), (25, '    fn af_sparse_get_info(vals: MutAfArray, rIdx: MutAfArray, cIdx: MutAfArray, stype: *mut c_uint,'), (36, '    fn af_sparse_get_storage(out: *mut c_uint, input: AfArray) -> c_int;'), (72, '                                             col_indices.get() as AfArray, format as c_uint);'), (115, '                                                      aftype as c_uint, format as c_uint, 1);'), (137, '                                                        format as c_uint);'), (160, '                                           format as c_uint);'), (199, '    let mut val  : i64 = 0;'), (200, '    let mut row  : i64 = 0;'), (201, '    let mut col  : i64 = 0;'), (202, '    let mut stype: u32 = 0;'), (205, '                                         &mut col as MutAfArray, &mut stype as *mut c_uint,'), (209, '    (val.into(), row.into(), col.into(), SparseFormat::from(stype))'), (300, '    let mut stype : u32 = 0;'), (302, '        let err_val = af_sparse_get_storage(&mut stype as *mut c_uint, input.get() as AfArray);'), (305, '    SparseFormat::from(stype)')], 'deleted': [(6, 'use self::libc::{uint8_t, c_void, c_int};'), (13, '                              rowIdx: AfArray, colIdx: AfArray, stype: uint8_t) -> c_int;'), (17, '                                       aftype: uint8_t, stype: uint8_t, src: uint8_t) -> c_int;'), (19, '    fn af_create_sparse_array_from_dense(out: MutAfArray, dense: AfArray, stype: uint8_t) -> c_int;'), (21, '    fn af_sparse_convert_to(out: MutAfArray, input: AfArray, dstStrge: uint8_t) -> c_int;'), (25, '    fn af_sparse_get_info(vals: MutAfArray, rIdx: MutAfArray, cIdx: MutAfArray, stype: *mut uint8_t,'), (36, '    fn af_sparse_get_storage(out: *mut uint8_t, input: AfArray) -> c_int;'), (72, '                                             col_indices.get() as AfArray, format as uint8_t);'), (115, '                                                      aftype as uint8_t, format as uint8_t, 1);'), (137, '                                                        format as uint8_t);'), (160, '                                           format as uint8_t);'), (199, '    let mut val : i64 = 0;'), (200, '    let mut row : i64 = 0;'), (201, '    let mut col : i64 = 0;'), (202, '    let mut stype : u8 = 0;'), (205, '                                         &mut col as MutAfArray, &mut stype as *mut uint8_t,'), (209, '    (val.into(), row.into(), col.into(), SparseFormat::from(stype as i32))'), (300, '    let mut stype : u8 = 0;'), (302, '        let err_val = af_sparse_get_storage(&mut stype as *mut uint8_t, input.get() as AfArray);'), (305, '    SparseFormat::from(stype as i32)')]}",
    "num_lines_added": "20",
    "num_lines_deleted": "20",
    "nloc": "153"
  },
  {
    "file_change_id": "253657586497636",
    "hash": "e7e291709240bd83ca35a12b85d87f074002be7",
    "old_path": "src/statistics/mod.rs",
    "new_path": "src/statistics/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -3,7 +3,7 @@ extern crate libc;\n use array::Array;\n use defines::{AfError, TopkFn};\n use error::HANDLE_ERROR;\n-use self::libc::{c_int};\n+use self::libc::{c_int, c_uint};\n use util::{AfArray, DimT, MutAfArray, MutDouble};\n use util::{RealNumber, CovarianceComputable};\n use util::{HasAfEnum, MedianComputable, RealFloating};\n@@ -30,7 +30,7 @@ extern {\n \n     fn af_corrcoef(real: MutDouble, imag: MutDouble, X: AfArray, Y: AfArray) -> c_int;\n     fn af_topk(vals: MutAfArray, idxs: MutAfArray, arr: AfArray, k: c_int,\n-               dim: c_int, order: c_int) -> c_int;\n+               dim: c_int, order: c_uint) -> c_int;\n }\n \n /// Find the median along a given dimension\n@@ -336,7 +336,7 @@ pub fn topk<T>(input: &Array<T>, k: u32, dim: i32, order: TopkFn) -> (Array<T>,\n     unsafe {\n         let err_val = af_topk(&mut t0 as MutAfArray, &mut t1 as MutAfArray,\n                               input.get() as AfArray, k as c_int, dim as c_int,\n-                              order as c_int);\n+                              order as c_uint);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     (t0.into(), t1.into())\n",
    "diff_parsed": "{'added': [(6, 'use self::libc::{c_int, c_uint};'), (33, '               dim: c_int, order: c_uint) -> c_int;'), (339, '                              order as c_uint);')], 'deleted': [(6, 'use self::libc::{c_int};'), (33, '               dim: c_int, order: c_int) -> c_int;'), (339, '                              order as c_int);')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "3",
    "nloc": "199"
  },
  {
    "file_change_id": "164251579058815",
    "hash": "e7e291709240bd83ca35a12b85d87f074002be7",
    "old_path": "src/util.rs",
    "new_path": "src/util.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -7,7 +7,7 @@ use error::HANDLE_ERROR;\n use std::mem;\n use self::num::Complex;\n use num::Zero;\n-use self::libc::{uint8_t, c_int, size_t, c_void};\n+use self::libc::{c_uint, c_int, size_t, c_void};\n \n pub type AfArray       = self::libc::c_longlong;\n pub type AfIndex       = self::libc::c_longlong;\n@@ -32,7 +32,7 @@ pub type WndHandle     = self::libc::c_ulonglong;\n \n #[allow(dead_code)]\n extern {\n-    fn af_get_size_of(size: *mut size_t, aftype: uint8_t) -> c_int;\n+    fn af_get_size_of(size: *mut size_t, aftype: c_uint) -> c_int;\n \n     fn af_alloc_host(ptr: *mut *const c_void, bytes: DimT) -> c_int;\n     fn af_free_host(ptr: *mut c_void) -> c_int;\n@@ -42,7 +42,7 @@ extern {\n pub fn get_size(value: DType) -> usize {\n     unsafe {\n         let mut ret_val: usize = 0;\n-        let err_val = af_get_size_of(&mut ret_val as *mut size_t, value as uint8_t);\n+        let err_val = af_get_size_of(&mut ret_val as *mut size_t, value as c_uint);\n         HANDLE_ERROR(AfError::from(err_val));\n         ret_val\n     }\n@@ -75,37 +75,37 @@ impl From<i32> for AfError {\n     }\n }\n \n-impl From<i32> for DType {\n-    fn from(t: i32) -> DType {\n-        assert!(DType::F32 as i32 <= t && t <= DType::U64 as i32);\n+impl From<u32> for DType {\n+    fn from(t: u32) -> DType {\n+        assert!(DType::F32 as u32 <= t && t <= DType::U64 as u32);\n         unsafe { mem::transmute(t) }\n     }\n }\n \n-impl From<i32> for InterpType {\n-    fn from(t: i32) -> InterpType {\n-        assert!(InterpType::NEAREST as i32 <= t && t <= InterpType::BICUBIC_SPLINE as i32);\n+impl From<u32> for InterpType {\n+    fn from(t: u32) -> InterpType {\n+        assert!(InterpType::NEAREST as u32 <= t && t <= InterpType::BICUBIC_SPLINE as u32);\n         unsafe { mem::transmute(t) }\n     }\n }\n \n-impl From<i32> for ConvMode {\n-    fn from(t: i32) -> ConvMode {\n-        assert!(ConvMode::DEFAULT as i32 <= t && t <= ConvMode::EXPAND as i32);\n+impl From<u32> for ConvMode {\n+    fn from(t: u32) -> ConvMode {\n+        assert!(ConvMode::DEFAULT as u32 <= t && t <= ConvMode::EXPAND as u32);\n         unsafe { mem::transmute(t) }\n     }\n }\n \n-impl From<i32> for ConvDomain {\n-    fn from(t: i32) -> ConvDomain {\n-        assert!(ConvDomain::AUTO as i32 <= t && t <= ConvDomain::FREQUENCY as i32);\n+impl From<u32> for ConvDomain {\n+    fn from(t: u32) -> ConvDomain {\n+        assert!(ConvDomain::AUTO as u32 <= t && t <= ConvDomain::FREQUENCY as u32);\n         unsafe { mem::transmute(t) }\n     }\n }\n \n-impl From<i32> for MatchType {\n-    fn from(t: i32) -> MatchType {\n-        assert!(MatchType::SAD as i32 <= t && t <= MatchType::SHD as i32);\n+impl From<u32> for MatchType {\n+    fn from(t: u32) -> MatchType {\n+        assert!(MatchType::SAD as u32 <= t && t <= MatchType::SHD as u32);\n         unsafe { mem::transmute(t) }\n     }\n }\n@@ -126,9 +126,9 @@ pub fn to_u32(t: MatProp) -> u32 {\n     }\n }\n \n-impl From<i32> for ColorMap {\n-    fn from(t: i32) -> ColorMap {\n-        assert!(ColorMap::DEFAULT as i32 <= t && t <= ColorMap::BLUE as i32);\n+impl From<u32> for ColorMap {\n+    fn from(t: u32) -> ColorMap {\n+        assert!(ColorMap::DEFAULT as u32 <= t && t <= ColorMap::BLUE as u32);\n         unsafe { mem::transmute(t) }\n     }\n }\n@@ -357,23 +357,23 @@ impl HasAfEnum for u64  {\n     fn get_af_dtype() -> DType { DType::U64 }\n }\n \n-impl From<i32> for SparseFormat {\n-    fn from(t: i32) -> SparseFormat {\n-        assert!(SparseFormat::DENSE as i32 <= t && t <= SparseFormat::COO as i32);\n+impl From<u32> for SparseFormat {\n+    fn from(t: u32) -> SparseFormat {\n+        assert!(SparseFormat::DENSE as u32 <= t && t <= SparseFormat::COO as u32);\n         unsafe { mem::transmute(t) }\n     }\n }\n \n-impl From<i32> for BinaryOp {\n-    fn from(t: i32) -> BinaryOp {\n-        assert!(BinaryOp::ADD as i32 <= t && t <= BinaryOp::MAX as i32);\n+impl From<u32> for BinaryOp {\n+    fn from(t: u32) -> BinaryOp {\n+        assert!(BinaryOp::ADD as u32 <= t && t <= BinaryOp::MAX as u32);\n         unsafe { mem::transmute(t) }\n     }\n }\n \n-impl From<i32> for RandomEngineType {\n-    fn from(t: i32) -> RandomEngineType {\n-        assert!(RandomEngineType::PHILOX_4X32_10 as i32 <= t && t <= RandomEngineType::MERSENNE_GP11213 as i32);\n+impl From<u32> for RandomEngineType {\n+    fn from(t: u32) -> RandomEngineType {\n+        assert!(RandomEngineType::PHILOX_4X32_10 as u32 <= t && t <= RandomEngineType::MERSENNE_GP11213 as u32);\n         unsafe { mem::transmute(t) }\n     }\n }\n",
    "diff_parsed": "{'added': [(10, 'use self::libc::{c_uint, c_int, size_t, c_void};'), (35, '    fn af_get_size_of(size: *mut size_t, aftype: c_uint) -> c_int;'), (45, '        let err_val = af_get_size_of(&mut ret_val as *mut size_t, value as c_uint);'), (78, 'impl From<u32> for DType {'), (79, '    fn from(t: u32) -> DType {'), (80, '        assert!(DType::F32 as u32 <= t && t <= DType::U64 as u32);'), (85, 'impl From<u32> for InterpType {'), (86, '    fn from(t: u32) -> InterpType {'), (87, '        assert!(InterpType::NEAREST as u32 <= t && t <= InterpType::BICUBIC_SPLINE as u32);'), (92, 'impl From<u32> for ConvMode {'), (93, '    fn from(t: u32) -> ConvMode {'), (94, '        assert!(ConvMode::DEFAULT as u32 <= t && t <= ConvMode::EXPAND as u32);'), (99, 'impl From<u32> for ConvDomain {'), (100, '    fn from(t: u32) -> ConvDomain {'), (101, '        assert!(ConvDomain::AUTO as u32 <= t && t <= ConvDomain::FREQUENCY as u32);'), (106, 'impl From<u32> for MatchType {'), (107, '    fn from(t: u32) -> MatchType {'), (108, '        assert!(MatchType::SAD as u32 <= t && t <= MatchType::SHD as u32);'), (129, 'impl From<u32> for ColorMap {'), (130, '    fn from(t: u32) -> ColorMap {'), (131, '        assert!(ColorMap::DEFAULT as u32 <= t && t <= ColorMap::BLUE as u32);'), (360, 'impl From<u32> for SparseFormat {'), (361, '    fn from(t: u32) -> SparseFormat {'), (362, '        assert!(SparseFormat::DENSE as u32 <= t && t <= SparseFormat::COO as u32);'), (367, 'impl From<u32> for BinaryOp {'), (368, '    fn from(t: u32) -> BinaryOp {'), (369, '        assert!(BinaryOp::ADD as u32 <= t && t <= BinaryOp::MAX as u32);'), (374, 'impl From<u32> for RandomEngineType {'), (375, '    fn from(t: u32) -> RandomEngineType {'), (376, '        assert!(RandomEngineType::PHILOX_4X32_10 as u32 <= t && t <= RandomEngineType::MERSENNE_GP11213 as u32);')], 'deleted': [(10, 'use self::libc::{uint8_t, c_int, size_t, c_void};'), (35, '    fn af_get_size_of(size: *mut size_t, aftype: uint8_t) -> c_int;'), (45, '        let err_val = af_get_size_of(&mut ret_val as *mut size_t, value as uint8_t);'), (78, 'impl From<i32> for DType {'), (79, '    fn from(t: i32) -> DType {'), (80, '        assert!(DType::F32 as i32 <= t && t <= DType::U64 as i32);'), (85, 'impl From<i32> for InterpType {'), (86, '    fn from(t: i32) -> InterpType {'), (87, '        assert!(InterpType::NEAREST as i32 <= t && t <= InterpType::BICUBIC_SPLINE as i32);'), (92, 'impl From<i32> for ConvMode {'), (93, '    fn from(t: i32) -> ConvMode {'), (94, '        assert!(ConvMode::DEFAULT as i32 <= t && t <= ConvMode::EXPAND as i32);'), (99, 'impl From<i32> for ConvDomain {'), (100, '    fn from(t: i32) -> ConvDomain {'), (101, '        assert!(ConvDomain::AUTO as i32 <= t && t <= ConvDomain::FREQUENCY as i32);'), (106, 'impl From<i32> for MatchType {'), (107, '    fn from(t: i32) -> MatchType {'), (108, '        assert!(MatchType::SAD as i32 <= t && t <= MatchType::SHD as i32);'), (129, 'impl From<i32> for ColorMap {'), (130, '    fn from(t: i32) -> ColorMap {'), (131, '        assert!(ColorMap::DEFAULT as i32 <= t && t <= ColorMap::BLUE as i32);'), (360, 'impl From<i32> for SparseFormat {'), (361, '    fn from(t: i32) -> SparseFormat {'), (362, '        assert!(SparseFormat::DENSE as i32 <= t && t <= SparseFormat::COO as i32);'), (367, 'impl From<i32> for BinaryOp {'), (368, '    fn from(t: i32) -> BinaryOp {'), (369, '        assert!(BinaryOp::ADD as i32 <= t && t <= BinaryOp::MAX as i32);'), (374, 'impl From<i32> for RandomEngineType {'), (375, '    fn from(t: i32) -> RandomEngineType {'), (376, '        assert!(RandomEngineType::PHILOX_4X32_10 as i32 <= t && t <= RandomEngineType::MERSENNE_GP11213 as i32);')]}",
    "num_lines_added": "30",
    "num_lines_deleted": "30",
    "nloc": "539"
  },
  {
    "file_change_id": "246629148860722",
    "hash": "e7e291709240bd83ca35a12b85d87f074002be7",
    "old_path": "src/vision/mod.rs",
    "new_path": "src/vision/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -6,7 +6,7 @@ use defines::{AfError, HomographyType, MatchType};\n use error::HANDLE_ERROR;\n use util::{AfArray, DimT, Feat, MutAfArray, MutFeat};\n use util::{HasAfEnum, RealFloating, ImageFilterType};\n-use self::libc::{c_void, uint8_t, c_uint, c_int, c_float, c_double, c_longlong};\n+use self::libc::{c_void, c_uint, c_int, c_float, c_double, c_longlong};\n \n // af_sift and af_gloh uses patented algorithms, so didn't add them\n // they are built using installer builds\n@@ -39,7 +39,7 @@ extern {\n                             dist_dim: DimT, n_dist: c_uint, dist_type: c_int) -> c_int;\n \n     fn af_match_template(out: MutAfArray, search_img: AfArray, template_img: AfArray,\n-                         mtype: uint8_t) -> c_int;\n+                         mtype: c_uint) -> c_int;\n \n     fn af_susan(feat: MutFeat, i: AfArray, r: c_uint, d: c_float, g: c_float, f: c_float, e: c_uint) -> c_int;\n \n@@ -405,7 +405,7 @@ pub fn match_template<T>(search_img: &Array<T>,\n     unsafe {\n         let err_val = af_match_template(&mut temp as MutAfArray,\n                           search_img.get() as AfArray, template_img.get() as AfArray,\n-                          mtype as uint8_t);\n+                          mtype as c_uint);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n",
    "diff_parsed": "{'added': [(9, 'use self::libc::{c_void, c_uint, c_int, c_float, c_double, c_longlong};'), (42, '                         mtype: c_uint) -> c_int;'), (408, '                          mtype as c_uint);')], 'deleted': [(9, 'use self::libc::{c_void, uint8_t, c_uint, c_int, c_float, c_double, c_longlong};'), (42, '                         mtype: uint8_t) -> c_int;'), (408, '                          mtype as uint8_t);')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "3",
    "nloc": "265"
  },
  {
    "file_change_id": "197939986226376",
    "hash": "1b643df85ca4a56f7d96105a9eb35e1b917ee48",
    "old_path": "src/go_offset_log.rs",
    "new_path": "src/go_offset_log.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -215,8 +215,7 @@ where\n {\n     // Entry is [payload size: u64, payload ]\n \n-    let mut buf = Vec::with_capacity(frame.data_size);\n-    unsafe { buf.set_len(frame.data_size) };\n+    let mut buf = vec![0; frame.data_size];\n \n     let n = read_at(&mut buf, frame.data_start())?;\n     if n < frame.data_size {\n",
    "diff_parsed": "{'added': [(218, '    let mut buf = vec![0; frame.data_size];')], 'deleted': [(218, '    let mut buf = Vec::with_capacity(frame.data_size);'), (219, '    unsafe { buf.set_len(frame.data_size) };')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "2",
    "nloc": "268"
  },
  {
    "file_change_id": "212456862517565",
    "hash": "1b643df85ca4a56f7d96105a9eb35e1b917ee48",
    "old_path": "src/offset_log.rs",
    "new_path": "src/offset_log.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -335,8 +335,7 @@ where\n     let tail_size = size_of_frame_tail::<ByteType>();\n     let to_read = frame.data_size + tail_size;\n \n-    let mut buf = Vec::with_capacity(to_read);\n-    unsafe { buf.set_len(to_read) };\n+    let mut buf = vec![0; to_read];\n \n     let n = read_at(&mut buf, frame.data_start())?;\n     if n < to_read {\n@@ -353,7 +352,7 @@ where\n             offset: frame.offset,\n             data: buf,\n         },\n-        next: next,\n+        next,\n     })\n }\n \n",
    "diff_parsed": "{'added': [(338, '    let mut buf = vec![0; to_read];'), (355, '        next,')], 'deleted': [(338, '    let mut buf = Vec::with_capacity(to_read);'), (339, '    unsafe { buf.set_len(to_read) };'), (356, '        next: next,')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "3",
    "nloc": "585"
  },
  {
    "file_change_id": "240487279583862",
    "hash": "dd0639bf2876773b66382f47285f7db701f628d",
    "old_path": "src/main.rs",
    "new_path": "src/main.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -106,6 +106,14 @@ struct Server {\n     port_ranges: Vec<(u16, u16)>,\n }\n \n+impl Server {\n+    fn validate_hostname(&self) -> bool {\n+        self.hostname\n+            .chars()\n+            .all(|c| c.is_ascii_alphanumeric() || c == '-')\n+    }\n+}\n+\n // latitude and longitude omitted\n #[derive(serde::Deserialize)]\n struct City {\n@@ -130,13 +138,26 @@ struct ServerList {\n \n impl ServerList {\n     fn new(client: reqwest::blocking::Client, token: &str) -> Self {\n-        client\n+        let server_list = client\n             .get(&format!(\"{}/vpn/servers\", BASE_URL))\n             .bearer_auth(token)\n             .send()\n             .unwrap()\n             .json::<ServerList>()\n-            .unwrap()\n+            .unwrap();\n+        if let Some(server) = server_list\n+            .countries\n+            .iter()\n+            .flat_map(|country| country.cities.iter().flat_map(|city| city.servers.iter()))\n+            .find(|server| !server.validate_hostname())\n+        {\n+            eprintln!(\n+                \"A server contains invalid characters in its hostname: {}\",\n+                server.hostname\n+            );\n+            std::process::exit(3);\n+        }\n+        server_list\n     }\n }\n \n",
    "diff_parsed": "{'added': [(109, 'impl Server {'), (110, '    fn validate_hostname(&self) -> bool {'), (111, '        self.hostname'), (112, '            .chars()'), (113, \"            .all(|c| c.is_ascii_alphanumeric() || c == '-')\"), (114, '    }'), (115, '}'), (141, '        let server_list = client'), (147, '            .unwrap();'), (148, '        if let Some(server) = server_list'), (149, '            .countries'), (150, '            .iter()'), (151, '            .flat_map(|country| country.cities.iter().flat_map(|city| city.servers.iter()))'), (152, '            .find(|server| !server.validate_hostname())'), (153, '        {'), (154, '            eprintln!('), (155, '                \"A server contains invalid characters in its hostname: {}\",'), (156, '                server.hostname'), (157, '            );'), (158, '            std::process::exit(3);'), (159, '        }'), (160, '        server_list')], 'deleted': [(133, '        client'), (139, '            .unwrap()')]}",
    "num_lines_added": "22",
    "num_lines_deleted": "2",
    "nloc": "523"
  },
  {
    "file_change_id": "89398062357828",
    "hash": "f9e8a1c13cca73e356b48f8a16a6bd308f20988",
    "old_path": "src/sync/ms_queue.rs",
    "new_path": "src/sync/ms_queue.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -174,7 +174,7 @@ impl<T> MsQueue<T> {\n                         unsafe {\n                             // signal the thread\n                             (*signal).data = Some(cache.into_data());\n-                            (*signal).ready.store(true, Relaxed);\n+                            (*signal).ready.store(true, Release);\n                             (*signal).thread.unpark();\n                             guard.unlinked(head);\n                             return;\n@@ -295,7 +295,7 @@ impl<T> MsQueue<T> {\n             // case, blocked.\n             match self.push_internal(&guard, tail, node) {\n                 Ok(()) => {\n-                    while !signal.ready.load(Relaxed) {\n+                    while !signal.ready.load(Acquire) {\n                         thread::park();\n                     }\n                     return signal.data.unwrap();\n",
    "diff_parsed": "{'added': [(177, '                            (*signal).ready.store(true, Release);'), (298, '                    while !signal.ready.load(Acquire) {')], 'deleted': [(177, '                            (*signal).ready.store(true, Relaxed);'), (298, '                    while !signal.ready.load(Relaxed) {')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "392"
  },
  {
    "file_change_id": "52281260016306",
    "hash": "f86e6d392326f0e4dc25eeec8b26af36f2b0fbc",
    "old_path": "src/instance.rs",
    "new_path": "src/instance.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -494,9 +494,9 @@ impl<T> std::convert::From<Py<T>> for PyObject\n where\n     T: AsRef<PyAny>,\n {\n+    #[inline]\n     fn from(other: Py<T>) -> Self {\n-        let Py(ptr, _) = other;\n-        Py(ptr, PhantomData)\n+        unsafe { Self::from_non_null(other.into_non_null()) }\n     }\n }\n \n@@ -647,4 +647,14 @@ mod test {\n         };\n         assert_eq!(unsafe { ffi::Py_REFCNT(dict.as_ptr()) }, 1);\n     }\n+\n+    #[test]\n+    fn pyobject_from_py() {\n+        Python::with_gil(|py| {\n+            let dict: Py<PyDict> = PyDict::new(py).into();\n+            let cnt = dict.get_refcnt(py);\n+            let p: PyObject = dict.into();\n+            assert_eq!(p.get_refcnt(py), cnt);\n+        });\n+    }\n }\n",
    "diff_parsed": "{'added': [(497, '    #[inline]'), (499, '        unsafe { Self::from_non_null(other.into_non_null()) }'), (651, '    #[test]'), (652, '    fn pyobject_from_py() {'), (653, '        Python::with_gil(|py| {'), (654, '            let dict: Py<PyDict> = PyDict::new(py).into();'), (655, '            let cnt = dict.get_refcnt(py);'), (656, '            let p: PyObject = dict.into();'), (657, '            assert_eq!(p.get_refcnt(py), cnt);'), (658, '        });'), (659, '    }')], 'deleted': [(498, '        let Py(ptr, _) = other;'), (499, '        Py(ptr, PhantomData)')]}",
    "num_lines_added": "11",
    "num_lines_deleted": "2",
    "nloc": "404"
  },
  {
    "file_change_id": "175650609377847",
    "hash": "45f172cf8407e05cb9ed431f68663ad4f46b232",
    "old_path": "streebog/src/streebog.rs",
    "new_path": "streebog/src/streebog.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -61,12 +61,10 @@ impl StreebogState {\n     }\n \n     fn update_sigma(&mut self, m: &Block) {\n-        let mut over = false;\n+        let mut carry = 0;\n         for (a, b) in self.sigma.iter_mut().zip(m.iter()) {\n-            let (res, loc_over) = (*a).overflowing_add(*b);\n-            *a = res;\n-            if over { *a += 1; }\n-            over = loc_over;\n+            carry = (*a as u16) + (*b as u16) + (carry >> 8);\n+            *a = (carry & 0xFF) as u8;\n         }\n     }\n \n",
    "diff_parsed": "{'added': [(64, '        let mut carry = 0;'), (66, '            carry = (*a as u16) + (*b as u16) + (carry >> 8);'), (67, '            *a = (carry & 0xFF) as u8;')], 'deleted': [(64, '        let mut over = false;'), (66, '            let (res, loc_over) = (*a).overflowing_add(*b);'), (67, '            *a = res;'), (68, '            if over { *a += 1; }'), (69, '            over = loc_over;')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "5",
    "nloc": "137"
  },
  {
    "file_change_id": "26255975533873",
    "hash": "bbe7cc5381c5380b54fb8bbb4f77a3725917ff0",
    "old_path": "src/transport/sendmail/mod.rs",
    "new_path": "src/transport/sendmail/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -120,6 +120,7 @@ impl SendmailTransport {\n         c.arg(\"-i\")\n             .arg(\"-f\")\n             .arg(envelope.from().map(|f| f.as_ref()).unwrap_or(\"\\\"\\\"\"))\n+            .arg(\"--\")\n             .args(envelope.to())\n             .stdin(Stdio::piped())\n             .stdout(Stdio::piped());\n@@ -135,6 +136,7 @@ impl SendmailTransport {\n         c.arg(\"-i\")\n             .arg(\"-f\")\n             .arg(envelope.from().map(|f| f.as_ref()).unwrap_or(\"\\\"\\\"\"))\n+            .arg(\"--\")\n             .args(envelope.to())\n             .stdin(Stdio::piped())\n             .stdout(Stdio::piped());\n@@ -150,6 +152,7 @@ impl SendmailTransport {\n         c.arg(\"-i\")\n             .arg(\"-f\")\n             .arg(envelope.from().map(|f| f.as_ref()).unwrap_or(\"\\\"\\\"\"))\n+            .arg(\"--\")\n             .args(envelope.to())\n             .stdin(Stdio::piped())\n             .stdout(Stdio::piped());\n",
    "diff_parsed": "{'added': [(123, '            .arg(\"--\")'), (139, '            .arg(\"--\")'), (155, '            .arg(\"--\")')], 'deleted': []}",
    "num_lines_added": "3",
    "num_lines_deleted": "0",
    "nloc": "150"
  },
  {
    "file_change_id": "196628380876484",
    "hash": "414bc9e7abac7500312e0324378ec320c079a98",
    "old_path": "src/transport/sendmail/mod.rs",
    "new_path": "src/transport/sendmail/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -117,10 +117,11 @@ impl SendmailTransport {\n \n     fn command(&self, envelope: &Envelope) -> Command {\n         let mut c = Command::new(&self.command);\n-        c.arg(\"-i\")\n-            .arg(\"-f\")\n-            .arg(envelope.from().map(|f| f.as_ref()).unwrap_or(\"\\\"\\\"\"))\n-            .arg(\"--\")\n+        c.arg(\"-i\");\n+        if let Some(from) = envelope.from() {\n+            c.arg(\"-f\").arg(from);\n+        }\n+        c.arg(\"--\")\n             .args(envelope.to())\n             .stdin(Stdio::piped())\n             .stdout(Stdio::piped());\n@@ -133,10 +134,11 @@ impl SendmailTransport {\n \n         let mut c = Command::new(&self.command);\n         c.kill_on_drop(true);\n-        c.arg(\"-i\")\n-            .arg(\"-f\")\n-            .arg(envelope.from().map(|f| f.as_ref()).unwrap_or(\"\\\"\\\"\"))\n-            .arg(\"--\")\n+        c.arg(\"-i\");\n+        if let Some(from) = envelope.from() {\n+            c.arg(\"-f\").arg(from);\n+        }\n+        c.arg(\"--\")\n             .args(envelope.to())\n             .stdin(Stdio::piped())\n             .stdout(Stdio::piped());\n@@ -149,10 +151,11 @@ impl SendmailTransport {\n \n         let mut c = Command::new(&self.command);\n         c.kill_on_drop(true);\n-        c.arg(\"-i\")\n-            .arg(\"-f\")\n-            .arg(envelope.from().map(|f| f.as_ref()).unwrap_or(\"\\\"\\\"\"))\n-            .arg(\"--\")\n+        c.arg(\"-i\");\n+        if let Some(from) = envelope.from() {\n+            c.arg(\"-f\").arg(from);\n+        }\n+        c.arg(\"--\")\n             .args(envelope.to())\n             .stdin(Stdio::piped())\n             .stdout(Stdio::piped());\n",
    "diff_parsed": "{'added': [(120, '        c.arg(\"-i\");'), (121, '        if let Some(from) = envelope.from() {'), (122, '            c.arg(\"-f\").arg(from);'), (123, '        }'), (124, '        c.arg(\"--\")'), (137, '        c.arg(\"-i\");'), (138, '        if let Some(from) = envelope.from() {'), (139, '            c.arg(\"-f\").arg(from);'), (140, '        }'), (141, '        c.arg(\"--\")'), (154, '        c.arg(\"-i\");'), (155, '        if let Some(from) = envelope.from() {'), (156, '            c.arg(\"-f\").arg(from);'), (157, '        }'), (158, '        c.arg(\"--\")')], 'deleted': [(120, '        c.arg(\"-i\")'), (121, '            .arg(\"-f\")'), (122, '            .arg(envelope.from().map(|f| f.as_ref()).unwrap_or(\"\\\\\"\\\\\"\"))'), (123, '            .arg(\"--\")'), (136, '        c.arg(\"-i\")'), (137, '            .arg(\"-f\")'), (138, '            .arg(envelope.from().map(|f| f.as_ref()).unwrap_or(\"\\\\\"\\\\\"\"))'), (139, '            .arg(\"--\")'), (152, '        c.arg(\"-i\")'), (153, '            .arg(\"-f\")'), (154, '            .arg(envelope.from().map(|f| f.as_ref()).unwrap_or(\"\\\\\"\\\\\"\"))'), (155, '            .arg(\"--\")')]}",
    "num_lines_added": "15",
    "num_lines_deleted": "12",
    "nloc": "153"
  },
  {
    "file_change_id": "159906672727159",
    "hash": "76bc9b5fbae73262307c41e72dbcfa0796073f3",
    "old_path": "src/array.rs",
    "new_path": "src/array.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -174,26 +174,24 @@ macro_rules! impl_array {\n         where\n             F: FnMut(T) -> U,\n         {\n-            fn map_array(mut values: [T; $size], mut f: F) -> Self {\n+            fn map_array(values: [T; $size], mut f: F) -> Self {\n                 use std::{\n-                    mem::forget,\n+                    mem::{ManuallyDrop, MaybeUninit},\n                     ptr::{read, write},\n                 };\n \n+                // Use `ManuallyDrop<_>` to guard against panic safety issue.\n+                // Upon panic in `f`, `values` isn't dropped\n+                // and thus item copied by `read()` is dropped only once.\n+                let mut values = ManuallyDrop::new(values);\n                 unsafe {\n-                    // All elements of `result` is written.\n-                    // Each element of `values` read once and then forgotten.\n-                    // Hence safe in case `f` never panics.\n-                    // TODO: Make it panic-safe.\n-                    let mut result: ::std::mem::MaybeUninit<[U; $size]> =\n-                        ::std::mem::MaybeUninit::zeroed();\n+                    let mut result: MaybeUninit<[U; $size]> = MaybeUninit::zeroed();\n                     for i in 0..$size {\n                         write(\n                             result.as_mut_ptr().cast::<U>().add(i),\n                             f(read(&mut values[i])),\n                         );\n                     }\n-                    forget(values);\n                     result.assume_init()\n                 }\n             }\n",
    "diff_parsed": "{'added': [(177, '            fn map_array(values: [T; $size], mut f: F) -> Self {'), (179, '                    mem::{ManuallyDrop, MaybeUninit},'), (186, '                let mut values = ManuallyDrop::new(values);'), (188, '                    let mut result: MaybeUninit<[U; $size]> = MaybeUninit::zeroed();')], 'deleted': [(177, '            fn map_array(mut values: [T; $size], mut f: F) -> Self {'), (179, '                    mem::forget,'), (188, '                    let mut result: ::std::mem::MaybeUninit<[U; $size]> ='), (189, '                        ::std::mem::MaybeUninit::zeroed();'), (196, '                    forget(values);')]}",
    "num_lines_added": "4",
    "num_lines_deleted": "5",
    "nloc": "265"
  },
  {
    "file_change_id": "206233344722417",
    "hash": "ee5d1cf3b2df709ae1521d11521f38e335c45be",
    "old_path": "tokio-rustls/src/common/mod.rs",
    "new_path": "tokio-rustls/src/common/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -218,7 +218,10 @@ impl<'a, IO: AsyncRead + AsyncWrite + Unpin, S: Session> Stream<'a, IO, S> {\n             while !self.eof && self.session.wants_read() {\n                 match self.read_io(cx) {\n                     Poll::Ready(Ok(0)) => self.eof = true,\n-                    Poll::Ready(Ok(n)) => rdlen += n,\n+                    Poll::Ready(Ok(n)) => {\n+                        rdlen += n;\n+                        self.process_new_packets(cx)?;\n+                    }\n                     Poll::Pending => {\n                         read_would_block = true;\n                         break;\n@@ -227,8 +230,6 @@ impl<'a, IO: AsyncRead + AsyncWrite + Unpin, S: Session> Stream<'a, IO, S> {\n                 }\n             }\n \n-            self.process_new_packets(cx)?;\n-\n             return match (self.eof, self.session.is_handshaking()) {\n                 (true, true) => {\n                     let err = io::Error::new(io::ErrorKind::UnexpectedEof, \"tls handshake eof\");\n@@ -266,7 +267,7 @@ impl<'a, IO: AsyncRead + AsyncWrite + Unpin, S: Session> AsyncRead for Stream<'a\n                         self.eof = true;\n                         break;\n                     }\n-                    Poll::Ready(Ok(_)) => (),\n+                    Poll::Ready(Ok(_)) => self.process_new_packets(cx)?,\n                     Poll::Pending => {\n                         would_block = true;\n                         break;\n@@ -275,8 +276,6 @@ impl<'a, IO: AsyncRead + AsyncWrite + Unpin, S: Session> AsyncRead for Stream<'a\n                 }\n             }\n \n-            self.process_new_packets(cx)?;\n-\n             return match self.session.read(&mut buf[pos..]) {\n                 Ok(0) if pos == 0 && would_block => Poll::Pending,\n                 Ok(n) if self.eof || would_block => Poll::Ready(Ok(pos + n)),\n",
    "diff_parsed": "{'added': [(221, '                    Poll::Ready(Ok(n)) => {'), (222, '                        rdlen += n;'), (223, '                        self.process_new_packets(cx)?;'), (224, '                    }'), (270, '                    Poll::Ready(Ok(_)) => self.process_new_packets(cx)?,')], 'deleted': [(221, '                    Poll::Ready(Ok(n)) => rdlen += n,'), (230, '            self.process_new_packets(cx)?;'), (269, '                    Poll::Ready(Ok(_)) => (),'), (278, '            self.process_new_packets(cx)?;')]}",
    "num_lines_added": "5",
    "num_lines_deleted": "4",
    "nloc": "333"
  },
  {
    "file_change_id": "59766125992021",
    "hash": "a986a9335d591fa5c826157d1674d47aa525357",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -50,7 +50,7 @@ pub struct ReadTicket<T> {\n     data: Arc<UnsafeCell<T>>,\n }\n \n-unsafe impl<T> Send for ReadTicket<T> {}\n+unsafe impl<T: Send> Send for ReadTicket<T> {}\n \n #[cfg(not(feature = \"futures\"))]\n impl<T> ReadTicket<T> {\n@@ -112,7 +112,7 @@ pub struct WriteTicket<T> {\n     data: Arc<UnsafeCell<T>>,\n }\n \n-unsafe impl<T> Send for WriteTicket<T> {}\n+unsafe impl<T: Send> Send for WriteTicket<T> {}\n \n #[cfg(not(feature = \"futures\"))]\n impl<T> WriteTicket<T> {\n",
    "diff_parsed": "{'added': [(53, 'unsafe impl<T: Send> Send for ReadTicket<T> {}'), (115, 'unsafe impl<T: Send> Send for WriteTicket<T> {}')], 'deleted': [(53, 'unsafe impl<T> Send for ReadTicket<T> {}'), (115, 'unsafe impl<T> Send for WriteTicket<T> {}')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "139"
  },
  {
    "file_change_id": "256076864343622",
    "hash": "1a2efcdbe68e5e7fd0a05836ac32d2cde78a0b2",
    "old_path": "tests/script.rs",
    "new_path": "tests/script.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -51,6 +51,7 @@ macro_rules! test_cases {\n                 out_json.reverse();\n \n                 let mut results = Vec::new();\n+                let mut state = Value::null();\n                 for (id, mut json) in in_json.into_iter().enumerate() {\n                     let uri = EventOriginUri{\n                         host: \"test\".into(),\n@@ -62,7 +63,6 @@ macro_rules! test_cases {\n                     };\n                     let context = EventContext::new(id as u64, Some(&uri));\n                     let mut meta = Value::from(Object::default());\n-                    let mut state = Value::null();\n                     match script.run(&context, AggrType::Tick, &mut json, &mut state, &mut meta)? {\n                         Return::Drop => (),\n                         Return::EmitEvent{..} => results.push(json),\n@@ -154,6 +154,7 @@ test_cases!(\n     // TODO\n     // const_in_const_lookup,\n     // INSERT\n+    merge_assign_target_state,\n     expr_path,\n     patch_default,\n     patch_default_key,\n@@ -186,7 +187,7 @@ test_cases!(\n     heredoc_quoted_curly,\n     string_interpolation_import,\n     string_interpolation_prefix,\n-    patch_in_place,\n+    patch_assign_target,\n     tuple_pattern,\n     pattern_cmp,\n     pass_args,\n",
    "diff_parsed": "{'added': [(54, '                let mut state = Value::null();'), (157, '    merge_assign_target_state,'), (190, '    patch_assign_target,')], 'deleted': [(65, '                    let mut state = Value::null();'), (189, '    patch_in_place,')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "2",
    "nloc": "179"
  },
  {
    "file_change_id": "46597822567096",
    "hash": "1a2efcdbe68e5e7fd0a05836ac32d2cde78a0b2",
    "old_path": "tests/script_runtime_error.rs",
    "new_path": "tests/script_runtime_error.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -105,10 +105,10 @@ macro_rules! ignore_cases {\n                 file.read_to_string(&mut err)?;\n                 let _err = err.trim();\n \n+                let mut state = Value::null();\n                 if let Some(mut json) =  in_json.pop() {\n                     let context = EventContext::new(0, None);\n                     let mut meta = Value::object();\n-                    let mut state = Value::null();\n                     let s = script.run(&context, AggrType::Tick, &mut json, &mut state, &mut meta);\n                     if let Err(e) = s {\n                         let mut h = Dumb::new();\n@@ -144,8 +144,8 @@ test_cases!(\n     function_error_n,\n     match_bad_guard_type,\n     match_no_clause_hit,\n-    merge_in_place_new_no_object,\n-    merge_in_place_target_no_object,\n+    merge_assign_target_new_no_object,\n+    merge_assign_target_target_no_object,\n     merge_new_no_object,\n     merge_target_no_object,\n     missing_local,\n",
    "diff_parsed": "{'added': [(108, '                let mut state = Value::null();'), (147, '    merge_assign_target_new_no_object,'), (148, '    merge_assign_target_target_no_object,')], 'deleted': [(111, '                    let mut state = Value::null();'), (147, '    merge_in_place_new_no_object,'), (148, '    merge_in_place_target_no_object,')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "3",
    "nloc": "149"
  },
  {
    "file_change_id": "279619756487453",
    "hash": "1a2efcdbe68e5e7fd0a05836ac32d2cde78a0b2",
    "old_path": "tremor-script/src/ast.rs",
    "new_path": "tremor-script/src/ast.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -961,10 +961,6 @@ pub enum Expr<'script> {\n     Match(Box<Match<'script, Self>>),\n     /// IfElse style match expression\n     IfElse(Box<IfElse<'script, Self>>),\n-    /// In place patch expression\n-    PatchInPlace(Box<Patch<'script>>),\n-    /// In place merge expression\n-    MergeInPlace(Box<Merge<'script>>),\n     /// Assignment expression\n     Assign {\n         /// Id\n",
    "diff_parsed": "{'added': [], 'deleted': [(965, \"    PatchInPlace(Box<Patch<'script>>),\"), (967, \"    MergeInPlace(Box<Merge<'script>>),\")]}",
    "num_lines_added": "0",
    "num_lines_deleted": "2",
    "nloc": "2420"
  },
  {
    "file_change_id": "71253403425755",
    "hash": "1a2efcdbe68e5e7fd0a05836ac32d2cde78a0b2",
    "old_path": "tremor-script/src/ast/base_expr.rs",
    "new_path": "tremor-script/src/ast/base_expr.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -248,8 +248,6 @@ impl<'script> BaseExpr for Expr<'script> {\n             Expr::Emit(e) => e.mid(),\n             Expr::Imut(e) => e.mid(),\n             Expr::Match(e) => e.mid(),\n-            Expr::MergeInPlace(e) => e.mid(),\n-            Expr::PatchInPlace(e) => e.mid(),\n             Expr::IfElse(e) => e.mid(),\n         }\n     }\n",
    "diff_parsed": "{'added': [], 'deleted': [(251, '            Expr::MergeInPlace(e) => e.mid(),'), (252, '            Expr::PatchInPlace(e) => e.mid(),')]}",
    "num_lines_added": "0",
    "num_lines_deleted": "2",
    "nloc": "497"
  },
  {
    "file_change_id": "215579316531171",
    "hash": "1a2efcdbe68e5e7fd0a05836ac32d2cde78a0b2",
    "old_path": "tremor-script/src/ast/raw.rs",
    "new_path": "tremor-script/src/ast/raw.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -18,14 +18,14 @@\n \n use crate::{\n     ast::{\n-        base_expr, eq::AstEq, query, upable::Upable, ArrayPattern, ArrayPredicatePattern,\n-        AssignPattern, BinExpr, BinOpKind, Bytes, BytesPart, ClauseGroup, Comprehension,\n-        ComprehensionCase, Costly, DefaultCase, EmitExpr, EventPath, Expr, ExprPath, Expression,\n-        Field, FnDecl, FnDoc, Helper, Ident, IfElse, ImutExpr, ImutExprInt, Invocable, Invoke,\n-        InvokeAggr, InvokeAggrFn, List, Literal, LocalPath, Match, Merge, MetadataPath, ModDoc,\n-        NodeMetas, Patch, PatchOperation, Path, Pattern, PredicateClause, PredicatePattern, Record,\n-        RecordPattern, Recur, ReservedPath, Script, Segment, StatePath, StrLitElement, StringLit,\n-        TestExpr, TuplePattern, UnaryExpr, UnaryOpKind,\n+        base_expr, query, upable::Upable, ArrayPattern, ArrayPredicatePattern, AssignPattern,\n+        BinExpr, BinOpKind, Bytes, BytesPart, ClauseGroup, Comprehension, ComprehensionCase,\n+        Costly, DefaultCase, EmitExpr, EventPath, Expr, ExprPath, Expression, Field, FnDecl, FnDoc,\n+        Helper, Ident, IfElse, ImutExpr, ImutExprInt, Invocable, Invoke, InvokeAggr, InvokeAggrFn,\n+        List, Literal, LocalPath, Match, Merge, MetadataPath, ModDoc, NodeMetas, Patch,\n+        PatchOperation, Path, Pattern, PredicateClause, PredicatePattern, Record, RecordPattern,\n+        Recur, ReservedPath, Script, Segment, StatePath, StrLitElement, StringLit, TestExpr,\n+        TuplePattern, UnaryExpr, UnaryOpKind,\n     },\n     errors::{\n         err_generic, error_generic, error_missing_effector, error_oops, Error, ErrorKind, Result,\n@@ -646,28 +646,16 @@ impl<'script> Upable<'script> for ExprRaw<'script> {\n                 let path = a.path.up(helper)?;\n                 let mid = helper.add_meta(a.start, a.end);\n                 match a.expr.up(helper)? {\n-                    Expr::Imut(ImutExprInt::Merge(m)) => {\n-                        if path.ast_eq(&m.target) {\n-                            Expr::MergeInPlace(Box::new(*m))\n-                        } else {\n-                            Expr::Assign {\n-                                mid,\n-                                path,\n-                                expr: Box::new(ImutExprInt::Merge(m).into()),\n-                            }\n-                        }\n-                    }\n-                    Expr::Imut(ImutExprInt::Patch(m)) => {\n-                        if path.ast_eq(&m.target) {\n-                            Expr::PatchInPlace(Box::new(*m))\n-                        } else {\n-                            Expr::Assign {\n-                                mid,\n-                                path,\n-                                expr: Box::new(ImutExprInt::Patch(m).into()),\n-                            }\n-                        }\n-                    }\n+                    Expr::Imut(ImutExprInt::Merge(m)) => Expr::Assign {\n+                        mid,\n+                        path,\n+                        expr: Box::new(ImutExprInt::Merge(m).into()),\n+                    },\n+                    Expr::Imut(ImutExprInt::Patch(m)) => Expr::Assign {\n+                        mid,\n+                        path,\n+                        expr: Box::new(ImutExprInt::Patch(m).into()),\n+                    },\n                     expr => Expr::Assign {\n                         mid,\n                         path,\n",
    "diff_parsed": "{'added': [(21, '        base_expr, query, upable::Upable, ArrayPattern, ArrayPredicatePattern, AssignPattern,'), (22, '        BinExpr, BinOpKind, Bytes, BytesPart, ClauseGroup, Comprehension, ComprehensionCase,'), (23, '        Costly, DefaultCase, EmitExpr, EventPath, Expr, ExprPath, Expression, Field, FnDecl, FnDoc,'), (24, '        Helper, Ident, IfElse, ImutExpr, ImutExprInt, Invocable, Invoke, InvokeAggr, InvokeAggrFn,'), (25, '        List, Literal, LocalPath, Match, Merge, MetadataPath, ModDoc, NodeMetas, Patch,'), (26, '        PatchOperation, Path, Pattern, PredicateClause, PredicatePattern, Record, RecordPattern,'), (27, '        Recur, ReservedPath, Script, Segment, StatePath, StrLitElement, StringLit, TestExpr,'), (28, '        TuplePattern, UnaryExpr, UnaryOpKind,'), (649, '                    Expr::Imut(ImutExprInt::Merge(m)) => Expr::Assign {'), (650, '                        mid,'), (651, '                        path,'), (652, '                        expr: Box::new(ImutExprInt::Merge(m).into()),'), (653, '                    },'), (654, '                    Expr::Imut(ImutExprInt::Patch(m)) => Expr::Assign {'), (655, '                        mid,'), (656, '                        path,'), (657, '                        expr: Box::new(ImutExprInt::Patch(m).into()),'), (658, '                    },')], 'deleted': [(21, '        base_expr, eq::AstEq, query, upable::Upable, ArrayPattern, ArrayPredicatePattern,'), (22, '        AssignPattern, BinExpr, BinOpKind, Bytes, BytesPart, ClauseGroup, Comprehension,'), (23, '        ComprehensionCase, Costly, DefaultCase, EmitExpr, EventPath, Expr, ExprPath, Expression,'), (24, '        Field, FnDecl, FnDoc, Helper, Ident, IfElse, ImutExpr, ImutExprInt, Invocable, Invoke,'), (25, '        InvokeAggr, InvokeAggrFn, List, Literal, LocalPath, Match, Merge, MetadataPath, ModDoc,'), (26, '        NodeMetas, Patch, PatchOperation, Path, Pattern, PredicateClause, PredicatePattern, Record,'), (27, '        RecordPattern, Recur, ReservedPath, Script, Segment, StatePath, StrLitElement, StringLit,'), (28, '        TestExpr, TuplePattern, UnaryExpr, UnaryOpKind,'), (649, '                    Expr::Imut(ImutExprInt::Merge(m)) => {'), (650, '                        if path.ast_eq(&m.target) {'), (651, '                            Expr::MergeInPlace(Box::new(*m))'), (652, '                        } else {'), (653, '                            Expr::Assign {'), (654, '                                mid,'), (655, '                                path,'), (656, '                                expr: Box::new(ImutExprInt::Merge(m).into()),'), (657, '                            }'), (658, '                        }'), (659, '                    }'), (660, '                    Expr::Imut(ImutExprInt::Patch(m)) => {'), (661, '                        if path.ast_eq(&m.target) {'), (662, '                            Expr::PatchInPlace(Box::new(*m))'), (663, '                        } else {'), (664, '                            Expr::Assign {'), (665, '                                mid,'), (666, '                                path,'), (667, '                                expr: Box::new(ImutExprInt::Patch(m).into()),'), (668, '                            }'), (669, '                        }'), (670, '                    }')]}",
    "num_lines_added": "18",
    "num_lines_deleted": "30",
    "nloc": "2394"
  },
  {
    "file_change_id": "136358946213878",
    "hash": "1a2efcdbe68e5e7fd0a05836ac32d2cde78a0b2",
    "old_path": "tremor-script/src/ast/to_static.rs",
    "new_path": "tremor-script/src/ast/to_static.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -159,8 +159,6 @@ impl<'script> Expr<'script> {\n         match self {\n             Expr::Match(e) => Expr::Match(Box::new(e.into_static())),\n             Expr::IfElse(e) => Expr::IfElse(Box::new(e.into_static())),\n-            Expr::PatchInPlace(e) => Expr::PatchInPlace(Box::new(e.into_static())),\n-            Expr::MergeInPlace(e) => Expr::MergeInPlace(Box::new(e.into_static())),\n             Expr::Assign { mid, path, expr } => Expr::Assign {\n                 mid,\n                 path: path.into_static(),\n",
    "diff_parsed": "{'added': [], 'deleted': [(162, '            Expr::PatchInPlace(e) => Expr::PatchInPlace(Box::new(e.into_static())),'), (163, '            Expr::MergeInPlace(e) => Expr::MergeInPlace(Box::new(e.into_static())),')]}",
    "num_lines_added": "0",
    "num_lines_deleted": "2",
    "nloc": "1036"
  },
  {
    "file_change_id": "163347938740540",
    "hash": "1a2efcdbe68e5e7fd0a05836ac32d2cde78a0b2",
    "old_path": "tremor-script/src/interpreter/expr.rs",
    "new_path": "tremor-script/src/interpreter/expr.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -13,24 +13,23 @@\n // limitations under the License.\n \n use super::{\n-    merge_values, patch_value, resolve, resolve_value, set_local_shadow, test_guard,\n-    test_predicate_expr, Env, ExecOpts, LocalStack, NULL,\n+    resolve, resolve_value, set_local_shadow, test_guard, test_predicate_expr, Env, ExecOpts,\n+    LocalStack, NULL,\n };\n use crate::errors::{\n     error_assign_array, error_assign_to_const, error_bad_key_err, error_invalid_assign_target,\n-    error_need_obj, error_need_obj_err, error_no_clause_hit, Result,\n+    error_need_obj_err, error_no_clause_hit, Result,\n };\n use crate::prelude::*;\n use crate::registry::RECUR_PTR;\n use crate::{\n     ast::{\n         BaseExpr, ClauseGroup, ClausePreCondition, Comprehension, DefaultCase, EmitExpr, EventPath,\n-        Expr, IfElse, ImutExprInt, Match, Merge, Patch, Path, Segment,\n+        Expr, IfElse, ImutExprInt, Match, Path, Segment,\n     },\n     errors::error_oops_err,\n };\n use crate::{stry, Value};\n-use matches::matches;\n use std::mem;\n use std::{\n     borrow::{Borrow, Cow},\n@@ -219,104 +218,6 @@ impl<'script> Expr<'script> {\n         }\n     }\n \n-    fn patch_in_place<'run, 'event>(\n-        opts: ExecOpts,\n-        env: &'run Env<'run, 'event>,\n-        event: &'run Value<'event>,\n-        state: &'run Value<'static>,\n-        meta: &'run Value<'event>,\n-        local: &'run LocalStack<'event>,\n-        expr: &'run Patch<'event>,\n-    ) -> Result<Cow<'run, Value<'event>>> {\n-        // This function is called when we encounter code that consumes a value\n-        // to patch it. So the following code:\n-        // ```tremor\n-        // let event = patch event of insert \"key\" => \"value\" end\n-        // ```\n-        // When executed on it's own would clone the event, add a key and\n-        // overwrite original event.\n-        //\n-        // We optimise this as:\n-        // ```\n-        // patch_in_place event of insert \"key\" => \"value\" end\n-        // ```\n-        //\n-        // This code is generated in impl Upable for ExprRaw where the following\n-        // checks are performed:\n-        //\n-        // 1) the patch is on the RHS of an assignment\n-        // 2) the path of the assigned value and the path of the patched\n-        //    expression are identical.\n-        //\n-        // In turn this guarantees (at compile time):\n-        //\n-        // 1) The target (`expr`) is a path lookup\n-        // 2) The target is not a known constant as otherwise the assignment\n-        //    will complan\n-        // 3) this leave the `expr` to be either a local, the event, the state,\n-        //    metadata or a subkey thereof.\n-        //\n-        // And the following guarantees at run time:\n-        //\n-        // 1) the `expr` is an existing key of the mentioned categories,\n-        //    otherwise `expr.target.run` will error.\n-        // 2) `value` will never be owned (however the resolve function is\n-        //    generic so it needs to return a Cow)\n-\n-        let value: Cow<'run, Value<'event>> =\n-            stry!(expr.target.run(opts, env, event, state, meta, local));\n-        debug_assert!(\n-            !matches!(value, Cow::Owned(_)),\n-            \"We should never see a owned value here as patch_in_place is only ever called on existing data in event, state, meta or local\"\n-        );\n-        let v: &Value<'event> = value.borrow();\n-        // ALLOW: https://github.com/tremor-rs/tremor-runtime/issues/1032\n-        #[allow(mutable_transmutes, clippy::transmute_ptr_to_ptr)]\n-        // ALLOW: https://github.com/tremor-rs/tremor-runtime/issues/1032\n-        let v: &mut Value<'event> = unsafe { mem::transmute(v) };\n-        stry!(patch_value(opts, env, event, state, meta, local, v, expr));\n-        Ok(value)\n-    }\n-\n-    fn merge_in_place<'run, 'event>(\n-        &'run self,\n-        opts: ExecOpts,\n-        env: &'run Env<'run, 'event>,\n-        event: &'run mut Value<'event>,\n-        state: &'run mut Value<'static>,\n-        meta: &'run mut Value<'event>,\n-        local: &'run mut LocalStack<'event>,\n-        expr: &'run Merge<'event>,\n-    ) -> Result<Cow<'run, Value<'event>>> {\n-        // Please see the soundness reasoning in `patch_in_place` for details\n-        // those functions perform the same function just with slighty different\n-        // operations.\n-        let value_cow: Cow<'run, Value<'event>> =\n-            stry!(expr.target.run(opts, env, event, state, meta, local));\n-        debug_assert!(\n-            !matches!(value_cow, Cow::Owned(_)),\n-            \"We should never see a owned value here as merge_in_place is only ever called on existing data in event, state, meta or local\"\n-        );\n-\n-        if value_cow.is_object() {\n-            let value: &Value<'event> = value_cow.borrow();\n-            // ALLOW: https://github.com/tremor-rs/tremor-runtime/issues/1032\n-            #[allow(mutable_transmutes, clippy::transmute_ptr_to_ptr)]\n-            // ALLOW: https://github.com/tremor-rs/tremor-runtime/issues/1032\n-            let value: &mut Value<'event> = unsafe { mem::transmute(value) };\n-            let replacement = stry!(expr.expr.run(opts, env, event, state, meta, local,));\n-\n-            if replacement.is_object() {\n-                stry!(merge_values(self, &expr.expr, value, &replacement));\n-                Ok(value_cow)\n-            } else {\n-                error_need_obj(self, &expr.expr, replacement.value_type(), env.meta)\n-            }\n-        } else {\n-            error_need_obj(self, &expr.target, value_cow.value_type(), env.meta)\n-        }\n-    }\n-\n     // TODO: Quite some overlap with `ImutExprInt::comprehension`\n     fn comprehension<'run, 'event>(\n         &'run self,\n@@ -641,12 +542,6 @@ impl<'script> Expr<'script> {\n             }\n             Expr::Match(ref expr) => self.match_expr(opts, env, event, state, meta, local, expr),\n             Expr::IfElse(ref expr) => self.if_expr(opts, env, event, state, meta, local, expr),\n-            Expr::MergeInPlace(ref expr) => self\n-                .merge_in_place(opts, env, event, state, meta, local, expr)\n-                .map(Cont::Cont),\n-            Expr::PatchInPlace(ref expr) => {\n-                Self::patch_in_place(opts, env, event, state, meta, local, expr).map(Cont::Cont)\n-            }\n             Expr::Comprehension(ref expr) => {\n                 self.comprehension(opts, env, event, state, meta, local, expr)\n             }\n",
    "diff_parsed": "{'added': [(16, '    resolve, resolve_value, set_local_shadow, test_guard, test_predicate_expr, Env, ExecOpts,'), (17, '    LocalStack, NULL,'), (21, '    error_need_obj_err, error_no_clause_hit, Result,'), (28, '        Expr, IfElse, ImutExprInt, Match, Path, Segment,')], 'deleted': [(16, '    merge_values, patch_value, resolve, resolve_value, set_local_shadow, test_guard,'), (17, '    test_predicate_expr, Env, ExecOpts, LocalStack, NULL,'), (21, '    error_need_obj, error_need_obj_err, error_no_clause_hit, Result,'), (28, '        Expr, IfElse, ImutExprInt, Match, Merge, Patch, Path, Segment,'), (33, 'use matches::matches;'), (222, \"    fn patch_in_place<'run, 'event>(\"), (223, '        opts: ExecOpts,'), (224, \"        env: &'run Env<'run, 'event>,\"), (225, \"        event: &'run Value<'event>,\"), (226, \"        state: &'run Value<'static>,\"), (227, \"        meta: &'run Value<'event>,\"), (228, \"        local: &'run LocalStack<'event>,\"), (229, \"        expr: &'run Patch<'event>,\"), (230, \"    ) -> Result<Cow<'run, Value<'event>>> {\"), (266, \"        let value: Cow<'run, Value<'event>> =\"), (267, '            stry!(expr.target.run(opts, env, event, state, meta, local));'), (268, '        debug_assert!('), (269, '            !matches!(value, Cow::Owned(_)),'), (270, '            \"We should never see a owned value here as patch_in_place is only ever called on existing data in event, state, meta or local\"'), (271, '        );'), (272, \"        let v: &Value<'event> = value.borrow();\"), (274, '        #[allow(mutable_transmutes, clippy::transmute_ptr_to_ptr)]'), (276, \"        let v: &mut Value<'event> = unsafe { mem::transmute(v) };\"), (277, '        stry!(patch_value(opts, env, event, state, meta, local, v, expr));'), (278, '        Ok(value)'), (279, '    }'), (281, \"    fn merge_in_place<'run, 'event>(\"), (282, \"        &'run self,\"), (283, '        opts: ExecOpts,'), (284, \"        env: &'run Env<'run, 'event>,\"), (285, \"        event: &'run mut Value<'event>,\"), (286, \"        state: &'run mut Value<'static>,\"), (287, \"        meta: &'run mut Value<'event>,\"), (288, \"        local: &'run mut LocalStack<'event>,\"), (289, \"        expr: &'run Merge<'event>,\"), (290, \"    ) -> Result<Cow<'run, Value<'event>>> {\"), (294, \"        let value_cow: Cow<'run, Value<'event>> =\"), (295, '            stry!(expr.target.run(opts, env, event, state, meta, local));'), (296, '        debug_assert!('), (297, '            !matches!(value_cow, Cow::Owned(_)),'), (298, '            \"We should never see a owned value here as merge_in_place is only ever called on existing data in event, state, meta or local\"'), (299, '        );'), (301, '        if value_cow.is_object() {'), (302, \"            let value: &Value<'event> = value_cow.borrow();\"), (304, '            #[allow(mutable_transmutes, clippy::transmute_ptr_to_ptr)]'), (306, \"            let value: &mut Value<'event> = unsafe { mem::transmute(value) };\"), (307, '            let replacement = stry!(expr.expr.run(opts, env, event, state, meta, local,));'), (309, '            if replacement.is_object() {'), (310, '                stry!(merge_values(self, &expr.expr, value, &replacement));'), (311, '                Ok(value_cow)'), (312, '            } else {'), (313, '                error_need_obj(self, &expr.expr, replacement.value_type(), env.meta)'), (314, '            }'), (315, '        } else {'), (316, '            error_need_obj(self, &expr.target, value_cow.value_type(), env.meta)'), (317, '        }'), (318, '    }'), (644, '            Expr::MergeInPlace(ref expr) => self'), (645, '                .merge_in_place(opts, env, event, state, meta, local, expr)'), (646, '                .map(Cont::Cont),'), (647, '            Expr::PatchInPlace(ref expr) => {'), (648, '                Self::patch_in_place(opts, env, event, state, meta, local, expr).map(Cont::Cont)'), (649, '            }')]}",
    "num_lines_added": "4",
    "num_lines_deleted": "63",
    "nloc": "495"
  },
  {
    "file_change_id": "158946158104955",
    "hash": "3bbb69d25b9ca995a4c25838781f89c62f2ca92",
    "old_path": "tremor-cli/src/run.rs",
    "new_path": "tremor-cli/src/run.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -40,7 +40,8 @@ struct Ingress {\n     codec: Box<dyn Codec>,\n }\n \n-type IngressHandler<T> = dyn Fn(&mut T, &mut u64, &mut Egress, u64, Value) -> Result<()>;\n+type IngressHandler<T> =\n+    dyn Fn(&mut T, &mut u64, &mut Egress, &mut Value<'static>, u64, Value) -> Result<()>;\n \n impl Ingress {\n     fn from_args(matches: &ArgMatches) -> Result<Self> {\n@@ -86,6 +87,7 @@ impl Ingress {\n         mut egress: &mut Egress,\n         handler: &IngressHandler<T>,\n     ) -> Result<()> {\n+        let mut state: Value<'static> = Value::null();\n         loop {\n             match self.buffer.read(&mut self.buf) {\n                 Ok(0) => {\n@@ -104,7 +106,6 @@ impl Ingress {\n                             Ok(None) => continue,\n                             Err(e) => return Err(e.into()),\n                         };\n-                        let event = event.clone();\n \n                         if self.is_interactive {\n                             eprintln!(\n@@ -114,7 +115,7 @@ impl Ingress {\n                             );\n                             highlight(self.is_pretty, &event)?;\n                         }\n-                        handler(runnable, &mut id, &mut egress, at, event)?;\n+                        handler(runnable, &mut id, &mut egress, &mut state, at, event)?;\n                     }\n                 }\n                 Err(e) => {\n@@ -245,15 +246,14 @@ fn run_tremor_source(matches: &ArgMatches, src: String) -> Result<()> {\n                 &mut script,\n                 id,\n                 &mut egress,\n-                &move |runnable, _id, egress, at, event| {\n+                &move |runnable, _id, egress, state, at, event| {\n                     let mut global_map = Value::object();\n-                    let mut state = Value::null();\n                     let mut event = event.clone_static();\n                     match runnable.run(\n                         &EventContext::new(at, None),\n                         AggrType::Tick,\n                         &mut event,\n-                        &mut state,\n+                        state,\n                         &mut global_map,\n                     ) {\n                         Ok(r) => egress.process(&src, &event, r),\n@@ -340,7 +340,7 @@ fn run_trickle_source(matches: &ArgMatches, src: String) -> Result<()> {\n         &mut pipeline,\n         id,\n         &mut egress,\n-        &move |runnable, id, egress, at, event| {\n+        &move |runnable, id, egress, _state, at, event| {\n             let value = EventPayload::new(vec![], |_| ValueAndMeta::from(event.clone_static()));\n \n             let mut continuation = vec![];\n",
    "diff_parsed": "{'added': [(43, 'type IngressHandler<T> ='), (44, \"    dyn Fn(&mut T, &mut u64, &mut Egress, &mut Value<'static>, u64, Value) -> Result<()>;\"), (90, \"        let mut state: Value<'static> = Value::null();\"), (118, '                        handler(runnable, &mut id, &mut egress, &mut state, at, event)?;'), (249, '                &move |runnable, _id, egress, state, at, event| {'), (256, '                        state,'), (343, '        &move |runnable, id, egress, _state, at, event| {')], 'deleted': [(43, 'type IngressHandler<T> = dyn Fn(&mut T, &mut u64, &mut Egress, u64, Value) -> Result<()>;'), (107, '                        let event = event.clone();'), (117, '                        handler(runnable, &mut id, &mut egress, at, event)?;'), (248, '                &move |runnable, _id, egress, at, event| {'), (250, '                    let mut state = Value::null();'), (256, '                        &mut state,'), (343, '        &move |runnable, id, egress, at, event| {')]}",
    "num_lines_added": "7",
    "num_lines_deleted": "7",
    "nloc": "367"
  },
  {
    "file_change_id": "127902549599046",
    "hash": "96ccccd55ddbff7f03a9d484f52d1080f40eae8",
    "old_path": "sha2/src/sha512/x86.rs",
    "new_path": "sha2/src/sha512/x86.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -106,8 +106,8 @@ unsafe fn load_data_avx2(\n \n     macro_rules! unrolled_iterations {\n         ($($i:literal),*) => {$(\n-            x[$i] = _mm256_insertf128_si256(x[$i], _mm_loadu_si128(data.add($i) as *const _), 1);\n-            x[$i] = _mm256_insertf128_si256(x[$i], _mm_loadu_si128(data.add($i + 1) as *const _), 0);\n+            x[$i] = _mm256_insertf128_si256(x[$i], _mm_loadu_si128(data.add(8 + $i) as *const _), 1);\n+            x[$i] = _mm256_insertf128_si256(x[$i], _mm_loadu_si128(data.add($i) as *const _), 0);\n \n             x[$i] = _mm256_shuffle_epi8(x[$i], MASK);\n \n",
    "diff_parsed": "{'added': [(109, '            x[$i] = _mm256_insertf128_si256(x[$i], _mm_loadu_si128(data.add(8 + $i) as *const _), 1);'), (110, '            x[$i] = _mm256_insertf128_si256(x[$i], _mm_loadu_si128(data.add($i) as *const _), 0);')], 'deleted': [(109, '            x[$i] = _mm256_insertf128_si256(x[$i], _mm_loadu_si128(data.add($i) as *const _), 1);'), (110, '            x[$i] = _mm256_insertf128_si256(x[$i], _mm_loadu_si128(data.add($i + 1) as *const _), 0);')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "268"
  },
  {
    "file_change_id": "63307996926572",
    "hash": "543687d6c85f39338a283d72614ea96a7fc8188",
    "old_path": "futures-task/src/waker.rs",
    "new_path": "futures-task/src/waker.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -18,7 +18,7 @@ pub(super) fn waker_vtable<W: ArcWake>() -> &'static RawWakerVTable {\n /// [`ArcWake.wake()`](ArcWake::wake) if awoken.\n pub fn waker<W>(wake: Arc<W>) -> Waker\n where\n-    W: ArcWake,\n+    W: ArcWake + 'static,\n {\n     let ptr = Arc::into_raw(wake) as *const ();\n \n",
    "diff_parsed": "{'added': [(21, \"    W: ArcWake + 'static,\")], 'deleted': [(21, '    W: ArcWake,')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "46"
  },
  {
    "file_change_id": "276556010538339",
    "hash": "d3d14ad5c32922444f857382976c22f056e3cef",
    "old_path": "src/entry.rs",
    "new_path": "src/entry.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -482,7 +482,16 @@ impl<'a> EntryFields<'a> {\n         // As a result if we don't recognize the kind we just write out the file\n         // as we would normally.\n \n-        fs::File::create(dst).and_then(|mut f| {\n+        // Remove an existing file, if any, to avoid writing through\n+        // symlinks/hardlinks to weird locations. The tar archive says this is a\n+        // regular file, so let's make it a regular file.\n+        (|| -> io::Result<()> {\n+            match fs::remove_file(dst) {\n+                Ok(()) => {}\n+                Err(ref e) if e.kind() == io::ErrorKind::NotFound => {}\n+                Err(e) => return Err(e)\n+            }\n+            let mut f = fs::File::create(dst)?;\n             for io in self.data.drain(..) {\n                 match io {\n                     EntryIo::Data(mut d) => {\n@@ -500,7 +509,7 @@ impl<'a> EntryFields<'a> {\n                 }\n             }\n             Ok(())\n-        }).map_err(|e| {\n+        })().map_err(|e| {\n             let header = self.header.path_bytes();\n             TarError::new(&format!(\"failed to unpack `{}` into `{}`\",\n                                    String::from_utf8_lossy(&header),\n",
    "diff_parsed": "{'added': [(488, '        (|| -> io::Result<()> {'), (489, '            match fs::remove_file(dst) {'), (490, '                Ok(()) => {}'), (491, '                Err(ref e) if e.kind() == io::ErrorKind::NotFound => {}'), (492, '                Err(e) => return Err(e)'), (493, '            }'), (494, '            let mut f = fs::File::create(dst)?;'), (512, '        })().map_err(|e| {')], 'deleted': [(485, '        fs::File::create(dst).and_then(|mut f| {'), (503, '        }).map_err(|e| {')]}",
    "num_lines_added": "8",
    "num_lines_deleted": "2",
    "nloc": "447"
  },
  {
    "file_change_id": "94655620451984",
    "hash": "d3d14ad5c32922444f857382976c22f056e3cef",
    "old_path": "tests/entry.rs",
    "new_path": "tests/entry.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -283,3 +283,38 @@ fn modify_hard_link_just_created() {\n     t!(t!(File::open(&test)).read_to_end(&mut contents));\n     assert_eq!(contents.len(), 0);\n }\n+\n+#[test]\n+fn modify_symlink_just_created() {\n+    let mut ar = tar::Builder::new(Vec::new());\n+\n+    let mut header = tar::Header::new_gnu();\n+    header.set_size(0);\n+    header.set_entry_type(tar::EntryType::Symlink);\n+    t!(header.set_path(\"foo\"));\n+    t!(header.set_link_name(\"../test\"));\n+    header.set_cksum();\n+    t!(ar.append(&header, &[][..]));\n+\n+    let mut header = tar::Header::new_gnu();\n+    header.set_size(1);\n+    header.set_entry_type(tar::EntryType::Regular);\n+    t!(header.set_path(\"foo\"));\n+    header.set_cksum();\n+    t!(ar.append(&header, &b\"x\"[..]));\n+\n+    let bytes = t!(ar.into_inner());\n+    let mut ar = tar::Archive::new(&bytes[..]);\n+\n+    let td = t!(TempDir::new(\"tar\"));\n+\n+    let test = td.path().join(\"test\");\n+    t!(File::create(&test));\n+\n+    let dir = td.path().join(\"dir\");\n+    t!(ar.unpack(&dir));\n+\n+    let mut contents = Vec::new();\n+    t!(t!(File::open(&test)).read_to_end(&mut contents));\n+    assert_eq!(contents.len(), 0);\n+}\n",
    "diff_parsed": "{'added': [(287, '#[test]'), (288, 'fn modify_symlink_just_created() {'), (289, '    let mut ar = tar::Builder::new(Vec::new());'), (291, '    let mut header = tar::Header::new_gnu();'), (292, '    header.set_size(0);'), (293, '    header.set_entry_type(tar::EntryType::Symlink);'), (294, '    t!(header.set_path(\"foo\"));'), (295, '    t!(header.set_link_name(\"../test\"));'), (296, '    header.set_cksum();'), (297, '    t!(ar.append(&header, &[][..]));'), (299, '    let mut header = tar::Header::new_gnu();'), (300, '    header.set_size(1);'), (301, '    header.set_entry_type(tar::EntryType::Regular);'), (302, '    t!(header.set_path(\"foo\"));'), (303, '    header.set_cksum();'), (304, '    t!(ar.append(&header, &b\"x\"[..]));'), (306, '    let bytes = t!(ar.into_inner());'), (307, '    let mut ar = tar::Archive::new(&bytes[..]);'), (309, '    let td = t!(TempDir::new(\"tar\"));'), (311, '    let test = td.path().join(\"test\");'), (312, '    t!(File::create(&test));'), (314, '    let dir = td.path().join(\"dir\");'), (315, '    t!(ar.unpack(&dir));'), (317, '    let mut contents = Vec::new();'), (318, '    t!(t!(File::open(&test)).read_to_end(&mut contents));'), (319, '    assert_eq!(contents.len(), 0);'), (320, '}')], 'deleted': []}",
    "num_lines_added": "27",
    "num_lines_deleted": "0",
    "nloc": "257"
  },
  {
    "file_change_id": "259742708188968",
    "hash": "cdc4276a7e3ec67185c2b66fcb7585ec8716de1",
    "old_path": "src/api.rs",
    "new_path": "src/api.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -291,7 +291,7 @@ pub trait RenderDocV110: RenderDocV100 {\n     ///\n     /// Data is saved to a capture log file at the location specified via\n     /// `set_log_file_path_template()`.\n-    fn trigger_multi_frame_capture(&self, num_frames: u32) {\n+    fn trigger_multi_frame_capture(&mut self, num_frames: u32) {\n         unsafe {\n             (self.entry_v110().TriggerMultiFrameCapture.unwrap())(num_frames);\n         }\n@@ -353,7 +353,7 @@ pub trait RenderDocV120: RenderDocV112 {\n     unsafe fn entry_v120(&self) -> &EntryV120;\n \n     #[allow(missing_docs)]\n-    fn set_capture_file_comments<'a, P, C>(&self, path: P, comments: C)\n+    fn set_capture_file_comments<'a, P, C>(&mut self, path: P, comments: C)\n     where\n         P: Into<Option<&'a str>>,\n         C: AsRef<str>,\n",
    "diff_parsed": "{'added': [(294, '    fn trigger_multi_frame_capture(&mut self, num_frames: u32) {'), (356, \"    fn set_capture_file_comments<'a, P, C>(&mut self, path: P, comments: C)\")], 'deleted': [(294, '    fn trigger_multi_frame_capture(&self, num_frames: u32) {'), (356, \"    fn set_capture_file_comments<'a, P, C>(&self, path: P, comments: C)\")]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "267"
  },
  {
    "file_change_id": "272755071335078",
    "hash": "85e98d1c9d5ba8af623120e8fee6c97a2c2aee0",
    "old_path": "src/untrusted.rs",
    "new_path": "src/untrusted.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -316,11 +316,11 @@ impl<'a> Reader<'a> {\n     pub fn skip_and_get_input(&mut self, num_bytes: usize)\n                               -> Result<Input<'a>, EndOfInput> {\n         let new_i = try!(self.i.checked_add(num_bytes).ok_or(EndOfInput));\n-        let ret = self.input.get_slice(self.i..new_i)\n-                            .map(|subslice| Input { value: subslice })\n-                            .ok_or(EndOfInput);\n+        let ret = try!(self.input.get_slice(self.i..new_i)\n+                                 .map(|subslice| Input { value: subslice })\n+                                 .ok_or(EndOfInput));\n         self.i = new_i;\n-        ret\n+        Ok(ret)\n     }\n \n     /// Skips the reader to the end of the input, returning the skipped input\n",
    "diff_parsed": "{'added': [(319, '        let ret = try!(self.input.get_slice(self.i..new_i)'), (320, '                                 .map(|subslice| Input { value: subslice })'), (321, '                                 .ok_or(EndOfInput));'), (323, '        Ok(ret)')], 'deleted': [(319, '        let ret = self.input.get_slice(self.i..new_i)'), (320, '                            .map(|subslice| Input { value: subslice })'), (321, '                            .ok_or(EndOfInput);'), (323, '        ret')]}",
    "num_lines_added": "4",
    "num_lines_deleted": "4",
    "nloc": "289"
  },
  {
    "file_change_id": "56214709689249",
    "hash": "fb1021a1c3c8a34d0eef7335811c52535e5c179",
    "old_path": "src/fields/fp/mod.rs",
    "new_path": "src/fields/fp/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -733,6 +733,28 @@ impl<F: PrimeField> FieldVar<F, F> for FpVar<F> {\n         *self = self.frobenius_map(power)?;\n         Ok(self)\n     }\n+\n+    #[tracing::instrument(target = \"r1cs\")]\n+    fn mul_by_inverse(&self, d: &Self) -> Result<Self, SynthesisError> {\n+        match (self, d) {\n+            (FpVar::Constant(_), _) | (_, FpVar::Constant(_)) => {\n+                let d_inv = d.inverse()?;\n+                Ok(d_inv * self)\n+            }\n+            (FpVar::Var(self_var), FpVar::Var(d_var)) => {\n+                let cs = self.cs().or(d.cs());\n+                let res_var = AllocatedFp::<F>::new_witness(self.cs(), || {\n+                    Ok(self_var.value()? * d_var.value()?.inverse().unwrap_or(F::zero()))\n+                })?;\n+                cs.enforce_constraint(\n+                    lc!() + res_var.variable,\n+                    lc!() + d_var.variable,\n+                    lc!() + self_var.variable,\n+                )?;\n+                Ok(FpVar::Var(res_var))\n+            }\n+        }\n+    }\n }\n \n impl_ops!(\n",
    "diff_parsed": "{'added': [(737, '    #[tracing::instrument(target = \"r1cs\")]'), (738, '    fn mul_by_inverse(&self, d: &Self) -> Result<Self, SynthesisError> {'), (739, '        match (self, d) {'), (740, '            (FpVar::Constant(_), _) | (_, FpVar::Constant(_)) => {'), (741, '                let d_inv = d.inverse()?;'), (742, '                Ok(d_inv * self)'), (743, '            }'), (744, '            (FpVar::Var(self_var), FpVar::Var(d_var)) => {'), (745, '                let cs = self.cs().or(d.cs());'), (746, '                let res_var = AllocatedFp::<F>::new_witness(self.cs(), || {'), (747, '                    Ok(self_var.value()? * d_var.value()?.inverse().unwrap_or(F::zero()))'), (748, '                })?;'), (749, '                cs.enforce_constraint('), (750, '                    lc!() + res_var.variable,'), (751, '                    lc!() + d_var.variable,'), (752, '                    lc!() + self_var.variable,'), (753, '                )?;'), (754, '                Ok(FpVar::Var(res_var))'), (755, '            }'), (756, '        }'), (757, '    }')], 'deleted': []}",
    "num_lines_added": "21",
    "num_lines_deleted": "0",
    "nloc": "976"
  },
  {
    "file_change_id": "242670243204442",
    "hash": "fb1021a1c3c8a34d0eef7335811c52535e5c179",
    "old_path": "src/fields/mod.rs",
    "new_path": "src/fields/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -155,16 +155,20 @@ pub trait FieldVar<F: Field, ConstraintF: Field>:\n     /// Computes `result` such that `self * result == Self::one()`.\n     fn inverse(&self) -> Result<Self, SynthesisError>;\n \n-    /// Returns `(self / d)`. but requires fewer constraints than `self * d.inverse()`.\n+    /// Returns `(self / d)`.\n     /// It is up to the caller to ensure that `d` is non-zero,\n-    /// since in that case the result is unconstrained.\n+    /// since in that case the constraint is unsatisfied.\n     fn mul_by_inverse(&self, d: &Self) -> Result<Self, SynthesisError> {\n-        let d_inv = if self.is_constant() || d.is_constant() {\n-            d.inverse()?\n+        if self.is_constant() || d.is_constant() {\n+            let d_inv = d.inverse()?;\n+            Ok(d_inv * self)\n         } else {\n-            Self::new_witness(self.cs(), || Ok(d.value()?.inverse().unwrap_or(F::zero())))?\n-        };\n-        Ok(d_inv * self)\n+            let res = Self::new_witness(self.cs(), || {\n+                Ok(self.value()? * d.value()?.inverse().unwrap_or(F::zero()))\n+            })?;\n+            res.mul_equals(d, self)?;\n+            Ok(res)\n+        }\n     }\n \n     /// Computes the frobenius map over `self`.\n",
    "diff_parsed": "{'added': [(162, '        if self.is_constant() || d.is_constant() {'), (163, '            let d_inv = d.inverse()?;'), (164, '            Ok(d_inv * self)'), (166, '            let res = Self::new_witness(self.cs(), || {'), (167, '                Ok(self.value()? * d.value()?.inverse().unwrap_or(F::zero()))'), (168, '            })?;'), (169, '            res.mul_equals(d, self)?;'), (170, '            Ok(res)'), (171, '        }')], 'deleted': [(162, '        let d_inv = if self.is_constant() || d.is_constant() {'), (163, '            d.inverse()?'), (165, '            Self::new_witness(self.cs(), || Ok(d.value()?.inverse().unwrap_or(F::zero())))?'), (166, '        };'), (167, '        Ok(d_inv * self)')]}",
    "num_lines_added": "9",
    "num_lines_deleted": "5",
    "nloc": "129"
  },
  {
    "file_change_id": "142922499488694",
    "hash": "b93aff6e904cffbbfd1f421b82f6dcc5ca19a4f",
    "old_path": "src/de.rs",
    "new_path": "src/de.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -79,6 +79,7 @@ struct Deserializer<'a> {\n     aliases: &'a BTreeMap<usize, usize>,\n     pos: &'a mut usize,\n     path: Path<'a>,\n+    remaining_depth: u8,\n }\n \n impl<'a> Deserializer<'a> {\n@@ -109,6 +110,7 @@ impl<'a> Deserializer<'a> {\n                     aliases: self.aliases,\n                     pos: pos,\n                     path: Path::Alias { parent: &self.path },\n+                    remaining_depth: self.remaining_depth,\n                 })\n             }\n             None => panic!(\"unresolved alias: {}\", *pos),\n@@ -161,11 +163,11 @@ impl<'a> Deserializer<'a> {\n     where\n         V: Visitor<'de>,\n     {\n-        let (value, len) = {\n-            let mut seq = SeqAccess { de: self, len: 0 };\n+        let (value, len) = self.recursion_check(|de| {\n+            let mut seq = SeqAccess { de: de, len: 0 };\n             let value = visitor.visit_seq(&mut seq)?;\n-            (value, seq.len)\n-        };\n+            Ok((value, seq.len))\n+        })?;\n         self.end_sequence(len)?;\n         Ok(value)\n     }\n@@ -174,15 +176,15 @@ impl<'a> Deserializer<'a> {\n     where\n         V: Visitor<'de>,\n     {\n-        let (value, len) = {\n+        let (value, len) = self.recursion_check(|de| {\n             let mut map = MapAccess {\n-                de: &mut *self,\n+                de: de,\n                 len: 0,\n                 key: None,\n             };\n             let value = visitor.visit_map(&mut map)?;\n-            (value, map.len)\n-        };\n+            Ok((value, map.len))\n+        })?;\n         self.end_mapping(len)?;\n         Ok(value)\n     }\n@@ -238,6 +240,16 @@ impl<'a> Deserializer<'a> {\n             Err(de::Error::invalid_length(total, &ExpectedMap(len)))\n         }\n     }\n+\n+    fn recursion_check<F: FnOnce(&mut Self) -> Result<T>, T>(&mut self, f: F) -> Result<T> {\n+        let previous_depth = self.remaining_depth;\n+        self.remaining_depth = previous_depth\n+            .checked_sub(1)\n+            .ok_or_else(Error::recursion_limit_exceeded)?;\n+        let result = f(self);\n+        self.remaining_depth = previous_depth;\n+        result\n+    }\n }\n \n fn visit_scalar<'de, V>(\n@@ -303,6 +315,7 @@ impl<'de, 'a, 'r> de::SeqAccess<'de> for SeqAccess<'a, 'r> {\n                         parent: &self.de.path,\n                         index: self.len,\n                     },\n+                    remaining_depth: self.de.remaining_depth,\n                 };\n                 self.len += 1;\n                 seed.deserialize(&mut element_de).map(Some)\n@@ -357,6 +370,7 @@ impl<'de, 'a, 'r> de::MapAccess<'de> for MapAccess<'a, 'r> {\n                     parent: &self.de.path,\n                 }\n             },\n+            remaining_depth: self.de.remaining_depth,\n         };\n         seed.deserialize(&mut value_de)\n     }\n@@ -409,6 +423,7 @@ impl<'de, 'a, 'r> de::EnumAccess<'de> for EnumAccess<'a, 'r> {\n                 parent: &self.de.path,\n                 key: variant,\n             },\n+            remaining_depth: self.de.remaining_depth,\n         };\n         Ok((ret, variant_visitor))\n     }\n@@ -949,6 +964,7 @@ where\n             aliases: &loader.aliases,\n             pos: &mut pos,\n             path: Path::Root,\n+            remaining_depth: 128,\n         })?;\n         if pos == loader.events.len() {\n             Ok(t)\n",
    "diff_parsed": "{'added': [(82, '    remaining_depth: u8,'), (113, '                    remaining_depth: self.remaining_depth,'), (166, '        let (value, len) = self.recursion_check(|de| {'), (167, '            let mut seq = SeqAccess { de: de, len: 0 };'), (169, '            Ok((value, seq.len))'), (170, '        })?;'), (179, '        let (value, len) = self.recursion_check(|de| {'), (181, '                de: de,'), (186, '            Ok((value, map.len))'), (187, '        })?;'), (244, '    fn recursion_check<F: FnOnce(&mut Self) -> Result<T>, T>(&mut self, f: F) -> Result<T> {'), (245, '        let previous_depth = self.remaining_depth;'), (246, '        self.remaining_depth = previous_depth'), (247, '            .checked_sub(1)'), (248, '            .ok_or_else(Error::recursion_limit_exceeded)?;'), (249, '        let result = f(self);'), (250, '        self.remaining_depth = previous_depth;'), (251, '        result'), (252, '    }'), (318, '                    remaining_depth: self.de.remaining_depth,'), (373, '            remaining_depth: self.de.remaining_depth,'), (426, '            remaining_depth: self.de.remaining_depth,'), (967, '            remaining_depth: 128,')], 'deleted': [(164, '        let (value, len) = {'), (165, '            let mut seq = SeqAccess { de: self, len: 0 };'), (167, '            (value, seq.len)'), (168, '        };'), (177, '        let (value, len) = {'), (179, '                de: &mut *self,'), (184, '            (value, map.len)'), (185, '        };')]}",
    "num_lines_added": "23",
    "num_lines_deleted": "8",
    "nloc": "916"
  },
  {
    "file_change_id": "150633762666633",
    "hash": "b93aff6e904cffbbfd1f421b82f6dcc5ca19a4f",
    "old_path": "src/error.rs",
    "new_path": "src/error.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -41,6 +41,7 @@ pub enum ErrorImpl {\n \n     EndOfStream,\n     MoreThanOneDocument,\n+    RecursionLimitExceeded,\n }\n \n #[derive(Debug)]\n@@ -157,6 +158,12 @@ impl Error {\n         Error(Box::new(ErrorImpl::FromUtf8(err)))\n     }\n \n+    // Not public API. Should be pub(crate).\n+    #[doc(hidden)]\n+    pub fn recursion_limit_exceeded() -> Error {\n+        Error(Box::new(ErrorImpl::RecursionLimitExceeded))\n+    }\n+\n     // Not public API. Should be pub(crate).\n     #[doc(hidden)]\n     pub fn fix_marker(mut self, marker: Marker, path: Path) -> Self {\n@@ -183,6 +190,7 @@ impl error::Error for Error {\n             ErrorImpl::MoreThanOneDocument => {\n                 \"deserializing from YAML containing more than one document is not supported\"\n             }\n+            ErrorImpl::RecursionLimitExceeded => \"recursion limit exceeded\",\n         }\n     }\n \n@@ -218,6 +226,7 @@ impl Display for Error {\n             ErrorImpl::MoreThanOneDocument => f.write_str(\n                 \"deserializing from YAML containing more than one document is not supported\",\n             ),\n+            ErrorImpl::RecursionLimitExceeded => f.write_str(\"recursion limit exceeded\"),\n         }\n     }\n }\n@@ -241,6 +250,9 @@ impl Debug for Error {\n             }\n             ErrorImpl::EndOfStream => formatter.debug_tuple(\"EndOfStream\").finish(),\n             ErrorImpl::MoreThanOneDocument => formatter.debug_tuple(\"MoreThanOneDocument\").finish(),\n+            ErrorImpl::RecursionLimitExceeded => {\n+                formatter.debug_tuple(\"RecursionLimitExceeded\").finish()\n+            }\n         }\n     }\n }\n",
    "diff_parsed": "{'added': [(44, '    RecursionLimitExceeded,'), (162, '    #[doc(hidden)]'), (163, '    pub fn recursion_limit_exceeded() -> Error {'), (164, '        Error(Box::new(ErrorImpl::RecursionLimitExceeded))'), (165, '    }'), (193, '            ErrorImpl::RecursionLimitExceeded => \"recursion limit exceeded\",'), (229, '            ErrorImpl::RecursionLimitExceeded => f.write_str(\"recursion limit exceeded\"),'), (253, '            ErrorImpl::RecursionLimitExceeded => {'), (254, '                formatter.debug_tuple(\"RecursionLimitExceeded\").finish()'), (255, '            }')], 'deleted': []}",
    "num_lines_added": "10",
    "num_lines_deleted": "0",
    "nloc": "189"
  },
  {
    "file_change_id": "35857175795136",
    "hash": "b93aff6e904cffbbfd1f421b82f6dcc5ca19a4f",
    "old_path": "tests/test_error.rs",
    "new_path": "tests/test_error.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -257,3 +257,51 @@ fn test_invalid_scalar_type() {\n     let expected = \"x: invalid type: unit value, expected an array of length 1 at line 2 column 1\";\n     test_error::<S>(yaml, expected);\n }\n+\n+#[test]\n+fn test_infinite_recursion_objects() {\n+    #[derive(Deserialize, Debug)]\n+    struct S {\n+        x: Option<Box<S>>,\n+    }\n+\n+    let yaml = \"&a {x: *a}\";\n+    let expected = \"recursion limit exceeded\";\n+    test_error::<S>(yaml, expected);\n+}\n+\n+#[test]\n+fn test_infinite_recursion_arrays() {\n+    #[derive(Deserialize, Debug)]\n+    struct S {\n+        x: Option<Box<S>>,\n+    }\n+\n+    let yaml = \"&a [*a]\";\n+    let expected = \"recursion limit exceeded\";\n+    test_error::<S>(yaml, expected);\n+}\n+\n+#[test]\n+fn test_finite_recursion_objects() {\n+    #[derive(Deserialize, Debug)]\n+    struct S {\n+        x: Option<Box<S>>,\n+    }\n+\n+    let yaml = \"{x:\".repeat(1_000) + &\"}\".repeat(1_000);\n+    let expected = \"recursion limit exceeded\";\n+    test_error::<i32>(&yaml, expected);\n+}\n+\n+#[test]\n+fn test_finite_recursion_arrays() {\n+    #[derive(Deserialize, Debug)]\n+    struct S {\n+        x: Option<Box<S>>,\n+    }\n+\n+    let yaml = \"[\".repeat(1_000) + &\"]\".repeat(1_000);\n+    let expected = \"recursion limit exceeded\";\n+    test_error::<S>(&yaml, expected);\n+}\n",
    "diff_parsed": "{'added': [(261, '#[test]'), (262, 'fn test_infinite_recursion_objects() {'), (263, '    #[derive(Deserialize, Debug)]'), (264, '    struct S {'), (265, '        x: Option<Box<S>>,'), (266, '    }'), (268, '    let yaml = \"&a {x: *a}\";'), (269, '    let expected = \"recursion limit exceeded\";'), (270, '    test_error::<S>(yaml, expected);'), (271, '}'), (273, '#[test]'), (274, 'fn test_infinite_recursion_arrays() {'), (275, '    #[derive(Deserialize, Debug)]'), (276, '    struct S {'), (277, '        x: Option<Box<S>>,'), (278, '    }'), (280, '    let yaml = \"&a [*a]\";'), (281, '    let expected = \"recursion limit exceeded\";'), (282, '    test_error::<S>(yaml, expected);'), (283, '}'), (285, '#[test]'), (286, 'fn test_finite_recursion_objects() {'), (287, '    #[derive(Deserialize, Debug)]'), (288, '    struct S {'), (289, '        x: Option<Box<S>>,'), (290, '    }'), (292, '    let yaml = \"{x:\".repeat(1_000) + &\"}\".repeat(1_000);'), (293, '    let expected = \"recursion limit exceeded\";'), (294, '    test_error::<i32>(&yaml, expected);'), (295, '}'), (297, '#[test]'), (298, 'fn test_finite_recursion_arrays() {'), (299, '    #[derive(Deserialize, Debug)]'), (300, '    struct S {'), (301, '        x: Option<Box<S>>,'), (302, '    }'), (304, '    let yaml = \"[\".repeat(1_000) + &\"]\".repeat(1_000);'), (305, '    let expected = \"recursion limit exceeded\";'), (306, '    test_error::<S>(&yaml, expected);'), (307, '}')], 'deleted': []}",
    "num_lines_added": "40",
    "num_lines_deleted": "0",
    "nloc": "266"
  },
  {
    "file_change_id": "100236268304514",
    "hash": "93458d01fed0ec81c0e7b4e98e6f35961356fae",
    "old_path": "src/transport/smtp/client/mod.rs",
    "new_path": "src/transport/smtp/client/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -78,7 +78,15 @@ impl ClientCodec {\n                     match self.escape_count {\n                         0 => self.escape_count = if *byte == b'\\r' { 1 } else { 0 },\n                         1 => self.escape_count = if *byte == b'\\n' { 2 } else { 0 },\n-                        2 => self.escape_count = if *byte == b'.' { 3 } else { 0 },\n+                        2 => {\n+                            self.escape_count = if *byte == b'.' {\n+                                3\n+                            } else if *byte == b'\\r' {\n+                                1\n+                            } else {\n+                                0\n+                            }\n+                        }\n                         _ => unreachable!(),\n                     }\n                     if self.escape_count == 3 {\n@@ -111,6 +119,7 @@ mod test {\n         let mut buf: Vec<u8> = vec![];\n \n         codec.encode(b\"test\\r\\n\", &mut buf);\n+        codec.encode(b\"test\\r\\n\\r\\n\", &mut buf);\n         codec.encode(b\".\\r\\n\", &mut buf);\n         codec.encode(b\"\\r\\ntest\", &mut buf);\n         codec.encode(b\"te\\r\\n.\\r\\nst\", &mut buf);\n@@ -121,7 +130,7 @@ mod test {\n         codec.encode(b\"test\", &mut buf);\n         assert_eq!(\n             String::from_utf8(buf).unwrap(),\n-            \"test\\r\\n..\\r\\n\\r\\ntestte\\r\\n..\\r\\nsttesttest.test\\n.test\\ntest\"\n+            \"test\\r\\ntest\\r\\n\\r\\n..\\r\\n\\r\\ntestte\\r\\n..\\r\\nsttesttest.test\\n.test\\ntest\"\n         );\n     }\n \n",
    "diff_parsed": "{'added': [(81, '                        2 => {'), (82, \"                            self.escape_count = if *byte == b'.' {\"), (83, '                                3'), (84, \"                            } else if *byte == b'\\\\r' {\"), (85, '                                1'), (86, '                            } else {'), (87, '                                0'), (88, '                            }'), (89, '                        }'), (122, '        codec.encode(b\"test\\\\r\\\\n\\\\r\\\\n\", &mut buf);'), (133, '            \"test\\\\r\\\\ntest\\\\r\\\\n\\\\r\\\\n..\\\\r\\\\n\\\\r\\\\ntestte\\\\r\\\\n..\\\\r\\\\nsttesttest.test\\\\n.test\\\\ntest\"')], 'deleted': [(81, \"                        2 => self.escape_count = if *byte == b'.' { 3 } else { 0 },\"), (124, '            \"test\\\\r\\\\n..\\\\r\\\\n\\\\r\\\\ntestte\\\\r\\\\n..\\\\r\\\\nsttesttest.test\\\\n.test\\\\ntest\"')]}",
    "num_lines_added": "11",
    "num_lines_deleted": "2",
    "nloc": "106"
  },
  {
    "file_change_id": "259772580375172",
    "hash": "38d308785f84f7037e63c04c0de1cb20d1c8284",
    "old_path": "crossbeam-channel/src/flavors/list.rs",
    "new_path": "crossbeam-channel/src/flavors/list.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -2,7 +2,7 @@\n \n use std::cell::UnsafeCell;\n use std::marker::PhantomData;\n-use std::mem::{self, ManuallyDrop};\n+use std::mem::MaybeUninit;\n use std::ptr;\n use std::sync::atomic::{self, AtomicPtr, AtomicUsize, Ordering};\n use std::time::Instant;\n@@ -42,7 +42,7 @@ const MARK_BIT: usize = 1;\n /// A slot in a block.\n struct Slot<T> {\n     /// The message.\n-    msg: UnsafeCell<ManuallyDrop<T>>,\n+    msg: UnsafeCell<MaybeUninit<T>>,\n \n     /// The state of the slot.\n     state: AtomicUsize,\n@@ -72,7 +72,13 @@ struct Block<T> {\n impl<T> Block<T> {\n     /// Creates an empty block.\n     fn new() -> Block<T> {\n-        unsafe { mem::zeroed() }\n+        // SAFETY: This is safe because:\n+        //  [1] `Block::next` (AtomicPtr) may be safely zero initialized.\n+        //  [2] `Block::slots` (Array) may be safely zero initialized because of [3, 4].\n+        //  [3] `Slot::msg` (UnsafeCell) may be safely zero initialized because it\n+        //       holds a MaybeUninit.\n+        //  [4] `Slot::state` (AtomicUsize) may be safely zero initialized.\n+        unsafe { MaybeUninit::zeroed().assume_init() }\n     }\n \n     /// Waits until the next pointer is set.\n@@ -280,7 +286,7 @@ impl<T> Channel<T> {\n         let block = token.list.block as *mut Block<T>;\n         let offset = token.list.offset;\n         let slot = (*block).slots.get_unchecked(offset);\n-        slot.msg.get().write(ManuallyDrop::new(msg));\n+        slot.msg.get().write(MaybeUninit::new(msg));\n         slot.state.fetch_or(WRITE, Ordering::Release);\n \n         // Wake a sleeping receiver.\n@@ -385,8 +391,7 @@ impl<T> Channel<T> {\n         let offset = token.list.offset;\n         let slot = (*block).slots.get_unchecked(offset);\n         slot.wait_write();\n-        let m = slot.msg.get().read();\n-        let msg = ManuallyDrop::into_inner(m);\n+        let msg = slot.msg.get().read().assume_init();\n \n         // Destroy the block if we've reached the end, or if another thread wanted to destroy but\n         // couldn't because we were busy reading from the slot.\n@@ -572,7 +577,8 @@ impl<T> Drop for Channel<T> {\n                 if offset < BLOCK_CAP {\n                     // Drop the message in the slot.\n                     let slot = (*block).slots.get_unchecked(offset);\n-                    ManuallyDrop::drop(&mut *(*slot).msg.get());\n+                    let p = &mut *slot.msg.get();\n+                    ptr::drop_in_place(p.as_mut_ptr());\n                 } else {\n                     // Deallocate the block and move to the next one.\n                     let next = (*block).next.load(Ordering::Relaxed);\n",
    "diff_parsed": "{'added': [(5, 'use std::mem::MaybeUninit;'), (45, '    msg: UnsafeCell<MaybeUninit<T>>,'), (81, '        unsafe { MaybeUninit::zeroed().assume_init() }'), (289, '        slot.msg.get().write(MaybeUninit::new(msg));'), (394, '        let msg = slot.msg.get().read().assume_init();'), (580, '                    let p = &mut *slot.msg.get();'), (581, '                    ptr::drop_in_place(p.as_mut_ptr());')], 'deleted': [(5, 'use std::mem::{self, ManuallyDrop};'), (45, '    msg: UnsafeCell<ManuallyDrop<T>>,'), (75, '        unsafe { mem::zeroed() }'), (283, '        slot.msg.get().write(ManuallyDrop::new(msg));'), (388, '        let m = slot.msg.get().read();'), (389, '        let msg = ManuallyDrop::into_inner(m);'), (575, '                    ManuallyDrop::drop(&mut *(*slot).msg.get());')]}",
    "num_lines_added": "7",
    "num_lines_deleted": "7",
    "nloc": "447"
  },
  {
    "file_change_id": "139571592264440",
    "hash": "7b35a3d17f5c5ec53f70576d4ca0e18be8ed289",
    "old_path": "crossbeam-queue/src/seg_queue.rs",
    "new_path": "crossbeam-queue/src/seg_queue.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -2,7 +2,7 @@ use alloc::boxed::Box;\n use core::cell::UnsafeCell;\n use core::fmt;\n use core::marker::PhantomData;\n-use core::mem::{self, ManuallyDrop};\n+use core::mem::MaybeUninit;\n use core::ptr;\n use core::sync::atomic::{self, AtomicPtr, AtomicUsize, Ordering};\n \n@@ -30,7 +30,7 @@ const HAS_NEXT: usize = 1;\n /// A slot in a block.\n struct Slot<T> {\n     /// The value.\n-    value: UnsafeCell<ManuallyDrop<T>>,\n+    value: UnsafeCell<MaybeUninit<T>>,\n \n     /// The state of the slot.\n     state: AtomicUsize,\n@@ -60,7 +60,13 @@ struct Block<T> {\n impl<T> Block<T> {\n     /// Creates an empty block that starts at `start_index`.\n     fn new() -> Block<T> {\n-        unsafe { mem::zeroed() }\n+        // SAFETY: This is safe because:\n+        //  [1] `Block::next` (AtomicPtr) may be safely zero initialized.\n+        //  [2] `Block::slots` (Array) may be safely zero initialized because of [3, 4].\n+        //  [3] `Slot::value` (UnsafeCell) may be safely zero initialized because it\n+        //       holds a MaybeUninit.\n+        //  [4] `Slot::state` (AtomicUsize) may be safely zero initialized.\n+        unsafe { MaybeUninit::zeroed().assume_init() }\n     }\n \n     /// Waits until the next pointer is set.\n@@ -244,7 +250,7 @@ impl<T> SegQueue<T> {\n \n                     // Write the value into the slot.\n                     let slot = (*block).slots.get_unchecked(offset);\n-                    slot.value.get().write(ManuallyDrop::new(value));\n+                    slot.value.get().write(MaybeUninit::new(value));\n                     slot.state.fetch_or(WRITE, Ordering::Release);\n \n                     return;\n@@ -339,8 +345,7 @@ impl<T> SegQueue<T> {\n                     // Read the value.\n                     let slot = (*block).slots.get_unchecked(offset);\n                     slot.wait_write();\n-                    let m = slot.value.get().read();\n-                    let value = ManuallyDrop::into_inner(m);\n+                    let value = slot.value.get().read().assume_init();\n \n                     // Destroy the block if we've reached the end, or if another thread wanted to\n                     // destroy but couldn't because we were busy reading from the slot.\n@@ -451,7 +456,8 @@ impl<T> Drop for SegQueue<T> {\n                 if offset < BLOCK_CAP {\n                     // Drop the value in the slot.\n                     let slot = (*block).slots.get_unchecked(offset);\n-                    ManuallyDrop::drop(&mut *(*slot).value.get());\n+                    let p = &mut *slot.value.get();\n+                    ptr::drop_in_place(p.as_mut_ptr());\n                 } else {\n                     // Deallocate the block and move to the next one.\n                     let next = (*block).next.load(Ordering::Relaxed);\n",
    "diff_parsed": "{'added': [(5, 'use core::mem::MaybeUninit;'), (33, '    value: UnsafeCell<MaybeUninit<T>>,'), (69, '        unsafe { MaybeUninit::zeroed().assume_init() }'), (253, '                    slot.value.get().write(MaybeUninit::new(value));'), (348, '                    let value = slot.value.get().read().assume_init();'), (459, '                    let p = &mut *slot.value.get();'), (460, '                    ptr::drop_in_place(p.as_mut_ptr());')], 'deleted': [(5, 'use core::mem::{self, ManuallyDrop};'), (33, '    value: UnsafeCell<ManuallyDrop<T>>,'), (63, '        unsafe { mem::zeroed() }'), (247, '                    slot.value.get().write(ManuallyDrop::new(value));'), (342, '                    let m = slot.value.get().read();'), (343, '                    let value = ManuallyDrop::into_inner(m);'), (454, '                    ManuallyDrop::drop(&mut *(*slot).value.get());')]}",
    "num_lines_added": "7",
    "num_lines_deleted": "7",
    "nloc": "273"
  },
  {
    "file_change_id": "177245379304518",
    "hash": "68e8708c2dda24e4b3b1807f5f301ca2b8ffa35",
    "old_path": "crossbeam-deque/src/lib.rs",
    "new_path": "crossbeam-deque/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -97,7 +97,7 @@ use std::cmp;\n use std::fmt;\n use std::iter::FromIterator;\n use std::marker::PhantomData;\n-use std::mem::{self, ManuallyDrop};\n+use std::mem::{self, MaybeUninit};\n use std::ptr;\n use std::sync::atomic::{self, AtomicIsize, AtomicPtr, AtomicUsize, Ordering};\n use std::sync::Arc;\n@@ -1140,7 +1140,7 @@ const HAS_NEXT: usize = 1;\n /// A slot in a block.\n struct Slot<T> {\n     /// The task.\n-    task: UnsafeCell<ManuallyDrop<T>>,\n+    task: UnsafeCell<MaybeUninit<T>>,\n \n     /// The state of the slot.\n     state: AtomicUsize,\n@@ -1170,7 +1170,13 @@ struct Block<T> {\n impl<T> Block<T> {\n     /// Creates an empty block that starts at `start_index`.\n     fn new() -> Block<T> {\n-        unsafe { mem::zeroed() }\n+        // SAFETY: This is safe because:\n+        //  [1] `Block::next` (AtomicPtr) may be safely zero initialized.\n+        //  [2] `Block::slots` (Array) may be safely zero initialized because of [3, 4].\n+        //  [3] `Slot::task` (UnsafeCell) may be safely zero initialized because it\n+        //       holds a MaybeUninit.\n+        //  [4] `Slot::state` (AtomicUsize) may be safely zero initialized.\n+        unsafe { MaybeUninit::zeroed().assume_init() }\n     }\n \n     /// Waits until the next pointer is set.\n@@ -1329,7 +1335,7 @@ impl<T> Injector<T> {\n \n                     // Write the task into the slot.\n                     let slot = (*block).slots.get_unchecked(offset);\n-                    slot.task.get().write(ManuallyDrop::new(task));\n+                    slot.task.get().write(MaybeUninit::new(task));\n                     slot.state.fetch_or(WRITE, Ordering::Release);\n \n                     return;\n@@ -1422,8 +1428,7 @@ impl<T> Injector<T> {\n             // Read the task.\n             let slot = (*block).slots.get_unchecked(offset);\n             slot.wait_write();\n-            let m = slot.task.get().read();\n-            let task = ManuallyDrop::into_inner(m);\n+            let task = slot.task.get().read().assume_init();\n \n             // Destroy the block if we've reached the end, or if another thread wanted to destroy\n             // but couldn't because we were busy reading from the slot.\n@@ -1548,8 +1553,7 @@ impl<T> Injector<T> {\n                         // Read the task.\n                         let slot = (*block).slots.get_unchecked(offset + i);\n                         slot.wait_write();\n-                        let m = slot.task.get().read();\n-                        let task = ManuallyDrop::into_inner(m);\n+                        let task = slot.task.get().read().assume_init();\n \n                         // Write it into the destination queue.\n                         dest_buffer.write(dest_b.wrapping_add(i as isize), task);\n@@ -1561,8 +1565,7 @@ impl<T> Injector<T> {\n                         // Read the task.\n                         let slot = (*block).slots.get_unchecked(offset + i);\n                         slot.wait_write();\n-                        let m = slot.task.get().read();\n-                        let task = ManuallyDrop::into_inner(m);\n+                        let task = slot.task.get().read().assume_init();\n \n                         // Write it into the destination queue.\n                         dest_buffer.write(dest_b.wrapping_add((batch_size - 1 - i) as isize), task);\n@@ -1704,8 +1707,7 @@ impl<T> Injector<T> {\n             // Read the task.\n             let slot = (*block).slots.get_unchecked(offset);\n             slot.wait_write();\n-            let m = slot.task.get().read();\n-            let task = ManuallyDrop::into_inner(m);\n+            let task = slot.task.get().read().assume_init();\n \n             match dest.flavor {\n                 Flavor::Fifo => {\n@@ -1714,8 +1716,7 @@ impl<T> Injector<T> {\n                         // Read the task.\n                         let slot = (*block).slots.get_unchecked(offset + i + 1);\n                         slot.wait_write();\n-                        let m = slot.task.get().read();\n-                        let task = ManuallyDrop::into_inner(m);\n+                        let task = slot.task.get().read().assume_init();\n \n                         // Write it into the destination queue.\n                         dest_buffer.write(dest_b.wrapping_add(i as isize), task);\n@@ -1728,8 +1729,7 @@ impl<T> Injector<T> {\n                         // Read the task.\n                         let slot = (*block).slots.get_unchecked(offset + i + 1);\n                         slot.wait_write();\n-                        let m = slot.task.get().read();\n-                        let task = ManuallyDrop::into_inner(m);\n+                        let task = slot.task.get().read().assume_init();\n \n                         // Write it into the destination queue.\n                         dest_buffer.write(dest_b.wrapping_add((batch_size - 1 - i) as isize), task);\n@@ -1804,7 +1804,8 @@ impl<T> Drop for Injector<T> {\n                 if offset < BLOCK_CAP {\n                     // Drop the task in the slot.\n                     let slot = (*block).slots.get_unchecked(offset);\n-                    ManuallyDrop::drop(&mut *(*slot).task.get());\n+                    let p = &mut *slot.task.get();\n+                    ptr::drop_in_place(p.as_mut_ptr());\n                 } else {\n                     // Deallocate the block and move to the next one.\n                     let next = (*block).next.load(Ordering::Relaxed);\n",
    "diff_parsed": "{'added': [(100, 'use std::mem::{self, MaybeUninit};'), (1143, '    task: UnsafeCell<MaybeUninit<T>>,'), (1179, '        unsafe { MaybeUninit::zeroed().assume_init() }'), (1338, '                    slot.task.get().write(MaybeUninit::new(task));'), (1431, '            let task = slot.task.get().read().assume_init();'), (1556, '                        let task = slot.task.get().read().assume_init();'), (1568, '                        let task = slot.task.get().read().assume_init();'), (1710, '            let task = slot.task.get().read().assume_init();'), (1719, '                        let task = slot.task.get().read().assume_init();'), (1732, '                        let task = slot.task.get().read().assume_init();'), (1807, '                    let p = &mut *slot.task.get();'), (1808, '                    ptr::drop_in_place(p.as_mut_ptr());')], 'deleted': [(100, 'use std::mem::{self, ManuallyDrop};'), (1143, '    task: UnsafeCell<ManuallyDrop<T>>,'), (1173, '        unsafe { mem::zeroed() }'), (1332, '                    slot.task.get().write(ManuallyDrop::new(task));'), (1425, '            let m = slot.task.get().read();'), (1426, '            let task = ManuallyDrop::into_inner(m);'), (1551, '                        let m = slot.task.get().read();'), (1552, '                        let task = ManuallyDrop::into_inner(m);'), (1564, '                        let m = slot.task.get().read();'), (1565, '                        let task = ManuallyDrop::into_inner(m);'), (1707, '            let m = slot.task.get().read();'), (1708, '            let task = ManuallyDrop::into_inner(m);'), (1717, '                        let m = slot.task.get().read();'), (1718, '                        let task = ManuallyDrop::into_inner(m);'), (1731, '                        let m = slot.task.get().read();'), (1732, '                        let task = ManuallyDrop::into_inner(m);'), (1807, '                    ManuallyDrop::drop(&mut *(*slot).task.get());')]}",
    "num_lines_added": "12",
    "num_lines_deleted": "17",
    "nloc": "997"
  },
  {
    "file_change_id": "84023723202769",
    "hash": "e0fd465b9b7de8b60b0b588e264aca1fa92fbd1",
    "old_path": "crossbeam-epoch/src/deferred.rs",
    "new_path": "crossbeam-epoch/src/deferred.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,7 +1,7 @@\n use alloc::boxed::Box;\n use core::fmt;\n use core::marker::PhantomData;\n-use core::mem;\n+use core::mem::{self, MaybeUninit};\n use core::ptr;\n \n /// Number of words a piece of `Data` can hold.\n@@ -36,11 +36,8 @@ impl Deferred {\n \n         unsafe {\n             if size <= mem::size_of::<Data>() && align <= mem::align_of::<Data>() {\n-                // TODO(taiki-e): when the minimum supported Rust version is bumped to 1.36+,\n-                // replace this with `mem::MaybeUninit`.\n-                #[allow(deprecated)]\n-                let mut data: Data = mem::uninitialized();\n-                ptr::write(&mut data as *mut Data as *mut F, f);\n+                let mut data = MaybeUninit::<Data>::uninit();\n+                ptr::write(data.as_mut_ptr() as *mut F, f);\n \n                 unsafe fn call<F: FnOnce()>(raw: *mut u8) {\n                     let f: F = ptr::read(raw as *mut F);\n@@ -49,16 +46,13 @@ impl Deferred {\n \n                 Deferred {\n                     call: call::<F>,\n-                    data,\n+                    data: data.assume_init(),\n                     _marker: PhantomData,\n                 }\n             } else {\n                 let b: Box<F> = Box::new(f);\n-                // TODO(taiki-e): when the minimum supported Rust version is bumped to 1.36+,\n-                // replace this with `mem::MaybeUninit`.\n-                #[allow(deprecated)]\n-                let mut data: Data = mem::uninitialized();\n-                ptr::write(&mut data as *mut Data as *mut Box<F>, b);\n+                let mut data = MaybeUninit::<Data>::uninit();\n+                ptr::write(data.as_mut_ptr() as *mut Box<F>, b);\n \n                 unsafe fn call<F: FnOnce()>(raw: *mut u8) {\n                     let b: Box<F> = ptr::read(raw as *mut Box<F>);\n@@ -67,7 +61,7 @@ impl Deferred {\n \n                 Deferred {\n                     call: call::<F>,\n-                    data,\n+                    data: data.assume_init(),\n                     _marker: PhantomData,\n                 }\n             }\n",
    "diff_parsed": "{'added': [(4, 'use core::mem::{self, MaybeUninit};'), (39, '                let mut data = MaybeUninit::<Data>::uninit();'), (40, '                ptr::write(data.as_mut_ptr() as *mut F, f);'), (49, '                    data: data.assume_init(),'), (54, '                let mut data = MaybeUninit::<Data>::uninit();'), (55, '                ptr::write(data.as_mut_ptr() as *mut Box<F>, b);'), (64, '                    data: data.assume_init(),')], 'deleted': [(4, 'use core::mem;'), (41, '                #[allow(deprecated)]'), (42, '                let mut data: Data = mem::uninitialized();'), (43, '                ptr::write(&mut data as *mut Data as *mut F, f);'), (52, '                    data,'), (59, '                #[allow(deprecated)]'), (60, '                let mut data: Data = mem::uninitialized();'), (61, '                ptr::write(&mut data as *mut Data as *mut Box<F>, b);'), (70, '                    data,')]}",
    "num_lines_added": "7",
    "num_lines_deleted": "9",
    "nloc": "103"
  },
  {
    "file_change_id": "239461305213347",
    "hash": "f48c1c763a73467e2fde6158c0abc2faa162ae8",
    "old_path": "crossbeam-epoch/src/sync/queue.rs",
    "new_path": "crossbeam-epoch/src/sync/queue.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -8,8 +8,7 @@\n //! Simon Doherty, Lindsay Groves, Victor Luchangco, and Mark Moir. 2004b. Formal Verification of a\n //! Practical Lock-Free Queue Algorithm. https://doi.org/10.1007/978-3-540-30232-2_7\n \n-use core::mem::{self, ManuallyDrop};\n-use core::ptr;\n+use core::mem::MaybeUninit;\n use core::sync::atomic::Ordering::{Acquire, Relaxed, Release};\n \n use crossbeam_utils::CachePadded;\n@@ -29,11 +28,11 @@ pub struct Queue<T> {\n struct Node<T> {\n     /// The slot in which a value of type `T` can be stored.\n     ///\n-    /// The type of `data` is `ManuallyDrop<T>` because a `Node<T>` doesn't always contain a `T`.\n+    /// The type of `data` is `MaybeUninit<T>` because a `Node<T>` doesn't always contain a `T`.\n     /// For example, the sentinel node in a queue never contains a value: its slot is always empty.\n     /// Other nodes start their life with a push operation and contain a value until it gets popped\n     /// out. After that such empty nodes get added to the collector for destruction.\n-    data: ManuallyDrop<T>,\n+    data: MaybeUninit<T>,\n \n     next: Atomic<Node<T>>,\n }\n@@ -49,11 +48,8 @@ impl<T> Queue<T> {\n             head: CachePadded::new(Atomic::null()),\n             tail: CachePadded::new(Atomic::null()),\n         };\n-        // TODO(taiki-e): when the minimum supported Rust version is bumped to 1.36+,\n-        // replace this with `mem::MaybeUninit`.\n-        #[allow(deprecated)]\n         let sentinel = Owned::new(Node {\n-            data: unsafe { mem::uninitialized() },\n+            data: MaybeUninit::uninit(),\n             next: Atomic::null(),\n         });\n         unsafe {\n@@ -93,7 +89,7 @@ impl<T> Queue<T> {\n     /// Adds `t` to the back of the queue, possibly waking up threads blocked on `pop`.\n     pub fn push(&self, t: T, guard: &Guard) {\n         let new = Owned::new(Node {\n-            data: ManuallyDrop::new(t),\n+            data: MaybeUninit::new(t),\n             next: Atomic::null(),\n         });\n         let new = Owned::into_shared(new, guard);\n@@ -126,7 +122,8 @@ impl<T> Queue<T> {\n                             let _ = self.tail.compare_and_set(tail, next, Release, guard);\n                         }\n                         guard.defer_destroy(head);\n-                        Some(ManuallyDrop::into_inner(ptr::read(&n.data)))\n+                        // TODO: Replace with MaybeUninit::read when api is stable\n+                        Some(n.data.as_ptr().read())\n                     })\n                     .map_err(|_| ())\n             },\n@@ -145,22 +142,25 @@ impl<T> Queue<T> {\n         let head = self.head.load(Acquire, guard);\n         let h = unsafe { head.deref() };\n         let next = h.next.load(Acquire, guard);\n-        match unsafe { next.as_ref() } {\n-            Some(n) if condition(&n.data) => unsafe {\n-                self.head\n-                    .compare_and_set(head, next, Release, guard)\n-                    .map(|_| {\n-                        let tail = self.tail.load(Relaxed, guard);\n-                        // Advance the tail so that we don't retire a pointer to a reachable node.\n-                        if head == tail {\n-                            let _ = self.tail.compare_and_set(tail, next, Release, guard);\n-                        }\n-                        guard.defer_destroy(head);\n-                        Some(ManuallyDrop::into_inner(ptr::read(&n.data)))\n-                    })\n-                    .map_err(|_| ())\n-            },\n-            None | Some(_) => Ok(None),\n+        unsafe {\n+            match next.as_ref() {\n+                Some(n) if condition(&*n.data.as_ptr()) => {\n+                    self.head\n+                        .compare_and_set(head, next, Release, guard)\n+                        .map(|_| {\n+                            let tail = self.tail.load(Relaxed, guard);\n+                            // Advance the tail so that we don't retire a pointer to a reachable node.\n+                            if head == tail {\n+                                let _ = self.tail.compare_and_set(tail, next, Release, guard);\n+                            }\n+                            guard.defer_destroy(head);\n+                            // TODO: Replace with MaybeUninit::read when api is stable\n+                            Some(n.data.as_ptr().read())\n+                        })\n+                        .map_err(|_| ())\n+                }\n+                None | Some(_) => Ok(None),\n+            }\n         }\n     }\n \n",
    "diff_parsed": "{'added': [(11, 'use core::mem::MaybeUninit;'), (35, '    data: MaybeUninit<T>,'), (52, '            data: MaybeUninit::uninit(),'), (92, '            data: MaybeUninit::new(t),'), (126, '                        Some(n.data.as_ptr().read())'), (145, '        unsafe {'), (146, '            match next.as_ref() {'), (147, '                Some(n) if condition(&*n.data.as_ptr()) => {'), (148, '                    self.head'), (149, '                        .compare_and_set(head, next, Release, guard)'), (150, '                        .map(|_| {'), (151, '                            let tail = self.tail.load(Relaxed, guard);'), (153, '                            if head == tail {'), (154, '                                let _ = self.tail.compare_and_set(tail, next, Release, guard);'), (155, '                            }'), (156, '                            guard.defer_destroy(head);'), (158, '                            Some(n.data.as_ptr().read())'), (159, '                        })'), (160, '                        .map_err(|_| ())'), (161, '                }'), (162, '                None | Some(_) => Ok(None),'), (163, '            }')], 'deleted': [(11, 'use core::mem::{self, ManuallyDrop};'), (12, 'use core::ptr;'), (36, '    data: ManuallyDrop<T>,'), (54, '        #[allow(deprecated)]'), (56, '            data: unsafe { mem::uninitialized() },'), (96, '            data: ManuallyDrop::new(t),'), (129, '                        Some(ManuallyDrop::into_inner(ptr::read(&n.data)))'), (148, '        match unsafe { next.as_ref() } {'), (149, '            Some(n) if condition(&n.data) => unsafe {'), (150, '                self.head'), (151, '                    .compare_and_set(head, next, Release, guard)'), (152, '                    .map(|_| {'), (153, '                        let tail = self.tail.load(Relaxed, guard);'), (155, '                        if head == tail {'), (156, '                            let _ = self.tail.compare_and_set(tail, next, Release, guard);'), (157, '                        }'), (158, '                        guard.defer_destroy(head);'), (159, '                        Some(ManuallyDrop::into_inner(ptr::read(&n.data)))'), (160, '                    })'), (161, '                    .map_err(|_| ())'), (162, '            },'), (163, '            None | Some(_) => Ok(None),')]}",
    "num_lines_added": "22",
    "num_lines_deleted": "22",
    "nloc": "363"
  },
  {
    "file_change_id": "137558877138477",
    "hash": "6f3a3c17ea89fe16f55246cdfb64d684a52a529",
    "old_path": "crossbeam-queue/src/array_queue.rs",
    "new_path": "crossbeam-queue/src/array_queue.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -12,7 +12,7 @@ use alloc::vec::Vec;\n use core::cell::UnsafeCell;\n use core::fmt;\n use core::marker::PhantomData;\n-use core::mem;\n+use core::mem::{self, MaybeUninit};\n use core::ptr;\n use core::sync::atomic::{self, AtomicUsize, Ordering};\n \n@@ -29,7 +29,7 @@ struct Slot<T> {\n     stamp: AtomicUsize,\n \n     /// The value in this slot.\n-    value: UnsafeCell<T>,\n+    value: UnsafeCell<MaybeUninit<T>>,\n }\n \n /// A bounded multi-producer multi-consumer queue.\n@@ -186,9 +186,7 @@ impl<T> ArrayQueue<T> {\n                 ) {\n                     Ok(_) => {\n                         // Write the value into the slot and update the stamp.\n-                        unsafe {\n-                            slot.value.get().write(value);\n-                        }\n+                        unsafe { slot.value.get().write(MaybeUninit::new(value)) }\n                         slot.stamp.store(tail + 1, Ordering::Release);\n                         return Ok(());\n                     }\n@@ -266,7 +264,7 @@ impl<T> ArrayQueue<T> {\n                 ) {\n                     Ok(_) => {\n                         // Read the value from the slot and update the stamp.\n-                        let msg = unsafe { slot.value.get().read() };\n+                        let msg = unsafe { slot.value.get().read().assume_init() };\n                         slot.stamp\n                             .store(head.wrapping_add(self.one_lap), Ordering::Release);\n                         return Ok(msg);\n",
    "diff_parsed": "{'added': [(15, 'use core::mem::{self, MaybeUninit};'), (32, '    value: UnsafeCell<MaybeUninit<T>>,'), (189, '                        unsafe { slot.value.get().write(MaybeUninit::new(value)) }'), (267, '                        let msg = unsafe { slot.value.get().read().assume_init() };')], 'deleted': [(15, 'use core::mem;'), (32, '    value: UnsafeCell<T>,'), (189, '                        unsafe {'), (190, '                            slot.value.get().write(value);'), (191, '                        }'), (269, '                        let msg = unsafe { slot.value.get().read() };')]}",
    "num_lines_added": "4",
    "num_lines_deleted": "6",
    "nloc": "195"
  },
  {
    "file_change_id": "182780424865075",
    "hash": "71d2799afe690ef9d07bb77614c6bb164cb8e67",
    "old_path": "crossbeam-channel/src/flavors/array.rs",
    "new_path": "crossbeam-channel/src/flavors/array.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -15,7 +15,7 @@\n \n use std::cell::UnsafeCell;\n use std::marker::PhantomData;\n-use std::mem;\n+use std::mem::{self, MaybeUninit};\n use std::ptr;\n use std::sync::atomic::{self, AtomicUsize, Ordering};\n use std::time::Instant;\n@@ -33,7 +33,7 @@ struct Slot<T> {\n     stamp: AtomicUsize,\n \n     /// The message in this slot.\n-    msg: UnsafeCell<T>,\n+    msg: UnsafeCell<MaybeUninit<T>>,\n }\n \n /// The token type for the array flavor.\n@@ -233,7 +233,7 @@ impl<T> Channel<T> {\n         let slot: &Slot<T> = &*(token.array.slot as *const Slot<T>);\n \n         // Write the message into the slot and update the stamp.\n-        slot.msg.get().write(msg);\n+        slot.msg.get().write(MaybeUninit::new(msg));\n         slot.stamp.store(token.array.stamp, Ordering::Release);\n \n         // Wake a sleeping receiver.\n@@ -323,7 +323,7 @@ impl<T> Channel<T> {\n         let slot: &Slot<T> = &*(token.array.slot as *const Slot<T>);\n \n         // Read the message from the slot and update the stamp.\n-        let msg = slot.msg.get().read();\n+        let msg = slot.msg.get().read().assume_init();\n         slot.stamp.store(token.array.stamp, Ordering::Release);\n \n         // Wake a sleeping sender.\n",
    "diff_parsed": "{'added': [(18, 'use std::mem::{self, MaybeUninit};'), (36, '    msg: UnsafeCell<MaybeUninit<T>>,'), (236, '        slot.msg.get().write(MaybeUninit::new(msg));'), (326, '        let msg = slot.msg.get().read().assume_init();')], 'deleted': [(18, 'use std::mem;'), (36, '    msg: UnsafeCell<T>,'), (236, '        slot.msg.get().write(msg);'), (326, '        let msg = slot.msg.get().read();')]}",
    "num_lines_added": "4",
    "num_lines_deleted": "4",
    "nloc": "410"
  },
  {
    "file_change_id": "80689400076173",
    "hash": "b5525b73a5955c5f39157f088b78b93e8943649",
    "old_path": "crossbeam-channel/src/flavors/array.rs",
    "new_path": "crossbeam-channel/src/flavors/array.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -15,13 +15,15 @@\n \n use std::cell::UnsafeCell;\n use std::marker::PhantomData;\n-use std::mem::{self, MaybeUninit};\n+use std::mem;\n use std::ptr;\n use std::sync::atomic::{self, AtomicUsize, Ordering};\n use std::time::Instant;\n \n use crossbeam_utils::{Backoff, CachePadded};\n \n+use maybe_uninit::MaybeUninit;\n+\n use context::Context;\n use err::{RecvTimeoutError, SendTimeoutError, TryRecvError, TrySendError};\n use select::{Operation, SelectHandle, Selected, Token};\n",
    "diff_parsed": "{'added': [(18, 'use std::mem;'), (25, 'use maybe_uninit::MaybeUninit;')], 'deleted': [(18, 'use std::mem::{self, MaybeUninit};')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "1",
    "nloc": "416"
  },
  {
    "file_change_id": "37071341354956",
    "hash": "b5525b73a5955c5f39157f088b78b93e8943649",
    "old_path": "crossbeam-channel/src/flavors/list.rs",
    "new_path": "crossbeam-channel/src/flavors/list.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -2,13 +2,14 @@\n \n use std::cell::UnsafeCell;\n use std::marker::PhantomData;\n-use std::mem::MaybeUninit;\n use std::ptr;\n use std::sync::atomic::{self, AtomicPtr, AtomicUsize, Ordering};\n use std::time::Instant;\n \n use crossbeam_utils::{Backoff, CachePadded};\n \n+use maybe_uninit::MaybeUninit;\n+\n use context::Context;\n use err::{RecvTimeoutError, SendTimeoutError, TryRecvError, TrySendError};\n use select::{Operation, SelectHandle, Selected, Token};\n",
    "diff_parsed": "{'added': [(11, 'use maybe_uninit::MaybeUninit;')], 'deleted': [(5, 'use std::mem::MaybeUninit;')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "447"
  },
  {
    "file_change_id": "174112826265203",
    "hash": "b5525b73a5955c5f39157f088b78b93e8943649",
    "old_path": "crossbeam-channel/src/lib.rs",
    "new_path": "crossbeam-channel/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -348,6 +348,7 @@\n #![warn(missing_debug_implementations)]\n \n extern crate crossbeam_utils;\n+extern crate maybe_uninit;\n \n mod channel;\n mod context;\n",
    "diff_parsed": "{'added': [(351, 'extern crate maybe_uninit;')], 'deleted': []}",
    "num_lines_added": "1",
    "num_lines_deleted": "0",
    "nloc": "26"
  },
  {
    "file_change_id": "121391165250239",
    "hash": "b5525b73a5955c5f39157f088b78b93e8943649",
    "old_path": "crossbeam-deque/src/lib.rs",
    "new_path": "crossbeam-deque/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -92,12 +92,14 @@\n extern crate crossbeam_epoch as epoch;\n extern crate crossbeam_utils as utils;\n \n+extern crate maybe_uninit;\n+\n use std::cell::{Cell, UnsafeCell};\n use std::cmp;\n use std::fmt;\n use std::iter::FromIterator;\n use std::marker::PhantomData;\n-use std::mem::{self, MaybeUninit};\n+use std::mem;\n use std::ptr;\n use std::sync::atomic::{self, AtomicIsize, AtomicPtr, AtomicUsize, Ordering};\n use std::sync::Arc;\n@@ -105,6 +107,8 @@ use std::sync::Arc;\n use epoch::{Atomic, Owned};\n use utils::{Backoff, CachePadded};\n \n+use maybe_uninit::MaybeUninit;\n+\n // Minimum buffer capacity.\n const MIN_CAP: usize = 64;\n // Maximum number of tasks that can be stolen in `steal_batch()` and `steal_batch_and_pop()`.\n",
    "diff_parsed": "{'added': [(95, 'extern crate maybe_uninit;'), (102, 'use std::mem;'), (110, 'use maybe_uninit::MaybeUninit;')], 'deleted': [(100, 'use std::mem::{self, MaybeUninit};')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "1",
    "nloc": "999"
  },
  {
    "file_change_id": "76622138158970",
    "hash": "b5525b73a5955c5f39157f088b78b93e8943649",
    "old_path": "crossbeam-epoch/src/deferred.rs",
    "new_path": "crossbeam-epoch/src/deferred.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,9 +1,11 @@\n use alloc::boxed::Box;\n use core::fmt;\n use core::marker::PhantomData;\n-use core::mem::{self, MaybeUninit};\n+use core::mem;\n use core::ptr;\n \n+use maybe_uninit::MaybeUninit;\n+\n /// Number of words a piece of `Data` can hold.\n ///\n /// Three words should be enough for the majority of cases. For example, you can fit inside it the\n",
    "diff_parsed": "{'added': [(4, 'use core::mem;'), (7, 'use maybe_uninit::MaybeUninit;')], 'deleted': [(4, 'use core::mem::{self, MaybeUninit};')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "1",
    "nloc": "104"
  },
  {
    "file_change_id": "32689718625670",
    "hash": "b5525b73a5955c5f39157f088b78b93e8943649",
    "old_path": "crossbeam-epoch/src/lib.rs",
    "new_path": "crossbeam-epoch/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -64,6 +64,8 @@ extern crate cfg_if;\n #[cfg(feature = \"std\")]\n extern crate core;\n \n+extern crate maybe_uninit;\n+\n cfg_if! {\n     if #[cfg(feature = \"alloc\")] {\n         extern crate alloc;\n",
    "diff_parsed": "{'added': [(67, 'extern crate maybe_uninit;')], 'deleted': []}",
    "num_lines_added": "1",
    "num_lines_deleted": "0",
    "nloc": "44"
  },
  {
    "file_change_id": "231319361993156",
    "hash": "b5525b73a5955c5f39157f088b78b93e8943649",
    "old_path": "crossbeam-epoch/src/sync/queue.rs",
    "new_path": "crossbeam-epoch/src/sync/queue.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -8,11 +8,12 @@\n //! Simon Doherty, Lindsay Groves, Victor Luchangco, and Mark Moir. 2004b. Formal Verification of a\n //! Practical Lock-Free Queue Algorithm. https://doi.org/10.1007/978-3-540-30232-2_7\n \n-use core::mem::MaybeUninit;\n use core::sync::atomic::Ordering::{Acquire, Relaxed, Release};\n \n use crossbeam_utils::CachePadded;\n \n+use maybe_uninit::MaybeUninit;\n+\n use {unprotected, Atomic, Guard, Owned, Shared};\n \n // The representation here is a singly-linked list, with a sentinel node at the front. In general\n",
    "diff_parsed": "{'added': [(15, 'use maybe_uninit::MaybeUninit;')], 'deleted': [(11, 'use core::mem::MaybeUninit;')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "362"
  },
  {
    "file_change_id": "153176072349888",
    "hash": "b5525b73a5955c5f39157f088b78b93e8943649",
    "old_path": "crossbeam-queue/src/array_queue.rs",
    "new_path": "crossbeam-queue/src/array_queue.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -12,12 +12,14 @@ use alloc::vec::Vec;\n use core::cell::UnsafeCell;\n use core::fmt;\n use core::marker::PhantomData;\n-use core::mem::{self, MaybeUninit};\n+use core::mem;\n use core::ptr;\n use core::sync::atomic::{self, AtomicUsize, Ordering};\n \n use crossbeam_utils::{Backoff, CachePadded};\n \n+use maybe_uninit::MaybeUninit;\n+\n use err::{PopError, PushError};\n \n /// A slot in a queue.\n",
    "diff_parsed": "{'added': [(15, 'use core::mem;'), (21, 'use maybe_uninit::MaybeUninit;')], 'deleted': [(15, 'use core::mem::{self, MaybeUninit};')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "1",
    "nloc": "201"
  },
  {
    "file_change_id": "208020544707673",
    "hash": "b5525b73a5955c5f39157f088b78b93e8943649",
    "old_path": "crossbeam-queue/src/lib.rs",
    "new_path": "crossbeam-queue/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -17,6 +17,8 @@ extern crate cfg_if;\n #[cfg(feature = \"std\")]\n extern crate core;\n \n+extern crate maybe_uninit;\n+\n cfg_if! {\n     if #[cfg(feature = \"alloc\")] {\n         extern crate alloc;\n",
    "diff_parsed": "{'added': [(20, 'extern crate maybe_uninit;')], 'deleted': []}",
    "num_lines_added": "1",
    "num_lines_deleted": "0",
    "nloc": "26"
  },
  {
    "file_change_id": "127369926689232",
    "hash": "b5525b73a5955c5f39157f088b78b93e8943649",
    "old_path": "crossbeam-queue/src/seg_queue.rs",
    "new_path": "crossbeam-queue/src/seg_queue.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -2,12 +2,13 @@ use alloc::boxed::Box;\n use core::cell::UnsafeCell;\n use core::fmt;\n use core::marker::PhantomData;\n-use core::mem::MaybeUninit;\n use core::ptr;\n use core::sync::atomic::{self, AtomicPtr, AtomicUsize, Ordering};\n \n use crossbeam_utils::{Backoff, CachePadded};\n \n+use maybe_uninit::MaybeUninit;\n+\n use err::PopError;\n \n // Bits indicating the state of a slot:\n",
    "diff_parsed": "{'added': [(10, 'use maybe_uninit::MaybeUninit;')], 'deleted': [(5, 'use core::mem::MaybeUninit;')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "273"
  },
  {
    "file_change_id": "259485550739693",
    "hash": "d78de60ea78c3aa0eeca66f42dda0154a7cc89fc",
    "old_path": "crossbeam-queue/src/array_queue.rs",
    "new_path": "crossbeam-queue/src/array_queue.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -413,7 +413,17 @@ impl<T> Drop for ArrayQueue<T> {\n             };\n \n             unsafe {\n-                self.buffer.add(index).drop_in_place();\n+                let ptr = self.buffer.add(index);\n+                {\n+                    // This requires an extra scope because when we drop the Slot,\n+                    // reference to it should not exist.\n+                    let slot = &mut *ptr;\n+                    let value = &mut *slot.value.get();\n+                    // Drop the message (MaybeUninit<T>).\n+                    value.as_mut_ptr().drop_in_place();\n+                }\n+                // Drop slot (This should be a no-op).\n+                ptr.drop_in_place();\n             }\n         }\n \n",
    "diff_parsed": "{'added': [(416, '                let ptr = self.buffer.add(index);'), (417, '                {'), (420, '                    let slot = &mut *ptr;'), (421, '                    let value = &mut *slot.value.get();'), (423, '                    value.as_mut_ptr().drop_in_place();'), (424, '                }'), (426, '                ptr.drop_in_place();')], 'deleted': [(416, '                self.buffer.add(index).drop_in_place();')]}",
    "num_lines_added": "7",
    "num_lines_deleted": "1",
    "nloc": "201"
  },
  {
    "file_change_id": "253125448388907",
    "hash": "dce3e118f2778423113e6d6019dd05d88cf7e0e6",
    "old_path": "crossbeam-channel/src/flavors/array.rs",
    "new_path": "crossbeam-channel/src/flavors/array.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -542,7 +542,17 @@ impl<T> Drop for Channel<T> {\n             };\n \n             unsafe {\n-                self.buffer.add(index).drop_in_place();\n+                let ptr = self.buffer.add(index);\n+                {\n+                    // This requires an extra scope because when we drop the Slot,\n+                    // reference to it should not exist.\n+                    let slot = &mut *ptr;\n+                    let msg = &mut *slot.msg.get();\n+                    // Drop the message (MaybeUninit<T>).\n+                    msg.as_mut_ptr().drop_in_place();\n+                }\n+                // Drop slot (This should be a no-op).\n+                ptr.drop_in_place();\n             }\n         }\n \n",
    "diff_parsed": "{'added': [(545, '                let ptr = self.buffer.add(index);'), (546, '                {'), (549, '                    let slot = &mut *ptr;'), (550, '                    let msg = &mut *slot.msg.get();'), (552, '                    msg.as_mut_ptr().drop_in_place();'), (553, '                }'), (555, '                ptr.drop_in_place();')], 'deleted': [(545, '                self.buffer.add(index).drop_in_place();')]}",
    "num_lines_added": "7",
    "num_lines_deleted": "1",
    "nloc": "416"
  },
  {
    "file_change_id": "234010389358531",
    "hash": "65d17446c4242da0f9e1ae84b9dbce5108a822f",
    "old_path": "src/hdr/decoder.rs",
    "new_path": "src/hdr/decoder.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -330,57 +330,48 @@ impl<R: BufRead> HDRDecoder<R> {\n     pub fn read_image_transform<T: Send, F: Send + Sync + Fn(RGBE8Pixel) -> T>(\n         mut self,\n         f: F,\n-    ) -> ImageResult<Vec<T>> {\n+        output_slice: &mut [T],\n+    ) -> ImageResult<()> {\n+        assert_eq!(output_slice.len(), self.width as usize * self.height as usize);\n+\n         // Don't read anything if image is empty\n         if self.width == 0 || self.height == 0 {\n-            return Ok(vec![]);\n+            return Ok(());\n         }\n-        // expression self.width > 0 && self.height > 0 is true from now to the end of this method\n-        // scanline buffer\n-        let uszwidth = self.width as usize;\n \n-        let pixel_count = self.width as usize * self.height as usize;\n-        let mut ret = Vec::with_capacity(pixel_count);\n-        unsafe {\n-            // RGBE8Pixel doesn't implement Drop, so it's Ok to drop half-initialized ret\n-            ret.set_len(pixel_count);\n-        } // ret contains uninitialized data, so now it's my responsibility to return fully initialized ret\n-\n-        {\n-            let chunks_iter = ret.chunks_mut(uszwidth);\n-            let mut pool = Pool::new(8); //\n-\n-            try!(pool.scoped(|scope| {\n-                for chunk in chunks_iter {\n-                    let mut buf = Vec::<RGBE8Pixel>::with_capacity(uszwidth);\n-                    unsafe {\n-                        buf.set_len(uszwidth);\n+        let chunks_iter = output_slice.chunks_mut(self.width as usize);\n+        let mut pool = Pool::new(8); //\n+\n+        try!(pool.scoped(|scope| {\n+            for chunk in chunks_iter {\n+                let mut buf = vec![Default::default(); self.width as usize];\n+                try!(read_scanline(&mut self.r, &mut buf[..]));\n+                let f = &f;\n+                scope.execute(move || {\n+                    for (dst, &pix) in chunk.iter_mut().zip(buf.iter()) {\n+                        *dst = f(pix);\n                     }\n-                    try!(read_scanline(&mut self.r, &mut buf[..]));\n-                    let f = &f;\n-                    scope.execute(move || {\n-                        for (dst, &pix) in chunk.iter_mut().zip(buf.iter()) {\n-                            *dst = f(pix);\n-                        }\n-                    });\n-                }\n-                Ok(())\n-            }) as Result<(), ImageError>);\n-        }\n-\n-        Ok(ret)\n+                });\n+            }\n+            Ok(())\n+        }) as Result<(), ImageError>);\n+        Ok(())\n     }\n \n     /// Consumes decoder and returns a vector of Rgb<u8> pixels.\n     /// scale = 1, gamma = 2.2\n     pub fn read_image_ldr(self) -> ImageResult<Vec<Rgb<u8>>> {\n-        self.read_image_transform(|pix| pix.to_ldr())\n+        let mut ret = vec![Rgb([0,0,0]); self.width as usize * self.height as usize];\n+        self.read_image_transform(|pix| pix.to_ldr(), &mut ret[..])?;\n+        Ok(ret)\n     }\n \n     /// Consumes decoder and returns a vector of Rgb<f32> pixels.\n     ///\n     pub fn read_image_hdr(self) -> ImageResult<Vec<Rgb<f32>>> {\n-        self.read_image_transform(|pix| pix.to_hdr())\n+        let mut ret = vec![Rgb([0.0, 0.0, 0.0]); self.width as usize * self.height as usize];\n+        self.read_image_transform(|pix| pix.to_hdr(), &mut ret[..])?;\n+        Ok(ret)\n     }\n }\n \n",
    "diff_parsed": "{'added': [(333, '        output_slice: &mut [T],'), (334, '    ) -> ImageResult<()> {'), (335, '        assert_eq!(output_slice.len(), self.width as usize * self.height as usize);'), (339, '            return Ok(());'), (342, '        let chunks_iter = output_slice.chunks_mut(self.width as usize);'), (343, '        let mut pool = Pool::new(8); //'), (345, '        try!(pool.scoped(|scope| {'), (346, '            for chunk in chunks_iter {'), (347, '                let mut buf = vec![Default::default(); self.width as usize];'), (348, '                try!(read_scanline(&mut self.r, &mut buf[..]));'), (349, '                let f = &f;'), (350, '                scope.execute(move || {'), (351, '                    for (dst, &pix) in chunk.iter_mut().zip(buf.iter()) {'), (352, '                        *dst = f(pix);'), (354, '                });'), (355, '            }'), (356, '            Ok(())'), (357, '        }) as Result<(), ImageError>);'), (358, '        Ok(())'), (364, '        let mut ret = vec![Rgb([0,0,0]); self.width as usize * self.height as usize];'), (365, '        self.read_image_transform(|pix| pix.to_ldr(), &mut ret[..])?;'), (366, '        Ok(ret)'), (372, '        let mut ret = vec![Rgb([0.0, 0.0, 0.0]); self.width as usize * self.height as usize];'), (373, '        self.read_image_transform(|pix| pix.to_hdr(), &mut ret[..])?;'), (374, '        Ok(ret)')], 'deleted': [(333, '    ) -> ImageResult<Vec<T>> {'), (336, '            return Ok(vec![]);'), (340, '        let uszwidth = self.width as usize;'), (342, '        let pixel_count = self.width as usize * self.height as usize;'), (343, '        let mut ret = Vec::with_capacity(pixel_count);'), (344, '        unsafe {'), (346, '            ret.set_len(pixel_count);'), (347, \"        } // ret contains uninitialized data, so now it's my responsibility to return fully initialized ret\"), (349, '        {'), (350, '            let chunks_iter = ret.chunks_mut(uszwidth);'), (351, '            let mut pool = Pool::new(8); //'), (353, '            try!(pool.scoped(|scope| {'), (354, '                for chunk in chunks_iter {'), (355, '                    let mut buf = Vec::<RGBE8Pixel>::with_capacity(uszwidth);'), (356, '                    unsafe {'), (357, '                        buf.set_len(uszwidth);'), (359, '                    try!(read_scanline(&mut self.r, &mut buf[..]));'), (360, '                    let f = &f;'), (361, '                    scope.execute(move || {'), (362, '                        for (dst, &pix) in chunk.iter_mut().zip(buf.iter()) {'), (363, '                            *dst = f(pix);'), (364, '                        }'), (365, '                    });'), (366, '                }'), (367, '                Ok(())'), (368, '            }) as Result<(), ImageError>);'), (369, '        }'), (371, '        Ok(ret)'), (377, '        self.read_image_transform(|pix| pix.to_ldr())'), (383, '        self.read_image_transform(|pix| pix.to_hdr())')]}",
    "num_lines_added": "25",
    "num_lines_deleted": "30",
    "nloc": "737"
  },
  {
    "file_change_id": "273167565290950",
    "hash": "6c7bf22907a75d1bbaed52e4f7dd9716f5e6f73",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -143,7 +143,8 @@ pub fn clean_text(src: &str) -> String {\n             ' ' => \"&#32;\",\n             '\\t' => \"&#9;\",\n             '\\n' => \"&#10;\",\n-            '\\r' => \"&#12;\",\n+            '\\x0c' => \"&#12;\",\n+            '\\r' => \"&#13;\",\n             // a spec-compliant browser will perform this replacement anyway, but the middleware might not\n             '\\0' => \"&#65533;\",\n             // ALL OTHER CHARACTERS ARE PASSED THROUGH VERBATIM\n@@ -3436,6 +3437,14 @@ mod test {\n         );\n     }\n \n+    #[test]\n+    fn clean_text_spaces_test() {\n+        assert_eq!(\n+            clean_text(\"\\x09\\x0a\\x0c\\x20\"),\n+            \"&#9;&#10;&#12;&#32;\"\n+        );\n+    }\n+\n     #[test]\n     fn ns_svg() {\n         // https://github.com/cure53/DOMPurify/pull/495\n",
    "diff_parsed": "{'added': [(146, '            \\'\\\\x0c\\' => \"&#12;\",'), (147, '            \\'\\\\r\\' => \"&#13;\",'), (3440, '    #[test]'), (3441, '    fn clean_text_spaces_test() {'), (3442, '        assert_eq!('), (3443, '            clean_text(\"\\\\x09\\\\x0a\\\\x0c\\\\x20\"),'), (3444, '            \"&#9;&#10;&#12;&#32;\"'), (3445, '        );'), (3446, '    }')], 'deleted': [(146, '            \\'\\\\r\\' => \"&#12;\",')]}",
    "num_lines_added": "9",
    "num_lines_deleted": "1",
    "nloc": "2648"
  },
  {
    "file_change_id": "270834828632187",
    "hash": "4c00d6212aa5fa56d16cc8a1774ad908d10522b",
    "old_path": "lock_api/src/lib.rs",
    "new_path": "lock_api/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -99,6 +99,8 @@ pub struct GuardSend(());\n /// Marker type which indicates that the Guard type for a lock is not `Send`.\n pub struct GuardNoSend(*mut ());\n \n+unsafe impl Sync for GuardNoSend {}\n+\n mod mutex;\n pub use crate::mutex::*;\n \n",
    "diff_parsed": "{'added': [(102, 'unsafe impl Sync for GuardNoSend {}')], 'deleted': []}",
    "num_lines_added": "1",
    "num_lines_deleted": "0",
    "nloc": "15"
  },
  {
    "file_change_id": "131915622137832",
    "hash": "4c00d6212aa5fa56d16cc8a1774ad908d10522b",
    "old_path": "lock_api/src/mutex.rs",
    "new_path": "lock_api/src/mutex.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -601,7 +601,7 @@ unsafe impl<'a, R: RawMutex + Sync + 'a, T: ?Sized + Sync + 'a> Sync\n     for MappedMutexGuard<'a, R, T>\n {\n }\n-unsafe impl<'a, R: RawMutex + 'a, T: ?Sized + 'a> Send for MappedMutexGuard<'a, R, T> where\n+unsafe impl<'a, R: RawMutex + 'a, T: ?Sized + Send + 'a> Send for MappedMutexGuard<'a, R, T> where\n     R::GuardMarker: Send\n {\n }\n",
    "diff_parsed": "{'added': [(604, \"unsafe impl<'a, R: RawMutex + 'a, T: ?Sized + Send + 'a> Send for MappedMutexGuard<'a, R, T> where\")], 'deleted': [(604, \"unsafe impl<'a, R: RawMutex + 'a, T: ?Sized + 'a> Send for MappedMutexGuard<'a, R, T> where\")]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "572"
  },
  {
    "file_change_id": "9718337496532",
    "hash": "4c00d6212aa5fa56d16cc8a1774ad908d10522b",
    "old_path": "lock_api/src/rwlock.rs",
    "new_path": "lock_api/src/rwlock.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -875,8 +875,6 @@ pub struct RwLockReadGuard<'a, R: RawRwLock, T: ?Sized> {\n     marker: PhantomData<(&'a T, R::GuardMarker)>,\n }\n \n-unsafe impl<'a, R: RawRwLock + 'a, T: ?Sized + Sync + 'a> Sync for RwLockReadGuard<'a, R, T> {}\n-\n impl<'a, R: RawRwLock + 'a, T: ?Sized + 'a> RwLockReadGuard<'a, R, T> {\n     /// Returns a reference to the original reader-writer lock object.\n     pub fn rwlock(s: &Self) -> &'a RwLock<R, T> {\n@@ -1051,8 +1049,6 @@ pub struct RwLockWriteGuard<'a, R: RawRwLock, T: ?Sized> {\n     marker: PhantomData<(&'a mut T, R::GuardMarker)>,\n }\n \n-unsafe impl<'a, R: RawRwLock + 'a, T: ?Sized + Sync + 'a> Sync for RwLockWriteGuard<'a, R, T> {}\n-\n impl<'a, R: RawRwLock + 'a, T: ?Sized + 'a> RwLockWriteGuard<'a, R, T> {\n     /// Returns a reference to the original reader-writer lock object.\n     pub fn rwlock(s: &Self) -> &'a RwLock<R, T> {\n@@ -1514,7 +1510,7 @@ pub struct MappedRwLockReadGuard<'a, R: RawRwLock, T: ?Sized> {\n }\n \n unsafe impl<'a, R: RawRwLock + 'a, T: ?Sized + Sync + 'a> Sync for MappedRwLockReadGuard<'a, R, T> {}\n-unsafe impl<'a, R: RawRwLock + 'a, T: ?Sized + 'a> Send for MappedRwLockReadGuard<'a, R, T> where\n+unsafe impl<'a, R: RawRwLock + 'a, T: ?Sized + Sync + 'a> Send for MappedRwLockReadGuard<'a, R, T> where\n     R::GuardMarker: Send\n {\n }\n@@ -1652,7 +1648,7 @@ unsafe impl<'a, R: RawRwLock + 'a, T: ?Sized + Sync + 'a> Sync\n     for MappedRwLockWriteGuard<'a, R, T>\n {\n }\n-unsafe impl<'a, R: RawRwLock + 'a, T: ?Sized + 'a> Send for MappedRwLockWriteGuard<'a, R, T> where\n+unsafe impl<'a, R: RawRwLock + 'a, T: ?Sized + Send + 'a> Send for MappedRwLockWriteGuard<'a, R, T> where\n     R::GuardMarker: Send\n {\n }\n",
    "diff_parsed": "{'added': [(1513, \"unsafe impl<'a, R: RawRwLock + 'a, T: ?Sized + Sync + 'a> Send for MappedRwLockReadGuard<'a, R, T> where\"), (1651, \"unsafe impl<'a, R: RawRwLock + 'a, T: ?Sized + Send + 'a> Send for MappedRwLockWriteGuard<'a, R, T> where\")], 'deleted': [(878, \"unsafe impl<'a, R: RawRwLock + 'a, T: ?Sized + Sync + 'a> Sync for RwLockReadGuard<'a, R, T> {}\"), (1054, \"unsafe impl<'a, R: RawRwLock + 'a, T: ?Sized + Sync + 'a> Sync for RwLockWriteGuard<'a, R, T> {}\"), (1517, \"unsafe impl<'a, R: RawRwLock + 'a, T: ?Sized + 'a> Send for MappedRwLockReadGuard<'a, R, T> where\"), (1655, \"unsafe impl<'a, R: RawRwLock + 'a, T: ?Sized + 'a> Send for MappedRwLockWriteGuard<'a, R, T> where\")]}",
    "num_lines_added": "2",
    "num_lines_deleted": "4",
    "nloc": "1166"
  },
  {
    "file_change_id": "64693861743451",
    "hash": "a134e06d740f9d7c287f74c0af2cd0620677436",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -314,7 +314,7 @@ pub unsafe fn guarded_transmute_vec_permissive<T>(mut bytes: Vec<u8>) -> Vec<T>\n     let capacity = bytes.capacity() / size_of::<T>();\n     let len = bytes.len() / size_of::<T>();\n     forget(bytes);\n-    Vec::from_raw_parts(ptr as *mut T, capacity, len)\n+    Vec::from_raw_parts(ptr as *mut T, len, capacity)\n }\n \n /// Trasform a byte vector into a vector of an arbitrary type.\n",
    "diff_parsed": "{'added': [(317, '    Vec::from_raw_parts(ptr as *mut T, len, capacity)')], 'deleted': [(317, '    Vec::from_raw_parts(ptr as *mut T, capacity, len)')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "64"
  },
  {
    "file_change_id": "37175147143847",
    "hash": "a134e06d740f9d7c287f74c0af2cd0620677436",
    "old_path": "src/to_bytes.rs",
    "new_path": "src/to_bytes.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -231,7 +231,7 @@ pub unsafe fn guarded_transmute_to_bytes_vec<T>(mut from: Vec<T>) -> Vec<u8> {\n     let len = from.len() * size_of::<T>();\n     let ptr = from.as_mut_ptr();\n     forget(from);\n-    Vec::from_raw_parts(ptr as *mut u8, capacity, len)\n+    Vec::from_raw_parts(ptr as *mut u8, len, capacity)\n }\n \n /// Transmute a vector of POD types into a vector of their bytes,\n",
    "diff_parsed": "{'added': [(234, '    Vec::from_raw_parts(ptr as *mut u8, len, capacity)')], 'deleted': [(234, '    Vec::from_raw_parts(ptr as *mut u8, capacity, len)')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "29"
  },
  {
    "file_change_id": "108450201109879",
    "hash": "4218155363f893032362d083a0e7fe5c5b0865c",
    "old_path": "tower-http/src/services/fs/serve_dir.rs",
    "new_path": "tower-http/src/services/fs/serve_dir.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -137,7 +137,7 @@ fn build_and_validate_path(base_path: &Path, requested_path: &str) -> Option<Pat\n \n     let mut full_path = base_path.to_path_buf();\n     for seg in path_decoded.split('/') {\n-        if seg.starts_with(\"..\") || seg.contains('\\\\') {\n+        if seg.starts_with(\"..\") || seg.contains('\\\\') || seg.contains(':') {\n             return None;\n         }\n         full_path.push(seg);\n",
    "diff_parsed": "{'added': [(140, '        if seg.starts_with(\"..\") || seg.contains(\\'\\\\\\\\\\') || seg.contains(\\':\\') {')], 'deleted': [(140, '        if seg.starts_with(\"..\") || seg.contains(\\'\\\\\\\\\\') {')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "874"
  },
  {
    "file_change_id": "33814480829671",
    "hash": "4ee8515f969d55768d875ea0b32491037a52fa1",
    "old_path": "tower-http/src/services/fs/serve_dir.rs",
    "new_path": "tower-http/src/services/fs/serve_dir.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -130,19 +130,26 @@ impl ServeVariant {\n }\n \n fn build_and_validate_path(base_path: &Path, requested_path: &str) -> Option<PathBuf> {\n-    // build and validate the path\n     let path = requested_path.trim_start_matches('/');\n \n     let path_decoded = percent_decode(path.as_ref()).decode_utf8().ok()?;\n+    let path_decoded = Path::new(&*path_decoded);\n \n     let mut full_path = base_path.to_path_buf();\n-    for seg in path_decoded.split('/') {\n-        if seg.starts_with(\"..\") || seg.contains('\\\\') || seg.contains(':') {\n-            return None;\n+    for component in path_decoded.components() {\n+        match component {\n+            std::path::Component::Normal(comp) => full_path.push(comp),\n+            std::path::Component::CurDir => {}\n+            std::path::Component::Prefix(_)\n+            | std::path::Component::RootDir\n+            | std::path::Component::ParentDir => return None,\n         }\n-        full_path.push(seg);\n     }\n-    Some(full_path)\n+    if full_path.is_relative() {\n+        Some(full_path)\n+    } else {\n+        None\n+    }\n }\n \n impl ServeDir {\n@@ -984,15 +991,10 @@ mod tests {\n \n     #[tokio::test]\n     async fn access_cjk_percent_encoded_uri_path() {\n-        let cjk_filename = \"\u4f60\u597d\u4e16\u754c.txt\";\n         // percent encoding present of \u4f60\u597d\u4e16\u754c.txt\n         let cjk_filename_encoded = \"%E4%BD%A0%E5%A5%BD%E4%B8%96%E7%95%8C.txt\";\n \n-        let tmp_dir = std::env::temp_dir();\n-        let tmp_filename = std::path::Path::new(tmp_dir.as_path()).join(cjk_filename);\n-        let _ = tokio::fs::File::create(&tmp_filename).await.unwrap();\n-\n-        let svc = ServeDir::new(&tmp_dir);\n+        let svc = ServeDir::new(\"../test-files\");\n \n         let req = Request::builder()\n             .uri(format!(\"/{}\", cjk_filename_encoded))\n@@ -1002,20 +1004,13 @@ mod tests {\n \n         assert_eq!(res.status(), StatusCode::OK);\n         assert_eq!(res.headers()[\"content-type\"], \"text/plain\");\n-        let _ = tokio::fs::remove_file(&tmp_filename).await.unwrap();\n     }\n \n     #[tokio::test]\n     async fn access_space_percent_encoded_uri_path() {\n-        let raw_filename = \"filename with space.txt\";\n-        // percent encoding present of \"filename with space.txt\"\n         let encoded_filename = \"filename%20with%20space.txt\";\n \n-        let tmp_dir = std::env::temp_dir();\n-        let tmp_filename = std::path::Path::new(tmp_dir.as_path()).join(raw_filename);\n-        let _ = tokio::fs::File::create(&tmp_filename).await.unwrap();\n-\n-        let svc = ServeDir::new(&tmp_dir);\n+        let svc = ServeDir::new(\"../test-files\");\n \n         let req = Request::builder()\n             .uri(format!(\"/{}\", encoded_filename))\n@@ -1025,7 +1020,6 @@ mod tests {\n \n         assert_eq!(res.status(), StatusCode::OK);\n         assert_eq!(res.headers()[\"content-type\"], \"text/plain\");\n-        let _ = tokio::fs::remove_file(&tmp_filename).await.unwrap();\n     }\n \n     #[tokio::test]\n",
    "diff_parsed": "{'added': [(136, '    let path_decoded = Path::new(&*path_decoded);'), (139, '    for component in path_decoded.components() {'), (140, '        match component {'), (141, '            std::path::Component::Normal(comp) => full_path.push(comp),'), (142, '            std::path::Component::CurDir => {}'), (143, '            std::path::Component::Prefix(_)'), (144, '            | std::path::Component::RootDir'), (145, '            | std::path::Component::ParentDir => return None,'), (148, '    if full_path.is_relative() {'), (149, '        Some(full_path)'), (150, '    } else {'), (151, '        None'), (152, '    }'), (997, '        let svc = ServeDir::new(\"../test-files\");'), (1013, '        let svc = ServeDir::new(\"../test-files\");')], 'deleted': [(139, \"    for seg in path_decoded.split('/') {\"), (140, '        if seg.starts_with(\"..\") || seg.contains(\\'\\\\\\\\\\') || seg.contains(\\':\\') {'), (141, '            return None;'), (143, '        full_path.push(seg);'), (145, '    Some(full_path)'), (987, '        let cjk_filename = \"\u4f60\u597d\u4e16\u754c.txt\";'), (991, '        let tmp_dir = std::env::temp_dir();'), (992, '        let tmp_filename = std::path::Path::new(tmp_dir.as_path()).join(cjk_filename);'), (993, '        let _ = tokio::fs::File::create(&tmp_filename).await.unwrap();'), (995, '        let svc = ServeDir::new(&tmp_dir);'), (1005, '        let _ = tokio::fs::remove_file(&tmp_filename).await.unwrap();'), (1010, '        let raw_filename = \"filename with space.txt\";'), (1014, '        let tmp_dir = std::env::temp_dir();'), (1015, '        let tmp_filename = std::path::Path::new(tmp_dir.as_path()).join(raw_filename);'), (1016, '        let _ = tokio::fs::File::create(&tmp_filename).await.unwrap();'), (1018, '        let svc = ServeDir::new(&tmp_dir);'), (1028, '        let _ = tokio::fs::remove_file(&tmp_filename).await.unwrap();')]}",
    "num_lines_added": "15",
    "num_lines_deleted": "17",
    "nloc": "872"
  },
  {
    "file_change_id": "158081428607345",
    "hash": "877dc0a52adedd1daaabcfcb56d90d1da1da862",
    "old_path": "src/proto/h1/role.rs",
    "new_path": "src/proto/h1/role.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,16 +1,14 @@\n-// `mem::uninitialized` replaced with `mem::MaybeUninit`,\n-// can't upgrade yet\n #![allow(deprecated)]\n \n use std::fmt::{self, Write};\n-use std::mem;\n+use std::mem::{self, MaybeUninit};\n \n #[cfg(any(test, feature = \"server\", feature = \"ffi\"))]\n use bytes::Bytes;\n use bytes::BytesMut;\n-use http::header::{self, Entry, HeaderName, HeaderValue};\n #[cfg(feature = \"server\")]\n use http::header::ValueIter;\n+use http::header::{self, Entry, HeaderName, HeaderValue};\n use http::{HeaderMap, Method, StatusCode, Version};\n \n use crate::body::DecodedLength;\n@@ -126,7 +124,10 @@ impl Http1Transaction for Server {\n         // but we *never* read any of it until after httparse has assigned\n         // values into it. By not zeroing out the stack memory, this saves\n         // a good ~5% on pipeline benchmarks.\n-        let mut headers_indices: [HeaderIndices; MAX_HEADERS] = unsafe { mem::uninitialized() };\n+        let mut headers_indices: [MaybeUninit<HeaderIndices>; MAX_HEADERS] = unsafe {\n+            // SAFETY: We can go safely from MaybeUninit array to array of MaybeUninit\n+            MaybeUninit::uninit().assume_init()\n+        };\n         {\n             let mut headers: [httparse::Header<'_>; MAX_HEADERS] = unsafe { mem::uninitialized() };\n             trace!(\n@@ -205,6 +206,8 @@ impl Http1Transaction for Server {\n         headers.reserve(headers_len);\n \n         for header in &headers_indices[..headers_len] {\n+            // SAFETY: array is valid up to `headers_len`\n+            let header = unsafe { &*header.as_ptr() };\n             let name = header_name!(&slice[header.name.0..header.name.1]);\n             let value = header_value!(slice.slice(header.value.0..header.value.1));\n \n@@ -880,7 +883,10 @@ impl Http1Transaction for Client {\n         // Loop to skip information status code headers (100 Continue, etc).\n         loop {\n             // Unsafe: see comment in Server Http1Transaction, above.\n-            let mut headers_indices: [HeaderIndices; MAX_HEADERS] = unsafe { mem::uninitialized() };\n+            let mut headers_indices: [MaybeUninit<HeaderIndices>; MAX_HEADERS] = unsafe {\n+                // SAFETY: We can go safely from MaybeUninit array to array of MaybeUninit\n+                MaybeUninit::uninit().assume_init()\n+            };\n             let (len, status, reason, version, headers_len) = {\n                 let mut headers: [httparse::Header<'_>; MAX_HEADERS] =\n                     unsafe { mem::uninitialized() };\n@@ -891,8 +897,7 @@ impl Http1Transaction for Client {\n                 );\n                 let mut res = httparse::Response::new(&mut headers);\n                 let bytes = buf.as_ref();\n-                match ctx.h1_parser_config.parse_response(&mut res, bytes)\n-                {\n+                match ctx.h1_parser_config.parse_response(&mut res, bytes) {\n                     Ok(httparse::Status::Complete(len)) => {\n                         trace!(\"Response.parse Complete({})\", len);\n                         let status = StatusCode::from_u16(res.code.unwrap())?;\n@@ -948,6 +953,8 @@ impl Http1Transaction for Client {\n \n             headers.reserve(headers_len);\n             for header in &headers_indices[..headers_len] {\n+                // SAFETY: array is valid up to `headers_len`\n+                let header = unsafe { &*header.as_ptr() };\n                 let name = header_name!(&slice[header.name.0..header.name.1]);\n                 let value = header_value!(slice.slice(header.value.0..header.value.1));\n \n@@ -1290,7 +1297,7 @@ struct HeaderIndices {\n fn record_header_indices(\n     bytes: &[u8],\n     headers: &[httparse::Header<'_>],\n-    indices: &mut [HeaderIndices],\n+    indices: &mut [MaybeUninit<HeaderIndices>],\n ) -> Result<(), crate::error::Parse> {\n     let bytes_ptr = bytes.as_ptr() as usize;\n \n@@ -1301,10 +1308,19 @@ fn record_header_indices(\n         }\n         let name_start = header.name.as_ptr() as usize - bytes_ptr;\n         let name_end = name_start + header.name.len();\n-        indices.name = (name_start, name_end);\n         let value_start = header.value.as_ptr() as usize - bytes_ptr;\n         let value_end = value_start + header.value.len();\n-        indices.value = (value_start, value_end);\n+\n+        // FIXME(maybe_uninit_extra)\n+        // FIXME(addr_of)\n+        // Currently we don't have `ptr::addr_of_mut` in stable rust or\n+        // MaybeUninit::write, so this is some way of assigning into a MaybeUninit\n+        // safely\n+        let new_header_indices = HeaderIndices {\n+            name: (name_start, name_end),\n+            value: (value_start, value_end),\n+        };\n+        *indices = MaybeUninit::new(new_header_indices);\n     }\n \n     Ok(())\n",
    "diff_parsed": "{'added': [(4, 'use std::mem::{self, MaybeUninit};'), (11, 'use http::header::{self, Entry, HeaderName, HeaderValue};'), (127, '        let mut headers_indices: [MaybeUninit<HeaderIndices>; MAX_HEADERS] = unsafe {'), (129, '            MaybeUninit::uninit().assume_init()'), (130, '        };'), (210, '            let header = unsafe { &*header.as_ptr() };'), (886, '            let mut headers_indices: [MaybeUninit<HeaderIndices>; MAX_HEADERS] = unsafe {'), (888, '                MaybeUninit::uninit().assume_init()'), (889, '            };'), (900, '                match ctx.h1_parser_config.parse_response(&mut res, bytes) {'), (957, '                let header = unsafe { &*header.as_ptr() };'), (1300, '    indices: &mut [MaybeUninit<HeaderIndices>],'), (1319, '        let new_header_indices = HeaderIndices {'), (1320, '            name: (name_start, name_end),'), (1321, '            value: (value_start, value_end),'), (1322, '        };'), (1323, '        *indices = MaybeUninit::new(new_header_indices);')], 'deleted': [(6, 'use std::mem;'), (11, 'use http::header::{self, Entry, HeaderName, HeaderValue};'), (129, '        let mut headers_indices: [HeaderIndices; MAX_HEADERS] = unsafe { mem::uninitialized() };'), (883, '            let mut headers_indices: [HeaderIndices; MAX_HEADERS] = unsafe { mem::uninitialized() };'), (894, '                match ctx.h1_parser_config.parse_response(&mut res, bytes)'), (895, '                {'), (1293, '    indices: &mut [HeaderIndices],'), (1304, '        indices.name = (name_start, name_end);'), (1307, '        indices.value = (value_start, value_end);')]}",
    "num_lines_added": "17",
    "num_lines_deleted": "9",
    "nloc": "2478"
  },
  {
    "file_change_id": "67708705380686",
    "hash": "7500d7ddfd1c39a5fbfefd54b9014842d9862af",
    "old_path": "src/proto/h1/role.rs",
    "new_path": "src/proto/h1/role.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -129,15 +129,18 @@ impl Http1Transaction for Server {\n             MaybeUninit::uninit().assume_init()\n         };\n         {\n-            let mut headers: [httparse::Header<'_>; MAX_HEADERS] = unsafe { mem::uninitialized() };\n+            /* SAFETY: it is safe to go from MaybeUninit array to array of MaybeUninit */\n+            let mut headers: [MaybeUninit<httparse::Header<'_>>; MAX_HEADERS] = unsafe {\n+                MaybeUninit::uninit().assume_init()\n+            };\n             trace!(\n                 \"Request.parse([Header; {}], [u8; {}])\",\n                 headers.len(),\n                 buf.len()\n             );\n-            let mut req = httparse::Request::new(&mut headers);\n             let bytes = buf.as_ref();\n-            match req.parse(bytes) {\n+            let (req, status) = httparse::Request::with_uninit_headers(&mut headers, bytes);\n+            match status {\n                 Ok(httparse::Status::Complete(parsed_len)) => {\n                     trace!(\"Request.parse Complete({})\", parsed_len);\n                     len = parsed_len;\n",
    "diff_parsed": "{'added': [(132, '            /* SAFETY: it is safe to go from MaybeUninit array to array of MaybeUninit */'), (133, \"            let mut headers: [MaybeUninit<httparse::Header<'_>>; MAX_HEADERS] = unsafe {\"), (134, '                MaybeUninit::uninit().assume_init()'), (135, '            };'), (142, '            let (req, status) = httparse::Request::with_uninit_headers(&mut headers, bytes);'), (143, '            match status {')], 'deleted': [(132, \"            let mut headers: [httparse::Header<'_>; MAX_HEADERS] = unsafe { mem::uninitialized() };\"), (138, '            let mut req = httparse::Request::new(&mut headers);'), (140, '            match req.parse(bytes) {')]}",
    "num_lines_added": "6",
    "num_lines_deleted": "3",
    "nloc": "2480"
  },
  {
    "file_change_id": "256280172089561",
    "hash": "e57b06f701462547dc5eceb032b0651501ee974",
    "old_path": "src/proto/h1/role.rs",
    "new_path": "src/proto/h1/role.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -891,16 +891,17 @@ impl Http1Transaction for Client {\n                 MaybeUninit::uninit().assume_init()\n             };\n             let (len, status, reason, version, headers_len) = {\n-                let mut headers: [httparse::Header<'_>; MAX_HEADERS] =\n-                    unsafe { mem::uninitialized() };\n+                // SAFETY: We can go safely from MaybeUninit array to array of MaybeUninit\n+                let mut headers: [MaybeUninit<httparse::Header<'_>>; MAX_HEADERS] =\n+                    unsafe { MaybeUninit::uninit().assume_init() };\n                 trace!(\n                     \"Response.parse([Header; {}], [u8; {}])\",\n                     headers.len(),\n                     buf.len()\n                 );\n-                let mut res = httparse::Response::new(&mut headers);\n                 let bytes = buf.as_ref();\n-                match ctx.h1_parser_config.parse_response(&mut res, bytes) {\n+                let (res, status) = ctx.h1_parser_config.parse_response_with_uninit_headers(&mut headers, bytes);\n+                match status {\n                     Ok(httparse::Status::Complete(len)) => {\n                         trace!(\"Response.parse Complete({})\", len);\n                         let status = StatusCode::from_u16(res.code.unwrap())?;\n",
    "diff_parsed": "{'added': [(895, \"                let mut headers: [MaybeUninit<httparse::Header<'_>>; MAX_HEADERS] =\"), (896, '                    unsafe { MaybeUninit::uninit().assume_init() };'), (903, '                let (res, status) = ctx.h1_parser_config.parse_response_with_uninit_headers(&mut headers, bytes);'), (904, '                match status {')], 'deleted': [(894, \"                let mut headers: [httparse::Header<'_>; MAX_HEADERS] =\"), (895, '                    unsafe { mem::uninitialized() };'), (901, '                let mut res = httparse::Response::new(&mut headers);'), (903, '                match ctx.h1_parser_config.parse_response(&mut res, bytes) {')]}",
    "num_lines_added": "4",
    "num_lines_deleted": "4",
    "nloc": "2481"
  },
  {
    "file_change_id": "176486328971501",
    "hash": "5cf0b14921d2d21b0317307441cd6e7c36fa0da",
    "old_path": "src/proto/h1/role.rs",
    "new_path": "src/proto/h1/role.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -138,9 +138,9 @@ impl Http1Transaction for Server {\n                 headers.len(),\n                 buf.len()\n             );\n+            let mut req = httparse::Request::new(&mut []);\n             let bytes = buf.as_ref();\n-            let (req, status) = httparse::Request::with_uninit_headers(&mut headers, bytes);\n-            match status {\n+            match req.parse_with_uninit_headers(bytes, &mut headers) {\n                 Ok(httparse::Status::Complete(parsed_len)) => {\n                     trace!(\"Request.parse Complete({})\", parsed_len);\n                     len = parsed_len;\n@@ -899,9 +899,11 @@ impl Http1Transaction for Client {\n                     headers.len(),\n                     buf.len()\n                 );\n+                let mut res = httparse::Response::new(&mut []);\n                 let bytes = buf.as_ref();\n-                let (res, status) = ctx.h1_parser_config.parse_response_with_uninit_headers(&mut headers, bytes);\n-                match status {\n+                match ctx.h1_parser_config\n+                    .parse_response_with_uninit_headers(&mut res, bytes, &mut headers)\n+                {\n                     Ok(httparse::Status::Complete(len)) => {\n                         trace!(\"Response.parse Complete({})\", len);\n                         let status = StatusCode::from_u16(res.code.unwrap())?;\n",
    "diff_parsed": "{'added': [(141, '            let mut req = httparse::Request::new(&mut []);'), (143, '            match req.parse_with_uninit_headers(bytes, &mut headers) {'), (902, '                let mut res = httparse::Response::new(&mut []);'), (904, '                match ctx.h1_parser_config'), (905, '                    .parse_response_with_uninit_headers(&mut res, bytes, &mut headers)'), (906, '                {')], 'deleted': [(142, '            let (req, status) = httparse::Request::with_uninit_headers(&mut headers, bytes);'), (143, '            match status {'), (903, '                let (res, status) = ctx.h1_parser_config.parse_response_with_uninit_headers(&mut headers, bytes);'), (904, '                match status {')]}",
    "num_lines_added": "6",
    "num_lines_deleted": "4",
    "nloc": "2483"
  },
  {
    "file_change_id": "280036525338500",
    "hash": "684f2fa76d44fa2b1b063ad0443a1b0d16dfad0e",
    "old_path": "src/proto/h1/role.rs",
    "new_path": "src/proto/h1/role.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1308,36 +1308,18 @@ fn record_header_indices(\n     Ok(())\n }\n \n-// Write header names as title case. The header name is assumed to be ASCII,\n-// therefore it is trivial to convert an ASCII character from lowercase to\n-// uppercase. It is as simple as XORing the lowercase character byte with\n-// space.\n+// Write header names as title case. The header name is assumed to be ASCII.\n fn title_case(dst: &mut Vec<u8>, name: &[u8]) {\n     dst.reserve(name.len());\n \n-    let mut iter = name.iter();\n-\n-    // Uppercase the first character\n-    if let Some(c) = iter.next() {\n-        if *c >= b'a' && *c <= b'z' {\n-            dst.push(*c ^ b' ');\n-        } else {\n-            dst.push(*c);\n-        }\n-    }\n-\n-    while let Some(c) = iter.next() {\n-        dst.push(*c);\n-\n-        if *c == b'-' {\n-            if let Some(c) = iter.next() {\n-                if *c >= b'a' && *c <= b'z' {\n-                    dst.push(*c ^ b' ');\n-                } else {\n-                    dst.push(*c);\n-                }\n-            }\n+    // Ensure first character is uppercased\n+    let mut prev = b'-';\n+    for &(mut c) in name {\n+        if prev == b'-' {\n+            c.make_ascii_uppercase();\n         }\n+        dst.push(c);\n+        prev = c;\n     }\n }\n \n@@ -2316,6 +2298,8 @@ mod tests {\n             .insert(\"content-length\", HeaderValue::from_static(\"10\"));\n         head.headers\n             .insert(\"content-type\", HeaderValue::from_static(\"application/json\"));\n+        head.headers\n+            .insert(\"weird--header\", HeaderValue::from_static(\"\"));\n \n         let mut vec = Vec::new();\n         Server::encode(\n@@ -2331,7 +2315,7 @@ mod tests {\n         .unwrap();\n \n         let expected_response =\n-            b\"HTTP/1.1 200 OK\\r\\nContent-Length: 10\\r\\nContent-Type: application/json\\r\\n\";\n+            b\"HTTP/1.1 200 OK\\r\\nContent-Length: 10\\r\\nContent-Type: application/json\\r\\nWeird--Header: \\r\\n\";\n \n         assert_eq!(&vec[..expected_response.len()], &expected_response[..]);\n     }\n",
    "diff_parsed": "{'added': [(1316, \"    let mut prev = b'-';\"), (1317, '    for &(mut c) in name {'), (1318, \"        if prev == b'-' {\"), (1319, '            c.make_ascii_uppercase();'), (1321, '        dst.push(c);'), (1322, '        prev = c;'), (2301, '        head.headers'), (2302, '            .insert(\"weird--header\", HeaderValue::from_static(\"\"));'), (2318, '            b\"HTTP/1.1 200 OK\\\\r\\\\nContent-Length: 10\\\\r\\\\nContent-Type: application/json\\\\r\\\\nWeird--Header: \\\\r\\\\n\";')], 'deleted': [(1318, '    let mut iter = name.iter();'), (1321, '    if let Some(c) = iter.next() {'), (1322, \"        if *c >= b'a' && *c <= b'z' {\"), (1323, \"            dst.push(*c ^ b' ');\"), (1324, '        } else {'), (1325, '            dst.push(*c);'), (1326, '        }'), (1327, '    }'), (1329, '    while let Some(c) = iter.next() {'), (1330, '        dst.push(*c);'), (1332, \"        if *c == b'-' {\"), (1333, '            if let Some(c) = iter.next() {'), (1334, \"                if *c >= b'a' && *c <= b'z' {\"), (1335, \"                    dst.push(*c ^ b' ');\"), (1336, '                } else {'), (1337, '                    dst.push(*c);'), (1338, '                }'), (1339, '            }'), (2334, '            b\"HTTP/1.1 200 OK\\\\r\\\\nContent-Length: 10\\\\r\\\\nContent-Type: application/json\\\\r\\\\n\";')]}",
    "num_lines_added": "9",
    "num_lines_deleted": "19",
    "nloc": "2527"
  },
  {
    "file_change_id": "168842320939340",
    "hash": "df65b33f8a9dbd06b95b0a6af7521f0d4723354",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1135,7 +1135,7 @@ impl<K: Hash + Eq, V, S: BuildHasher> IntoIterator for LinkedHashMap<K, V, S> {\n         }\n         self.clear_free_list();\n         // drop the HashMap but not the LinkedHashMap\n-        self.map = unsafe { mem::uninitialized() };\n+        unsafe { ptr::drop_in_place(&mut self.map); }\n         mem::forget(self);\n \n         IntoIter {\n",
    "diff_parsed": "{'added': [(1138, '        unsafe { ptr::drop_in_place(&mut self.map); }')], 'deleted': [(1138, '        self.map = unsafe { mem::uninitialized() };')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "927"
  },
  {
    "file_change_id": "51650506781063",
    "hash": "a83ccecf515b5273e4dd0306c1b9f6dcb7daf96",
    "old_path": "lib.rs",
    "new_path": "lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -63,7 +63,7 @@ use std::iter::{repeat, FromIterator, IntoIterator};\n #[cfg(feature = \"serde\")]\n use std::marker::PhantomData;\n use std::mem;\n-use std::mem::ManuallyDrop;\n+use std::mem::MaybeUninit;\n use std::ops;\n use std::ptr;\n use std::slice;\n@@ -280,29 +280,27 @@ impl<'a, T: 'a> Drop for Drain<'a, T> {\n \n #[cfg(feature = \"union\")]\n union SmallVecData<A: Array> {\n-    inline: ManuallyDrop<A>,\n+    inline: MaybeUninit<A>,\n     heap: (*mut A::Item, usize),\n }\n \n #[cfg(feature = \"union\")]\n impl<A: Array> SmallVecData<A> {\n     #[inline]\n-    unsafe fn inline(&self) -> &A {\n-        &self.inline\n+    unsafe fn inline(&self) -> *const A::Item {\n+        self.inline.as_ptr() as *const A::Item\n     }\n     #[inline]\n-    unsafe fn inline_mut(&mut self) -> &mut A {\n-        &mut self.inline\n+    unsafe fn inline_mut(&mut self) -> *mut A::Item {\n+        self.inline.as_mut_ptr() as *mut A::Item\n     }\n     #[inline]\n-    fn from_inline(inline: A) -> SmallVecData<A> {\n-        SmallVecData {\n-            inline: ManuallyDrop::new(inline),\n-        }\n+    fn from_inline(inline: MaybeUninit<A>) -> SmallVecData<A> {\n+        SmallVecData { inline }\n     }\n     #[inline]\n-    unsafe fn into_inline(self) -> A {\n-        ManuallyDrop::into_inner(self.inline)\n+    unsafe fn into_inline(self) -> MaybeUninit<A> {\n+        self.inline\n     }\n     #[inline]\n     unsafe fn heap(&self) -> (*mut A::Item, usize) {\n@@ -320,34 +318,34 @@ impl<A: Array> SmallVecData<A> {\n \n #[cfg(not(feature = \"union\"))]\n enum SmallVecData<A: Array> {\n-    Inline(ManuallyDrop<A>),\n+    Inline(MaybeUninit<A>),\n     Heap((*mut A::Item, usize)),\n }\n \n #[cfg(not(feature = \"union\"))]\n impl<A: Array> SmallVecData<A> {\n     #[inline]\n-    unsafe fn inline(&self) -> &A {\n+    unsafe fn inline(&self) -> *const A::Item {\n         match *self {\n-            SmallVecData::Inline(ref a) => a,\n+            SmallVecData::Inline(ref a) => a.as_ptr() as *const A::Item,\n             _ => debug_unreachable!(),\n         }\n     }\n     #[inline]\n-    unsafe fn inline_mut(&mut self) -> &mut A {\n+    unsafe fn inline_mut(&mut self) -> *mut A::Item {\n         match *self {\n-            SmallVecData::Inline(ref mut a) => a,\n+            SmallVecData::Inline(ref mut a) => a.as_mut_ptr() as *mut A::Item,\n             _ => debug_unreachable!(),\n         }\n     }\n     #[inline]\n-    fn from_inline(inline: A) -> SmallVecData<A> {\n-        SmallVecData::Inline(ManuallyDrop::new(inline))\n+    fn from_inline(inline: MaybeUninit<A>) -> SmallVecData<A> {\n+        SmallVecData::Inline(inline)\n     }\n     #[inline]\n-    unsafe fn into_inline(self) -> A {\n+    unsafe fn into_inline(self) -> MaybeUninit<A> {\n         match self {\n-            SmallVecData::Inline(a) => ManuallyDrop::into_inner(a),\n+            SmallVecData::Inline(a) => a,\n             _ => debug_unreachable!(),\n         }\n     }\n@@ -412,11 +410,15 @@ impl<A: Array> SmallVec<A> {\n     /// Construct an empty vector\n     #[inline]\n     pub fn new() -> SmallVec<A> {\n-        unsafe {\n-            SmallVec {\n-                capacity: 0,\n-                data: SmallVecData::from_inline(mem::uninitialized()),\n-            }\n+        // Try to detect invalid custom implementations of `Array`. Hopefuly,\n+        // this check should be optimized away entirely for valid ones.\n+        assert!(\n+            mem::size_of::<A>() == A::size() * mem::size_of::<A::Item>()\n+                && mem::align_of::<A>() >= mem::align_of::<A::Item>()\n+        );\n+        SmallVec {\n+            capacity: 0,\n+            data: SmallVecData::from_inline(MaybeUninit::uninit()),\n         }\n     }\n \n@@ -456,10 +458,10 @@ impl<A: Array> SmallVec<A> {\n     pub fn from_vec(mut vec: Vec<A::Item>) -> SmallVec<A> {\n         if vec.capacity() <= A::size() {\n             unsafe {\n-                let mut data = SmallVecData::<A>::from_inline(mem::uninitialized());\n+                let mut data = SmallVecData::<A>::from_inline(MaybeUninit::uninit());\n                 let len = vec.len();\n                 vec.set_len(0);\n-                ptr::copy_nonoverlapping(vec.as_ptr(), data.inline_mut().ptr_mut(), len);\n+                ptr::copy_nonoverlapping(vec.as_ptr(), data.inline_mut(), len);\n \n                 SmallVec {\n                     capacity: len,\n@@ -492,7 +494,7 @@ impl<A: Array> SmallVec<A> {\n     pub fn from_buf(buf: A) -> SmallVec<A> {\n         SmallVec {\n             capacity: A::size(),\n-            data: SmallVecData::from_inline(buf),\n+            data: SmallVecData::from_inline(MaybeUninit::new(buf)),\n         }\n     }\n \n@@ -511,7 +513,7 @@ impl<A: Array> SmallVec<A> {\n     #[inline]\n     pub fn from_buf_and_len(buf: A, len: usize) -> SmallVec<A> {\n         assert!(len <= A::size());\n-        unsafe { SmallVec::from_buf_and_len_unchecked(buf, len) }\n+        unsafe { SmallVec::from_buf_and_len_unchecked(MaybeUninit::new(buf), len) }\n     }\n \n     /// Constructs a new `SmallVec` on the stack from an `A` without\n@@ -520,16 +522,17 @@ impl<A: Array> SmallVec<A> {\n     ///\n     /// ```rust\n     /// use smallvec::SmallVec;\n+    /// use std::mem::MaybeUninit;\n     ///\n     /// let buf = [1, 2, 3, 4, 5, 0, 0, 0];\n     /// let small_vec: SmallVec<_> = unsafe {\n-    ///     SmallVec::from_buf_and_len_unchecked(buf, 5)\n+    ///     SmallVec::from_buf_and_len_unchecked(MaybeUninit::new(buf), 5)\n     /// };\n     ///\n     /// assert_eq!(&*small_vec, &[1, 2, 3, 4, 5]);\n     /// ```\n     #[inline]\n-    pub unsafe fn from_buf_and_len_unchecked(buf: A, len: usize) -> SmallVec<A> {\n+    pub unsafe fn from_buf_and_len_unchecked(buf: MaybeUninit<A>, len: usize) -> SmallVec<A> {\n         SmallVec {\n             capacity: len,\n             data: SmallVecData::from_inline(buf),\n@@ -579,7 +582,7 @@ impl<A: Array> SmallVec<A> {\n                 let (ptr, len) = self.data.heap();\n                 (ptr, len, self.capacity)\n             } else {\n-                (self.data.inline().ptr(), self.capacity, A::size())\n+                (self.data.inline(), self.capacity, A::size())\n             }\n         }\n     }\n@@ -592,11 +595,7 @@ impl<A: Array> SmallVec<A> {\n                 let &mut (ptr, ref mut len_ptr) = self.data.heap_mut();\n                 (ptr, len_ptr, self.capacity)\n             } else {\n-                (\n-                    self.data.inline_mut().ptr_mut(),\n-                    &mut self.capacity,\n-                    A::size(),\n-                )\n+                (self.data.inline_mut(), &mut self.capacity, A::size())\n             }\n         }\n     }\n@@ -663,8 +662,8 @@ impl<A: Array> SmallVec<A> {\n                 if unspilled {\n                     return;\n                 }\n-                self.data = SmallVecData::from_inline(mem::uninitialized());\n-                ptr::copy_nonoverlapping(ptr, self.data.inline_mut().ptr_mut(), len);\n+                self.data = SmallVecData::from_inline(MaybeUninit::uninit());\n+                ptr::copy_nonoverlapping(ptr, self.data.inline_mut(), len);\n                 self.capacity = len;\n             } else if new_cap != cap {\n                 let mut vec = Vec::with_capacity(new_cap);\n@@ -730,8 +729,8 @@ impl<A: Array> SmallVec<A> {\n         if self.inline_size() >= len {\n             unsafe {\n                 let (ptr, len) = self.data.heap();\n-                self.data = SmallVecData::from_inline(mem::uninitialized());\n-                ptr::copy_nonoverlapping(ptr, self.data.inline_mut().ptr_mut(), len);\n+                self.data = SmallVecData::from_inline(MaybeUninit::uninit());\n+                ptr::copy_nonoverlapping(ptr, self.data.inline_mut(), len);\n                 deallocate(ptr, self.capacity);\n                 self.capacity = len;\n             }\n@@ -900,7 +899,7 @@ impl<A: Array> SmallVec<A> {\n             unsafe {\n                 let data = ptr::read(&self.data);\n                 mem::forget(self);\n-                Ok(data.into_inline())\n+                Ok(data.into_inline().assume_init())\n             }\n         }\n     }\n@@ -1062,8 +1061,12 @@ where\n             SmallVec {\n                 capacity: len,\n                 data: SmallVecData::from_inline(unsafe {\n-                    let mut data: A = mem::uninitialized();\n-                    ptr::copy_nonoverlapping(slice.as_ptr(), data.ptr_mut(), len);\n+                    let mut data: MaybeUninit<A> = MaybeUninit::uninit();\n+                    ptr::copy_nonoverlapping(\n+                        slice.as_ptr(),\n+                        data.as_mut_ptr() as *mut A::Item,\n+                        len,\n+                    );\n                     data\n                 }),\n             }\n@@ -1603,10 +1606,6 @@ pub unsafe trait Array {\n     type Item;\n     /// Returns the number of items the array can hold.\n     fn size() -> usize;\n-    /// Returns a pointer to the first element of the array.\n-    fn ptr(&self) -> *const Self::Item;\n-    /// Returns a mutable pointer to the first element of the array.\n-    fn ptr_mut(&mut self) -> *mut Self::Item;\n }\n \n /// Set the length of the vec when the `SetLenOnDrop` value goes out of scope.\n@@ -1650,8 +1649,6 @@ macro_rules! impl_array(\n             unsafe impl<T> Array for [T; $size] {\n                 type Item = T;\n                 fn size() -> usize { $size }\n-                fn ptr(&self) -> *const T { self.as_ptr() }\n-                fn ptr_mut(&mut self) -> *mut T { self.as_mut_ptr() }\n             }\n         )+\n     }\n@@ -1985,7 +1982,7 @@ mod tests {\n         );\n     }\n \n-    #[cfg(feature = \"std\")]\n+    #[cfg(all(feature = \"std\", not(miri)))] // Miri currently does not support unwinding\n     #[test]\n     // https://github.com/servo/rust-smallvec/issues/96\n     fn test_insert_many_panic() {\n",
    "diff_parsed": "{'added': [(66, 'use std::mem::MaybeUninit;'), (283, '    inline: MaybeUninit<A>,'), (290, '    unsafe fn inline(&self) -> *const A::Item {'), (291, '        self.inline.as_ptr() as *const A::Item'), (294, '    unsafe fn inline_mut(&mut self) -> *mut A::Item {'), (295, '        self.inline.as_mut_ptr() as *mut A::Item'), (298, '    fn from_inline(inline: MaybeUninit<A>) -> SmallVecData<A> {'), (299, '        SmallVecData { inline }'), (302, '    unsafe fn into_inline(self) -> MaybeUninit<A> {'), (303, '        self.inline'), (321, '    Inline(MaybeUninit<A>),'), (328, '    unsafe fn inline(&self) -> *const A::Item {'), (330, '            SmallVecData::Inline(ref a) => a.as_ptr() as *const A::Item,'), (335, '    unsafe fn inline_mut(&mut self) -> *mut A::Item {'), (337, '            SmallVecData::Inline(ref mut a) => a.as_mut_ptr() as *mut A::Item,'), (342, '    fn from_inline(inline: MaybeUninit<A>) -> SmallVecData<A> {'), (343, '        SmallVecData::Inline(inline)'), (346, '    unsafe fn into_inline(self) -> MaybeUninit<A> {'), (348, '            SmallVecData::Inline(a) => a,'), (415, '        assert!('), (416, '            mem::size_of::<A>() == A::size() * mem::size_of::<A::Item>()'), (417, '                && mem::align_of::<A>() >= mem::align_of::<A::Item>()'), (418, '        );'), (419, '        SmallVec {'), (420, '            capacity: 0,'), (421, '            data: SmallVecData::from_inline(MaybeUninit::uninit()),'), (461, '                let mut data = SmallVecData::<A>::from_inline(MaybeUninit::uninit());'), (464, '                ptr::copy_nonoverlapping(vec.as_ptr(), data.inline_mut(), len);'), (497, '            data: SmallVecData::from_inline(MaybeUninit::new(buf)),'), (516, '        unsafe { SmallVec::from_buf_and_len_unchecked(MaybeUninit::new(buf), len) }'), (535, '    pub unsafe fn from_buf_and_len_unchecked(buf: MaybeUninit<A>, len: usize) -> SmallVec<A> {'), (585, '                (self.data.inline(), self.capacity, A::size())'), (598, '                (self.data.inline_mut(), &mut self.capacity, A::size())'), (665, '                self.data = SmallVecData::from_inline(MaybeUninit::uninit());'), (666, '                ptr::copy_nonoverlapping(ptr, self.data.inline_mut(), len);'), (732, '                self.data = SmallVecData::from_inline(MaybeUninit::uninit());'), (733, '                ptr::copy_nonoverlapping(ptr, self.data.inline_mut(), len);'), (902, '                Ok(data.into_inline().assume_init())'), (1064, '                    let mut data: MaybeUninit<A> = MaybeUninit::uninit();'), (1065, '                    ptr::copy_nonoverlapping('), (1066, '                        slice.as_ptr(),'), (1067, '                        data.as_mut_ptr() as *mut A::Item,'), (1068, '                        len,'), (1069, '                    );'), (1985, '    #[cfg(all(feature = \"std\", not(miri)))] // Miri currently does not support unwinding')], 'deleted': [(66, 'use std::mem::ManuallyDrop;'), (283, '    inline: ManuallyDrop<A>,'), (290, '    unsafe fn inline(&self) -> &A {'), (291, '        &self.inline'), (294, '    unsafe fn inline_mut(&mut self) -> &mut A {'), (295, '        &mut self.inline'), (298, '    fn from_inline(inline: A) -> SmallVecData<A> {'), (299, '        SmallVecData {'), (300, '            inline: ManuallyDrop::new(inline),'), (301, '        }'), (304, '    unsafe fn into_inline(self) -> A {'), (305, '        ManuallyDrop::into_inner(self.inline)'), (323, '    Inline(ManuallyDrop<A>),'), (330, '    unsafe fn inline(&self) -> &A {'), (332, '            SmallVecData::Inline(ref a) => a,'), (337, '    unsafe fn inline_mut(&mut self) -> &mut A {'), (339, '            SmallVecData::Inline(ref mut a) => a,'), (344, '    fn from_inline(inline: A) -> SmallVecData<A> {'), (345, '        SmallVecData::Inline(ManuallyDrop::new(inline))'), (348, '    unsafe fn into_inline(self) -> A {'), (350, '            SmallVecData::Inline(a) => ManuallyDrop::into_inner(a),'), (415, '        unsafe {'), (416, '            SmallVec {'), (417, '                capacity: 0,'), (418, '                data: SmallVecData::from_inline(mem::uninitialized()),'), (419, '            }'), (459, '                let mut data = SmallVecData::<A>::from_inline(mem::uninitialized());'), (462, '                ptr::copy_nonoverlapping(vec.as_ptr(), data.inline_mut().ptr_mut(), len);'), (495, '            data: SmallVecData::from_inline(buf),'), (514, '        unsafe { SmallVec::from_buf_and_len_unchecked(buf, len) }'), (532, '    pub unsafe fn from_buf_and_len_unchecked(buf: A, len: usize) -> SmallVec<A> {'), (582, '                (self.data.inline().ptr(), self.capacity, A::size())'), (595, '                ('), (596, '                    self.data.inline_mut().ptr_mut(),'), (597, '                    &mut self.capacity,'), (598, '                    A::size(),'), (599, '                )'), (666, '                self.data = SmallVecData::from_inline(mem::uninitialized());'), (667, '                ptr::copy_nonoverlapping(ptr, self.data.inline_mut().ptr_mut(), len);'), (733, '                self.data = SmallVecData::from_inline(mem::uninitialized());'), (734, '                ptr::copy_nonoverlapping(ptr, self.data.inline_mut().ptr_mut(), len);'), (903, '                Ok(data.into_inline())'), (1065, '                    let mut data: A = mem::uninitialized();'), (1066, '                    ptr::copy_nonoverlapping(slice.as_ptr(), data.ptr_mut(), len);'), (1607, '    fn ptr(&self) -> *const Self::Item;'), (1609, '    fn ptr_mut(&mut self) -> *mut Self::Item;'), (1653, '                fn ptr(&self) -> *const T { self.as_ptr() }'), (1654, '                fn ptr_mut(&mut self) -> *mut T { self.as_mut_ptr() }'), (1988, '    #[cfg(feature = \"std\")]')]}",
    "num_lines_added": "45",
    "num_lines_deleted": "49",
    "nloc": "1961"
  },
  {
    "file_change_id": "224149053670860",
    "hash": "390a7b1049fa5ba1d627feaef2a1629e0e7826b",
    "old_path": "rand_core/src/le.rs",
    "new_path": "rand_core/src/le.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -16,7 +16,7 @@ use core::convert::TryInto;\n /// Reads unsigned 32 bit integers from `src` into `dst`.\n #[inline]\n pub fn read_u32_into(src: &[u8], dst: &mut [u32]) {\n-    assert!(4 * src.len() >= dst.len());\n+    assert!(src.len() >= 4 * dst.len());\n     for (out, chunk) in dst.iter_mut().zip(src.chunks_exact(4)) {\n         *out = u32::from_le_bytes(chunk.try_into().unwrap());\n     }\n@@ -25,7 +25,7 @@ pub fn read_u32_into(src: &[u8], dst: &mut [u32]) {\n /// Reads unsigned 64 bit integers from `src` into `dst`.\n #[inline]\n pub fn read_u64_into(src: &[u8], dst: &mut [u64]) {\n-    assert!(8 * src.len() >= dst.len());\n+    assert!(src.len() >= 8 * dst.len());\n     for (out, chunk) in dst.iter_mut().zip(src.chunks_exact(8)) {\n         *out = u64::from_le_bytes(chunk.try_into().unwrap());\n     }\n",
    "diff_parsed": "{'added': [(19, '    assert!(src.len() >= 4 * dst.len());'), (28, '    assert!(src.len() >= 8 * dst.len());')], 'deleted': [(19, '    assert!(4 * src.len() >= dst.len());'), (28, '    assert!(8 * src.len() >= dst.len());')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "34"
  },
  {
    "file_change_id": "1584003648461",
    "hash": "a6d7cdd2221ae5087fa354a100733b2cc4fd008",
    "old_path": "src/snip.rs",
    "new_path": "src/snip.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -13,7 +13,7 @@ pub(crate) fn preamble_skipcount<R: Read>(reader: &mut R, n_preamble_rows: usize\n     let mut skipcount = 0;\n     loop {\n         let cap = 1 << 12;\n-        let mut buffer = Vec::with_capacity(cap);\n+        let mut buffer = vec![0; cap];\n         unsafe { buffer.set_len(cap); }\n         let n_read = reader.read(&mut buffer)?;\n         let mut crlf_pos = 0;\n",
    "diff_parsed": "{'added': [(16, '        let mut buffer = vec![0; cap];')], 'deleted': [(16, '        let mut buffer = Vec::with_capacity(cap);')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "42"
  },
  {
    "file_change_id": "156903777009113",
    "hash": "4b8426b89b861d9bea20e126576b0febb9d1351",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1781,7 +1781,8 @@ impl<'a> Builder<'a> {\n                 removed.push(node);\n                 continue;\n             }\n-            let pass = self.clean_child(&mut node, url_base);\n+            let pass_clean = self.clean_child(&mut node, url_base);\n+            let pass = pass_clean && self.check_expected_namespace(&parent, &node);\n             if pass {\n                 self.adjust_node_attributes(&mut node, &link_rel, url_base, self.id_prefix);\n                 dom.append(&parent.clone(), NodeOrText::AppendNode(node.clone()));\n@@ -1892,6 +1893,125 @@ impl<'a> Builder<'a> {\n         }\n     }\n \n+    // Check for unexpected namespace changes.\n+    //\n+    // The issue happens if developers added to the list of allowed tags any\n+    // tag which is parsed in RCDATA state, PLAINTEXT state or RCDATA state,\n+    // that is:\n+    //\n+    // * title\n+    // * textarea\n+    // * style\n+    // * xmp\n+    // * iframe\n+    // * noembed\n+    // * noframes\n+    // * plaintext\n+    //\n+    // An example in the wild is Plume, that allows iframe [1].  So in next\n+    // examples I'll assume the following policy:\n+    //\n+    //     Builder::new()\n+    //        .add_tags(&[\"iframe\"])\n+    //\n+    // In HTML namespace `<iframe>` is parsed specially; that is, its content is\n+    // treated as text. For instance, the following html:\n+    //\n+    //     <iframe><a>test\n+    //\n+    // Is parsed into the following DOM tree:\n+    //\n+    //     iframe\n+    //     \u2514\u2500 #text: <a>test\n+    //\n+    // So iframe cannot have any children other than a text node.\n+    //\n+    // The same is not true, though, in \"foreign content\"; that is, within\n+    // <svg> or <math> tags. The following html:\n+    //\n+    //     <svg><iframe><a>test\n+    //\n+    // is parsed differently:\n+    //\n+    //    svg\n+    //    \u2514\u2500 iframe\n+    //       \u2514\u2500 a\n+    //          \u2514\u2500 #text: test\n+    //\n+    // So in SVG namespace iframe can have children.\n+    //\n+    // Ammonia disallows <svg> but it keeps its content after deleting it. And\n+    // the parser internally keeps track of the namespace of the element. So\n+    // assume we have the following snippet:\n+    //\n+    //     <svg><iframe><a title=\"</iframe><img src onerror=alert(1)>\">test\n+    //\n+    // It is parsed into:\n+    //\n+    //     svg\n+    //     \u2514\u2500 iframe\n+    //        \u2514\u2500 a title=\"</iframe><img src onerror=alert(1)>\"\n+    //           \u2514\u2500 #text: test\n+    //\n+    // This DOM tree is harmless from ammonia point of view because the piece\n+    // of code that looks like XSS is in a title attribute. Hence, the\n+    // resulting \"safe\" HTML from ammonia would be:\n+    //\n+    //     <iframe><a title=\"</iframe><img src onerror=alert(1)>\" rel=\"noopener\n+    // noreferrer\">test</a></iframe>\n+    //\n+    // However, at this point, the information about namespace is lost, which\n+    // means that the browser will parse this snippet into:\n+    //\n+    //     \u251c\u2500 iframe\n+    //     \u2502  \u2514\u2500 #text: <a title=\"\n+    //     \u251c\u2500 img src=\"\" onerror=\"alert(1)\"\n+    //     \u2514\u2500 #text: \" rel=\"noopener noreferrer\">test\n+    //\n+    // Leading to XSS.\n+    //\n+    // To solve this issue, check for unexpected namespace switches after cleanup.\n+    // Elements which change namespace at an unexpected point are removed.\n+    // This function returns `true` if `child` should be kept, and `false` if it\n+    // should be removed.\n+    fn check_expected_namespace(&self, parent: &Handle, child: &Handle) -> bool {\n+        let (parent, child) = match (&parent.data, &child.data) {\n+            (NodeData::Element { name: pn, .. }, NodeData::Element { name: cn, .. }) => (pn, cn),\n+            _ => return true,\n+        };\n+        // The only way to switch from html to svg is with the <svg> tag\n+        if parent.ns == ns!(html) && child.ns == ns!(svg) {\n+            child.local == local_name!(\"svg\")\n+        // The only way to switch from html to mathml is with the <math> tag\n+        } else if parent.ns == ns!(html) && child.ns == ns!(mathml) {\n+            child.local == local_name!(\"math\")\n+        // The only way to switch from mathml to svg/html is with a text integration point\n+        } else if parent.ns == ns!(mathml) && child.ns != ns!(mathml) {\n+            // https://html.spec.whatwg.org/#mathml\n+            matches!(\n+                &*parent.local,\n+                \"mi\" | \"mo\" | \"mn\" | \"ms\" | \"mtext\" | \"annotation-xml\"\n+            )\n+        // The only way to switch from svg to mathml/html is with an html integration point\n+        } else if parent.ns == ns!(svg) && child.ns != ns!(svg) {\n+            // https://html.spec.whatwg.org/#svg-0\n+            matches!(&*parent.local, \"foreignObject\")\n+        } else if child.ns == ns!(svg) {\n+            is_svg_tag(&*child.local)\n+        } else if child.ns == ns!(mathml) {\n+            is_mathml_tag(&*child.local)\n+        } else if child.ns == ns!(html) {\n+            (!is_svg_tag(&*child.local) && !is_mathml_tag(&*child.local))\n+                || matches!(\n+                    &*child.local,\n+                    \"title\" | \"style\" | \"font\" | \"a\" | \"script\" | \"span\"\n+                )\n+        } else {\n+            // There are no other supported ways to switch namespace\n+            parent.ns == child.ns\n+        }\n+    }\n+\n     /// Add and transform special-cased attributes and elements.\n     ///\n     /// This function handles:\n@@ -2050,6 +2170,280 @@ fn is_url_attr(element: &str, attr: &str) -> bool {\n         || (element == \"video\" && attr == \"poster\")\n }\n \n+/// Given an element name, check if it's SVG\n+fn is_svg_tag(element: &str) -> bool {\n+    // https://svgwg.org/svg2-draft/eltindex.html\n+    match element {\n+        \"a\"\n+        | \"animate\"\n+        | \"animateMotion\"\n+        | \"animateTransform\"\n+        | \"circle\"\n+        | \"clipPath\"\n+        | \"defs\"\n+        | \"desc\"\n+        | \"discard\"\n+        | \"ellipse\"\n+        | \"feBlend\"\n+        | \"feColorMatrix\"\n+        | \"feComponentTransfer\"\n+        | \"feComposite\"\n+        | \"feConvolveMatrix\"\n+        | \"feDiffuseLighting\"\n+        | \"feDisplacementMap\"\n+        | \"feDistantLight\"\n+        | \"feDropShadow\"\n+        | \"feFlood\"\n+        | \"feFuncA\"\n+        | \"feFuncB\"\n+        | \"feFuncG\"\n+        | \"feFuncR\"\n+        | \"feGaussianBlur\"\n+        | \"feImage\"\n+        | \"feMerge\"\n+        | \"feMergeNode\"\n+        | \"feMorphology\"\n+        | \"feOffset\"\n+        | \"fePointLight\"\n+        | \"feSpecularLighting\"\n+        | \"feSpotLight\"\n+        | \"feTile\"\n+        | \"feTurbulence\"\n+        | \"filter\"\n+        | \"foreignObject\"\n+        | \"g\"\n+        | \"image\"\n+        | \"line\"\n+        | \"linearGradient\"\n+        | \"marker\"\n+        | \"mask\"\n+        | \"metadata\"\n+        | \"mpath\"\n+        | \"path\"\n+        | \"pattern\"\n+        | \"polygon\"\n+        | \"polyline\"\n+        | \"radialGradient\"\n+        | \"rect\"\n+        | \"script\"\n+        | \"set\"\n+        | \"stop\"\n+        | \"style\"\n+        | \"svg\"\n+        | \"switch\"\n+        | \"symbol\"\n+        | \"text\"\n+        | \"textPath\"\n+        | \"title\"\n+        | \"tspan\"\n+        | \"use\"\n+        | \"view\" => true,\n+        _ => false,\n+    }\n+}\n+\n+/// Given an element name, check if it's Math\n+fn is_mathml_tag(element: &str) -> bool {\n+    // https://svgwg.org/svg2-draft/eltindex.html\n+    match element {\n+        \"abs\"\n+        | \"and\"\n+        | \"annotation\"\n+        | \"annotation-xml\"\n+        | \"apply\"\n+        | \"approx\"\n+        | \"arccos\"\n+        | \"arccosh\"\n+        | \"arccot\"\n+        | \"arccoth\"\n+        | \"arccsc\"\n+        | \"arccsch\"\n+        | \"arcsec\"\n+        | \"arcsech\"\n+        | \"arcsin\"\n+        | \"arcsinh\"\n+        | \"arctan\"\n+        | \"arctanh\"\n+        | \"arg\"\n+        | \"bind\"\n+        | \"bvar\"\n+        | \"card\"\n+        | \"cartesianproduct\"\n+        | \"cbytes\"\n+        | \"ceiling\"\n+        | \"cerror\"\n+        | \"ci\"\n+        | \"cn\"\n+        | \"codomain\"\n+        | \"complexes\"\n+        | \"compose\"\n+        | \"condition\"\n+        | \"conjugate\"\n+        | \"cos\"\n+        | \"cosh\"\n+        | \"cot\"\n+        | \"coth\"\n+        | \"cs\"\n+        | \"csc\"\n+        | \"csch\"\n+        | \"csymbol\"\n+        | \"curl\"\n+        | \"declare\"\n+        | \"degree\"\n+        | \"determinant\"\n+        | \"diff\"\n+        | \"divergence\"\n+        | \"divide\"\n+        | \"domain\"\n+        | \"domainofapplication\"\n+        | \"emptyset\"\n+        | \"eq\"\n+        | \"equivalent\"\n+        | \"eulergamma\"\n+        | \"exists\"\n+        | \"exp\"\n+        | \"exponentiale\"\n+        | \"factorial\"\n+        | \"factorof\"\n+        | \"false\"\n+        | \"floor\"\n+        | \"fn\"\n+        | \"forall\"\n+        | \"gcd\"\n+        | \"geq\"\n+        | \"grad\"\n+        | \"gt\"\n+        | \"ident\"\n+        | \"image\"\n+        | \"imaginary\"\n+        | \"imaginaryi\"\n+        | \"implies\"\n+        | \"in\"\n+        | \"infinity\"\n+        | \"int\"\n+        | \"integers\"\n+        | \"intersect\"\n+        | \"interval\"\n+        | \"inverse\"\n+        | \"lambda\"\n+        | \"laplacian\"\n+        | \"lcm\"\n+        | \"leq\"\n+        | \"limit\"\n+        | \"list\"\n+        | \"ln\"\n+        | \"log\"\n+        | \"logbase\"\n+        | \"lowlimit\"\n+        | \"lt\"\n+        | \"maction\"\n+        | \"maligngroup\"\n+        | \"malignmark\"\n+        | \"math\"\n+        | \"matrix\"\n+        | \"matrixrow\"\n+        | \"max\"\n+        | \"mean\"\n+        | \"median\"\n+        | \"menclose\"\n+        | \"merror\"\n+        | \"mfenced\"\n+        | \"mfrac\"\n+        | \"mglyph\"\n+        | \"mi\"\n+        | \"min\"\n+        | \"minus\"\n+        | \"mlabeledtr\"\n+        | \"mlongdiv\"\n+        | \"mmultiscripts\"\n+        | \"mn\"\n+        | \"mo\"\n+        | \"mode\"\n+        | \"moment\"\n+        | \"momentabout\"\n+        | \"mover\"\n+        | \"mpadded\"\n+        | \"mphantom\"\n+        | \"mprescripts\"\n+        | \"mroot\"\n+        | \"mrow\"\n+        | \"ms\"\n+        | \"mscarries\"\n+        | \"mscarry\"\n+        | \"msgroup\"\n+        | \"msline\"\n+        | \"mspace\"\n+        | \"msqrt\"\n+        | \"msrow\"\n+        | \"mstack\"\n+        | \"mstyle\"\n+        | \"msub\"\n+        | \"msubsup\"\n+        | \"msup\"\n+        | \"mtable\"\n+        | \"mtd\"\n+        | \"mtext\"\n+        | \"mtr\"\n+        | \"munder\"\n+        | \"munderover\"\n+        | \"naturalnumbers\"\n+        | \"neq\"\n+        | \"none\"\n+        | \"not\"\n+        | \"notanumber\"\n+        | \"notin\"\n+        | \"notprsubset\"\n+        | \"notsubset\"\n+        | \"or\"\n+        | \"otherwise\"\n+        | \"outerproduct\"\n+        | \"partialdiff\"\n+        | \"pi\"\n+        | \"piece\"\n+        | \"piecewise\"\n+        | \"plus\"\n+        | \"power\"\n+        | \"primes\"\n+        | \"product\"\n+        | \"prsubset\"\n+        | \"quotient\"\n+        | \"rationals\"\n+        | \"real\"\n+        | \"reals\"\n+        | \"reln\"\n+        | \"rem\"\n+        | \"root\"\n+        | \"scalarproduct\"\n+        | \"sdev\"\n+        | \"sec\"\n+        | \"sech\"\n+        | \"selector\"\n+        | \"semantics\"\n+        | \"sep\"\n+        | \"set\"\n+        | \"setdiff\"\n+        | \"share\"\n+        | \"sin\"\n+        | \"sinh\"\n+        | \"span\"\n+        | \"subset\"\n+        | \"sum\"\n+        | \"tan\"\n+        | \"tanh\"\n+        | \"tendsto\"\n+        | \"times\"\n+        | \"transpose\"\n+        | \"true\"\n+        | \"union\"\n+        | \"uplimit\"\n+        | \"variance\"\n+        | \"vector\"\n+        | \"vectorproduct\"\n+        | \"xor\" => true,\n+        _ => false,\n+    }\n+}\n+\n fn is_url_relative(url: &str) -> bool {\n     matches!(\n         Url::parse(url),\n@@ -2479,7 +2873,8 @@ mod test {\n                         (\"rel\", \"noopener noreferrer\") => true,\n                         _ => false,\n                     },\n-                    \"{}\", value.to_string()\n+                    \"{}\",\n+                    value.to_string()\n                 );\n                 Some(value.into())\n             })\n@@ -3037,6 +3432,64 @@ mod test {\n         );\n     }\n \n+    #[test]\n+    fn ns_svg() {\n+        // https://github.com/cure53/DOMPurify/pull/495\n+        let fragment = r##\"<svg><iframe><a title=\"</iframe><img src onerror=alert(1)>\">test\"##;\n+        let result = String::from(Builder::new().add_tags(&[\"iframe\"]).clean(fragment));\n+        assert_eq!(\n+            result.to_string(),\n+            \"test\"\n+        );\n+\n+        let fragment = \"<svg><iframe>remove me</iframe></svg><iframe>keep me</iframe>\";\n+        let result = String::from(Builder::new().add_tags(&[\"iframe\"]).clean(fragment));\n+        assert_eq!(result.to_string(), \"remove me<iframe>keep me</iframe>\");\n+\n+        let fragment = \"<svg><a>remove me</a></svg><iframe>keep me</iframe>\";\n+        let result = String::from(Builder::new().add_tags(&[\"iframe\"]).clean(fragment));\n+        assert_eq!(result.to_string(), \"remove me<iframe>keep me</iframe>\");\n+\n+        let fragment = \"<svg><a>keep me</a></svg><iframe>keep me</iframe>\";\n+        let result = String::from(Builder::new().add_tags(&[\"iframe\", \"svg\"]).clean(fragment));\n+        assert_eq!(\n+            result.to_string(),\n+            \"<svg><a rel=\\\"noopener noreferrer\\\">keep me</a></svg><iframe>keep me</iframe>\"\n+        );\n+    }\n+\n+    #[test]\n+    fn ns_mathml() {\n+        // https://github.com/cure53/DOMPurify/pull/495\n+        let fragment = \"<mglyph></mglyph>\";\n+        let result = String::from(\n+            Builder::new()\n+                .add_tags(&[\"math\", \"mtext\", \"mglyph\"])\n+                .clean(fragment),\n+        );\n+        assert_eq!(result.to_string(), \"\");\n+        let fragment = \"<math><mtext><div><mglyph>\";\n+        let result = String::from(\n+            Builder::new()\n+                .add_tags(&[\"math\", \"mtext\", \"mglyph\"])\n+                .clean(fragment),\n+        );\n+        assert_eq!(\n+            result.to_string(),\n+            \"<math><mtext><div></div></mtext></math>\"\n+        );\n+        let fragment = \"<math><mtext><mglyph>\";\n+        let result = String::from(\n+            Builder::new()\n+                .add_tags(&[\"math\", \"mtext\", \"mglyph\"])\n+                .clean(fragment),\n+        );\n+        assert_eq!(\n+            result.to_string(),\n+            \"<math><mtext><mglyph></mglyph></mtext></math>\"\n+        );\n+    }\n+\n     #[test]\n     fn generic_attribute_prefixes() {\n         let prefix_data = [\"data-\"];\n",
    "diff_parsed": "{'added': [(1784, '            let pass_clean = self.clean_child(&mut node, url_base);'), (1785, '            let pass = pass_clean && self.check_expected_namespace(&parent, &node);'), (1977, '    fn check_expected_namespace(&self, parent: &Handle, child: &Handle) -> bool {'), (1978, '        let (parent, child) = match (&parent.data, &child.data) {'), (1979, '            (NodeData::Element { name: pn, .. }, NodeData::Element { name: cn, .. }) => (pn, cn),'), (1980, '            _ => return true,'), (1981, '        };'), (1983, '        if parent.ns == ns!(html) && child.ns == ns!(svg) {'), (1984, '            child.local == local_name!(\"svg\")'), (1986, '        } else if parent.ns == ns!(html) && child.ns == ns!(mathml) {'), (1987, '            child.local == local_name!(\"math\")'), (1989, '        } else if parent.ns == ns!(mathml) && child.ns != ns!(mathml) {'), (1991, '            matches!('), (1992, '                &*parent.local,'), (1993, '                \"mi\" | \"mo\" | \"mn\" | \"ms\" | \"mtext\" | \"annotation-xml\"'), (1994, '            )'), (1996, '        } else if parent.ns == ns!(svg) && child.ns != ns!(svg) {'), (1998, '            matches!(&*parent.local, \"foreignObject\")'), (1999, '        } else if child.ns == ns!(svg) {'), (2000, '            is_svg_tag(&*child.local)'), (2001, '        } else if child.ns == ns!(mathml) {'), (2002, '            is_mathml_tag(&*child.local)'), (2003, '        } else if child.ns == ns!(html) {'), (2004, '            (!is_svg_tag(&*child.local) && !is_mathml_tag(&*child.local))'), (2005, '                || matches!('), (2006, '                    &*child.local,'), (2007, '                    \"title\" | \"style\" | \"font\" | \"a\" | \"script\" | \"span\"'), (2008, '                )'), (2009, '        } else {'), (2011, '            parent.ns == child.ns'), (2012, '        }'), (2013, '    }'), (2174, 'fn is_svg_tag(element: &str) -> bool {'), (2176, '    match element {'), (2177, '        \"a\"'), (2178, '        | \"animate\"'), (2179, '        | \"animateMotion\"'), (2180, '        | \"animateTransform\"'), (2181, '        | \"circle\"'), (2182, '        | \"clipPath\"'), (2183, '        | \"defs\"'), (2184, '        | \"desc\"'), (2185, '        | \"discard\"'), (2186, '        | \"ellipse\"'), (2187, '        | \"feBlend\"'), (2188, '        | \"feColorMatrix\"'), (2189, '        | \"feComponentTransfer\"'), (2190, '        | \"feComposite\"'), (2191, '        | \"feConvolveMatrix\"'), (2192, '        | \"feDiffuseLighting\"'), (2193, '        | \"feDisplacementMap\"'), (2194, '        | \"feDistantLight\"'), (2195, '        | \"feDropShadow\"'), (2196, '        | \"feFlood\"'), (2197, '        | \"feFuncA\"'), (2198, '        | \"feFuncB\"'), (2199, '        | \"feFuncG\"'), (2200, '        | \"feFuncR\"'), (2201, '        | \"feGaussianBlur\"'), (2202, '        | \"feImage\"'), (2203, '        | \"feMerge\"'), (2204, '        | \"feMergeNode\"'), (2205, '        | \"feMorphology\"'), (2206, '        | \"feOffset\"'), (2207, '        | \"fePointLight\"'), (2208, '        | \"feSpecularLighting\"'), (2209, '        | \"feSpotLight\"'), (2210, '        | \"feTile\"'), (2211, '        | \"feTurbulence\"'), (2212, '        | \"filter\"'), (2213, '        | \"foreignObject\"'), (2214, '        | \"g\"'), (2215, '        | \"image\"'), (2216, '        | \"line\"'), (2217, '        | \"linearGradient\"'), (2218, '        | \"marker\"'), (2219, '        | \"mask\"'), (2220, '        | \"metadata\"'), (2221, '        | \"mpath\"'), (2222, '        | \"path\"'), (2223, '        | \"pattern\"'), (2224, '        | \"polygon\"'), (2225, '        | \"polyline\"'), (2226, '        | \"radialGradient\"'), (2227, '        | \"rect\"'), (2228, '        | \"script\"'), (2229, '        | \"set\"'), (2230, '        | \"stop\"'), (2231, '        | \"style\"'), (2232, '        | \"svg\"'), (2233, '        | \"switch\"'), (2234, '        | \"symbol\"'), (2235, '        | \"text\"'), (2236, '        | \"textPath\"'), (2237, '        | \"title\"'), (2238, '        | \"tspan\"'), (2239, '        | \"use\"'), (2240, '        | \"view\" => true,'), (2241, '        _ => false,'), (2242, '    }'), (2243, '}'), (2246, 'fn is_mathml_tag(element: &str) -> bool {'), (2248, '    match element {'), (2249, '        \"abs\"'), (2250, '        | \"and\"'), (2251, '        | \"annotation\"'), (2252, '        | \"annotation-xml\"'), (2253, '        | \"apply\"'), (2254, '        | \"approx\"'), (2255, '        | \"arccos\"'), (2256, '        | \"arccosh\"'), (2257, '        | \"arccot\"'), (2258, '        | \"arccoth\"'), (2259, '        | \"arccsc\"'), (2260, '        | \"arccsch\"'), (2261, '        | \"arcsec\"'), (2262, '        | \"arcsech\"'), (2263, '        | \"arcsin\"'), (2264, '        | \"arcsinh\"'), (2265, '        | \"arctan\"'), (2266, '        | \"arctanh\"'), (2267, '        | \"arg\"'), (2268, '        | \"bind\"'), (2269, '        | \"bvar\"'), (2270, '        | \"card\"'), (2271, '        | \"cartesianproduct\"'), (2272, '        | \"cbytes\"'), (2273, '        | \"ceiling\"'), (2274, '        | \"cerror\"'), (2275, '        | \"ci\"'), (2276, '        | \"cn\"'), (2277, '        | \"codomain\"'), (2278, '        | \"complexes\"'), (2279, '        | \"compose\"'), (2280, '        | \"condition\"'), (2281, '        | \"conjugate\"'), (2282, '        | \"cos\"'), (2283, '        | \"cosh\"'), (2284, '        | \"cot\"'), (2285, '        | \"coth\"'), (2286, '        | \"cs\"'), (2287, '        | \"csc\"'), (2288, '        | \"csch\"'), (2289, '        | \"csymbol\"'), (2290, '        | \"curl\"'), (2291, '        | \"declare\"'), (2292, '        | \"degree\"'), (2293, '        | \"determinant\"'), (2294, '        | \"diff\"'), (2295, '        | \"divergence\"'), (2296, '        | \"divide\"'), (2297, '        | \"domain\"'), (2298, '        | \"domainofapplication\"'), (2299, '        | \"emptyset\"'), (2300, '        | \"eq\"'), (2301, '        | \"equivalent\"'), (2302, '        | \"eulergamma\"'), (2303, '        | \"exists\"'), (2304, '        | \"exp\"'), (2305, '        | \"exponentiale\"'), (2306, '        | \"factorial\"'), (2307, '        | \"factorof\"'), (2308, '        | \"false\"'), (2309, '        | \"floor\"'), (2310, '        | \"fn\"'), (2311, '        | \"forall\"'), (2312, '        | \"gcd\"'), (2313, '        | \"geq\"'), (2314, '        | \"grad\"'), (2315, '        | \"gt\"'), (2316, '        | \"ident\"'), (2317, '        | \"image\"'), (2318, '        | \"imaginary\"'), (2319, '        | \"imaginaryi\"'), (2320, '        | \"implies\"'), (2321, '        | \"in\"'), (2322, '        | \"infinity\"'), (2323, '        | \"int\"'), (2324, '        | \"integers\"'), (2325, '        | \"intersect\"'), (2326, '        | \"interval\"'), (2327, '        | \"inverse\"'), (2328, '        | \"lambda\"'), (2329, '        | \"laplacian\"'), (2330, '        | \"lcm\"'), (2331, '        | \"leq\"'), (2332, '        | \"limit\"'), (2333, '        | \"list\"'), (2334, '        | \"ln\"'), (2335, '        | \"log\"'), (2336, '        | \"logbase\"'), (2337, '        | \"lowlimit\"'), (2338, '        | \"lt\"'), (2339, '        | \"maction\"'), (2340, '        | \"maligngroup\"'), (2341, '        | \"malignmark\"'), (2342, '        | \"math\"'), (2343, '        | \"matrix\"'), (2344, '        | \"matrixrow\"'), (2345, '        | \"max\"'), (2346, '        | \"mean\"'), (2347, '        | \"median\"'), (2348, '        | \"menclose\"'), (2349, '        | \"merror\"'), (2350, '        | \"mfenced\"'), (2351, '        | \"mfrac\"'), (2352, '        | \"mglyph\"'), (2353, '        | \"mi\"'), (2354, '        | \"min\"'), (2355, '        | \"minus\"'), (2356, '        | \"mlabeledtr\"'), (2357, '        | \"mlongdiv\"'), (2358, '        | \"mmultiscripts\"'), (2359, '        | \"mn\"'), (2360, '        | \"mo\"'), (2361, '        | \"mode\"'), (2362, '        | \"moment\"'), (2363, '        | \"momentabout\"'), (2364, '        | \"mover\"'), (2365, '        | \"mpadded\"'), (2366, '        | \"mphantom\"'), (2367, '        | \"mprescripts\"'), (2368, '        | \"mroot\"'), (2369, '        | \"mrow\"'), (2370, '        | \"ms\"'), (2371, '        | \"mscarries\"'), (2372, '        | \"mscarry\"'), (2373, '        | \"msgroup\"'), (2374, '        | \"msline\"'), (2375, '        | \"mspace\"'), (2376, '        | \"msqrt\"'), (2377, '        | \"msrow\"'), (2378, '        | \"mstack\"'), (2379, '        | \"mstyle\"'), (2380, '        | \"msub\"'), (2381, '        | \"msubsup\"'), (2382, '        | \"msup\"'), (2383, '        | \"mtable\"'), (2384, '        | \"mtd\"'), (2385, '        | \"mtext\"'), (2386, '        | \"mtr\"'), (2387, '        | \"munder\"'), (2388, '        | \"munderover\"'), (2389, '        | \"naturalnumbers\"'), (2390, '        | \"neq\"'), (2391, '        | \"none\"'), (2392, '        | \"not\"'), (2393, '        | \"notanumber\"'), (2394, '        | \"notin\"'), (2395, '        | \"notprsubset\"'), (2396, '        | \"notsubset\"'), (2397, '        | \"or\"'), (2398, '        | \"otherwise\"'), (2399, '        | \"outerproduct\"'), (2400, '        | \"partialdiff\"'), (2401, '        | \"pi\"'), (2402, '        | \"piece\"'), (2403, '        | \"piecewise\"'), (2404, '        | \"plus\"'), (2405, '        | \"power\"'), (2406, '        | \"primes\"'), (2407, '        | \"product\"'), (2408, '        | \"prsubset\"'), (2409, '        | \"quotient\"'), (2410, '        | \"rationals\"'), (2411, '        | \"real\"'), (2412, '        | \"reals\"'), (2413, '        | \"reln\"'), (2414, '        | \"rem\"'), (2415, '        | \"root\"'), (2416, '        | \"scalarproduct\"'), (2417, '        | \"sdev\"'), (2418, '        | \"sec\"'), (2419, '        | \"sech\"'), (2420, '        | \"selector\"'), (2421, '        | \"semantics\"'), (2422, '        | \"sep\"'), (2423, '        | \"set\"'), (2424, '        | \"setdiff\"'), (2425, '        | \"share\"'), (2426, '        | \"sin\"'), (2427, '        | \"sinh\"'), (2428, '        | \"span\"'), (2429, '        | \"subset\"'), (2430, '        | \"sum\"'), (2431, '        | \"tan\"'), (2432, '        | \"tanh\"'), (2433, '        | \"tendsto\"'), (2434, '        | \"times\"'), (2435, '        | \"transpose\"'), (2436, '        | \"true\"'), (2437, '        | \"union\"'), (2438, '        | \"uplimit\"'), (2439, '        | \"variance\"'), (2440, '        | \"vector\"'), (2441, '        | \"vectorproduct\"'), (2442, '        | \"xor\" => true,'), (2443, '        _ => false,'), (2444, '    }'), (2445, '}'), (2876, '                    \"{}\",'), (2877, '                    value.to_string()'), (3435, '    #[test]'), (3436, '    fn ns_svg() {'), (3438, '        let fragment = r##\"<svg><iframe><a title=\"</iframe><img src onerror=alert(1)>\">test\"##;'), (3439, '        let result = String::from(Builder::new().add_tags(&[\"iframe\"]).clean(fragment));'), (3440, '        assert_eq!('), (3441, '            result.to_string(),'), (3442, '            \"test\"'), (3443, '        );'), (3445, '        let fragment = \"<svg><iframe>remove me</iframe></svg><iframe>keep me</iframe>\";'), (3446, '        let result = String::from(Builder::new().add_tags(&[\"iframe\"]).clean(fragment));'), (3447, '        assert_eq!(result.to_string(), \"remove me<iframe>keep me</iframe>\");'), (3449, '        let fragment = \"<svg><a>remove me</a></svg><iframe>keep me</iframe>\";'), (3450, '        let result = String::from(Builder::new().add_tags(&[\"iframe\"]).clean(fragment));'), (3451, '        assert_eq!(result.to_string(), \"remove me<iframe>keep me</iframe>\");'), (3453, '        let fragment = \"<svg><a>keep me</a></svg><iframe>keep me</iframe>\";'), (3454, '        let result = String::from(Builder::new().add_tags(&[\"iframe\", \"svg\"]).clean(fragment));'), (3455, '        assert_eq!('), (3456, '            result.to_string(),'), (3457, '            \"<svg><a rel=\\\\\"noopener noreferrer\\\\\">keep me</a></svg><iframe>keep me</iframe>\"'), (3458, '        );'), (3459, '    }'), (3461, '    #[test]'), (3462, '    fn ns_mathml() {'), (3464, '        let fragment = \"<mglyph></mglyph>\";'), (3465, '        let result = String::from('), (3466, '            Builder::new()'), (3467, '                .add_tags(&[\"math\", \"mtext\", \"mglyph\"])'), (3468, '                .clean(fragment),'), (3469, '        );'), (3470, '        assert_eq!(result.to_string(), \"\");'), (3471, '        let fragment = \"<math><mtext><div><mglyph>\";'), (3472, '        let result = String::from('), (3473, '            Builder::new()'), (3474, '                .add_tags(&[\"math\", \"mtext\", \"mglyph\"])'), (3475, '                .clean(fragment),'), (3476, '        );'), (3477, '        assert_eq!('), (3478, '            result.to_string(),'), (3479, '            \"<math><mtext><div></div></mtext></math>\"'), (3480, '        );'), (3481, '        let fragment = \"<math><mtext><mglyph>\";'), (3482, '        let result = String::from('), (3483, '            Builder::new()'), (3484, '                .add_tags(&[\"math\", \"mtext\", \"mglyph\"])'), (3485, '                .clean(fragment),'), (3486, '        );'), (3487, '        assert_eq!('), (3488, '            result.to_string(),'), (3489, '            \"<math><mtext><mglyph></mglyph></mtext></math>\"'), (3490, '        );'), (3491, '    }')], 'deleted': [(1784, '            let pass = self.clean_child(&mut node, url_base);'), (2482, '                    \"{}\", value.to_string()')]}",
    "num_lines_added": "353",
    "num_lines_deleted": "2",
    "nloc": "2639"
  },
  {
    "file_change_id": "204417078166784",
    "hash": "582b6221887e92aeab1ac9008c75133974ed939",
    "old_path": "parc/src/lib.rs",
    "new_path": "parc/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -380,7 +380,7 @@ impl<T> LockWeak<T> {\n     }\n }\n \n-unsafe impl<T> Send for LockWeak<T> {}\n+unsafe impl<T: Sync> Send for LockWeak<T> {}\n \n /// Unclonable owned reference to a [`ParentArc`](struct.ParentArc.html).\n ///\n",
    "diff_parsed": "{'added': [(383, 'unsafe impl<T: Sync> Send for LockWeak<T> {}')], 'deleted': [(383, 'unsafe impl<T> Send for LockWeak<T> {}')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "309"
  },
  {
    "file_change_id": "59718777847958",
    "hash": "be327d581e8434a2ba41b74affc915f42d8abfc",
    "old_path": "crossbeam-channel/src/flavors/array.rs",
    "new_path": "crossbeam-channel/src/flavors/array.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -115,7 +115,7 @@ impl<T> Channel<T> {\n         // Allocate a buffer of `cap` slots initialized\n         // with stamps.\n         let buffer = {\n-            let mut v: Vec<Slot<T>> = (0..cap)\n+            let mut boxed: Box<[Slot<T>]> = (0..cap)\n                 .map(|i| {\n                     // Set the stamp to `{ lap: 0, mark: 0, index: i }`.\n                     Slot {\n@@ -124,8 +124,8 @@ impl<T> Channel<T> {\n                     }\n                 })\n                 .collect();\n-            let ptr = v.as_mut_ptr();\n-            mem::forget(v);\n+            let ptr = boxed.as_mut_ptr();\n+            mem::forget(boxed);\n             ptr\n         };\n \n@@ -553,7 +553,11 @@ impl<T> Drop for Channel<T> {\n \n         // Finally, deallocate the buffer, but don't run any destructors.\n         unsafe {\n-            Vec::from_raw_parts(self.buffer, 0, self.cap);\n+            // Create a slice from the buffer to make\n+            // a fat pointer. Then, use Box::from_raw\n+            // to deallocate it.\n+            let ptr = std::slice::from_raw_parts_mut(self.buffer, self.cap) as *mut [Slot<T>];\n+            Box::from_raw(ptr);\n         }\n     }\n }\n",
    "diff_parsed": "{'added': [(118, '            let mut boxed: Box<[Slot<T>]> = (0..cap)'), (127, '            let ptr = boxed.as_mut_ptr();'), (128, '            mem::forget(boxed);'), (559, '            let ptr = std::slice::from_raw_parts_mut(self.buffer, self.cap) as *mut [Slot<T>];'), (560, '            Box::from_raw(ptr);')], 'deleted': [(118, '            let mut v: Vec<Slot<T>> = (0..cap)'), (127, '            let ptr = v.as_mut_ptr();'), (128, '            mem::forget(v);'), (556, '            Vec::from_raw_parts(self.buffer, 0, self.cap);')]}",
    "num_lines_added": "5",
    "num_lines_deleted": "4",
    "nloc": "425"
  },
  {
    "file_change_id": "190417661131640",
    "hash": "be327d581e8434a2ba41b74affc915f42d8abfc",
    "old_path": "crossbeam-queue/src/array_queue.rs",
    "new_path": "crossbeam-queue/src/array_queue.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -8,7 +8,7 @@\n //!   - Simplified BSD License and Apache License, Version 2.0\n //!   - http://www.1024cores.net/home/code-license\n \n-use alloc::vec::Vec;\n+use alloc::boxed::Box;\n use core::cell::UnsafeCell;\n use core::fmt;\n use core::marker::PhantomData;\n@@ -110,7 +110,7 @@ impl<T> ArrayQueue<T> {\n         // Allocate a buffer of `cap` slots initialized\n         // with stamps.\n         let buffer = {\n-            let mut v: Vec<Slot<T>> = (0..cap)\n+            let mut boxed: Box<[Slot<T>]> = (0..cap)\n                 .map(|i| {\n                     // Set the stamp to `{ lap: 0, index: i }`.\n                     Slot {\n@@ -119,8 +119,8 @@ impl<T> ArrayQueue<T> {\n                     }\n                 })\n                 .collect();\n-            let ptr = v.as_mut_ptr();\n-            mem::forget(v);\n+            let ptr = boxed.as_mut_ptr();\n+            mem::forget(boxed);\n             ptr\n         };\n \n@@ -425,7 +425,11 @@ impl<T> Drop for ArrayQueue<T> {\n \n         // Finally, deallocate the buffer, but don't run any destructors.\n         unsafe {\n-            Vec::from_raw_parts(self.buffer, 0, self.cap);\n+            // Create a slice from the buffer to make\n+            // a fat pointer. Then, use Box::from_raw\n+            // to deallocate it.\n+            let ptr = core::slice::from_raw_parts_mut(self.buffer, self.cap) as *mut [Slot<T>];\n+            Box::from_raw(ptr);\n         }\n     }\n }\n",
    "diff_parsed": "{'added': [(11, 'use alloc::boxed::Box;'), (113, '            let mut boxed: Box<[Slot<T>]> = (0..cap)'), (122, '            let ptr = boxed.as_mut_ptr();'), (123, '            mem::forget(boxed);'), (431, '            let ptr = core::slice::from_raw_parts_mut(self.buffer, self.cap) as *mut [Slot<T>];'), (432, '            Box::from_raw(ptr);')], 'deleted': [(11, 'use alloc::vec::Vec;'), (113, '            let mut v: Vec<Slot<T>> = (0..cap)'), (122, '            let ptr = v.as_mut_ptr();'), (123, '            mem::forget(v);'), (428, '            Vec::from_raw_parts(self.buffer, 0, self.cap);')]}",
    "num_lines_added": "6",
    "num_lines_deleted": "5",
    "nloc": "203"
  },
  {
    "file_change_id": "243018059384384",
    "hash": "813a329f11b4901f962d89fe340004bb32129ac",
    "old_path": "src/net.rs",
    "new_path": "src/net.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -13,6 +13,8 @@ use std::sync::atomic::{AtomicUsize, Ordering};\n \n use winapi::ctypes::*;\n use winapi::shared::guiddef::*;\n+use winapi::shared::in6addr::{in6_addr_u, IN6_ADDR};\n+use winapi::shared::inaddr::{in_addr_S_un, IN_ADDR};\n use winapi::shared::minwindef::*;\n use winapi::shared::minwindef::{FALSE, TRUE};\n use winapi::shared::ntdef::*;\n@@ -456,16 +458,64 @@ fn cvt(i: c_int, size: DWORD) -> io::Result<Option<usize>> {\n     }\n }\n \n-fn socket_addr_to_ptrs(addr: &SocketAddr) -> (*const SOCKADDR, c_int) {\n+/// A type with the same memory layout as `SOCKADDR`. Used in converting Rust level\n+/// SocketAddr* types into their system representation. The benefit of this specific\n+/// type over using `SOCKADDR_STORAGE` is that this type is exactly as large as it\n+/// needs to be and not a lot larger. And it can be initialized cleaner from Rust.\n+#[repr(C)]\n+pub(crate) union SocketAddrCRepr {\n+    v4: SOCKADDR_IN,\n+    v6: SOCKADDR_IN6_LH,\n+}\n+\n+impl SocketAddrCRepr {\n+    pub(crate) fn as_ptr(&self) -> *const SOCKADDR {\n+        self as *const _ as *const SOCKADDR\n+    }\n+}\n+\n+fn socket_addr_to_ptrs(addr: &SocketAddr) -> (SocketAddrCRepr, c_int) {\n     match *addr {\n-        SocketAddr::V4(ref a) => (\n-            a as *const _ as *const _,\n-            mem::size_of::<SOCKADDR_IN>() as c_int,\n-        ),\n-        SocketAddr::V6(ref a) => (\n-            a as *const _ as *const _,\n-            mem::size_of::<SOCKADDR_IN6_LH>() as c_int,\n-        ),\n+        SocketAddr::V4(ref a) => {\n+            let sin_addr = unsafe {\n+                let mut s_un = mem::zeroed::<in_addr_S_un>();\n+                *s_un.S_addr_mut() = u32::from_ne_bytes(a.ip().octets());\n+                IN_ADDR { S_un: s_un }\n+            };\n+\n+            let sockaddr_in = SOCKADDR_IN {\n+                sin_family: AF_INET as ADDRESS_FAMILY,\n+                sin_port: a.port().to_be(),\n+                sin_addr,\n+                sin_zero: [0; 8],\n+            };\n+\n+            let sockaddr = SocketAddrCRepr { v4: sockaddr_in };\n+            (sockaddr, mem::size_of::<SOCKADDR_IN>() as c_int)\n+        }\n+        SocketAddr::V6(ref a) => {\n+            let sin6_addr = unsafe {\n+                let mut u = mem::zeroed::<in6_addr_u>();\n+                *u.Byte_mut() = a.ip().octets();\n+                IN6_ADDR { u }\n+            };\n+            let u = unsafe {\n+                let mut u = mem::zeroed::<SOCKADDR_IN6_LH_u>();\n+                *u.sin6_scope_id_mut() = a.scope_id();\n+                u\n+            };\n+\n+            let sockaddr_in6 = SOCKADDR_IN6_LH {\n+                sin6_family: AF_INET6 as ADDRESS_FAMILY,\n+                sin6_port: a.port().to_be(),\n+                sin6_addr,\n+                sin6_flowinfo: a.flowinfo(),\n+                u,\n+            };\n+\n+            let sockaddr = SocketAddrCRepr { v6: sockaddr_in6 };\n+            (sockaddr, mem::size_of::<SOCKADDR_IN6_LH>() as c_int)\n+        }\n     }\n }\n \n@@ -650,7 +700,7 @@ unsafe fn connect_overlapped(\n     let mut bytes_sent: DWORD = 0;\n     let r = connect_ex(\n         socket,\n-        addr_buf,\n+        addr_buf.as_ptr(),\n         addr_len,\n         buf.as_ptr() as *mut _,\n         buf.len() as u32,\n@@ -723,7 +773,7 @@ impl UdpSocketExt for UdpSocket {\n             1,\n             &mut sent_bytes,\n             0,\n-            addr_buf as *const _,\n+            addr_buf.as_ptr() as *const _,\n             addr_len,\n             overlapped,\n             None,\n",
    "diff_parsed": "{'added': [(16, 'use winapi::shared::in6addr::{in6_addr_u, IN6_ADDR};'), (17, 'use winapi::shared::inaddr::{in_addr_S_un, IN_ADDR};'), (465, '#[repr(C)]'), (466, 'pub(crate) union SocketAddrCRepr {'), (467, '    v4: SOCKADDR_IN,'), (468, '    v6: SOCKADDR_IN6_LH,'), (469, '}'), (471, 'impl SocketAddrCRepr {'), (472, '    pub(crate) fn as_ptr(&self) -> *const SOCKADDR {'), (473, '        self as *const _ as *const SOCKADDR'), (474, '    }'), (475, '}'), (477, 'fn socket_addr_to_ptrs(addr: &SocketAddr) -> (SocketAddrCRepr, c_int) {'), (479, '        SocketAddr::V4(ref a) => {'), (480, '            let sin_addr = unsafe {'), (481, '                let mut s_un = mem::zeroed::<in_addr_S_un>();'), (482, '                *s_un.S_addr_mut() = u32::from_ne_bytes(a.ip().octets());'), (483, '                IN_ADDR { S_un: s_un }'), (484, '            };'), (486, '            let sockaddr_in = SOCKADDR_IN {'), (487, '                sin_family: AF_INET as ADDRESS_FAMILY,'), (488, '                sin_port: a.port().to_be(),'), (489, '                sin_addr,'), (490, '                sin_zero: [0; 8],'), (491, '            };'), (493, '            let sockaddr = SocketAddrCRepr { v4: sockaddr_in };'), (494, '            (sockaddr, mem::size_of::<SOCKADDR_IN>() as c_int)'), (495, '        }'), (496, '        SocketAddr::V6(ref a) => {'), (497, '            let sin6_addr = unsafe {'), (498, '                let mut u = mem::zeroed::<in6_addr_u>();'), (499, '                *u.Byte_mut() = a.ip().octets();'), (500, '                IN6_ADDR { u }'), (501, '            };'), (502, '            let u = unsafe {'), (503, '                let mut u = mem::zeroed::<SOCKADDR_IN6_LH_u>();'), (504, '                *u.sin6_scope_id_mut() = a.scope_id();'), (505, '                u'), (506, '            };'), (508, '            let sockaddr_in6 = SOCKADDR_IN6_LH {'), (509, '                sin6_family: AF_INET6 as ADDRESS_FAMILY,'), (510, '                sin6_port: a.port().to_be(),'), (511, '                sin6_addr,'), (512, '                sin6_flowinfo: a.flowinfo(),'), (513, '                u,'), (514, '            };'), (516, '            let sockaddr = SocketAddrCRepr { v6: sockaddr_in6 };'), (517, '            (sockaddr, mem::size_of::<SOCKADDR_IN6_LH>() as c_int)'), (518, '        }'), (703, '        addr_buf.as_ptr(),'), (776, '            addr_buf.as_ptr() as *const _,')], 'deleted': [(459, 'fn socket_addr_to_ptrs(addr: &SocketAddr) -> (*const SOCKADDR, c_int) {'), (461, '        SocketAddr::V4(ref a) => ('), (462, '            a as *const _ as *const _,'), (463, '            mem::size_of::<SOCKADDR_IN>() as c_int,'), (464, '        ),'), (465, '        SocketAddr::V6(ref a) => ('), (466, '            a as *const _ as *const _,'), (467, '            mem::size_of::<SOCKADDR_IN6_LH>() as c_int,'), (468, '        ),'), (653, '        addr_buf,'), (726, '            addr_buf as *const _,')]}",
    "num_lines_added": "51",
    "num_lines_deleted": "11",
    "nloc": "876"
  },
  {
    "file_change_id": "60385310024988",
    "hash": "2783715269d56a0020160179c0f2ba883d12d87",
    "old_path": "src/net.rs",
    "new_path": "src/net.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -13,6 +13,8 @@ use std::os::windows::prelude::*;\n \n use net2::TcpBuilder;\n use winapi::*;\n+use winapi::shared::inaddr::{in_addr_S_un, IN_ADDR};\n+use winapi::shared::in6addr::{in6_addr_u, IN6_ADDR};\n use ws2_32::*;\n \n /// A type to represent a buffer in which a socket address will be stored.\n@@ -478,13 +480,63 @@ fn cvt(i: c_int, size: DWORD) -> io::Result<Option<usize>> {\n     }\n }\n \n-fn socket_addr_to_ptrs(addr: &SocketAddr) -> (*const SOCKADDR, c_int) {\n+/// A type with the same memory layout as `SOCKADDR`. Used in converting Rust level\n+/// SocketAddr* types into their system representation. The benefit of this specific\n+/// type over using `SOCKADDR_STORAGE` is that this type is exactly as large as it\n+/// needs to be and not a lot larger. And it can be initialized cleaner from Rust.\n+#[repr(C)]\n+pub(crate) union SocketAddrCRepr {\n+    v4: SOCKADDR_IN,\n+    v6: SOCKADDR_IN6_LH,\n+}\n+\n+impl SocketAddrCRepr {\n+    pub(crate) fn as_ptr(&self) -> *const SOCKADDR {\n+        self as *const _ as *const SOCKADDR\n+    }\n+}\n+\n+fn socket_addr_to_ptrs(addr: &SocketAddr) -> (SocketAddrCRepr, c_int) {\n     match *addr {\n         SocketAddr::V4(ref a) => {\n-            (a as *const _ as *const _, mem::size_of::<SOCKADDR_IN>() as c_int)\n+            let sin_addr = unsafe {\n+                let mut s_un = mem::zeroed::<in_addr_S_un>();\n+                *s_un.S_addr_mut() = u32::from_ne_bytes(a.ip().octets());\n+                IN_ADDR { S_un: s_un }\n+            };\n+\n+            let sockaddr_in = SOCKADDR_IN {\n+                sin_family: AF_INET as ADDRESS_FAMILY,\n+                sin_port: a.port().to_be(),\n+                sin_addr,\n+                sin_zero: [0; 8],\n+            };\n+\n+            let sockaddr = SocketAddrCRepr { v4: sockaddr_in };\n+            (sockaddr, mem::size_of::<SOCKADDR_IN>() as c_int)\n         }\n         SocketAddr::V6(ref a) => {\n-            (a as *const _ as *const _, mem::size_of::<sockaddr_in6>() as c_int)\n+            let sin6_addr = unsafe {\n+                let mut u = mem::zeroed::<in6_addr_u>();\n+                *u.Byte_mut() = a.ip().octets();\n+                IN6_ADDR { u }\n+            };\n+            let u = unsafe {\n+                let mut u = mem::zeroed::<SOCKADDR_IN6_LH_u>();\n+                *u.sin6_scope_id_mut() = a.scope_id();\n+                u\n+            };\n+\n+            let sockaddr_in6 = SOCKADDR_IN6_LH {\n+                sin6_family: AF_INET6 as ADDRESS_FAMILY,\n+                sin6_port: a.port().to_be(),\n+                sin6_addr,\n+                sin6_flowinfo: a.flowinfo(),\n+                u,\n+            };\n+\n+            let sockaddr = SocketAddrCRepr { v6: sockaddr_in6 };\n+            (sockaddr, mem::size_of::<SOCKADDR_IN6_LH>() as c_int)\n         }\n     }\n }\n@@ -643,7 +695,7 @@ unsafe fn connect_overlapped(socket: SOCKET,\n \n     let (addr_buf, addr_len) = socket_addr_to_ptrs(addr);\n     let mut bytes_sent: DWORD = 0;\n-    let r = connect_ex(socket, addr_buf, addr_len,\n+    let r = connect_ex(socket, addr_buf.as_ptr(), addr_len,\n                        buf.as_ptr() as *mut _,\n                        buf.len() as u32,\n                        &mut bytes_sent, overlapped);\n@@ -694,7 +746,7 @@ impl UdpSocketExt for UdpSocket {\n         let mut sent_bytes = 0;\n         let r = WSASendTo(self.as_raw_socket(), &mut buf, 1,\n                           &mut sent_bytes, 0,\n-                          addr_buf as *const _, addr_len,\n+                          addr_buf.as_ptr() as *const _, addr_len,\n                           overlapped, None);\n         cvt(r, sent_bytes)\n     }\n",
    "diff_parsed": "{'added': [(16, 'use winapi::shared::inaddr::{in_addr_S_un, IN_ADDR};'), (17, 'use winapi::shared::in6addr::{in6_addr_u, IN6_ADDR};'), (487, '#[repr(C)]'), (488, 'pub(crate) union SocketAddrCRepr {'), (489, '    v4: SOCKADDR_IN,'), (490, '    v6: SOCKADDR_IN6_LH,'), (491, '}'), (493, 'impl SocketAddrCRepr {'), (494, '    pub(crate) fn as_ptr(&self) -> *const SOCKADDR {'), (495, '        self as *const _ as *const SOCKADDR'), (496, '    }'), (497, '}'), (499, 'fn socket_addr_to_ptrs(addr: &SocketAddr) -> (SocketAddrCRepr, c_int) {'), (502, '            let sin_addr = unsafe {'), (503, '                let mut s_un = mem::zeroed::<in_addr_S_un>();'), (504, '                *s_un.S_addr_mut() = u32::from_ne_bytes(a.ip().octets());'), (505, '                IN_ADDR { S_un: s_un }'), (506, '            };'), (508, '            let sockaddr_in = SOCKADDR_IN {'), (509, '                sin_family: AF_INET as ADDRESS_FAMILY,'), (510, '                sin_port: a.port().to_be(),'), (511, '                sin_addr,'), (512, '                sin_zero: [0; 8],'), (513, '            };'), (515, '            let sockaddr = SocketAddrCRepr { v4: sockaddr_in };'), (516, '            (sockaddr, mem::size_of::<SOCKADDR_IN>() as c_int)'), (519, '            let sin6_addr = unsafe {'), (520, '                let mut u = mem::zeroed::<in6_addr_u>();'), (521, '                *u.Byte_mut() = a.ip().octets();'), (522, '                IN6_ADDR { u }'), (523, '            };'), (524, '            let u = unsafe {'), (525, '                let mut u = mem::zeroed::<SOCKADDR_IN6_LH_u>();'), (526, '                *u.sin6_scope_id_mut() = a.scope_id();'), (527, '                u'), (528, '            };'), (530, '            let sockaddr_in6 = SOCKADDR_IN6_LH {'), (531, '                sin6_family: AF_INET6 as ADDRESS_FAMILY,'), (532, '                sin6_port: a.port().to_be(),'), (533, '                sin6_addr,'), (534, '                sin6_flowinfo: a.flowinfo(),'), (535, '                u,'), (536, '            };'), (538, '            let sockaddr = SocketAddrCRepr { v6: sockaddr_in6 };'), (539, '            (sockaddr, mem::size_of::<SOCKADDR_IN6_LH>() as c_int)'), (698, '    let r = connect_ex(socket, addr_buf.as_ptr(), addr_len,'), (749, '                          addr_buf.as_ptr() as *const _, addr_len,')], 'deleted': [(481, 'fn socket_addr_to_ptrs(addr: &SocketAddr) -> (*const SOCKADDR, c_int) {'), (484, '            (a as *const _ as *const _, mem::size_of::<SOCKADDR_IN>() as c_int)'), (487, '            (a as *const _ as *const _, mem::size_of::<sockaddr_in6>() as c_int)'), (646, '    let r = connect_ex(socket, addr_buf, addr_len,'), (697, '                          addr_buf as *const _, addr_len,')]}",
    "num_lines_added": "47",
    "num_lines_deleted": "5",
    "nloc": "758"
  },
  {
    "file_change_id": "90851717272224",
    "hash": "27b77cc870b922d305015841978b581ceb18e3b",
    "old_path": "src/net.rs",
    "new_path": "src/net.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -13,8 +13,9 @@ use std::os::windows::prelude::*;\n \n use net2::TcpBuilder;\n use winapi::*;\n-use winapi::shared::inaddr::{in_addr_S_un, IN_ADDR};\n-use winapi::shared::in6addr::{in6_addr_u, IN6_ADDR};\n+use winapi::inaddr::IN_ADDR;\n+use winapi::ws2def::SOCKADDR_IN;\n+use winapi::ws2ipdef::{in6_addr, sockaddr_in6};\n use ws2_32::*;\n \n /// A type to represent a buffer in which a socket address will be stored.\n@@ -487,7 +488,7 @@ fn cvt(i: c_int, size: DWORD) -> io::Result<Option<usize>> {\n #[repr(C)]\n pub(crate) union SocketAddrCRepr {\n     v4: SOCKADDR_IN,\n-    v6: SOCKADDR_IN6_LH,\n+    v6: sockaddr_in6,\n }\n \n impl SocketAddrCRepr {\n@@ -499,16 +500,10 @@ impl SocketAddrCRepr {\n fn socket_addr_to_ptrs(addr: &SocketAddr) -> (SocketAddrCRepr, c_int) {\n     match *addr {\n         SocketAddr::V4(ref a) => {\n-            let sin_addr = unsafe {\n-                let mut s_un = mem::zeroed::<in_addr_S_un>();\n-                *s_un.S_addr_mut() = u32::from_ne_bytes(a.ip().octets());\n-                IN_ADDR { S_un: s_un }\n-            };\n-\n             let sockaddr_in = SOCKADDR_IN {\n                 sin_family: AF_INET as ADDRESS_FAMILY,\n                 sin_port: a.port().to_be(),\n-                sin_addr,\n+                sin_addr: IN_ADDR { S_un: u32::from_ne_bytes(a.ip().octets()) },\n                 sin_zero: [0; 8],\n             };\n \n@@ -516,27 +511,16 @@ fn socket_addr_to_ptrs(addr: &SocketAddr) -> (SocketAddrCRepr, c_int) {\n             (sockaddr, mem::size_of::<SOCKADDR_IN>() as c_int)\n         }\n         SocketAddr::V6(ref a) => {\n-            let sin6_addr = unsafe {\n-                let mut u = mem::zeroed::<in6_addr_u>();\n-                *u.Byte_mut() = a.ip().octets();\n-                IN6_ADDR { u }\n-            };\n-            let u = unsafe {\n-                let mut u = mem::zeroed::<SOCKADDR_IN6_LH_u>();\n-                *u.sin6_scope_id_mut() = a.scope_id();\n-                u\n-            };\n-\n-            let sockaddr_in6 = SOCKADDR_IN6_LH {\n-                sin6_family: AF_INET6 as ADDRESS_FAMILY,\n+            let sockaddr_in6 = sockaddr_in6 {\n+                sin6_family: AF_INET6 as i16,\n                 sin6_port: a.port().to_be(),\n-                sin6_addr,\n+                sin6_addr: in6_addr { s6_addr: a.ip().octets() },\n                 sin6_flowinfo: a.flowinfo(),\n-                u,\n+                sin6_scope_id: a.scope_id(),\n             };\n \n             let sockaddr = SocketAddrCRepr { v6: sockaddr_in6 };\n-            (sockaddr, mem::size_of::<SOCKADDR_IN6_LH>() as c_int)\n+            (sockaddr, mem::size_of::<sockaddr_in6>() as c_int)\n         }\n     }\n }\n",
    "diff_parsed": "{'added': [(16, 'use winapi::inaddr::IN_ADDR;'), (17, 'use winapi::ws2def::SOCKADDR_IN;'), (18, 'use winapi::ws2ipdef::{in6_addr, sockaddr_in6};'), (491, '    v6: sockaddr_in6,'), (506, '                sin_addr: IN_ADDR { S_un: u32::from_ne_bytes(a.ip().octets()) },'), (514, '            let sockaddr_in6 = sockaddr_in6 {'), (515, '                sin6_family: AF_INET6 as i16,'), (517, '                sin6_addr: in6_addr { s6_addr: a.ip().octets() },'), (519, '                sin6_scope_id: a.scope_id(),'), (523, '            (sockaddr, mem::size_of::<sockaddr_in6>() as c_int)')], 'deleted': [(16, 'use winapi::shared::inaddr::{in_addr_S_un, IN_ADDR};'), (17, 'use winapi::shared::in6addr::{in6_addr_u, IN6_ADDR};'), (490, '    v6: SOCKADDR_IN6_LH,'), (502, '            let sin_addr = unsafe {'), (503, '                let mut s_un = mem::zeroed::<in_addr_S_un>();'), (504, '                *s_un.S_addr_mut() = u32::from_ne_bytes(a.ip().octets());'), (505, '                IN_ADDR { S_un: s_un }'), (506, '            };'), (511, '                sin_addr,'), (519, '            let sin6_addr = unsafe {'), (520, '                let mut u = mem::zeroed::<in6_addr_u>();'), (521, '                *u.Byte_mut() = a.ip().octets();'), (522, '                IN6_ADDR { u }'), (523, '            };'), (524, '            let u = unsafe {'), (525, '                let mut u = mem::zeroed::<SOCKADDR_IN6_LH_u>();'), (526, '                *u.sin6_scope_id_mut() = a.scope_id();'), (527, '                u'), (528, '            };'), (530, '            let sockaddr_in6 = SOCKADDR_IN6_LH {'), (531, '                sin6_family: AF_INET6 as ADDRESS_FAMILY,'), (533, '                sin6_addr,'), (535, '                u,'), (539, '            (sockaddr, mem::size_of::<SOCKADDR_IN6_LH>() as c_int)')]}",
    "num_lines_added": "10",
    "num_lines_deleted": "24",
    "nloc": "744"
  },
  {
    "file_change_id": "127426847091038",
    "hash": "043d5f0e4200b9bafc083997cc7bbf2c1bef91d",
    "old_path": "src/windows/mod.rs",
    "new_path": "src/windows/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -6,7 +6,6 @@ use std::borrow::Cow;\n use std::char;\n use std::ffi::OsStr;\n use std::ffi::OsString;\n-use std::mem;\n use std::os::windows::ffi::OsStrExt;\n use std::os::windows::ffi::OsStringExt;\n \n@@ -17,6 +16,73 @@ use crate::OsStringBytes;\n #[allow(clippy::module_inception)]\n mod imp;\n \n+// UTF-8 ranges and tags for encoding characters\n+// From Rust's libcore/char/mod.rs\n+const TAG_CONT: u8 = 0b1000_0000;\n+const TAG_TWO_B: u8 = 0b1100_0000;\n+const TAG_THREE_B: u8 = 0b1110_0000;\n+const TAG_FOUR_B: u8 = 0b1111_0000;\n+const MAX_ONE_B: u32 = 0x80;\n+const MAX_TWO_B: u32 = 0x800;\n+const MAX_THREE_B: u32 = 0x10000;\n+\n+// From Rust's libcore/char/methods.rs (char::len_utf8)\n+fn len_wtf8(code: u32) -> usize {\n+    if code < MAX_ONE_B {\n+        1\n+    } else if code < MAX_TWO_B {\n+        2\n+    } else if code < MAX_THREE_B {\n+        3\n+    } else {\n+        4\n+    }\n+}\n+\n+// From Rust's libcore/char/methods.rs (char::encode_utf8)\n+fn encode_wtf8(code: u32, dst: &mut [u8]) -> &mut [u8] {\n+    let len = len_wtf8(code);\n+    match (len, &mut dst[..]) {\n+        (1, [a, ..]) => {\n+            *a = code as u8;\n+        }\n+        (2, [a, b, ..]) => {\n+            *a = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;\n+            *b = (code & 0x3F) as u8 | TAG_CONT;\n+        }\n+        (3, [a, b, c, ..]) => {\n+            *a = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;\n+            *b = (code >> 6 & 0x3F) as u8 | TAG_CONT;\n+            *c = (code & 0x3F) as u8 | TAG_CONT;\n+        }\n+        (4, [a, b, c, d, ..]) => {\n+            *a = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;\n+            *b = (code >> 12 & 0x3F) as u8 | TAG_CONT;\n+            *c = (code >> 6 & 0x3F) as u8 | TAG_CONT;\n+            *d = (code & 0x3F) as u8 | TAG_CONT;\n+        }\n+        _ => unreachable!(),\n+    };\n+    &mut dst[..len]\n+}\n+\n+// From Rust's libcore/char/methods.rs (char::encode_utf16)\n+fn encode_wide(mut code: u32, dst: &mut [u16]) -> &mut [u16] {\n+    if (code & 0xFFFF) == code && !dst.is_empty() {\n+        // The BMP falls through (assuming non-surrogate, as it should)\n+        dst[0] = code as u16;\n+        &mut dst[..1]\n+    } else if dst.len() >= 2 {\n+        // Supplementary planes break into surrogates.\n+        code -= 0x1_0000;\n+        dst[0] = 0xD800 | ((code >> 10) as u16);\n+        dst[1] = 0xDC00 | ((code as u16) & 0x3FF);\n+        dst\n+    } else {\n+        unreachable!()\n+    }\n+}\n+\n fn wide_to_wtf8<TString>(encoded_string: TString, length: usize) -> Vec<u8>\n where\n     TString: IntoIterator<Item = u16>,\n@@ -24,17 +90,12 @@ where\n     // https://github.com/rust-lang/rust/blob/49c68bd53f90e375bfb3cbba8c1c67a9e0adb9c0/src/libstd/sys_common/wtf8.rs#L183-L199\n \n     let mut string = Vec::with_capacity(length);\n-    let mut buffer = [0; mem::size_of::<char>()];\n+    let mut buffer = [0; 4];\n     for ch in char::decode_utf16(encoded_string) {\n-        let unchecked_char = ch.unwrap_or_else(|surrogate| {\n-            let surrogate = surrogate.unpaired_surrogate().into();\n-            debug_assert!(surrogate <= u32::from(char::MAX));\n-            // SAFETY: https://docs.rs/os_str_bytes/#safety\n-            unsafe { char::from_u32_unchecked(surrogate) }\n-        });\n-        string.extend_from_slice(\n-            unchecked_char.encode_utf8(&mut buffer).as_bytes(),\n-        );\n+        let ch = ch\n+            .map(u32::from)\n+            .unwrap_or_else(|surrogate| surrogate.unpaired_surrogate().into());\n+        string.extend_from_slice(encode_wtf8(ch, &mut buffer));\n     }\n     debug_assert_eq!(string.len(), length);\n     string\n@@ -47,11 +108,7 @@ fn wtf8_to_wide(string: &[u8]) -> Vec<u16> {\n     let mut encoded_string = Vec::new();\n     let mut buffer = [0; 2];\n     while let Some(code_point) = imp::next_code_point(&mut string) {\n-        debug_assert!(code_point <= u32::from(char::MAX));\n-        // SAFETY: https://docs.rs/os_str_bytes/#safety\n-        let unchecked_char = unsafe { char::from_u32_unchecked(code_point) };\n-        encoded_string\n-            .extend_from_slice(unchecked_char.encode_utf16(&mut buffer));\n+        encoded_string.extend_from_slice(encode_wide(code_point, &mut buffer));\n     }\n     encoded_string\n }\n",
    "diff_parsed": "{'added': [(21, 'const TAG_CONT: u8 = 0b1000_0000;'), (22, 'const TAG_TWO_B: u8 = 0b1100_0000;'), (23, 'const TAG_THREE_B: u8 = 0b1110_0000;'), (24, 'const TAG_FOUR_B: u8 = 0b1111_0000;'), (25, 'const MAX_ONE_B: u32 = 0x80;'), (26, 'const MAX_TWO_B: u32 = 0x800;'), (27, 'const MAX_THREE_B: u32 = 0x10000;'), (30, 'fn len_wtf8(code: u32) -> usize {'), (31, '    if code < MAX_ONE_B {'), (32, '        1'), (33, '    } else if code < MAX_TWO_B {'), (34, '        2'), (35, '    } else if code < MAX_THREE_B {'), (36, '        3'), (37, '    } else {'), (38, '        4'), (39, '    }'), (40, '}'), (43, 'fn encode_wtf8(code: u32, dst: &mut [u8]) -> &mut [u8] {'), (44, '    let len = len_wtf8(code);'), (45, '    match (len, &mut dst[..]) {'), (46, '        (1, [a, ..]) => {'), (47, '            *a = code as u8;'), (48, '        }'), (49, '        (2, [a, b, ..]) => {'), (50, '            *a = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;'), (51, '            *b = (code & 0x3F) as u8 | TAG_CONT;'), (52, '        }'), (53, '        (3, [a, b, c, ..]) => {'), (54, '            *a = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;'), (55, '            *b = (code >> 6 & 0x3F) as u8 | TAG_CONT;'), (56, '            *c = (code & 0x3F) as u8 | TAG_CONT;'), (57, '        }'), (58, '        (4, [a, b, c, d, ..]) => {'), (59, '            *a = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;'), (60, '            *b = (code >> 12 & 0x3F) as u8 | TAG_CONT;'), (61, '            *c = (code >> 6 & 0x3F) as u8 | TAG_CONT;'), (62, '            *d = (code & 0x3F) as u8 | TAG_CONT;'), (63, '        }'), (64, '        _ => unreachable!(),'), (65, '    };'), (66, '    &mut dst[..len]'), (67, '}'), (70, 'fn encode_wide(mut code: u32, dst: &mut [u16]) -> &mut [u16] {'), (71, '    if (code & 0xFFFF) == code && !dst.is_empty() {'), (73, '        dst[0] = code as u16;'), (74, '        &mut dst[..1]'), (75, '    } else if dst.len() >= 2 {'), (77, '        code -= 0x1_0000;'), (78, '        dst[0] = 0xD800 | ((code >> 10) as u16);'), (79, '        dst[1] = 0xDC00 | ((code as u16) & 0x3FF);'), (80, '        dst'), (81, '    } else {'), (82, '        unreachable!()'), (83, '    }'), (84, '}'), (93, '    let mut buffer = [0; 4];'), (95, '        let ch = ch'), (96, '            .map(u32::from)'), (97, '            .unwrap_or_else(|surrogate| surrogate.unpaired_surrogate().into());'), (98, '        string.extend_from_slice(encode_wtf8(ch, &mut buffer));'), (111, '        encoded_string.extend_from_slice(encode_wide(code_point, &mut buffer));')], 'deleted': [(9, 'use std::mem;'), (27, '    let mut buffer = [0; mem::size_of::<char>()];'), (29, '        let unchecked_char = ch.unwrap_or_else(|surrogate| {'), (30, '            let surrogate = surrogate.unpaired_surrogate().into();'), (31, '            debug_assert!(surrogate <= u32::from(char::MAX));'), (33, '            unsafe { char::from_u32_unchecked(surrogate) }'), (34, '        });'), (35, '        string.extend_from_slice('), (36, '            unchecked_char.encode_utf8(&mut buffer).as_bytes(),'), (37, '        );'), (50, '        debug_assert!(code_point <= u32::from(char::MAX));'), (52, '        let unchecked_char = unsafe { char::from_u32_unchecked(code_point) };'), (53, '        encoded_string'), (54, '            .extend_from_slice(unchecked_char.encode_utf16(&mut buffer));')]}",
    "num_lines_added": "62",
    "num_lines_deleted": "14",
    "nloc": "167"
  },
  {
    "file_change_id": "31892449503751",
    "hash": "fd4bd03686c476efcc9d758e234f0bdf1732e7d",
    "old_path": "src/windows/mod.rs",
    "new_path": "src/windows/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -42,24 +42,24 @@ fn len_wtf8(code: u32) -> usize {\n // From Rust's libcore/char/methods.rs (char::encode_utf8)\n fn encode_wtf8(code: u32, dst: &mut [u8]) -> &mut [u8] {\n     let len = len_wtf8(code);\n-    match (len, &mut dst[..]) {\n-        (1, [a, ..]) => {\n-            *a = code as u8;\n+    match len {\n+        1 => {\n+            dst[0] = code as u8;\n         }\n-        (2, [a, b, ..]) => {\n-            *a = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;\n-            *b = (code & 0x3F) as u8 | TAG_CONT;\n+        2 => {\n+            dst[0] = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;\n+            dst[1] = (code & 0x3F) as u8 | TAG_CONT;\n         }\n-        (3, [a, b, c, ..]) => {\n-            *a = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;\n-            *b = (code >> 6 & 0x3F) as u8 | TAG_CONT;\n-            *c = (code & 0x3F) as u8 | TAG_CONT;\n+        3 => {\n+            dst[0] = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;\n+            dst[1] = (code >> 6 & 0x3F) as u8 | TAG_CONT;\n+            dst[2] = (code & 0x3F) as u8 | TAG_CONT;\n         }\n-        (4, [a, b, c, d, ..]) => {\n-            *a = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;\n-            *b = (code >> 12 & 0x3F) as u8 | TAG_CONT;\n-            *c = (code >> 6 & 0x3F) as u8 | TAG_CONT;\n-            *d = (code & 0x3F) as u8 | TAG_CONT;\n+        4 => {\n+            dst[0] = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;\n+            dst[1] = (code >> 12 & 0x3F) as u8 | TAG_CONT;\n+            dst[2] = (code >> 6 & 0x3F) as u8 | TAG_CONT;\n+            dst[3] = (code & 0x3F) as u8 | TAG_CONT;\n         }\n         _ => unreachable!(),\n     };\n",
    "diff_parsed": "{'added': [(45, '    match len {'), (46, '        1 => {'), (47, '            dst[0] = code as u8;'), (49, '        2 => {'), (50, '            dst[0] = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;'), (51, '            dst[1] = (code & 0x3F) as u8 | TAG_CONT;'), (53, '        3 => {'), (54, '            dst[0] = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;'), (55, '            dst[1] = (code >> 6 & 0x3F) as u8 | TAG_CONT;'), (56, '            dst[2] = (code & 0x3F) as u8 | TAG_CONT;'), (58, '        4 => {'), (59, '            dst[0] = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;'), (60, '            dst[1] = (code >> 12 & 0x3F) as u8 | TAG_CONT;'), (61, '            dst[2] = (code >> 6 & 0x3F) as u8 | TAG_CONT;'), (62, '            dst[3] = (code & 0x3F) as u8 | TAG_CONT;')], 'deleted': [(45, '    match (len, &mut dst[..]) {'), (46, '        (1, [a, ..]) => {'), (47, '            *a = code as u8;'), (49, '        (2, [a, b, ..]) => {'), (50, '            *a = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;'), (51, '            *b = (code & 0x3F) as u8 | TAG_CONT;'), (53, '        (3, [a, b, c, ..]) => {'), (54, '            *a = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;'), (55, '            *b = (code >> 6 & 0x3F) as u8 | TAG_CONT;'), (56, '            *c = (code & 0x3F) as u8 | TAG_CONT;'), (58, '        (4, [a, b, c, d, ..]) => {'), (59, '            *a = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;'), (60, '            *b = (code >> 12 & 0x3F) as u8 | TAG_CONT;'), (61, '            *c = (code >> 6 & 0x3F) as u8 | TAG_CONT;'), (62, '            *d = (code & 0x3F) as u8 | TAG_CONT;')]}",
    "num_lines_added": "15",
    "num_lines_deleted": "15",
    "nloc": "167"
  },
  {
    "file_change_id": "252637112291563",
    "hash": "4dd2832d0e4bd0253ea77dd15bcd95ea171bfee",
    "old_path": "cli/tests/integration/run_tests.rs",
    "new_path": "cli/tests/integration/run_tests.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -2523,3 +2523,93 @@ itest!(fetch_async_error_stack {\n   output: \"fetch_async_error_stack.ts.out\",\n   exit_code: 1,\n });\n+\n+itest!(unstable_ffi_1 {\n+  args: \"run unstable_ffi_1.js\",\n+  output: \"unstable_ffi_1.js.out\",\n+  exit_code: 70,\n+});\n+\n+itest!(unstable_ffi_2 {\n+  args: \"run unstable_ffi_2.js\",\n+  output: \"unstable_ffi_2.js.out\",\n+  exit_code: 70,\n+});\n+\n+itest!(unstable_ffi_3 {\n+  args: \"run unstable_ffi_3.js\",\n+  output: \"unstable_ffi_3.js.out\",\n+  exit_code: 70,\n+});\n+\n+itest!(unstable_ffi_4 {\n+  args: \"run unstable_ffi_4.js\",\n+  output: \"unstable_ffi_4.js.out\",\n+  exit_code: 70,\n+});\n+\n+itest!(unstable_ffi_5 {\n+  args: \"run unstable_ffi_5.js\",\n+  output: \"unstable_ffi_5.js.out\",\n+  exit_code: 70,\n+});\n+\n+itest!(unstable_ffi_6 {\n+  args: \"run unstable_ffi_6.js\",\n+  output: \"unstable_ffi_6.js.out\",\n+  exit_code: 70,\n+});\n+\n+itest!(unstable_ffi_7 {\n+  args: \"run unstable_ffi_7.js\",\n+  output: \"unstable_ffi_7.js.out\",\n+  exit_code: 70,\n+});\n+\n+itest!(unstable_ffi_8 {\n+  args: \"run unstable_ffi_8.js\",\n+  output: \"unstable_ffi_8.js.out\",\n+  exit_code: 70,\n+});\n+\n+itest!(unstable_ffi_9 {\n+  args: \"run unstable_ffi_9.js\",\n+  output: \"unstable_ffi_9.js.out\",\n+  exit_code: 70,\n+});\n+\n+itest!(unstable_ffi_10 {\n+  args: \"run unstable_ffi_10.js\",\n+  output: \"unstable_ffi_10.js.out\",\n+  exit_code: 70,\n+});\n+\n+itest!(unstable_ffi_11 {\n+  args: \"run unstable_ffi_11.js\",\n+  output: \"unstable_ffi_11.js.out\",\n+  exit_code: 70,\n+});\n+\n+itest!(unstable_ffi_12 {\n+  args: \"run unstable_ffi_12.js\",\n+  output: \"unstable_ffi_12.js.out\",\n+  exit_code: 70,\n+});\n+\n+itest!(unstable_ffi_13 {\n+  args: \"run unstable_ffi_13.js\",\n+  output: \"unstable_ffi_13.js.out\",\n+  exit_code: 70,\n+});\n+\n+itest!(unstable_ffi_14 {\n+  args: \"run unstable_ffi_14.js\",\n+  output: \"unstable_ffi_14.js.out\",\n+  exit_code: 70,\n+});\n+\n+itest!(unstable_ffi_15 {\n+  args: \"run unstable_ffi_15.js\",\n+  output: \"unstable_ffi_15.js.out\",\n+  exit_code: 70,\n+});\n",
    "diff_parsed": "{'added': [(2527, 'itest!(unstable_ffi_1 {'), (2528, '  args: \"run unstable_ffi_1.js\",'), (2529, '  output: \"unstable_ffi_1.js.out\",'), (2530, '  exit_code: 70,'), (2531, '});'), (2533, 'itest!(unstable_ffi_2 {'), (2534, '  args: \"run unstable_ffi_2.js\",'), (2535, '  output: \"unstable_ffi_2.js.out\",'), (2536, '  exit_code: 70,'), (2537, '});'), (2539, 'itest!(unstable_ffi_3 {'), (2540, '  args: \"run unstable_ffi_3.js\",'), (2541, '  output: \"unstable_ffi_3.js.out\",'), (2542, '  exit_code: 70,'), (2543, '});'), (2545, 'itest!(unstable_ffi_4 {'), (2546, '  args: \"run unstable_ffi_4.js\",'), (2547, '  output: \"unstable_ffi_4.js.out\",'), (2548, '  exit_code: 70,'), (2549, '});'), (2551, 'itest!(unstable_ffi_5 {'), (2552, '  args: \"run unstable_ffi_5.js\",'), (2553, '  output: \"unstable_ffi_5.js.out\",'), (2554, '  exit_code: 70,'), (2555, '});'), (2557, 'itest!(unstable_ffi_6 {'), (2558, '  args: \"run unstable_ffi_6.js\",'), (2559, '  output: \"unstable_ffi_6.js.out\",'), (2560, '  exit_code: 70,'), (2561, '});'), (2563, 'itest!(unstable_ffi_7 {'), (2564, '  args: \"run unstable_ffi_7.js\",'), (2565, '  output: \"unstable_ffi_7.js.out\",'), (2566, '  exit_code: 70,'), (2567, '});'), (2569, 'itest!(unstable_ffi_8 {'), (2570, '  args: \"run unstable_ffi_8.js\",'), (2571, '  output: \"unstable_ffi_8.js.out\",'), (2572, '  exit_code: 70,'), (2573, '});'), (2575, 'itest!(unstable_ffi_9 {'), (2576, '  args: \"run unstable_ffi_9.js\",'), (2577, '  output: \"unstable_ffi_9.js.out\",'), (2578, '  exit_code: 70,'), (2579, '});'), (2581, 'itest!(unstable_ffi_10 {'), (2582, '  args: \"run unstable_ffi_10.js\",'), (2583, '  output: \"unstable_ffi_10.js.out\",'), (2584, '  exit_code: 70,'), (2585, '});'), (2587, 'itest!(unstable_ffi_11 {'), (2588, '  args: \"run unstable_ffi_11.js\",'), (2589, '  output: \"unstable_ffi_11.js.out\",'), (2590, '  exit_code: 70,'), (2591, '});'), (2593, 'itest!(unstable_ffi_12 {'), (2594, '  args: \"run unstable_ffi_12.js\",'), (2595, '  output: \"unstable_ffi_12.js.out\",'), (2596, '  exit_code: 70,'), (2597, '});'), (2599, 'itest!(unstable_ffi_13 {'), (2600, '  args: \"run unstable_ffi_13.js\",'), (2601, '  output: \"unstable_ffi_13.js.out\",'), (2602, '  exit_code: 70,'), (2603, '});'), (2605, 'itest!(unstable_ffi_14 {'), (2606, '  args: \"run unstable_ffi_14.js\",'), (2607, '  output: \"unstable_ffi_14.js.out\",'), (2608, '  exit_code: 70,'), (2609, '});'), (2611, 'itest!(unstable_ffi_15 {'), (2612, '  args: \"run unstable_ffi_15.js\",'), (2613, '  output: \"unstable_ffi_15.js.out\",'), (2614, '  exit_code: 70,'), (2615, '});')], 'deleted': []}",
    "num_lines_added": "75",
    "num_lines_deleted": "0",
    "nloc": "2180"
  },
  {
    "file_change_id": "264029948444574",
    "hash": "4dd2832d0e4bd0253ea77dd15bcd95ea171bfee",
    "old_path": "ext/ffi/lib.rs",
    "new_path": "ext/ffi/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -45,6 +45,11 @@ fn check_unstable(state: &OpState, api_name: &str) {\n   }\n }\n \n+pub fn check_unstable2(state: &Rc<RefCell<OpState>>, api_name: &str) {\n+  let state = state.borrow();\n+  check_unstable(&state, api_name)\n+}\n+\n pub trait FfiPermissions {\n   fn check(&mut self, path: Option<&Path>) -> Result<(), AnyError>;\n }\n@@ -144,8 +149,8 @@ pub fn init<P: FfiPermissions + 'static>(unstable: bool) -> Extension {\n       op_ffi_get_static::decl(),\n       op_ffi_call::decl(),\n       op_ffi_call_nonblocking::decl(),\n-      op_ffi_call_ptr::decl(),\n-      op_ffi_call_ptr_nonblocking::decl(),\n+      op_ffi_call_ptr::decl::<P>(),\n+      op_ffi_call_ptr_nonblocking::decl::<P>(),\n       op_ffi_ptr_of::decl::<P>(),\n       op_ffi_buf_copy_into::decl::<P>(),\n       op_ffi_cstr_read::decl::<P>(),\n@@ -648,15 +653,38 @@ fn ffi_call(args: FfiCallArgs, symbol: &Symbol) -> Result<Value, AnyError> {\n }\n \n #[op]\n-fn op_ffi_call_ptr(args: FfiCallPtrArgs) -> Result<Value, AnyError> {\n+fn op_ffi_call_ptr<FP>(\n+  state: &mut deno_core::OpState,\n+  args: FfiCallPtrArgs,\n+) -> Result<Value, AnyError>\n+where\n+  FP: FfiPermissions + 'static,\n+{\n+  check_unstable(state, \"Deno.UnsafeFnPointer#call\");\n+\n+  let permissions = state.borrow_mut::<FP>();\n+  permissions.check(None)?;\n+\n   let symbol = args.get_symbol();\n   ffi_call(args.into(), &symbol)\n }\n \n #[op]\n-async fn op_ffi_call_ptr_nonblocking(\n+async fn op_ffi_call_ptr_nonblocking<FP>(\n+  state: Rc<RefCell<deno_core::OpState>>,\n   args: FfiCallPtrArgs,\n-) -> Result<Value, AnyError> {\n+) -> Result<Value, AnyError>\n+where\n+  FP: FfiPermissions + 'static,\n+{\n+  check_unstable2(&state, \"Deno.UnsafeFnPointer#call\");\n+\n+  {\n+    let mut state = state.borrow_mut();\n+    let permissions = state.borrow_mut::<FP>();\n+    permissions.check(None)?;\n+  }\n+\n   let symbol = args.get_symbol();\n   tokio::task::spawn_blocking(move || ffi_call(args.into(), &symbol))\n     .await\n@@ -774,6 +802,8 @@ fn op_ffi_ptr_of<FP>(\n where\n   FP: FfiPermissions + 'static,\n {\n+  check_unstable(state, \"Deno.UnsafePointer#of\");\n+\n   let permissions = state.borrow_mut::<FP>();\n   permissions.check(None)?;\n \n@@ -788,6 +818,8 @@ fn op_ffi_buf_copy_into<FP>(\n where\n   FP: FfiPermissions + 'static,\n {\n+  check_unstable(state, \"Deno.UnsafePointerView#copyInto\");\n+\n   let permissions = state.borrow_mut::<FP>();\n   permissions.check(None)?;\n \n@@ -810,6 +842,8 @@ fn op_ffi_cstr_read<FP>(\n where\n   FP: FfiPermissions + 'static,\n {\n+  check_unstable(state, \"Deno.UnsafePointerView#getCString\");\n+\n   let permissions = state.borrow_mut::<FP>();\n   permissions.check(None)?;\n \n@@ -825,6 +859,8 @@ fn op_ffi_read_u8<FP>(\n where\n   FP: FfiPermissions + 'static,\n {\n+  check_unstable(state, \"Deno.UnsafePointerView#getUint8\");\n+\n   let permissions = state.borrow_mut::<FP>();\n   permissions.check(None)?;\n \n@@ -839,6 +875,8 @@ fn op_ffi_read_i8<FP>(\n where\n   FP: FfiPermissions + 'static,\n {\n+  check_unstable(state, \"Deno.UnsafePointerView#getInt8\");\n+\n   let permissions = state.borrow_mut::<FP>();\n   permissions.check(None)?;\n \n@@ -853,6 +891,8 @@ fn op_ffi_read_u16<FP>(\n where\n   FP: FfiPermissions + 'static,\n {\n+  check_unstable(state, \"Deno.UnsafePointerView#getUint16\");\n+\n   let permissions = state.borrow_mut::<FP>();\n   permissions.check(None)?;\n \n@@ -867,6 +907,8 @@ fn op_ffi_read_i16<FP>(\n where\n   FP: FfiPermissions + 'static,\n {\n+  check_unstable(state, \"Deno.UnsafePointerView#getInt16\");\n+\n   let permissions = state.borrow_mut::<FP>();\n   permissions.check(None)?;\n \n@@ -881,6 +923,8 @@ fn op_ffi_read_u32<FP>(\n where\n   FP: FfiPermissions + 'static,\n {\n+  check_unstable(state, \"Deno.UnsafePointerView#getUint32\");\n+\n   let permissions = state.borrow_mut::<FP>();\n   permissions.check(None)?;\n \n@@ -895,6 +939,8 @@ fn op_ffi_read_i32<FP>(\n where\n   FP: FfiPermissions + 'static,\n {\n+  check_unstable(state, \"Deno.UnsafePointerView#getInt32\");\n+\n   let permissions = state.borrow_mut::<FP>();\n   permissions.check(None)?;\n \n@@ -909,6 +955,8 @@ fn op_ffi_read_u64<FP>(\n where\n   FP: FfiPermissions + 'static,\n {\n+  check_unstable(state, \"Deno.UnsafePointerView#getBigUint64\");\n+\n   let permissions = state.borrow_mut::<FP>();\n   permissions.check(None)?;\n \n@@ -925,6 +973,8 @@ fn op_ffi_read_f32<FP>(\n where\n   FP: FfiPermissions + 'static,\n {\n+  check_unstable(state, \"Deno.UnsafePointerView#getFloat32\");\n+\n   let permissions = state.borrow_mut::<FP>();\n   permissions.check(None)?;\n \n@@ -939,6 +989,8 @@ fn op_ffi_read_f64<FP>(\n where\n   FP: FfiPermissions + 'static,\n {\n+  check_unstable(state, \"Deno.UnsafePointerView#getFloat64\");\n+\n   let permissions = state.borrow_mut::<FP>();\n   permissions.check(None)?;\n \n",
    "diff_parsed": "{'added': [(48, 'pub fn check_unstable2(state: &Rc<RefCell<OpState>>, api_name: &str) {'), (49, '  let state = state.borrow();'), (50, '  check_unstable(&state, api_name)'), (51, '}'), (152, '      op_ffi_call_ptr::decl::<P>(),'), (153, '      op_ffi_call_ptr_nonblocking::decl::<P>(),'), (656, 'fn op_ffi_call_ptr<FP>('), (657, '  state: &mut deno_core::OpState,'), (658, '  args: FfiCallPtrArgs,'), (659, ') -> Result<Value, AnyError>'), (660, 'where'), (661, \"  FP: FfiPermissions + 'static,\"), (662, '{'), (663, '  check_unstable(state, \"Deno.UnsafeFnPointer#call\");'), (665, '  let permissions = state.borrow_mut::<FP>();'), (666, '  permissions.check(None)?;'), (673, 'async fn op_ffi_call_ptr_nonblocking<FP>('), (674, '  state: Rc<RefCell<deno_core::OpState>>,'), (676, ') -> Result<Value, AnyError>'), (677, 'where'), (678, \"  FP: FfiPermissions + 'static,\"), (679, '{'), (680, '  check_unstable2(&state, \"Deno.UnsafeFnPointer#call\");'), (682, '  {'), (683, '    let mut state = state.borrow_mut();'), (684, '    let permissions = state.borrow_mut::<FP>();'), (685, '    permissions.check(None)?;'), (686, '  }'), (805, '  check_unstable(state, \"Deno.UnsafePointer#of\");'), (821, '  check_unstable(state, \"Deno.UnsafePointerView#copyInto\");'), (845, '  check_unstable(state, \"Deno.UnsafePointerView#getCString\");'), (862, '  check_unstable(state, \"Deno.UnsafePointerView#getUint8\");'), (878, '  check_unstable(state, \"Deno.UnsafePointerView#getInt8\");'), (894, '  check_unstable(state, \"Deno.UnsafePointerView#getUint16\");'), (910, '  check_unstable(state, \"Deno.UnsafePointerView#getInt16\");'), (926, '  check_unstable(state, \"Deno.UnsafePointerView#getUint32\");'), (942, '  check_unstable(state, \"Deno.UnsafePointerView#getInt32\");'), (958, '  check_unstable(state, \"Deno.UnsafePointerView#getBigUint64\");'), (976, '  check_unstable(state, \"Deno.UnsafePointerView#getFloat32\");'), (992, '  check_unstable(state, \"Deno.UnsafePointerView#getFloat64\");')], 'deleted': [(147, '      op_ffi_call_ptr::decl(),'), (148, '      op_ffi_call_ptr_nonblocking::decl(),'), (651, 'fn op_ffi_call_ptr(args: FfiCallPtrArgs) -> Result<Value, AnyError> {'), (657, 'async fn op_ffi_call_ptr_nonblocking('), (659, ') -> Result<Value, AnyError> {')]}",
    "num_lines_added": "40",
    "num_lines_deleted": "5",
    "nloc": "941"
  },
  {
    "file_change_id": "107164930863950",
    "hash": "9340c55139dc0baaa19df3c3a75c4e46836eda33",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -458,7 +458,7 @@ impl core::fmt::LowerHex for SecretKey {\n }\n \n impl Signature {\n-    pub fn parse(p: &[u8; util::SIGNATURE_SIZE]) -> Signature {\n+    pub fn parse_overflowing(p: &[u8; util::SIGNATURE_SIZE]) -> Signature {\n         let mut r = Scalar::default();\n         let mut s = Scalar::default();\n \n@@ -469,14 +469,39 @@ impl Signature {\n         Signature { r, s }\n     }\n \n-    pub fn parse_slice(p: &[u8]) -> Result<Signature, Error> {\n+    pub fn parse_standard(p: &[u8; util::SIGNATURE_SIZE]) -> Result<Signature, Error> {\n+        let mut r = Scalar::default();\n+        let mut s = Scalar::default();\n+\n+        // Okay for signature to overflow\n+        let overflowed_r = r.set_b32(array_ref!(p, 0, 32));\n+        let overflowed_s = s.set_b32(array_ref!(p, 32, 32));\n+\n+        if bool::from(overflowed_r | overflowed_s) {\n+            return Err(Error::InvalidSignature)\n+        }\n+\n+        Ok(Signature { r, s })\n+    }\n+\n+    pub fn parse_overflowing_slice(p: &[u8]) -> Result<Signature, Error> {\n         if p.len() != util::SIGNATURE_SIZE {\n             return Err(Error::InvalidInputLength);\n         }\n \n         let mut a = [0; util::SIGNATURE_SIZE];\n         a.copy_from_slice(p);\n-        Ok(Self::parse(&a))\n+        Ok(Self::parse_overflowing(&a))\n+    }\n+\n+    pub fn parse_standard_slice(p: &[u8]) -> Result<Signature, Error> {\n+        if p.len() != util::SIGNATURE_SIZE {\n+            return Err(Error::InvalidInputLength);\n+        }\n+\n+        let mut a = [0; util::SIGNATURE_SIZE];\n+        a.copy_from_slice(p);\n+        Ok(Self::parse_standard(&a)?)\n     }\n \n     pub fn parse_der(p: &[u8]) -> Result<Signature, Error> {\n",
    "diff_parsed": "{'added': [(461, '    pub fn parse_overflowing(p: &[u8; util::SIGNATURE_SIZE]) -> Signature {'), (472, '    pub fn parse_standard(p: &[u8; util::SIGNATURE_SIZE]) -> Result<Signature, Error> {'), (473, '        let mut r = Scalar::default();'), (474, '        let mut s = Scalar::default();'), (477, '        let overflowed_r = r.set_b32(array_ref!(p, 0, 32));'), (478, '        let overflowed_s = s.set_b32(array_ref!(p, 32, 32));'), (480, '        if bool::from(overflowed_r | overflowed_s) {'), (481, '            return Err(Error::InvalidSignature)'), (482, '        }'), (484, '        Ok(Signature { r, s })'), (485, '    }'), (487, '    pub fn parse_overflowing_slice(p: &[u8]) -> Result<Signature, Error> {'), (494, '        Ok(Self::parse_overflowing(&a))'), (495, '    }'), (497, '    pub fn parse_standard_slice(p: &[u8]) -> Result<Signature, Error> {'), (498, '        if p.len() != util::SIGNATURE_SIZE {'), (499, '            return Err(Error::InvalidInputLength);'), (500, '        }'), (502, '        let mut a = [0; util::SIGNATURE_SIZE];'), (503, '        a.copy_from_slice(p);'), (504, '        Ok(Self::parse_standard(&a)?)')], 'deleted': [(461, '    pub fn parse(p: &[u8; util::SIGNATURE_SIZE]) -> Signature {'), (472, '    pub fn parse_slice(p: &[u8]) -> Result<Signature, Error> {'), (479, '        Ok(Self::parse(&a))')]}",
    "num_lines_added": "21",
    "num_lines_deleted": "3",
    "nloc": "642"
  },
  {
    "file_change_id": "135378089821424",
    "hash": "5d3207830790420468b1e4f88d6a607df9e3379",
    "old_path": "actix-service/src/and_then.rs",
    "new_path": "actix-service/src/and_then.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,16 +1,17 @@\n use std::future::Future;\n use std::pin::Pin;\n use std::rc::Rc;\n+use std::cell::RefCell;\n use std::task::{Context, Poll};\n \n use super::{Service, ServiceFactory};\n-use crate::cell::Cell;\n+\n \n /// Service for the `and_then` combinator, chaining a computation onto the end\n /// of another service which completes successfully.\n ///\n /// This is created by the `ServiceExt::and_then` method.\n-pub(crate) struct AndThenService<A, B>(Cell<(A, B)>);\n+pub(crate) struct AndThenService<A, B>(Rc<RefCell<(A, B)>>);\n \n impl<A, B> AndThenService<A, B> {\n     /// Create new `AndThen` combinator\n@@ -19,7 +20,7 @@ impl<A, B> AndThenService<A, B> {\n         A: Service,\n         B: Service<Request = A::Response, Error = A::Error>,\n     {\n-        Self(Cell::new((a, b)))\n+        Self(Rc::new(RefCell::new((a, b))))\n     }\n }\n \n@@ -40,7 +41,7 @@ where\n     type Future = AndThenServiceResponse<A, B>;\n \n     fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {\n-        let srv = self.0.get_mut();\n+        let mut srv = self.0.borrow_mut();\n         let not_ready = !srv.0.poll_ready(cx)?.is_ready();\n         if !srv.1.poll_ready(cx)?.is_ready() || not_ready {\n             Poll::Pending\n@@ -51,7 +52,7 @@ where\n \n     fn call(&mut self, req: A::Request) -> Self::Future {\n         AndThenServiceResponse {\n-            state: State::A(self.0.get_mut().0.call(req), Some(self.0.clone())),\n+            state: State::A(self.0.borrow_mut().0.call(req), Some(self.0.clone())),\n         }\n     }\n }\n@@ -72,7 +73,7 @@ where\n     A: Service,\n     B: Service<Request = A::Response, Error = A::Error>,\n {\n-    A(#[pin] A::Future, Option<Cell<(A, B)>>),\n+    A(#[pin] A::Future, Option<Rc<RefCell<(A, B)>>>),\n     B(#[pin] B::Future),\n     Empty,\n }\n@@ -90,9 +91,9 @@ where\n         match this.state.as_mut().project() {\n             StateProj::A(fut, b) => match fut.poll(cx)? {\n                 Poll::Ready(res) => {\n-                    let mut b = b.take().unwrap();\n+                    let b = b.take().unwrap();\n                     this.state.set(State::Empty); // drop fut A\n-                    let fut = b.get_mut().1.call(res);\n+                    let fut = b.borrow_mut().1.call(res);\n                     this.state.set(State::B(fut));\n                     self.poll(cx)\n                 }\n",
    "diff_parsed": "{'added': [(4, 'use std::cell::RefCell;'), (14, 'pub(crate) struct AndThenService<A, B>(Rc<RefCell<(A, B)>>);'), (23, '        Self(Rc::new(RefCell::new((a, b))))'), (44, '        let mut srv = self.0.borrow_mut();'), (55, '            state: State::A(self.0.borrow_mut().0.call(req), Some(self.0.clone())),'), (76, '    A(#[pin] A::Future, Option<Rc<RefCell<(A, B)>>>),'), (94, '                    let b = b.take().unwrap();'), (96, '                    let fut = b.borrow_mut().1.call(res);')], 'deleted': [(7, 'use crate::cell::Cell;'), (13, 'pub(crate) struct AndThenService<A, B>(Cell<(A, B)>);'), (22, '        Self(Cell::new((a, b)))'), (43, '        let srv = self.0.get_mut();'), (54, '            state: State::A(self.0.get_mut().0.call(req), Some(self.0.clone())),'), (75, '    A(#[pin] A::Future, Option<Cell<(A, B)>>),'), (93, '                    let mut b = b.take().unwrap();'), (95, '                    let fut = b.get_mut().1.call(res);')]}",
    "num_lines_added": "8",
    "num_lines_deleted": "8",
    "nloc": "299.0"
  },
  {
    "file_change_id": "276678511130657",
    "hash": "5d3207830790420468b1e4f88d6a607df9e3379",
    "old_path": "actix-service/src/and_then_apply_fn.rs",
    "new_path": "actix-service/src/and_then_apply_fn.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -2,9 +2,9 @@ use std::future::Future;\n use std::marker::PhantomData;\n use std::pin::Pin;\n use std::rc::Rc;\n+use std::cell::RefCell;\n use std::task::{Context, Poll};\n \n-use crate::cell::Cell;\n use crate::{Service, ServiceFactory};\n \n /// `Apply` service combinator\n@@ -16,7 +16,7 @@ where\n     Fut: Future<Output = Result<Res, Err>>,\n     Err: From<A::Error> + From<B::Error>,\n {\n-    srv: Cell<(A, B, F)>,\n+    srv: Rc<RefCell<(A, B, F)>>,\n     r: PhantomData<(Fut, Res, Err)>,\n }\n \n@@ -31,7 +31,7 @@ where\n     /// Create new `Apply` combinator\n     pub(crate) fn new(a: A, b: B, f: F) -> Self {\n         Self {\n-            srv: Cell::new((a, b, f)),\n+            srv:  Rc::new(RefCell::new((a, b, f))),\n             r: PhantomData,\n         }\n     }\n@@ -67,7 +67,7 @@ where\n     type Future = AndThenApplyFnFuture<A, B, F, Fut, Res, Err>;\n \n     fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {\n-        let inner = self.srv.get_mut();\n+        let mut inner = self.srv.borrow_mut();\n         let not_ready = inner.0.poll_ready(cx)?.is_pending();\n         if inner.1.poll_ready(cx)?.is_pending() || not_ready {\n             Poll::Pending\n@@ -77,7 +77,7 @@ where\n     }\n \n     fn call(&mut self, req: A::Request) -> Self::Future {\n-        let fut = self.srv.get_mut().0.call(req);\n+        let fut = self.srv.borrow_mut().0.call(req);\n         AndThenApplyFnFuture {\n             state: State::A(fut, Some(self.srv.clone())),\n         }\n@@ -108,7 +108,7 @@ where\n     Err: From<A::Error>,\n     Err: From<B::Error>,\n {\n-    A(#[pin] A::Future, Option<Cell<(A, B, F)>>),\n+    A(#[pin] A::Future, Option<Rc<RefCell<(A, B, F)>>>),\n     B(#[pin] Fut),\n     Empty,\n }\n@@ -129,10 +129,10 @@ where\n         match this.state.as_mut().project() {\n             StateProj::A(fut, b) => match fut.poll(cx)? {\n                 Poll::Ready(res) => {\n-                    let mut b = b.take().unwrap();\n+                    let b = b.take().unwrap();\n                     this.state.set(State::Empty);\n-                    let b = b.get_mut();\n-                    let fut = (&mut b.2)(res, &mut b.1);\n+                    let (_, b, f) = &mut *b.borrow_mut();\n+                    let fut = f(res, b);\n                     this.state.set(State::B(fut));\n                     self.poll(cx)\n                 }\n@@ -255,11 +255,11 @@ where\n \n         if this.a.is_some() && this.b.is_some() {\n             Poll::Ready(Ok(AndThenApplyFn {\n-                srv: Cell::new((\n+                srv: Rc::new(RefCell::new((\n                     this.a.take().unwrap(),\n                     this.b.take().unwrap(),\n                     this.f.clone(),\n-                )),\n+                ))),\n                 r: PhantomData,\n             }))\n         } else {\n",
    "diff_parsed": "{'added': [(5, 'use std::cell::RefCell;'), (19, '    srv: Rc<RefCell<(A, B, F)>>,'), (34, '            srv:  Rc::new(RefCell::new((a, b, f))),'), (70, '        let mut inner = self.srv.borrow_mut();'), (80, '        let fut = self.srv.borrow_mut().0.call(req);'), (111, '    A(#[pin] A::Future, Option<Rc<RefCell<(A, B, F)>>>),'), (132, '                    let b = b.take().unwrap();'), (134, '                    let (_, b, f) = &mut *b.borrow_mut();'), (135, '                    let fut = f(res, b);'), (258, '                srv: Rc::new(RefCell::new(('), (262, '                ))),')], 'deleted': [(7, 'use crate::cell::Cell;'), (19, '    srv: Cell<(A, B, F)>,'), (34, '            srv: Cell::new((a, b, f)),'), (70, '        let inner = self.srv.get_mut();'), (80, '        let fut = self.srv.get_mut().0.call(req);'), (111, '    A(#[pin] A::Future, Option<Cell<(A, B, F)>>),'), (132, '                    let mut b = b.take().unwrap();'), (134, '                    let b = b.get_mut();'), (135, '                    let fut = (&mut b.2)(res, &mut b.1);'), (258, '                srv: Cell::new(('), (262, '                )),')]}",
    "num_lines_added": "11",
    "num_lines_deleted": "11",
    "nloc": "304.0"
  },
  {
    "file_change_id": "202349732086260",
    "hash": "5d3207830790420468b1e4f88d6a607df9e3379",
    "old_path": "actix-service/src/apply_cfg.rs",
    "new_path": "actix-service/src/apply_cfg.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -2,8 +2,9 @@ use std::future::Future;\n use std::marker::PhantomData;\n use std::pin::Pin;\n use std::task::{Context, Poll};\n+use std::rc::Rc;\n+use std::cell::RefCell;\n \n-use crate::cell::Cell;\n use crate::{Service, ServiceFactory};\n \n /// Convert `Fn(Config, &mut Service1) -> Future<Service2>` fn to a service factory\n@@ -26,7 +27,7 @@ where\n     S: Service,\n {\n     ApplyConfigService {\n-        srv: Cell::new((srv, f)),\n+        srv: Rc::new(RefCell::new((srv, f))),\n         _t: PhantomData,\n     }\n }\n@@ -53,7 +54,7 @@ where\n     S: Service,\n {\n     ApplyConfigServiceFactory {\n-        srv: Cell::new((factory, f)),\n+        srv: Rc::new(RefCell::new((factory, f))),\n         _t: PhantomData,\n     }\n }\n@@ -66,7 +67,7 @@ where\n     R: Future<Output = Result<S, E>>,\n     S: Service,\n {\n-    srv: Cell<(T, F)>,\n+    srv: Rc<RefCell<(T, F)>>,\n     _t: PhantomData<(C, R, S)>,\n }\n \n@@ -102,10 +103,8 @@ where\n     type Future = R;\n \n     fn new_service(&self, cfg: C) -> Self::Future {\n-        unsafe {\n-            let srv = self.srv.get_mut_unsafe();\n-            (srv.1)(cfg, &mut srv.0)\n-        }\n+        let (t, f) = &mut *self.srv.borrow_mut();\n+        f(cfg, t)\n     }\n }\n \n@@ -117,7 +116,7 @@ where\n     R: Future<Output = Result<S, T::InitError>>,\n     S: Service,\n {\n-    srv: Cell<(T, F)>,\n+    srv: Rc<RefCell<(T, F)>>,\n     _t: PhantomData<(C, R, S)>,\n }\n \n@@ -157,7 +156,7 @@ where\n         ApplyConfigServiceFactoryResponse {\n             cfg: Some(cfg),\n             store: self.srv.clone(),\n-            state: State::A(self.srv.get_ref().0.new_service(())),\n+            state: State::A(self.srv.borrow().0.new_service(())),\n         }\n     }\n }\n@@ -172,7 +171,7 @@ where\n     S: Service,\n {\n     cfg: Option<C>,\n-    store: Cell<(T, F)>,\n+    store: Rc<RefCell<(T, F)>>,\n     #[pin]\n     state: State<T, R, S>,\n }\n@@ -213,8 +212,11 @@ where\n             },\n             StateProj::B(srv) => match srv.poll_ready(cx)? {\n                 Poll::Ready(_) => {\n-                    let fut = (this.store.get_mut().1)(this.cfg.take().unwrap(), srv);\n-                    this.state.set(State::C(fut));\n+                    {\n+                        let (_, f) = &mut *this.store.borrow_mut();\n+                        let fut = f(this.cfg.take().unwrap(), srv);\n+                        this.state.set(State::C(fut));\n+                    }\n                     self.poll(cx)\n                 }\n                 Poll::Pending => Poll::Pending,\n",
    "diff_parsed": "{'added': [(5, 'use std::rc::Rc;'), (6, 'use std::cell::RefCell;'), (30, '        srv: Rc::new(RefCell::new((srv, f))),'), (57, '        srv: Rc::new(RefCell::new((factory, f))),'), (70, '    srv: Rc<RefCell<(T, F)>>,'), (106, '        let (t, f) = &mut *self.srv.borrow_mut();'), (107, '        f(cfg, t)'), (119, '    srv: Rc<RefCell<(T, F)>>,'), (159, '            state: State::A(self.srv.borrow().0.new_service(())),'), (174, '    store: Rc<RefCell<(T, F)>>,'), (215, '                    {'), (216, '                        let (_, f) = &mut *this.store.borrow_mut();'), (217, '                        let fut = f(this.cfg.take().unwrap(), srv);'), (218, '                        this.state.set(State::C(fut));'), (219, '                    }')], 'deleted': [(6, 'use crate::cell::Cell;'), (29, '        srv: Cell::new((srv, f)),'), (56, '        srv: Cell::new((factory, f)),'), (69, '    srv: Cell<(T, F)>,'), (105, '        unsafe {'), (106, '            let srv = self.srv.get_mut_unsafe();'), (107, '            (srv.1)(cfg, &mut srv.0)'), (108, '        }'), (120, '    srv: Cell<(T, F)>,'), (160, '            state: State::A(self.srv.get_ref().0.new_service(())),'), (175, '    store: Cell<(T, F)>,'), (216, '                    let fut = (this.store.get_mut().1)(this.cfg.take().unwrap(), srv);'), (217, '                    this.state.set(State::C(fut));')]}",
    "num_lines_added": "15",
    "num_lines_deleted": "13",
    "nloc": "202.0"
  },
  {
    "file_change_id": "216037674329385",
    "hash": "5d3207830790420468b1e4f88d6a607df9e3379",
    "old_path": "actix-service/src/cell.rs",
    "new_path": "None",
    "change_type": "ModificationType.DELETE",
    "diff": "@@ -1,57 +0,0 @@\n-//! Custom cell impl, internal use only\n-use std::task::{Context, Poll};\n-use std::{cell::UnsafeCell, fmt, rc::Rc};\n-\n-pub(crate) struct Cell<T> {\n-    inner: Rc<UnsafeCell<T>>,\n-}\n-\n-impl<T> Clone for Cell<T> {\n-    fn clone(&self) -> Self {\n-        Self {\n-            inner: self.inner.clone(),\n-        }\n-    }\n-}\n-\n-impl<T: fmt::Debug> fmt::Debug for Cell<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.inner.fmt(f)\n-    }\n-}\n-\n-impl<T> Cell<T> {\n-    pub(crate) fn new(inner: T) -> Self {\n-        Self {\n-            inner: Rc::new(UnsafeCell::new(inner)),\n-        }\n-    }\n-\n-    pub(crate) fn get_ref(&self) -> &T {\n-        unsafe { &*self.inner.as_ref().get() }\n-    }\n-\n-    pub(crate) fn get_mut(&mut self) -> &mut T {\n-        unsafe { &mut *self.inner.as_ref().get() }\n-    }\n-\n-    #[allow(clippy::mut_from_ref)]\n-    pub(crate) unsafe fn get_mut_unsafe(&self) -> &mut T {\n-        &mut *self.inner.as_ref().get()\n-    }\n-}\n-\n-impl<T: crate::Service> crate::Service for Cell<T> {\n-    type Request = T::Request;\n-    type Response = T::Response;\n-    type Error = T::Error;\n-    type Future = T::Future;\n-\n-    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {\n-        self.get_mut().poll_ready(cx)\n-    }\n-\n-    fn call(&mut self, req: Self::Request) -> Self::Future {\n-        self.get_mut().call(req)\n-    }\n-}\n",
    "diff_parsed": "{'added': [], 'deleted': [(2, 'use std::task::{Context, Poll};'), (3, 'use std::{cell::UnsafeCell, fmt, rc::Rc};'), (5, 'pub(crate) struct Cell<T> {'), (6, '    inner: Rc<UnsafeCell<T>>,'), (7, '}'), (9, 'impl<T> Clone for Cell<T> {'), (10, '    fn clone(&self) -> Self {'), (11, '        Self {'), (12, '            inner: self.inner.clone(),'), (13, '        }'), (14, '    }'), (15, '}'), (17, 'impl<T: fmt::Debug> fmt::Debug for Cell<T> {'), (18, \"    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\"), (19, '        self.inner.fmt(f)'), (20, '    }'), (21, '}'), (23, 'impl<T> Cell<T> {'), (24, '    pub(crate) fn new(inner: T) -> Self {'), (25, '        Self {'), (26, '            inner: Rc::new(UnsafeCell::new(inner)),'), (27, '        }'), (28, '    }'), (30, '    pub(crate) fn get_ref(&self) -> &T {'), (31, '        unsafe { &*self.inner.as_ref().get() }'), (32, '    }'), (34, '    pub(crate) fn get_mut(&mut self) -> &mut T {'), (35, '        unsafe { &mut *self.inner.as_ref().get() }'), (36, '    }'), (38, '    #[allow(clippy::mut_from_ref)]'), (39, '    pub(crate) unsafe fn get_mut_unsafe(&self) -> &mut T {'), (40, '        &mut *self.inner.as_ref().get()'), (41, '    }'), (42, '}'), (44, 'impl<T: crate::Service> crate::Service for Cell<T> {'), (45, '    type Request = T::Request;'), (46, '    type Response = T::Response;'), (47, '    type Error = T::Error;'), (48, '    type Future = T::Future;'), (50, \"    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {\"), (51, '        self.get_mut().poll_ready(cx)'), (52, '    }'), (54, '    fn call(&mut self, req: Self::Request) -> Self::Future {'), (55, '        self.get_mut().call(req)'), (56, '    }'), (57, '}')]}",
    "num_lines_added": "0",
    "num_lines_deleted": "46",
    "nloc": "nan"
  },
  {
    "file_change_id": "110443159845904",
    "hash": "5d3207830790420468b1e4f88d6a607df9e3379",
    "old_path": "actix-service/src/lib.rs",
    "new_path": "actix-service/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -12,7 +12,6 @@ mod and_then_apply_fn;\n mod apply;\n mod apply_cfg;\n pub mod boxed;\n-mod cell;\n mod fn_service;\n mod map;\n mod map_config;\n",
    "diff_parsed": "{'added': [], 'deleted': [(15, 'mod cell;')]}",
    "num_lines_added": "0",
    "num_lines_deleted": "1",
    "nloc": "237.0"
  },
  {
    "file_change_id": "185652293077685",
    "hash": "5d3207830790420468b1e4f88d6a607df9e3379",
    "old_path": "actix-service/src/then.rs",
    "new_path": "actix-service/src/then.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,16 +1,16 @@\n use std::future::Future;\n use std::pin::Pin;\n use std::rc::Rc;\n+use std::cell::RefCell;\n use std::task::{Context, Poll};\n \n use super::{Service, ServiceFactory};\n-use crate::cell::Cell;\n \n /// Service for the `then` combinator, chaining a computation onto the end of\n /// another service.\n ///\n /// This is created by the `Pipeline::then` method.\n-pub(crate) struct ThenService<A, B>(Cell<(A, B)>);\n+pub(crate) struct ThenService<A, B>(Rc<RefCell<(A, B)>>);\n \n impl<A, B> ThenService<A, B> {\n     /// Create new `.then()` combinator\n@@ -19,7 +19,7 @@ impl<A, B> ThenService<A, B> {\n         A: Service,\n         B: Service<Request = Result<A::Response, A::Error>, Error = A::Error>,\n     {\n-        Self(Cell::new((a, b)))\n+        Self(Rc::new(RefCell::new((a, b))))\n     }\n }\n \n@@ -40,7 +40,7 @@ where\n     type Future = ThenServiceResponse<A, B>;\n \n     fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {\n-        let srv = self.0.get_mut();\n+        let mut srv = self.0.borrow_mut();\n         let not_ready = !srv.0.poll_ready(cx)?.is_ready();\n         if !srv.1.poll_ready(cx)?.is_ready() || not_ready {\n             Poll::Pending\n@@ -51,7 +51,7 @@ where\n \n     fn call(&mut self, req: A::Request) -> Self::Future {\n         ThenServiceResponse {\n-            state: State::A(self.0.get_mut().0.call(req), Some(self.0.clone())),\n+            state: State::A(self.0.borrow_mut().0.call(req), Some(self.0.clone())),\n         }\n     }\n }\n@@ -72,7 +72,7 @@ where\n     A: Service,\n     B: Service<Request = Result<A::Response, A::Error>>,\n {\n-    A(#[pin] A::Future, Option<Cell<(A, B)>>),\n+    A(#[pin] A::Future, Option<Rc<RefCell<(A, B)>>>),\n     B(#[pin] B::Future),\n     Empty,\n }\n@@ -90,9 +90,9 @@ where\n         match this.state.as_mut().project() {\n             StateProj::A(fut, b) => match fut.poll(cx) {\n                 Poll::Ready(res) => {\n-                    let mut b = b.take().unwrap();\n+                    let b = b.take().unwrap();\n                     this.state.set(State::Empty); // drop fut A\n-                    let fut = b.get_mut().1.call(res);\n+                    let fut = b.borrow_mut().1.call(res);\n                     this.state.set(State::B(fut));\n                     self.poll(cx)\n                 }\n",
    "diff_parsed": "{'added': [(4, 'use std::cell::RefCell;'), (13, 'pub(crate) struct ThenService<A, B>(Rc<RefCell<(A, B)>>);'), (22, '        Self(Rc::new(RefCell::new((a, b))))'), (43, '        let mut srv = self.0.borrow_mut();'), (54, '            state: State::A(self.0.borrow_mut().0.call(req), Some(self.0.clone())),'), (75, '    A(#[pin] A::Future, Option<Rc<RefCell<(A, B)>>>),'), (93, '                    let b = b.take().unwrap();'), (95, '                    let fut = b.borrow_mut().1.call(res);')], 'deleted': [(7, 'use crate::cell::Cell;'), (13, 'pub(crate) struct ThenService<A, B>(Cell<(A, B)>);'), (22, '        Self(Cell::new((a, b)))'), (43, '        let srv = self.0.get_mut();'), (54, '            state: State::A(self.0.get_mut().0.call(req), Some(self.0.clone())),'), (75, '    A(#[pin] A::Future, Option<Cell<(A, B)>>),'), (93, '                    let mut b = b.take().unwrap();'), (95, '                    let fut = b.get_mut().1.call(res);')]}",
    "num_lines_added": "8",
    "num_lines_deleted": "8",
    "nloc": "296.0"
  },
  {
    "file_change_id": "48101942633990",
    "hash": "f7c378b26e273d237575154800f6c2bd3bf2005",
    "old_path": "crossbeam-utils/src/atomic/atomic_cell.rs",
    "new_path": "crossbeam-utils/src/atomic/atomic_cell.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -465,8 +465,24 @@ macro_rules! impl_arithmetic {\n             /// ```\n             #[inline]\n             pub fn fetch_add(&self, val: $t) -> $t {\n-                let a = unsafe { &*(self.value.get() as *const $atomic) };\n-                a.fetch_add(val, Ordering::AcqRel)\n+                if can_transmute::<$t, $atomic>() {\n+                    let a = unsafe { &*(self.value.get() as *const $atomic) };\n+                    a.fetch_add(val, Ordering::AcqRel)\n+                } else {\n+                    #[cfg(crossbeam_loom)]\n+                    {\n+                        let _ = val;\n+                        unimplemented!(\"loom does not support non-atomic atomic ops\");\n+                    }\n+                    #[cfg(not(crossbeam_loom))]\n+                    {\n+                        let _guard = lock(self.value.get() as usize).write();\n+                        let value = unsafe { &mut *(self.value.get()) };\n+                        let old = *value;\n+                        *value = value.wrapping_add(val);\n+                        old\n+                    }\n+                }\n             }\n \n             /// Decrements the current value by `val` and returns the previous value.\n@@ -485,8 +501,24 @@ macro_rules! impl_arithmetic {\n             /// ```\n             #[inline]\n             pub fn fetch_sub(&self, val: $t) -> $t {\n-                let a = unsafe { &*(self.value.get() as *const $atomic) };\n-                a.fetch_sub(val, Ordering::AcqRel)\n+                if can_transmute::<$t, $atomic>() {\n+                    let a = unsafe { &*(self.value.get() as *const $atomic) };\n+                    a.fetch_sub(val, Ordering::AcqRel)\n+                } else {\n+                    #[cfg(crossbeam_loom)]\n+                    {\n+                        let _ = val;\n+                        unimplemented!(\"loom does not support non-atomic atomic ops\");\n+                    }\n+                    #[cfg(not(crossbeam_loom))]\n+                    {\n+                        let _guard = lock(self.value.get() as usize).write();\n+                        let value = unsafe { &mut *(self.value.get()) };\n+                        let old = *value;\n+                        *value = value.wrapping_sub(val);\n+                        old\n+                    }\n+                }\n             }\n \n             /// Applies bitwise \"and\" to the current value and returns the previous value.\n@@ -503,8 +535,24 @@ macro_rules! impl_arithmetic {\n             /// ```\n             #[inline]\n             pub fn fetch_and(&self, val: $t) -> $t {\n-                let a = unsafe { &*(self.value.get() as *const $atomic) };\n-                a.fetch_and(val, Ordering::AcqRel)\n+                if can_transmute::<$t, $atomic>() {\n+                    let a = unsafe { &*(self.value.get() as *const $atomic) };\n+                    a.fetch_and(val, Ordering::AcqRel)\n+                } else {\n+                    #[cfg(crossbeam_loom)]\n+                    {\n+                        let _ = val;\n+                        unimplemented!(\"loom does not support non-atomic atomic ops\");\n+                    }\n+                    #[cfg(not(crossbeam_loom))]\n+                    {\n+                        let _guard = lock(self.value.get() as usize).write();\n+                        let value = unsafe { &mut *(self.value.get()) };\n+                        let old = *value;\n+                        *value &= val;\n+                        old\n+                    }\n+                }\n             }\n \n             /// Applies bitwise \"or\" to the current value and returns the previous value.\n@@ -521,8 +569,24 @@ macro_rules! impl_arithmetic {\n             /// ```\n             #[inline]\n             pub fn fetch_or(&self, val: $t) -> $t {\n-                let a = unsafe { &*(self.value.get() as *const $atomic) };\n-                a.fetch_or(val, Ordering::AcqRel)\n+                if can_transmute::<$t, $atomic>() {\n+                    let a = unsafe { &*(self.value.get() as *const $atomic) };\n+                    a.fetch_or(val, Ordering::AcqRel)\n+                } else {\n+                    #[cfg(crossbeam_loom)]\n+                    {\n+                        let _ = val;\n+                        unimplemented!(\"loom does not support non-atomic atomic ops\");\n+                    }\n+                    #[cfg(not(crossbeam_loom))]\n+                    {\n+                        let _guard = lock(self.value.get() as usize).write();\n+                        let value = unsafe { &mut *(self.value.get()) };\n+                        let old = *value;\n+                        *value |= val;\n+                        old\n+                    }\n+                }\n             }\n \n             /// Applies bitwise \"xor\" to the current value and returns the previous value.\n@@ -539,8 +603,24 @@ macro_rules! impl_arithmetic {\n             /// ```\n             #[inline]\n             pub fn fetch_xor(&self, val: $t) -> $t {\n-                let a = unsafe { &*(self.value.get() as *const $atomic) };\n-                a.fetch_xor(val, Ordering::AcqRel)\n+                if can_transmute::<$t, $atomic>() {\n+                    let a = unsafe { &*(self.value.get() as *const $atomic) };\n+                    a.fetch_xor(val, Ordering::AcqRel)\n+                } else {\n+                    #[cfg(crossbeam_loom)]\n+                    {\n+                        let _ = val;\n+                        unimplemented!(\"loom does not support non-atomic atomic ops\");\n+                    }\n+                    #[cfg(not(crossbeam_loom))]\n+                    {\n+                        let _guard = lock(self.value.get() as usize).write();\n+                        let value = unsafe { &mut *(self.value.get()) };\n+                        let old = *value;\n+                        *value ^= val;\n+                        old\n+                    }\n+                }\n             }\n         }\n     };\n",
    "diff_parsed": "{'added': [(468, '                if can_transmute::<$t, $atomic>() {'), (469, '                    let a = unsafe { &*(self.value.get() as *const $atomic) };'), (470, '                    a.fetch_add(val, Ordering::AcqRel)'), (471, '                } else {'), (472, '                    #[cfg(crossbeam_loom)]'), (473, '                    {'), (474, '                        let _ = val;'), (475, '                        unimplemented!(\"loom does not support non-atomic atomic ops\");'), (476, '                    }'), (477, '                    #[cfg(not(crossbeam_loom))]'), (478, '                    {'), (479, '                        let _guard = lock(self.value.get() as usize).write();'), (480, '                        let value = unsafe { &mut *(self.value.get()) };'), (481, '                        let old = *value;'), (482, '                        *value = value.wrapping_add(val);'), (483, '                        old'), (484, '                    }'), (485, '                }'), (504, '                if can_transmute::<$t, $atomic>() {'), (505, '                    let a = unsafe { &*(self.value.get() as *const $atomic) };'), (506, '                    a.fetch_sub(val, Ordering::AcqRel)'), (507, '                } else {'), (508, '                    #[cfg(crossbeam_loom)]'), (509, '                    {'), (510, '                        let _ = val;'), (511, '                        unimplemented!(\"loom does not support non-atomic atomic ops\");'), (512, '                    }'), (513, '                    #[cfg(not(crossbeam_loom))]'), (514, '                    {'), (515, '                        let _guard = lock(self.value.get() as usize).write();'), (516, '                        let value = unsafe { &mut *(self.value.get()) };'), (517, '                        let old = *value;'), (518, '                        *value = value.wrapping_sub(val);'), (519, '                        old'), (520, '                    }'), (521, '                }'), (538, '                if can_transmute::<$t, $atomic>() {'), (539, '                    let a = unsafe { &*(self.value.get() as *const $atomic) };'), (540, '                    a.fetch_and(val, Ordering::AcqRel)'), (541, '                } else {'), (542, '                    #[cfg(crossbeam_loom)]'), (543, '                    {'), (544, '                        let _ = val;'), (545, '                        unimplemented!(\"loom does not support non-atomic atomic ops\");'), (546, '                    }'), (547, '                    #[cfg(not(crossbeam_loom))]'), (548, '                    {'), (549, '                        let _guard = lock(self.value.get() as usize).write();'), (550, '                        let value = unsafe { &mut *(self.value.get()) };'), (551, '                        let old = *value;'), (552, '                        *value &= val;'), (553, '                        old'), (554, '                    }'), (555, '                }'), (572, '                if can_transmute::<$t, $atomic>() {'), (573, '                    let a = unsafe { &*(self.value.get() as *const $atomic) };'), (574, '                    a.fetch_or(val, Ordering::AcqRel)'), (575, '                } else {'), (576, '                    #[cfg(crossbeam_loom)]'), (577, '                    {'), (578, '                        let _ = val;'), (579, '                        unimplemented!(\"loom does not support non-atomic atomic ops\");'), (580, '                    }'), (581, '                    #[cfg(not(crossbeam_loom))]'), (582, '                    {'), (583, '                        let _guard = lock(self.value.get() as usize).write();'), (584, '                        let value = unsafe { &mut *(self.value.get()) };'), (585, '                        let old = *value;'), (586, '                        *value |= val;'), (587, '                        old'), (588, '                    }'), (589, '                }'), (606, '                if can_transmute::<$t, $atomic>() {'), (607, '                    let a = unsafe { &*(self.value.get() as *const $atomic) };'), (608, '                    a.fetch_xor(val, Ordering::AcqRel)'), (609, '                } else {'), (610, '                    #[cfg(crossbeam_loom)]'), (611, '                    {'), (612, '                        let _ = val;'), (613, '                        unimplemented!(\"loom does not support non-atomic atomic ops\");'), (614, '                    }'), (615, '                    #[cfg(not(crossbeam_loom))]'), (616, '                    {'), (617, '                        let _guard = lock(self.value.get() as usize).write();'), (618, '                        let value = unsafe { &mut *(self.value.get()) };'), (619, '                        let old = *value;'), (620, '                        *value ^= val;'), (621, '                        old'), (622, '                    }'), (623, '                }')], 'deleted': [(468, '                let a = unsafe { &*(self.value.get() as *const $atomic) };'), (469, '                a.fetch_add(val, Ordering::AcqRel)'), (488, '                let a = unsafe { &*(self.value.get() as *const $atomic) };'), (489, '                a.fetch_sub(val, Ordering::AcqRel)'), (506, '                let a = unsafe { &*(self.value.get() as *const $atomic) };'), (507, '                a.fetch_and(val, Ordering::AcqRel)'), (524, '                let a = unsafe { &*(self.value.get() as *const $atomic) };'), (525, '                a.fetch_or(val, Ordering::AcqRel)'), (542, '                let a = unsafe { &*(self.value.get() as *const $atomic) };'), (543, '                a.fetch_xor(val, Ordering::AcqRel)')]}",
    "num_lines_added": "90",
    "num_lines_deleted": "10",
    "nloc": "548"
  },
  {
    "file_change_id": "83796398166882",
    "hash": "7b5c8fe6b684239213e7e3e9d74c3dfc12599f1",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -377,8 +377,7 @@ impl<T: Float + AddAssign> AddAssign for NotNan<T> {\n /// Panics if the provided value is NaN.\n impl<T: Float + AddAssign> AddAssign<T> for NotNan<T> {\n     fn add_assign(&mut self, other: T) {\n-        self.0 += other;\n-        assert!(!self.0.is_nan(), \"Addition resulted in NaN\");\n+        *self = *self + other;\n     }\n }\n \n@@ -425,8 +424,7 @@ impl<T: Float + SubAssign> SubAssign for NotNan<T> {\n /// Panics if the provided value is NaN or the computation results in NaN\n impl<T: Float + SubAssign> SubAssign<T> for NotNan<T> {\n     fn sub_assign(&mut self, other: T) {\n-        self.0 -= other;\n-        assert!(!self.0.is_nan(), \"Subtraction resulted in NaN\");\n+        *self = *self - other;\n     }\n }\n \n@@ -460,8 +458,7 @@ impl<T: Float + MulAssign> MulAssign for NotNan<T> {\n /// Panics if the provided value is NaN.\n impl<T: Float + MulAssign> MulAssign<T> for NotNan<T> {\n     fn mul_assign(&mut self, other: T) {\n-        self.0 *= other;\n-        assert!(!self.0.is_nan(), \"Multiplication resulted in NaN\");\n+        *self = *self * other;\n     }\n }\n \n@@ -507,8 +504,7 @@ impl<T: Float + DivAssign> DivAssign for NotNan<T> {\n /// Panics if the provided value is NaN or the computation results in NaN\n impl<T: Float + DivAssign> DivAssign<T> for NotNan<T> {\n     fn div_assign(&mut self, other: T) {\n-        self.0 /= other;\n-        assert!(!self.0.is_nan(), \"Division resulted in NaN\");\n+        *self = *self / other;\n     }\n }\n \n@@ -542,8 +538,7 @@ impl<T: Float + RemAssign> RemAssign for NotNan<T> {\n /// Panics if the provided value is NaN or the computation results in NaN\n impl<T: Float + RemAssign> RemAssign<T> for NotNan<T> {\n     fn rem_assign(&mut self, other: T) {\n-        self.0 %= other;\n-        assert!(!self.0.is_nan(), \"Rem resulted in NaN\");\n+        *self = *self % other;\n     }\n }\n \n",
    "diff_parsed": "{'added': [(380, '        *self = *self + other;'), (427, '        *self = *self - other;'), (461, '        *self = *self * other;'), (507, '        *self = *self / other;'), (541, '        *self = *self % other;')], 'deleted': [(380, '        self.0 += other;'), (381, '        assert!(!self.0.is_nan(), \"Addition resulted in NaN\");'), (428, '        self.0 -= other;'), (429, '        assert!(!self.0.is_nan(), \"Subtraction resulted in NaN\");'), (463, '        self.0 *= other;'), (464, '        assert!(!self.0.is_nan(), \"Multiplication resulted in NaN\");'), (510, '        self.0 /= other;'), (511, '        assert!(!self.0.is_nan(), \"Division resulted in NaN\");'), (545, '        self.0 %= other;'), (546, '        assert!(!self.0.is_nan(), \"Rem resulted in NaN\");')]}",
    "num_lines_added": "5",
    "num_lines_deleted": "10",
    "nloc": "585"
  },
  {
    "file_change_id": "150138335324731",
    "hash": "7b5c8fe6b684239213e7e3e9d74c3dfc12599f1",
    "old_path": "tests/test.rs",
    "new_path": "tests/test.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -590,3 +590,18 @@ fn not_nan_usage_in_const_context() {\n     const A: NotNan<f32> = unsafe { NotNan::unchecked_new(111f32) };\n     assert_eq!(A, NotNan::new(111f32).unwrap());\n }\n+\n+#[test]\n+fn not_nan_panic_safety() {\n+    let catch_op = |mut num, op: fn(&mut NotNan<_>)| {\n+        let mut num_ref = panic::AssertUnwindSafe(&mut num);\n+        let _ = panic::catch_unwind(move || op(*num_ref));\n+        num\n+    };\n+\n+    assert!(!catch_op(not_nan(f32::INFINITY), |a| *a += f32::NEG_INFINITY).is_nan());\n+    assert!(!catch_op(not_nan(f32::INFINITY), |a| *a -= f32::INFINITY).is_nan());\n+    assert!(!catch_op(not_nan(0.0), |a| *a *= f32::INFINITY).is_nan());\n+    assert!(!catch_op(not_nan(0.0), |a| *a /= 0.0).is_nan());\n+    assert!(!catch_op(not_nan(0.0), |a| *a %= 0.0).is_nan());\n+}\n",
    "diff_parsed": "{'added': [(594, '#[test]'), (595, 'fn not_nan_panic_safety() {'), (596, '    let catch_op = |mut num, op: fn(&mut NotNan<_>)| {'), (597, '        let mut num_ref = panic::AssertUnwindSafe(&mut num);'), (598, '        let _ = panic::catch_unwind(move || op(*num_ref));'), (599, '        num'), (600, '    };'), (602, '    assert!(!catch_op(not_nan(f32::INFINITY), |a| *a += f32::NEG_INFINITY).is_nan());'), (603, '    assert!(!catch_op(not_nan(f32::INFINITY), |a| *a -= f32::INFINITY).is_nan());'), (604, '    assert!(!catch_op(not_nan(0.0), |a| *a *= f32::INFINITY).is_nan());'), (605, '    assert!(!catch_op(not_nan(0.0), |a| *a /= 0.0).is_nan());'), (606, '    assert!(!catch_op(not_nan(0.0), |a| *a %= 0.0).is_nan());'), (607, '}')], 'deleted': []}",
    "num_lines_added": "13",
    "num_lines_deleted": "0",
    "nloc": "537"
  },
  {
    "file_change_id": "202954485020623",
    "hash": "15cb335e66d518a25950ff40906676f982b64a2",
    "old_path": "openssl/src/cms.rs",
    "new_path": "openssl/src/cms.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -138,22 +138,14 @@ impl CmsContentInfo {\n         flags: CMSOptions,\n     ) -> Result<CmsContentInfo, ErrorStack> {\n         unsafe {\n-            let signcert = match signcert {\n-                Some(cert) => cert.as_ptr(),\n-                None => ptr::null_mut(),\n-            };\n-            let pkey = match pkey {\n-                Some(pkey) => pkey.as_ptr(),\n-                None => ptr::null_mut(),\n-            };\n-            let data_bio_ptr = match data {\n-                Some(data) => MemBioSlice::new(data)?.as_ptr(),\n-                None => ptr::null_mut(),\n-            };\n-            let certs = match certs {\n-                Some(certs) => certs.as_ptr(),\n-                None => ptr::null_mut(),\n+            let signcert = signcert.map_or(ptr::null_mut(), |p| p.as_ptr());\n+            let pkey = pkey.map_or(ptr::null_mut(), |p| p.as_ptr());\n+            let data_bio = match data {\n+                Some(data) => Some(MemBioSlice::new(data)?),\n+                None => None,\n             };\n+            let data_bio_ptr = data_bio.as_ref().map_or(ptr::null_mut(), |p| p.as_ptr());\n+            let certs = certs.map_or(ptr::null_mut(), |p| p.as_ptr());\n \n             let cms = cvt_p(ffi::CMS_sign(\n                 signcert,\n",
    "diff_parsed": "{'added': [(141, '            let signcert = signcert.map_or(ptr::null_mut(), |p| p.as_ptr());'), (142, '            let pkey = pkey.map_or(ptr::null_mut(), |p| p.as_ptr());'), (143, '            let data_bio = match data {'), (144, '                Some(data) => Some(MemBioSlice::new(data)?),'), (145, '                None => None,'), (147, '            let data_bio_ptr = data_bio.as_ref().map_or(ptr::null_mut(), |p| p.as_ptr());'), (148, '            let certs = certs.map_or(ptr::null_mut(), |p| p.as_ptr());')], 'deleted': [(141, '            let signcert = match signcert {'), (142, '                Some(cert) => cert.as_ptr(),'), (143, '                None => ptr::null_mut(),'), (144, '            };'), (145, '            let pkey = match pkey {'), (146, '                Some(pkey) => pkey.as_ptr(),'), (147, '                None => ptr::null_mut(),'), (148, '            };'), (149, '            let data_bio_ptr = match data {'), (150, '                Some(data) => MemBioSlice::new(data)?.as_ptr(),'), (151, '                None => ptr::null_mut(),'), (152, '            };'), (153, '            let certs = match certs {'), (154, '                Some(certs) => certs.as_ptr(),'), (155, '                None => ptr::null_mut(),')]}",
    "num_lines_added": "7",
    "num_lines_deleted": "15",
    "nloc": "105"
  },
  {
    "file_change_id": "142126349901587",
    "hash": "dde31d26fd7b8ea23fbcb2928583a7882748e65",
    "old_path": "pnet_macros/src/decorator.rs",
    "new_path": "pnet_macros/src/decorator.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -657,14 +657,10 @@ fn handle_vec_primitive(\n         };\n \n         let copy_vals = if inner_ty_str == \"u8\" {\n-            // Efficient copy_nonoverlapping (memcpy)\n+            // Efficient copy_from_slice (memcpy)\n             format!(\"\n-                                    // &mut and & can never overlap\n-                                    unsafe {{\n-                                        copy_nonoverlapping(vals[..].as_ptr(),\n-                                                            _self.packet[current_offset..].as_mut_ptr(),\n-                                                            vals.len())\n-                                    }}\n+                                    _self.packet[current_offset..current_offset + vals.len()]\n+                                        .copy_from_slice(vals);\n                                 \")\n         } else {\n             // e.g. Vec<u16> -> Vec<u8>\n@@ -689,7 +685,6 @@ fn handle_vec_primitive(\n                                 #[allow(trivial_numeric_casts)]\n                                 #[cfg_attr(feature = \\\"clippy\\\", allow(used_underscore_binding))]\n                                 pub fn set_{name}(&mut self, vals: &[{inner_ty_str}]) {{\n-                                    use std::ptr::copy_nonoverlapping;\n                                     let mut _self = self;\n                                     let current_offset = {co};\n \n",
    "diff_parsed": "{'added': [(662, '                                    _self.packet[current_offset..current_offset + vals.len()]'), (663, '                                        .copy_from_slice(vals);')], 'deleted': [(663, '                                    unsafe {{'), (664, '                                        copy_nonoverlapping(vals[..].as_ptr(),'), (665, '                                                            _self.packet[current_offset..].as_mut_ptr(),'), (666, '                                                            vals.len())'), (667, '                                    }}'), (692, '                                    use std::ptr::copy_nonoverlapping;')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "6",
    "nloc": "1553.0"
  },
  {
    "file_change_id": "202225073970533",
    "hash": "dde31d26fd7b8ea23fbcb2928583a7882748e65",
    "old_path": "pnet_packet/src/ipv4.rs.in",
    "new_path": "pnet_packet/src/ipv4.rs.in",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -378,3 +378,27 @@ fn ipv4_packet_option_test() {\n \n     assert_eq!(&ref_packet[..], &packet[..]);\n }\n+\n+#[test]\n+fn ipv4_packet_set_payload_test() {\n+    use Packet;\n+\n+    let mut packet = [0u8; 25]; // allow 20 byte header and 5 byte payload\n+    let mut ip_packet = MutableIpv4Packet::new(&mut packet[..]).unwrap();\n+    ip_packet.set_total_length(25);\n+    ip_packet.set_header_length(5);\n+    let payload = b\"stuff\"; // 5 bytes\n+    ip_packet.set_payload(&payload[..]);\n+    assert_eq!(ip_packet.payload(), payload);\n+}\n+\n+#[test]\n+#[should_panic(expected = \"index 25 out of range for slice of length 24\")]\n+fn ipv4_packet_set_payload_test_panic() {\n+    let mut packet = [0u8; 24]; // allow 20 byte header and 4 byte payload\n+    let mut ip_packet = MutableIpv4Packet::new(&mut packet[..]).unwrap();\n+    ip_packet.set_total_length(25);\n+    ip_packet.set_header_length(5);\n+    let payload = b\"stuff\"; // 5 bytes\n+    ip_packet.set_payload(&payload[..]); // panic\n+}\n",
    "diff_parsed": "{'added': [(382, '#[test]'), (383, 'fn ipv4_packet_set_payload_test() {'), (384, '    use Packet;'), (386, '    let mut packet = [0u8; 25]; // allow 20 byte header and 5 byte payload'), (387, '    let mut ip_packet = MutableIpv4Packet::new(&mut packet[..]).unwrap();'), (388, '    ip_packet.set_total_length(25);'), (389, '    ip_packet.set_header_length(5);'), (390, '    let payload = b\"stuff\"; // 5 bytes'), (391, '    ip_packet.set_payload(&payload[..]);'), (392, '    assert_eq!(ip_packet.payload(), payload);'), (393, '}'), (395, '#[test]'), (396, '#[should_panic(expected = \"index 25 out of range for slice of length 24\")]'), (397, 'fn ipv4_packet_set_payload_test_panic() {'), (398, '    let mut packet = [0u8; 24]; // allow 20 byte header and 4 byte payload'), (399, '    let mut ip_packet = MutableIpv4Packet::new(&mut packet[..]).unwrap();'), (400, '    ip_packet.set_total_length(25);'), (401, '    ip_packet.set_header_length(5);'), (402, '    let payload = b\"stuff\"; // 5 bytes'), (403, '    ip_packet.set_payload(&payload[..]); // panic'), (404, '}')], 'deleted': []}",
    "num_lines_added": "21",
    "num_lines_deleted": "0",
    "nloc": "nan"
  },
  {
    "file_change_id": "123884456341153",
    "hash": "7d13cc67dbe94ab0340e2a492c489dc16815300",
    "old_path": "src/vector/focus.rs",
    "new_path": "src/vector/focus.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -279,10 +279,10 @@ impl<A> Clone for TreeFocus<A> {\n \n #[allow(unsafe_code)]\n #[cfg(threadsafe)]\n-unsafe impl<A> Send for TreeFocus<A> {}\n+unsafe impl<A: Send> Send for TreeFocus<A> {}\n #[allow(unsafe_code)]\n #[cfg(threadsafe)]\n-unsafe impl<A> Sync for TreeFocus<A> {}\n+unsafe impl<A: Sync> Sync for TreeFocus<A> {}\n \n #[inline]\n fn contains<A: Ord>(range: &Range<A>, index: &A) -> bool {\n",
    "diff_parsed": "{'added': [(282, 'unsafe impl<A: Send> Send for TreeFocus<A> {}'), (285, 'unsafe impl<A: Sync> Sync for TreeFocus<A> {}')], 'deleted': [(282, 'unsafe impl<A> Send for TreeFocus<A> {}'), (285, 'unsafe impl<A> Sync for TreeFocus<A> {}')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "589"
  },
  {
    "file_change_id": "22405286808640",
    "hash": "623b87397a569729c4bcabae747823c5668cce9",
    "old_path": "src/common.rs",
    "new_path": "src/common.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -239,7 +239,7 @@ impl FromStr for HeaderField {\n     type Err = ();\n \n     fn from_str(s: &str) -> Result<HeaderField, ()> {\n-        AsciiString::from_ascii(s.trim())\n+        AsciiString::from_ascii(s)\n             .map(HeaderField)\n             .map_err(|_| ())\n     }\n",
    "diff_parsed": "{'added': [(242, '        AsciiString::from_ascii(s)')], 'deleted': [(242, '        AsciiString::from_ascii(s.trim())')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "403"
  },
  {
    "file_change_id": "185644328225116",
    "hash": "d4133288261612d43853245aa886e1a3a0d2dbf",
    "old_path": "diesel/src/sqlite/connection/statement_iterator.rs",
    "new_path": "diesel/src/sqlite/connection/statement_iterator.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -42,28 +42,35 @@ where\n \n pub struct NamedStatementIterator<'a, T> {\n     stmt: StatementUse<'a>,\n-    column_indices: HashMap<&'a str, usize>,\n+    column_indices: Option<HashMap<&'a str, usize>>,\n     _marker: PhantomData<T>,\n }\n \n impl<'a, T> NamedStatementIterator<'a, T> {\n     #[allow(clippy::new_ret_no_self)]\n     pub fn new(stmt: StatementUse<'a>) -> QueryResult<Self> {\n-        let column_indices = (0..stmt.num_fields())\n+        Ok(NamedStatementIterator {\n+            stmt,\n+            column_indices: None,\n+            _marker: PhantomData,\n+        })\n+    }\n+\n+    fn populate_column_indices(&mut self) -> QueryResult<()> {\n+        let column_indices = (0..self.stmt.num_fields())\n             .filter_map(|i| {\n-                stmt.field_name(i).map(|column| {\n-                    let column = column\n-                        .to_str()\n+                dbg!(i);\n+                dbg!(self.stmt.field_name(i)).map(|column| {\n+                    let column = dbg!(column\n+                        .to_str())\n                         .map_err(|e| DeserializationError(e.into()))?;\n                     Ok((column, i))\n                 })\n             })\n             .collect::<QueryResult<_>>()?;\n-        Ok(NamedStatementIterator {\n-            stmt,\n-            column_indices,\n-            _marker: PhantomData,\n-        })\n+\n+        self.column_indices = Some(column_indices);\n+        Ok(())\n     }\n }\n \n@@ -78,8 +85,13 @@ where\n             Ok(row) => row,\n             Err(e) => return Some(Err(e)),\n         };\n+        if self.column_indices.is_none() {\n+            if let Err(e) = self.populate_column_indices() {\n+                return Some(Err(e));\n+            }\n+        }\n         row.map(|row| {\n-            let row = row.into_named(&self.column_indices);\n+            let row = row.into_named(self.column_indices.as_ref().expect(\"it's there because we populated it above\"));\n             T::build(&row).map_err(DeserializationError)\n         })\n     }\n",
    "diff_parsed": "{'added': [(45, \"    column_indices: Option<HashMap<&'a str, usize>>,\"), (52, '        Ok(NamedStatementIterator {'), (53, '            stmt,'), (54, '            column_indices: None,'), (55, '            _marker: PhantomData,'), (56, '        })'), (57, '    }'), (59, '    fn populate_column_indices(&mut self) -> QueryResult<()> {'), (60, '        let column_indices = (0..self.stmt.num_fields())'), (62, '                dbg!(i);'), (63, '                dbg!(self.stmt.field_name(i)).map(|column| {'), (64, '                    let column = dbg!(column'), (65, '                        .to_str())'), (72, '        self.column_indices = Some(column_indices);'), (73, '        Ok(())'), (88, '        if self.column_indices.is_none() {'), (89, '            if let Err(e) = self.populate_column_indices() {'), (90, '                return Some(Err(e));'), (91, '            }'), (92, '        }'), (94, '            let row = row.into_named(self.column_indices.as_ref().expect(\"it\\'s there because we populated it above\"));')], 'deleted': [(45, \"    column_indices: HashMap<&'a str, usize>,\"), (52, '        let column_indices = (0..stmt.num_fields())'), (54, '                stmt.field_name(i).map(|column| {'), (55, '                    let column = column'), (56, '                        .to_str()'), (62, '        Ok(NamedStatementIterator {'), (63, '            stmt,'), (64, '            column_indices,'), (65, '            _marker: PhantomData,'), (66, '        })'), (82, '            let row = row.into_named(&self.column_indices);')]}",
    "num_lines_added": "21",
    "num_lines_deleted": "11",
    "nloc": "94"
  },
  {
    "file_change_id": "234784853336954",
    "hash": "d61b49cb90391fc4f7f72a1abe597476c8651a0",
    "old_path": "src/scanner.rs",
    "new_path": "src/scanner.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -149,7 +149,7 @@ pub struct Scanner<T> {\n     simple_keys: Vec<SimpleKey>,\n     indent: isize,\n     indents: Vec<isize>,\n-    flow_level: usize,\n+    flow_level: u8,\n     tokens_parsed: usize,\n     token_available: bool,\n }\n@@ -906,7 +906,7 @@ impl<T: Iterator<Item=char>> Scanner<T> {\n         // The indicators '[' and '{' may start a simple key.\n         try!(self.save_simple_key());\n \n-        self.increase_flow_level();\n+        self.increase_flow_level()?;\n \n         self.allow_simple_key();\n \n@@ -941,9 +941,11 @@ impl<T: Iterator<Item=char>> Scanner<T> {\n         Ok(())\n     }\n \n-    fn increase_flow_level(&mut self) {\n+    fn increase_flow_level(&mut self) -> ScanResult {\n         self.simple_keys.push(SimpleKey::new(Marker::new(0,0,0)));\n-        self.flow_level += 1;\n+        self.flow_level = self.flow_level.checked_add(1)\n+            .ok_or_else(|| ScanError::new(self.mark, \"Recursion limit exceeded\"))?;\n+        Ok(())\n     }\n     fn decrease_flow_level(&mut self) {\n         if self.flow_level > 0 {\n",
    "diff_parsed": "{'added': [(152, '    flow_level: u8,'), (909, '        self.increase_flow_level()?;'), (944, '    fn increase_flow_level(&mut self) -> ScanResult {'), (946, '        self.flow_level = self.flow_level.checked_add(1)'), (947, '            .ok_or_else(|| ScanError::new(self.mark, \"Recursion limit exceeded\"))?;'), (948, '        Ok(())')], 'deleted': [(152, '    flow_level: usize,'), (909, '        self.increase_flow_level();'), (944, '    fn increase_flow_level(&mut self) {'), (946, '        self.flow_level += 1;')]}",
    "num_lines_added": "6",
    "num_lines_deleted": "4",
    "nloc": "1685"
  },
  {
    "file_change_id": "150171384498168",
    "hash": "d61b49cb90391fc4f7f72a1abe597476c8651a0",
    "old_path": "src/yaml.rs",
    "new_path": "src/yaml.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -638,4 +638,16 @@ c: ~\n         let first = out.into_iter().next().unwrap();\n         assert_eq!(first[0][\"important\"].as_bool().unwrap(), true);\n     }\n+\n+    #[test]\n+    fn test_recursion_depth_check_objects() {\n+        let s = \"{a:\".repeat(10_000) + &\"}\".repeat(10_000);\n+        assert!(YamlLoader::load_from_str(&s).is_err());\n+    }\n+\n+    #[test]\n+    fn test_recursion_depth_check_arrays() {\n+        let s = \"[\".repeat(10_000) + &\"]\".repeat(10_000);\n+        assert!(YamlLoader::load_from_str(&s).is_err());\n+    }\n }\n",
    "diff_parsed": "{'added': [(642, '    #[test]'), (643, '    fn test_recursion_depth_check_objects() {'), (644, '        let s = \"{a:\".repeat(10_000) + &\"}\".repeat(10_000);'), (645, '        assert!(YamlLoader::load_from_str(&s).is_err());'), (646, '    }'), (648, '    #[test]'), (649, '    fn test_recursion_depth_check_arrays() {'), (650, '        let s = \"[\".repeat(10_000) + &\"]\".repeat(10_000);'), (651, '        assert!(YamlLoader::load_from_str(&s).is_err());'), (652, '    }')], 'deleted': []}",
    "num_lines_added": "10",
    "num_lines_deleted": "0",
    "nloc": "565"
  },
  {
    "file_change_id": "108337886029679",
    "hash": "86354da6f5ea3af009c42331dc20c9a717fe980",
    "old_path": "examples/tests-loader/src/generators/rust.rs",
    "new_path": "examples/tests-loader/src/generators/rust.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -220,6 +220,15 @@ impl GenTest for types::Vector {\n                     .build();\n                 let expected = #name::from_slice(#expected).unwrap();\n                 #assert_stmt\n+                assert_eq!(\n+                    result.total_size(),\n+                    result.as_slice().len(),\n+                    \"\\nstruct: {}:\\n  data: {:#x}\\n  partial read total_size: {}, actual: {}\\n\",\n+                    #name::NAME,\n+                    result,\n+                    result.total_size(),\n+                    result.as_slice().len()\n+                );\n             }\n         );\n         vec![test]\n",
    "diff_parsed": "{'added': [(223, '                assert_eq!('), (224, '                    result.total_size(),'), (225, '                    result.as_slice().len(),'), (226, '                    \"\\\\nstruct: {}:\\\\n  data: {:#x}\\\\n  partial read total_size: {}, actual: {}\\\\n\",'), (227, '                    #name::NAME,'), (228, '                    result,'), (229, '                    result.total_size(),'), (230, '                    result.as_slice().len()'), (231, '                );')], 'deleted': []}",
    "num_lines_added": "9",
    "num_lines_deleted": "0",
    "nloc": "223"
  },
  {
    "file_change_id": "50597248076082",
    "hash": "86354da6f5ea3af009c42331dc20c9a717fe980",
    "old_path": "tools/codegen/src/generator/languages/rust/properties.rs",
    "new_path": "tools/codegen/src/generator/languages/rust/properties.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -47,7 +47,7 @@ impl DefProperties for ast::FixVec {\n     fn def_properties(&self) -> m4::TokenStream {\n         quote!(\n             pub fn total_size(&self) -> usize {\n-                molecule::NUMBER_SIZE * (self.item_count() + 1)\n+                molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()\n             }\n             pub fn item_count(&self) -> usize {\n                 molecule::unpack_number(self.as_slice()) as usize\n",
    "diff_parsed": "{'added': [(50, '                molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()')], 'deleted': [(50, '                molecule::NUMBER_SIZE * (self.item_count() + 1)')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "103"
  },
  {
    "file_change_id": "139487117312276",
    "hash": "18e3cc6b1f611809eed260b05797e2b488157ac",
    "old_path": "src/download.rs",
    "new_path": "src/download.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -170,12 +170,13 @@ fn check_image_and_sig(\n         .with_context(|| format!(\"opening {}\", path.display()))?;\n \n     // perform GPG verification\n-    let mut reader = GpgReader::new(\n+    let mut reader = VerifyReader::new(\n         BufReader::with_capacity(BUFFER_SIZE, &mut file),\n-        signature,\n+        Some(signature),\n         keys,\n     )?;\n     copy(&mut reader, &mut io::sink())?;\n+    reader.verify()?;\n \n     Ok(())\n }\n@@ -241,16 +242,14 @@ pub fn write_image<F>(\n where\n     F: FnOnce(&[u8], &mut dyn Read, &mut File, &Path, Option<&SavedPartitions>) -> Result<()>,\n {\n-    let mut reader: Box<dyn Read> = Box::new(&mut source.reader);\n-\n-    // wrap source for GPG verification\n-    if let Some(signature) = source.signature.as_ref() {\n-        reader = Box::new(GpgReader::new(reader, signature, keys)?);\n-    }\n+    // wrap source for signature verification, if available\n+    // keep the reader so we can explicitly check the result afterward\n+    let mut verify_reader =\n+        VerifyReader::new(&mut source.reader, source.signature.as_deref(), keys)?;\n \n     // wrap again for progress reporting\n-    reader = Box::new(ProgressReader::new(\n-        reader,\n+    let mut reader: Box<dyn Read> = Box::new(ProgressReader::new(\n+        &mut verify_reader,\n         source.length_hint,\n         &source.artifact_type,\n     ));\n@@ -297,6 +296,10 @@ where\n     // call the callback to copy the image\n     image_copy(&first_mb, &mut reader, dest, dest_path, saved)?;\n \n+    // check signature\n+    drop(reader);\n+    verify_reader.verify()?;\n+\n     // finish I/O before closing the progress bar\n     dest.sync_all().context(\"syncing data to disk\")?;\n \n@@ -517,6 +520,11 @@ mod tests {\n             &include_bytes!(\"../fixtures/verify/1M.sig\")[..],\n             &[0; 1 << 20][..],\n         );\n+        test_one_signed_file(\n+            &include_bytes!(\"../fixtures/verify/1M.gz\")[..],\n+            &include_bytes!(\"../fixtures/verify/1M.gz.sig\")[..],\n+            &[0; 1 << 20][..],\n+        );\n         test_one_signed_file(\n             &include_bytes!(\"../fixtures/verify/1M.xz\")[..],\n             &include_bytes!(\"../fixtures/verify/1M.xz.sig\")[..],\n",
    "diff_parsed": "{'added': [(173, '    let mut reader = VerifyReader::new('), (175, '        Some(signature),'), (179, '    reader.verify()?;'), (247, '    let mut verify_reader ='), (248, '        VerifyReader::new(&mut source.reader, source.signature.as_deref(), keys)?;'), (251, '    let mut reader: Box<dyn Read> = Box::new(ProgressReader::new('), (252, '        &mut verify_reader,'), (300, '    drop(reader);'), (301, '    verify_reader.verify()?;'), (523, '        test_one_signed_file('), (524, '            &include_bytes!(\"../fixtures/verify/1M.gz\")[..],'), (525, '            &include_bytes!(\"../fixtures/verify/1M.gz.sig\")[..],'), (526, '            &[0; 1 << 20][..],'), (527, '        );')], 'deleted': [(173, '    let mut reader = GpgReader::new('), (175, '        signature,'), (244, '    let mut reader: Box<dyn Read> = Box::new(&mut source.reader);'), (247, '    if let Some(signature) = source.signature.as_ref() {'), (248, '        reader = Box::new(GpgReader::new(reader, signature, keys)?);'), (249, '    }'), (252, '    reader = Box::new(ProgressReader::new('), (253, '        reader,')]}",
    "num_lines_added": "14",
    "num_lines_deleted": "8",
    "nloc": "613"
  },
  {
    "file_change_id": "280928881995059",
    "hash": "18e3cc6b1f611809eed260b05797e2b488157ac",
    "old_path": "src/io/verify.rs",
    "new_path": "src/io/verify.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -37,7 +37,46 @@ enum VerifyReport {\n     Ignore,\n }\n \n-pub struct GpgReader<R: Read> {\n+pub struct VerifyReader<R: Read> {\n+    typ: VerifyType<R>,\n+}\n+\n+enum VerifyType<R: Read> {\n+    None(R),\n+    Gpg(GpgReader<R>),\n+}\n+\n+impl<R: Read> VerifyReader<R> {\n+    pub fn new(source: R, gpg_signature: Option<&[u8]>, keys: VerifyKeys) -> Result<Self> {\n+        let typ = if let Some(signature) = gpg_signature {\n+            VerifyType::Gpg(GpgReader::new(source, signature, keys)?)\n+        } else {\n+            VerifyType::None(source)\n+        };\n+        Ok(VerifyReader { typ })\n+    }\n+\n+    /// Return an error if signature verification fails, and report the\n+    /// result to stderr\n+    pub fn verify(&mut self) -> Result<()> {\n+        match &mut self.typ {\n+            VerifyType::None(_) => (),\n+            VerifyType::Gpg(reader) => reader.finish(VerifyReport::Stderr)?,\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl<R: Read> Read for VerifyReader<R> {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        match &mut self.typ {\n+            VerifyType::None(reader) => reader.read(buf),\n+            VerifyType::Gpg(reader) => reader.read(buf),\n+        }\n+    }\n+}\n+\n+struct GpgReader<R: Read> {\n     _gpgdir: TempDir,\n     source: R,\n     child: Child,\n@@ -45,7 +84,7 @@ pub struct GpgReader<R: Read> {\n }\n \n impl<R: Read> GpgReader<R> {\n-    pub fn new(source: R, signature: &[u8], keys: VerifyKeys) -> Result<Self> {\n+    fn new(source: R, signature: &[u8], keys: VerifyKeys) -> Result<Self> {\n         // create GPG home directory with restrictive mode\n         let gpgdir = tempfile::Builder::new()\n             .prefix(\"coreos-installer-\")\n@@ -235,9 +274,6 @@ impl<R: Read> Read for GpgReader<R> {\n                 .as_mut()\n                 .unwrap()\n                 .write_all(&buf[0..count])?;\n-        } else {\n-            // end of input; check result\n-            self.finish(VerifyReport::Stderr)?;\n         }\n         Ok(count)\n     }\n@@ -261,11 +297,12 @@ mod tests {\n         let data = include_bytes!(\"../../fixtures/verify/test-key.priv.asc\");\n         let sig = include_bytes!(\"../../fixtures/verify/test-key.priv.asc.sig\");\n \n-        let mut reader = GpgReader::new(&data[..], &sig[..], VerifyKeys::InsecureTest).unwrap();\n+        let mut reader =\n+            VerifyReader::new(&data[..], Some(&sig[..]), VerifyKeys::InsecureTest).unwrap();\n         let mut buf = Vec::new();\n         reader.read_to_end(&mut buf).unwrap();\n-        reader.finish(VerifyReport::Stderr).unwrap();\n-        reader.finish(VerifyReport::Stderr).unwrap();\n+        reader.verify().unwrap();\n+        reader.verify().unwrap();\n         assert_eq!(&buf[..], &data[..]);\n     }\n \n@@ -276,11 +313,13 @@ mod tests {\n         let sig = include_bytes!(\"../../fixtures/verify/test-key.priv.asc.sig\");\n         data[data.len() - 1] = b'!';\n \n-        let mut reader = GpgReader::new(&data[..], &sig[..], VerifyKeys::InsecureTest).unwrap();\n+        let mut reader =\n+            VerifyReader::new(&data[..], Some(&sig[..]), VerifyKeys::InsecureTest).unwrap();\n         let mut buf = Vec::new();\n-        reader.read_to_end(&mut buf).unwrap_err();\n-        reader.finish(VerifyReport::Stderr).unwrap_err();\n-        reader.finish(VerifyReport::Stderr).unwrap_err();\n+        reader.read_to_end(&mut buf).unwrap();\n+        reader.verify().unwrap_err();\n+        reader.verify().unwrap_err();\n+        assert_eq!(&buf[..], &data[..]);\n     }\n \n     /// Read truncated data with otherwise-valid signature\n@@ -289,11 +328,13 @@ mod tests {\n         let data = include_bytes!(\"../../fixtures/verify/test-key.priv.asc\");\n         let sig = include_bytes!(\"../../fixtures/verify/test-key.priv.asc.sig\");\n \n-        let mut reader = GpgReader::new(&data[..1000], &sig[..], VerifyKeys::InsecureTest).unwrap();\n+        let mut reader =\n+            VerifyReader::new(&data[..1000], Some(&sig[..]), VerifyKeys::InsecureTest).unwrap();\n         let mut buf = Vec::new();\n-        reader.read_to_end(&mut buf).unwrap_err();\n-        reader.finish(VerifyReport::Stderr).unwrap_err();\n-        reader.finish(VerifyReport::Stderr).unwrap_err();\n+        reader.read_to_end(&mut buf).unwrap();\n+        reader.verify().unwrap_err();\n+        reader.verify().unwrap_err();\n+        assert_eq!(&buf[..], &data[..1000]);\n     }\n \n     /// Read data with signing key not in keyring\n@@ -302,10 +343,12 @@ mod tests {\n         let data = include_bytes!(\"../../fixtures/verify/test-key.priv.asc\");\n         let sig = include_bytes!(\"../../fixtures/verify/test-key.priv.asc.random.sig\");\n \n-        let mut reader = GpgReader::new(&data[..], &sig[..], VerifyKeys::InsecureTest).unwrap();\n+        let mut reader =\n+            VerifyReader::new(&data[..], Some(&sig[..]), VerifyKeys::InsecureTest).unwrap();\n         let mut buf = Vec::new();\n-        reader.read_to_end(&mut buf).unwrap_err();\n-        reader.finish(VerifyReport::Stderr).unwrap_err();\n-        reader.finish(VerifyReport::Stderr).unwrap_err();\n+        reader.read_to_end(&mut buf).unwrap();\n+        reader.verify().unwrap_err();\n+        reader.verify().unwrap_err();\n+        assert_eq!(&buf[..], &data[..]);\n     }\n }\n",
    "diff_parsed": "{'added': [(40, 'pub struct VerifyReader<R: Read> {'), (41, '    typ: VerifyType<R>,'), (42, '}'), (44, 'enum VerifyType<R: Read> {'), (45, '    None(R),'), (46, '    Gpg(GpgReader<R>),'), (47, '}'), (49, 'impl<R: Read> VerifyReader<R> {'), (50, '    pub fn new(source: R, gpg_signature: Option<&[u8]>, keys: VerifyKeys) -> Result<Self> {'), (51, '        let typ = if let Some(signature) = gpg_signature {'), (52, '            VerifyType::Gpg(GpgReader::new(source, signature, keys)?)'), (53, '        } else {'), (54, '            VerifyType::None(source)'), (55, '        };'), (56, '        Ok(VerifyReader { typ })'), (57, '    }'), (61, '    pub fn verify(&mut self) -> Result<()> {'), (62, '        match &mut self.typ {'), (63, '            VerifyType::None(_) => (),'), (64, '            VerifyType::Gpg(reader) => reader.finish(VerifyReport::Stderr)?,'), (65, '        }'), (66, '        Ok(())'), (67, '    }'), (68, '}'), (70, 'impl<R: Read> Read for VerifyReader<R> {'), (71, '    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {'), (72, '        match &mut self.typ {'), (73, '            VerifyType::None(reader) => reader.read(buf),'), (74, '            VerifyType::Gpg(reader) => reader.read(buf),'), (75, '        }'), (76, '    }'), (77, '}'), (79, 'struct GpgReader<R: Read> {'), (87, '    fn new(source: R, signature: &[u8], keys: VerifyKeys) -> Result<Self> {'), (300, '        let mut reader ='), (301, '            VerifyReader::new(&data[..], Some(&sig[..]), VerifyKeys::InsecureTest).unwrap();'), (304, '        reader.verify().unwrap();'), (305, '        reader.verify().unwrap();'), (316, '        let mut reader ='), (317, '            VerifyReader::new(&data[..], Some(&sig[..]), VerifyKeys::InsecureTest).unwrap();'), (319, '        reader.read_to_end(&mut buf).unwrap();'), (320, '        reader.verify().unwrap_err();'), (321, '        reader.verify().unwrap_err();'), (322, '        assert_eq!(&buf[..], &data[..]);'), (331, '        let mut reader ='), (332, '            VerifyReader::new(&data[..1000], Some(&sig[..]), VerifyKeys::InsecureTest).unwrap();'), (334, '        reader.read_to_end(&mut buf).unwrap();'), (335, '        reader.verify().unwrap_err();'), (336, '        reader.verify().unwrap_err();'), (337, '        assert_eq!(&buf[..], &data[..1000]);'), (346, '        let mut reader ='), (347, '            VerifyReader::new(&data[..], Some(&sig[..]), VerifyKeys::InsecureTest).unwrap();'), (349, '        reader.read_to_end(&mut buf).unwrap();'), (350, '        reader.verify().unwrap_err();'), (351, '        reader.verify().unwrap_err();'), (352, '        assert_eq!(&buf[..], &data[..]);')], 'deleted': [(40, 'pub struct GpgReader<R: Read> {'), (48, '    pub fn new(source: R, signature: &[u8], keys: VerifyKeys) -> Result<Self> {'), (238, '        } else {'), (240, '            self.finish(VerifyReport::Stderr)?;'), (264, '        let mut reader = GpgReader::new(&data[..], &sig[..], VerifyKeys::InsecureTest).unwrap();'), (267, '        reader.finish(VerifyReport::Stderr).unwrap();'), (268, '        reader.finish(VerifyReport::Stderr).unwrap();'), (279, '        let mut reader = GpgReader::new(&data[..], &sig[..], VerifyKeys::InsecureTest).unwrap();'), (281, '        reader.read_to_end(&mut buf).unwrap_err();'), (282, '        reader.finish(VerifyReport::Stderr).unwrap_err();'), (283, '        reader.finish(VerifyReport::Stderr).unwrap_err();'), (292, '        let mut reader = GpgReader::new(&data[..1000], &sig[..], VerifyKeys::InsecureTest).unwrap();'), (294, '        reader.read_to_end(&mut buf).unwrap_err();'), (295, '        reader.finish(VerifyReport::Stderr).unwrap_err();'), (296, '        reader.finish(VerifyReport::Stderr).unwrap_err();'), (305, '        let mut reader = GpgReader::new(&data[..], &sig[..], VerifyKeys::InsecureTest).unwrap();'), (307, '        reader.read_to_end(&mut buf).unwrap_err();'), (308, '        reader.finish(VerifyReport::Stderr).unwrap_err();'), (309, '        reader.finish(VerifyReport::Stderr).unwrap_err();')]}",
    "num_lines_added": "56",
    "num_lines_deleted": "19",
    "nloc": "268"
  },
  {
    "file_change_id": "234011523741934",
    "hash": "99c67ffdf9111e5d3b0de9f4be2447c4b4ca84f",
    "old_path": "src/io/compress.rs",
    "new_path": "src/io/compress.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -13,9 +13,9 @@\n // limitations under the License.\n \n use anyhow::{Context, Result};\n-use flate2::read::GzDecoder;\n+use flate2::bufread::GzDecoder;\n use std::io::{self, BufRead, Read};\n-use xz2::read::XzDecoder;\n+use xz2::bufread::XzDecoder;\n \n enum CompressDecoder<R: BufRead> {\n     Uncompressed(R),\n",
    "diff_parsed": "{'added': [(16, 'use flate2::bufread::GzDecoder;'), (18, 'use xz2::bufread::XzDecoder;')], 'deleted': [(16, 'use flate2::read::GzDecoder;'), (18, 'use xz2::read::XzDecoder;')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "36"
  },
  {
    "file_change_id": "214394927750487",
    "hash": "99c67ffdf9111e5d3b0de9f4be2447c4b4ca84f",
    "old_path": "src/osmet/file.rs",
    "new_path": "src/osmet/file.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -20,7 +20,7 @@ use anyhow::{anyhow, bail, Context, Result};\n use bincode::Options;\n use serde::{Deserialize, Serialize};\n use structopt::clap::crate_version;\n-use xz2::read::XzDecoder;\n+use xz2::bufread::XzDecoder;\n \n use crate::io::{bincoder, BUFFER_SIZE};\n \n",
    "diff_parsed": "{'added': [(23, 'use xz2::bufread::XzDecoder;')], 'deleted': [(23, 'use xz2::read::XzDecoder;')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "146"
  },
  {
    "file_change_id": "54452286686336",
    "hash": "dbcbefe069fcd53ebc1981fc97fd5b3f94f396d",
    "old_path": "src/io/compress.rs",
    "new_path": "src/io/compress.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -14,7 +14,7 @@\n \n use anyhow::{Context, Result};\n use flate2::bufread::GzDecoder;\n-use std::io::{self, BufRead, Read};\n+use std::io::{self, BufRead, ErrorKind, Read};\n use xz2::bufread::XzDecoder;\n \n enum CompressDecoder<R: BufRead> {\n@@ -48,8 +48,60 @@ impl<R: BufRead> Read for DecompressReader<R> {\n         use CompressDecoder::*;\n         match &mut self.decoder {\n             Uncompressed(d) => d.read(buf),\n-            Gzip(d) => d.read(buf),\n+            Gzip(d) => {\n+                let count = d.read(buf)?;\n+                if count == 0 {\n+                    // GzDecoder stops reading as soon as it encounters the\n+                    // gzip trailer, so it doesn't notice trailing data,\n+                    // which indicates something wrong with the input.  Try\n+                    // reading one more byte, and fail if there is one.\n+                    let mut buf = [0; 1];\n+                    if d.get_mut().read(&mut buf)? > 0 {\n+                        return Err(io::Error::new(\n+                            ErrorKind::InvalidData,\n+                            \"found trailing data after compressed gzip stream\",\n+                        ));\n+                    }\n+                }\n+                Ok(count)\n+            }\n             Xz(d) => d.read(buf),\n         }\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use std::io::BufReader;\n+\n+    /// Test that DecompressReader fails if data is appended to the\n+    /// compressed stream.\n+    #[test]\n+    fn test_decompress_reader_trailing_data() {\n+        test_decompress_reader_trailing_data_one(\n+            &include_bytes!(\"../../fixtures/verify/1M.gz\")[..],\n+        );\n+        test_decompress_reader_trailing_data_one(\n+            &include_bytes!(\"../../fixtures/verify/1M.xz\")[..],\n+        );\n+    }\n+\n+    fn test_decompress_reader_trailing_data_one(input: &[u8]) {\n+        let mut input = input.to_vec();\n+        let mut output = Vec::new();\n+\n+        // successful run\n+        DecompressReader::new(BufReader::new(&*input))\n+            .unwrap()\n+            .read_to_end(&mut output)\n+            .unwrap();\n+\n+        // add trailing garbage, make sure we notice\n+        input.push(0);\n+        DecompressReader::new(BufReader::new(&*input))\n+            .unwrap()\n+            .read_to_end(&mut output)\n+            .unwrap_err();\n+    }\n+}\n",
    "diff_parsed": "{'added': [(17, 'use std::io::{self, BufRead, ErrorKind, Read};'), (51, '            Gzip(d) => {'), (52, '                let count = d.read(buf)?;'), (53, '                if count == 0 {'), (58, '                    let mut buf = [0; 1];'), (59, '                    if d.get_mut().read(&mut buf)? > 0 {'), (60, '                        return Err(io::Error::new('), (61, '                            ErrorKind::InvalidData,'), (62, '                            \"found trailing data after compressed gzip stream\",'), (63, '                        ));'), (64, '                    }'), (65, '                }'), (66, '                Ok(count)'), (67, '            }'), (73, '#[cfg(test)]'), (74, 'mod tests {'), (75, '    use super::*;'), (76, '    use std::io::BufReader;'), (80, '    #[test]'), (81, '    fn test_decompress_reader_trailing_data() {'), (82, '        test_decompress_reader_trailing_data_one('), (83, '            &include_bytes!(\"../../fixtures/verify/1M.gz\")[..],'), (84, '        );'), (85, '        test_decompress_reader_trailing_data_one('), (86, '            &include_bytes!(\"../../fixtures/verify/1M.xz\")[..],'), (87, '        );'), (88, '    }'), (90, '    fn test_decompress_reader_trailing_data_one(input: &[u8]) {'), (91, '        let mut input = input.to_vec();'), (92, '        let mut output = Vec::new();'), (95, '        DecompressReader::new(BufReader::new(&*input))'), (96, '            .unwrap()'), (97, '            .read_to_end(&mut output)'), (98, '            .unwrap();'), (101, '        input.push(0);'), (102, '        DecompressReader::new(BufReader::new(&*input))'), (103, '            .unwrap()'), (104, '            .read_to_end(&mut output)'), (105, '            .unwrap_err();'), (106, '    }'), (107, '}')], 'deleted': [(17, 'use std::io::{self, BufRead, Read};'), (51, '            Gzip(d) => d.read(buf),')]}",
    "num_lines_added": "41",
    "num_lines_deleted": "2",
    "nloc": "75"
  },
  {
    "file_change_id": "1622430734360",
    "hash": "1faf18eee11f14969b77ae0f76dcd9ebd437d0c",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -372,8 +372,8 @@ pub struct RcuCell<T> {\n     link: LinkWrapper<T>,\n }\n \n-unsafe impl<T> Send for RcuCell<T> {}\n-unsafe impl<T> Sync for RcuCell<T> {}\n+unsafe impl<T: Send> Send for RcuCell<T> {}\n+unsafe impl<T: Sync> Sync for RcuCell<T> {}\n \n impl<T> Default for RcuCell<T> {\n     fn default() -> Self {\n",
    "diff_parsed": "{'added': [(375, 'unsafe impl<T: Send> Send for RcuCell<T> {}'), (376, 'unsafe impl<T: Sync> Sync for RcuCell<T> {}')], 'deleted': [(375, 'unsafe impl<T> Send for RcuCell<T> {}'), (376, 'unsafe impl<T> Sync for RcuCell<T> {}')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "416"
  },
  {
    "file_change_id": "200919676472284",
    "hash": "0940e509dca55d19197adbe7cb5c1d5423a390c",
    "old_path": "src/biguint/multiplication.rs",
    "new_path": "src/biguint/multiplication.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -69,14 +69,20 @@ fn bigint_from_slice(slice: &[BigDigit]) -> BigInt {\n fn mac3(mut acc: &mut [BigDigit], mut b: &[BigDigit], mut c: &[BigDigit]) {\n     // Least-significant zeros have no effect on the output.\n     if let Some(&0) = b.first() {\n-        let nz = b.iter().position(|&d| d != 0).unwrap();\n-        b = &b[nz..];\n-        acc = &mut acc[nz..];\n+        if let Some(nz) = b.iter().position(|&d| d != 0) {\n+            b = &b[nz..];\n+            acc = &mut acc[nz..];\n+        } else {\n+            return;\n+        }\n     }\n     if let Some(&0) = c.first() {\n-        let nz = c.iter().position(|&d| d != 0).unwrap();\n-        c = &c[nz..];\n-        acc = &mut acc[nz..];\n+        if let Some(nz) = c.iter().position(|&d| d != 0) {\n+            c = &c[nz..];\n+            acc = &mut acc[nz..];\n+        } else {\n+            return;\n+        }\n     }\n \n     let acc = acc;\n",
    "diff_parsed": "{'added': [(72, '        if let Some(nz) = b.iter().position(|&d| d != 0) {'), (73, '            b = &b[nz..];'), (74, '            acc = &mut acc[nz..];'), (75, '        } else {'), (76, '            return;'), (77, '        }'), (80, '        if let Some(nz) = c.iter().position(|&d| d != 0) {'), (81, '            c = &c[nz..];'), (82, '            acc = &mut acc[nz..];'), (83, '        } else {'), (84, '            return;'), (85, '        }')], 'deleted': [(72, '        let nz = b.iter().position(|&d| d != 0).unwrap();'), (73, '        b = &b[nz..];'), (74, '        acc = &mut acc[nz..];'), (77, '        let nz = c.iter().position(|&d| d != 0).unwrap();'), (78, '        c = &c[nz..];'), (79, '        acc = &mut acc[nz..];')]}",
    "num_lines_added": "12",
    "num_lines_deleted": "6",
    "nloc": "330"
  },
  {
    "file_change_id": "120545004650453",
    "hash": "0940e509dca55d19197adbe7cb5c1d5423a390c",
    "old_path": "None",
    "new_path": "tests/fuzzed.rs",
    "change_type": "ModificationType.ADD",
    "diff": "@@ -0,0 +1,185 @@\n+//! Check buggy inputs that were found by fuzzing\n+\n+use num_bigint::BigUint;\n+use num_traits::Num;\n+\n+#[test]\n+fn fuzzed_mul_1() {\n+    let hex1 = \"\\\n+        cd6839ee857cf791a40494c2e522846eefbca9eca9912fdc1feed4561dbde75c75f1ddca2325ebb1\\\n+        b9cd6eae07308578e58e57f4ddd7dc239b4fd347b883e37d87232a8e5d5a8690c8dba69c97fe8ac4\\\n+        58add18be7e460e03c9d1ae8223db53d20681a4027ffc17d1e43b764791c4db5ff7add849da7e378\\\n+        ac8d9be0e8b517c490da3c0f944b6a52a0c5dc5217c71da8eec35d2c3110d8b041d2b52f3e2a8904\\\n+        abcaaca517a8f2ef6cd26ceadd39a1cf9f770bc08f55f5a230cd81961348bb18534245430699de77\\\n+        d93b805153cffd05dfd0f2cfc2332888cec9c5abf3ece9b4d7886ad94c784bf74fce12853b2a9a75\\\n+        b62a845151a703446cc20300eafe7332330e992ae88817cd6ccef8877b66a7252300a4664d7074da\\\n+        181cd9fd502ea1cd71c0b02db3c009fe970a7d226382cdba5b5576c5c0341694681c7adc4ca2d059\\\n+        d9a6b300957a2235a4eb6689b71d34dcc4037b520eabd2c8b66604bb662fe2bcf533ba8d242dbc91\\\n+        f04c1795b9f0fee800d197d8c6e998248b15855a9602b76cb3f94b148d8f71f7d6225b79d63a8e20\\\n+        8ec8f0fa56a1c381b6c09bad9886056aec17fc92b9bb0f8625fd3444e40cccc2ede768ddb23c66ad\\\n+        59a680a26a26d519d02e4d46ce93cce9e9dd86702bdd376abae0959a0e8e418aa507a63fafb8f422\\\n+        83b03dc26f371c5e261a8f90f3ac9e2a6bcc7f0a39c3f73043b5aa5a950d4e945e9f68b2c2e593e3\\\n+        b995be174714c1967b71f579043f89bfce37437af9388828a3ba0465c88954110cae6d38b638e094\\\n+        13c15c9faddd6fb63623fd50e06d00c4d5954e787158b3e4eea7e9fae8b189fa8a204b23ac2f7bbc\\\n+        b601189c0df2075977c2424336024ba3594172bea87f0f92beb20276ce8510c8ef2a4cd5ede87e7e\\\n+        38b3fa49d66fbcd322be686a349c24919f4000000000000000000000000000000000000000000000\\\n+        000000000000000000000000000000000\";\n+    let hex2 = \"\\\n+        40000000000000000000000000000000000000000000000000000000000000000000000000000000\\\n+        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\n+        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\n+        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\n+        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\n+        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\n+        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\n+        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\n+        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\n+        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\n+        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\n+        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\n+        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\n+        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\n+        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\n+        00000000000000000000000000000000000000000000000000000000000000000000000007\";\n+\n+    // Result produced independently in Python\n+    let hex_result = \"\\\n+        335a0e7ba15f3de469012530b948a11bbbef2a7b2a644bf707fbb515876f79d71d7c777288c97aec\\\n+        6e735bab81cc215e396395fd3775f708e6d3f4d1ee20f8df61c8caa39756a1a43236e9a725ffa2b1\\\n+        162b7462f9f918380f2746ba088f6d4f481a069009fff05f4790edd91e47136d7fdeb7612769f8de\\\n+        2b2366f83a2d45f124368f03e512da94a831771485f1c76a3bb0d74b0c44362c1074ad4bcf8aa241\\\n+        2af2ab2945ea3cbbdb349b3ab74e6873e7ddc2f023d57d688c33606584d22ec614d09150c1a6779d\\\n+        f64ee01454f3ff4177f43cb3f08cca2233b2716afcfb3a6d35e21ab6531e12fdd3f384a14ecaa69d\\\n+        6d8aa1145469c0d11b3080c03abf9ccc8cc3a64aba2205f35b33be21ded9a9c948c02919935c1d36\\\n+        8607367f540ba8735c702c0b6cf0027fa5c29f4898e0b36e96d55db1700d05a51a071eb71328b416\\\n+        7669acc0255e888d693ad9a26dc74d373100ded483aaf4b22d99812ed98bf8af3d4ceea3490b6f24\\\n+        7c1305e56e7c3fba003465f631ba660922c56156a580addb2cfe52c52363dc7df58896de758ea388\\\n+        23b23c3e95a870e06db026eb6621815abb05ff24ae6ec3e1897f4d1139033330bb79da376c8f19ab\\\n+        5669a0289a89b546740b9351b3a4f33a7a77619c0af74ddaaeb8256683a39062a941e98febee3d08\\\n+        a0ec0f709bcdc7178986a3e43ceb278a9af31fc28e70fdcc10ed6a96a54353a517a7da2cb0b964f8\\\n+        ee656f85d1c530659edc7d5e410fe26ff38dd0debe4e220a28ee811972225504432b9b4e2d8e3825\\\n+        04f05727eb775bed8d88ff54381b40313565539e1c562cf93ba9fa7eba2c627ea28812c8eb0bdeef\\\n+        2d804627037c81d65df09090cd8092e8d6505cafaa1fc3e4afac809db3a144323bca93358117f935\\\n+        13d3695771180f461cf38bb995b531c9e072f84f04df87ce5ad0315387399d1086f60971dc149e06\\\n+        c23253a64e46e467b210e704f93f2ec6f60b9b386eb1f629e48d79adf57e018e4827f5cb5e6cc0ba\\\n+        d3573ea621a84bbc58efaff4abe2d8b7c117fe4a6bd3da03bf4fc61ff9fc5c0ea04f97384cb7df43\\\n+        265cf3a65ff5f7a46d0e0fe8426569063ea671cf9e87578c355775ecd1ccc2f44ab329bf20b28ab8\\\n+        83a59ea48bf9c0fa6c0c936cad5c415243eb59b76f559e8b1a86fd1daa46cfe4d52e351546f0a082\\\n+        394aafeb291eb6a3ae4f661bbda78467b3ab7a63f1e4baebf1174a13c32ea281a49e2a3937fb299e\\\n+        393b9116def94e15066cf5265f6566302c5bb8a69df9a8cbb45fce9203f5047ecc1e1331f6a8c9f5\\\n+        ed31466c9e1c44d13fea4045f621496bf0b893a0187f563f68416c9e0ed8c75c061873b274f38ee5\\\n+        041656ef77826fcdc401cc72095c185f3e66b2c37cfcca211fcb4f332ab46a19dbfd4027fd9214a5\\\n+        181596f85805bb26ed706328ffcd96a57a1a1303f8ebd10d8fdeec1dc6daf08054db99e2e3e77e96\\\n+        d85e6c588bff4441bf2baa25ec74a7e803141d6cab09ec6de23c5999548153de0fdfa6cebd738d84\\\n+        70e70fd3b4b1441cefa60a9a65650ead11330c83eb1c24173665e3caca83358bbdce0eacf199d1b0\\\n+        510a81c6930ab9ecf6a9b85328f2977947945bc251d9f7a87a135d260e965bdce354470b3a131832\\\n+        a2f1914b1d601db64f1dbcc43ea382d85cd08bb91c7a161ec87bc14c7758c4fc8cfb8e240c8a4988\\\n+        5dc10e0dfb7afbed3622fb0561d715254b196ceb42869765dc5cdac5d9c6e20df9b54c6228fa07ac\\\n+        44619e3372464fcfd67a10117770ca23369b796d0336de113fa5a3757e8a2819d9815b75738cebd8\\\n+        04dd0e29c5f334dae77044fffb5ac000000000000000000000000000000000000000000000000000\\\n+        000000000000000000000000000\";\n+\n+    let bn1 = &BigUint::from_str_radix(hex1, 16).unwrap();\n+    let bn2 = &BigUint::from_str_radix(hex2, 16).unwrap();\n+    let result = BigUint::from_str_radix(hex_result, 16).unwrap();\n+\n+    assert_eq!(bn1 * bn2, result);\n+    assert_eq!(bn2 * bn1, result);\n+}\n+\n+#[test]\n+fn fuzzed_mul_2() {\n+    let hex_a = \"\\\n+        812cff04ff812cff04ff8180ff80ffff11ff80ff2cff04ff812cff04ff812cff04ff81232cff047d\\\n+        ff04ff812cff04ff812cff04ff812cff047f812cff04ff8180ff2cff04ff04ff8180ff2cff04ff04\\\n+        ff812cbf04ff8180ff2cff04ff812cff0401010000000000000000ffff1a80ffc006c70084ffff80\\\n+        ffc0064006000084ffff72ffc020ffffffffffff06d709000000dbffffffc799999999b999999999\\\n+        99999999000084ffff72ffc02006e1ffffffc70900ffffff00f312ff80ebffffff6f505f6c2e6712\\\n+        108970ffff5f6c6f6727020000000000007400000000000000000000a50000000000000000000000\\\n+        000000000000000000000000ff812cff04ff812cff2c04ff812cff8180ff2cff04ff04ff818b8b8b\\\n+        8b8b8b8b8b8b8b8b8b8b8b8b8b06c70084ffff80ffc006c700847fff80ffc006c700ffff12c70084\\\n+        ffff80ffc0060000000000000056ff00c789bfff80ffc006c70084ffff80ffc006c700ffff840100\\\n+        00000000001289ffc08b8b8b8b8b8b8b2c\";\n+    let hex_b = \"\\\n+        7ed300fb007ed300fb007e7f00db00fb007ed3007ed300fb007edcd300fb8200fb007ed300fb007e\\\n+        d300fb007ed300fb007ed300fbfeffffffffffffa8fb007e7f00d300fb00fb007ed340fb007e7f00\\\n+        00fb007ed300fb007ed300fb007e7f00d300fb00fb007e7f00d300fb007efb007e7f00d300fb007e\\\n+        d300fb007e7f0097d300fb00bf007ed300fb007ed300fb00fb00fb00fbffffffffffffffffffff00\\\n+        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\n+        000000000000df9b3900ff908fa08d9e968c9a0000e7fffb7fff0000003fd9004c90d8f600de7f00\\\n+        3fdf9b3900ff908fa08d9e968cf9b9ff0000ed38ff7b00007f003ff9ffffffffffffffa900ff3876\\\n+        000078003ff938ff7b00007f003ff938ff00007bfeffffffffffffed76003f74747474747474d300\\\n+        fb00fb007e7f00d300fb007efb007e7f00d3003e7f007ed300fb007ed300fb007e7f00d300fb017e\\\n+        d300fb007ed300fb007edcd300fb8200fb007e0000e580\";\n+    let hex_c = \"\\\n+        7b00387ffff938ff7b80007f003ff9b9ff00fdec38ff7b00007f003ff9ffffffffffffffa900ff38\\\n+        76000078003ff938ff7b00007f003ff938ff00007bfeffffffffffffed76003f74747474747474d3\\\n+        00fb00fb007e7f00d300fb007efb007e7f00d3003e7f007ed300fb007ed300fb007e7f00d300fb01\\\n+        7ed300fb007ed300fb007edcd300fb8200fb007e000000ee7f003f0000007b00387ffff938ff7b80\\\n+        007f003ff9b9ff00fdec38ff7b00007f003ff9ffffffffffffffa900ff3876000078003ff938ff7b\\\n+        00007f003ff938ff00007bfeffffffffffffed76003f74747474747474d300fb00fb007e7f00d300\\\n+        fb007efb007e7f00d3003e7f007ed300fb007ed300fb007e7f00d300fb017ed300fb007ed300fb00\\\n+        7edcd300fb8200fb007e000000ee7f003f000000000000000000000000000000002a000000000000\\\n+        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\n+        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\n+        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\n+        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\n+        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\n+        0000000000000000000000df9b3900ff908fa08d9e968c9a0000e7fffb7fff0000003fd9004c90d8\\\n+        f600de7f003fdf9b3900ff908fa08d9e968c9a0000e7fffa7fff0000004005004c90d8f600de908f\\\n+        dcd300fb8200fb007e0000e57f003ff938ff7b00007f003d7ed300fb007ed300fb007ed300fb007e\\\n+        fa00fb007ed300fbf9ffffffffffffffa900ff387600007f003ff938ff7b00007f003ff938fd0000\\\n+        7bfeffffffffffffed76003f74747474747474d300fc\";\n+\n+    // Result produced independently in Python\n+    let hex_result = \"\\\n+        1ebf6415da7ac71a689cd450727b7a361402a1626e0b6cd057e0e2a77d4cb722c1b7d0cbd73a7c07\\\n+        d756813fe97d73d5905c4a26404c7162769ba2dbc1e2742855a1db803e2d2c2fddc77c0598cc70fe\\\n+        066fd4b81cae3e23c55b4795de63acacd1343cf5ad5e715e6919d140c01bab1af1a737ebbf8a7775\\\n+        7602acd611f555ee2d5be56cc14b97c248009cd77490a3dfd6762bae25459a544e369eb4b0cc952a\\\n+        8e6a551ff35a4a7a6e5f5b0b72495c4baadf3a26b9d5d97402ad60fa2324e93adc96ca159b62d147\\\n+        5695f26ff27da100a76e2d273420572e61b4dfbd97e826d9d946f85b87434523f6aa7ce43c443285\\\n+        33f5b5adf32574167b1e9ea3bf6254d6afacf865894907de196285169cfcc1c0fcf438873d13f7e8\\\n+        654acc27c1abb00bec2729e34c994ff2152f60406f75db3ab616541795d9db8ca0b381148de7875f\\\n+        e7a8191407abc390718003698ca28498948caf1dbc3f02593dd85fa929ebae86cfe783d7be473e98\\\n+        0060d9ec60843661cb4cb9b8ddb24bb710f93700b22530501b5ea26c5c94c7370fe0ccbafe0ce7e4\\\n+        cd4f071d0cf0ac151c85a5b132ecaa75793abfb4a6ee33fddd2aa2f5cf2a8eb19c75322792c0d8dc\\\n+        1efb2dcd8ae2b49dd57b84898f531c7f745464f637716151831db56b3e293f587dc95a5e12edfe6b\\\n+        8458033dddf3556da55bef55ba3c3769def0c0f0c86786aca8313dc0ce09118760721eb545d69b46\\\n+        cdb89d377f2c80e67b572da0f75760c2849288a8457c18c6f0b58244b7f95a7567ce23756f1fe359\\\n+        64f7e84fbe28b188157519dd99b8798b076e21984d15c37f41da1309e0fbc539e8b9b09fed36a908\\\n+        28c94f72e7b755c187e58db6bfef0c02309086626ad0fe2efd2ff1467b3de11e057687865f4f85e7\\\n+        0a39bcbc4674dcaded9b04562afe08eb92fbd96ea4a99aa4f9347a075d4421f070ce3a33225f5af1\\\n+        9c27ec5d1720e659ca7fff9686f46b01d76d7de64c738671aaec57ee5582ef7956206fb37c6a36f8\\\n+        8f226ce2124a7f9894a0e9a7aa02001746e6def35699d7adc84a7dcf513ff3da20fd849950f41a5d\\\n+        bb02c91666697156d69ebbe2ef26732b6595d1b6d014a60006d2d3c7055ff9b531779195b8dcd7d9\\\n+        426e776cbc9041735384568ba4adbf7eeea7e0e6cbb47b70335a7ed12a68904eecd334921e4ae6d9\\\n+        c983af20d73215c39573963f03bc87082450cc1c70250e1e8eaa318acaf044a072891fc60324d134\\\n+        6c0a1d02cceb4d4806e536d6017bf6bc125c41694ded38766fea51bfbf7a008ca0b3eb1168766486\\\n+        8aa8469b3e6787a5d5bad6cd67c24005a5cbaa10b63d1b4d05ac42a8b31263052a1260b5900be628\\\n+        4dcab4eb0cf5cda815412ced7bd78f87c00ac3581f41a04352a4a186805a5c9e37b14561a5fc97d2\\\n+        52ca4654fe3d82f42080c21483789cc4b4cbb568f79844f7a317aa2a6555774da26c6f027d3cb0ee\\\n+        9276c6dc4f285fc3b4b9a3cd51c8815cebf110e73c80a9b842cc3b7c80af13f702662b10e868eb61\\\n+        947000b390cd2f3a0899f6f1bab86acf767062f5526507790645ae13b9701ba96b3f873047c9d3b8\\\n+        5e8a5d904a01fbfe10e63495b6021e7cc082aa66679e4d92b3e4e2d62490b44f7e250584cedff0e7\\\n+        072a870ddaa9687a1eae11afc874d83065fb98dbc3cfd90f39517ff3015c71a8c0ab36a6483c7b87\\\n+        f41b2c832fa9428fe95ffba4e49cc553d9e2d33a540958da51588e5120fef6497bfaa96a4dcfc024\\\n+        8170c57f78e9ab9546efbbaf8e9ad6a993493577edd3d29ce8fd9a2e9eb4363b5b472a4ecb2065eb\\\n+        38f876a841af1f227a703248955c8978329dffcd8e065d8da4d42504796ff7abc62832ed86c4f8d0\\\n+        0f55cd567fb9d42524be57ebdacef730c3f94c0372f86fa1b0114f8620f553e4329b2a586fcfeedc\\\n+        af47934909090e14a1f1204e6f1681fb2df05356381e6340f4feaf0787e06218b0b0d8df51acb0bc\\\n+        f98546f33273adf260da959d6fc4a04872122af6508d124abb963c14c30e7c07fee368324921fe33\\\n+        9ae89490c5d6cdae0c356bb6921de95ea13b54e23800\";\n+\n+    let a = &BigUint::from_str_radix(hex_a, 16).unwrap();\n+    let b = &BigUint::from_str_radix(hex_b, 16).unwrap();\n+    let c = &BigUint::from_str_radix(hex_c, 16).unwrap();\n+    let result = BigUint::from_str_radix(hex_result, 16).unwrap();\n+\n+    assert_eq!(a * b * c, result);\n+    assert_eq!(a * c * b, result);\n+    assert_eq!(b * a * c, result);\n+    assert_eq!(b * c * a, result);\n+    assert_eq!(c * a * b, result);\n+    assert_eq!(c * b * a, result);\n+}\n",
    "diff_parsed": "{'added': [(3, 'use num_bigint::BigUint;'), (4, 'use num_traits::Num;'), (6, '#[test]'), (7, 'fn fuzzed_mul_1() {'), (8, '    let hex1 = \"\\\\'), (9, '        cd6839ee857cf791a40494c2e522846eefbca9eca9912fdc1feed4561dbde75c75f1ddca2325ebb1\\\\'), (10, '        b9cd6eae07308578e58e57f4ddd7dc239b4fd347b883e37d87232a8e5d5a8690c8dba69c97fe8ac4\\\\'), (11, '        58add18be7e460e03c9d1ae8223db53d20681a4027ffc17d1e43b764791c4db5ff7add849da7e378\\\\'), (12, '        ac8d9be0e8b517c490da3c0f944b6a52a0c5dc5217c71da8eec35d2c3110d8b041d2b52f3e2a8904\\\\'), (13, '        abcaaca517a8f2ef6cd26ceadd39a1cf9f770bc08f55f5a230cd81961348bb18534245430699de77\\\\'), (14, '        d93b805153cffd05dfd0f2cfc2332888cec9c5abf3ece9b4d7886ad94c784bf74fce12853b2a9a75\\\\'), (15, '        b62a845151a703446cc20300eafe7332330e992ae88817cd6ccef8877b66a7252300a4664d7074da\\\\'), (16, '        181cd9fd502ea1cd71c0b02db3c009fe970a7d226382cdba5b5576c5c0341694681c7adc4ca2d059\\\\'), (17, '        d9a6b300957a2235a4eb6689b71d34dcc4037b520eabd2c8b66604bb662fe2bcf533ba8d242dbc91\\\\'), (18, '        f04c1795b9f0fee800d197d8c6e998248b15855a9602b76cb3f94b148d8f71f7d6225b79d63a8e20\\\\'), (19, '        8ec8f0fa56a1c381b6c09bad9886056aec17fc92b9bb0f8625fd3444e40cccc2ede768ddb23c66ad\\\\'), (20, '        59a680a26a26d519d02e4d46ce93cce9e9dd86702bdd376abae0959a0e8e418aa507a63fafb8f422\\\\'), (21, '        83b03dc26f371c5e261a8f90f3ac9e2a6bcc7f0a39c3f73043b5aa5a950d4e945e9f68b2c2e593e3\\\\'), (22, '        b995be174714c1967b71f579043f89bfce37437af9388828a3ba0465c88954110cae6d38b638e094\\\\'), (23, '        13c15c9faddd6fb63623fd50e06d00c4d5954e787158b3e4eea7e9fae8b189fa8a204b23ac2f7bbc\\\\'), (24, '        b601189c0df2075977c2424336024ba3594172bea87f0f92beb20276ce8510c8ef2a4cd5ede87e7e\\\\'), (25, '        38b3fa49d66fbcd322be686a349c24919f4000000000000000000000000000000000000000000000\\\\'), (26, '        000000000000000000000000000000000\";'), (27, '    let hex2 = \"\\\\'), (28, '        40000000000000000000000000000000000000000000000000000000000000000000000000000000\\\\'), (29, '        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\\'), (30, '        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\\'), (31, '        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\\'), (32, '        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\\'), (33, '        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\\'), (34, '        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\\'), (35, '        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\\'), (36, '        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\\'), (37, '        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\\'), (38, '        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\\'), (39, '        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\\'), (40, '        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\\'), (41, '        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\\'), (42, '        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\\'), (43, '        00000000000000000000000000000000000000000000000000000000000000000000000007\";'), (46, '    let hex_result = \"\\\\'), (47, '        335a0e7ba15f3de469012530b948a11bbbef2a7b2a644bf707fbb515876f79d71d7c777288c97aec\\\\'), (48, '        6e735bab81cc215e396395fd3775f708e6d3f4d1ee20f8df61c8caa39756a1a43236e9a725ffa2b1\\\\'), (49, '        162b7462f9f918380f2746ba088f6d4f481a069009fff05f4790edd91e47136d7fdeb7612769f8de\\\\'), (50, '        2b2366f83a2d45f124368f03e512da94a831771485f1c76a3bb0d74b0c44362c1074ad4bcf8aa241\\\\'), (51, '        2af2ab2945ea3cbbdb349b3ab74e6873e7ddc2f023d57d688c33606584d22ec614d09150c1a6779d\\\\'), (52, '        f64ee01454f3ff4177f43cb3f08cca2233b2716afcfb3a6d35e21ab6531e12fdd3f384a14ecaa69d\\\\'), (53, '        6d8aa1145469c0d11b3080c03abf9ccc8cc3a64aba2205f35b33be21ded9a9c948c02919935c1d36\\\\'), (54, '        8607367f540ba8735c702c0b6cf0027fa5c29f4898e0b36e96d55db1700d05a51a071eb71328b416\\\\'), (55, '        7669acc0255e888d693ad9a26dc74d373100ded483aaf4b22d99812ed98bf8af3d4ceea3490b6f24\\\\'), (56, '        7c1305e56e7c3fba003465f631ba660922c56156a580addb2cfe52c52363dc7df58896de758ea388\\\\'), (57, '        23b23c3e95a870e06db026eb6621815abb05ff24ae6ec3e1897f4d1139033330bb79da376c8f19ab\\\\'), (58, '        5669a0289a89b546740b9351b3a4f33a7a77619c0af74ddaaeb8256683a39062a941e98febee3d08\\\\'), (59, '        a0ec0f709bcdc7178986a3e43ceb278a9af31fc28e70fdcc10ed6a96a54353a517a7da2cb0b964f8\\\\'), (60, '        ee656f85d1c530659edc7d5e410fe26ff38dd0debe4e220a28ee811972225504432b9b4e2d8e3825\\\\'), (61, '        04f05727eb775bed8d88ff54381b40313565539e1c562cf93ba9fa7eba2c627ea28812c8eb0bdeef\\\\'), (62, '        2d804627037c81d65df09090cd8092e8d6505cafaa1fc3e4afac809db3a144323bca93358117f935\\\\'), (63, '        13d3695771180f461cf38bb995b531c9e072f84f04df87ce5ad0315387399d1086f60971dc149e06\\\\'), (64, '        c23253a64e46e467b210e704f93f2ec6f60b9b386eb1f629e48d79adf57e018e4827f5cb5e6cc0ba\\\\'), (65, '        d3573ea621a84bbc58efaff4abe2d8b7c117fe4a6bd3da03bf4fc61ff9fc5c0ea04f97384cb7df43\\\\'), (66, '        265cf3a65ff5f7a46d0e0fe8426569063ea671cf9e87578c355775ecd1ccc2f44ab329bf20b28ab8\\\\'), (67, '        83a59ea48bf9c0fa6c0c936cad5c415243eb59b76f559e8b1a86fd1daa46cfe4d52e351546f0a082\\\\'), (68, '        394aafeb291eb6a3ae4f661bbda78467b3ab7a63f1e4baebf1174a13c32ea281a49e2a3937fb299e\\\\'), (69, '        393b9116def94e15066cf5265f6566302c5bb8a69df9a8cbb45fce9203f5047ecc1e1331f6a8c9f5\\\\'), (70, '        ed31466c9e1c44d13fea4045f621496bf0b893a0187f563f68416c9e0ed8c75c061873b274f38ee5\\\\'), (71, '        041656ef77826fcdc401cc72095c185f3e66b2c37cfcca211fcb4f332ab46a19dbfd4027fd9214a5\\\\'), (72, '        181596f85805bb26ed706328ffcd96a57a1a1303f8ebd10d8fdeec1dc6daf08054db99e2e3e77e96\\\\'), (73, '        d85e6c588bff4441bf2baa25ec74a7e803141d6cab09ec6de23c5999548153de0fdfa6cebd738d84\\\\'), (74, '        70e70fd3b4b1441cefa60a9a65650ead11330c83eb1c24173665e3caca83358bbdce0eacf199d1b0\\\\'), (75, '        510a81c6930ab9ecf6a9b85328f2977947945bc251d9f7a87a135d260e965bdce354470b3a131832\\\\'), (76, '        a2f1914b1d601db64f1dbcc43ea382d85cd08bb91c7a161ec87bc14c7758c4fc8cfb8e240c8a4988\\\\'), (77, '        5dc10e0dfb7afbed3622fb0561d715254b196ceb42869765dc5cdac5d9c6e20df9b54c6228fa07ac\\\\'), (78, '        44619e3372464fcfd67a10117770ca23369b796d0336de113fa5a3757e8a2819d9815b75738cebd8\\\\'), (79, '        04dd0e29c5f334dae77044fffb5ac000000000000000000000000000000000000000000000000000\\\\'), (80, '        000000000000000000000000000\";'), (82, '    let bn1 = &BigUint::from_str_radix(hex1, 16).unwrap();'), (83, '    let bn2 = &BigUint::from_str_radix(hex2, 16).unwrap();'), (84, '    let result = BigUint::from_str_radix(hex_result, 16).unwrap();'), (86, '    assert_eq!(bn1 * bn2, result);'), (87, '    assert_eq!(bn2 * bn1, result);'), (88, '}'), (90, '#[test]'), (91, 'fn fuzzed_mul_2() {'), (92, '    let hex_a = \"\\\\'), (93, '        812cff04ff812cff04ff8180ff80ffff11ff80ff2cff04ff812cff04ff812cff04ff81232cff047d\\\\'), (94, '        ff04ff812cff04ff812cff04ff812cff047f812cff04ff8180ff2cff04ff04ff8180ff2cff04ff04\\\\'), (95, '        ff812cbf04ff8180ff2cff04ff812cff0401010000000000000000ffff1a80ffc006c70084ffff80\\\\'), (96, '        ffc0064006000084ffff72ffc020ffffffffffff06d709000000dbffffffc799999999b999999999\\\\'), (97, '        99999999000084ffff72ffc02006e1ffffffc70900ffffff00f312ff80ebffffff6f505f6c2e6712\\\\'), (98, '        108970ffff5f6c6f6727020000000000007400000000000000000000a50000000000000000000000\\\\'), (99, '        000000000000000000000000ff812cff04ff812cff2c04ff812cff8180ff2cff04ff04ff818b8b8b\\\\'), (100, '        8b8b8b8b8b8b8b8b8b8b8b8b8b06c70084ffff80ffc006c700847fff80ffc006c700ffff12c70084\\\\'), (101, '        ffff80ffc0060000000000000056ff00c789bfff80ffc006c70084ffff80ffc006c700ffff840100\\\\'), (102, '        00000000001289ffc08b8b8b8b8b8b8b2c\";'), (103, '    let hex_b = \"\\\\'), (104, '        7ed300fb007ed300fb007e7f00db00fb007ed3007ed300fb007edcd300fb8200fb007ed300fb007e\\\\'), (105, '        d300fb007ed300fb007ed300fbfeffffffffffffa8fb007e7f00d300fb00fb007ed340fb007e7f00\\\\'), (106, '        00fb007ed300fb007ed300fb007e7f00d300fb00fb007e7f00d300fb007efb007e7f00d300fb007e\\\\'), (107, '        d300fb007e7f0097d300fb00bf007ed300fb007ed300fb00fb00fb00fbffffffffffffffffffff00\\\\'), (108, '        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\\'), (109, '        000000000000df9b3900ff908fa08d9e968c9a0000e7fffb7fff0000003fd9004c90d8f600de7f00\\\\'), (110, '        3fdf9b3900ff908fa08d9e968cf9b9ff0000ed38ff7b00007f003ff9ffffffffffffffa900ff3876\\\\'), (111, '        000078003ff938ff7b00007f003ff938ff00007bfeffffffffffffed76003f74747474747474d300\\\\'), (112, '        fb00fb007e7f00d300fb007efb007e7f00d3003e7f007ed300fb007ed300fb007e7f00d300fb017e\\\\'), (113, '        d300fb007ed300fb007edcd300fb8200fb007e0000e580\";'), (114, '    let hex_c = \"\\\\'), (115, '        7b00387ffff938ff7b80007f003ff9b9ff00fdec38ff7b00007f003ff9ffffffffffffffa900ff38\\\\'), (116, '        76000078003ff938ff7b00007f003ff938ff00007bfeffffffffffffed76003f74747474747474d3\\\\'), (117, '        00fb00fb007e7f00d300fb007efb007e7f00d3003e7f007ed300fb007ed300fb007e7f00d300fb01\\\\'), (118, '        7ed300fb007ed300fb007edcd300fb8200fb007e000000ee7f003f0000007b00387ffff938ff7b80\\\\'), (119, '        007f003ff9b9ff00fdec38ff7b00007f003ff9ffffffffffffffa900ff3876000078003ff938ff7b\\\\'), (120, '        00007f003ff938ff00007bfeffffffffffffed76003f74747474747474d300fb00fb007e7f00d300\\\\'), (121, '        fb007efb007e7f00d3003e7f007ed300fb007ed300fb007e7f00d300fb017ed300fb007ed300fb00\\\\'), (122, '        7edcd300fb8200fb007e000000ee7f003f000000000000000000000000000000002a000000000000\\\\'), (123, '        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\\'), (124, '        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\\'), (125, '        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\\'), (126, '        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\\'), (127, '        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\\'), (128, '        0000000000000000000000df9b3900ff908fa08d9e968c9a0000e7fffb7fff0000003fd9004c90d8\\\\'), (129, '        f600de7f003fdf9b3900ff908fa08d9e968c9a0000e7fffa7fff0000004005004c90d8f600de908f\\\\'), (130, '        dcd300fb8200fb007e0000e57f003ff938ff7b00007f003d7ed300fb007ed300fb007ed300fb007e\\\\'), (131, '        fa00fb007ed300fbf9ffffffffffffffa900ff387600007f003ff938ff7b00007f003ff938fd0000\\\\'), (132, '        7bfeffffffffffffed76003f74747474747474d300fc\";'), (135, '    let hex_result = \"\\\\'), (136, '        1ebf6415da7ac71a689cd450727b7a361402a1626e0b6cd057e0e2a77d4cb722c1b7d0cbd73a7c07\\\\'), (137, '        d756813fe97d73d5905c4a26404c7162769ba2dbc1e2742855a1db803e2d2c2fddc77c0598cc70fe\\\\'), (138, '        066fd4b81cae3e23c55b4795de63acacd1343cf5ad5e715e6919d140c01bab1af1a737ebbf8a7775\\\\'), (139, '        7602acd611f555ee2d5be56cc14b97c248009cd77490a3dfd6762bae25459a544e369eb4b0cc952a\\\\'), (140, '        8e6a551ff35a4a7a6e5f5b0b72495c4baadf3a26b9d5d97402ad60fa2324e93adc96ca159b62d147\\\\'), (141, '        5695f26ff27da100a76e2d273420572e61b4dfbd97e826d9d946f85b87434523f6aa7ce43c443285\\\\'), (142, '        33f5b5adf32574167b1e9ea3bf6254d6afacf865894907de196285169cfcc1c0fcf438873d13f7e8\\\\'), (143, '        654acc27c1abb00bec2729e34c994ff2152f60406f75db3ab616541795d9db8ca0b381148de7875f\\\\'), (144, '        e7a8191407abc390718003698ca28498948caf1dbc3f02593dd85fa929ebae86cfe783d7be473e98\\\\'), (145, '        0060d9ec60843661cb4cb9b8ddb24bb710f93700b22530501b5ea26c5c94c7370fe0ccbafe0ce7e4\\\\'), (146, '        cd4f071d0cf0ac151c85a5b132ecaa75793abfb4a6ee33fddd2aa2f5cf2a8eb19c75322792c0d8dc\\\\'), (147, '        1efb2dcd8ae2b49dd57b84898f531c7f745464f637716151831db56b3e293f587dc95a5e12edfe6b\\\\'), (148, '        8458033dddf3556da55bef55ba3c3769def0c0f0c86786aca8313dc0ce09118760721eb545d69b46\\\\'), (149, '        cdb89d377f2c80e67b572da0f75760c2849288a8457c18c6f0b58244b7f95a7567ce23756f1fe359\\\\'), (150, '        64f7e84fbe28b188157519dd99b8798b076e21984d15c37f41da1309e0fbc539e8b9b09fed36a908\\\\'), (151, '        28c94f72e7b755c187e58db6bfef0c02309086626ad0fe2efd2ff1467b3de11e057687865f4f85e7\\\\'), (152, '        0a39bcbc4674dcaded9b04562afe08eb92fbd96ea4a99aa4f9347a075d4421f070ce3a33225f5af1\\\\'), (153, '        9c27ec5d1720e659ca7fff9686f46b01d76d7de64c738671aaec57ee5582ef7956206fb37c6a36f8\\\\'), (154, '        8f226ce2124a7f9894a0e9a7aa02001746e6def35699d7adc84a7dcf513ff3da20fd849950f41a5d\\\\'), (155, '        bb02c91666697156d69ebbe2ef26732b6595d1b6d014a60006d2d3c7055ff9b531779195b8dcd7d9\\\\'), (156, '        426e776cbc9041735384568ba4adbf7eeea7e0e6cbb47b70335a7ed12a68904eecd334921e4ae6d9\\\\'), (157, '        c983af20d73215c39573963f03bc87082450cc1c70250e1e8eaa318acaf044a072891fc60324d134\\\\'), (158, '        6c0a1d02cceb4d4806e536d6017bf6bc125c41694ded38766fea51bfbf7a008ca0b3eb1168766486\\\\'), (159, '        8aa8469b3e6787a5d5bad6cd67c24005a5cbaa10b63d1b4d05ac42a8b31263052a1260b5900be628\\\\'), (160, '        4dcab4eb0cf5cda815412ced7bd78f87c00ac3581f41a04352a4a186805a5c9e37b14561a5fc97d2\\\\'), (161, '        52ca4654fe3d82f42080c21483789cc4b4cbb568f79844f7a317aa2a6555774da26c6f027d3cb0ee\\\\'), (162, '        9276c6dc4f285fc3b4b9a3cd51c8815cebf110e73c80a9b842cc3b7c80af13f702662b10e868eb61\\\\'), (163, '        947000b390cd2f3a0899f6f1bab86acf767062f5526507790645ae13b9701ba96b3f873047c9d3b8\\\\'), (164, '        5e8a5d904a01fbfe10e63495b6021e7cc082aa66679e4d92b3e4e2d62490b44f7e250584cedff0e7\\\\'), (165, '        072a870ddaa9687a1eae11afc874d83065fb98dbc3cfd90f39517ff3015c71a8c0ab36a6483c7b87\\\\'), (166, '        f41b2c832fa9428fe95ffba4e49cc553d9e2d33a540958da51588e5120fef6497bfaa96a4dcfc024\\\\'), (167, '        8170c57f78e9ab9546efbbaf8e9ad6a993493577edd3d29ce8fd9a2e9eb4363b5b472a4ecb2065eb\\\\'), (168, '        38f876a841af1f227a703248955c8978329dffcd8e065d8da4d42504796ff7abc62832ed86c4f8d0\\\\'), (169, '        0f55cd567fb9d42524be57ebdacef730c3f94c0372f86fa1b0114f8620f553e4329b2a586fcfeedc\\\\'), (170, '        af47934909090e14a1f1204e6f1681fb2df05356381e6340f4feaf0787e06218b0b0d8df51acb0bc\\\\'), (171, '        f98546f33273adf260da959d6fc4a04872122af6508d124abb963c14c30e7c07fee368324921fe33\\\\'), (172, '        9ae89490c5d6cdae0c356bb6921de95ea13b54e23800\";'), (174, '    let a = &BigUint::from_str_radix(hex_a, 16).unwrap();'), (175, '    let b = &BigUint::from_str_radix(hex_b, 16).unwrap();'), (176, '    let c = &BigUint::from_str_radix(hex_c, 16).unwrap();'), (177, '    let result = BigUint::from_str_radix(hex_result, 16).unwrap();'), (179, '    assert_eq!(a * b * c, result);'), (180, '    assert_eq!(a * c * b, result);'), (181, '    assert_eq!(b * a * c, result);'), (182, '    assert_eq!(b * c * a, result);'), (183, '    assert_eq!(c * a * b, result);'), (184, '    assert_eq!(c * b * a, result);'), (185, '}')], 'deleted': []}",
    "num_lines_added": "173",
    "num_lines_deleted": "0",
    "nloc": "173"
  },
  {
    "file_change_id": "244366461367763",
    "hash": "8008707fea97b9215f3b949a0eb6044aec709a3",
    "old_path": "src/biguint/multiplication.rs",
    "new_path": "src/biguint/multiplication.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -174,7 +174,7 @@ fn mac3(mut acc: &mut [BigDigit], mut b: &[BigDigit], mut c: &[BigDigit]) {\n \n         // We reuse the same BigUint for all the intermediate multiplies and have to size p\n         // appropriately here: x1.len() >= x0.len and y1.len() >= y0.len():\n-        let len = x1.len() + y1.len();\n+        let len = x1.len() + y1.len() + 1;\n         let mut p = BigUint { data: vec![0; len] };\n \n         // p2 = x1 * y1\n@@ -350,7 +350,7 @@ fn mac3(mut acc: &mut [BigDigit], mut b: &[BigDigit], mut c: &[BigDigit]) {\n }\n \n fn mul3(x: &[BigDigit], y: &[BigDigit]) -> BigUint {\n-    let len = x.len() + y.len();\n+    let len = x.len() + y.len() + 1;\n     let mut prod = BigUint { data: vec![0; len] };\n \n     mac3(&mut prod.data, x, y);\n",
    "diff_parsed": "{'added': [(177, '        let len = x1.len() + y1.len() + 1;'), (353, '    let len = x.len() + y.len() + 1;')], 'deleted': [(177, '        let len = x1.len() + y1.len();'), (353, '    let len = x.len() + y.len();')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "330"
  },
  {
    "file_change_id": "109245622487458",
    "hash": "8008707fea97b9215f3b949a0eb6044aec709a3",
    "old_path": "tests/biguint.rs",
    "new_path": "tests/biguint.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1008,12 +1008,26 @@ fn test_checked_mul() {\n #[test]\n fn test_mul_overflow() {\n     // Test for issue #187 - overflow due to mac3 incorrectly sizing temporary\n-    let s = \"531137992816767098689588206552468627329593117727031923199444138200403559860852242739162502232636710047537552105951370000796528760829212940754539968588340162273730474622005920097370111\";\n+    let s = \"5311379928167670986895882065524686273295931177270319231994441382\\\n+             0040355986085224273916250223263671004753755210595137000079652876\\\n+             0829212940754539968588340162273730474622005920097370111\";\n     let a: BigUint = s.parse().unwrap();\n     let b = a.clone();\n     let _ = a.checked_mul(&b);\n }\n \n+#[test]\n+fn test_mul_overflow_2() {\n+    // Try a bunch of sizes that are right on the edge of multiplication length\n+    // overflow, where (x * x).data.len() == 2 * x.data.len() + 1.\n+    for i in 1u8..20 {\n+        let bits = 1u32 << i;\n+        let x = (BigUint::one() << bits) - 1u32;\n+        let x2 = (BigUint::one() << (2 * bits)) - &x - &x - 1u32;\n+        assert_eq!(&x * &x, x2);\n+    }\n+}\n+\n #[test]\n fn test_checked_div() {\n     for elm in MUL_TRIPLES.iter() {\n",
    "diff_parsed": "{'added': [(1011, '    let s = \"5311379928167670986895882065524686273295931177270319231994441382\\\\'), (1012, '             0040355986085224273916250223263671004753755210595137000079652876\\\\'), (1013, '             0829212940754539968588340162273730474622005920097370111\";'), (1019, '#[test]'), (1020, 'fn test_mul_overflow_2() {'), (1023, '    for i in 1u8..20 {'), (1024, '        let bits = 1u32 << i;'), (1025, '        let x = (BigUint::one() << bits) - 1u32;'), (1026, '        let x2 = (BigUint::one() << (2 * bits)) - &x - &x - 1u32;'), (1027, '        assert_eq!(&x * &x, x2);'), (1028, '    }'), (1029, '}')], 'deleted': [(1011, '    let s = \"531137992816767098689588206552468627329593117727031923199444138200403559860852242739162502232636710047537552105951370000796528760829212940754539968588340162273730474622005920097370111\";')]}",
    "num_lines_added": "12",
    "num_lines_deleted": "1",
    "nloc": "1684"
  },
  {
    "file_change_id": "166582456410264",
    "hash": "c13df26bf356b8c33c390b310f22227a7fd654d",
    "old_path": "src/elf.rs",
    "new_path": "src/elf.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,4 +1,3 @@\n-#![allow(clippy::integer_arithmetic)]\n //! This module relocates a BPF ELF\n \n // Note: Typically ELF shared objects are loaded using the program headers and\n@@ -243,10 +242,14 @@ impl<E: UserDefinedError, I: InstructionMeter> Executable<E, I> {\n \n     /// Get the .text section virtual address and bytes\n     pub fn get_text_bytes(&self) -> (u64, &[u8]) {\n-        let offset = (self.text_section_info.vaddr - ebpf::MM_PROGRAM_START) as usize;\n+        let offset = (self\n+            .text_section_info\n+            .vaddr\n+            .saturating_sub(ebpf::MM_PROGRAM_START)) as usize;\n         (\n             self.text_section_info.vaddr,\n-            &self.ro_section[offset..offset + self.text_section_info.offset_range.len()],\n+            &self.ro_section\n+                [offset..offset.saturating_add(self.text_section_info.offset_range.len())],\n         )\n     }\n \n@@ -312,7 +315,10 @@ impl<E: UserDefinedError, I: InstructionMeter> Executable<E, I> {\n         }\n         Err(ElfError::UnresolvedSymbol(\n             name.to_string(),\n-            file_offset / ebpf::INSN_SIZE + ebpf::ELF_INSN_DUMP_OFFSET,\n+            file_offset\n+                .checked_div(ebpf::INSN_SIZE)\n+                .and_then(|offset| offset.checked_add(ebpf::ELF_INSN_DUMP_OFFSET))\n+                .unwrap_or(ebpf::ELF_INSN_DUMP_OFFSET),\n             file_offset,\n         )\n         .into())\n@@ -408,21 +414,25 @@ impl<E: UserDefinedError, I: InstructionMeter> Executable<E, I> {\n         )?;\n \n         // calculate entrypoint offset into the text section\n-        let offset = elf.header.e_entry - text_section.sh_addr;\n-        if offset % ebpf::INSN_SIZE as u64 != 0 {\n+        let offset = elf.header.e_entry.saturating_sub(text_section.sh_addr);\n+        if offset.checked_rem(ebpf::INSN_SIZE as u64) != Some(0) {\n+            return Err(ElfError::InvalidEntrypoint);\n+        }\n+        if let Some(entrypoint) = (offset as usize).checked_div(ebpf::INSN_SIZE) {\n+            bpf_functions.remove(&ebpf::hash_symbol_name(b\"entrypoint\"));\n+            register_bpf_function(\n+                &mut bpf_functions,\n+                entrypoint,\n+                \"entrypoint\",\n+                config.enable_symbol_and_section_labels,\n+            )?;\n+        } else {\n             return Err(ElfError::InvalidEntrypoint);\n         }\n-        let entrypoint = offset as usize / ebpf::INSN_SIZE;\n-        bpf_functions.remove(&ebpf::hash_symbol_name(b\"entrypoint\"));\n-        register_bpf_function(\n-            &mut bpf_functions,\n-            entrypoint,\n-            \"entrypoint\",\n-            config.enable_symbol_and_section_labels,\n-        )?;\n \n         // concatenate the read-only sections into one\n-        let mut ro_length = text_section.sh_addr as usize + text_section_info.offset_range.len();\n+        let mut ro_length =\n+            (text_section.sh_addr as usize).saturating_add(text_section_info.offset_range.len());\n         let ro_slices = elf\n             .section_headers\n             .iter()\n@@ -446,13 +456,17 @@ impl<E: UserDefinedError, I: InstructionMeter> Executable<E, I> {\n                     .as_slice()\n                     .get(section_header.file_range().unwrap_or_default())\n                     .ok_or(ElfError::ValueOutOfBounds)?;\n-                ro_length = ro_length.max(section_header.sh_addr as usize + slice.len());\n+                ro_length =\n+                    ro_length.max((section_header.sh_addr as usize).saturating_add(slice.len()));\n                 Ok((section_header.sh_addr as usize, slice))\n             })\n             .collect::<Result<Vec<_>, ElfError>>()?;\n+        if ro_length > elf_bytes.len() {\n+            return Err(ElfError::ValueOutOfBounds);\n+        }\n         let mut ro_section = vec![0; ro_length];\n         ro_section[text_section.sh_addr as usize\n-            ..text_section.sh_addr as usize + text_section_info.offset_range.len()]\n+            ..(text_section.sh_addr as usize).saturating_add(text_section_info.offset_range.len())]\n             .copy_from_slice(\n                 elf_bytes\n                     .as_slice()\n@@ -460,7 +474,7 @@ impl<E: UserDefinedError, I: InstructionMeter> Executable<E, I> {\n                     .ok_or(ElfError::ValueOutOfBounds)?,\n             );\n         for (offset, slice) in ro_slices.iter() {\n-            ro_section[*offset..*offset + slice.len()].copy_from_slice(slice);\n+            ro_section[*offset..offset.saturating_add(slice.len())].copy_from_slice(slice);\n         }\n \n         Ok(Self {\n@@ -483,13 +497,19 @@ impl<E: UserDefinedError, I: InstructionMeter> Executable<E, I> {\n         bpf_functions: &mut BTreeMap<u32, (usize, String)>,\n         elf_bytes: &mut [u8],\n     ) -> Result<(), ElfError> {\n-        for i in 0..elf_bytes.len() / ebpf::INSN_SIZE {\n+        let instruction_count = elf_bytes\n+            .len()\n+            .checked_div(ebpf::INSN_SIZE)\n+            .ok_or(ElfError::ValueOutOfBounds)?;\n+        for i in 0..instruction_count {\n             let mut insn = ebpf::get_insn(elf_bytes, i);\n             if insn.opc == ebpf::CALL_IMM && insn.imm != -1 {\n-                let target_pc = i as isize + 1 + insn.imm as isize;\n-                if target_pc < 0 || target_pc >= (elf_bytes.len() / ebpf::INSN_SIZE) as isize {\n+                let target_pc = (i as isize)\n+                    .saturating_add(1)\n+                    .saturating_add(insn.imm as isize);\n+                if target_pc < 0 || target_pc >= instruction_count as isize {\n                     return Err(ElfError::RelativeJumpOutOfBounds(\n-                        i + ebpf::ELF_INSN_DUMP_OFFSET,\n+                        i.saturating_add(ebpf::ELF_INSN_DUMP_OFFSET),\n                     ));\n                 }\n                 let name = format!(\"function_{}\", target_pc);\n@@ -500,8 +520,9 @@ impl<E: UserDefinedError, I: InstructionMeter> Executable<E, I> {\n                     enable_symbol_and_section_labels,\n                 )?;\n                 insn.imm = hash as i64;\n+                let offset = i.saturating_mul(ebpf::INSN_SIZE);\n                 let checked_slice = elf_bytes\n-                    .get_mut(i * ebpf::INSN_SIZE..(i * ebpf::INSN_SIZE) + ebpf::INSN_SIZE)\n+                    .get_mut(offset..offset.saturating_add(ebpf::INSN_SIZE))\n                     .ok_or(ElfError::ValueOutOfBounds)?;\n                 checked_slice.copy_from_slice(&insn.to_vec());\n             }\n@@ -527,14 +548,17 @@ impl<E: UserDefinedError, I: InstructionMeter> Executable<E, I> {\n             return Err(ElfError::WrongType);\n         }\n \n-        let num_text_sections = elf.section_headers.iter().fold(0, |count, section_header| {\n-            if let Some(this_name) = elf.shdr_strtab.get_at(section_header.sh_name) {\n-                if this_name == \".text\" {\n-                    return count + 1;\n-                }\n-            }\n-            count\n-        });\n+        let num_text_sections =\n+            elf.section_headers\n+                .iter()\n+                .fold(0, |count: usize, section_header| {\n+                    if let Some(this_name) = elf.shdr_strtab.get_at(section_header.sh_name) {\n+                        if this_name == \".text\" {\n+                            return count.saturating_add(1);\n+                        }\n+                    }\n+                    count\n+                });\n         if 1 != num_text_sections {\n             return Err(ElfError::NotOneTextSection);\n         }\n@@ -628,19 +652,19 @@ impl<E: UserDefinedError, I: InstructionMeter> Executable<E, I> {\n                         .dynsyms\n                         .get(relocation.r_sym)\n                         .ok_or(ElfError::UnknownSymbol(relocation.r_sym))?;\n-                    let addr = (sym.st_value + refd_pa) as u64;\n+                    let addr = sym.st_value.saturating_add(refd_pa) as u64;\n                     let checked_slice = elf_bytes\n                         .get_mut(imm_offset..imm_offset.saturating_add(BYTE_LENGTH_IMMEIDATE))\n                         .ok_or(ElfError::ValueOutOfBounds)?;\n                     LittleEndian::write_u32(checked_slice, (addr & 0xFFFFFFFF) as u32);\n+                    let file_offset = imm_offset.saturating_add(ebpf::INSN_SIZE);\n                     let checked_slice = elf_bytes\n-                        .get_mut(\n-                            imm_offset.saturating_add(ebpf::INSN_SIZE)\n-                                ..imm_offset\n-                                    .saturating_add(ebpf::INSN_SIZE + BYTE_LENGTH_IMMEIDATE),\n-                        )\n+                        .get_mut(file_offset..file_offset.saturating_add(BYTE_LENGTH_IMMEIDATE))\n                         .ok_or(ElfError::ValueOutOfBounds)?;\n-                    LittleEndian::write_u32(checked_slice, (addr >> 32) as u32);\n+                    LittleEndian::write_u32(\n+                        checked_slice,\n+                        addr.checked_shr(32).unwrap_or_default() as u32,\n+                    );\n                 }\n                 Some(BpfRelocationType::R_Bpf_64_Relative) => {\n                     // Raw relocation between sections.  The instruction being relocated contains\n@@ -674,14 +698,14 @@ impl<E: UserDefinedError, I: InstructionMeter> Executable<E, I> {\n                             .get_mut(imm_offset..imm_offset.saturating_add(BYTE_LENGTH_IMMEIDATE))\n                             .ok_or(ElfError::ValueOutOfBounds)?;\n                         LittleEndian::write_u32(checked_slice, (refd_pa & 0xFFFFFFFF) as u32);\n+                        let file_offset = imm_offset.saturating_add(ebpf::INSN_SIZE);\n                         let checked_slice = elf_bytes\n-                            .get_mut(\n-                                imm_offset.saturating_add(ebpf::INSN_SIZE)\n-                                    ..imm_offset\n-                                        .saturating_add(ebpf::INSN_SIZE + BYTE_LENGTH_IMMEIDATE),\n-                            )\n+                            .get_mut(file_offset..file_offset.saturating_add(BYTE_LENGTH_IMMEIDATE))\n                             .ok_or(ElfError::ValueOutOfBounds)?;\n-                        LittleEndian::write_u32(checked_slice, (refd_pa >> 32) as u32);\n+                        LittleEndian::write_u32(\n+                            checked_slice,\n+                            refd_pa.checked_shr(32).unwrap_or_default() as u32,\n+                        );\n                     } else {\n                         // 64 bit memory location, write entire 64 bit physical address directly\n                         let checked_slice = elf_bytes\n@@ -708,8 +732,10 @@ impl<E: UserDefinedError, I: InstructionMeter> Executable<E, I> {\n                         if !text_section.vm_range().contains(&(sym.st_value as usize)) {\n                             return Err(ElfError::ValueOutOfBounds);\n                         }\n-                        let target_pc =\n-                            (sym.st_value - text_section.sh_addr) as usize / ebpf::INSN_SIZE;\n+                        let target_pc = (sym.st_value.saturating_sub(text_section.sh_addr)\n+                            as usize)\n+                            .checked_div(ebpf::INSN_SIZE)\n+                            .unwrap_or_default();\n                         register_bpf_function(\n                             bpf_functions,\n                             target_pc,\n@@ -727,7 +753,12 @@ impl<E: UserDefinedError, I: InstructionMeter> Executable<E, I> {\n                         {\n                             return Err(ElfError::UnresolvedSymbol(\n                                 name.to_string(),\n-                                r_offset / ebpf::INSN_SIZE + ebpf::ELF_INSN_DUMP_OFFSET,\n+                                r_offset\n+                                    .checked_div(ebpf::INSN_SIZE)\n+                                    .and_then(|offset| {\n+                                        offset.checked_add(ebpf::ELF_INSN_DUMP_OFFSET)\n+                                    })\n+                                    .unwrap_or(ebpf::ELF_INSN_DUMP_OFFSET),\n                                 r_offset,\n                             ));\n                         }\n@@ -760,7 +791,9 @@ impl<E: UserDefinedError, I: InstructionMeter> Executable<E, I> {\n                 {\n                     return Err(ElfError::ValueOutOfBounds);\n                 }\n-                let target_pc = (symbol.st_value - text_section.sh_addr) as usize / ebpf::INSN_SIZE;\n+                let target_pc = (symbol.st_value.saturating_sub(text_section.sh_addr) as usize)\n+                    .checked_div(ebpf::INSN_SIZE)\n+                    .unwrap_or_default();\n                 let name = elf\n                     .strtab\n                     .get_at(symbol.st_name)\n",
    "diff_parsed": "{'added': [(245, '        let offset = (self'), (246, '            .text_section_info'), (247, '            .vaddr'), (248, '            .saturating_sub(ebpf::MM_PROGRAM_START)) as usize;'), (251, '            &self.ro_section'), (252, '                [offset..offset.saturating_add(self.text_section_info.offset_range.len())],'), (318, '            file_offset'), (319, '                .checked_div(ebpf::INSN_SIZE)'), (320, '                .and_then(|offset| offset.checked_add(ebpf::ELF_INSN_DUMP_OFFSET))'), (321, '                .unwrap_or(ebpf::ELF_INSN_DUMP_OFFSET),'), (417, '        let offset = elf.header.e_entry.saturating_sub(text_section.sh_addr);'), (418, '        if offset.checked_rem(ebpf::INSN_SIZE as u64) != Some(0) {'), (419, '            return Err(ElfError::InvalidEntrypoint);'), (420, '        }'), (421, '        if let Some(entrypoint) = (offset as usize).checked_div(ebpf::INSN_SIZE) {'), (422, '            bpf_functions.remove(&ebpf::hash_symbol_name(b\"entrypoint\"));'), (423, '            register_bpf_function('), (424, '                &mut bpf_functions,'), (425, '                entrypoint,'), (426, '                \"entrypoint\",'), (427, '                config.enable_symbol_and_section_labels,'), (428, '            )?;'), (429, '        } else {'), (434, '        let mut ro_length ='), (435, '            (text_section.sh_addr as usize).saturating_add(text_section_info.offset_range.len());'), (459, '                ro_length ='), (460, '                    ro_length.max((section_header.sh_addr as usize).saturating_add(slice.len()));'), (464, '        if ro_length > elf_bytes.len() {'), (465, '            return Err(ElfError::ValueOutOfBounds);'), (466, '        }'), (469, '            ..(text_section.sh_addr as usize).saturating_add(text_section_info.offset_range.len())]'), (477, '            ro_section[*offset..offset.saturating_add(slice.len())].copy_from_slice(slice);'), (500, '        let instruction_count = elf_bytes'), (501, '            .len()'), (502, '            .checked_div(ebpf::INSN_SIZE)'), (503, '            .ok_or(ElfError::ValueOutOfBounds)?;'), (504, '        for i in 0..instruction_count {'), (507, '                let target_pc = (i as isize)'), (508, '                    .saturating_add(1)'), (509, '                    .saturating_add(insn.imm as isize);'), (510, '                if target_pc < 0 || target_pc >= instruction_count as isize {'), (512, '                        i.saturating_add(ebpf::ELF_INSN_DUMP_OFFSET),'), (523, '                let offset = i.saturating_mul(ebpf::INSN_SIZE);'), (525, '                    .get_mut(offset..offset.saturating_add(ebpf::INSN_SIZE))'), (551, '        let num_text_sections ='), (552, '            elf.section_headers'), (553, '                .iter()'), (554, '                .fold(0, |count: usize, section_header| {'), (555, '                    if let Some(this_name) = elf.shdr_strtab.get_at(section_header.sh_name) {'), (556, '                        if this_name == \".text\" {'), (557, '                            return count.saturating_add(1);'), (558, '                        }'), (559, '                    }'), (560, '                    count'), (561, '                });'), (655, '                    let addr = sym.st_value.saturating_add(refd_pa) as u64;'), (660, '                    let file_offset = imm_offset.saturating_add(ebpf::INSN_SIZE);'), (662, '                        .get_mut(file_offset..file_offset.saturating_add(BYTE_LENGTH_IMMEIDATE))'), (664, '                    LittleEndian::write_u32('), (665, '                        checked_slice,'), (666, '                        addr.checked_shr(32).unwrap_or_default() as u32,'), (667, '                    );'), (701, '                        let file_offset = imm_offset.saturating_add(ebpf::INSN_SIZE);'), (703, '                            .get_mut(file_offset..file_offset.saturating_add(BYTE_LENGTH_IMMEIDATE))'), (705, '                        LittleEndian::write_u32('), (706, '                            checked_slice,'), (707, '                            refd_pa.checked_shr(32).unwrap_or_default() as u32,'), (708, '                        );'), (735, '                        let target_pc = (sym.st_value.saturating_sub(text_section.sh_addr)'), (736, '                            as usize)'), (737, '                            .checked_div(ebpf::INSN_SIZE)'), (738, '                            .unwrap_or_default();'), (756, '                                r_offset'), (757, '                                    .checked_div(ebpf::INSN_SIZE)'), (758, '                                    .and_then(|offset| {'), (759, '                                        offset.checked_add(ebpf::ELF_INSN_DUMP_OFFSET)'), (760, '                                    })'), (761, '                                    .unwrap_or(ebpf::ELF_INSN_DUMP_OFFSET),'), (794, '                let target_pc = (symbol.st_value.saturating_sub(text_section.sh_addr) as usize)'), (795, '                    .checked_div(ebpf::INSN_SIZE)'), (796, '                    .unwrap_or_default();')], 'deleted': [(1, '#![allow(clippy::integer_arithmetic)]'), (246, '        let offset = (self.text_section_info.vaddr - ebpf::MM_PROGRAM_START) as usize;'), (249, '            &self.ro_section[offset..offset + self.text_section_info.offset_range.len()],'), (315, '            file_offset / ebpf::INSN_SIZE + ebpf::ELF_INSN_DUMP_OFFSET,'), (411, '        let offset = elf.header.e_entry - text_section.sh_addr;'), (412, '        if offset % ebpf::INSN_SIZE as u64 != 0 {'), (415, '        let entrypoint = offset as usize / ebpf::INSN_SIZE;'), (416, '        bpf_functions.remove(&ebpf::hash_symbol_name(b\"entrypoint\"));'), (417, '        register_bpf_function('), (418, '            &mut bpf_functions,'), (419, '            entrypoint,'), (420, '            \"entrypoint\",'), (421, '            config.enable_symbol_and_section_labels,'), (422, '        )?;'), (425, '        let mut ro_length = text_section.sh_addr as usize + text_section_info.offset_range.len();'), (449, '                ro_length = ro_length.max(section_header.sh_addr as usize + slice.len());'), (455, '            ..text_section.sh_addr as usize + text_section_info.offset_range.len()]'), (463, '            ro_section[*offset..*offset + slice.len()].copy_from_slice(slice);'), (486, '        for i in 0..elf_bytes.len() / ebpf::INSN_SIZE {'), (489, '                let target_pc = i as isize + 1 + insn.imm as isize;'), (490, '                if target_pc < 0 || target_pc >= (elf_bytes.len() / ebpf::INSN_SIZE) as isize {'), (492, '                        i + ebpf::ELF_INSN_DUMP_OFFSET,'), (504, '                    .get_mut(i * ebpf::INSN_SIZE..(i * ebpf::INSN_SIZE) + ebpf::INSN_SIZE)'), (530, '        let num_text_sections = elf.section_headers.iter().fold(0, |count, section_header| {'), (531, '            if let Some(this_name) = elf.shdr_strtab.get_at(section_header.sh_name) {'), (532, '                if this_name == \".text\" {'), (533, '                    return count + 1;'), (534, '                }'), (535, '            }'), (536, '            count'), (537, '        });'), (631, '                    let addr = (sym.st_value + refd_pa) as u64;'), (637, '                        .get_mut('), (638, '                            imm_offset.saturating_add(ebpf::INSN_SIZE)'), (639, '                                ..imm_offset'), (640, '                                    .saturating_add(ebpf::INSN_SIZE + BYTE_LENGTH_IMMEIDATE),'), (641, '                        )'), (643, '                    LittleEndian::write_u32(checked_slice, (addr >> 32) as u32);'), (678, '                            .get_mut('), (679, '                                imm_offset.saturating_add(ebpf::INSN_SIZE)'), (680, '                                    ..imm_offset'), (681, '                                        .saturating_add(ebpf::INSN_SIZE + BYTE_LENGTH_IMMEIDATE),'), (682, '                            )'), (684, '                        LittleEndian::write_u32(checked_slice, (refd_pa >> 32) as u32);'), (711, '                        let target_pc ='), (712, '                            (sym.st_value - text_section.sh_addr) as usize / ebpf::INSN_SIZE;'), (730, '                                r_offset / ebpf::INSN_SIZE + ebpf::ELF_INSN_DUMP_OFFSET,'), (763, '                let target_pc = (symbol.st_value - text_section.sh_addr) as usize / ebpf::INSN_SIZE;')]}",
    "num_lines_added": "81",
    "num_lines_deleted": "48",
    "nloc": "950"
  },
  {
    "file_change_id": "73182420682696",
    "hash": "fae052b834b097ced9a89a8fff8466e18f38307",
    "old_path": "src/crypto/generichash/digest.rs",
    "new_path": "src/crypto/generichash/digest.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -26,7 +26,7 @@ impl PartialEq for Digest {\n         if other.len != self.len {\n             return false;\n         }\n-        memcmp(self.as_ref(), self.as_ref())\n+        memcmp(self.as_ref(), other.as_ref())\n     }\n }\n \n",
    "diff_parsed": "{'added': [(29, '        memcmp(self.as_ref(), other.as_ref())')], 'deleted': [(29, '        memcmp(self.as_ref(), self.as_ref())')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "88"
  },
  {
    "file_change_id": "98539175739786",
    "hash": "fae052b834b097ced9a89a8fff8466e18f38307",
    "old_path": "src/crypto/generichash/mod.rs",
    "new_path": "src/crypto/generichash/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -191,4 +191,25 @@ mod test {\n             assert!(result_hash.as_ref() == expected_hash.as_slice());\n         }\n     }\n+\n+    #[test]\n+    fn test_digest_equality() {\n+        let data1 = [1, 2];\n+        let data2 = [3, 4];\n+\n+        let h1 = {\n+            let mut hasher = State::new(32, None).unwrap();\n+            hasher.update(&data1).unwrap();\n+            hasher.finalize().unwrap()\n+        };\n+\n+        let h2 = {\n+            let mut hasher = State::new(32, None).unwrap();\n+            hasher.update(&data2).unwrap();\n+            hasher.finalize().unwrap()\n+        };\n+\n+        assert_eq!(h1, h1);\n+        assert_ne!(h1, h2);\n+    }\n }\n",
    "diff_parsed": "{'added': [(195, '    #[test]'), (196, '    fn test_digest_equality() {'), (197, '        let data1 = [1, 2];'), (198, '        let data2 = [3, 4];'), (200, '        let h1 = {'), (201, '            let mut hasher = State::new(32, None).unwrap();'), (202, '            hasher.update(&data1).unwrap();'), (203, '            hasher.finalize().unwrap()'), (204, '        };'), (206, '        let h2 = {'), (207, '            let mut hasher = State::new(32, None).unwrap();'), (208, '            hasher.update(&data2).unwrap();'), (209, '            hasher.finalize().unwrap()'), (210, '        };'), (212, '        assert_eq!(h1, h1);'), (213, '        assert_ne!(h1, h2);'), (214, '    }')], 'deleted': []}",
    "num_lines_added": "17",
    "num_lines_deleted": "0",
    "nloc": "162"
  },
  {
    "file_change_id": "180585151170052",
    "hash": "e88c6ff22e0d1a7b0733d9b90fadc4722763d7d",
    "old_path": "src/cfb.rs",
    "new_path": "src/cfb.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -245,9 +245,7 @@ impl Sectors {\n         let end = start + self.size;\n         if end > self.data.len() {\n             let mut len = self.data.len();\n-            unsafe {\n-                self.data.set_len(end);\n-            }\n+            self.data.resize(end, 0);\n             // read_exact or stop if EOF\n             while len < end {\n                 let read = r.read(&mut self.data[len..end]).map_err(CfbError::Io)?;\n",
    "diff_parsed": "{'added': [(248, '            self.data.resize(end, 0);')], 'deleted': [(248, '            unsafe {'), (249, '                self.data.set_len(end);'), (250, '            }')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "3",
    "nloc": "383"
  },
  {
    "file_change_id": "151732644109886",
    "hash": "e093c2b7b6ecbf34f8afbd87ee111df256957e4",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1103,8 +1103,9 @@ pub fn prefresh(pad: WINDOW, pmin_row: i32, pmin_col: i32, smin_row: i32, smin_c\n { unsafe { ll::prefresh(pad, pmin_row, pmin_col, smin_row, smin_col, smax_row, smax_col) } }\n \n \n-pub fn printw(s: &str) -> i32\n-{ unsafe { ll::printw(s.to_c_str().as_ptr()) } }\n+#[deprecated(since = \"5.98.0\", note = \"printw can segfault when printing string that contains % sign. Use addstr instead\")]\n+unsafe pub fn printw(s: &str) -> i32\n+{ ll::printw(s.to_c_str().as_ptr()) }\n \n \n pub fn putp(s: &str) -> i32\n",
    "diff_parsed": "{'added': [(1106, '#[deprecated(since = \"5.98.0\", note = \"printw can segfault when printing string that contains % sign. Use addstr instead\")]'), (1107, 'unsafe pub fn printw(s: &str) -> i32'), (1108, '{ ll::printw(s.to_c_str().as_ptr()) }')], 'deleted': [(1106, 'pub fn printw(s: &str) -> i32'), (1107, '{ unsafe { ll::printw(s.to_c_str().as_ptr()) } }')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "2",
    "nloc": "1259"
  },
  {
    "file_change_id": "139932283641547",
    "hash": "a9165de8065bab6ee6969a1b31ddac549f634c1",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1104,7 +1104,7 @@ pub fn prefresh(pad: WINDOW, pmin_row: i32, pmin_col: i32, smin_row: i32, smin_c\n \n \n #[deprecated(since = \"5.98.0\", note = \"printw can segfault when printing string that contains % sign. Use addstr instead\")]\n-unsafe pub fn printw(s: &str) -> i32\n+pub fn printw(s: &str) -> i32\n { ll::printw(s.to_c_str().as_ptr()) }\n \n \n",
    "diff_parsed": "{'added': [(1107, 'pub fn printw(s: &str) -> i32')], 'deleted': [(1107, 'unsafe pub fn printw(s: &str) -> i32')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "1259"
  },
  {
    "file_change_id": "83185189766760",
    "hash": "7fcee591341b3d37c25676cbac868bd27b4b208",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1105,7 +1105,7 @@ pub fn prefresh(pad: WINDOW, pmin_row: i32, pmin_col: i32, smin_row: i32, smin_c\n \n #[deprecated(since = \"5.98.0\", note = \"printw can segfault when printing string that contains % sign. Use addstr instead\")]\n pub fn printw(s: &str) -> i32\n-{ ll::printw(s.to_c_str().as_ptr()) }\n+{ unsafe { ll::printw(s.to_c_str().as_ptr()) } }\n \n \n pub fn putp(s: &str) -> i32\n",
    "diff_parsed": "{'added': [(1108, '{ unsafe { ll::printw(s.to_c_str().as_ptr()) } }')], 'deleted': [(1108, '{ ll::printw(s.to_c_str().as_ptr()) }')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "1259"
  },
  {
    "file_change_id": "226672161556895",
    "hash": "0df01c9d0c5d42166dc49e903002f53978ef10e",
    "old_path": "src/rw_lock.rs",
    "new_path": "src/rw_lock.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -3,6 +3,7 @@ use core::cell::UnsafeCell;\n use core::ops::{Deref, DerefMut};\n use core::fmt;\n use core::default::Default;\n+use core::mem;\n \n /// A reader-writer lock\n ///\n@@ -16,9 +17,12 @@ use core::default::Default;\n /// allow concurrent access through readers. The RAII guards returned from the\n /// locking methods implement `Deref` (and `DerefMut` for the `write` methods)\n /// to allow access to the contained of the lock.\n+/// \n+/// Read RAII guards are upgradeable to write RAII locks through the\n+/// [`upgrade`](RwLockReadGuard::upgrade) / [`try_upgrade`](RwLockReadGuard::try_upgrade) functions.\n ///\n-/// Based on\n-/// <https://jfdube.wordpress.com/2014/01/03/implementing-a-recursive-read-write-spinlock/>\n+/// Based on Facebook's\n+/// [`folly/RWSpinLock.h`](https://github.com/facebook/folly/blob/a0394d84f2d5c3e50ebfd0566f9d3acb52cfab5a/folly/synchronization/RWSpinLock.h).\n ///\n /// # Examples\n ///\n@@ -48,6 +52,10 @@ pub struct RwLock<T: ?Sized>\n     data: UnsafeCell<T>,\n }\n \n+const READER: usize = 4;\n+const UPGRADED: usize = 2;\n+const WRITER: usize = 1;\n+\n /// A guard from which the protected data can be read\n ///\n /// When the guard falls out of scope it will decrement the read count,\n@@ -69,12 +77,25 @@ pub struct RwLockWriteGuard<'a, T: 'a + ?Sized>\n     data: &'a mut T,\n }\n \n+/// A guard from which the protected data can be read, and can be upgraded\n+/// to a writable guard if needed\n+/// \n+/// No writers or other upgradeable guards can exist while this is in scope. New reader\n+/// creation is prevented (to alleviate writer starvation) but there may be existing readers\n+/// when the lock is acquired.\n+/// \n+/// When the guard falls out of scope it will release the lock.\n+#[derive(Debug)]\n+pub struct RwLockUpgradeableGuard<'a, T: 'a + ?Sized>\n+{\n+    lock: &'a AtomicUsize,\n+    data: &'a T,\n+}\n+\n // Same unsafe impls as `std::sync::RwLock`\n unsafe impl<T: ?Sized + Send> Send for RwLock<T> {}\n unsafe impl<T: ?Sized + Send + Sync> Sync for RwLock<T> {}\n \n-const USIZE_MSB: usize = ::core::isize::MIN as usize;\n-\n impl<T> RwLock<T>\n {\n     /// Creates a new spinlock wrapping the supplied data.\n@@ -103,6 +124,7 @@ impl<T> RwLock<T>\n     }\n \n     /// Consumes this `RwLock`, returning the underlying data.\n+    #[inline]\n     pub fn into_inner(self) -> T\n     {\n         // We know statically that there are no outstanding references to\n@@ -136,35 +158,13 @@ impl<T: ?Sized> RwLock<T>\n     /// }\n     /// ```\n     #[inline]\n-    pub fn read<'a>(&'a self) -> RwLockReadGuard<'a, T>\n+    pub fn read(&self) -> RwLockReadGuard<T>\n     {\n-        // (funny do-while loop)\n-        while {\n-            // Old value, with write bit unset\n-            let mut old;\n-\n-            // Wait for for writer to go away before doing expensive atomic ops\n-            // (funny do-while loop)\n-            while {\n-                old = self.lock.load(Ordering::Relaxed);\n-                old & USIZE_MSB != 0\n-            } {\n-                cpu_relax();\n+        loop {\n+            match self.try_read() {\n+                Some(guard) => return guard,\n+                None => cpu_relax(),\n             }\n-\n-            // unset write bit\n-            old &= !USIZE_MSB;\n-\n-            let new = old + 1;\n-            debug_assert!(new != (!USIZE_MSB) & (!0));\n-\n-            self.lock.compare_and_swap(old, new, Ordering::SeqCst) != old\n-        } {\n-            cpu_relax();\n-        }\n-        RwLockReadGuard {\n-            lock: &self.lock,\n-            data: unsafe { & *self.data.get() },\n         }\n     }\n \n@@ -193,21 +193,19 @@ impl<T: ?Sized> RwLock<T>\n     #[inline]\n     pub fn try_read(&self) -> Option<RwLockReadGuard<T>>\n     {\n-        // Old value, with write bit unset\n-        let old = (!USIZE_MSB) & self.lock.load(Ordering::Relaxed);\n-\n-        let new = old + 1;\n-        debug_assert!(new != (!USIZE_MSB) & (!0));\n-        if self.lock.compare_and_swap(old,\n-                                      new,\n-                                      Ordering::SeqCst) == old\n-        {\n+        let value = self.lock.fetch_add(READER, Ordering::Acquire);\n+\n+        // We check the UPGRADED bit here so that new readers are prevented when an UPGRADED lock is held.\n+        // This helps reduce writer starvation.\n+        if value & (WRITER | UPGRADED) != 0 {\n+            // Lock is taken, undo.\n+            self.lock.fetch_sub(READER, Ordering::Release);\n+            None\n+        } else {\n             Some(RwLockReadGuard {\n                 lock: &self.lock,\n-                data: unsafe { & *self.data.get() },\n+                data: unsafe { &*self.data.get() },\n             })\n-        } else {\n-            None\n         }\n     }\n \n@@ -216,20 +214,23 @@ impl<T: ?Sized> RwLock<T>\n     /// This is *extremely* unsafe if there are outstanding `RwLockReadGuard`s\n     /// live, or if called more times than `read` has been called, but can be\n     /// useful in FFI contexts where the caller doesn't know how to deal with\n-    /// RAII.\n+    /// RAII. The underlying atomic operation uses `Ordering::Release`.\n+    #[inline]\n     pub unsafe fn force_read_decrement(&self) {\n-        debug_assert!(self.lock.load(Ordering::Relaxed) & (!USIZE_MSB) > 0);\n-        self.lock.fetch_sub(1, Ordering::SeqCst);\n+        debug_assert!(self.lock.load(Ordering::Relaxed) & !WRITER > 0);\n+        self.lock.fetch_sub(READER, Ordering::Release);\n     }\n \n     /// Force unlock exclusive write access.\n     ///\n     /// This is *extremely* unsafe if there are outstanding `RwLockWriteGuard`s\n     /// live, or if called when there are current readers, but can be useful in\n-    /// FFI contexts where the caller doesn't know how to deal with RAII.\n+    /// FFI contexts where the caller doesn't know how to deal with RAII. The\n+    /// underlying atomic operation uses `Ordering::Release`.\n+    #[inline]\n     pub unsafe fn force_write_unlock(&self) {\n-        debug_assert_eq!(self.lock.load(Ordering::Relaxed), USIZE_MSB);\n-        self.lock.store(0, Ordering::Relaxed);\n+        debug_assert_eq!(self.lock.load(Ordering::Relaxed) & !(WRITER | UPGRADED), 0);\n+        self.lock.fetch_and(!(WRITER | UPGRADED), Ordering::Release);\n     }\n \n     /// Lock this rwlock with exclusive write access, blocking the current\n@@ -251,29 +252,20 @@ impl<T: ?Sized> RwLock<T>\n     /// }\n     /// ```\n     #[inline]\n-    pub fn write<'a>(&'a self) -> RwLockWriteGuard<'a, T>\n+    pub fn write(&self) -> RwLockWriteGuard<T>\n     {\n-        loop\n-        {\n-            // Old value, with write bit unset.\n-            let old = (!USIZE_MSB) & self.lock.load(Ordering::Relaxed);\n-            // Old value, with write bit set.\n-            let new = USIZE_MSB | old;\n-            if self.lock.compare_and_swap(old,\n-                                          new,\n-                                          Ordering::SeqCst) == old\n-            {\n-                // Wait for readers to go away, then lock is ours.\n-                while self.lock.load(Ordering::Relaxed) != USIZE_MSB {\n-                    cpu_relax();\n-                }\n-                break\n+        loop {\n+            // Use compare_exchange_weak as a slight optimisation instead of just calling try_write which\n+            // uses compare_exchange (strong) internally.\n+            if self.lock.compare_exchange_weak(0, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {\n+                return RwLockWriteGuard {\n+                    lock: &self.lock,\n+                    data: unsafe { &mut *self.data.get() },\n+                };\n+            } else {\n+                cpu_relax();\n             }\n         }\n-        RwLockWriteGuard {\n-            lock: &self.lock,\n-            data: unsafe { &mut *self.data.get() },\n-        }\n     }\n \n     /// Attempt to lock this rwlock with exclusive write access.\n@@ -298,10 +290,7 @@ impl<T: ?Sized> RwLock<T>\n     #[inline]\n     pub fn try_write(&self) -> Option<RwLockWriteGuard<T>>\n     {\n-        if self.lock.compare_and_swap(0,\n-                                      USIZE_MSB,\n-                                      Ordering::SeqCst) == 0\n-        {\n+        if self.lock.compare_exchange(0, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {\n             Some(RwLockWriteGuard {\n                 lock: &self.lock,\n                 data: unsafe { &mut *self.data.get() },\n@@ -310,6 +299,111 @@ impl<T: ?Sized> RwLock<T>\n             None\n         }\n     }\n+\n+    /// Obtain a readable lock guard that can later be upgraded to a writable lock guard.\n+    /// Upgrades can be done through the [`RwLock::upgrade`](RwLock::upgrade) method.\n+    #[inline]\n+    pub fn upgradeable_read(&self) -> RwLockUpgradeableGuard<T> {\n+        loop {\n+            match self.try_upgradeable_read() {\n+                Some(guard) => return guard,\n+                None => cpu_relax(),\n+            }\n+        }\n+    }\n+\n+    /// Tries to obtain an upgradeable lock guard.\n+    #[inline]\n+    pub fn try_upgradeable_read(&self) -> Option<RwLockUpgradeableGuard<T>> {\n+        if self.lock.fetch_or(UPGRADED, Ordering::Acquire) & (WRITER | UPGRADED) == 0 {\n+            Some(RwLockUpgradeableGuard {\n+                lock: &self.lock,\n+                data: unsafe { &mut *self.data.get() },\n+            })\n+        } else {\n+            // We can't unflip the UPGRADED bit back just yet as there is another upgradeable or write lock. \n+            // When they unlock, they will clear the bit.\n+            None\n+        }\n+    }\n+\n+    /// Upgrades an upgradeable lock guard to a writable lock guard.\n+    /// \n+    /// ```\n+    /// let mylock = spin::RwLock::new(0);\n+    /// \n+    /// let upgradeable = mylock.upgradeable_read(); // Readable, but not yet writable\n+    /// let writable = mylock.upgrade(upgradeable);\n+    /// ```\n+    #[inline]\n+    pub fn upgrade<'a>(&self, guard: RwLockUpgradeableGuard<'a, T>) -> RwLockWriteGuard<T> {\n+        loop {\n+            // Use compare_exchange_weak as a slight optimisation instead of just calling try_upgrade which\n+            // uses compare_exchange (strong) internally.\n+            if self.lock.compare_exchange_weak(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {\n+                // Upgrade successful - forget the old guard so its destructor doesn't run\n+                mem::forget(guard);\n+\n+                return RwLockWriteGuard {\n+                    lock: &self.lock,\n+                    data: unsafe { &mut *self.data.get() },\n+                };\n+            }\n+\n+            cpu_relax();\n+        }\n+    }\n+\n+    /// Tries to upgrade an upgradeable lock guard to a writable lock guard.\n+    /// \n+    /// ```\n+    /// let mylock = spin::RwLock::new(0);\n+    /// let upgradeable = mylock.upgradeable_read(); // Readable, but not yet writable\n+    /// \n+    /// match mylock.try_upgrade(upgradeable) {\n+    ///     Ok(writable) => /* upgrade successful - use writable lock guard */ (),\n+    ///     Err(upgradeable) => /* upgrade unsuccessful */ (),\n+    /// };\n+    /// ```\n+    #[inline]\n+    pub fn try_upgrade<'a>(&self, guard: RwLockUpgradeableGuard<'a, T>) -> Result<RwLockWriteGuard<T>, RwLockUpgradeableGuard<'a, T>> {\n+        if self.lock.compare_exchange(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {\n+            // Upgrade successful - forget the old guard so its destructor doesn't run\n+            mem::forget(guard);\n+\n+            Ok(RwLockWriteGuard {\n+                lock: &self.lock,\n+                data: unsafe { &mut *self.data.get() },\n+            })\n+        } else {\n+            Err(guard)\n+        }\n+    }\n+\n+    /// Downgrades the writable lock guard to a readable, shared lock guard. Cannot fail and is guaranteed not to spin.\n+    /// \n+    /// ```\n+    /// let mylock = spin::RwLock::new(0);\n+    /// \n+    /// let mut writable = mylock.write();\n+    /// *writable = 1;\n+    /// \n+    /// let readable = mylock.downgrade(writable); // This is guaranteed not to spin\n+    /// # let readable_2 = mylock.try_read().unwrap();\n+    /// assert_eq!(*readable, 1);\n+    /// ```\n+    #[inline]\n+    pub fn downgrade<'a>(&self, guard: RwLockWriteGuard<'a, T>) -> RwLockReadGuard<T> {\n+        self.lock.fetch_add(READER, Ordering::Acquire);\n+\n+        // Remove the WRITER bit\n+        mem::drop(guard);\n+\n+        RwLockReadGuard {\n+            lock: &self.lock,\n+            data: unsafe { &*self.data.get() },\n+        }\n+    }\n }\n \n impl<T: ?Sized + fmt::Debug> fmt::Debug for RwLock<T>\n@@ -338,6 +432,12 @@ impl<'rwlock, T: ?Sized> Deref for RwLockReadGuard<'rwlock, T> {\n     fn deref(&self) -> &T { self.data }\n }\n \n+impl<'rwlock, T: ?Sized> Deref for RwLockUpgradeableGuard<'rwlock, T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T { self.data }\n+}\n+\n impl<'rwlock, T: ?Sized> Deref for RwLockWriteGuard<'rwlock, T> {\n     type Target = T;\n \n@@ -350,15 +450,25 @@ impl<'rwlock, T: ?Sized> DerefMut for RwLockWriteGuard<'rwlock, T> {\n \n impl<'rwlock, T: ?Sized> Drop for RwLockReadGuard<'rwlock, T> {\n     fn drop(&mut self) {\n-        debug_assert!(self.lock.load(Ordering::Relaxed) & (!USIZE_MSB) > 0);\n-        self.lock.fetch_sub(1, Ordering::SeqCst);\n+        debug_assert!(self.lock.load(Ordering::Relaxed) & !(WRITER | UPGRADED) > 0);\n+        self.lock.fetch_sub(READER, Ordering::Release);\n+    }\n+}\n+\n+impl<'rwlock, T: ?Sized> Drop for RwLockUpgradeableGuard<'rwlock, T> {\n+    fn drop(&mut self) {\n+        debug_assert_eq!(self.lock.load(Ordering::Relaxed) & (WRITER | UPGRADED), UPGRADED);\n+        self.lock.fetch_sub(UPGRADED, Ordering::AcqRel);\n     }\n }\n \n impl<'rwlock, T: ?Sized> Drop for RwLockWriteGuard<'rwlock, T> {\n     fn drop(&mut self) {\n-        debug_assert_eq!(self.lock.load(Ordering::Relaxed), USIZE_MSB);\n-        self.lock.store(0, Ordering::Relaxed);\n+        debug_assert_eq!(self.lock.load(Ordering::Relaxed) & WRITER, WRITER);\n+        \n+        // Writer is responsible for clearing both WRITER and UPGRADED bits.\n+        // The UPGRADED bit may be set if an upgradeable lock attempts an upgrade while this lock is held.\n+        self.lock.fetch_and(!(WRITER | UPGRADED), Ordering::Release);\n     }\n }\n \n@@ -451,7 +561,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_rw_arc_access_in_unwind() {\n+    fn test_rw_access_in_unwind() {\n         let arc = Arc::new(RwLock::new(1));\n         let arc2 = arc.clone();\n         let _ = thread::spawn(move|| -> () {\n@@ -499,6 +609,13 @@ mod tests {\n         drop(read_guard);\n     }\n \n+    #[test]\n+    fn test_rw_try_read() {\n+        let m = RwLock::new(0);\n+        mem::forget(m.write());\n+        assert!(m.try_read().is_none());\n+    }\n+\n     #[test]\n     fn test_into_inner() {\n         let m = RwLock::new(NonCopy(10));\n@@ -551,4 +668,26 @@ mod tests {\n         }\n         assert!(m.try_read().is_some());\n     }\n+\n+    #[test]\n+    fn test_upgrade() {\n+        let m = RwLock::new(());\n+        {\n+            let _r = m.read();\n+            let upg = m.try_upgradeable_read().unwrap();\n+            assert!(m.try_read().is_none());\n+            assert!(m.try_write().is_none());\n+            assert!(m.try_upgrade(upg).is_err());\n+        }\n+        {\n+            let _w = m.write();\n+            assert!(m.try_upgradeable_read().is_none());\n+        }\n+        {\n+            let _u = m.upgradeable_read();\n+            assert!(m.try_upgradeable_read().is_none());\n+        }\n+\n+        assert!(m.try_upgrade(m.try_upgradeable_read().unwrap()).is_ok());\n+    }\n }\n",
    "diff_parsed": "{'added': [(6, 'use core::mem;'), (55, 'const READER: usize = 4;'), (56, 'const UPGRADED: usize = 2;'), (57, 'const WRITER: usize = 1;'), (88, '#[derive(Debug)]'), (89, \"pub struct RwLockUpgradeableGuard<'a, T: 'a + ?Sized>\"), (90, '{'), (91, \"    lock: &'a AtomicUsize,\"), (92, \"    data: &'a T,\"), (93, '}'), (127, '    #[inline]'), (161, '    pub fn read(&self) -> RwLockReadGuard<T>'), (163, '        loop {'), (164, '            match self.try_read() {'), (165, '                Some(guard) => return guard,'), (166, '                None => cpu_relax(),'), (196, '        let value = self.lock.fetch_add(READER, Ordering::Acquire);'), (200, '        if value & (WRITER | UPGRADED) != 0 {'), (202, '            self.lock.fetch_sub(READER, Ordering::Release);'), (203, '            None'), (204, '        } else {'), (207, '                data: unsafe { &*self.data.get() },'), (218, '    #[inline]'), (220, '        debug_assert!(self.lock.load(Ordering::Relaxed) & !WRITER > 0);'), (221, '        self.lock.fetch_sub(READER, Ordering::Release);'), (230, '    #[inline]'), (232, '        debug_assert_eq!(self.lock.load(Ordering::Relaxed) & !(WRITER | UPGRADED), 0);'), (233, '        self.lock.fetch_and(!(WRITER | UPGRADED), Ordering::Release);'), (255, '    pub fn write(&self) -> RwLockWriteGuard<T>'), (257, '        loop {'), (260, '            if self.lock.compare_exchange_weak(0, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {'), (261, '                return RwLockWriteGuard {'), (262, '                    lock: &self.lock,'), (263, '                    data: unsafe { &mut *self.data.get() },'), (264, '                };'), (265, '            } else {'), (266, '                cpu_relax();'), (293, '        if self.lock.compare_exchange(0, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {'), (305, '    #[inline]'), (306, '    pub fn upgradeable_read(&self) -> RwLockUpgradeableGuard<T> {'), (307, '        loop {'), (308, '            match self.try_upgradeable_read() {'), (309, '                Some(guard) => return guard,'), (310, '                None => cpu_relax(),'), (311, '            }'), (312, '        }'), (313, '    }'), (316, '    #[inline]'), (317, '    pub fn try_upgradeable_read(&self) -> Option<RwLockUpgradeableGuard<T>> {'), (318, '        if self.lock.fetch_or(UPGRADED, Ordering::Acquire) & (WRITER | UPGRADED) == 0 {'), (319, '            Some(RwLockUpgradeableGuard {'), (320, '                lock: &self.lock,'), (321, '                data: unsafe { &mut *self.data.get() },'), (322, '            })'), (323, '        } else {'), (326, '            None'), (327, '        }'), (328, '    }'), (338, '    #[inline]'), (339, \"    pub fn upgrade<'a>(&self, guard: RwLockUpgradeableGuard<'a, T>) -> RwLockWriteGuard<T> {\"), (340, '        loop {'), (343, '            if self.lock.compare_exchange_weak(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {'), (345, '                mem::forget(guard);'), (347, '                return RwLockWriteGuard {'), (348, '                    lock: &self.lock,'), (349, '                    data: unsafe { &mut *self.data.get() },'), (350, '                };'), (351, '            }'), (353, '            cpu_relax();'), (354, '        }'), (355, '    }'), (368, '    #[inline]'), (369, \"    pub fn try_upgrade<'a>(&self, guard: RwLockUpgradeableGuard<'a, T>) -> Result<RwLockWriteGuard<T>, RwLockUpgradeableGuard<'a, T>> {\"), (370, '        if self.lock.compare_exchange(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {'), (372, '            mem::forget(guard);'), (374, '            Ok(RwLockWriteGuard {'), (375, '                lock: &self.lock,'), (376, '                data: unsafe { &mut *self.data.get() },'), (377, '            })'), (378, '        } else {'), (379, '            Err(guard)'), (380, '        }'), (381, '    }'), (395, '    #[inline]'), (396, \"    pub fn downgrade<'a>(&self, guard: RwLockWriteGuard<'a, T>) -> RwLockReadGuard<T> {\"), (397, '        self.lock.fetch_add(READER, Ordering::Acquire);'), (400, '        mem::drop(guard);'), (402, '        RwLockReadGuard {'), (403, '            lock: &self.lock,'), (404, '            data: unsafe { &*self.data.get() },'), (405, '        }'), (406, '    }'), (435, \"impl<'rwlock, T: ?Sized> Deref for RwLockUpgradeableGuard<'rwlock, T> {\"), (436, '    type Target = T;'), (438, '    fn deref(&self) -> &T { self.data }'), (439, '}'), (453, '        debug_assert!(self.lock.load(Ordering::Relaxed) & !(WRITER | UPGRADED) > 0);'), (454, '        self.lock.fetch_sub(READER, Ordering::Release);'), (455, '    }'), (456, '}'), (458, \"impl<'rwlock, T: ?Sized> Drop for RwLockUpgradeableGuard<'rwlock, T> {\"), (459, '    fn drop(&mut self) {'), (460, '        debug_assert_eq!(self.lock.load(Ordering::Relaxed) & (WRITER | UPGRADED), UPGRADED);'), (461, '        self.lock.fetch_sub(UPGRADED, Ordering::AcqRel);'), (467, '        debug_assert_eq!(self.lock.load(Ordering::Relaxed) & WRITER, WRITER);'), (471, '        self.lock.fetch_and(!(WRITER | UPGRADED), Ordering::Release);'), (564, '    fn test_rw_access_in_unwind() {'), (612, '    #[test]'), (613, '    fn test_rw_try_read() {'), (614, '        let m = RwLock::new(0);'), (615, '        mem::forget(m.write());'), (616, '        assert!(m.try_read().is_none());'), (617, '    }'), (672, '    #[test]'), (673, '    fn test_upgrade() {'), (674, '        let m = RwLock::new(());'), (675, '        {'), (676, '            let _r = m.read();'), (677, '            let upg = m.try_upgradeable_read().unwrap();'), (678, '            assert!(m.try_read().is_none());'), (679, '            assert!(m.try_write().is_none());'), (680, '            assert!(m.try_upgrade(upg).is_err());'), (681, '        }'), (682, '        {'), (683, '            let _w = m.write();'), (684, '            assert!(m.try_upgradeable_read().is_none());'), (685, '        }'), (686, '        {'), (687, '            let _u = m.upgradeable_read();'), (688, '            assert!(m.try_upgradeable_read().is_none());'), (689, '        }'), (691, '        assert!(m.try_upgrade(m.try_upgradeable_read().unwrap()).is_ok());'), (692, '    }')], 'deleted': [(76, 'const USIZE_MSB: usize = ::core::isize::MIN as usize;'), (139, \"    pub fn read<'a>(&'a self) -> RwLockReadGuard<'a, T>\"), (142, '        while {'), (144, '            let mut old;'), (148, '            while {'), (149, '                old = self.lock.load(Ordering::Relaxed);'), (150, '                old & USIZE_MSB != 0'), (151, '            } {'), (152, '                cpu_relax();'), (156, '            old &= !USIZE_MSB;'), (158, '            let new = old + 1;'), (159, '            debug_assert!(new != (!USIZE_MSB) & (!0));'), (161, '            self.lock.compare_and_swap(old, new, Ordering::SeqCst) != old'), (162, '        } {'), (163, '            cpu_relax();'), (164, '        }'), (165, '        RwLockReadGuard {'), (166, '            lock: &self.lock,'), (167, '            data: unsafe { & *self.data.get() },'), (197, '        let old = (!USIZE_MSB) & self.lock.load(Ordering::Relaxed);'), (199, '        let new = old + 1;'), (200, '        debug_assert!(new != (!USIZE_MSB) & (!0));'), (201, '        if self.lock.compare_and_swap(old,'), (202, '                                      new,'), (203, '                                      Ordering::SeqCst) == old'), (204, '        {'), (207, '                data: unsafe { & *self.data.get() },'), (209, '        } else {'), (210, '            None'), (221, '        debug_assert!(self.lock.load(Ordering::Relaxed) & (!USIZE_MSB) > 0);'), (222, '        self.lock.fetch_sub(1, Ordering::SeqCst);'), (231, '        debug_assert_eq!(self.lock.load(Ordering::Relaxed), USIZE_MSB);'), (232, '        self.lock.store(0, Ordering::Relaxed);'), (254, \"    pub fn write<'a>(&'a self) -> RwLockWriteGuard<'a, T>\"), (256, '        loop'), (257, '        {'), (259, '            let old = (!USIZE_MSB) & self.lock.load(Ordering::Relaxed);'), (261, '            let new = USIZE_MSB | old;'), (262, '            if self.lock.compare_and_swap(old,'), (263, '                                          new,'), (264, '                                          Ordering::SeqCst) == old'), (265, '            {'), (267, '                while self.lock.load(Ordering::Relaxed) != USIZE_MSB {'), (268, '                    cpu_relax();'), (269, '                }'), (270, '                break'), (273, '        RwLockWriteGuard {'), (274, '            lock: &self.lock,'), (275, '            data: unsafe { &mut *self.data.get() },'), (276, '        }'), (301, '        if self.lock.compare_and_swap(0,'), (302, '                                      USIZE_MSB,'), (303, '                                      Ordering::SeqCst) == 0'), (304, '        {'), (353, '        debug_assert!(self.lock.load(Ordering::Relaxed) & (!USIZE_MSB) > 0);'), (354, '        self.lock.fetch_sub(1, Ordering::SeqCst);'), (360, '        debug_assert_eq!(self.lock.load(Ordering::Relaxed), USIZE_MSB);'), (361, '        self.lock.store(0, Ordering::Relaxed);'), (454, '    fn test_rw_arc_access_in_unwind() {')]}",
    "num_lines_added": "133",
    "num_lines_deleted": "59",
    "nloc": "388"
  },
  {
    "file_change_id": "199051539905858",
    "hash": "6d1c1e335998339263f651f33d34220c4bebc5c",
    "old_path": "src/rw_lock.rs",
    "new_path": "src/rw_lock.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,9 +1,10 @@\n-use core::sync::atomic::{AtomicUsize, Ordering, spin_loop_hint as cpu_relax};\n use core::cell::UnsafeCell;\n-use core::ops::{Deref, DerefMut};\n-use core::fmt;\n use core::default::Default;\n+use core::fmt;\n use core::mem;\n+use core::ops::{Deref, DerefMut};\n+use core::ptr::NonNull;\n+use core::sync::atomic::{spin_loop_hint as cpu_relax, AtomicUsize, Ordering};\n \n /// A reader-writer lock\n ///\n@@ -17,9 +18,12 @@ use core::mem;\n /// allow concurrent access through readers. The RAII guards returned from the\n /// locking methods implement `Deref` (and `DerefMut` for the `write` methods)\n /// to allow access to the contained of the lock.\n-/// \n-/// Read RAII guards are upgradeable to write RAII locks through the\n-/// [`upgrade`](RwLockReadGuard::upgrade) / [`try_upgrade`](RwLockReadGuard::try_upgrade) functions.\n+///\n+/// An [`RwLockUpgradeableGuard`](RwLockUpgradeableGuard) can be upgraded to a\n+/// writable guard through the [`RwLockUpgradeableGuard::upgrade`](RwLockUpgradeableGuard::upgrade)\n+/// [`RwLockUpgradeableGuard::try_upgrade`](RwLockUpgradeableGuard::try_upgrade) functions.\n+/// Writable or upgradeable guards can be downgraded through their respective `downgrade`\n+/// functions.\n ///\n /// Based on Facebook's\n /// [`folly/RWSpinLock.h`](https://github.com/facebook/folly/blob/a0394d84f2d5c3e50ebfd0566f9d3acb52cfab5a/folly/synchronization/RWSpinLock.h).\n@@ -46,8 +50,7 @@ use core::mem;\n ///     assert_eq!(*w, 6);\n /// } // write lock is dropped here\n /// ```\n-pub struct RwLock<T: ?Sized>\n-{\n+pub struct RwLock<T: ?Sized> {\n     lock: AtomicUsize,\n     data: UnsafeCell<T>,\n }\n@@ -61,43 +64,39 @@ const WRITER: usize = 1;\n /// When the guard falls out of scope it will decrement the read count,\n /// potentially releasing the lock.\n #[derive(Debug)]\n-pub struct RwLockReadGuard<'a, T: 'a + ?Sized>\n-{\n+pub struct RwLockReadGuard<'a, T: 'a + ?Sized> {\n     lock: &'a AtomicUsize,\n-    data: &'a T,\n+    data: NonNull<T>,\n }\n \n /// A guard to which the protected data can be written\n ///\n /// When the guard falls out of scope it will release the lock.\n #[derive(Debug)]\n-pub struct RwLockWriteGuard<'a, T: 'a + ?Sized>\n-{\n+pub struct RwLockWriteGuard<'a, T: 'a + ?Sized> {\n     lock: &'a AtomicUsize,\n-    data: &'a mut T,\n+    data: NonNull<T>,\n }\n \n /// A guard from which the protected data can be read, and can be upgraded\n /// to a writable guard if needed\n-/// \n+///\n /// No writers or other upgradeable guards can exist while this is in scope. New reader\n /// creation is prevented (to alleviate writer starvation) but there may be existing readers\n /// when the lock is acquired.\n-/// \n+///\n /// When the guard falls out of scope it will release the lock.\n #[derive(Debug)]\n-pub struct RwLockUpgradeableGuard<'a, T: 'a + ?Sized>\n-{\n+pub struct RwLockUpgradeableGuard<'a, T: 'a + ?Sized> {\n     lock: &'a AtomicUsize,\n-    data: &'a T,\n+    data: NonNull<T>,\n }\n \n // Same unsafe impls as `std::sync::RwLock`\n unsafe impl<T: ?Sized + Send> Send for RwLock<T> {}\n unsafe impl<T: ?Sized + Send + Sync> Sync for RwLock<T> {}\n \n-impl<T> RwLock<T>\n-{\n+impl<T> RwLock<T> {\n     /// Creates a new spinlock wrapping the supplied data.\n     ///\n     /// May be used statically:\n@@ -114,10 +113,8 @@ impl<T> RwLock<T>\n     /// }\n     /// ```\n     #[inline]\n-    pub const fn new(user_data: T) -> RwLock<T>\n-    {\n-        RwLock\n-        {\n+    pub const fn new(user_data: T) -> RwLock<T> {\n+        RwLock {\n             lock: AtomicUsize::new(0),\n             data: UnsafeCell::new(user_data),\n         }\n@@ -125,8 +122,7 @@ impl<T> RwLock<T>\n \n     /// Consumes this `RwLock`, returning the underlying data.\n     #[inline]\n-    pub fn into_inner(self) -> T\n-    {\n+    pub fn into_inner(self) -> T {\n         // We know statically that there are no outstanding references to\n         // `self` so there's no need to lock.\n         let RwLock { data, .. } = self;\n@@ -134,8 +130,7 @@ impl<T> RwLock<T>\n     }\n }\n \n-impl<T: ?Sized> RwLock<T>\n-{\n+impl<T: ?Sized> RwLock<T> {\n     /// Locks this rwlock with shared read access, blocking the current thread\n     /// until it can be acquired.\n     ///\n@@ -158,8 +153,7 @@ impl<T: ?Sized> RwLock<T>\n     /// }\n     /// ```\n     #[inline]\n-    pub fn read(&self) -> RwLockReadGuard<T>\n-    {\n+    pub fn read(&self) -> RwLockReadGuard<T> {\n         loop {\n             match self.try_read() {\n                 Some(guard) => return guard,\n@@ -191,8 +185,7 @@ impl<T: ?Sized> RwLock<T>\n     /// }\n     /// ```\n     #[inline]\n-    pub fn try_read(&self) -> Option<RwLockReadGuard<T>>\n-    {\n+    pub fn try_read(&self) -> Option<RwLockReadGuard<T>> {\n         let value = self.lock.fetch_add(READER, Ordering::Acquire);\n \n         // We check the UPGRADED bit here so that new readers are prevented when an UPGRADED lock is held.\n@@ -204,7 +197,7 @@ impl<T: ?Sized> RwLock<T>\n         } else {\n             Some(RwLockReadGuard {\n                 lock: &self.lock,\n-                data: unsafe { &*self.data.get() },\n+                data: unsafe { NonNull::new_unchecked(self.data.get()) },\n             })\n         }\n     }\n@@ -252,15 +245,18 @@ impl<T: ?Sized> RwLock<T>\n     /// }\n     /// ```\n     #[inline]\n-    pub fn write(&self) -> RwLockWriteGuard<T>\n-    {\n+    pub fn write(&self) -> RwLockWriteGuard<T> {\n         loop {\n             // Use compare_exchange_weak as a slight optimisation instead of just calling try_write which\n             // uses compare_exchange (strong) internally.\n-            if self.lock.compare_exchange_weak(0, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {\n+            if self\n+                .lock\n+                .compare_exchange_weak(0, WRITER, Ordering::Acquire, Ordering::Relaxed)\n+                .is_ok()\n+            {\n                 return RwLockWriteGuard {\n                     lock: &self.lock,\n-                    data: unsafe { &mut *self.data.get() },\n+                    data: unsafe { NonNull::new_unchecked(self.data.get()) },\n                 };\n             } else {\n                 cpu_relax();\n@@ -288,12 +284,15 @@ impl<T: ?Sized> RwLock<T>\n     /// }\n     /// ```\n     #[inline]\n-    pub fn try_write(&self) -> Option<RwLockWriteGuard<T>>\n-    {\n-        if self.lock.compare_exchange(0, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {\n+    pub fn try_write(&self) -> Option<RwLockWriteGuard<T>> {\n+        if self\n+            .lock\n+            .compare_exchange(0, WRITER, Ordering::Acquire, Ordering::Relaxed)\n+            .is_ok()\n+        {\n             Some(RwLockWriteGuard {\n                 lock: &self.lock,\n-                data: unsafe { &mut *self.data.get() },\n+                data: unsafe { NonNull::new_unchecked(self.data.get()) },\n             })\n         } else {\n             None\n@@ -301,7 +300,7 @@ impl<T: ?Sized> RwLock<T>\n     }\n \n     /// Obtain a readable lock guard that can later be upgraded to a writable lock guard.\n-    /// Upgrades can be done through the [`RwLock::upgrade`](RwLock::upgrade) method.\n+    /// Upgrades can be done through the [`RwLockUpgradeableGuard::upgrade`](RwLockUpgradeableGuard::upgrade) method.\n     #[inline]\n     pub fn upgradeable_read(&self) -> RwLockUpgradeableGuard<T> {\n         loop {\n@@ -318,36 +317,62 @@ impl<T: ?Sized> RwLock<T>\n         if self.lock.fetch_or(UPGRADED, Ordering::Acquire) & (WRITER | UPGRADED) == 0 {\n             Some(RwLockUpgradeableGuard {\n                 lock: &self.lock,\n-                data: unsafe { &mut *self.data.get() },\n+                data: unsafe { NonNull::new_unchecked(self.data.get()) },\n             })\n         } else {\n-            // We can't unflip the UPGRADED bit back just yet as there is another upgradeable or write lock. \n+            // We can't unflip the UPGRADED bit back just yet as there is another upgradeable or write lock.\n             // When they unlock, they will clear the bit.\n             None\n         }\n     }\n+}\n \n+impl<T: ?Sized + fmt::Debug> fmt::Debug for RwLock<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.try_read() {\n+            Some(guard) => write!(f, \"RwLock {{ data: \")\n+                .and_then(|()| (&*guard).fmt(f))\n+                .and_then(|()| write!(f, \"}}\")),\n+            None => write!(f, \"RwLock {{ <locked> }}\"),\n+        }\n+    }\n+}\n+\n+impl<T: ?Sized + Default> Default for RwLock<T> {\n+    fn default() -> RwLock<T> {\n+        RwLock::new(Default::default())\n+    }\n+}\n+\n+impl<'rwlock, T: ?Sized> RwLockUpgradeableGuard<'rwlock, T> {\n     /// Upgrades an upgradeable lock guard to a writable lock guard.\n-    /// \n+    ///\n     /// ```\n     /// let mylock = spin::RwLock::new(0);\n-    /// \n+    ///\n     /// let upgradeable = mylock.upgradeable_read(); // Readable, but not yet writable\n-    /// let writable = mylock.upgrade(upgradeable);\n+    /// let writable = upgradeable.upgrade();\n     /// ```\n     #[inline]\n-    pub fn upgrade<'a>(&self, guard: RwLockUpgradeableGuard<'a, T>) -> RwLockWriteGuard<T> {\n+    pub fn upgrade(self) -> RwLockWriteGuard<'rwlock, T> {\n         loop {\n             // Use compare_exchange_weak as a slight optimisation instead of just calling try_upgrade which\n             // uses compare_exchange (strong) internally.\n-            if self.lock.compare_exchange_weak(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {\n-                // Upgrade successful - forget the old guard so its destructor doesn't run\n-                mem::forget(guard);\n-\n-                return RwLockWriteGuard {\n-                    lock: &self.lock,\n-                    data: unsafe { &mut *self.data.get() },\n+            if self\n+                .lock\n+                .compare_exchange_weak(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed)\n+                .is_ok()\n+            {\n+                // Upgrade successful\n+                let out = RwLockWriteGuard {\n+                    lock: self.lock,\n+                    data: self.data,\n                 };\n+\n+                // Forget the old guard so its destructor doesn't run\n+                mem::forget(self);\n+\n+                return out;\n             }\n \n             cpu_relax();\n@@ -355,97 +380,120 @@ impl<T: ?Sized> RwLock<T>\n     }\n \n     /// Tries to upgrade an upgradeable lock guard to a writable lock guard.\n-    /// \n+    ///\n     /// ```\n     /// let mylock = spin::RwLock::new(0);\n     /// let upgradeable = mylock.upgradeable_read(); // Readable, but not yet writable\n-    /// \n-    /// match mylock.try_upgrade(upgradeable) {\n+    ///\n+    /// match upgradeable.try_upgrade() {\n     ///     Ok(writable) => /* upgrade successful - use writable lock guard */ (),\n     ///     Err(upgradeable) => /* upgrade unsuccessful */ (),\n     /// };\n     /// ```\n     #[inline]\n-    pub fn try_upgrade<'a>(&self, guard: RwLockUpgradeableGuard<'a, T>) -> Result<RwLockWriteGuard<T>, RwLockUpgradeableGuard<'a, T>> {\n-        if self.lock.compare_exchange(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {\n-            // Upgrade successful - forget the old guard so its destructor doesn't run\n-            mem::forget(guard);\n-\n-            Ok(RwLockWriteGuard {\n+    pub fn try_upgrade(self) -> Result<RwLockWriteGuard<'rwlock, T>, Self> {\n+        if self\n+            .lock\n+            .compare_exchange(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed)\n+            .is_ok()\n+        {\n+            // Upgrade successful\n+            let out = Ok(RwLockWriteGuard {\n                 lock: &self.lock,\n-                data: unsafe { &mut *self.data.get() },\n-            })\n+                data: self.data,\n+            });\n+\n+            // Forget the old guard so its destructor doesn't run\n+            mem::forget(self);\n+\n+            out\n         } else {\n-            Err(guard)\n+            Err(self)\n+        }\n+    }\n+\n+    #[inline]\n+    /// Downgrades the upgradeable lock guard to a readable, shared lock guard. Cannot fail and is guaranteed not to spin.\n+    ///\n+    /// ```\n+    /// let mylock = spin::RwLock::new(1);\n+    ///\n+    /// let upgradeable = mylock.upgradeable_read();\n+    /// assert!(mylock.try_read().is_none());\n+    /// assert_eq!(*upgradeable, 1);\n+    ///\n+    /// let readable = upgradeable.downgrade(); // This is guaranteed not to spin\n+    /// assert!(mylock.try_read().is_some());\n+    /// assert_eq!(*readable, 1);\n+    /// ```\n+    pub fn downgrade(self) -> RwLockReadGuard<'rwlock, T> {\n+        // Reserve the read guard for ourselves\n+        self.lock.fetch_add(READER, Ordering::Acquire);\n+\n+        RwLockReadGuard {\n+            lock: &self.lock,\n+            data: self.data,\n         }\n+\n+        // Dropping self removes the UPGRADED bit\n     }\n+}\n \n+impl<'rwlock, T: ?Sized> RwLockWriteGuard<'rwlock, T> {\n     /// Downgrades the writable lock guard to a readable, shared lock guard. Cannot fail and is guaranteed not to spin.\n-    /// \n+    ///\n     /// ```\n     /// let mylock = spin::RwLock::new(0);\n-    /// \n+    ///\n     /// let mut writable = mylock.write();\n     /// *writable = 1;\n-    /// \n-    /// let readable = mylock.downgrade(writable); // This is guaranteed not to spin\n+    ///\n+    /// let readable = writable.downgrade(); // This is guaranteed not to spin\n     /// # let readable_2 = mylock.try_read().unwrap();\n     /// assert_eq!(*readable, 1);\n     /// ```\n     #[inline]\n-    pub fn downgrade<'a>(&self, guard: RwLockWriteGuard<'a, T>) -> RwLockReadGuard<T> {\n+    pub fn downgrade(self) -> RwLockReadGuard<'rwlock, T> {\n+        // Reserve the read guard for ourselves\n         self.lock.fetch_add(READER, Ordering::Acquire);\n \n-        // Remove the WRITER bit\n-        mem::drop(guard);\n-\n         RwLockReadGuard {\n             lock: &self.lock,\n-            data: unsafe { &*self.data.get() },\n+            data: self.data,\n         }\n-    }\n-}\n \n-impl<T: ?Sized + fmt::Debug> fmt::Debug for RwLock<T>\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result\n-    {\n-        match self.try_read()\n-        {\n-            Some(guard) => write!(f, \"RwLock {{ data: \")\n-                .and_then(|()| (&*guard).fmt(f))\n-                .and_then(|()| write!(f, \"}}\")),\n-            None => write!(f, \"RwLock {{ <locked> }}\"),\n-        }\n-    }\n-}\n-\n-impl<T: ?Sized + Default> Default for RwLock<T> {\n-    fn default() -> RwLock<T> {\n-        RwLock::new(Default::default())\n+        // Dropping self removes the WRITER bit\n     }\n }\n \n impl<'rwlock, T: ?Sized> Deref for RwLockReadGuard<'rwlock, T> {\n     type Target = T;\n \n-    fn deref(&self) -> &T { self.data }\n+    fn deref(&self) -> &T {\n+        unsafe { self.data.as_ref() }\n+    }\n }\n \n impl<'rwlock, T: ?Sized> Deref for RwLockUpgradeableGuard<'rwlock, T> {\n     type Target = T;\n \n-    fn deref(&self) -> &T { self.data }\n+    fn deref(&self) -> &T {\n+        unsafe { self.data.as_ref() }\n+    }\n }\n \n impl<'rwlock, T: ?Sized> Deref for RwLockWriteGuard<'rwlock, T> {\n     type Target = T;\n \n-    fn deref(&self) -> &T { self.data }\n+    fn deref(&self) -> &T {\n+        unsafe { self.data.as_ref() }\n+    }\n }\n \n impl<'rwlock, T: ?Sized> DerefMut for RwLockWriteGuard<'rwlock, T> {\n-    fn deref_mut(&mut self) -> &mut T { self.data }\n+    fn deref_mut(&mut self) -> &mut T {\n+        unsafe { self.data.as_mut() }\n+    }\n }\n \n impl<'rwlock, T: ?Sized> Drop for RwLockReadGuard<'rwlock, T> {\n@@ -457,7 +505,10 @@ impl<'rwlock, T: ?Sized> Drop for RwLockReadGuard<'rwlock, T> {\n \n impl<'rwlock, T: ?Sized> Drop for RwLockUpgradeableGuard<'rwlock, T> {\n     fn drop(&mut self) {\n-        debug_assert_eq!(self.lock.load(Ordering::Relaxed) & (WRITER | UPGRADED), UPGRADED);\n+        debug_assert_eq!(\n+            self.lock.load(Ordering::Relaxed) & (WRITER | UPGRADED),\n+            UPGRADED\n+        );\n         self.lock.fetch_sub(UPGRADED, Ordering::AcqRel);\n     }\n }\n@@ -465,7 +516,7 @@ impl<'rwlock, T: ?Sized> Drop for RwLockUpgradeableGuard<'rwlock, T> {\n impl<'rwlock, T: ?Sized> Drop for RwLockWriteGuard<'rwlock, T> {\n     fn drop(&mut self) {\n         debug_assert_eq!(self.lock.load(Ordering::Relaxed) & WRITER, WRITER);\n-        \n+\n         // Writer is responsible for clearing both WRITER and UPGRADED bits.\n         // The UPGRADED bit may be set if an upgradeable lock attempts an upgrade while this lock is held.\n         self.lock.fetch_and(!(WRITER | UPGRADED), Ordering::Release);\n@@ -476,9 +527,9 @@ impl<'rwlock, T: ?Sized> Drop for RwLockWriteGuard<'rwlock, T> {\n mod tests {\n     use std::prelude::v1::*;\n \n-    use std::sync::Arc;\n-    use std::sync::mpsc::channel;\n     use std::sync::atomic::{AtomicUsize, Ordering};\n+    use std::sync::mpsc::channel;\n+    use std::sync::Arc;\n     use std::thread;\n \n     use super::*;\n@@ -528,7 +579,7 @@ mod tests {\n         let arc2 = arc.clone();\n         let (tx, rx) = channel();\n \n-        thread::spawn(move|| {\n+        thread::spawn(move || {\n             let mut lock = arc2.write();\n             for _ in 0..10 {\n                 let tmp = *lock;\n@@ -543,7 +594,7 @@ mod tests {\n         let mut children = Vec::new();\n         for _ in 0..5 {\n             let arc3 = arc.clone();\n-            children.push(thread::spawn(move|| {\n+            children.push(thread::spawn(move || {\n                 let lock = arc3.read();\n                 assert!(*lock >= 0);\n             }));\n@@ -564,7 +615,7 @@ mod tests {\n     fn test_rw_access_in_unwind() {\n         let arc = Arc::new(RwLock::new(1));\n         let arc2 = arc.clone();\n-        let _ = thread::spawn(move|| -> () {\n+        let _ = thread::spawn(move || -> () {\n             struct Unwinder {\n                 i: Arc<RwLock<isize>>,\n             }\n@@ -576,7 +627,8 @@ mod tests {\n             }\n             let _u = Unwinder { i: arc2 };\n             panic!();\n-        }).join();\n+        })\n+        .join();\n         let lock = arc.read();\n         assert_eq!(*lock, 2);\n     }\n@@ -603,7 +655,10 @@ mod tests {\n         let write_result = lock.try_write();\n         match write_result {\n             None => (),\n-            Some(_) => assert!(false, \"try_write should not succeed while read_guard is in scope\"),\n+            Some(_) => assert!(\n+                false,\n+                \"try_write should not succeed while read_guard is in scope\"\n+            ),\n         }\n \n         drop(read_guard);\n@@ -670,24 +725,28 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_upgrade() {\n+    fn test_upgrade_downgrade() {\n         let m = RwLock::new(());\n         {\n             let _r = m.read();\n             let upg = m.try_upgradeable_read().unwrap();\n             assert!(m.try_read().is_none());\n             assert!(m.try_write().is_none());\n-            assert!(m.try_upgrade(upg).is_err());\n+            assert!(upg.try_upgrade().is_err());\n         }\n         {\n-            let _w = m.write();\n+            let w = m.write();\n             assert!(m.try_upgradeable_read().is_none());\n+            let _r = w.downgrade();\n+            assert!(m.try_upgradeable_read().is_some());\n+            assert!(m.try_read().is_some());\n+            assert!(m.try_write().is_none());\n         }\n         {\n             let _u = m.upgradeable_read();\n             assert!(m.try_upgradeable_read().is_none());\n         }\n \n-        assert!(m.try_upgrade(m.try_upgradeable_read().unwrap()).is_ok());\n+        assert!(m.try_upgradeable_read().unwrap().try_upgrade().is_ok());\n     }\n }\n",
    "diff_parsed": "{'added': [(3, 'use core::fmt;'), (5, 'use core::ops::{Deref, DerefMut};'), (6, 'use core::ptr::NonNull;'), (7, 'use core::sync::atomic::{spin_loop_hint as cpu_relax, AtomicUsize, Ordering};'), (53, 'pub struct RwLock<T: ?Sized> {'), (67, \"pub struct RwLockReadGuard<'a, T: 'a + ?Sized> {\"), (69, '    data: NonNull<T>,'), (76, \"pub struct RwLockWriteGuard<'a, T: 'a + ?Sized> {\"), (78, '    data: NonNull<T>,'), (90, \"pub struct RwLockUpgradeableGuard<'a, T: 'a + ?Sized> {\"), (92, '    data: NonNull<T>,'), (99, 'impl<T> RwLock<T> {'), (116, '    pub const fn new(user_data: T) -> RwLock<T> {'), (117, '        RwLock {'), (125, '    pub fn into_inner(self) -> T {'), (133, 'impl<T: ?Sized> RwLock<T> {'), (156, '    pub fn read(&self) -> RwLockReadGuard<T> {'), (188, '    pub fn try_read(&self) -> Option<RwLockReadGuard<T>> {'), (200, '                data: unsafe { NonNull::new_unchecked(self.data.get()) },'), (248, '    pub fn write(&self) -> RwLockWriteGuard<T> {'), (252, '            if self'), (253, '                .lock'), (254, '                .compare_exchange_weak(0, WRITER, Ordering::Acquire, Ordering::Relaxed)'), (255, '                .is_ok()'), (256, '            {'), (259, '                    data: unsafe { NonNull::new_unchecked(self.data.get()) },'), (287, '    pub fn try_write(&self) -> Option<RwLockWriteGuard<T>> {'), (288, '        if self'), (289, '            .lock'), (290, '            .compare_exchange(0, WRITER, Ordering::Acquire, Ordering::Relaxed)'), (291, '            .is_ok()'), (292, '        {'), (295, '                data: unsafe { NonNull::new_unchecked(self.data.get()) },'), (320, '                data: unsafe { NonNull::new_unchecked(self.data.get()) },'), (328, '}'), (330, 'impl<T: ?Sized + fmt::Debug> fmt::Debug for RwLock<T> {'), (331, '    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {'), (332, '        match self.try_read() {'), (333, '            Some(guard) => write!(f, \"RwLock {{ data: \")'), (334, '                .and_then(|()| (&*guard).fmt(f))'), (335, '                .and_then(|()| write!(f, \"}}\")),'), (336, '            None => write!(f, \"RwLock {{ <locked> }}\"),'), (337, '        }'), (338, '    }'), (339, '}'), (341, 'impl<T: ?Sized + Default> Default for RwLock<T> {'), (342, '    fn default() -> RwLock<T> {'), (343, '        RwLock::new(Default::default())'), (344, '    }'), (345, '}'), (347, \"impl<'rwlock, T: ?Sized> RwLockUpgradeableGuard<'rwlock, T> {\"), (357, \"    pub fn upgrade(self) -> RwLockWriteGuard<'rwlock, T> {\"), (361, '            if self'), (362, '                .lock'), (363, '                .compare_exchange_weak(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed)'), (364, '                .is_ok()'), (365, '            {'), (367, '                let out = RwLockWriteGuard {'), (368, '                    lock: self.lock,'), (369, '                    data: self.data,'), (373, '                mem::forget(self);'), (375, '                return out;'), (394, \"    pub fn try_upgrade(self) -> Result<RwLockWriteGuard<'rwlock, T>, Self> {\"), (395, '        if self'), (396, '            .lock'), (397, '            .compare_exchange(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed)'), (398, '            .is_ok()'), (399, '        {'), (401, '            let out = Ok(RwLockWriteGuard {'), (403, '                data: self.data,'), (404, '            });'), (407, '            mem::forget(self);'), (409, '            out'), (411, '            Err(self)'), (412, '        }'), (413, '    }'), (415, '    #[inline]'), (429, \"    pub fn downgrade(self) -> RwLockReadGuard<'rwlock, T> {\"), (431, '        self.lock.fetch_add(READER, Ordering::Acquire);'), (433, '        RwLockReadGuard {'), (434, '            lock: &self.lock,'), (435, '            data: self.data,'), (440, '}'), (442, \"impl<'rwlock, T: ?Sized> RwLockWriteGuard<'rwlock, T> {\"), (456, \"    pub fn downgrade(self) -> RwLockReadGuard<'rwlock, T> {\"), (462, '            data: self.data,'), (472, '    fn deref(&self) -> &T {'), (473, '        unsafe { self.data.as_ref() }'), (474, '    }'), (480, '    fn deref(&self) -> &T {'), (481, '        unsafe { self.data.as_ref() }'), (482, '    }'), (488, '    fn deref(&self) -> &T {'), (489, '        unsafe { self.data.as_ref() }'), (490, '    }'), (494, '    fn deref_mut(&mut self) -> &mut T {'), (495, '        unsafe { self.data.as_mut() }'), (496, '    }'), (508, '        debug_assert_eq!('), (509, '            self.lock.load(Ordering::Relaxed) & (WRITER | UPGRADED),'), (510, '            UPGRADED'), (511, '        );'), (531, '    use std::sync::mpsc::channel;'), (532, '    use std::sync::Arc;'), (582, '        thread::spawn(move || {'), (597, '            children.push(thread::spawn(move || {'), (618, '        let _ = thread::spawn(move || -> () {'), (630, '        })'), (631, '        .join();'), (658, '            Some(_) => assert!('), (659, '                false,'), (660, '                \"try_write should not succeed while read_guard is in scope\"'), (661, '            ),'), (728, '    fn test_upgrade_downgrade() {'), (735, '            assert!(upg.try_upgrade().is_err());'), (738, '            let w = m.write();'), (740, '            let _r = w.downgrade();'), (741, '            assert!(m.try_upgradeable_read().is_some());'), (742, '            assert!(m.try_read().is_some());'), (743, '            assert!(m.try_write().is_none());'), (750, '        assert!(m.try_upgradeable_read().unwrap().try_upgrade().is_ok());')], 'deleted': [(1, 'use core::sync::atomic::{AtomicUsize, Ordering, spin_loop_hint as cpu_relax};'), (3, 'use core::ops::{Deref, DerefMut};'), (4, 'use core::fmt;'), (49, 'pub struct RwLock<T: ?Sized>'), (50, '{'), (64, \"pub struct RwLockReadGuard<'a, T: 'a + ?Sized>\"), (65, '{'), (67, \"    data: &'a T,\"), (74, \"pub struct RwLockWriteGuard<'a, T: 'a + ?Sized>\"), (75, '{'), (77, \"    data: &'a mut T,\"), (89, \"pub struct RwLockUpgradeableGuard<'a, T: 'a + ?Sized>\"), (90, '{'), (92, \"    data: &'a T,\"), (99, 'impl<T> RwLock<T>'), (100, '{'), (117, '    pub const fn new(user_data: T) -> RwLock<T>'), (118, '    {'), (119, '        RwLock'), (120, '        {'), (128, '    pub fn into_inner(self) -> T'), (129, '    {'), (137, 'impl<T: ?Sized> RwLock<T>'), (138, '{'), (161, '    pub fn read(&self) -> RwLockReadGuard<T>'), (162, '    {'), (194, '    pub fn try_read(&self) -> Option<RwLockReadGuard<T>>'), (195, '    {'), (207, '                data: unsafe { &*self.data.get() },'), (255, '    pub fn write(&self) -> RwLockWriteGuard<T>'), (256, '    {'), (260, '            if self.lock.compare_exchange_weak(0, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {'), (263, '                    data: unsafe { &mut *self.data.get() },'), (291, '    pub fn try_write(&self) -> Option<RwLockWriteGuard<T>>'), (292, '    {'), (293, '        if self.lock.compare_exchange(0, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {'), (296, '                data: unsafe { &mut *self.data.get() },'), (321, '                data: unsafe { &mut *self.data.get() },'), (339, \"    pub fn upgrade<'a>(&self, guard: RwLockUpgradeableGuard<'a, T>) -> RwLockWriteGuard<T> {\"), (343, '            if self.lock.compare_exchange_weak(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {'), (345, '                mem::forget(guard);'), (347, '                return RwLockWriteGuard {'), (348, '                    lock: &self.lock,'), (349, '                    data: unsafe { &mut *self.data.get() },'), (369, \"    pub fn try_upgrade<'a>(&self, guard: RwLockUpgradeableGuard<'a, T>) -> Result<RwLockWriteGuard<T>, RwLockUpgradeableGuard<'a, T>> {\"), (370, '        if self.lock.compare_exchange(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {'), (372, '            mem::forget(guard);'), (374, '            Ok(RwLockWriteGuard {'), (376, '                data: unsafe { &mut *self.data.get() },'), (377, '            })'), (379, '            Err(guard)'), (396, \"    pub fn downgrade<'a>(&self, guard: RwLockWriteGuard<'a, T>) -> RwLockReadGuard<T> {\"), (400, '        mem::drop(guard);'), (404, '            data: unsafe { &*self.data.get() },'), (406, '    }'), (407, '}'), (409, 'impl<T: ?Sized + fmt::Debug> fmt::Debug for RwLock<T>'), (410, '{'), (411, '    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result'), (412, '    {'), (413, '        match self.try_read()'), (414, '        {'), (415, '            Some(guard) => write!(f, \"RwLock {{ data: \")'), (416, '                .and_then(|()| (&*guard).fmt(f))'), (417, '                .and_then(|()| write!(f, \"}}\")),'), (418, '            None => write!(f, \"RwLock {{ <locked> }}\"),'), (419, '        }'), (420, '    }'), (421, '}'), (423, 'impl<T: ?Sized + Default> Default for RwLock<T> {'), (424, '    fn default() -> RwLock<T> {'), (425, '        RwLock::new(Default::default())'), (432, '    fn deref(&self) -> &T { self.data }'), (438, '    fn deref(&self) -> &T { self.data }'), (444, '    fn deref(&self) -> &T { self.data }'), (448, '    fn deref_mut(&mut self) -> &mut T { self.data }'), (460, '        debug_assert_eq!(self.lock.load(Ordering::Relaxed) & (WRITER | UPGRADED), UPGRADED);'), (479, '    use std::sync::Arc;'), (480, '    use std::sync::mpsc::channel;'), (531, '        thread::spawn(move|| {'), (546, '            children.push(thread::spawn(move|| {'), (567, '        let _ = thread::spawn(move|| -> () {'), (579, '        }).join();'), (606, '            Some(_) => assert!(false, \"try_write should not succeed while read_guard is in scope\"),'), (673, '    fn test_upgrade() {'), (680, '            assert!(m.try_upgrade(upg).is_err());'), (683, '            let _w = m.write();'), (691, '        assert!(m.try_upgrade(m.try_upgradeable_read().unwrap()).is_ok());')]}",
    "num_lines_added": "121",
    "num_lines_deleted": "88",
    "nloc": "471"
  },
  {
    "file_change_id": "226024033273744",
    "hash": "2aab6e058ae16f9caa3aff2a6bf2602926eb60a",
    "old_path": "src/rw_lock.rs",
    "new_path": "src/rw_lock.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -4,6 +4,7 @@ use core::fmt;\n use core::mem;\n use core::ops::{Deref, DerefMut};\n use core::ptr::NonNull;\n+use core::marker::PhantomData;\n use core::sync::atomic::{spin_loop_hint as cpu_relax, AtomicUsize, Ordering};\n \n /// A reader-writer lock\n@@ -76,6 +77,8 @@ pub struct RwLockReadGuard<'a, T: 'a + ?Sized> {\n pub struct RwLockWriteGuard<'a, T: 'a + ?Sized> {\n     lock: &'a AtomicUsize,\n     data: NonNull<T>,\n+    #[doc(hidden)]\n+    _invariant: PhantomData<&'a mut T>,\n }\n \n /// A guard from which the protected data can be read, and can be upgraded\n@@ -90,6 +93,8 @@ pub struct RwLockWriteGuard<'a, T: 'a + ?Sized> {\n pub struct RwLockUpgradeableGuard<'a, T: 'a + ?Sized> {\n     lock: &'a AtomicUsize,\n     data: NonNull<T>,\n+    #[doc(hidden)]\n+    _invariant: PhantomData<&'a mut T>,\n }\n \n // Same unsafe impls as `std::sync::RwLock`\n@@ -257,6 +262,7 @@ impl<T: ?Sized> RwLock<T> {\n                 return RwLockWriteGuard {\n                     lock: &self.lock,\n                     data: unsafe { NonNull::new_unchecked(self.data.get()) },\n+                    _invariant: PhantomData,\n                 };\n             } else {\n                 cpu_relax();\n@@ -293,6 +299,7 @@ impl<T: ?Sized> RwLock<T> {\n             Some(RwLockWriteGuard {\n                 lock: &self.lock,\n                 data: unsafe { NonNull::new_unchecked(self.data.get()) },\n+                _invariant: PhantomData,\n             })\n         } else {\n             None\n@@ -318,6 +325,7 @@ impl<T: ?Sized> RwLock<T> {\n             Some(RwLockUpgradeableGuard {\n                 lock: &self.lock,\n                 data: unsafe { NonNull::new_unchecked(self.data.get()) },\n+                _invariant: PhantomData,\n             })\n         } else {\n             // We can't unflip the UPGRADED bit back just yet as there is another upgradeable or write lock.\n@@ -367,6 +375,7 @@ impl<'rwlock, T: ?Sized> RwLockUpgradeableGuard<'rwlock, T> {\n                 let out = RwLockWriteGuard {\n                     lock: self.lock,\n                     data: self.data,\n+                    _invariant: PhantomData,\n                 };\n \n                 // Forget the old guard so its destructor doesn't run\n@@ -401,6 +410,7 @@ impl<'rwlock, T: ?Sized> RwLockUpgradeableGuard<'rwlock, T> {\n             let out = Ok(RwLockWriteGuard {\n                 lock: &self.lock,\n                 data: self.data,\n+                _invariant: PhantomData,\n             });\n \n             // Forget the old guard so its destructor doesn't run\n",
    "diff_parsed": "{'added': [(7, 'use core::marker::PhantomData;'), (80, '    #[doc(hidden)]'), (81, \"    _invariant: PhantomData<&'a mut T>,\"), (96, '    #[doc(hidden)]'), (97, \"    _invariant: PhantomData<&'a mut T>,\"), (265, '                    _invariant: PhantomData,'), (302, '                _invariant: PhantomData,'), (328, '                _invariant: PhantomData,'), (378, '                    _invariant: PhantomData,'), (413, '                _invariant: PhantomData,')], 'deleted': []}",
    "num_lines_added": "10",
    "num_lines_deleted": "0",
    "nloc": "490"
  },
  {
    "file_change_id": "124677808837010",
    "hash": "ba0220287e8801d6ecff0de2199b39d2e699698",
    "old_path": "src/rw_lock.rs",
    "new_path": "src/rw_lock.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,10 +1,10 @@\n use core::cell::UnsafeCell;\n use core::default::Default;\n use core::fmt;\n+use core::marker::PhantomData;\n use core::mem;\n use core::ops::{Deref, DerefMut};\n use core::ptr::NonNull;\n-use core::marker::PhantomData;\n use core::sync::atomic::{spin_loop_hint as cpu_relax, AtomicUsize, Ordering};\n \n /// A reader-writer lock\n@@ -231,6 +231,28 @@ impl<T: ?Sized> RwLock<T> {\n         self.lock.fetch_and(!(WRITER | UPGRADED), Ordering::Release);\n     }\n \n+    #[inline(always)]\n+    fn try_write_internal(&self, strong: bool) -> Option<RwLockWriteGuard<T>> {\n+        if compare_exchange(\n+            &self.lock,\n+            0,\n+            WRITER,\n+            Ordering::Acquire,\n+            Ordering::Relaxed,\n+            strong,\n+        )\n+        .is_ok()\n+        {\n+            Some(RwLockWriteGuard {\n+                lock: &self.lock,\n+                data: unsafe { NonNull::new_unchecked(self.data.get()) },\n+                _invariant: PhantomData,\n+            })\n+        } else {\n+            None\n+        }\n+    }\n+\n     /// Lock this rwlock with exclusive write access, blocking the current\n     /// thread until it can be acquired.\n     ///\n@@ -252,20 +274,9 @@ impl<T: ?Sized> RwLock<T> {\n     #[inline]\n     pub fn write(&self) -> RwLockWriteGuard<T> {\n         loop {\n-            // Use compare_exchange_weak as a slight optimisation instead of just calling try_write which\n-            // uses compare_exchange (strong) internally.\n-            if self\n-                .lock\n-                .compare_exchange_weak(0, WRITER, Ordering::Acquire, Ordering::Relaxed)\n-                .is_ok()\n-            {\n-                return RwLockWriteGuard {\n-                    lock: &self.lock,\n-                    data: unsafe { NonNull::new_unchecked(self.data.get()) },\n-                    _invariant: PhantomData,\n-                };\n-            } else {\n-                cpu_relax();\n+            match self.try_write_internal(false) {\n+                Some(guard) => return guard,\n+                None => cpu_relax(),\n             }\n         }\n     }\n@@ -291,19 +302,7 @@ impl<T: ?Sized> RwLock<T> {\n     /// ```\n     #[inline]\n     pub fn try_write(&self) -> Option<RwLockWriteGuard<T>> {\n-        if self\n-            .lock\n-            .compare_exchange(0, WRITER, Ordering::Acquire, Ordering::Relaxed)\n-            .is_ok()\n-        {\n-            Some(RwLockWriteGuard {\n-                lock: &self.lock,\n-                data: unsafe { NonNull::new_unchecked(self.data.get()) },\n-                _invariant: PhantomData,\n-            })\n-        } else {\n-            None\n-        }\n+        self.try_write_internal(false)\n     }\n \n     /// Obtain a readable lock guard that can later be upgraded to a writable lock guard.\n@@ -353,6 +352,34 @@ impl<T: ?Sized + Default> Default for RwLock<T> {\n }\n \n impl<'rwlock, T: ?Sized> RwLockUpgradeableGuard<'rwlock, T> {\n+    #[inline(always)]\n+    fn try_upgrade_internal(self, strong: bool) -> Result<RwLockWriteGuard<'rwlock, T>, Self> {\n+        if compare_exchange(\n+            &self.lock,\n+            UPGRADED,\n+            WRITER,\n+            Ordering::Acquire,\n+            Ordering::Relaxed,\n+            strong,\n+        )\n+        .is_ok()\n+        {\n+            // Upgrade successful\n+            let out = Ok(RwLockWriteGuard {\n+                lock: &self.lock,\n+                data: self.data,\n+                _invariant: PhantomData,\n+            });\n+\n+            // Forget the old guard so its destructor doesn't run\n+            mem::forget(self);\n+\n+            out\n+        } else {\n+            Err(self)\n+        }\n+    }\n+\n     /// Upgrades an upgradeable lock guard to a writable lock guard.\n     ///\n     /// ```\n@@ -362,27 +389,12 @@ impl<'rwlock, T: ?Sized> RwLockUpgradeableGuard<'rwlock, T> {\n     /// let writable = upgradeable.upgrade();\n     /// ```\n     #[inline]\n-    pub fn upgrade(self) -> RwLockWriteGuard<'rwlock, T> {\n+    pub fn upgrade(mut self) -> RwLockWriteGuard<'rwlock, T> {\n         loop {\n-            // Use compare_exchange_weak as a slight optimisation instead of just calling try_upgrade which\n-            // uses compare_exchange (strong) internally.\n-            if self\n-                .lock\n-                .compare_exchange_weak(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed)\n-                .is_ok()\n-            {\n-                // Upgrade successful\n-                let out = RwLockWriteGuard {\n-                    lock: self.lock,\n-                    data: self.data,\n-                    _invariant: PhantomData,\n-                };\n-\n-                // Forget the old guard so its destructor doesn't run\n-                mem::forget(self);\n-\n-                return out;\n-            }\n+            self = match self.try_upgrade_internal(false) {\n+                Ok(guard) => return guard,\n+                Err(e) => e,\n+            };\n \n             cpu_relax();\n         }\n@@ -401,25 +413,7 @@ impl<'rwlock, T: ?Sized> RwLockUpgradeableGuard<'rwlock, T> {\n     /// ```\n     #[inline]\n     pub fn try_upgrade(self) -> Result<RwLockWriteGuard<'rwlock, T>, Self> {\n-        if self\n-            .lock\n-            .compare_exchange(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed)\n-            .is_ok()\n-        {\n-            // Upgrade successful\n-            let out = Ok(RwLockWriteGuard {\n-                lock: &self.lock,\n-                data: self.data,\n-                _invariant: PhantomData,\n-            });\n-\n-            // Forget the old guard so its destructor doesn't run\n-            mem::forget(self);\n-\n-            out\n-        } else {\n-            Err(self)\n-        }\n+        self.try_upgrade_internal(true)\n     }\n \n     #[inline]\n@@ -533,6 +527,22 @@ impl<'rwlock, T: ?Sized> Drop for RwLockWriteGuard<'rwlock, T> {\n     }\n }\n \n+#[inline(always)]\n+fn compare_exchange(\n+    atomic: &AtomicUsize,\n+    current: usize,\n+    new: usize,\n+    success: Ordering,\n+    failure: Ordering,\n+    strong: bool,\n+) -> Result<usize, usize> {\n+    if strong {\n+        atomic.compare_exchange(current, new, success, failure)\n+    } else {\n+        atomic.compare_exchange_weak(current, new, success, failure)\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use std::prelude::v1::*;\n",
    "diff_parsed": "{'added': [(4, 'use core::marker::PhantomData;'), (234, '    #[inline(always)]'), (235, '    fn try_write_internal(&self, strong: bool) -> Option<RwLockWriteGuard<T>> {'), (236, '        if compare_exchange('), (237, '            &self.lock,'), (238, '            0,'), (239, '            WRITER,'), (240, '            Ordering::Acquire,'), (241, '            Ordering::Relaxed,'), (242, '            strong,'), (243, '        )'), (244, '        .is_ok()'), (245, '        {'), (246, '            Some(RwLockWriteGuard {'), (247, '                lock: &self.lock,'), (248, '                data: unsafe { NonNull::new_unchecked(self.data.get()) },'), (249, '                _invariant: PhantomData,'), (250, '            })'), (251, '        } else {'), (252, '            None'), (253, '        }'), (254, '    }'), (277, '            match self.try_write_internal(false) {'), (278, '                Some(guard) => return guard,'), (279, '                None => cpu_relax(),'), (305, '        self.try_write_internal(false)'), (355, '    #[inline(always)]'), (356, \"    fn try_upgrade_internal(self, strong: bool) -> Result<RwLockWriteGuard<'rwlock, T>, Self> {\"), (357, '        if compare_exchange('), (358, '            &self.lock,'), (359, '            UPGRADED,'), (360, '            WRITER,'), (361, '            Ordering::Acquire,'), (362, '            Ordering::Relaxed,'), (363, '            strong,'), (364, '        )'), (365, '        .is_ok()'), (366, '        {'), (368, '            let out = Ok(RwLockWriteGuard {'), (369, '                lock: &self.lock,'), (370, '                data: self.data,'), (371, '                _invariant: PhantomData,'), (372, '            });'), (375, '            mem::forget(self);'), (377, '            out'), (378, '        } else {'), (379, '            Err(self)'), (380, '        }'), (381, '    }'), (392, \"    pub fn upgrade(mut self) -> RwLockWriteGuard<'rwlock, T> {\"), (394, '            self = match self.try_upgrade_internal(false) {'), (395, '                Ok(guard) => return guard,'), (396, '                Err(e) => e,'), (397, '            };'), (416, '        self.try_upgrade_internal(true)'), (530, '#[inline(always)]'), (531, 'fn compare_exchange('), (532, '    atomic: &AtomicUsize,'), (533, '    current: usize,'), (534, '    new: usize,'), (535, '    success: Ordering,'), (536, '    failure: Ordering,'), (537, '    strong: bool,'), (538, ') -> Result<usize, usize> {'), (539, '    if strong {'), (540, '        atomic.compare_exchange(current, new, success, failure)'), (541, '    } else {'), (542, '        atomic.compare_exchange_weak(current, new, success, failure)'), (543, '    }'), (544, '}')], 'deleted': [(7, 'use core::marker::PhantomData;'), (257, '            if self'), (258, '                .lock'), (259, '                .compare_exchange_weak(0, WRITER, Ordering::Acquire, Ordering::Relaxed)'), (260, '                .is_ok()'), (261, '            {'), (262, '                return RwLockWriteGuard {'), (263, '                    lock: &self.lock,'), (264, '                    data: unsafe { NonNull::new_unchecked(self.data.get()) },'), (265, '                    _invariant: PhantomData,'), (266, '                };'), (267, '            } else {'), (268, '                cpu_relax();'), (294, '        if self'), (295, '            .lock'), (296, '            .compare_exchange(0, WRITER, Ordering::Acquire, Ordering::Relaxed)'), (297, '            .is_ok()'), (298, '        {'), (299, '            Some(RwLockWriteGuard {'), (300, '                lock: &self.lock,'), (301, '                data: unsafe { NonNull::new_unchecked(self.data.get()) },'), (302, '                _invariant: PhantomData,'), (303, '            })'), (304, '        } else {'), (305, '            None'), (306, '        }'), (365, \"    pub fn upgrade(self) -> RwLockWriteGuard<'rwlock, T> {\"), (369, '            if self'), (370, '                .lock'), (371, '                .compare_exchange_weak(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed)'), (372, '                .is_ok()'), (373, '            {'), (375, '                let out = RwLockWriteGuard {'), (376, '                    lock: self.lock,'), (377, '                    data: self.data,'), (378, '                    _invariant: PhantomData,'), (379, '                };'), (382, '                mem::forget(self);'), (384, '                return out;'), (385, '            }'), (404, '        if self'), (405, '            .lock'), (406, '            .compare_exchange(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed)'), (407, '            .is_ok()'), (408, '        {'), (410, '            let out = Ok(RwLockWriteGuard {'), (411, '                lock: &self.lock,'), (412, '                data: self.data,'), (413, '                _invariant: PhantomData,'), (414, '            });'), (417, '            mem::forget(self);'), (419, '            out'), (420, '        } else {'), (421, '            Err(self)'), (422, '        }')]}",
    "num_lines_added": "70",
    "num_lines_deleted": "55",
    "nloc": "513"
  },
  {
    "file_change_id": "259502251510466",
    "hash": "4bda3d9e3837e90008de3a26fb0d8182fc5227e",
    "old_path": "src/rw_lock.rs",
    "new_path": "src/rw_lock.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -302,7 +302,7 @@ impl<T: ?Sized> RwLock<T> {\n     /// ```\n     #[inline]\n     pub fn try_write(&self) -> Option<RwLockWriteGuard<T>> {\n-        self.try_write_internal(false)\n+        self.try_write_internal(true)\n     }\n \n     /// Obtain a readable lock guard that can later be upgraded to a writable lock guard.\n",
    "diff_parsed": "{'added': [(305, '        self.try_write_internal(true)')], 'deleted': [(305, '        self.try_write_internal(false)')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "513"
  },
  {
    "file_change_id": "208452756918776",
    "hash": "75cdea2c14c81678dbecdfba67c8b75c583b1cd4",
    "old_path": "src/sys/windows/net.rs",
    "new_path": "src/sys/windows/net.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,10 +1,13 @@\n use std::io;\n-use std::mem::size_of_val;\n+use std::mem;\n use std::net::SocketAddr;\n use std::sync::Once;\n \n use winapi::ctypes::c_int;\n-use winapi::shared::ws2def::SOCKADDR;\n+use winapi::shared::inaddr::IN_ADDR;\n+use winapi::shared::in6addr::IN6_ADDR;\n+use winapi::shared::ws2def::{AF_INET, AF_INET6, ADDRESS_FAMILY, SOCKADDR, SOCKADDR_IN};\n+use winapi::shared::ws2ipdef::SOCKADDR_IN6_LH;\n use winapi::um::winsock2::{ioctlsocket, socket, FIONBIO, INVALID_SOCKET, SOCKET};\n \n /// Initialise the network stack for Windows.\n@@ -41,15 +44,50 @@ pub(crate) fn new_socket(domain: c_int, socket_type: c_int) -> io::Result<SOCKET\n     })\n }\n \n-pub(crate) fn socket_addr(addr: &SocketAddr) -> (*const SOCKADDR, c_int) {\n+/// A type with the same memory layout as `SOCKADDR`. Used in converting Rust level\n+/// SocketAddr* types into their system representation. The benefit of this specific\n+/// type over using `SOCKADDR_STORAGE` is that this type is exactly as large as it\n+/// needs to be and not a lot larger. And it can be initialized cleaner from Rust.\n+#[repr(C)]\n+pub(crate) union SocketAddrCRepr {\n+    v4: SOCKADDR_IN,\n+    v6: SOCKADDR_IN6_LH,\n+}\n+\n+impl SocketAddrCRepr {\n+    pub(crate) fn as_ptr(&self) -> *const SOCKADDR {\n+        self as *const _ as *const SOCKADDR\n+    }\n+}\n+\n+pub(crate) fn socket_addr(addr: &SocketAddr) -> (SocketAddrCRepr, c_int) {\n     match addr {\n-        SocketAddr::V4(ref addr) => (\n-            addr as *const _ as *const SOCKADDR,\n-            size_of_val(addr) as c_int,\n-        ),\n-        SocketAddr::V6(ref addr) => (\n-            addr as *const _ as *const SOCKADDR,\n-            size_of_val(addr) as c_int,\n-        ),\n+        SocketAddr::V4(ref addr) => {\n+            // `s_addr` is stored as BE on all machine and the array is in BE order.\n+            // So the native endian conversion method is used so that it's never swapped.\n+            let sin_addr = IN_ADDR { S_un: unsafe { mem::transmute(u32::from_ne_bytes(addr.ip().octets())) } };\n+\n+            let sockaddr_in = SOCKADDR_IN {\n+                sin_family: AF_INET as ADDRESS_FAMILY,\n+                sin_port: addr.port().to_be(),\n+                sin_addr,\n+                sin_zero: [0; 8],\n+            };\n+\n+            let sockaddr = SocketAddrCRepr { v4: sockaddr_in };\n+            (sockaddr, mem::size_of::<SOCKADDR_IN>() as c_int)\n+        },\n+        SocketAddr::V6(ref addr) => {\n+            let sockaddr_in6 = SOCKADDR_IN6_LH {\n+                sin6_family: AF_INET6 as ADDRESS_FAMILY,\n+                sin6_port: addr.port().to_be(),\n+                sin6_addr: IN6_ADDR { u: unsafe { mem::transmute(addr.ip().octets()) } },\n+                sin6_flowinfo: addr.flowinfo(),\n+                u: unsafe { mem::transmute(addr.scope_id()) },\n+            };\n+\n+            let sockaddr = SocketAddrCRepr { v6: sockaddr_in6 };\n+            (sockaddr, mem::size_of::<SOCKADDR_IN6_LH>() as c_int)\n+        }\n     }\n }\n",
    "diff_parsed": "{'added': [(2, 'use std::mem;'), (7, 'use winapi::shared::inaddr::IN_ADDR;'), (8, 'use winapi::shared::in6addr::IN6_ADDR;'), (9, 'use winapi::shared::ws2def::{AF_INET, AF_INET6, ADDRESS_FAMILY, SOCKADDR, SOCKADDR_IN};'), (10, 'use winapi::shared::ws2ipdef::SOCKADDR_IN6_LH;'), (51, '#[repr(C)]'), (52, 'pub(crate) union SocketAddrCRepr {'), (53, '    v4: SOCKADDR_IN,'), (54, '    v6: SOCKADDR_IN6_LH,'), (55, '}'), (57, 'impl SocketAddrCRepr {'), (58, '    pub(crate) fn as_ptr(&self) -> *const SOCKADDR {'), (59, '        self as *const _ as *const SOCKADDR'), (60, '    }'), (61, '}'), (63, 'pub(crate) fn socket_addr(addr: &SocketAddr) -> (SocketAddrCRepr, c_int) {'), (65, '        SocketAddr::V4(ref addr) => {'), (68, '            let sin_addr = IN_ADDR { S_un: unsafe { mem::transmute(u32::from_ne_bytes(addr.ip().octets())) } };'), (70, '            let sockaddr_in = SOCKADDR_IN {'), (71, '                sin_family: AF_INET as ADDRESS_FAMILY,'), (72, '                sin_port: addr.port().to_be(),'), (73, '                sin_addr,'), (74, '                sin_zero: [0; 8],'), (75, '            };'), (77, '            let sockaddr = SocketAddrCRepr { v4: sockaddr_in };'), (78, '            (sockaddr, mem::size_of::<SOCKADDR_IN>() as c_int)'), (79, '        },'), (80, '        SocketAddr::V6(ref addr) => {'), (81, '            let sockaddr_in6 = SOCKADDR_IN6_LH {'), (82, '                sin6_family: AF_INET6 as ADDRESS_FAMILY,'), (83, '                sin6_port: addr.port().to_be(),'), (84, '                sin6_addr: IN6_ADDR { u: unsafe { mem::transmute(addr.ip().octets()) } },'), (85, '                sin6_flowinfo: addr.flowinfo(),'), (86, '                u: unsafe { mem::transmute(addr.scope_id()) },'), (87, '            };'), (89, '            let sockaddr = SocketAddrCRepr { v6: sockaddr_in6 };'), (90, '            (sockaddr, mem::size_of::<SOCKADDR_IN6_LH>() as c_int)'), (91, '        }')], 'deleted': [(2, 'use std::mem::size_of_val;'), (7, 'use winapi::shared::ws2def::SOCKADDR;'), (44, 'pub(crate) fn socket_addr(addr: &SocketAddr) -> (*const SOCKADDR, c_int) {'), (46, '        SocketAddr::V4(ref addr) => ('), (47, '            addr as *const _ as *const SOCKADDR,'), (48, '            size_of_val(addr) as c_int,'), (49, '        ),'), (50, '        SocketAddr::V6(ref addr) => ('), (51, '            addr as *const _ as *const SOCKADDR,'), (52, '            size_of_val(addr) as c_int,'), (53, '        ),')]}",
    "num_lines_added": "38",
    "num_lines_deleted": "11",
    "nloc": "70"
  },
  {
    "file_change_id": "97221986573887",
    "hash": "75cdea2c14c81678dbecdfba67c8b75c583b1cd4",
    "old_path": "src/sys/windows/tcp.rs",
    "new_path": "src/sys/windows/tcp.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -35,7 +35,7 @@ pub(crate) fn bind(socket: TcpSocket, addr: SocketAddr) -> io::Result<()> {\n \n     let (raw_addr, raw_addr_length) = socket_addr(&addr);\n     syscall!(\n-        bind(socket, raw_addr, raw_addr_length),\n+        bind(socket, raw_addr.as_ptr(), raw_addr_length),\n         PartialEq::eq,\n         SOCKET_ERROR\n     )?;\n@@ -48,7 +48,7 @@ pub(crate) fn connect(socket: TcpSocket, addr: SocketAddr) -> io::Result<net::Tc\n     let (raw_addr, raw_addr_length) = socket_addr(&addr);\n \n     let res = syscall!(\n-        connect(socket, raw_addr, raw_addr_length),\n+        connect(socket, raw_addr.as_ptr(), raw_addr_length),\n         PartialEq::eq,\n         SOCKET_ERROR\n     );\n",
    "diff_parsed": "{'added': [(38, '        bind(socket, raw_addr.as_ptr(), raw_addr_length),'), (51, '        connect(socket, raw_addr.as_ptr(), raw_addr_length),')], 'deleted': [(38, '        bind(socket, raw_addr, raw_addr_length),'), (51, '        connect(socket, raw_addr, raw_addr_length),')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "183"
  },
  {
    "file_change_id": "210998762311033",
    "hash": "75cdea2c14c81678dbecdfba67c8b75c583b1cd4",
    "old_path": "src/sys/windows/udp.rs",
    "new_path": "src/sys/windows/udp.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -12,7 +12,7 @@ pub fn bind(addr: SocketAddr) -> io::Result<net::UdpSocket> {\n     new_ip_socket(addr, SOCK_DGRAM).and_then(|socket| {\n         let (raw_addr, raw_addr_length) = socket_addr(&addr);\n         syscall!(\n-            win_bind(socket, raw_addr, raw_addr_length,),\n+            win_bind(socket, raw_addr.as_ptr(), raw_addr_length,),\n             PartialEq::eq,\n             SOCKET_ERROR\n         )\n",
    "diff_parsed": "{'added': [(15, '            win_bind(socket, raw_addr.as_ptr(), raw_addr_length,),')], 'deleted': [(15, '            win_bind(socket, raw_addr, raw_addr_length,),')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "22"
  },
  {
    "file_change_id": "80398379962987",
    "hash": "a790f9935ab0f74f28d24507c19b7ac0ad0e3b14",
    "old_path": "src/sys/unix/net.rs",
    "new_path": "src/sys/unix/net.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,4 +1,4 @@\n-use std::net::SocketAddr;\n+use std::net::{Ipv4Addr, Ipv6Addr, SocketAddr, SocketAddrV4, SocketAddrV6};\n \n pub(crate) fn new_ip_socket(\n     addr: SocketAddr,\n@@ -64,32 +64,76 @@ pub(crate) fn new_socket(\n     socket\n }\n \n-pub(crate) fn socket_addr(addr: &SocketAddr) -> (*const libc::sockaddr, libc::socklen_t) {\n-    use std::mem::size_of_val;\n+/// A type with the same memory layout as `libc::sockaddr`. Used in converting Rust level\n+/// SocketAddr* types into their system representation. The benefit of this specific\n+/// type over using `libc::sockaddr_storage` is that this type is exactly as large as it\n+/// needs to be and not a lot larger. And it can be initialized cleaner from Rust.\n+#[repr(C)]\n+pub(crate) union SocketAddrCRepr {\n+    v4: libc::sockaddr_in,\n+    v6: libc::sockaddr_in6,\n+}\n+\n+impl SocketAddrCRepr {\n+    pub fn as_ptr(&self) -> *const libc::sockaddr {\n+        self as *const _ as *const libc::sockaddr\n+    }\n+}\n+\n+/// Converts a Rust `SocketAddr` into the system representation.\n+pub(crate) fn socket_addr(addr: &SocketAddr) -> (SocketAddrCRepr, libc::socklen_t) {\n+    use std::mem;\n \n     match addr {\n-        SocketAddr::V4(ref addr) => (\n-            addr as *const _ as *const libc::sockaddr,\n-            size_of_val(addr) as libc::socklen_t,\n-        ),\n-        SocketAddr::V6(ref addr) => (\n-            addr as *const _ as *const libc::sockaddr,\n-            size_of_val(addr) as libc::socklen_t,\n-        ),\n+        SocketAddr::V4(ref a) => {\n+            // `s_addr` is stored as BE on all machine and the array is in BE order.\n+            // So the native endian conversion method is used so that it's never swapped.\n+            let sin_addr = libc::in_addr { s_addr: u32::from_ne_bytes(a.ip().octets()) };\n+\n+            let sockaddr_in = libc::sockaddr_in {\n+                sin_family: libc::AF_INET as libc::sa_family_t,\n+                sin_port: a.port().to_be(),\n+                sin_addr,\n+                ..unsafe { mem::zeroed() }\n+            };\n+\n+            let sockaddr = SocketAddrCRepr { v4: sockaddr_in };\n+            (sockaddr, mem::size_of::<libc::sockaddr_in>() as libc::socklen_t)\n+        }\n+        SocketAddr::V6(ref a) => {\n+            let sockaddr_in6 = libc::sockaddr_in6 {\n+                sin6_family: libc::AF_INET6 as libc::sa_family_t,\n+                sin6_port: a.port().to_be(),\n+                sin6_addr: libc::in6_addr { s6_addr: a.ip().octets() },\n+                sin6_flowinfo: a.flowinfo(),\n+                sin6_scope_id: a.scope_id(),\n+                ..unsafe { mem::zeroed() }\n+            };\n+\n+            let sockaddr = SocketAddrCRepr { v6: sockaddr_in6 };\n+            (sockaddr, mem::size_of::<libc::sockaddr_in6>() as libc::socklen_t)\n+        }\n     }\n }\n \n-/// `storage` must be initialised to `sockaddr_in` or `sockaddr_in6`.\n+/// Converts a `libc::sockaddr` compatible struct into a native Rust `SocketAddr`.\n+/// SAFETY: `storage` must be initialised to `sockaddr_in` or `sockaddr_in6`.\n pub(crate) unsafe fn to_socket_addr(\n     storage: *const libc::sockaddr_storage,\n ) -> std::io::Result<SocketAddr> {\n     match (*storage).ss_family as libc::c_int {\n-        libc::AF_INET => Ok(SocketAddr::V4(\n-            *(storage as *const libc::sockaddr_in as *const _),\n-        )),\n-        libc::AF_INET6 => Ok(SocketAddr::V6(\n-            *(storage as *const libc::sockaddr_in6 as *const _),\n-        )),\n+        libc::AF_INET => {\n+            let addr: &libc::sockaddr_in = &*(storage as *const libc::sockaddr_in);\n+            let ip = Ipv4Addr::from(addr.sin_addr.s_addr.to_ne_bytes());\n+            let port = u16::from_be(addr.sin_port);\n+            Ok(SocketAddr::V4(SocketAddrV4::new(ip, port)))\n+        },\n+        libc::AF_INET6 => {\n+            let addr: &libc::sockaddr_in6 = &*(storage as *const libc::sockaddr_in6);\n+            let ip = Ipv6Addr::from(addr.sin6_addr.s6_addr);\n+            let port = u16::from_be(addr.sin6_port);\n+            Ok(SocketAddr::V6(SocketAddrV6::new(ip, port, addr.sin6_flowinfo, addr.sin6_scope_id)))\n+        },\n         _ => Err(std::io::ErrorKind::InvalidInput.into()),\n     }\n }\n",
    "diff_parsed": "{'added': [(1, 'use std::net::{Ipv4Addr, Ipv6Addr, SocketAddr, SocketAddrV4, SocketAddrV6};'), (71, '#[repr(C)]'), (72, 'pub(crate) union SocketAddrCRepr {'), (73, '    v4: libc::sockaddr_in,'), (74, '    v6: libc::sockaddr_in6,'), (75, '}'), (77, 'impl SocketAddrCRepr {'), (78, '    pub fn as_ptr(&self) -> *const libc::sockaddr {'), (79, '        self as *const _ as *const libc::sockaddr'), (80, '    }'), (81, '}'), (84, 'pub(crate) fn socket_addr(addr: &SocketAddr) -> (SocketAddrCRepr, libc::socklen_t) {'), (85, '    use std::mem;'), (88, '        SocketAddr::V4(ref a) => {'), (91, '            let sin_addr = libc::in_addr { s_addr: u32::from_ne_bytes(a.ip().octets()) };'), (93, '            let sockaddr_in = libc::sockaddr_in {'), (94, '                sin_family: libc::AF_INET as libc::sa_family_t,'), (95, '                sin_port: a.port().to_be(),'), (96, '                sin_addr,'), (97, '                ..unsafe { mem::zeroed() }'), (98, '            };'), (100, '            let sockaddr = SocketAddrCRepr { v4: sockaddr_in };'), (101, '            (sockaddr, mem::size_of::<libc::sockaddr_in>() as libc::socklen_t)'), (102, '        }'), (103, '        SocketAddr::V6(ref a) => {'), (104, '            let sockaddr_in6 = libc::sockaddr_in6 {'), (105, '                sin6_family: libc::AF_INET6 as libc::sa_family_t,'), (106, '                sin6_port: a.port().to_be(),'), (107, '                sin6_addr: libc::in6_addr { s6_addr: a.ip().octets() },'), (108, '                sin6_flowinfo: a.flowinfo(),'), (109, '                sin6_scope_id: a.scope_id(),'), (110, '                ..unsafe { mem::zeroed() }'), (111, '            };'), (113, '            let sockaddr = SocketAddrCRepr { v6: sockaddr_in6 };'), (114, '            (sockaddr, mem::size_of::<libc::sockaddr_in6>() as libc::socklen_t)'), (115, '        }'), (125, '        libc::AF_INET => {'), (126, '            let addr: &libc::sockaddr_in = &*(storage as *const libc::sockaddr_in);'), (127, '            let ip = Ipv4Addr::from(addr.sin_addr.s_addr.to_ne_bytes());'), (128, '            let port = u16::from_be(addr.sin_port);'), (129, '            Ok(SocketAddr::V4(SocketAddrV4::new(ip, port)))'), (130, '        },'), (131, '        libc::AF_INET6 => {'), (132, '            let addr: &libc::sockaddr_in6 = &*(storage as *const libc::sockaddr_in6);'), (133, '            let ip = Ipv6Addr::from(addr.sin6_addr.s6_addr);'), (134, '            let port = u16::from_be(addr.sin6_port);'), (135, '            Ok(SocketAddr::V6(SocketAddrV6::new(ip, port, addr.sin6_flowinfo, addr.sin6_scope_id)))'), (136, '        },')], 'deleted': [(1, 'use std::net::SocketAddr;'), (67, 'pub(crate) fn socket_addr(addr: &SocketAddr) -> (*const libc::sockaddr, libc::socklen_t) {'), (68, '    use std::mem::size_of_val;'), (71, '        SocketAddr::V4(ref addr) => ('), (72, '            addr as *const _ as *const libc::sockaddr,'), (73, '            size_of_val(addr) as libc::socklen_t,'), (74, '        ),'), (75, '        SocketAddr::V6(ref addr) => ('), (76, '            addr as *const _ as *const libc::sockaddr,'), (77, '            size_of_val(addr) as libc::socklen_t,'), (78, '        ),'), (87, '        libc::AF_INET => Ok(SocketAddr::V4('), (88, '            *(storage as *const libc::sockaddr_in as *const _),'), (89, '        )),'), (90, '        libc::AF_INET6 => Ok(SocketAddr::V6('), (91, '            *(storage as *const libc::sockaddr_in6 as *const _),'), (92, '        )),')]}",
    "num_lines_added": "48",
    "num_lines_deleted": "17",
    "nloc": "106"
  },
  {
    "file_change_id": "153040059478716",
    "hash": "a790f9935ab0f74f28d24507c19b7ac0ad0e3b14",
    "old_path": "src/sys/unix/tcp.rs",
    "new_path": "src/sys/unix/tcp.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -20,14 +20,14 @@ pub(crate) fn new_v6_socket() -> io::Result<TcpSocket> {\n \n pub(crate) fn bind(socket: TcpSocket, addr: SocketAddr) -> io::Result<()> {\n     let (raw_addr, raw_addr_length) = socket_addr(&addr);\n-    syscall!(bind(socket, raw_addr, raw_addr_length))?;\n+    syscall!(bind(socket, raw_addr.as_ptr(), raw_addr_length))?;\n     Ok(())\n }\n \n pub(crate) fn connect(socket: TcpSocket, addr: SocketAddr) -> io::Result<net::TcpStream> {\n     let (raw_addr, raw_addr_length) = socket_addr(&addr);\n \n-    match syscall!(connect(socket, raw_addr, raw_addr_length)) {\n+    match syscall!(connect(socket, raw_addr.as_ptr(), raw_addr_length)) {\n         Err(err) if err.raw_os_error() != Some(libc::EINPROGRESS) => {\n             Err(err)\n         }\n",
    "diff_parsed": "{'added': [(23, '    syscall!(bind(socket, raw_addr.as_ptr(), raw_addr_length))?;'), (30, '    match syscall!(connect(socket, raw_addr.as_ptr(), raw_addr_length)) {')], 'deleted': [(23, '    syscall!(bind(socket, raw_addr, raw_addr_length))?;'), (30, '    match syscall!(connect(socket, raw_addr, raw_addr_length)) {')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "187"
  },
  {
    "file_change_id": "115126804479032",
    "hash": "a790f9935ab0f74f28d24507c19b7ac0ad0e3b14",
    "old_path": "src/sys/unix/udp.rs",
    "new_path": "src/sys/unix/udp.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -11,7 +11,7 @@ pub fn bind(addr: SocketAddr) -> io::Result<net::UdpSocket> {\n \n     socket.and_then(|socket| {\n         let (raw_addr, raw_addr_length) = socket_addr(&addr);\n-        syscall!(bind(socket, raw_addr, raw_addr_length))\n+        syscall!(bind(socket, raw_addr.as_ptr(), raw_addr_length))\n             .map_err(|err| {\n                 // Close the socket if we hit an error, ignoring the error\n                 // from closing since we can't pass back two errors.\n",
    "diff_parsed": "{'added': [(14, '        syscall!(bind(socket, raw_addr.as_ptr(), raw_addr_length))')], 'deleted': [(14, '        syscall!(bind(socket, raw_addr, raw_addr_length))')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "17"
  },
  {
    "file_change_id": "275842685932283",
    "hash": "f1320f02cb404ec6e8ad5ef638260dcacc9c8b9",
    "old_path": "matrix/src/lib.rs",
    "new_path": "matrix/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -8,7 +8,10 @@ extern crate basic_dsp_vector;\n \n use basic_dsp_vector::numbers::*;\n use basic_dsp_vector::*;\n-use std::{mem, ptr};\n+use std::{\n+    mem::ManuallyDrop,\n+    ptr\n+};\n \n mod mat_impl;\n pub use self::mat_impl::*;\n@@ -230,13 +233,12 @@ impl<S, D> TransformContent<S, D> for [S; 2] {\n     where\n         F: FnMut(S) -> D,\n     {\n+        let self_forget = ManuallyDrop::new(self);\n         unsafe {\n-            let result = [\n-                conversion(ptr::read(&self[0])),\n-                conversion(ptr::read(&self[1])),\n-            ];\n-            mem::forget(self);\n-            result\n+            [\n+                conversion(ptr::read(&self_forget[0])),\n+                conversion(ptr::read(&self_forget[1])),\n+            ]\n         }\n     }\n \n@@ -244,11 +246,11 @@ impl<S, D> TransformContent<S, D> for [S; 2] {\n     where\n         F: FnMut(S) -> TransRes<D>,\n     {\n+        let self_forget = ManuallyDrop::new(self);\n         unsafe {\n             let mut error = None;\n-            let first = try_conv!(conversion(ptr::read(&self[0])), error);\n-            let second = try_conv!(conversion(ptr::read(&self[1])), error);\n-            mem::forget(self);\n+            let first = try_conv!(conversion(ptr::read(&self_forget[0])), error);\n+            let second = try_conv!(conversion(ptr::read(&self_forget[1])), error);\n \n             match error {\n                 None => Ok([first, second]),\n@@ -265,14 +267,14 @@ impl<S, D> TransformContent<S, D> for [S; 3] {\n     where\n         F: FnMut(S) -> D,\n     {\n+        let self_forget = ManuallyDrop::new(self);\n+        \n         unsafe {\n-            let result = [\n-                conversion(ptr::read(&self[0])),\n-                conversion(ptr::read(&self[1])),\n-                conversion(ptr::read(&self[2])),\n-            ];\n-            mem::forget(self);\n-            result\n+            [\n+                conversion(ptr::read(&self_forget[0])),\n+                conversion(ptr::read(&self_forget[1])),\n+                conversion(ptr::read(&self_forget[2])),\n+            ]\n         }\n     }\n \n@@ -280,12 +282,13 @@ impl<S, D> TransformContent<S, D> for [S; 3] {\n     where\n         F: FnMut(S) -> TransRes<D>,\n     {\n+        let self_forget = ManuallyDrop::new(self);\n+\n         unsafe {\n             let mut error = None;\n-            let first = try_conv!(conversion(ptr::read(&self[0])), error);\n-            let second = try_conv!(conversion(ptr::read(&self[1])), error);\n-            let third = try_conv!(conversion(ptr::read(&self[2])), error);\n-            mem::forget(self);\n+            let first = try_conv!(conversion(ptr::read(&self_forget[0])), error);\n+            let second = try_conv!(conversion(ptr::read(&self_forget[1])), error);\n+            let third = try_conv!(conversion(ptr::read(&self_forget[2])), error);\n \n             match error {\n                 None => Ok([first, second, third]),\n@@ -302,15 +305,15 @@ impl<S, D> TransformContent<S, D> for [S; 4] {\n     where\n         F: FnMut(S) -> D,\n     {\n+        let self_forget = ManuallyDrop::new(self);\n+\n         unsafe {\n-            let result = [\n-                conversion(ptr::read(&self[0])),\n-                conversion(ptr::read(&self[1])),\n-                conversion(ptr::read(&self[2])),\n-                conversion(ptr::read(&self[3])),\n-            ];\n-            mem::forget(self);\n-            result\n+            [\n+                conversion(ptr::read(&self_forget[0])),\n+                conversion(ptr::read(&self_forget[1])),\n+                conversion(ptr::read(&self_forget[2])),\n+                conversion(ptr::read(&self_forget[3])),\n+            ]\n         }\n     }\n \n@@ -318,13 +321,14 @@ impl<S, D> TransformContent<S, D> for [S; 4] {\n     where\n         F: FnMut(S) -> TransRes<D>,\n     {\n+        let self_forget = ManuallyDrop::new(self);\n+\n         unsafe {\n             let mut error = None;\n-            let first = try_conv!(conversion(ptr::read(&self[0])), error);\n-            let second = try_conv!(conversion(ptr::read(&self[1])), error);\n-            let third = try_conv!(conversion(ptr::read(&self[2])), error);\n-            let fourth = try_conv!(conversion(ptr::read(&self[3])), error);\n-            mem::forget(self);\n+            let first = try_conv!(conversion(ptr::read(&self_forget[0])), error);\n+            let second = try_conv!(conversion(ptr::read(&self_forget[1])), error);\n+            let third = try_conv!(conversion(ptr::read(&self_forget[2])), error);\n+            let fourth = try_conv!(conversion(ptr::read(&self_forget[3])), error);\n \n             match error {\n                 None => Ok([first, second, third, fourth]),\n",
    "diff_parsed": "{'added': [(11, 'use std::{'), (12, '    mem::ManuallyDrop,'), (13, '    ptr'), (14, '};'), (236, '        let self_forget = ManuallyDrop::new(self);'), (238, '            ['), (239, '                conversion(ptr::read(&self_forget[0])),'), (240, '                conversion(ptr::read(&self_forget[1])),'), (241, '            ]'), (249, '        let self_forget = ManuallyDrop::new(self);'), (252, '            let first = try_conv!(conversion(ptr::read(&self_forget[0])), error);'), (253, '            let second = try_conv!(conversion(ptr::read(&self_forget[1])), error);'), (270, '        let self_forget = ManuallyDrop::new(self);'), (273, '            ['), (274, '                conversion(ptr::read(&self_forget[0])),'), (275, '                conversion(ptr::read(&self_forget[1])),'), (276, '                conversion(ptr::read(&self_forget[2])),'), (277, '            ]'), (285, '        let self_forget = ManuallyDrop::new(self);'), (289, '            let first = try_conv!(conversion(ptr::read(&self_forget[0])), error);'), (290, '            let second = try_conv!(conversion(ptr::read(&self_forget[1])), error);'), (291, '            let third = try_conv!(conversion(ptr::read(&self_forget[2])), error);'), (308, '        let self_forget = ManuallyDrop::new(self);'), (311, '            ['), (312, '                conversion(ptr::read(&self_forget[0])),'), (313, '                conversion(ptr::read(&self_forget[1])),'), (314, '                conversion(ptr::read(&self_forget[2])),'), (315, '                conversion(ptr::read(&self_forget[3])),'), (316, '            ]'), (324, '        let self_forget = ManuallyDrop::new(self);'), (328, '            let first = try_conv!(conversion(ptr::read(&self_forget[0])), error);'), (329, '            let second = try_conv!(conversion(ptr::read(&self_forget[1])), error);'), (330, '            let third = try_conv!(conversion(ptr::read(&self_forget[2])), error);'), (331, '            let fourth = try_conv!(conversion(ptr::read(&self_forget[3])), error);')], 'deleted': [(11, 'use std::{mem, ptr};'), (234, '            let result = ['), (235, '                conversion(ptr::read(&self[0])),'), (236, '                conversion(ptr::read(&self[1])),'), (237, '            ];'), (238, '            mem::forget(self);'), (239, '            result'), (249, '            let first = try_conv!(conversion(ptr::read(&self[0])), error);'), (250, '            let second = try_conv!(conversion(ptr::read(&self[1])), error);'), (251, '            mem::forget(self);'), (269, '            let result = ['), (270, '                conversion(ptr::read(&self[0])),'), (271, '                conversion(ptr::read(&self[1])),'), (272, '                conversion(ptr::read(&self[2])),'), (273, '            ];'), (274, '            mem::forget(self);'), (275, '            result'), (285, '            let first = try_conv!(conversion(ptr::read(&self[0])), error);'), (286, '            let second = try_conv!(conversion(ptr::read(&self[1])), error);'), (287, '            let third = try_conv!(conversion(ptr::read(&self[2])), error);'), (288, '            mem::forget(self);'), (306, '            let result = ['), (307, '                conversion(ptr::read(&self[0])),'), (308, '                conversion(ptr::read(&self[1])),'), (309, '                conversion(ptr::read(&self[2])),'), (310, '                conversion(ptr::read(&self[3])),'), (311, '            ];'), (312, '            mem::forget(self);'), (313, '            result'), (323, '            let first = try_conv!(conversion(ptr::read(&self[0])), error);'), (324, '            let second = try_conv!(conversion(ptr::read(&self[1])), error);'), (325, '            let third = try_conv!(conversion(ptr::read(&self[2])), error);'), (326, '            let fourth = try_conv!(conversion(ptr::read(&self[3])), error);'), (327, '            mem::forget(self);')]}",
    "num_lines_added": "34",
    "num_lines_deleted": "34",
    "nloc": "278"
  },
  {
    "file_change_id": "12846335739145",
    "hash": "b3a53796b7335d22b9c3d6810dda3fc9acf15df",
    "old_path": "src/header/map.rs",
    "new_path": "src/header/map.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -638,6 +638,8 @@ impl<T> HeaderMap<T> {\n \n         if cap > self.indices.len() {\n             let cap = cap.next_power_of_two();\n+            assert!(cap < MAX_SIZE, \"header map reserve over max capacity\");\n+            assert!(cap != 0, \"header map reserve overflowed\");\n \n             if self.entries.len() == 0 {\n                 self.mask = cap - 1;\n",
    "diff_parsed": "{'added': [(641, '            assert!(cap < MAX_SIZE, \"header map reserve over max capacity\");'), (642, '            assert!(cap != 0, \"header map reserve overflowed\");')], 'deleted': []}",
    "num_lines_added": "2",
    "num_lines_deleted": "0",
    "nloc": "2217"
  },
  {
    "file_change_id": "42263119494649",
    "hash": "b3a53796b7335d22b9c3d6810dda3fc9acf15df",
    "old_path": "tests/header_map.rs",
    "new_path": "tests/header_map.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -37,6 +37,22 @@ fn smoke() {\n     }\n }\n \n+#[test]\n+#[should_panic]\n+fn reserve_over_capacity() {\n+    // See https://github.com/hyperium/http/issues/352\n+    let mut headers = HeaderMap::<u32>::with_capacity(32);\n+    headers.reserve(50_000); // over MAX_SIZE\n+}\n+\n+#[test]\n+#[should_panic]\n+fn reserve_overflow() {\n+    // See https://github.com/hyperium/http/issues/352\n+    let mut headers = HeaderMap::<u32>::with_capacity(0);\n+    headers.reserve(std::usize::MAX); // next_power_of_two overflows\n+}\n+\n #[test]\n fn drain() {\n     let mut headers = HeaderMap::new();\n",
    "diff_parsed": "{'added': [(40, '#[test]'), (41, '#[should_panic]'), (42, 'fn reserve_over_capacity() {'), (44, '    let mut headers = HeaderMap::<u32>::with_capacity(32);'), (45, '    headers.reserve(50_000); // over MAX_SIZE'), (46, '}'), (48, '#[test]'), (49, '#[should_panic]'), (50, 'fn reserve_overflow() {'), (52, '    let mut headers = HeaderMap::<u32>::with_capacity(0);'), (53, '    headers.reserve(std::usize::MAX); // next_power_of_two overflows'), (54, '}')], 'deleted': []}",
    "num_lines_added": "12",
    "num_lines_deleted": "0",
    "nloc": "298"
  },
  {
    "file_change_id": "191195974403583",
    "hash": "a064d69ba4a62d455cab67693cd61e6509db5a1",
    "old_path": "src/ms_queue.rs",
    "new_path": "src/ms_queue.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,6 +1,7 @@\n-use std::sync::atomic::Ordering::{Acquire, Relaxed, Release};\n+use std::mem::{self, ManuallyDrop};\n+use std::ptr;\n use std::sync::atomic::AtomicBool;\n-use std::{mem, ptr};\n+use std::sync::atomic::Ordering::{Acquire, Relaxed, Release};\n use std::thread::{self, Thread};\n \n use epoch::{self, Atomic, Owned, Shared};\n@@ -28,7 +29,7 @@ struct Node<T> {\n #[derive(Debug)]\n enum Payload<T> {\n     /// A node with actual data that can be popped.\n-    Data(T),\n+    Data(ManuallyDrop<T>),\n     /// A node representing a blocked request for data.\n     Blocked(*mut Signal<T>),\n }\n@@ -122,7 +123,7 @@ impl<T> MsQueue<T> {\n             fn into_node(self) -> Owned<Node<T>> {\n                 match self {\n                     Cache::Data(t) => Owned::new(Node {\n-                        payload: Payload::Data(t),\n+                        payload: Payload::Data(ManuallyDrop::new(t)),\n                         next: Atomic::null(),\n                     }),\n                     Cache::Node(n) => n,\n@@ -134,7 +135,7 @@ impl<T> MsQueue<T> {\n                 match self {\n                     Cache::Data(t) => t,\n                     Cache::Node(node) => match (*node.into_box()).payload {\n-                        Payload::Data(t) => t,\n+                        Payload::Data(t) => ManuallyDrop::into_inner(t),\n                         _ => unreachable!(),\n                     },\n                 }\n@@ -195,9 +196,9 @@ impl<T> MsQueue<T> {\n         }\n     }\n \n-    #[inline(always)]\n     // Attempt to pop a data node. `Ok(None)` if queue is empty or in blocking\n     // mode; `Err(())` if lost race to pop.\n+    #[inline(always)]\n     fn pop_internal(&self, guard: &epoch::Guard) -> Result<Option<T>, ()> {\n         let head_shared = self.head.load(Acquire, guard);\n         let head = unsafe { head_shared.as_ref() }.unwrap();\n@@ -210,7 +211,7 @@ impl<T> MsQueue<T> {\n                         .is_ok()\n                     {\n                         guard.defer(move || head_shared.into_owned());\n-                        Ok(Some(ptr::read(t)))\n+                        Ok(Some(ManuallyDrop::into_inner(ptr::read(t))))\n                     } else {\n                         Err(())\n                     }\n",
    "diff_parsed": "{'added': [(1, 'use std::mem::{self, ManuallyDrop};'), (2, 'use std::ptr;'), (4, 'use std::sync::atomic::Ordering::{Acquire, Relaxed, Release};'), (32, '    Data(ManuallyDrop<T>),'), (126, '                        payload: Payload::Data(ManuallyDrop::new(t)),'), (138, '                        Payload::Data(t) => ManuallyDrop::into_inner(t),'), (201, '    #[inline(always)]'), (214, '                        Ok(Some(ManuallyDrop::into_inner(ptr::read(t))))')], 'deleted': [(1, 'use std::sync::atomic::Ordering::{Acquire, Relaxed, Release};'), (3, 'use std::{mem, ptr};'), (31, '    Data(T),'), (125, '                        payload: Payload::Data(t),'), (137, '                        Payload::Data(t) => t,'), (198, '    #[inline(always)]'), (213, '                        Ok(Some(ptr::read(t)))')]}",
    "num_lines_added": "8",
    "num_lines_deleted": "7",
    "nloc": "430"
  },
  {
    "file_change_id": "161210909722884",
    "hash": "a064d69ba4a62d455cab67693cd61e6509db5a1",
    "old_path": "src/seg_queue.rs",
    "new_path": "src/seg_queue.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,9 +1,10 @@\n+use std::cell::UnsafeCell;\n+use std::cmp;\n+use std::fmt;\n+use std::mem::{self, ManuallyDrop};\n+use std::ptr;\n use std::sync::atomic::Ordering::{Acquire, Relaxed, Release};\n use std::sync::atomic::{AtomicBool, AtomicUsize};\n-use std::fmt;\n-use std::{mem, ptr};\n-use std::cmp;\n-use std::cell::UnsafeCell;\n \n use epoch::{self, Atomic, Owned};\n \n@@ -21,7 +22,7 @@ pub struct SegQueue<T> {\n \n struct Segment<T> {\n     low: AtomicUsize,\n-    data: [UnsafeCell<(T, AtomicBool)>; SEG_SIZE],\n+    data: ManuallyDrop<[UnsafeCell<(T, AtomicBool)>; SEG_SIZE]>,\n     high: AtomicUsize,\n     next: Atomic<Segment<T>>,\n }\n@@ -37,7 +38,7 @@ unsafe impl<T: Send> Sync for Segment<T> {}\n impl<T> Segment<T> {\n     fn new() -> Segment<T> {\n         let rqueue = Segment {\n-            data: unsafe { mem::uninitialized() },\n+            data: unsafe { ManuallyDrop::new(mem::uninitialized()) },\n             low: AtomicUsize::new(0),\n             high: AtomicUsize::new(0),\n             next: Atomic::null(),\n",
    "diff_parsed": "{'added': [(1, 'use std::cell::UnsafeCell;'), (2, 'use std::cmp;'), (3, 'use std::fmt;'), (4, 'use std::mem::{self, ManuallyDrop};'), (5, 'use std::ptr;'), (25, '    data: ManuallyDrop<[UnsafeCell<(T, AtomicBool)>; SEG_SIZE]>,'), (41, '            data: unsafe { ManuallyDrop::new(mem::uninitialized()) },')], 'deleted': [(3, 'use std::fmt;'), (4, 'use std::{mem, ptr};'), (5, 'use std::cmp;'), (6, 'use std::cell::UnsafeCell;'), (24, '    data: [UnsafeCell<(T, AtomicBool)>; SEG_SIZE],'), (40, '            data: unsafe { mem::uninitialized() },')]}",
    "num_lines_added": "7",
    "num_lines_deleted": "6",
    "nloc": "265"
  },
  {
    "file_change_id": "33096066959590",
    "hash": "4496dd9c1cf543536c024c6d47f0b62613c75f5",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -33,125 +33,49 @@\n #![warn(missing_docs, missing_debug_implementations, rust_2018_idioms)]\n \n use std::io;\n-use std::mem::{self, MaybeUninit};\n use std::net::{SocketAddr, TcpStream};\n-use std::ptr;\n \n-#[cfg(unix)]\n-use {\n-    libc::{sockaddr, sockaddr_storage, socklen_t},\n-    std::os::unix::net::UnixStream,\n-    std::os::unix::prelude::{FromRawFd, RawFd},\n-    std::path::Path,\n-};\n-\n-#[cfg(windows)]\n-use {\n-    std::os::windows::io::FromRawSocket,\n-    winapi::shared::ws2def::{SOCKADDR as sockaddr, SOCKADDR_STORAGE as sockaddr_storage},\n-    winapi::um::ws2tcpip::socklen_t,\n-};\n-\n-/// A raw socket address.\n-struct Addr {\n-    storage: sockaddr_storage,\n-    len: socklen_t,\n-}\n-\n-impl Addr {\n-    /// Creates a raw socket address from `SocketAddr`.\n-    fn new(addr: SocketAddr) -> Self {\n-        let (addr, len): (*const sockaddr, socklen_t) = match &addr {\n-            SocketAddr::V4(addr) => (addr as *const _ as *const _, mem::size_of_val(addr) as _),\n-            SocketAddr::V6(addr) => (addr as *const _ as *const _, mem::size_of_val(addr) as _),\n-        };\n-        unsafe { Self::from_raw_parts(addr, len) }\n-    }\n-\n-    /// Creates an `Addr` from its raw parts.\n-    unsafe fn from_raw_parts(addr: *const sockaddr, len: socklen_t) -> Self {\n-        let mut storage = MaybeUninit::<sockaddr_storage>::uninit();\n-        ptr::copy_nonoverlapping(\n-            addr as *const _ as *const u8,\n-            &mut storage as *mut _ as *mut u8,\n-            len as usize,\n-        );\n-        Self {\n-            storage: storage.assume_init(),\n-            len,\n-        }\n-    }\n-}\n+use socket2::{Domain, Protocol, SockAddr, Socket, Type};\n \n #[cfg(unix)]\n-fn connect(addr: Addr, family: libc::c_int, protocol: libc::c_int) -> io::Result<RawFd> {\n-    /// Calls a libc function and results in `io::Result`.\n-    macro_rules! syscall {\n-        ($fn:ident $args:tt) => {{\n-            let res = unsafe { libc::$fn $args };\n-            if res == -1 {\n-                Err(std::io::Error::last_os_error())\n-            } else {\n-                Ok(res)\n-            }\n-        }};\n-    }\n-\n-    // A guard that closes the file descriptor if an error occurs before the end.\n-    let mut guard;\n-\n-    // On linux, we pass the `SOCK_CLOEXEC` flag to atomically create the socket and set it as\n-    // CLOEXEC.\n-    #[cfg(target_os = \"linux\")]\n-    let fd = {\n-        let fd = syscall!(socket(\n-            family,\n-            libc::SOCK_STREAM | libc::SOCK_CLOEXEC,\n-            protocol,\n-        ))?;\n-        guard = CallOnDrop(Some(move || drop(syscall!(close(fd)))));\n-        fd\n-    };\n-\n-    // On other systems, we first create the socket and then set it as CLOEXEC.\n-    #[cfg(not(target_os = \"linux\"))]\n-    let fd = {\n-        let fd = syscall!(socket(family, libc::SOCK_STREAM, protocol))?;\n-        guard = CallOnDrop(Some(move || drop(syscall!(close(fd)))));\n-\n-        let flags = syscall!(fcntl(fd, libc::F_GETFD))? | libc::FD_CLOEXEC;\n-        syscall!(fcntl(fd, libc::F_SETFD, flags))?;\n-\n-        #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-        {\n-            let payload = &1i32 as *const i32 as *const libc::c_void;\n-            syscall!(setsockopt(\n-                fd,\n-                libc::SOL_SOCKET,\n-                libc::SO_NOSIGPIPE,\n-                payload,\n-                std::mem::size_of::<i32>() as libc::socklen_t,\n-            ))?;\n-        }\n-        fd\n-    };\n-\n-    // Put socket into non-blocking mode.\n-    let flags = syscall!(fcntl(fd, libc::F_GETFL))? | libc::O_NONBLOCK;\n-    syscall!(fcntl(fd, libc::F_SETFL, flags))?;\n-\n-    // Start connecting.\n-    match syscall!(connect(fd, &addr.storage as *const _ as *const _, addr.len)) {\n+use std::{os::unix::net::UnixStream, path::Path};\n+\n+fn connect(addr: SockAddr, domain: Domain, protocol: Option<Protocol>) -> io::Result<Socket> {\n+    let sock_type = Type::STREAM;\n+    #[cfg(any(\n+        target_os = \"android\",\n+        target_os = \"dragonfly\",\n+        target_os = \"freebsd\",\n+        target_os = \"fuchsia\",\n+        target_os = \"illumos\",\n+        target_os = \"linux\",\n+        target_os = \"netbsd\",\n+        target_os = \"openbsd\"\n+    ))]\n+    // If we can, set nonblocking at socket creation for unix\n+    let sock_type = sock_type.nonblocking();\n+    // This automatically handles cloexec on unix, no_inherit on windows and nosigpipe on macos\n+    let socket = Socket::new(domain, sock_type, protocol)?;\n+    #[cfg(not(any(\n+        target_os = \"android\",\n+        target_os = \"dragonfly\",\n+        target_os = \"freebsd\",\n+        target_os = \"fuchsia\",\n+        target_os = \"illumos\",\n+        target_os = \"linux\",\n+        target_os = \"netbsd\",\n+        target_os = \"openbsd\"\n+    )))]\n+    // If the current platform doesn't support nonblocking at creation, enable it after creation\n+    socket.set_nonblocking(true)?;\n+    match socket.connect(&addr) {\n         Ok(_) => {}\n+        #[cfg(unix)]\n         Err(err) if err.raw_os_error() == Some(libc::EINPROGRESS) => {}\n         Err(err) if err.kind() == io::ErrorKind::WouldBlock => {}\n         Err(err) => return Err(err),\n     }\n-\n-    // Disarm the guard so that it doesn't close the file descriptor.\n-    guard.0.take();\n-\n-    Ok(fd)\n+    Ok(socket)\n }\n \n /// Creates a pending Unix connection to the specified path.\n@@ -184,52 +108,8 @@ fn connect(addr: Addr, family: libc::c_int, protocol: libc::c_int) -> io::Result\n /// ```\n #[cfg(unix)]\n pub fn unix<P: AsRef<Path>>(path: P) -> io::Result<UnixStream> {\n-    use std::cmp::Ordering;\n-    use std::os::unix::ffi::OsStrExt;\n-\n-    let addr = unsafe {\n-        let mut addr = mem::zeroed::<libc::sockaddr_un>();\n-        addr.sun_family = libc::AF_UNIX as libc::sa_family_t;\n-\n-        let bytes = path.as_ref().as_os_str().as_bytes();\n-\n-        match (bytes.get(0), bytes.len().cmp(&addr.sun_path.len())) {\n-            // Abstract paths don't need a null terminator\n-            (Some(&0), Ordering::Greater) => {\n-                return Err(io::Error::new(\n-                    io::ErrorKind::InvalidInput,\n-                    \"path must be no longer than SUN_LEN\",\n-                ));\n-            }\n-            (Some(&0), _) => {}\n-            (_, Ordering::Greater) | (_, Ordering::Equal) => {\n-                return Err(io::Error::new(\n-                    io::ErrorKind::InvalidInput,\n-                    \"path must be shorter than SUN_LEN\",\n-                ));\n-            }\n-            _ => {}\n-        }\n-\n-        for (dst, src) in addr.sun_path.iter_mut().zip(bytes) {\n-            *dst = *src as libc::c_char;\n-        }\n-        // null byte for pathname is already there since we zeroed up front\n-\n-        let base = &addr as *const _ as usize;\n-        let path = &addr.sun_path as *const _ as usize;\n-        let sun_path_offset = path - base;\n-\n-        let mut len = sun_path_offset + bytes.len();\n-        match bytes.get(0) {\n-            Some(&0) | None => {}\n-            Some(_) => len += 1,\n-        }\n-        Addr::from_raw_parts(&addr as *const _ as *const _, len as libc::socklen_t)\n-    };\n-\n-    let fd = connect(addr, libc::AF_UNIX, 0)?;\n-    unsafe { Ok(UnixStream::from_raw_fd(fd)) }\n+    let socket = connect(SockAddr::unix(path)?, Domain::UNIX, None)?;\n+    Ok(socket.into())\n }\n \n /// Creates a pending TCP connection to the specified address.\n@@ -263,99 +143,8 @@ pub fn unix<P: AsRef<Path>>(path: P) -> io::Result<UnixStream> {\n /// # std::io::Result::Ok(())\n /// ```\n pub fn tcp<A: Into<SocketAddr>>(addr: A) -> io::Result<TcpStream> {\n-    tcp_connect(addr.into())\n-}\n-\n-#[cfg(unix)]\n-fn tcp_connect(addr: SocketAddr) -> io::Result<TcpStream> {\n     let addr = addr.into();\n-    let fd = connect(\n-        Addr::new(addr),\n-        if addr.is_ipv6() {\n-            libc::AF_INET6\n-        } else {\n-            libc::AF_INET\n-        },\n-        libc::IPPROTO_TCP,\n-    )?;\n-    unsafe { Ok(TcpStream::from_raw_fd(fd)) }\n-}\n-\n-#[cfg(windows)]\n-fn tcp_connect(addr: SocketAddr) -> io::Result<TcpStream> {\n-    use std::net::UdpSocket;\n-    use std::sync::Once;\n-\n-    use winapi::ctypes::{c_int, c_ulong};\n-    use winapi::shared::minwindef::DWORD;\n-    use winapi::shared::ntdef::HANDLE;\n-    use winapi::shared::ws2def::{AF_INET, AF_INET6, IPPROTO_TCP, SOCK_STREAM};\n-    use winapi::um::handleapi::SetHandleInformation;\n-    use winapi::um::winsock2 as sock;\n-\n-    static INIT: Once = Once::new();\n-    INIT.call_once(|| {\n-        // Initialize winsock through the standard library by just creating a dummy socket.\n-        // Whether this is successful or not we drop the result as libstd will be sure to have\n-        // initialized winsock.\n-        let _ = UdpSocket::bind(\"127.0.0.1:34254\");\n-    });\n-\n-    const HANDLE_FLAG_INHERIT: DWORD = 0x00000001;\n-    const WSA_FLAG_OVERLAPPED: DWORD = 0x01;\n-\n-    let family = if addr.is_ipv6() { AF_INET6 } else { AF_INET };\n-    let addr = Addr::new(addr);\n-\n-    unsafe {\n-        let socket = match sock::WSASocketW(\n-            family,\n-            SOCK_STREAM,\n-            IPPROTO_TCP as _,\n-            ptr::null_mut(),\n-            0,\n-            WSA_FLAG_OVERLAPPED,\n-        ) {\n-            sock::INVALID_SOCKET => {\n-                return Err(io::Error::from_raw_os_error(sock::WSAGetLastError()))\n-            }\n-            socket => socket,\n-        };\n-\n-        // Create a TCP stream now so that it closes the socket if an error occurs before the end.\n-        let stream = TcpStream::from_raw_socket(socket as _);\n-\n-        // Set no inherit.\n-        if SetHandleInformation(socket as HANDLE, HANDLE_FLAG_INHERIT, 0) == 0 {\n-            return Err(io::Error::last_os_error());\n-        }\n-\n-        // Put socket into nonblocking mode.\n-        let mut nonblocking = true as c_ulong;\n-        if sock::ioctlsocket(socket, sock::FIONBIO as c_int, &mut nonblocking) != 0 {\n-            return Err(io::Error::last_os_error());\n-        }\n-\n-        // Start connecting.\n-        match sock::connect(socket, &addr.storage as *const _ as *const _, addr.len) {\n-            0 => {}\n-            _ => match io::Error::from_raw_os_error(sock::WSAGetLastError()) {\n-                err if err.kind() == io::ErrorKind::WouldBlock => {}\n-                err => return Err(err),\n-            },\n-        }\n-\n-        Ok(stream)\n-    }\n-}\n-\n-/// Runs a closure when dropped.\n-struct CallOnDrop<F: FnOnce()>(Option<F>);\n-\n-impl<F: FnOnce()> Drop for CallOnDrop<F> {\n-    fn drop(&mut self) {\n-        if let Some(f) = self.0.take() {\n-            f();\n-        }\n-    }\n+    let domain = Domain::for_address(addr);\n+    let socket = connect(addr.into(), domain, Some(Protocol::TCP))?;\n+    Ok(socket.into())\n }\n",
    "diff_parsed": "{'added': [(38, 'use socket2::{Domain, Protocol, SockAddr, Socket, Type};'), (41, 'use std::{os::unix::net::UnixStream, path::Path};'), (43, 'fn connect(addr: SockAddr, domain: Domain, protocol: Option<Protocol>) -> io::Result<Socket> {'), (44, '    let sock_type = Type::STREAM;'), (45, '    #[cfg(any('), (46, '        target_os = \"android\",'), (47, '        target_os = \"dragonfly\",'), (48, '        target_os = \"freebsd\",'), (49, '        target_os = \"fuchsia\",'), (50, '        target_os = \"illumos\",'), (51, '        target_os = \"linux\",'), (52, '        target_os = \"netbsd\",'), (53, '        target_os = \"openbsd\"'), (54, '    ))]'), (56, '    let sock_type = sock_type.nonblocking();'), (58, '    let socket = Socket::new(domain, sock_type, protocol)?;'), (59, '    #[cfg(not(any('), (60, '        target_os = \"android\",'), (61, '        target_os = \"dragonfly\",'), (62, '        target_os = \"freebsd\",'), (63, '        target_os = \"fuchsia\",'), (64, '        target_os = \"illumos\",'), (65, '        target_os = \"linux\",'), (66, '        target_os = \"netbsd\",'), (67, '        target_os = \"openbsd\"'), (68, '    )))]'), (70, '    socket.set_nonblocking(true)?;'), (71, '    match socket.connect(&addr) {'), (73, '        #[cfg(unix)]'), (78, '    Ok(socket)'), (111, '    let socket = connect(SockAddr::unix(path)?, Domain::UNIX, None)?;'), (112, '    Ok(socket.into())'), (147, '    let domain = Domain::for_address(addr);'), (148, '    let socket = connect(addr.into(), domain, Some(Protocol::TCP))?;'), (149, '    Ok(socket.into())')], 'deleted': [(36, 'use std::mem::{self, MaybeUninit};'), (38, 'use std::ptr;'), (40, '#[cfg(unix)]'), (41, 'use {'), (42, '    libc::{sockaddr, sockaddr_storage, socklen_t},'), (43, '    std::os::unix::net::UnixStream,'), (44, '    std::os::unix::prelude::{FromRawFd, RawFd},'), (45, '    std::path::Path,'), (46, '};'), (48, '#[cfg(windows)]'), (49, 'use {'), (50, '    std::os::windows::io::FromRawSocket,'), (51, '    winapi::shared::ws2def::{SOCKADDR as sockaddr, SOCKADDR_STORAGE as sockaddr_storage},'), (52, '    winapi::um::ws2tcpip::socklen_t,'), (53, '};'), (56, 'struct Addr {'), (57, '    storage: sockaddr_storage,'), (58, '    len: socklen_t,'), (59, '}'), (61, 'impl Addr {'), (63, '    fn new(addr: SocketAddr) -> Self {'), (64, '        let (addr, len): (*const sockaddr, socklen_t) = match &addr {'), (65, '            SocketAddr::V4(addr) => (addr as *const _ as *const _, mem::size_of_val(addr) as _),'), (66, '            SocketAddr::V6(addr) => (addr as *const _ as *const _, mem::size_of_val(addr) as _),'), (67, '        };'), (68, '        unsafe { Self::from_raw_parts(addr, len) }'), (69, '    }'), (72, '    unsafe fn from_raw_parts(addr: *const sockaddr, len: socklen_t) -> Self {'), (73, '        let mut storage = MaybeUninit::<sockaddr_storage>::uninit();'), (74, '        ptr::copy_nonoverlapping('), (75, '            addr as *const _ as *const u8,'), (76, '            &mut storage as *mut _ as *mut u8,'), (77, '            len as usize,'), (78, '        );'), (79, '        Self {'), (80, '            storage: storage.assume_init(),'), (81, '            len,'), (82, '        }'), (83, '    }'), (84, '}'), (87, 'fn connect(addr: Addr, family: libc::c_int, protocol: libc::c_int) -> io::Result<RawFd> {'), (89, '    macro_rules! syscall {'), (90, '        ($fn:ident $args:tt) => {{'), (91, '            let res = unsafe { libc::$fn $args };'), (92, '            if res == -1 {'), (93, '                Err(std::io::Error::last_os_error())'), (94, '            } else {'), (95, '                Ok(res)'), (96, '            }'), (97, '        }};'), (98, '    }'), (101, '    let mut guard;'), (105, '    #[cfg(target_os = \"linux\")]'), (106, '    let fd = {'), (107, '        let fd = syscall!(socket('), (108, '            family,'), (109, '            libc::SOCK_STREAM | libc::SOCK_CLOEXEC,'), (110, '            protocol,'), (111, '        ))?;'), (112, '        guard = CallOnDrop(Some(move || drop(syscall!(close(fd)))));'), (113, '        fd'), (114, '    };'), (117, '    #[cfg(not(target_os = \"linux\"))]'), (118, '    let fd = {'), (119, '        let fd = syscall!(socket(family, libc::SOCK_STREAM, protocol))?;'), (120, '        guard = CallOnDrop(Some(move || drop(syscall!(close(fd)))));'), (122, '        let flags = syscall!(fcntl(fd, libc::F_GETFD))? | libc::FD_CLOEXEC;'), (123, '        syscall!(fcntl(fd, libc::F_SETFD, flags))?;'), (125, '        #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]'), (126, '        {'), (127, '            let payload = &1i32 as *const i32 as *const libc::c_void;'), (128, '            syscall!(setsockopt('), (129, '                fd,'), (130, '                libc::SOL_SOCKET,'), (131, '                libc::SO_NOSIGPIPE,'), (132, '                payload,'), (133, '                std::mem::size_of::<i32>() as libc::socklen_t,'), (134, '            ))?;'), (135, '        }'), (136, '        fd'), (137, '    };'), (140, '    let flags = syscall!(fcntl(fd, libc::F_GETFL))? | libc::O_NONBLOCK;'), (141, '    syscall!(fcntl(fd, libc::F_SETFL, flags))?;'), (144, '    match syscall!(connect(fd, &addr.storage as *const _ as *const _, addr.len)) {'), (152, '    guard.0.take();'), (154, '    Ok(fd)'), (187, '    use std::cmp::Ordering;'), (188, '    use std::os::unix::ffi::OsStrExt;'), (190, '    let addr = unsafe {'), (191, '        let mut addr = mem::zeroed::<libc::sockaddr_un>();'), (192, '        addr.sun_family = libc::AF_UNIX as libc::sa_family_t;'), (194, '        let bytes = path.as_ref().as_os_str().as_bytes();'), (196, '        match (bytes.get(0), bytes.len().cmp(&addr.sun_path.len())) {'), (198, '            (Some(&0), Ordering::Greater) => {'), (199, '                return Err(io::Error::new('), (200, '                    io::ErrorKind::InvalidInput,'), (201, '                    \"path must be no longer than SUN_LEN\",'), (202, '                ));'), (203, '            }'), (204, '            (Some(&0), _) => {}'), (205, '            (_, Ordering::Greater) | (_, Ordering::Equal) => {'), (206, '                return Err(io::Error::new('), (207, '                    io::ErrorKind::InvalidInput,'), (208, '                    \"path must be shorter than SUN_LEN\",'), (209, '                ));'), (210, '            }'), (211, '            _ => {}'), (212, '        }'), (214, '        for (dst, src) in addr.sun_path.iter_mut().zip(bytes) {'), (215, '            *dst = *src as libc::c_char;'), (216, '        }'), (219, '        let base = &addr as *const _ as usize;'), (220, '        let path = &addr.sun_path as *const _ as usize;'), (221, '        let sun_path_offset = path - base;'), (223, '        let mut len = sun_path_offset + bytes.len();'), (224, '        match bytes.get(0) {'), (225, '            Some(&0) | None => {}'), (226, '            Some(_) => len += 1,'), (227, '        }'), (228, '        Addr::from_raw_parts(&addr as *const _ as *const _, len as libc::socklen_t)'), (229, '    };'), (231, '    let fd = connect(addr, libc::AF_UNIX, 0)?;'), (232, '    unsafe { Ok(UnixStream::from_raw_fd(fd)) }'), (266, '    tcp_connect(addr.into())'), (267, '}'), (269, '#[cfg(unix)]'), (270, 'fn tcp_connect(addr: SocketAddr) -> io::Result<TcpStream> {'), (272, '    let fd = connect('), (273, '        Addr::new(addr),'), (274, '        if addr.is_ipv6() {'), (275, '            libc::AF_INET6'), (276, '        } else {'), (277, '            libc::AF_INET'), (278, '        },'), (279, '        libc::IPPROTO_TCP,'), (280, '    )?;'), (281, '    unsafe { Ok(TcpStream::from_raw_fd(fd)) }'), (282, '}'), (284, '#[cfg(windows)]'), (285, 'fn tcp_connect(addr: SocketAddr) -> io::Result<TcpStream> {'), (286, '    use std::net::UdpSocket;'), (287, '    use std::sync::Once;'), (289, '    use winapi::ctypes::{c_int, c_ulong};'), (290, '    use winapi::shared::minwindef::DWORD;'), (291, '    use winapi::shared::ntdef::HANDLE;'), (292, '    use winapi::shared::ws2def::{AF_INET, AF_INET6, IPPROTO_TCP, SOCK_STREAM};'), (293, '    use winapi::um::handleapi::SetHandleInformation;'), (294, '    use winapi::um::winsock2 as sock;'), (296, '    static INIT: Once = Once::new();'), (297, '    INIT.call_once(|| {'), (301, '        let _ = UdpSocket::bind(\"127.0.0.1:34254\");'), (302, '    });'), (304, '    const HANDLE_FLAG_INHERIT: DWORD = 0x00000001;'), (305, '    const WSA_FLAG_OVERLAPPED: DWORD = 0x01;'), (307, '    let family = if addr.is_ipv6() { AF_INET6 } else { AF_INET };'), (308, '    let addr = Addr::new(addr);'), (310, '    unsafe {'), (311, '        let socket = match sock::WSASocketW('), (312, '            family,'), (313, '            SOCK_STREAM,'), (314, '            IPPROTO_TCP as _,'), (315, '            ptr::null_mut(),'), (316, '            0,'), (317, '            WSA_FLAG_OVERLAPPED,'), (318, '        ) {'), (319, '            sock::INVALID_SOCKET => {'), (320, '                return Err(io::Error::from_raw_os_error(sock::WSAGetLastError()))'), (321, '            }'), (322, '            socket => socket,'), (323, '        };'), (326, '        let stream = TcpStream::from_raw_socket(socket as _);'), (329, '        if SetHandleInformation(socket as HANDLE, HANDLE_FLAG_INHERIT, 0) == 0 {'), (330, '            return Err(io::Error::last_os_error());'), (331, '        }'), (334, '        let mut nonblocking = true as c_ulong;'), (335, '        if sock::ioctlsocket(socket, sock::FIONBIO as c_int, &mut nonblocking) != 0 {'), (336, '            return Err(io::Error::last_os_error());'), (337, '        }'), (340, '        match sock::connect(socket, &addr.storage as *const _ as *const _, addr.len) {'), (341, '            0 => {}'), (342, '            _ => match io::Error::from_raw_os_error(sock::WSAGetLastError()) {'), (343, '                err if err.kind() == io::ErrorKind::WouldBlock => {}'), (344, '                err => return Err(err),'), (345, '            },'), (346, '        }'), (348, '        Ok(stream)'), (349, '    }'), (350, '}'), (353, 'struct CallOnDrop<F: FnOnce()>(Option<F>);'), (355, 'impl<F: FnOnce()> Drop for CallOnDrop<F> {'), (356, '    fn drop(&mut self) {'), (357, '        if let Some(f) = self.0.take() {'), (358, '            f();'), (359, '        }'), (360, '    }')]}",
    "num_lines_added": "35",
    "num_lines_deleted": "195",
    "nloc": "51"
  },
  {
    "file_change_id": "188932671318253",
    "hash": "4ba0d0f689440963e38b8adbe7fc2cabc6e573d",
    "old_path": "lib.rs",
    "new_path": "lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -665,6 +665,8 @@ impl<A: Array> SmallVec<A> {\n                 if unspilled {\n                     return;\n                 }\n+            } else {\n+                return;\n             }\n             deallocate(ptr, cap);\n         }\n@@ -2341,4 +2343,18 @@ mod tests {\n         v.extend(it);\n         assert_eq!(v[..], ['a']);\n     }\n+\n+    #[test]\n+    fn grow_spilled_same_size() {\n+        let mut v: SmallVec<[u8; 2]> = SmallVec::new();\n+        v.push(0);\n+        v.push(1);\n+        v.push(2);\n+        assert!(v.spilled());\n+        assert_eq!(v.capacity(), 4);\n+        // grow with the same capacity\n+        v.grow(4);\n+        assert_eq!(v.capacity(), 4);\n+        assert_eq!(v[..], [0, 1, 2]);\n+    }\n }\n",
    "diff_parsed": "{'added': [(668, '            } else {'), (669, '                return;'), (2347, '    #[test]'), (2348, '    fn grow_spilled_same_size() {'), (2349, '        let mut v: SmallVec<[u8; 2]> = SmallVec::new();'), (2350, '        v.push(0);'), (2351, '        v.push(1);'), (2352, '        v.push(2);'), (2353, '        assert!(v.spilled());'), (2354, '        assert_eq!(v.capacity(), 4);'), (2356, '        v.grow(4);'), (2357, '        assert_eq!(v.capacity(), 4);'), (2358, '        assert_eq!(v[..], [0, 1, 2]);'), (2359, '    }')], 'deleted': []}",
    "num_lines_added": "14",
    "num_lines_deleted": "0",
    "nloc": "1813"
  },
  {
    "file_change_id": "250806394889883",
    "hash": "31a8de9c2f9b096352c4df3877aa8d3df5b73d0",
    "old_path": "build.rs",
    "new_path": "build.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -6,7 +6,7 @@ fn main() {\n     assert!(version().unwrap().major >= 1);\n \n     // Check for a minimum version\n-    if version().unwrap() >= Version::parse(\"1.33.0\").unwrap() {\n-        println!(\"cargo:rustc-cfg=memoffset_constant_expression\");\n+    if version().unwrap() >= Version::parse(\"1.37.0\").unwrap() {\n+        println!(\"cargo:rustc-cfg=memoffset_maybe_uninit\");\n     }\n }\n",
    "diff_parsed": "{'added': [(9, '    if version().unwrap() >= Version::parse(\"1.37.0\").unwrap() {'), (10, '        println!(\"cargo:rustc-cfg=memoffset_maybe_uninit\");')], 'deleted': [(9, '    if version().unwrap() >= Version::parse(\"1.33.0\").unwrap() {'), (10, '        println!(\"cargo:rustc-cfg=memoffset_constant_expression\");')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "8.0"
  },
  {
    "file_change_id": "174796385511365",
    "hash": "31a8de9c2f9b096352c4df3877aa8d3df5b73d0",
    "old_path": "src/constant_impl.rs",
    "new_path": "None",
    "change_type": "ModificationType.DELETE",
    "diff": "@@ -1,13 +0,0 @@\n-// A helper to get a const fn version of size_of_val\n-#[doc(hidden)]\n-pub const fn size_of<T>(_: &T) -> usize {\n-    ::mem::size_of::<T>()\n-}\n-\n-// While constant pointer transmutation isn't stable, union transmutation is\n-// This hack should go away after rust-lang/rust#51910\n-#[doc(hidden)]\n-pub union Transmuter<T: 'static> {\n-    pub ptr: &'static T,\n-    pub int: usize,\n-}\n",
    "diff_parsed": "{'added': [], 'deleted': [(2, '#[doc(hidden)]'), (3, 'pub const fn size_of<T>(_: &T) -> usize {'), (4, '    ::mem::size_of::<T>()'), (5, '}'), (9, '#[doc(hidden)]'), (10, \"pub union Transmuter<T: 'static> {\"), (11, \"    pub ptr: &'static T,\"), (12, '    pub int: usize,'), (13, '}')]}",
    "num_lines_added": "0",
    "num_lines_deleted": "9",
    "nloc": "nan"
  },
  {
    "file_change_id": "170594221044300",
    "hash": "31a8de9c2f9b096352c4df3877aa8d3df5b73d0",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -67,12 +67,8 @@\n #[doc(hidden)]\n pub use core::mem;\n \n-#[cfg(memoffset_constant_expression)]\n #[doc(hidden)]\n-mod constant_impl;\n-\n-#[cfg(memoffset_constant_expression)]\n-pub use constant_impl::{size_of, Transmuter};\n+pub use core::ptr;\n \n #[macro_use]\n mod offset_of;\n",
    "diff_parsed": "{'added': [(71, 'pub use core::ptr;')], 'deleted': [(70, '#[cfg(memoffset_constant_expression)]'), (72, 'mod constant_impl;'), (74, '#[cfg(memoffset_constant_expression)]'), (75, 'pub use constant_impl::{size_of, Transmuter};')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "4",
    "nloc": "9.0"
  },
  {
    "file_change_id": "258672561958651",
    "hash": "31a8de9c2f9b096352c4df3877aa8d3df5b73d0",
    "old_path": "src/offset_of.rs",
    "new_path": "src/offset_of.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -66,30 +66,30 @@\n /// }\n /// ```\n #[macro_export]\n-#[cfg(memoffset_constant_expression)]\n+#[cfg(memoffset_maybe_uninit)]\n macro_rules! offset_of {\n-    ($parent:ty, $($field:tt)+) => (unsafe {\n-        let x: &'static $parent = $crate::Transmuter::<$parent> { int: 0 }.ptr;\n-        $crate::Transmuter { ptr: &x.$($field)+ }.int\n+    ($parent:ty, $field:tt) => (unsafe {\n+        // Create an instance of the container and calculate the offset to its\n+        // field. Although we are creating references to uninitialized data this\n+        // is fine since we are not dereferencing them.\n+        let val = $crate::mem::MaybeUninit::<$parent>::uninitialized();\n+        let &$container { $field: ref f, .. } = &*val.as_ptr();\n+        #[allow(unused_unsafe)]\n+        let result = unsafe { (f as *const _ as *const u8).offset_from(val.as_ptr() as *const u8) };\n+        result as isize\n     });\n }\n \n #[macro_export]\n-#[cfg(not(memoffset_constant_expression))]\n+#[cfg(not(memoffset_maybe_uninit))]\n macro_rules! offset_of {\n-    ($father:ty, $($field:tt)+) => ({\n-        #[allow(unused_unsafe)]\n-        let root: $father = unsafe { $crate::mem::uninitialized() };\n-\n-        let base = &root as *const _ as usize;\n-\n-        // Future error: borrow of packed field requires unsafe function or block (error E0133)\n+    ($parent:ty, $field:tt) => ({\n+        let non_null = $crate::ptr::NonNull::<$parent>::dangling();\n+        let base_ptr = unsafe { non_null.as_ref() };\n         #[allow(unused_unsafe)]\n-        let member =  unsafe { &root.$($field)* as *const _ as usize };\n-\n-        $crate::mem::forget(root);\n-\n-        member - base\n+        let field_ptr = unsafe { &base_ptr.$field };\n+        let offset = (field_ptr as *const _ as usize) - (base_ptr as *const _ as usize);\n+        offset\n     });\n }\n \n@@ -109,18 +109,6 @@ mod tests {\n         assert_eq!(offset_of!(Foo, c), 8);\n     }\n \n-    #[test]\n-    fn offset_index() {\n-        assert_eq!(offset_of!(Foo, b[2]), 6);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    #[allow(const_err)]\n-    fn offset_index_out_of_bounds() {\n-        offset_of!(Foo, b[4]);\n-    }\n-\n     #[test]\n     fn tuple_struct() {\n         #[repr(C, packed)]\n",
    "diff_parsed": "{'added': [(69, '#[cfg(memoffset_maybe_uninit)]'), (71, '    ($parent:ty, $field:tt) => (unsafe {'), (75, '        let val = $crate::mem::MaybeUninit::<$parent>::uninitialized();'), (76, '        let &$container { $field: ref f, .. } = &*val.as_ptr();'), (77, '        #[allow(unused_unsafe)]'), (78, '        let result = unsafe { (f as *const _ as *const u8).offset_from(val.as_ptr() as *const u8) };'), (79, '        result as isize'), (84, '#[cfg(not(memoffset_maybe_uninit))]'), (86, '    ($parent:ty, $field:tt) => ({'), (87, '        let non_null = $crate::ptr::NonNull::<$parent>::dangling();'), (88, '        let base_ptr = unsafe { non_null.as_ref() };'), (90, '        let field_ptr = unsafe { &base_ptr.$field };'), (91, '        let offset = (field_ptr as *const _ as usize) - (base_ptr as *const _ as usize);'), (92, '        offset')], 'deleted': [(69, '#[cfg(memoffset_constant_expression)]'), (71, '    ($parent:ty, $($field:tt)+) => (unsafe {'), (72, \"        let x: &'static $parent = $crate::Transmuter::<$parent> { int: 0 }.ptr;\"), (73, '        $crate::Transmuter { ptr: &x.$($field)+ }.int'), (78, '#[cfg(not(memoffset_constant_expression))]'), (80, '    ($father:ty, $($field:tt)+) => ({'), (81, '        #[allow(unused_unsafe)]'), (82, '        let root: $father = unsafe { $crate::mem::uninitialized() };'), (84, '        let base = &root as *const _ as usize;'), (88, '        let member =  unsafe { &root.$($field)* as *const _ as usize };'), (90, '        $crate::mem::forget(root);'), (92, '        member - base'), (112, '    #[test]'), (113, '    fn offset_index() {'), (114, '        assert_eq!(offset_of!(Foo, b[2]), 6);'), (115, '    }'), (117, '    #[test]'), (118, '    #[should_panic]'), (119, '    #[allow(const_err)]'), (120, '    fn offset_index_out_of_bounds() {'), (121, '        offset_of!(Foo, b[4]);'), (122, '    }')]}",
    "num_lines_added": "14",
    "num_lines_deleted": "22",
    "nloc": "44.0"
  },
  {
    "file_change_id": "14632977399329",
    "hash": "31a8de9c2f9b096352c4df3877aa8d3df5b73d0",
    "old_path": "src/span_of.rs",
    "new_path": "src/span_of.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -267,30 +267,15 @@ mod tests {\n             span_of!(Test, y..),\n             offset_of!(Test, y)..mem::size_of::<Test>()\n         );\n-        assert_eq!(\n-            span_of!(Test, y[0]..),\n-            offset_of!(Test, y[0])..mem::size_of::<Test>()\n-        );\n+        \n         assert_eq!(\n             span_of!(Test, z..),\n             offset_of!(Test, z)..mem::size_of::<Test>()\n         );\n-        assert_eq!(\n-            span_of!(Test, z.foo..),\n-            offset_of!(Test, z.foo)..mem::size_of::<Test>()\n-        );\n         assert_eq!(\n             span_of!(Test, egg..),\n             offset_of!(Test, egg)..mem::size_of::<Test>()\n         );\n-        assert_eq!(\n-            span_of!(Test, egg[0]..),\n-            offset_of!(Test, egg[0])..mem::size_of::<Test>()\n-        );\n-        assert_eq!(\n-            span_of!(Test, egg[0][0]..),\n-            offset_of!(Test, egg[0][0])..mem::size_of::<Test>()\n-        );\n         assert_eq!(\n             span_of!(Test, x..y),\n             offset_of!(Test, x)..offset_of!(Test, y)\n@@ -299,25 +284,9 @@ mod tests {\n             span_of!(Test, x..=y),\n             offset_of!(Test, x)..offset_of!(Test, y) + mem::size_of::<[u8; 56]>()\n         );\n-        assert_eq!(\n-            span_of!(Test, x..y[4]),\n-            offset_of!(Test, x)..offset_of!(Test, y[4])\n-        );\n         assert_eq!(\n             span_of!(Test, x..=y[4]),\n             offset_of!(Test, x)..offset_of!(Test, y) + mem::size_of::<[u8; 5]>()\n         );\n-        assert_eq!(\n-            span_of!(Test, x..z.foo),\n-            offset_of!(Test, x)..offset_of!(Test, z.foo)\n-        );\n-        assert_eq!(\n-            span_of!(Test, x..=z.foo),\n-            offset_of!(Test, x)..offset_of!(Test, z.foo) + mem::size_of::<u32>()\n-        );\n-        assert_eq!(\n-            span_of!(Test, egg[0][0]..egg[1][0]),\n-            offset_of!(Test, egg[0][0])..offset_of!(Test, egg[1][0])\n-        );\n     }\n }\n",
    "diff_parsed": "{'added': [], 'deleted': [(270, '        assert_eq!('), (271, '            span_of!(Test, y[0]..),'), (272, '            offset_of!(Test, y[0])..mem::size_of::<Test>()'), (273, '        );'), (278, '        assert_eq!('), (279, '            span_of!(Test, z.foo..),'), (280, '            offset_of!(Test, z.foo)..mem::size_of::<Test>()'), (281, '        );'), (286, '        assert_eq!('), (287, '            span_of!(Test, egg[0]..),'), (288, '            offset_of!(Test, egg[0])..mem::size_of::<Test>()'), (289, '        );'), (290, '        assert_eq!('), (291, '            span_of!(Test, egg[0][0]..),'), (292, '            offset_of!(Test, egg[0][0])..mem::size_of::<Test>()'), (293, '        );'), (302, '        assert_eq!('), (303, '            span_of!(Test, x..y[4]),'), (304, '            offset_of!(Test, x)..offset_of!(Test, y[4])'), (305, '        );'), (310, '        assert_eq!('), (311, '            span_of!(Test, x..z.foo),'), (312, '            offset_of!(Test, x)..offset_of!(Test, z.foo)'), (313, '        );'), (314, '        assert_eq!('), (315, '            span_of!(Test, x..=z.foo),'), (316, '            offset_of!(Test, x)..offset_of!(Test, z.foo) + mem::size_of::<u32>()'), (317, '        );'), (318, '        assert_eq!('), (319, '            span_of!(Test, egg[0][0]..egg[1][0]),'), (320, '            offset_of!(Test, egg[0][0])..offset_of!(Test, egg[1][0])'), (321, '        );')]}",
    "num_lines_added": "0",
    "num_lines_deleted": "32",
    "nloc": "193.0"
  },
  {
    "file_change_id": "203717893439416",
    "hash": "2d7317336ebaba7a6ffd778dbc8c52b5bbbd151",
    "old_path": "futures-util/src/stream/futures_unordered/iter.rs",
    "new_path": "futures-util/src/stream/futures_unordered/iter.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -2,6 +2,7 @@ use super::FuturesUnordered;\n use super::task::Task;\n use core::marker::PhantomData;\n use core::pin::Pin;\n+use core::sync::atomic::Ordering::Relaxed;\n \n #[derive(Debug)]\n /// Mutable iterator over all futures in the unordered set.\n@@ -20,6 +21,7 @@ pub struct IterMut<'a, Fut: Unpin> (pub(super) IterPinMut<'a, Fut>);\n pub struct IterPinRef<'a, Fut> {\n     pub(super) task: *const Task<Fut>,\n     pub(super) len: usize,\n+    pub(super) pending_next_all: *mut Task<Fut>,\n     pub(super) _marker: PhantomData<&'a FuturesUnordered<Fut>>\n }\n \n@@ -36,7 +38,12 @@ impl<'a, Fut> Iterator for IterPinMut<'a, Fut> {\n         }\n         unsafe {\n             let future = (*(*self.task).future.get()).as_mut().unwrap();\n-            let next = *(*self.task).next_all.get();\n+\n+            // Mutable access to a previously shared `FuturesUnordered` implies\n+            // that the other threads already released the object before the\n+            // current thread acquired it, so relaxed ordering can be used and\n+            // valid `next_all` checks can be skipped.\n+            let next = (*self.task).next_all.load(Relaxed);\n             self.task = next;\n             self.len -= 1;\n             Some(Pin::new_unchecked(future))\n@@ -73,7 +80,15 @@ impl<'a, Fut> Iterator for IterPinRef<'a, Fut> {\n         }\n         unsafe {\n             let future = (*(*self.task).future.get()).as_ref().unwrap();\n-            let next = *(*self.task).next_all.get();\n+\n+            // Relaxed ordering can be used since acquire ordering when\n+            // `head_all` was initially read for this iterator implies acquire\n+            // ordering for all previously inserted nodes (and we don't need to\n+            // read `len_all` again for any other nodes).\n+            let next = (*self.task).spin_next_all(\n+                self.pending_next_all,\n+                Relaxed,\n+            );\n             self.task = next;\n             self.len -= 1;\n             Some(Pin::new_unchecked(future))\n",
    "diff_parsed": "{'added': [(5, 'use core::sync::atomic::Ordering::Relaxed;'), (24, '    pub(super) pending_next_all: *mut Task<Fut>,'), (46, '            let next = (*self.task).next_all.load(Relaxed);'), (88, '            let next = (*self.task).spin_next_all('), (89, '                self.pending_next_all,'), (90, '                Relaxed,'), (91, '            );')], 'deleted': [(39, '            let next = *(*self.task).next_all.get();'), (76, '            let next = *(*self.task).next_all.get();')]}",
    "num_lines_added": "7",
    "num_lines_deleted": "2",
    "nloc": "91"
  },
  {
    "file_change_id": "240833640622287",
    "hash": "2d7317336ebaba7a6ffd778dbc8c52b5bbbd151",
    "old_path": "futures-util/src/stream/futures_unordered/mod.rs",
    "new_path": "futures-util/src/stream/futures_unordered/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -8,14 +8,14 @@ use futures_core::stream::{FusedStream, Stream};\n use futures_core::task::{Context, Poll};\n use futures_task::{FutureObj, LocalFutureObj, Spawn, LocalSpawn, SpawnError};\n use crate::task::AtomicWaker;\n-use core::cell::{Cell, UnsafeCell};\n+use core::cell::UnsafeCell;\n use core::fmt::{self, Debug};\n use core::iter::FromIterator;\n use core::marker::PhantomData;\n use core::mem;\n use core::pin::Pin;\n use core::ptr;\n-use core::sync::atomic::Ordering::SeqCst;\n+use core::sync::atomic::Ordering::{AcqRel, Acquire, Relaxed, Release, SeqCst};\n use core::sync::atomic::{AtomicPtr, AtomicBool};\n use alloc::sync::{Arc, Weak};\n \n@@ -30,15 +30,6 @@ use self::task::Task;\n mod ready_to_run_queue;\n use self::ready_to_run_queue::{ReadyToRunQueue, Dequeue};\n \n-/// Constant used for a `FuturesUnordered` to indicate we are empty and have\n-/// yielded a `None` element so can return `true` from\n-/// `FusedStream::is_terminated`\n-///\n-/// It is safe to not check for this when incrementing as even a ZST future will\n-/// have a `Task` allocated for it, so we cannot ever reach usize::max_value()\n-/// without running out of ram.\n-const TERMINATED_SENTINEL_LENGTH: usize = usize::max_value();\n-\n /// Constant used for a `FuturesUnordered` to determine how many times it is\n /// allowed to poll underlying futures without yielding.\n ///\n@@ -79,8 +70,8 @@ const YIELD_EVERY: usize = 32;\n #[must_use = \"streams do nothing unless polled\"]\n pub struct FuturesUnordered<Fut> {\n     ready_to_run_queue: Arc<ReadyToRunQueue<Fut>>,\n-    len: Cell<usize>,\n-    head_all: Cell<*const Task<Fut>>,\n+    head_all: AtomicPtr<Task<Fut>>,\n+    is_terminated: AtomicBool,\n }\n \n unsafe impl<Fut: Send> Send for FuturesUnordered<Fut> {}\n@@ -107,10 +98,12 @@ impl LocalSpawn for FuturesUnordered<LocalFutureObj<'_, ()>> {\n \n // FuturesUnordered is implemented using two linked lists. One which links all\n // futures managed by a `FuturesUnordered` and one that tracks futures that have\n-// been scheduled for polling. The first linked list is not thread safe and is\n-// only accessed by the thread that owns the `FuturesUnordered` value. The\n-// second linked list is an implementation of the intrusive MPSC queue algorithm\n-// described by 1024cores.net.\n+// been scheduled for polling. The first linked list allows for thread safe\n+// insertion of nodes at the head as well as forward iteration, but is otherwise\n+// not thread safe and is only accessed by the thread that owns the\n+// `FuturesUnordered` value for any other operations. The second linked list is\n+// an implementation of the intrusive MPSC queue algorithm described by\n+// 1024cores.net.\n //\n // When a future is submitted to the set, a task is allocated and inserted in\n // both linked lists. The next call to `poll_next` will (eventually) see this\n@@ -137,8 +130,9 @@ impl<Fut: Future> FuturesUnordered<Fut> {\n     pub fn new() -> FuturesUnordered<Fut> {\n         let stub = Arc::new(Task {\n             future: UnsafeCell::new(None),\n-            next_all: UnsafeCell::new(ptr::null()),\n+            next_all: AtomicPtr::new(ptr::null_mut()),\n             prev_all: UnsafeCell::new(ptr::null()),\n+            len_all: UnsafeCell::new(0),\n             next_ready_to_run: AtomicPtr::new(ptr::null_mut()),\n             queued: AtomicBool::new(true),\n             ready_to_run_queue: Weak::new(),\n@@ -152,9 +146,9 @@ impl<Fut: Future> FuturesUnordered<Fut> {\n         });\n \n         FuturesUnordered {\n-            len: 0.into(),\n-            head_all: Cell::from(ptr::null()),\n+            head_all: AtomicPtr::new(ptr::null_mut()),\n             ready_to_run_queue,\n+            is_terminated: AtomicBool::new(false),\n         }\n     }\n }\n@@ -170,14 +164,15 @@ impl<Fut> FuturesUnordered<Fut> {\n     ///\n     /// This represents the total number of in-flight futures.\n     pub fn len(&self) -> usize {\n-        let len = self.len.get();\n-        if len == TERMINATED_SENTINEL_LENGTH { 0 } else { len }\n+        let (_, len) = self.atomic_load_head_and_len_all();\n+        len\n     }\n \n     /// Returns `true` if the set contains no futures.\n     pub fn is_empty(&self) -> bool {\n-        let len = self.len.get();\n-        len == 0 || len == TERMINATED_SENTINEL_LENGTH\n+        // Relaxed ordering can be used here since we don't need to read from\n+        // the head pointer, only check whether it is null.\n+        self.head_all.load(Relaxed).is_null()\n     }\n \n     /// Push a future into the set.\n@@ -189,18 +184,17 @@ impl<Fut> FuturesUnordered<Fut> {\n     pub fn push(&self, future: Fut) {\n         let task = Arc::new(Task {\n             future: UnsafeCell::new(Some(future)),\n-            next_all: UnsafeCell::new(ptr::null_mut()),\n+            next_all: AtomicPtr::new(self.pending_next_all()),\n             prev_all: UnsafeCell::new(ptr::null_mut()),\n+            len_all: UnsafeCell::new(0),\n             next_ready_to_run: AtomicPtr::new(ptr::null_mut()),\n             queued: AtomicBool::new(true),\n             ready_to_run_queue: Arc::downgrade(&self.ready_to_run_queue),\n         });\n \n-        // If we've previously marked ourselves as terminated we need to reset\n-        // len to 0 to track it correctly\n-        if self.len.get() == TERMINATED_SENTINEL_LENGTH {\n-            self.len.set(0);\n-        }\n+        // Reset the `is_terminated` flag if we've previously marked ourselves\n+        // as terminated.\n+        self.is_terminated.store(false, Relaxed);\n \n         // Right now our task has a strong reference count of 1. We transfer\n         // ownership of this reference count to our internal linked list\n@@ -221,9 +215,12 @@ impl<Fut> FuturesUnordered<Fut> {\n \n     /// Returns an iterator that allows inspecting each future in the set.\n     fn iter_pin_ref(self: Pin<&Self>) -> IterPinRef<'_, Fut> {\n+        let (task, len) = self.atomic_load_head_and_len_all();\n+\n         IterPinRef {\n-            task: self.head_all.get(),\n-            len: self.len(),\n+            task,\n+            len,\n+            pending_next_all: self.pending_next_all(),\n             _marker: PhantomData,\n         }\n     }\n@@ -234,21 +231,49 @@ impl<Fut> FuturesUnordered<Fut> {\n     }\n \n     /// Returns an iterator that allows modifying each future in the set.\n-    pub fn iter_pin_mut(self: Pin<&mut Self>) -> IterPinMut<'_, Fut> {\n+    pub fn iter_pin_mut(mut self: Pin<&mut Self>) -> IterPinMut<'_, Fut> {\n+        // `head_all` can be accessed directly and we don't need to spin on\n+        // `Task::next_all` since we have exclusive access to the set.\n+        let task = *self.head_all.get_mut();\n+        let len = if task.is_null() {\n+            0\n+        } else {\n+            unsafe {\n+                *(*task).len_all.get()\n+            }\n+        };\n+\n         IterPinMut {\n-            task: self.head_all.get(),\n-            len: self.len(),\n+            task,\n+            len,\n             _marker: PhantomData\n         }\n     }\n \n+    /// Returns the current head node and number of futures in the list of all\n+    /// futures within a context where access is shared with other threads\n+    /// (mostly for use with the `len` and `iter_pin_ref` methods).\n+    fn atomic_load_head_and_len_all(&self) -> (*const Task<Fut>, usize) {\n+        let task = self.head_all.load(Acquire);\n+        let len = if task.is_null() {\n+            0\n+        } else {\n+            unsafe {\n+                (*task).spin_next_all(self.pending_next_all(), Acquire);\n+                *(*task).len_all.get()\n+            }\n+        };\n+\n+        (task, len)\n+    }\n+\n     /// Releases the task. It destorys the future inside and either drops\n     /// the `Arc<Task>` or transfers ownership to the ready to run queue.\n     /// The task this method is called on must have been unlinked before.\n     fn release_task(&mut self, task: Arc<Task<Fut>>) {\n         // `release_task` must only be called on unlinked tasks\n+        debug_assert_eq!(task.next_all.load(Relaxed), self.pending_next_all());\n         unsafe {\n-            debug_assert!((*task.next_all.get()).is_null());\n             debug_assert!((*task.prev_all.get()).is_null());\n         }\n \n@@ -284,17 +309,38 @@ impl<Fut> FuturesUnordered<Fut> {\n \n     /// Insert a new task into the internal linked list.\n     fn link(&self, task: Arc<Task<Fut>>) -> *const Task<Fut> {\n+        // `next_all` should already be reset to the pending state before this\n+        // function is called.\n+        debug_assert_eq!(task.next_all.load(Relaxed), self.pending_next_all());\n         let ptr = Arc::into_raw(task);\n+\n+        // Atomically swap out the old head node to get the node that should be\n+        // assigned to `next_all`.\n+        let next = self.head_all.swap(ptr as *mut _, AcqRel);\n+\n         unsafe {\n-            *(*ptr).next_all.get() = self.head_all.get();\n-            if !self.head_all.get().is_null() {\n-                *(*self.head_all.get()).prev_all.get() = ptr;\n+            // Store the new list length in the new node.\n+            let new_len = if next.is_null() {\n+                1\n+            } else {\n+                // Make sure `next_all` has been written to signal that it is\n+                // safe to read `len_all`.\n+                (*next).spin_next_all(self.pending_next_all(), Acquire);\n+                *(*next).len_all.get() + 1\n+            };\n+            *(*ptr).len_all.get() = new_len;\n+\n+            // Write the old head as the next node pointer, signaling to other\n+            // threads that `len_all` and `next_all` are ready to read.\n+            (*ptr).next_all.store(next, Release);\n+\n+            // `prev_all` updates don't need to be synchronized, as the field is\n+            // only ever used after exclusive access has been acquired.\n+            if !next.is_null() {\n+                *(*next).prev_all.get() = ptr;\n             }\n         }\n \n-        self.head_all.set(ptr);\n-        let old_len = self.len.get();\n-        self.len.set(old_len + 1);\n         ptr\n     }\n \n@@ -303,10 +349,16 @@ impl<Fut> FuturesUnordered<Fut> {\n     /// This method is unsafe because it has be guaranteed that `task` is a\n     /// valid pointer.\n     unsafe fn unlink(&mut self, task: *const Task<Fut>) -> Arc<Task<Fut>> {\n+        // Compute the new list length now in case we're removing the head node\n+        // and won't be able to retrieve the correct length later.\n+        let head = *self.head_all.get_mut();\n+        debug_assert!(!head.is_null());\n+        let new_len = *(*head).len_all.get() - 1;\n+\n         let task = Arc::from_raw(task);\n-        let next = *task.next_all.get();\n+        let next = task.next_all.load(Relaxed);\n         let prev = *task.prev_all.get();\n-        *task.next_all.get() = ptr::null_mut();\n+        task.next_all.store(self.pending_next_all(), Relaxed);\n         *task.prev_all.get() = ptr::null_mut();\n \n         if !next.is_null() {\n@@ -314,14 +366,48 @@ impl<Fut> FuturesUnordered<Fut> {\n         }\n \n         if !prev.is_null() {\n-            *(*prev).next_all.get() = next;\n+            (*prev).next_all.store(next, Relaxed);\n         } else {\n-            self.head_all.set(next);\n+            *self.head_all.get_mut() = next;\n+        }\n+\n+        // Store the new list length in the head node.\n+        let head = *self.head_all.get_mut();\n+        if !head.is_null() {\n+            *(*head).len_all.get() = new_len;\n         }\n-        let old_len = self.len.get();\n-        self.len.set(old_len - 1);\n+\n         task\n     }\n+\n+    /// Returns the reserved value for `Task::next_all` to indicate a pending\n+    /// assignment from the thread that inserted the task.\n+    ///\n+    /// `FuturesUnordered::link` needs to update `Task` pointers in an order\n+    /// that ensures any iterators created on other threads can correctly\n+    /// traverse the entire `Task` list using the chain of `next_all` pointers.\n+    /// This could be solved with a compare-exchange loop that stores the\n+    /// current `head_all` in `next_all` and swaps out `head_all` with the new\n+    /// `Task` pointer if the head hasn't already changed. Under heavy thread\n+    /// contention, this compare-exchange loop could become costly.\n+    ///\n+    /// An alternative is to initialize `next_all` to a reserved pending state\n+    /// first, perform an atomic swap on `head_all`, and finally update\n+    /// `next_all` with the old head node. Iterators will then either see the\n+    /// pending state value or the correct next node pointer, and can reload\n+    /// `next_all` as needed until the correct value is loaded. The number of\n+    /// retries needed (if any) would be small and will always be finite, so\n+    /// this should generally perform better than the compare-exchange loop.\n+    ///\n+    /// A valid `Task` pointer in the `head_all` list is guaranteed to never be\n+    /// this value, so it is safe to use as a reserved value until the correct\n+    /// value can be written.\n+    fn pending_next_all(&self) -> *mut Task<Fut> {\n+        // The `ReadyToRunQueue` stub is never inserted into the `head_all`\n+        // list, and its pointer value will remain valid for the lifetime of\n+        // this `FuturesUnordered`, so we can make use of its value here.\n+        &*self.ready_to_run_queue.stub as *const _ as *mut _\n+    }\n }\n \n impl<Fut: Future> Stream for FuturesUnordered<Fut> {\n@@ -345,7 +431,7 @@ impl<Fut: Future> Stream for FuturesUnordered<Fut> {\n                     if self.is_empty() {\n                         // We can only consider ourselves terminated once we\n                         // have yielded a `None`\n-                        self.len.set(TERMINATED_SENTINEL_LENGTH);\n+                        *self.is_terminated.get_mut() = true;\n                         return Poll::Ready(None);\n                     } else {\n                         return Poll::Pending;\n@@ -385,8 +471,11 @@ impl<Fut: Future> Stream for FuturesUnordered<Fut> {\n \n                     // Double check that the call to `release_task` really\n                     // happened. Calling it required the task to be unlinked.\n+                    debug_assert_eq!(\n+                        task.next_all.load(Relaxed),\n+                        self.pending_next_all()\n+                    );\n                     unsafe {\n-                        debug_assert!((*task.next_all.get()).is_null());\n                         debug_assert!((*task.prev_all.get()).is_null());\n                     }\n                     continue\n@@ -496,8 +585,8 @@ impl<Fut> Drop for FuturesUnordered<Fut> {\n         // wakers flying around which contain `Task<Fut>` references\n         // inside them. We'll let those naturally get deallocated.\n         unsafe {\n-            while !self.head_all.get().is_null() {\n-                let head = self.head_all.get();\n+            while !self.head_all.get_mut().is_null() {\n+                let head = *self.head_all.get_mut();\n                 let task = self.unlink(head);\n                 self.release_task(task);\n             }\n@@ -530,6 +619,6 @@ impl<Fut: Future> FromIterator<Fut> for FuturesUnordered<Fut> {\n \n impl<Fut: Future> FusedStream for FuturesUnordered<Fut> {\n     fn is_terminated(&self) -> bool {\n-        self.len.get() == TERMINATED_SENTINEL_LENGTH\n+        self.is_terminated.load(Relaxed)\n     }\n }\n",
    "diff_parsed": "{'added': [(11, 'use core::cell::UnsafeCell;'), (18, 'use core::sync::atomic::Ordering::{AcqRel, Acquire, Relaxed, Release, SeqCst};'), (73, '    head_all: AtomicPtr<Task<Fut>>,'), (74, '    is_terminated: AtomicBool,'), (133, '            next_all: AtomicPtr::new(ptr::null_mut()),'), (135, '            len_all: UnsafeCell::new(0),'), (149, '            head_all: AtomicPtr::new(ptr::null_mut()),'), (151, '            is_terminated: AtomicBool::new(false),'), (167, '        let (_, len) = self.atomic_load_head_and_len_all();'), (168, '        len'), (175, '        self.head_all.load(Relaxed).is_null()'), (187, '            next_all: AtomicPtr::new(self.pending_next_all()),'), (189, '            len_all: UnsafeCell::new(0),'), (197, '        self.is_terminated.store(false, Relaxed);'), (218, '        let (task, len) = self.atomic_load_head_and_len_all();'), (221, '            task,'), (222, '            len,'), (223, '            pending_next_all: self.pending_next_all(),'), (234, \"    pub fn iter_pin_mut(mut self: Pin<&mut Self>) -> IterPinMut<'_, Fut> {\"), (237, '        let task = *self.head_all.get_mut();'), (238, '        let len = if task.is_null() {'), (239, '            0'), (240, '        } else {'), (241, '            unsafe {'), (242, '                *(*task).len_all.get()'), (243, '            }'), (244, '        };'), (247, '            task,'), (248, '            len,'), (256, '    fn atomic_load_head_and_len_all(&self) -> (*const Task<Fut>, usize) {'), (257, '        let task = self.head_all.load(Acquire);'), (258, '        let len = if task.is_null() {'), (259, '            0'), (260, '        } else {'), (261, '            unsafe {'), (262, '                (*task).spin_next_all(self.pending_next_all(), Acquire);'), (263, '                *(*task).len_all.get()'), (264, '            }'), (265, '        };'), (267, '        (task, len)'), (268, '    }'), (275, '        debug_assert_eq!(task.next_all.load(Relaxed), self.pending_next_all());'), (314, '        debug_assert_eq!(task.next_all.load(Relaxed), self.pending_next_all());'), (319, '        let next = self.head_all.swap(ptr as *mut _, AcqRel);'), (323, '            let new_len = if next.is_null() {'), (324, '                1'), (325, '            } else {'), (328, '                (*next).spin_next_all(self.pending_next_all(), Acquire);'), (329, '                *(*next).len_all.get() + 1'), (330, '            };'), (331, '            *(*ptr).len_all.get() = new_len;'), (335, '            (*ptr).next_all.store(next, Release);'), (339, '            if !next.is_null() {'), (340, '                *(*next).prev_all.get() = ptr;'), (354, '        let head = *self.head_all.get_mut();'), (355, '        debug_assert!(!head.is_null());'), (356, '        let new_len = *(*head).len_all.get() - 1;'), (359, '        let next = task.next_all.load(Relaxed);'), (361, '        task.next_all.store(self.pending_next_all(), Relaxed);'), (369, '            (*prev).next_all.store(next, Relaxed);'), (371, '            *self.head_all.get_mut() = next;'), (372, '        }'), (375, '        let head = *self.head_all.get_mut();'), (376, '        if !head.is_null() {'), (377, '            *(*head).len_all.get() = new_len;'), (405, '    fn pending_next_all(&self) -> *mut Task<Fut> {'), (409, '        &*self.ready_to_run_queue.stub as *const _ as *mut _'), (410, '    }'), (434, '                        *self.is_terminated.get_mut() = true;'), (474, '                    debug_assert_eq!('), (475, '                        task.next_all.load(Relaxed),'), (476, '                        self.pending_next_all()'), (477, '                    );'), (588, '            while !self.head_all.get_mut().is_null() {'), (589, '                let head = *self.head_all.get_mut();'), (622, '        self.is_terminated.load(Relaxed)')], 'deleted': [(11, 'use core::cell::{Cell, UnsafeCell};'), (18, 'use core::sync::atomic::Ordering::SeqCst;'), (40, 'const TERMINATED_SENTINEL_LENGTH: usize = usize::max_value();'), (82, '    len: Cell<usize>,'), (83, '    head_all: Cell<*const Task<Fut>>,'), (140, '            next_all: UnsafeCell::new(ptr::null()),'), (155, '            len: 0.into(),'), (156, '            head_all: Cell::from(ptr::null()),'), (173, '        let len = self.len.get();'), (174, '        if len == TERMINATED_SENTINEL_LENGTH { 0 } else { len }'), (179, '        let len = self.len.get();'), (180, '        len == 0 || len == TERMINATED_SENTINEL_LENGTH'), (192, '            next_all: UnsafeCell::new(ptr::null_mut()),'), (201, '        if self.len.get() == TERMINATED_SENTINEL_LENGTH {'), (202, '            self.len.set(0);'), (203, '        }'), (225, '            task: self.head_all.get(),'), (226, '            len: self.len(),'), (237, \"    pub fn iter_pin_mut(self: Pin<&mut Self>) -> IterPinMut<'_, Fut> {\"), (239, '            task: self.head_all.get(),'), (240, '            len: self.len(),'), (251, '            debug_assert!((*task.next_all.get()).is_null());'), (289, '            *(*ptr).next_all.get() = self.head_all.get();'), (290, '            if !self.head_all.get().is_null() {'), (291, '                *(*self.head_all.get()).prev_all.get() = ptr;'), (295, '        self.head_all.set(ptr);'), (296, '        let old_len = self.len.get();'), (297, '        self.len.set(old_len + 1);'), (307, '        let next = *task.next_all.get();'), (309, '        *task.next_all.get() = ptr::null_mut();'), (317, '            *(*prev).next_all.get() = next;'), (319, '            self.head_all.set(next);'), (321, '        let old_len = self.len.get();'), (322, '        self.len.set(old_len - 1);'), (348, '                        self.len.set(TERMINATED_SENTINEL_LENGTH);'), (389, '                        debug_assert!((*task.next_all.get()).is_null());'), (499, '            while !self.head_all.get().is_null() {'), (500, '                let head = self.head_all.get();'), (533, '        self.len.get() == TERMINATED_SENTINEL_LENGTH')]}",
    "num_lines_added": "76",
    "num_lines_deleted": "39",
    "nloc": "353"
  },
  {
    "file_change_id": "159497105725012",
    "hash": "2d7317336ebaba7a6ffd778dbc8c52b5bbbd151",
    "old_path": "futures-util/src/stream/futures_unordered/task.rs",
    "new_path": "futures-util/src/stream/futures_unordered/task.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,6 +1,6 @@\n use core::cell::UnsafeCell;\n use core::sync::atomic::{AtomicPtr, AtomicBool};\n-use core::sync::atomic::Ordering::SeqCst;\n+use core::sync::atomic::Ordering::{self, SeqCst};\n use alloc::sync::{Arc, Weak};\n \n use crate::task::{ArcWake, WakerRef, waker_ref};\n@@ -11,12 +11,18 @@ pub(super) struct Task<Fut> {\n     // The future\n     pub(super) future: UnsafeCell<Option<Fut>>,\n \n-    // Next pointer for linked list tracking all active tasks\n-    pub(super) next_all: UnsafeCell<*const Task<Fut>>,\n+    // Next pointer for linked list tracking all active tasks (use\n+    // `spin_next_all` to read when access is shared across threads)\n+    pub(super) next_all: AtomicPtr<Task<Fut>>,\n \n     // Previous task in linked list tracking all active tasks\n     pub(super) prev_all: UnsafeCell<*const Task<Fut>>,\n \n+    // Length of the linked list tracking all active tasks when this node was\n+    // inserted (use `spin_next_all` to synchronize before reading when access\n+    // is shared across threads)\n+    pub(super) len_all: UnsafeCell<usize>,\n+\n     // Next pointer in ready to run queue\n     pub(super) next_ready_to_run: AtomicPtr<Task<Fut>>,\n \n@@ -67,6 +73,30 @@ impl<Fut> Task<Fut> {\n     pub(super) fn waker_ref<'a>(this: &'a Arc<Task<Fut>>) -> WakerRef<'a> {\n         waker_ref(this)\n     }\n+\n+    /// Spins until `next_all` is no longer set to `pending_next_all`.\n+    ///\n+    /// The temporary `pending_next_all` value is typically overwritten fairly\n+    /// quickly after a node is inserted into the list of all futures, so this\n+    /// should rarely spin much.\n+    ///\n+    /// When it returns, the correct `next_all` value is returned.\n+    ///\n+    /// `Relaxed` or `Acquire` ordering can be used. `Acquire` ordering must be\n+    /// used before `len_all` can be safely read.\n+    #[inline]\n+    pub(super) fn spin_next_all(\n+        &self,\n+        pending_next_all: *mut Self,\n+        ordering: Ordering,\n+    ) -> *const Self {\n+        loop {\n+            let next = self.next_all.load(ordering);\n+            if next != pending_next_all {\n+                return next;\n+            }\n+        }\n+    }\n }\n \n impl<Fut> Drop for Task<Fut> {\n",
    "diff_parsed": "{'added': [(3, 'use core::sync::atomic::Ordering::{self, SeqCst};'), (16, '    pub(super) next_all: AtomicPtr<Task<Fut>>,'), (24, '    pub(super) len_all: UnsafeCell<usize>,'), (87, '    #[inline]'), (88, '    pub(super) fn spin_next_all('), (89, '        &self,'), (90, '        pending_next_all: *mut Self,'), (91, '        ordering: Ordering,'), (92, '    ) -> *const Self {'), (93, '        loop {'), (94, '            let next = self.next_all.load(ordering);'), (95, '            if next != pending_next_all {'), (96, '                return next;'), (97, '            }'), (98, '        }'), (99, '    }')], 'deleted': [(3, 'use core::sync::atomic::Ordering::SeqCst;'), (15, '    pub(super) next_all: UnsafeCell<*const Task<Fut>>,')]}",
    "num_lines_added": "16",
    "num_lines_deleted": "2",
    "nloc": "72"
  },
  {
    "file_change_id": "185944976942426",
    "hash": "2d7317336ebaba7a6ffd778dbc8c52b5bbbd151",
    "old_path": "futures/tests/futures_unordered.rs",
    "new_path": "futures/tests/futures_unordered.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -245,3 +245,43 @@ fn futures_not_moved_after_poll() {\n     assert_stream_next!(stream, ());\n     assert_stream_done!(stream);\n }\n+\n+#[test]\n+fn len_valid_during_out_of_order_completion() {\n+    // Complete futures out-of-order and add new futures afterwards to ensure\n+    // length values remain correct.\n+    let (a_tx, a_rx) = oneshot::channel::<i32>();\n+    let (b_tx, b_rx) = oneshot::channel::<i32>();\n+    let (c_tx, c_rx) = oneshot::channel::<i32>();\n+    let (d_tx, d_rx) = oneshot::channel::<i32>();\n+\n+    let mut cx = noop_context();\n+    let mut stream = FuturesUnordered::new();\n+    assert_eq!(stream.len(), 0);\n+\n+    stream.push(a_rx);\n+    assert_eq!(stream.len(), 1);\n+    stream.push(b_rx);\n+    assert_eq!(stream.len(), 2);\n+    stream.push(c_rx);\n+    assert_eq!(stream.len(), 3);\n+\n+    b_tx.send(4).unwrap();\n+    assert_eq!(stream.poll_next_unpin(&mut cx), Poll::Ready(Some(Ok(4))));\n+    assert_eq!(stream.len(), 2);\n+\n+    stream.push(d_rx);\n+    assert_eq!(stream.len(), 3);\n+\n+    c_tx.send(5).unwrap();\n+    assert_eq!(stream.poll_next_unpin(&mut cx), Poll::Ready(Some(Ok(5))));\n+    assert_eq!(stream.len(), 2);\n+\n+    d_tx.send(6).unwrap();\n+    assert_eq!(stream.poll_next_unpin(&mut cx), Poll::Ready(Some(Ok(6))));\n+    assert_eq!(stream.len(), 1);\n+\n+    a_tx.send(7).unwrap();\n+    assert_eq!(stream.poll_next_unpin(&mut cx), Poll::Ready(Some(Ok(7))));\n+    assert_eq!(stream.len(), 0);\n+}\n",
    "diff_parsed": "{'added': [(249, '#[test]'), (250, 'fn len_valid_during_out_of_order_completion() {'), (253, '    let (a_tx, a_rx) = oneshot::channel::<i32>();'), (254, '    let (b_tx, b_rx) = oneshot::channel::<i32>();'), (255, '    let (c_tx, c_rx) = oneshot::channel::<i32>();'), (256, '    let (d_tx, d_rx) = oneshot::channel::<i32>();'), (258, '    let mut cx = noop_context();'), (259, '    let mut stream = FuturesUnordered::new();'), (260, '    assert_eq!(stream.len(), 0);'), (262, '    stream.push(a_rx);'), (263, '    assert_eq!(stream.len(), 1);'), (264, '    stream.push(b_rx);'), (265, '    assert_eq!(stream.len(), 2);'), (266, '    stream.push(c_rx);'), (267, '    assert_eq!(stream.len(), 3);'), (269, '    b_tx.send(4).unwrap();'), (270, '    assert_eq!(stream.poll_next_unpin(&mut cx), Poll::Ready(Some(Ok(4))));'), (271, '    assert_eq!(stream.len(), 2);'), (273, '    stream.push(d_rx);'), (274, '    assert_eq!(stream.len(), 3);'), (276, '    c_tx.send(5).unwrap();'), (277, '    assert_eq!(stream.poll_next_unpin(&mut cx), Poll::Ready(Some(Ok(5))));'), (278, '    assert_eq!(stream.len(), 2);'), (280, '    d_tx.send(6).unwrap();'), (281, '    assert_eq!(stream.poll_next_unpin(&mut cx), Poll::Ready(Some(Ok(6))));'), (282, '    assert_eq!(stream.len(), 1);'), (284, '    a_tx.send(7).unwrap();'), (285, '    assert_eq!(stream.poll_next_unpin(&mut cx), Poll::Ready(Some(Ok(7))));'), (286, '    assert_eq!(stream.len(), 0);'), (287, '}')], 'deleted': []}",
    "num_lines_added": "30",
    "num_lines_deleted": "0",
    "nloc": "235"
  },
  {
    "file_change_id": "150678240090393",
    "hash": "70c87a49451c4dfcb170461ad9c55fe2f104b7b",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -748,7 +748,7 @@ impl<T> SliceDeque<T> {\n             new_head += cap as isize;\n             debug_assert!(new_head >= 0);\n             self.tail_ += cap;\n-        } else if new_head as usize > cap {\n+        } else if new_head as usize >= cap {\n             // cannot panic because new_head >= 0\n             // If the new head is larger than the capacity, we shift the range\n             // by -capacity to move it towards the first mirrored\n@@ -765,6 +765,8 @@ impl<T> SliceDeque<T> {\n \n         debug_assert!(self.tail() <= self.tail_upper_bound());\n         debug_assert!(self.head() <= self.head_upper_bound());\n+\n+        debug_assert!(self.head() != self.capacity());\n     }\n \n     /// Moves the deque head by `x`.\n@@ -5890,4 +5892,21 @@ mod tests {\n             assert_eq!(v.as_ptr() as usize, mem::align_of::<Foo>());\n         }\n     }\n+\n+    #[test]\n+    fn issue_57() {\n+        const C: [i16; 3] = [42; 3];\n+\n+        let mut deque = SliceDeque::new();\n+\n+        for _ in 0..918 {\n+            deque.push_front(C);\n+        }\n+\n+        for _ in 0..237 {\n+            assert_eq!(deque.pop_front(), Some(C));\n+            assert!(!deque.is_empty());\n+            assert_eq!(*deque.back().unwrap(), C);\n+        }\n+    }\n }\n",
    "diff_parsed": "{'added': [(751, '        } else if new_head as usize >= cap {'), (769, '        debug_assert!(self.head() != self.capacity());'), (5896, '    #[test]'), (5897, '    fn issue_57() {'), (5898, '        const C: [i16; 3] = [42; 3];'), (5900, '        let mut deque = SliceDeque::new();'), (5902, '        for _ in 0..918 {'), (5903, '            deque.push_front(C);'), (5904, '        }'), (5906, '        for _ in 0..237 {'), (5907, '            assert_eq!(deque.pop_front(), Some(C));'), (5908, '            assert!(!deque.is_empty());'), (5909, '            assert_eq!(*deque.back().unwrap(), C);'), (5910, '        }'), (5911, '    }')], 'deleted': [(751, '        } else if new_head as usize > cap {')]}",
    "num_lines_added": "15",
    "num_lines_deleted": "1",
    "nloc": "4031"
  },
  {
    "file_change_id": "81780559006586",
    "hash": "11f396ca9accf6ae000db13a44505b57608733c",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -27,7 +27,7 @@ pub struct LateStatic<T> {\n }\n \n unsafe impl<T: Send> core::marker::Send for LateStatic<T> {}\n-unsafe impl<T: Send> core::marker::Sync for LateStatic<T> {}\n+unsafe impl<T: Sync> core::marker::Sync for LateStatic<T> {}\n \n impl<T> LateStatic<T> {\n     /// Construct a LateStatic.\n",
    "diff_parsed": "{'added': [(30, 'unsafe impl<T: Sync> core::marker::Sync for LateStatic<T> {}')], 'deleted': [(30, 'unsafe impl<T: Send> core::marker::Sync for LateStatic<T> {}')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "126"
  },
  {
    "file_change_id": "230337906850694",
    "hash": "26b249075930b46cfafc70b1d18fd0cb35fd231",
    "old_path": "lib.rs",
    "new_path": "lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -771,24 +771,33 @@ impl<A: Array> SmallVec<A> {\n         unsafe {\n             let old_len = self.len();\n             assert!(index <= old_len);\n-            let ptr = self.as_mut_ptr().offset(index as isize);\n+            let mut ptr = self.as_mut_ptr().offset(index as isize);\n+\n+            // Move the trailing elements.\n             ptr::copy(ptr, ptr.offset(lower_size_bound as isize), old_len - index);\n-            for (off, element) in iter.enumerate() {\n-                if off < lower_size_bound {\n-                    ptr::write(ptr.offset(off as isize), element);\n-                    let len = self.len() + 1;\n-                    self.set_len(len);\n-                } else {\n-                    // Iterator provided more elements than the hint.\n-                    assert!(index + off >= index);  // Protect against overflow.\n-                    self.insert(index + off, element);\n+\n+            // In case the iterator panics, don't double-drop the items we just copied above.\n+            self.set_len(index);\n+\n+            let mut num_added = 0;\n+            for element in iter {\n+                let mut cur = ptr.offset(num_added as isize);\n+                if num_added >= lower_size_bound {\n+                    // Iterator provided more elements than the hint.  Move trailing items again.\n+                    self.reserve(1);\n+                    ptr = self.as_mut_ptr().offset(index as isize);\n+                    cur = ptr.offset(num_added as isize);\n+                    ptr::copy(cur, cur.offset(1), old_len - index);\n                 }\n+                ptr::write(cur, element);\n+                num_added += 1;\n             }\n-            let num_added = self.len() - old_len;\n             if num_added < lower_size_bound {\n                 // Iterator provided fewer elements than the hint\n                 ptr::copy(ptr.offset(lower_size_bound as isize), ptr.offset(num_added as isize), old_len - index);\n             }\n+\n+            self.set_len(old_len + num_added);\n         }\n     }\n \n@@ -1645,6 +1654,37 @@ mod tests {\n         assert_eq!(&v.iter().map(|v| *v).collect::<Vec<_>>(), &[0, 5, 6, 1, 2, 3]);\n     }\n \n+    #[test]\n+    // https://github.com/servo/rust-smallvec/issues/96\n+    fn test_insert_many_panic() {\n+        struct PanicOnDoubleDrop {\n+            dropped: Box<bool>\n+        }\n+\n+        impl Drop for PanicOnDoubleDrop {\n+            fn drop(&mut self) {\n+                assert!(!*self.dropped, \"already dropped\");\n+                *self.dropped = true;\n+            }\n+        }\n+\n+        struct BadIter;\n+        impl Iterator for BadIter {\n+            type Item = PanicOnDoubleDrop;\n+            fn size_hint(&self) -> (usize, Option<usize>) { (1, None) }\n+            fn next(&mut self) -> Option<Self::Item> { panic!() }\n+        }\n+\n+        let mut vec: SmallVec<[PanicOnDoubleDrop; 0]> = vec![\n+            PanicOnDoubleDrop { dropped: Box::new(false) },\n+            PanicOnDoubleDrop { dropped: Box::new(false) },\n+        ].into();\n+        let result = ::std::panic::catch_unwind(move || {\n+            vec.insert_many(0, BadIter);\n+        });\n+        assert!(result.is_err());\n+    }\n+\n     #[test]\n     #[should_panic]\n     fn test_invalid_grow() {\n",
    "diff_parsed": "{'added': [(774, '            let mut ptr = self.as_mut_ptr().offset(index as isize);'), (780, '            self.set_len(index);'), (782, '            let mut num_added = 0;'), (783, '            for element in iter {'), (784, '                let mut cur = ptr.offset(num_added as isize);'), (785, '                if num_added >= lower_size_bound {'), (787, '                    self.reserve(1);'), (788, '                    ptr = self.as_mut_ptr().offset(index as isize);'), (789, '                    cur = ptr.offset(num_added as isize);'), (790, '                    ptr::copy(cur, cur.offset(1), old_len - index);'), (792, '                ptr::write(cur, element);'), (793, '                num_added += 1;'), (800, '            self.set_len(old_len + num_added);'), (1657, '    #[test]'), (1659, '    fn test_insert_many_panic() {'), (1660, '        struct PanicOnDoubleDrop {'), (1661, '            dropped: Box<bool>'), (1662, '        }'), (1664, '        impl Drop for PanicOnDoubleDrop {'), (1665, '            fn drop(&mut self) {'), (1666, '                assert!(!*self.dropped, \"already dropped\");'), (1667, '                *self.dropped = true;'), (1668, '            }'), (1669, '        }'), (1671, '        struct BadIter;'), (1672, '        impl Iterator for BadIter {'), (1673, '            type Item = PanicOnDoubleDrop;'), (1674, '            fn size_hint(&self) -> (usize, Option<usize>) { (1, None) }'), (1675, '            fn next(&mut self) -> Option<Self::Item> { panic!() }'), (1676, '        }'), (1678, '        let mut vec: SmallVec<[PanicOnDoubleDrop; 0]> = vec!['), (1679, '            PanicOnDoubleDrop { dropped: Box::new(false) },'), (1680, '            PanicOnDoubleDrop { dropped: Box::new(false) },'), (1681, '        ].into();'), (1682, '        let result = ::std::panic::catch_unwind(move || {'), (1683, '            vec.insert_many(0, BadIter);'), (1684, '        });'), (1685, '        assert!(result.is_err());'), (1686, '    }')], 'deleted': [(774, '            let ptr = self.as_mut_ptr().offset(index as isize);'), (776, '            for (off, element) in iter.enumerate() {'), (777, '                if off < lower_size_bound {'), (778, '                    ptr::write(ptr.offset(off as isize), element);'), (779, '                    let len = self.len() + 1;'), (780, '                    self.set_len(len);'), (781, '                } else {'), (783, '                    assert!(index + off >= index);  // Protect against overflow.'), (784, '                    self.insert(index + off, element);'), (787, '            let num_added = self.len() - old_len;')]}",
    "num_lines_added": "39",
    "num_lines_deleted": "10",
    "nloc": "1552"
  },
  {
    "file_change_id": "117329840245103",
    "hash": "1f4025218c4321ea42ad01d80dd6110def2d86d",
    "old_path": "lib.rs",
    "new_path": "lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -946,19 +946,17 @@ impl<A: Array> SmallVec<A> where A::Item: Clone {\n         if n > A::size() {\n             vec![elem; n].into()\n         } else {\n+            let mut v = SmallVec::<A>::new();\n             unsafe {\n-                let mut arr: A = ::std::mem::uninitialized();\n-                let ptr = arr.ptr_mut();\n+                let (ptr, len_ptr, _) = v.triple_mut();\n+                let mut local_len = SetLenOnDrop::new(len_ptr);\n \n                 for i in 0..n as isize {\n                     ::std::ptr::write(ptr.offset(i), elem.clone());\n-                }\n-\n-                SmallVec {\n-                    capacity: n,\n-                    data: SmallVecData::from_inline(arr),\n+                    local_len.increment_len(1);\n                 }\n             }\n+            v\n         }\n     }\n }\n@@ -1346,6 +1344,33 @@ pub unsafe trait Array {\n     fn ptr_mut(&mut self) -> *mut Self::Item;\n }\n \n+/// Set the length of the vec when the `SetLenOnDrop` value goes out of scope.\n+///\n+/// Copied from https://github.com/rust-lang/rust/pull/36355\n+struct SetLenOnDrop<'a> {\n+    len: &'a mut usize,\n+    local_len: usize,\n+}\n+\n+impl<'a> SetLenOnDrop<'a> {\n+    #[inline]\n+    fn new(len: &'a mut usize) -> Self {\n+        SetLenOnDrop { local_len: *len, len: len }\n+    }\n+\n+    #[inline]\n+    fn increment_len(&mut self, increment: usize) {\n+        self.local_len += increment;\n+    }\n+}\n+\n+impl<'a> Drop for SetLenOnDrop<'a> {\n+    #[inline]\n+    fn drop(&mut self) {\n+        *self.len = self.local_len;\n+    }\n+}\n+\n macro_rules! impl_array(\n     ($($size:expr),+) => {\n         $(\n",
    "diff_parsed": "{'added': [(949, '            let mut v = SmallVec::<A>::new();'), (951, '                let (ptr, len_ptr, _) = v.triple_mut();'), (952, '                let mut local_len = SetLenOnDrop::new(len_ptr);'), (956, '                    local_len.increment_len(1);'), (959, '            v'), (1350, \"struct SetLenOnDrop<'a> {\"), (1351, \"    len: &'a mut usize,\"), (1352, '    local_len: usize,'), (1353, '}'), (1355, \"impl<'a> SetLenOnDrop<'a> {\"), (1356, '    #[inline]'), (1357, \"    fn new(len: &'a mut usize) -> Self {\"), (1358, '        SetLenOnDrop { local_len: *len, len: len }'), (1359, '    }'), (1361, '    #[inline]'), (1362, '    fn increment_len(&mut self, increment: usize) {'), (1363, '        self.local_len += increment;'), (1364, '    }'), (1365, '}'), (1367, \"impl<'a> Drop for SetLenOnDrop<'a> {\"), (1368, '    #[inline]'), (1369, '    fn drop(&mut self) {'), (1370, '        *self.len = self.local_len;'), (1371, '    }'), (1372, '}')], 'deleted': [(950, '                let mut arr: A = ::std::mem::uninitialized();'), (951, '                let ptr = arr.ptr_mut();'), (955, '                }'), (957, '                SmallVec {'), (958, '                    capacity: n,'), (959, '                    data: SmallVecData::from_inline(arr),')]}",
    "num_lines_added": "25",
    "num_lines_deleted": "6",
    "nloc": "1605"
  },
  {
    "file_change_id": "150797209808453",
    "hash": "b1f4e6d166b6c5cc693bfbfe5856db4b098dbd8",
    "old_path": "src/tcell.rs",
    "new_path": "src/tcell.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -5,6 +5,10 @@ use std::collections::HashSet;\n use std::marker::PhantomData;\n use std::sync::{Condvar, Mutex};\n \n+// needs an abstraction as a struct, otherwise we'll get spurious error\n+// regarding \"function pointers cannot appear in constant functions\"\n+struct Invariant<Q>(fn(Q) -> Q);\n+\n static SINGLETON_CHECK: Lazy<Mutex<HashSet<TypeId>>> = Lazy::new(|| Mutex::new(HashSet::new()));\n static SINGLETON_CHECK_CONDVAR: Lazy<Condvar> = Lazy::new(Condvar::new);\n \n@@ -13,8 +17,8 @@ static SINGLETON_CHECK_CONDVAR: Lazy<Condvar> = Lazy::new(Condvar::new);\n ///\n /// See [crate documentation](index.html).\n pub struct TCellOwner<Q: 'static> {\n-    // Allow Send and Sync\n-    typ: PhantomData<Q>,\n+    // Allow Send and Sync, and Q is invariant\n+    typ: PhantomData<Invariant<Q>>,\n }\n \n impl<Q: 'static> Drop for TCellOwner<Q> {\n@@ -174,9 +178,11 @@ impl<Q: 'static> TCellOwner<Q> {\n ///\n /// [`TCellOwner`]: struct.TCellOwner.html\n pub struct TCell<Q, T: ?Sized> {\n-    // Use *const to disable Send and Sync, which are then re-enabled\n-    // below under certain conditions\n-    owner: PhantomData<*const Q>,\n+    // Use *const () to disable Send and Sync, which are then re-enabled\n+    // below under certain conditions,\n+    // use Invariant<Q> for invariant parameter, not influencing\n+    // other auto-traits like UnwindSafe\n+    owner: PhantomData<(*const (), Invariant<Q>)>,\n     value: UnsafeCell<T>,\n }\n \n",
    "diff_parsed": "{'added': [(10, 'struct Invariant<Q>(fn(Q) -> Q);'), (21, '    typ: PhantomData<Invariant<Q>>,'), (185, '    owner: PhantomData<(*const (), Invariant<Q>)>,')], 'deleted': [(17, '    typ: PhantomData<Q>,'), (179, '    owner: PhantomData<*const Q>,')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "2",
    "nloc": "297"
  },
  {
    "file_change_id": "151976839150021",
    "hash": "b1f4e6d166b6c5cc693bfbfe5856db4b098dbd8",
    "old_path": "src/tlcell.rs",
    "new_path": "src/tlcell.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -3,6 +3,10 @@ use std::cell::UnsafeCell;\n use std::collections::HashSet;\n use std::marker::PhantomData;\n \n+// needs an abstraction as a struct, otherwise we'll get spurious error\n+// regarding \"function pointers cannot appear in constant functions\"\n+struct Invariant<Q>(fn(Q) -> Q);\n+\n std::thread_local! {\n     static SINGLETON_CHECK: std::cell::RefCell<HashSet<TypeId>> = std::cell::RefCell::new(HashSet::new());\n }\n@@ -12,8 +16,10 @@ std::thread_local! {\n ///\n /// See [crate documentation](index.html).\n pub struct TLCellOwner<Q: 'static> {\n-    // Use *const to disable Send and Sync\n-    typ: PhantomData<*const Q>,\n+    // Use *const () to disable Send and Sync,\n+    // use Invariant<Q> for invariant parameter, not influencing\n+    // other auto-traits like UnwindSafe\n+    typ: PhantomData<(*const (), Invariant<Q>)>,\n }\n \n impl<Q: 'static> Drop for TLCellOwner<Q> {\n@@ -123,8 +129,10 @@ impl<Q: 'static> TLCellOwner<Q> {\n ///\n /// [`TLCellOwner`]: struct.TLCellOwner.html\n pub struct TLCell<Q, T: ?Sized> {\n-    // Use *const to disable Send and Sync\n-    owner: PhantomData<*const Q>,\n+    // Use *const () to disable Send and Sync,\n+    // use Invariant<Q> for invariant parameter, not influencing\n+    // other auto-traits like UnwindSafe\n+    owner: PhantomData<(*const (), Invariant<Q>)>,\n     value: UnsafeCell<T>,\n }\n \n",
    "diff_parsed": "{'added': [(8, 'struct Invariant<Q>(fn(Q) -> Q);'), (22, '    typ: PhantomData<(*const (), Invariant<Q>)>,'), (135, '    owner: PhantomData<(*const (), Invariant<Q>)>,')], 'deleted': [(16, '    typ: PhantomData<*const Q>,'), (127, '    owner: PhantomData<*const Q>,')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "2",
    "nloc": "212"
  },
  {
    "file_change_id": "232116381998380",
    "hash": "b03b1588858f0a47ab5909bfa6b4e1b395292b16",
    "old_path": "src/lcell.rs",
    "new_path": "src/lcell.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,7 +1,8 @@\n use std::cell::{Cell, UnsafeCell};\n use std::marker::PhantomData;\n+struct Invariant<Q>(fn(Q) -> Q);\n \n-type Id<'id> = PhantomData<Cell<&'id mut ()>>;\n+type Id<'id> = PhantomData<Invariant<&'id ()>>;\n \n /// Borrowing-owner of zero or more [`LCell`](struct.LCell.html)\n /// instances.\n@@ -169,7 +170,7 @@ impl<'id, T: ?Sized> LCell<'id, T> {\n     }\n }\n \n-// LCellOwner and LCell already automatically implement Send, but not\n+// LCell already automatically implements Send, but not\n // Sync. We can add these implementations though, since it's fine to\n // send a &LCell to another thread, and even mutably borrow the value\n // there, as long as T is Send and Sync.\n@@ -185,7 +186,6 @@ impl<'id, T: ?Sized> LCell<'id, T> {\n // as those of std::sync::RwLock<T>. That's not a coincidence.\n // The way these types let you access T concurrently is the same,\n // even though the locking mechanisms are different.\n-unsafe impl<'id> Sync for LCellOwner<'id> {}\n unsafe impl<'id, T: Send + Sync + ?Sized> Sync for LCell<'id, T> {}\n \n #[cfg(test)]\n",
    "diff_parsed": "{'added': [(3, 'struct Invariant<Q>(fn(Q) -> Q);'), (5, \"type Id<'id> = PhantomData<Invariant<&'id ()>>;\")], 'deleted': [(4, \"type Id<'id> = PhantomData<Cell<&'id mut ()>>;\"), (188, \"unsafe impl<'id> Sync for LCellOwner<'id> {}\")]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "220"
  },
  {
    "file_change_id": "41471655148990",
    "hash": "392a889f02c17edf0df4a9c08c134896b045387",
    "old_path": "futures-util/src/lock/mutex.rs",
    "new_path": "futures-util/src/lock/mutex.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -3,15 +3,16 @@ use futures_core::task::{Context, Poll, Waker};\n use slab::Slab;\n use std::{fmt, mem};\n use std::cell::UnsafeCell;\n+use std::marker::PhantomData;\n use std::ops::{Deref, DerefMut};\n use std::pin::Pin;\n use std::sync::Mutex as StdMutex;\n use std::sync::atomic::{AtomicUsize, Ordering};\n \n /// A futures-aware mutex.\n-/// \n+///\n /// # Fairness\n-/// \n+///\n /// This mutex provides no fairness guarantees. Tasks may not acquire the mutex\n /// in the order that they requested the lock, and it's possible for a single task\n /// which repeatedly takes the lock to starve other tasks, which may be left waiting\n@@ -288,7 +289,7 @@ impl<'a, T: ?Sized> MutexGuard<'a, T> {\n         // Don't run the `drop` method for MutexGuard. The ownership of the underlying\n         // locked state is being moved to the returned MappedMutexGuard.\n         mem::forget(this);\n-        MappedMutexGuard { mutex, value }\n+        MappedMutexGuard { mutex, value, _marker: PhantomData }\n     }\n }\n \n@@ -325,6 +326,7 @@ impl<T: ?Sized> DerefMut for MutexGuard<'_, T> {\n pub struct MappedMutexGuard<'a, T: ?Sized, U: ?Sized> {\n     mutex: &'a Mutex<T>,\n     value: *mut U,\n+    _marker: PhantomData<&'a mut U>,\n }\n \n impl<'a, T: ?Sized, U: ?Sized> MappedMutexGuard<'a, T, U> {\n@@ -354,7 +356,7 @@ impl<'a, T: ?Sized, U: ?Sized> MappedMutexGuard<'a, T, U> {\n         // Don't run the `drop` method for MappedMutexGuard. The ownership of the underlying\n         // locked state is being moved to the returned MappedMutexGuard.\n         mem::forget(this);\n-        MappedMutexGuard { mutex, value }\n+        MappedMutexGuard { mutex, value, _marker: PhantomData }\n     }\n }\n \n@@ -401,8 +403,8 @@ unsafe impl<T: ?Sized> Sync for MutexLockFuture<'_, T> {}\n // lock is essentially spinlock-equivalent (attempt to flip an atomic bool)\n unsafe impl<T: ?Sized + Send> Send for MutexGuard<'_, T> {}\n unsafe impl<T: ?Sized + Sync> Sync for MutexGuard<'_, T> {}\n-unsafe impl<T: ?Sized + Send, U: ?Sized> Send for MappedMutexGuard<'_, T, U> {}\n-unsafe impl<T: ?Sized + Sync, U: ?Sized> Sync for MappedMutexGuard<'_, T, U> {}\n+unsafe impl<T: ?Sized + Send, U: ?Sized + Send> Send for MappedMutexGuard<'_, T, U> {}\n+unsafe impl<T: ?Sized + Sync, U: ?Sized + Sync> Sync for MappedMutexGuard<'_, T, U> {}\n \n #[test]\n fn test_mutex_guard_debug_not_recurse() {\n",
    "diff_parsed": "{'added': [(6, 'use std::marker::PhantomData;'), (292, '        MappedMutexGuard { mutex, value, _marker: PhantomData }'), (329, \"    _marker: PhantomData<&'a mut U>,\"), (359, '        MappedMutexGuard { mutex, value, _marker: PhantomData }'), (406, \"unsafe impl<T: ?Sized + Send, U: ?Sized + Send> Send for MappedMutexGuard<'_, T, U> {}\"), (407, \"unsafe impl<T: ?Sized + Sync, U: ?Sized + Sync> Sync for MappedMutexGuard<'_, T, U> {}\")], 'deleted': [(291, '        MappedMutexGuard { mutex, value }'), (357, '        MappedMutexGuard { mutex, value }'), (404, \"unsafe impl<T: ?Sized + Send, U: ?Sized> Send for MappedMutexGuard<'_, T, U> {}\"), (405, \"unsafe impl<T: ?Sized + Sync, U: ?Sized> Sync for MappedMutexGuard<'_, T, U> {}\")]}",
    "num_lines_added": "6",
    "num_lines_deleted": "4",
    "nloc": "335"
  },
  {
    "file_change_id": "184625902898882",
    "hash": "0e6006de464caa331643f86cd2d9ba3b32b0983",
    "old_path": "src/de.rs",
    "new_path": "src/de.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -70,7 +70,7 @@ where\n     fn read_vec(&mut self) -> Result<Vec<u8>> {\n         let len: u32 = de::Deserialize::deserialize(&mut *self)?;\n         let mut buf = Vec::with_capacity(len as usize);\n-        unsafe { buf.set_len(len as usize) }\n+        buf.resize(len as usize, 0);\n         self.read_size(u64::from(len))?;\n         self.reader.read_exact(&mut buf[..])?;\n         Ok(buf)\n",
    "diff_parsed": "{'added': [(73, '        buf.resize(len as usize, 0);')], 'deleted': [(73, '        unsafe { buf.set_len(len as usize) }')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "452"
  },
  {
    "file_change_id": "95514333302028",
    "hash": "aabf5562f8c6374ab30f615b28e0cff9b5c79e5",
    "old_path": "src/greedy.rs",
    "new_path": "src/greedy.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -15,6 +15,7 @@ use std::ops::RangeBounds;\n /// [`std::io::BufReader`]: https://doc.rust-lang.org/std/io/struct.BufReader.html\n /// [`new`]: ./struct.GreedyAccessReader.html#method.new\n /// [`with_capacity`]: ./struct.GreedyAccessReader.html#method.with_capacity\n+#[derive(Debug, Clone)]\n pub struct GreedyAccessReader<R> {\n     inner: R,\n     buf: Vec<u8>,\n@@ -197,26 +198,14 @@ where\n         }\n \n         let b = self.buf.len();\n-        let buf = unsafe {\n-            // safe because it's within the buffer's limits\n-            // and we won't be reading uninitialized memory\n-            std::slice::from_raw_parts_mut(\n-                self.buf.as_mut_ptr().add(b),\n-                self.buf.capacity() - b)\n-        };\n+        self.buf.resize(self.buf.capacity(), 0);\n+        let buf = &mut self.buf[b..];\n+        let o = self.inner.read(buf)?;\n \n-        match self.inner.read(buf) {\n-            Ok(o) => {\n-                unsafe {\n-                    // reset the size to include the written portion,\n-                    // safe because the extra data is initialized\n-                    self.buf.set_len(b + o);\n-                }\n+        // truncate to exclude non-written portion\n+        self.buf.truncate(b + o);\n \n-                Ok(&self.buf[self.consumed..])\n-            }\n-            Err(e) => Err(e),\n-        }\n+        Ok(&self.buf[self.consumed..])\n     }\n \n     fn consume(&mut self, amt: usize) {\n",
    "diff_parsed": "{'added': [(18, '#[derive(Debug, Clone)]'), (201, '        self.buf.resize(self.buf.capacity(), 0);'), (202, '        let buf = &mut self.buf[b..];'), (203, '        let o = self.inner.read(buf)?;'), (206, '        self.buf.truncate(b + o);'), (208, '        Ok(&self.buf[self.consumed..])')], 'deleted': [(200, '        let buf = unsafe {'), (203, '            std::slice::from_raw_parts_mut('), (204, '                self.buf.as_mut_ptr().add(b),'), (205, '                self.buf.capacity() - b)'), (206, '        };'), (208, '        match self.inner.read(buf) {'), (209, '            Ok(o) => {'), (210, '                unsafe {'), (213, '                    self.buf.set_len(b + o);'), (214, '                }'), (216, '                Ok(&self.buf[self.consumed..])'), (217, '            }'), (218, '            Err(e) => Err(e),'), (219, '        }')]}",
    "num_lines_added": "6",
    "num_lines_deleted": "14",
    "nloc": "214"
  },
  {
    "file_change_id": "132428447265748",
    "hash": "f6d9bc6e8f6ad7f0d949a444a1c1d91d6d837e6",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -126,7 +126,7 @@ impl<T, U> LazyTransform<T, U>\n \n unsafe impl<T, U> Sync for LazyTransform<T, U>\n     where T: Sync + Send,\n-          U: Sync\n+          U: Send + Sync\n {\n }\n \n",
    "diff_parsed": "{'added': [(129, '          U: Send + Sync')], 'deleted': [(129, '          U: Sync')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "184"
  },
  {
    "file_change_id": "270864324623609",
    "hash": "50a50ed90d6ad78d812a40680257d8338843869",
    "old_path": "lib.rs",
    "new_path": "lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -654,6 +654,7 @@ impl<A: Array> SmallVec<A> {\n                 }\n                 self.data = SmallVecData::from_inline(mem::uninitialized());\n                 ptr::copy_nonoverlapping(ptr, self.data.inline_mut().ptr_mut(), len);\n+                self.capacity = len;\n             } else if new_cap != cap {\n                 let mut vec = Vec::with_capacity(new_cap);\n                 let new_alloc = vec.as_mut_ptr();\n@@ -2311,4 +2312,21 @@ mod tests {\n         let decoded: SmallVec<[i32; 2]> = deserialize(&encoded).unwrap();\n         assert_eq!(small_vec, decoded);\n     }\n+\n+    #[test]\n+    fn grow_to_shrink() {\n+        let mut v: SmallVec<[u8; 2]> = SmallVec::new();\n+        v.push(1);\n+        v.push(2);\n+        v.push(3);\n+        assert!(v.spilled());\n+        v.clear();\n+        // Shrink to inline.\n+        v.grow(2);\n+        assert!(!v.spilled());\n+        assert_eq!(v.capacity(), 2);\n+        assert_eq!(v.len(), 0);\n+        v.push(4);\n+        assert_eq!(v[..], [4]);\n+    }\n }\n",
    "diff_parsed": "{'added': [(657, '                self.capacity = len;'), (2316, '    #[test]'), (2317, '    fn grow_to_shrink() {'), (2318, '        let mut v: SmallVec<[u8; 2]> = SmallVec::new();'), (2319, '        v.push(1);'), (2320, '        v.push(2);'), (2321, '        v.push(3);'), (2322, '        assert!(v.spilled());'), (2323, '        v.clear();'), (2325, '        v.grow(2);'), (2326, '        assert!(!v.spilled());'), (2327, '        assert_eq!(v.capacity(), 2);'), (2328, '        assert_eq!(v.len(), 0);'), (2329, '        v.push(4);'), (2330, '        assert_eq!(v[..], [4]);'), (2331, '    }')], 'deleted': []}",
    "num_lines_added": "16",
    "num_lines_deleted": "0",
    "nloc": "1692"
  },
  {
    "file_change_id": "147031710235886",
    "hash": "ea809ba4ae37c4b0de54158e05699f1907c9e83",
    "old_path": "ash/src/util.rs",
    "new_path": "ash/src/util.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -113,15 +113,12 @@ pub fn read_spv<R: io::Read + io::Seek>(x: &mut R) -> io::Result<Vec<u32>> {\n         return Err(io::Error::new(io::ErrorKind::InvalidData, \"input too long\"));\n     }\n     let words = (size / 4) as usize;\n-    let mut result = Vec::<u32>::with_capacity(words);\n+    // https://github.com/MaikKlein/ash/issues/354:\n+    // Zero-initialize the result to prevent read_exact from possibly\n+    // reading uninitialized memory.\n+    let mut result = vec![0u32; words];\n     x.seek(io::SeekFrom::Start(0))?;\n-    unsafe {\n-        x.read_exact(slice::from_raw_parts_mut(\n-            result.as_mut_ptr() as *mut u8,\n-            words * 4,\n-        ))?;\n-        result.set_len(words);\n-    }\n+    x.read_exact(unsafe { slice::from_raw_parts_mut(result.as_mut_ptr() as *mut u8, words * 4) })?;\n     const MAGIC_NUMBER: u32 = 0x0723_0203;\n     if !result.is_empty() && result[0] == MAGIC_NUMBER.swap_bytes() {\n         for word in &mut result {\n",
    "diff_parsed": "{'added': [(119, '    let mut result = vec![0u32; words];'), (121, '    x.read_exact(unsafe { slice::from_raw_parts_mut(result.as_mut_ptr() as *mut u8, words * 4) })?;')], 'deleted': [(116, '    let mut result = Vec::<u32>::with_capacity(words);'), (118, '    unsafe {'), (119, '        x.read_exact(slice::from_raw_parts_mut('), (120, '            result.as_mut_ptr() as *mut u8,'), (121, '            words * 4,'), (122, '        ))?;'), (123, '        result.set_len(words);'), (124, '    }')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "8",
    "nloc": "102"
  },
  {
    "file_change_id": "100421883517729",
    "hash": "ffa2e8d54e4701e4d1f11fcfa5e1497ed6d4c8d",
    "old_path": "src/hazardous/hash/blake2b.rs",
    "new_path": "src/hazardous/hash/blake2b.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -305,30 +305,26 @@ impl Blake2b {\n \t#[inline(always)]\n \t/// Reset to `init()` state.\n \tpub fn reset(&mut self, secret_key: Option<&SecretKey>) -> Result<(), UnknownCryptoError> {\n-\t\tif self.is_finalized {\n-\t\t\tif secret_key.is_some() && (!self.is_keyed) {\n-\t\t\t\treturn Err(UnknownCryptoError);\n-\t\t\t}\n+\t\tif secret_key.is_some() && (!self.is_keyed) {\n+\t\t\treturn Err(UnknownCryptoError);\n+\t\t}\n \n-\t\t\tif secret_key.is_none() && self.is_keyed {\n-\t\t\t\treturn Err(UnknownCryptoError);\n-\t\t\t}\n+\t\tif secret_key.is_none() && self.is_keyed {\n+\t\t\treturn Err(UnknownCryptoError);\n+\t\t}\n \n-\t\t\tself.internal_state.copy_from_slice(&self.init_state);\n-\t\t\tself.buffer = [0u8; BLAKE2B_BLOCKSIZE];\n-\t\t\tself.leftover = 0;\n-\t\t\tself.t = [0u64; 2];\n-\t\t\tself.f = [0u64; 2];\n-\t\t\tself.is_finalized = false;\n+\t\tself.internal_state.copy_from_slice(&self.init_state);\n+\t\tself.buffer = [0u8; BLAKE2B_BLOCKSIZE];\n+\t\tself.leftover = 0;\n+\t\tself.t = [0u64; 2];\n+\t\tself.f = [0u64; 2];\n+\t\tself.is_finalized = false;\n \n-\t\t\tif secret_key.is_some() && self.is_keyed {\n-\t\t\t\tself.update(secret_key.unwrap().unprotected_as_bytes())?;\n-\t\t\t}\n-\n-\t\t\tOk(())\n-\t\t} else {\n-\t\t\tOk(())\n+\t\tif secret_key.is_some() && self.is_keyed {\n+\t\t\tself.update(secret_key.unwrap().unprotected_as_bytes())?;\n \t\t}\n+\n+\t\tOk(())\n \t}\n \n \t#[must_use]\n@@ -596,3 +592,22 @@ fn err_on_keyed_switch_on_reset() {\n \tlet _ = state_second.finalize().unwrap();\n \tassert!(state_second.reset(Some(&secret_key)).is_err());\n }\n+\n+#[test]\n+fn reset_after_update_correct_resets() {\n+\tlet state_1 = init(None, 64).unwrap();\n+\n+\tlet mut state_2 = init(None, 64).unwrap();\n+\tstate_2.update(b\"Tests\").unwrap();\n+\tstate_2.reset(None).unwrap();\n+\n+\tassert_eq!(state_1.init_state, state_2.init_state);\n+\tassert_eq!(state_1.internal_state, state_2.internal_state);\n+\tassert_eq!(state_1.buffer[..], state_2.buffer[..]);\n+\tassert_eq!(state_1.leftover, state_2.leftover);\n+\tassert_eq!(state_1.t, state_2.t);\n+\tassert_eq!(state_1.f, state_2.f);\n+\tassert_eq!(state_1.is_finalized, state_2.is_finalized);\n+\tassert_eq!(state_1.is_keyed, state_2.is_keyed);\n+\tassert_eq!(state_1.size, state_2.size);\n+}\n",
    "diff_parsed": "{'added': [(308, '\\t\\tif secret_key.is_some() && (!self.is_keyed) {'), (309, '\\t\\t\\treturn Err(UnknownCryptoError);'), (310, '\\t\\t}'), (312, '\\t\\tif secret_key.is_none() && self.is_keyed {'), (313, '\\t\\t\\treturn Err(UnknownCryptoError);'), (314, '\\t\\t}'), (316, '\\t\\tself.internal_state.copy_from_slice(&self.init_state);'), (317, '\\t\\tself.buffer = [0u8; BLAKE2B_BLOCKSIZE];'), (318, '\\t\\tself.leftover = 0;'), (319, '\\t\\tself.t = [0u64; 2];'), (320, '\\t\\tself.f = [0u64; 2];'), (321, '\\t\\tself.is_finalized = false;'), (323, '\\t\\tif secret_key.is_some() && self.is_keyed {'), (324, '\\t\\t\\tself.update(secret_key.unwrap().unprotected_as_bytes())?;'), (327, '\\t\\tOk(())'), (596, '#[test]'), (597, 'fn reset_after_update_correct_resets() {'), (598, '\\tlet state_1 = init(None, 64).unwrap();'), (600, '\\tlet mut state_2 = init(None, 64).unwrap();'), (601, '\\tstate_2.update(b\"Tests\").unwrap();'), (602, '\\tstate_2.reset(None).unwrap();'), (604, '\\tassert_eq!(state_1.init_state, state_2.init_state);'), (605, '\\tassert_eq!(state_1.internal_state, state_2.internal_state);'), (606, '\\tassert_eq!(state_1.buffer[..], state_2.buffer[..]);'), (607, '\\tassert_eq!(state_1.leftover, state_2.leftover);'), (608, '\\tassert_eq!(state_1.t, state_2.t);'), (609, '\\tassert_eq!(state_1.f, state_2.f);'), (610, '\\tassert_eq!(state_1.is_finalized, state_2.is_finalized);'), (611, '\\tassert_eq!(state_1.is_keyed, state_2.is_keyed);'), (612, '\\tassert_eq!(state_1.size, state_2.size);'), (613, '}')], 'deleted': [(308, '\\t\\tif self.is_finalized {'), (309, '\\t\\t\\tif secret_key.is_some() && (!self.is_keyed) {'), (310, '\\t\\t\\t\\treturn Err(UnknownCryptoError);'), (311, '\\t\\t\\t}'), (313, '\\t\\t\\tif secret_key.is_none() && self.is_keyed {'), (314, '\\t\\t\\t\\treturn Err(UnknownCryptoError);'), (315, '\\t\\t\\t}'), (317, '\\t\\t\\tself.internal_state.copy_from_slice(&self.init_state);'), (318, '\\t\\t\\tself.buffer = [0u8; BLAKE2B_BLOCKSIZE];'), (319, '\\t\\t\\tself.leftover = 0;'), (320, '\\t\\t\\tself.t = [0u64; 2];'), (321, '\\t\\t\\tself.f = [0u64; 2];'), (322, '\\t\\t\\tself.is_finalized = false;'), (324, '\\t\\t\\tif secret_key.is_some() && self.is_keyed {'), (325, '\\t\\t\\t\\tself.update(secret_key.unwrap().unprotected_as_bytes())?;'), (326, '\\t\\t\\t}'), (328, '\\t\\t\\tOk(())'), (329, '\\t\\t} else {'), (330, '\\t\\t\\tOk(())')]}",
    "num_lines_added": "31",
    "num_lines_deleted": "19",
    "nloc": "431"
  },
  {
    "file_change_id": "76398646208250",
    "hash": "ffa2e8d54e4701e4d1f11fcfa5e1497ed6d4c8d",
    "old_path": "src/hazardous/mac/hmac.rs",
    "new_path": "src/hazardous/mac/hmac.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -147,11 +147,8 @@ impl Hmac {\n \n \t/// Reset to `init()` state.\n \tpub fn reset(&mut self) {\n-\t\tif self.is_finalized {\n-\t\t\tself.ipad_hasher.input(self.ipad.as_ref());\n-\t\t\tself.is_finalized = false;\n-\t\t} else {\n-\t\t}\n+\t\tself.ipad_hasher.input(self.ipad.as_ref());\n+\t\tself.is_finalized = false;\n \t}\n \n \t#[must_use]\n@@ -350,3 +347,17 @@ fn double_reset_ok() {\n \ttag.reset();\n \ttag.reset();\n }\n+\n+#[test]\n+fn reset_after_update_correct_resets() {\n+\tlet secret_key = SecretKey::from_slice(\"Jefe\".as_bytes());\n+\n+\tlet state_1 = init(&secret_key);\n+\n+\tlet mut state_2 = init(&secret_key);\n+\tstate_2.update(b\"Tests\").unwrap();\n+\tstate_2.reset();\n+\n+\tassert_eq!(state_1.ipad[..], state_2.ipad[..]);\n+\tassert_eq!(state_1.is_finalized, state_2.is_finalized);\n+}\n",
    "diff_parsed": "{'added': [(150, '\\t\\tself.ipad_hasher.input(self.ipad.as_ref());'), (151, '\\t\\tself.is_finalized = false;'), (351, '#[test]'), (352, 'fn reset_after_update_correct_resets() {'), (353, '\\tlet secret_key = SecretKey::from_slice(\"Jefe\".as_bytes());'), (355, '\\tlet state_1 = init(&secret_key);'), (357, '\\tlet mut state_2 = init(&secret_key);'), (358, '\\tstate_2.update(b\"Tests\").unwrap();'), (359, '\\tstate_2.reset();'), (361, '\\tassert_eq!(state_1.ipad[..], state_2.ipad[..]);'), (362, '\\tassert_eq!(state_1.is_finalized, state_2.is_finalized);'), (363, '}')], 'deleted': [(150, '\\t\\tif self.is_finalized {'), (151, '\\t\\t\\tself.ipad_hasher.input(self.ipad.as_ref());'), (152, '\\t\\t\\tself.is_finalized = false;'), (153, '\\t\\t} else {'), (154, '\\t\\t}')]}",
    "num_lines_added": "12",
    "num_lines_deleted": "5",
    "nloc": "222"
  },
  {
    "file_change_id": "142131695869421",
    "hash": "ffa2e8d54e4701e4d1f11fcfa5e1497ed6d4c8d",
    "old_path": "src/hazardous/mac/poly1305.rs",
    "new_path": "src/hazardous/mac/poly1305.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -294,12 +294,10 @@ impl Poly1305 {\n \t#[inline(always)]\n \t/// Reset to `init()` state.\n \tpub fn reset(&mut self) {\n-\t\tif self.is_finalized {\n-\t\t\tself.a = [0u32; 5];\n-\t\t\tself.leftover = 0;\n-\t\t\tself.is_finalized = false;\n-\t\t} else {\n-\t\t}\n+\t\tself.a = [0u32; 5];\n+\t\tself.leftover = 0;\n+\t\tself.is_finalized = false;\n+\t\tself.buffer = [0u8; POLY1305_BLOCKSIZE];\n \t}\n \n \t#[must_use]\n@@ -524,3 +522,21 @@ fn double_reset_ok() {\n \tpoly1305_state.reset();\n \tpoly1305_state.reset();\n }\n+\n+#[test]\n+fn reset_after_update_correct_resets() {\n+\tlet secret_key = OneTimeKey::from_slice(&[0u8; 32]).unwrap();\n+\n+\tlet state_1 = init(&secret_key);\n+\n+\tlet mut state_2 = init(&secret_key);\n+\tstate_2.update(b\"Tests\").unwrap();\n+\tstate_2.reset();\n+\n+\tassert_eq!(state_1.a, state_2.a);\n+\tassert_eq!(state_1.r, state_2.r);\n+\tassert_eq!(state_1.s, state_2.s);\n+\tassert_eq!(state_1.leftover, state_2.leftover);\n+\tassert_eq!(state_1.buffer[..], state_2.buffer[..]);\n+\tassert_eq!(state_1.is_finalized, state_2.is_finalized);\n+}\n",
    "diff_parsed": "{'added': [(297, '\\t\\tself.a = [0u32; 5];'), (298, '\\t\\tself.leftover = 0;'), (299, '\\t\\tself.is_finalized = false;'), (300, '\\t\\tself.buffer = [0u8; POLY1305_BLOCKSIZE];'), (526, '#[test]'), (527, 'fn reset_after_update_correct_resets() {'), (528, '\\tlet secret_key = OneTimeKey::from_slice(&[0u8; 32]).unwrap();'), (530, '\\tlet state_1 = init(&secret_key);'), (532, '\\tlet mut state_2 = init(&secret_key);'), (533, '\\tstate_2.update(b\"Tests\").unwrap();'), (534, '\\tstate_2.reset();'), (536, '\\tassert_eq!(state_1.a, state_2.a);'), (537, '\\tassert_eq!(state_1.r, state_2.r);'), (538, '\\tassert_eq!(state_1.s, state_2.s);'), (539, '\\tassert_eq!(state_1.leftover, state_2.leftover);'), (540, '\\tassert_eq!(state_1.buffer[..], state_2.buffer[..]);'), (541, '\\tassert_eq!(state_1.is_finalized, state_2.is_finalized);'), (542, '}')], 'deleted': [(297, '\\t\\tif self.is_finalized {'), (298, '\\t\\t\\tself.a = [0u32; 5];'), (299, '\\t\\t\\tself.leftover = 0;'), (300, '\\t\\t\\tself.is_finalized = false;'), (301, '\\t\\t} else {'), (302, '\\t\\t}')]}",
    "num_lines_added": "18",
    "num_lines_deleted": "6",
    "nloc": "378"
  },
  {
    "file_change_id": "242169981595844",
    "hash": "ffa2e8d54e4701e4d1f11fcfa5e1497ed6d4c8d",
    "old_path": "src/hazardous/xof/cshake.rs",
    "new_path": "src/hazardous/xof/cshake.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -121,11 +121,8 @@ impl CShake {\n \n \t/// Reset to `init()` state.\n \tpub fn reset(&mut self) {\n-\t\tif self.is_finalized {\n-\t\t\tself.hasher = self.setup_hasher.clone();\n-\t\t\tself.is_finalized = false;\n-\t\t} else {\n-\t\t}\n+\t\tself.hasher = self.setup_hasher.clone();\n+\t\tself.is_finalized = false;\n \t}\n \n \t#[must_use]\n@@ -480,4 +477,25 @@ mod test {\n \t\tcshake.reset();\n \t\tcshake.reset();\n \t}\n+\n+\t#[test]\n+\tfn reset_after_update_correct_resets() {\n+\t\tlet input = b\"\\x00\\x01\\x02\\x03\";\n+\t\tlet custom = b\"\";\n+\t\tlet name = b\"Email Signature\";\n+\t\tlet mut out = [0u8; 64];\n+\t\tlet mut out2 = [0u8; 64];\n+\n+\t\tlet mut cshake = init(custom, Some(name)).unwrap();\n+\t\tcshake.update(input).unwrap();\n+\t\tcshake.finalize(&mut out).unwrap();\n+\n+\t\tlet mut cshake2 = init(custom, Some(name)).unwrap();\n+\t\tcshake2.update(input).unwrap();\n+\t\tcshake2.reset();\n+\t\tcshake2.update(input).unwrap();\n+\t\tcshake2.finalize(&mut out2).unwrap();\n+\n+\t\tassert!(out[..] == out2[..]);\n+\t}\n }\n",
    "diff_parsed": "{'added': [(124, '\\t\\tself.hasher = self.setup_hasher.clone();'), (125, '\\t\\tself.is_finalized = false;'), (481, '\\t#[test]'), (482, '\\tfn reset_after_update_correct_resets() {'), (483, '\\t\\tlet input = b\"\\\\x00\\\\x01\\\\x02\\\\x03\";'), (484, '\\t\\tlet custom = b\"\";'), (485, '\\t\\tlet name = b\"Email Signature\";'), (486, '\\t\\tlet mut out = [0u8; 64];'), (487, '\\t\\tlet mut out2 = [0u8; 64];'), (489, '\\t\\tlet mut cshake = init(custom, Some(name)).unwrap();'), (490, '\\t\\tcshake.update(input).unwrap();'), (491, '\\t\\tcshake.finalize(&mut out).unwrap();'), (493, '\\t\\tlet mut cshake2 = init(custom, Some(name)).unwrap();'), (494, '\\t\\tcshake2.update(input).unwrap();'), (495, '\\t\\tcshake2.reset();'), (496, '\\t\\tcshake2.update(input).unwrap();'), (497, '\\t\\tcshake2.finalize(&mut out2).unwrap();'), (499, '\\t\\tassert!(out[..] == out2[..]);'), (500, '\\t}')], 'deleted': [(124, '\\t\\tif self.is_finalized {'), (125, '\\t\\t\\tself.hasher = self.setup_hasher.clone();'), (126, '\\t\\t\\tself.is_finalized = false;'), (127, '\\t\\t} else {'), (128, '\\t\\t}')]}",
    "num_lines_added": "19",
    "num_lines_deleted": "5",
    "nloc": "331"
  },
  {
    "file_change_id": "21532632557294",
    "hash": "9803f31fbd1717d482d848f041044d061fca6da",
    "old_path": "derive-com-impl/src/derive.rs",
    "new_path": "derive-com-impl/src/derive.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -122,6 +122,8 @@ impl<'a> ComImpl<'a> {\n                         return winapi::shared::winerror::E_POINTER;\n                     }\n                     if #( #is_equal_iid )||* {\n+                        let that = &*(this as *const Self);\n+                        that.#refcount.add_ref();\n                         *ppv = this as *mut winapi::ctypes::c_void;\n                         winapi::shared::winerror::S_OK\n                     } else {\n",
    "diff_parsed": "{'added': [(125, '                        let that = &*(this as *const Self);'), (126, '                        that.#refcount.add_ref();')], 'deleted': []}",
    "num_lines_added": "2",
    "num_lines_deleted": "0",
    "nloc": "338"
  },
  {
    "file_change_id": "3547616076700",
    "hash": "8559aee7c5485426e3d5f7cfb7368248b6ca437",
    "old_path": "rmpv/src/decode/value.rs",
    "new_path": "rmpv/src/decode/value.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,4 +1,4 @@\n-use std::io::Read;\n+use std::io::{self, Read};\n \n use rmp::Marker;\n use rmp::decode::{read_marker, read_data_u8, read_data_u16, read_data_u32, read_data_u64,\n@@ -9,7 +9,9 @@ use crate::{Utf8String, Value};\n use super::Error;\n \n fn read_array_data<R: Read>(rd: &mut R, mut len: usize) -> Result<Vec<Value>, Error> {\n-    let mut vec = Vec::with_capacity(len);\n+    // Note: Do not preallocate a Vec of size `len`.\n+    // See https://github.com/3Hren/msgpack-rust/issues/151\n+    let mut vec = Vec::new();\n \n     while len > 0 {\n         vec.push(read_value(rd)?);\n@@ -20,7 +22,9 @@ fn read_array_data<R: Read>(rd: &mut R, mut len: usize) -> Result<Vec<Value>, Er\n }\n \n fn read_map_data<R: Read>(rd: &mut R, mut len: usize) -> Result<Vec<(Value, Value)>, Error> {\n-    let mut vec = Vec::with_capacity(len);\n+    // Note: Do not preallocate a Vec of size `len`.\n+    // See https://github.com/3Hren/msgpack-rust/issues/151\n+    let mut vec = Vec::new();\n \n     while len > 0 {\n         vec.push((read_value(rd)?, read_value(rd)?));\n@@ -44,9 +48,16 @@ fn read_str_data<R: Read>(rd: &mut R, len: usize) -> Result<Utf8String, Error> {\n }\n \n fn read_bin_data<R: Read>(rd: &mut R, len: usize) -> Result<Vec<u8>, Error> {\n-    let mut buf = Vec::with_capacity(len);\n-    buf.resize(len as usize, 0u8);\n-    rd.read_exact(&mut buf[..]).map_err(Error::InvalidDataRead)?;\n+    // Note: Do not preallocate a Vec of size `len`.\n+    // See https://github.com/3Hren/msgpack-rust/issues/151\n+    let mut buf = Vec::new();\n+    let bytes_read = rd.take(len as u64).read_to_end(&mut buf).map_err(Error::InvalidDataRead)?;\n+    if bytes_read != len {\n+        return Err(Error::InvalidDataRead(io::Error::new(\n+            io::ErrorKind::UnexpectedEof,\n+            format!(\"Expected {} bytes, read {} bytes\", len, bytes_read),\n+        )));\n+    }\n \n     Ok(buf)\n }\n",
    "diff_parsed": "{'added': [(1, 'use std::io::{self, Read};'), (14, '    let mut vec = Vec::new();'), (27, '    let mut vec = Vec::new();'), (53, '    let mut buf = Vec::new();'), (54, '    let bytes_read = rd.take(len as u64).read_to_end(&mut buf).map_err(Error::InvalidDataRead)?;'), (55, '    if bytes_read != len {'), (56, '        return Err(Error::InvalidDataRead(io::Error::new('), (57, '            io::ErrorKind::UnexpectedEof,'), (58, '            format!(\"Expected {} bytes, read {} bytes\", len, bytes_read),'), (59, '        )));'), (60, '    }')], 'deleted': [(1, 'use std::io::Read;'), (12, '    let mut vec = Vec::with_capacity(len);'), (23, '    let mut vec = Vec::with_capacity(len);'), (47, '    let mut buf = Vec::with_capacity(len);'), (48, '    buf.resize(len as usize, 0u8);'), (49, '    rd.read_exact(&mut buf[..]).map_err(Error::InvalidDataRead)?;')]}",
    "num_lines_added": "11",
    "num_lines_deleted": "6",
    "nloc": "176"
  },
  {
    "file_change_id": "69670222683219",
    "hash": "8559aee7c5485426e3d5f7cfb7368248b6ca437",
    "old_path": "rmpv/src/decode/value_ref.rs",
    "new_path": "rmpv/src/decode/value_ref.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -53,7 +53,9 @@ fn read_ext_body<'a, R>(rd: &mut R, len: usize) -> Result<(i8, &'a [u8]), Error>\n fn read_array_data<'a, R>(rd: &mut R, mut len: usize) -> Result<Vec<ValueRef<'a>>, Error>\n     where R: BorrowRead<'a>\n {\n-    let mut vec = Vec::with_capacity(len);\n+    // Note: Do not preallocate a Vec of size `len`.\n+    // See https://github.com/3Hren/msgpack-rust/issues/151\n+    let mut vec = Vec::new();\n \n     while len > 0 {\n         vec.push(read_value_ref(rd)?);\n@@ -66,7 +68,9 @@ fn read_array_data<'a, R>(rd: &mut R, mut len: usize) -> Result<Vec<ValueRef<'a>\n fn read_map_data<'a, R>(rd: &mut R, mut len: usize) -> Result<Vec<(ValueRef<'a>, ValueRef<'a>)>, Error>\n     where R: BorrowRead<'a>\n {\n-    let mut vec = Vec::with_capacity(len);\n+    // Note: Do not preallocate a Vec of size `len`.\n+    // See https://github.com/3Hren/msgpack-rust/issues/151\n+    let mut vec = Vec::new();\n \n     while len > 0 {\n         vec.push((read_value_ref(rd)?, read_value_ref(rd)?));\n",
    "diff_parsed": "{'added': [(58, '    let mut vec = Vec::new();'), (73, '    let mut vec = Vec::new();')], 'deleted': [(56, '    let mut vec = Vec::with_capacity(len);'), (69, '    let mut vec = Vec::with_capacity(len);')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "220"
  },
  {
    "file_change_id": "260593491703603",
    "hash": "8559aee7c5485426e3d5f7cfb7368248b6ca437",
    "old_path": "rmpv/tests/decode.rs",
    "new_path": "rmpv/tests/decode.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -361,3 +361,39 @@ fn from_array_of_two_integers() {\n     let vec = vec![Value::from(4), Value::from(42)];\n     assert_eq!(Value::Array(vec), read_value(&mut &buf[..]).unwrap());\n }\n+\n+#[test]\n+fn invalid_buf_size_bin32() {\n+    // This invalid buffer requests a 4 GiB byte vec.\n+    let buf: &[u8] = &[0xc6, 0xff, 0xff, 0xff, 0xff, 0x00];\n+    match read_value(&mut &buf[..]) {\n+        Ok(_) => panic!(\"Unexpected success\"),\n+        Err(Error::InvalidDataRead(_)) => { /* expected */ },\n+        Err(e) => panic!(\"Unexpected error: {}\", e),\n+    }\n+}\n+\n+#[test]\n+fn invalid_buf_size_arr() {\n+    // This invalid buffer requests a nested array of depth 10.\n+    // All arrays contain the maximum possible number of elements.\n+    // If a byte is preallocated for every array content,\n+    // that would require 40 GiB of RAM.\n+    let buf: &[u8] = &[\n+        0xdd, 0xff, 0xff, 0xff, 0xff,\n+        0xdd, 0xff, 0xff, 0xff, 0xff,\n+        0xdd, 0xff, 0xff, 0xff, 0xff,\n+        0xdd, 0xff, 0xff, 0xff, 0xff,\n+        0xdd, 0xff, 0xff, 0xff, 0xff,\n+        0xdd, 0xff, 0xff, 0xff, 0xff,\n+        0xdd, 0xff, 0xff, 0xff, 0xff,\n+        0xdd, 0xff, 0xff, 0xff, 0xff,\n+        0xdd, 0xff, 0xff, 0xff, 0xff,\n+        0xdd, 0xff, 0xff, 0xff, 0xff,\n+    ];\n+    match read_value(&mut &buf[..]) {\n+        Ok(_) => panic!(\"Unexpected success\"),\n+        Err(Error::InvalidMarkerRead(_)) => { /* expected */ },\n+        Err(e) => panic!(\"Unexpected error: {}\", e),\n+    }\n+}\n",
    "diff_parsed": "{'added': [(365, '#[test]'), (366, 'fn invalid_buf_size_bin32() {'), (368, '    let buf: &[u8] = &[0xc6, 0xff, 0xff, 0xff, 0xff, 0x00];'), (369, '    match read_value(&mut &buf[..]) {'), (370, '        Ok(_) => panic!(\"Unexpected success\"),'), (371, '        Err(Error::InvalidDataRead(_)) => { /* expected */ },'), (372, '        Err(e) => panic!(\"Unexpected error: {}\", e),'), (373, '    }'), (374, '}'), (376, '#[test]'), (377, 'fn invalid_buf_size_arr() {'), (382, '    let buf: &[u8] = &['), (383, '        0xdd, 0xff, 0xff, 0xff, 0xff,'), (384, '        0xdd, 0xff, 0xff, 0xff, 0xff,'), (385, '        0xdd, 0xff, 0xff, 0xff, 0xff,'), (386, '        0xdd, 0xff, 0xff, 0xff, 0xff,'), (387, '        0xdd, 0xff, 0xff, 0xff, 0xff,'), (388, '        0xdd, 0xff, 0xff, 0xff, 0xff,'), (389, '        0xdd, 0xff, 0xff, 0xff, 0xff,'), (390, '        0xdd, 0xff, 0xff, 0xff, 0xff,'), (391, '        0xdd, 0xff, 0xff, 0xff, 0xff,'), (392, '        0xdd, 0xff, 0xff, 0xff, 0xff,'), (393, '    ];'), (394, '    match read_value(&mut &buf[..]) {'), (395, '        Ok(_) => panic!(\"Unexpected success\"),'), (396, '        Err(Error::InvalidMarkerRead(_)) => { /* expected */ },'), (397, '        Err(e) => panic!(\"Unexpected error: {}\", e),'), (398, '    }'), (399, '}')], 'deleted': []}",
    "num_lines_added": "29",
    "num_lines_deleted": "0",
    "nloc": "326"
  },
  {
    "file_change_id": "103819720097446",
    "hash": "cb068895ca2aa236ad8bc858c80b2209cbc4f04",
    "old_path": "src/context.rs",
    "new_path": "src/context.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -48,7 +48,7 @@ pub trait Hotplug<T: UsbContext> {\n \n pub type Registration = c_int;\n \n-pub trait UsbContext: Clone + Sized {\n+pub trait UsbContext: Clone + Sized + Send + Sync {\n     /// Get the raw libusb_context pointer, for advanced use in unsafe code.\n     fn as_raw(&self) -> *mut libusb_context;\n \n",
    "diff_parsed": "{'added': [(51, 'pub trait UsbContext: Clone + Sized + Send + Sync {')], 'deleted': [(51, 'pub trait UsbContext: Clone + Sized {')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "203"
  },
  {
    "file_change_id": "281166303291694",
    "hash": "c66cd3085742c50ae231c77f1bc5b577d0cceb9",
    "old_path": "rust/flatbuffers/src/primitives.rs",
    "new_path": "rust/flatbuffers/src/primitives.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -263,6 +263,14 @@ impl<'a, T: Follow<'a> + 'a> Follow<'a> for SkipFileIdentifier<T> {\n     }\n }\n \n+impl<'a> Follow<'a> for bool {\n+    type Inner = bool;\n+    #[inline(always)]\n+    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+        read_scalar_at::<u8>(buf, loc) != 0\n+    }\n+}\n+\n /// Follow trait impls for primitive types.\n ///\n /// Ideally, these would be implemented as a single impl using trait bounds on\n@@ -280,7 +288,6 @@ macro_rules! impl_follow_for_endian_scalar {\n     };\n }\n \n-impl_follow_for_endian_scalar!(bool);\n impl_follow_for_endian_scalar!(u8);\n impl_follow_for_endian_scalar!(u16);\n impl_follow_for_endian_scalar!(u32);\n",
    "diff_parsed": "{'added': [(266, \"impl<'a> Follow<'a> for bool {\"), (267, '    type Inner = bool;'), (268, '    #[inline(always)]'), (269, \"    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\"), (270, '        read_scalar_at::<u8>(buf, loc) != 0'), (271, '    }'), (272, '}')], 'deleted': [(283, 'impl_follow_for_endian_scalar!(bool);')]}",
    "num_lines_added": "7",
    "num_lines_deleted": "1",
    "nloc": "209"
  },
  {
    "file_change_id": "123469684018642",
    "hash": "b3356ccba102cffa2c63cb61be5b704a29c474b",
    "old_path": "futures-task/src/noop_waker.rs",
    "new_path": "futures-task/src/noop_waker.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -3,7 +3,7 @@\n use core::task::{RawWaker, RawWakerVTable, Waker};\n use core::ptr::null;\n #[cfg(feature = \"std\")]\n-use core::cell::UnsafeCell;\n+use once_cell::sync::Lazy;\n \n unsafe fn noop_clone(_data: *const ()) -> RawWaker {\n     noop_raw_waker()\n@@ -47,9 +47,16 @@ pub fn noop_waker() -> Waker {\n #[inline]\n #[cfg(feature = \"std\")]\n pub fn noop_waker_ref() -> &'static Waker {\n-    thread_local! {\n-        static NOOP_WAKER_INSTANCE: UnsafeCell<Waker> =\n-            UnsafeCell::new(noop_waker());\n+    static NOOP_WAKER_INSTANCE: Lazy<Waker> = Lazy::new(noop_waker);\n+    &*NOOP_WAKER_INSTANCE\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    #[test]\n+    #[cfg(feature = \"std\")]\n+    fn issue_2091_cross_thread_segfault() {\n+        let waker = std::thread::spawn(super::noop_waker_ref).join().unwrap();\n+        waker.wake_by_ref();\n     }\n-    NOOP_WAKER_INSTANCE.with(|l| unsafe { &*l.get() })\n }\n",
    "diff_parsed": "{'added': [(6, 'use once_cell::sync::Lazy;'), (50, '    static NOOP_WAKER_INSTANCE: Lazy<Waker> = Lazy::new(noop_waker);'), (51, '    &*NOOP_WAKER_INSTANCE'), (52, '}'), (54, '#[cfg(test)]'), (55, 'mod tests {'), (56, '    #[test]'), (57, '    #[cfg(feature = \"std\")]'), (58, '    fn issue_2091_cross_thread_segfault() {'), (59, '        let waker = std::thread::spawn(super::noop_waker_ref).join().unwrap();'), (60, '        waker.wake_by_ref();')], 'deleted': [(6, 'use core::cell::UnsafeCell;'), (50, '    thread_local! {'), (51, '        static NOOP_WAKER_INSTANCE: UnsafeCell<Waker> ='), (52, '            UnsafeCell::new(noop_waker());'), (54, '    NOOP_WAKER_INSTANCE.with(|l| unsafe { &*l.get() })')]}",
    "num_lines_added": "11",
    "num_lines_deleted": "5",
    "nloc": "33"
  },
  {
    "file_change_id": "19421258864687",
    "hash": "b3356ccba102cffa2c63cb61be5b704a29c474b",
    "old_path": "futures-test/src/task/panic_waker.rs",
    "new_path": "futures-test/src/task/panic_waker.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,6 +1,6 @@\n use futures_core::task::{Waker, RawWaker, RawWakerVTable};\n-use core::cell::UnsafeCell;\n use core::ptr::null;\n+use once_cell::sync::Lazy;\n \n unsafe fn clone_panic_waker(_data: *const ()) -> RawWaker {\n     raw_panic_waker()\n@@ -52,9 +52,16 @@ pub fn panic_waker() -> Waker {\n /// waker.wake_by_ref(); // Will panic\n /// ```\n pub fn panic_waker_ref() -> &'static Waker {\n-    thread_local! {\n-        static PANIC_WAKER_INSTANCE: UnsafeCell<Waker> =\n-            UnsafeCell::new(panic_waker());\n+    static PANIC_WAKER_INSTANCE: Lazy<Waker> = Lazy::new(panic_waker);\n+    &*PANIC_WAKER_INSTANCE\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    #[test]\n+    #[should_panic(expected = \"should not be woken\")]\n+    fn issue_2091_cross_thread_segfault() {\n+        let waker = std::thread::spawn(super::panic_waker_ref).join().unwrap();\n+        waker.wake_by_ref();\n     }\n-    PANIC_WAKER_INSTANCE.with(|l| unsafe { &*l.get() })\n }\n",
    "diff_parsed": "{'added': [(3, 'use once_cell::sync::Lazy;'), (55, '    static PANIC_WAKER_INSTANCE: Lazy<Waker> = Lazy::new(panic_waker);'), (56, '    &*PANIC_WAKER_INSTANCE'), (57, '}'), (59, '#[cfg(test)]'), (60, 'mod tests {'), (61, '    #[test]'), (62, '    #[should_panic(expected = \"should not be woken\")]'), (63, '    fn issue_2091_cross_thread_segfault() {'), (64, '        let waker = std::thread::spawn(super::panic_waker_ref).join().unwrap();'), (65, '        waker.wake_by_ref();')], 'deleted': [(2, 'use core::cell::UnsafeCell;'), (55, '    thread_local! {'), (56, '        static PANIC_WAKER_INSTANCE: UnsafeCell<Waker> ='), (57, '            UnsafeCell::new(panic_waker());'), (59, '    PANIC_WAKER_INSTANCE.with(|l| unsafe { &*l.get() })')]}",
    "num_lines_added": "11",
    "num_lines_deleted": "5",
    "nloc": "35"
  },
  {
    "file_change_id": "25658197123695",
    "hash": "3f733cd056098d5e8de6ae8da40950500edc881",
    "old_path": "actix-utils/src/cell.rs",
    "new_path": "None",
    "change_type": "ModificationType.DELETE",
    "diff": "@@ -1,48 +0,0 @@\n-//! Custom cell impl\n-\n-use std::cell::UnsafeCell;\n-use std::fmt;\n-use std::rc::Rc;\n-\n-pub(crate) struct Cell<T> {\n-    pub(crate) inner: Rc<UnsafeCell<T>>,\n-}\n-\n-impl<T> Clone for Cell<T> {\n-    fn clone(&self) -> Self {\n-        Self {\n-            inner: self.inner.clone(),\n-        }\n-    }\n-}\n-\n-impl<T: fmt::Debug> fmt::Debug for Cell<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.inner.fmt(f)\n-    }\n-}\n-\n-impl<T> Cell<T> {\n-    pub(crate) fn new(inner: T) -> Self {\n-        Self {\n-            inner: Rc::new(UnsafeCell::new(inner)),\n-        }\n-    }\n-\n-    pub(crate) fn strong_count(&self) -> usize {\n-        Rc::strong_count(&self.inner)\n-    }\n-\n-    pub(crate) fn get_ref(&self) -> &T {\n-        unsafe { &*self.inner.as_ref().get() }\n-    }\n-\n-    pub(crate) fn get_mut(&mut self) -> &mut T {\n-        unsafe { &mut *self.inner.as_ref().get() }\n-    }\n-\n-    #[allow(clippy::mut_from_ref)]\n-    pub(crate) unsafe fn get_mut_unsafe(&self) -> &mut T {\n-        &mut *self.inner.as_ref().get()\n-    }\n-}\n",
    "diff_parsed": "{'added': [], 'deleted': [(3, 'use std::cell::UnsafeCell;'), (4, 'use std::fmt;'), (5, 'use std::rc::Rc;'), (7, 'pub(crate) struct Cell<T> {'), (8, '    pub(crate) inner: Rc<UnsafeCell<T>>,'), (9, '}'), (11, 'impl<T> Clone for Cell<T> {'), (12, '    fn clone(&self) -> Self {'), (13, '        Self {'), (14, '            inner: self.inner.clone(),'), (15, '        }'), (16, '    }'), (17, '}'), (19, 'impl<T: fmt::Debug> fmt::Debug for Cell<T> {'), (20, \"    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\"), (21, '        self.inner.fmt(f)'), (22, '    }'), (23, '}'), (25, 'impl<T> Cell<T> {'), (26, '    pub(crate) fn new(inner: T) -> Self {'), (27, '        Self {'), (28, '            inner: Rc::new(UnsafeCell::new(inner)),'), (29, '        }'), (30, '    }'), (32, '    pub(crate) fn strong_count(&self) -> usize {'), (33, '        Rc::strong_count(&self.inner)'), (34, '    }'), (36, '    pub(crate) fn get_ref(&self) -> &T {'), (37, '        unsafe { &*self.inner.as_ref().get() }'), (38, '    }'), (40, '    pub(crate) fn get_mut(&mut self) -> &mut T {'), (41, '        unsafe { &mut *self.inner.as_ref().get() }'), (42, '    }'), (44, '    #[allow(clippy::mut_from_ref)]'), (45, '    pub(crate) unsafe fn get_mut_unsafe(&self) -> &mut T {'), (46, '        &mut *self.inner.as_ref().get()'), (47, '    }'), (48, '}')]}",
    "num_lines_added": "0",
    "num_lines_deleted": "38",
    "nloc": "nan"
  },
  {
    "file_change_id": "82816989580609",
    "hash": "3f733cd056098d5e8de6ae8da40950500edc881",
    "old_path": "actix-utils/src/condition.rs",
    "new_path": "actix-utils/src/condition.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,14 +1,15 @@\n+use std::cell::RefCell;\n use std::future::Future;\n use std::pin::Pin;\n+use std::rc::Rc;\n use std::task::{Context, Poll};\n \n use slab::Slab;\n \n-use crate::cell::Cell;\n use crate::task::LocalWaker;\n \n /// Condition allows to notify multiple receivers at the same time\n-pub struct Condition(Cell<Inner>);\n+pub struct Condition(Rc<RefCell<Inner>>);\n \n struct Inner {\n     data: Slab<Option<LocalWaker>>,\n@@ -22,12 +23,12 @@ impl Default for Condition {\n \n impl Condition {\n     pub fn new() -> Condition {\n-        Condition(Cell::new(Inner { data: Slab::new() }))\n+        Condition(Rc::new(RefCell::new(Inner { data: Slab::new() })))\n     }\n \n     /// Get condition waiter\n     pub fn wait(&mut self) -> Waiter {\n-        let token = self.0.get_mut().data.insert(None);\n+        let token = self.0.borrow_mut().data.insert(None);\n         Waiter {\n             token,\n             inner: self.0.clone(),\n@@ -36,7 +37,7 @@ impl Condition {\n \n     /// Notify all waiters\n     pub fn notify(&self) {\n-        let inner = self.0.get_ref();\n+        let inner = self.0.borrow();\n         for item in inner.data.iter() {\n             if let Some(waker) = item.1 {\n                 waker.wake();\n@@ -54,12 +55,12 @@ impl Drop for Condition {\n #[must_use = \"Waiter do nothing unless polled\"]\n pub struct Waiter {\n     token: usize,\n-    inner: Cell<Inner>,\n+    inner: Rc<RefCell<Inner>>,\n }\n \n impl Clone for Waiter {\n     fn clone(&self) -> Self {\n-        let token = unsafe { self.inner.get_mut_unsafe() }.data.insert(None);\n+        let token = self.inner.borrow_mut().data.insert(None);\n         Waiter {\n             token,\n             inner: self.inner.clone(),\n@@ -73,7 +74,8 @@ impl Future for Waiter {\n     fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n         let this = self.get_mut();\n \n-        let inner = unsafe { this.inner.get_mut().data.get_unchecked_mut(this.token) };\n+        let mut inner = this.inner.borrow_mut();\n+        let inner = unsafe { inner.data.get_unchecked_mut(this.token) };\n         if inner.is_none() {\n             let waker = LocalWaker::default();\n             waker.register(cx.waker());\n@@ -89,7 +91,7 @@ impl Future for Waiter {\n \n impl Drop for Waiter {\n     fn drop(&mut self) {\n-        self.inner.get_mut().data.remove(self.token);\n+        self.inner.borrow_mut().data.remove(self.token);\n     }\n }\n \n",
    "diff_parsed": "{'added': [(1, 'use std::cell::RefCell;'), (4, 'use std::rc::Rc;'), (12, 'pub struct Condition(Rc<RefCell<Inner>>);'), (26, '        Condition(Rc::new(RefCell::new(Inner { data: Slab::new() })))'), (31, '        let token = self.0.borrow_mut().data.insert(None);'), (40, '        let inner = self.0.borrow();'), (58, '    inner: Rc<RefCell<Inner>>,'), (63, '        let token = self.inner.borrow_mut().data.insert(None);'), (77, '        let mut inner = this.inner.borrow_mut();'), (78, '        let inner = unsafe { inner.data.get_unchecked_mut(this.token) };'), (94, '        self.inner.borrow_mut().data.remove(self.token);')], 'deleted': [(7, 'use crate::cell::Cell;'), (11, 'pub struct Condition(Cell<Inner>);'), (25, '        Condition(Cell::new(Inner { data: Slab::new() }))'), (30, '        let token = self.0.get_mut().data.insert(None);'), (39, '        let inner = self.0.get_ref();'), (57, '    inner: Cell<Inner>,'), (62, '        let token = unsafe { self.inner.get_mut_unsafe() }.data.insert(None);'), (76, '        let inner = unsafe { this.inner.get_mut().data.get_unchecked_mut(this.token) };'), (92, '        self.inner.get_mut().data.remove(self.token);')]}",
    "num_lines_added": "11",
    "num_lines_deleted": "9",
    "nloc": "107.0"
  },
  {
    "file_change_id": "240852829069438",
    "hash": "3f733cd056098d5e8de6ae8da40950500edc881",
    "old_path": "actix-utils/src/either.rs",
    "new_path": "actix-utils/src/either.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -3,7 +3,7 @@ use std::pin::Pin;\n use std::task::{Context, Poll};\n \n use actix_service::{Service, ServiceFactory};\n-use futures_util::{future, ready, future::Future};\n+use futures_util::{future, future::Future, ready};\n \n /// Combine two different service types into a single type.\n ///\n",
    "diff_parsed": "{'added': [(6, 'use futures_util::{future, future::Future, ready};')], 'deleted': [(6, 'use futures_util::{future, ready, future::Future};')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "140.0"
  },
  {
    "file_change_id": "203009971115515",
    "hash": "3f733cd056098d5e8de6ae8da40950500edc881",
    "old_path": "actix-utils/src/lib.rs",
    "new_path": "actix-utils/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -2,7 +2,6 @@\n #![deny(rust_2018_idioms)]\n #![allow(clippy::type_complexity)]\n \n-mod cell;\n pub mod condition;\n pub mod counter;\n pub mod either;\n",
    "diff_parsed": "{'added': [], 'deleted': [(5, 'mod cell;')]}",
    "num_lines_added": "0",
    "num_lines_deleted": "1",
    "nloc": "15.0"
  },
  {
    "file_change_id": "125579946703427",
    "hash": "3f733cd056098d5e8de6ae8da40950500edc881",
    "old_path": "actix-utils/src/mpsc.rs",
    "new_path": "actix-utils/src/mpsc.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,24 +1,25 @@\n //! A multi-producer, single-consumer, futures-aware, FIFO queue.\n use std::any::Any;\n+use std::cell::RefCell;\n use std::collections::VecDeque;\n use std::error::Error;\n use std::fmt;\n use std::pin::Pin;\n+use std::rc::Rc;\n use std::task::{Context, Poll};\n \n use futures_sink::Sink;\n use futures_util::stream::Stream;\n \n-use crate::cell::Cell;\n use crate::task::LocalWaker;\n \n /// Creates a unbounded in-memory channel with buffered storage.\n pub fn channel<T>() -> (Sender<T>, Receiver<T>) {\n-    let shared = Cell::new(Shared {\n+    let shared = Rc::new(RefCell::new(Shared {\n         has_receiver: true,\n         buffer: VecDeque::new(),\n         blocked_recv: LocalWaker::new(),\n-    });\n+    }));\n     let sender = Sender {\n         shared: shared.clone(),\n     };\n@@ -38,7 +39,7 @@ struct Shared<T> {\n /// This is created by the `channel` function.\n #[derive(Debug)]\n pub struct Sender<T> {\n-    shared: Cell<Shared<T>>,\n+    shared: Rc<RefCell<Shared<T>>>,\n }\n \n impl<T> Unpin for Sender<T> {}\n@@ -46,7 +47,7 @@ impl<T> Unpin for Sender<T> {}\n impl<T> Sender<T> {\n     /// Sends the provided message along this channel.\n     pub fn send(&self, item: T) -> Result<(), SendError<T>> {\n-        let shared = unsafe { self.shared.get_mut_unsafe() };\n+        let mut shared = self.shared.borrow_mut();\n         if !shared.has_receiver {\n             return Err(SendError(item)); // receiver was dropped\n         };\n@@ -60,7 +61,7 @@ impl<T> Sender<T> {\n     /// This prevents any further messages from being sent on the channel while\n     /// still enabling the receiver to drain messages that are buffered.\n     pub fn close(&mut self) {\n-        self.shared.get_mut().has_receiver = false;\n+        self.shared.borrow_mut().has_receiver = false;\n     }\n }\n \n@@ -94,8 +95,8 @@ impl<T> Sink<T> for Sender<T> {\n \n impl<T> Drop for Sender<T> {\n     fn drop(&mut self) {\n-        let count = self.shared.strong_count();\n-        let shared = self.shared.get_mut();\n+        let count = Rc::strong_count(&self.shared);\n+        let shared = self.shared.borrow_mut();\n \n         // check is last sender is about to drop\n         if shared.has_receiver && count == 2 {\n@@ -110,7 +111,7 @@ impl<T> Drop for Sender<T> {\n /// This is created by the `channel` function.\n #[derive(Debug)]\n pub struct Receiver<T> {\n-    shared: Cell<Shared<T>>,\n+    shared: Rc<RefCell<Shared<T>>>,\n }\n \n impl<T> Receiver<T> {\n@@ -127,15 +128,16 @@ impl<T> Unpin for Receiver<T> {}\n impl<T> Stream for Receiver<T> {\n     type Item = T;\n \n-    fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {\n-        if self.shared.strong_count() == 1 {\n+    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {\n+        let mut shared = self.shared.borrow_mut();\n+        if Rc::strong_count(&self.shared) == 1 {\n             // All senders have been dropped, so drain the buffer and end the\n             // stream.\n-            Poll::Ready(self.shared.get_mut().buffer.pop_front())\n-        } else if let Some(msg) = self.shared.get_mut().buffer.pop_front() {\n+            Poll::Ready(shared.buffer.pop_front())\n+        } else if let Some(msg) = shared.buffer.pop_front() {\n             Poll::Ready(Some(msg))\n         } else {\n-            self.shared.get_mut().blocked_recv.register(cx.waker());\n+            shared.blocked_recv.register(cx.waker());\n             Poll::Pending\n         }\n     }\n@@ -143,7 +145,7 @@ impl<T> Stream for Receiver<T> {\n \n impl<T> Drop for Receiver<T> {\n     fn drop(&mut self) {\n-        let shared = self.shared.get_mut();\n+        let mut shared = self.shared.borrow_mut();\n         shared.buffer.clear();\n         shared.has_receiver = false;\n     }\n",
    "diff_parsed": "{'added': [(3, 'use std::cell::RefCell;'), (8, 'use std::rc::Rc;'), (18, '    let shared = Rc::new(RefCell::new(Shared {'), (22, '    }));'), (42, '    shared: Rc<RefCell<Shared<T>>>,'), (50, '        let mut shared = self.shared.borrow_mut();'), (64, '        self.shared.borrow_mut().has_receiver = false;'), (98, '        let count = Rc::strong_count(&self.shared);'), (99, '        let shared = self.shared.borrow_mut();'), (114, '    shared: Rc<RefCell<Shared<T>>>,'), (131, \"    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {\"), (132, '        let mut shared = self.shared.borrow_mut();'), (133, '        if Rc::strong_count(&self.shared) == 1 {'), (136, '            Poll::Ready(shared.buffer.pop_front())'), (137, '        } else if let Some(msg) = shared.buffer.pop_front() {'), (140, '            shared.blocked_recv.register(cx.waker());'), (148, '        let mut shared = self.shared.borrow_mut();')], 'deleted': [(12, 'use crate::cell::Cell;'), (17, '    let shared = Cell::new(Shared {'), (21, '    });'), (41, '    shared: Cell<Shared<T>>,'), (49, '        let shared = unsafe { self.shared.get_mut_unsafe() };'), (63, '        self.shared.get_mut().has_receiver = false;'), (97, '        let count = self.shared.strong_count();'), (98, '        let shared = self.shared.get_mut();'), (113, '    shared: Cell<Shared<T>>,'), (130, \"    fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {\"), (131, '        if self.shared.strong_count() == 1 {'), (134, '            Poll::Ready(self.shared.get_mut().buffer.pop_front())'), (135, '        } else if let Some(msg) = self.shared.get_mut().buffer.pop_front() {'), (138, '            self.shared.get_mut().blocked_recv.register(cx.waker());'), (146, '        let shared = self.shared.get_mut();')]}",
    "num_lines_added": "17",
    "num_lines_deleted": "15",
    "nloc": "184.0"
  },
  {
    "file_change_id": "122975880162119",
    "hash": "3f733cd056098d5e8de6ae8da40950500edc881",
    "old_path": "actix-utils/src/oneshot.rs",
    "new_path": "actix-utils/src/oneshot.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,20 +1,21 @@\n //! A one-shot, futures-aware channel.\n+use std::cell::RefCell;\n use std::future::Future;\n use std::pin::Pin;\n+use std::rc::Rc;\n use std::task::{Context, Poll};\n \n pub use futures_channel::oneshot::Canceled;\n use slab::Slab;\n \n-use crate::cell::Cell;\n use crate::task::LocalWaker;\n \n /// Creates a new futures-aware, one-shot channel.\n pub fn channel<T>() -> (Sender<T>, Receiver<T>) {\n-    let inner = Cell::new(Inner {\n+    let inner = Rc::new(RefCell::new(Inner {\n         value: None,\n         rx_task: LocalWaker::new(),\n-    });\n+    }));\n     let tx = Sender {\n         inner: inner.clone(),\n     };\n@@ -24,14 +25,14 @@ pub fn channel<T>() -> (Sender<T>, Receiver<T>) {\n \n /// Creates a new futures-aware, pool of one-shot's.\n pub fn pool<T>() -> Pool<T> {\n-    Pool(Cell::new(Slab::new()))\n+    Pool(Rc::new(RefCell::new(Slab::new())))\n }\n \n /// Represents the completion half of a oneshot through which the result of a\n /// computation is signaled.\n #[derive(Debug)]\n pub struct Sender<T> {\n-    inner: Cell<Inner<T>>,\n+    inner: Rc<RefCell<Inner<T>>>,\n }\n \n /// A future representing the completion of a computation happening elsewhere in\n@@ -39,7 +40,7 @@ pub struct Sender<T> {\n #[derive(Debug)]\n #[must_use = \"futures do nothing unless polled\"]\n pub struct Receiver<T> {\n-    inner: Cell<Inner<T>>,\n+    inner: Rc<RefCell<Inner<T>>>,\n }\n \n // The channels do not ever project Pin to the inner T\n@@ -63,9 +64,9 @@ impl<T> Sender<T> {\n     /// then `Ok(())` is returned. If the receiving end was dropped before\n     /// this function was called, however, then `Err` is returned with the value\n     /// provided.\n-    pub fn send(mut self, val: T) -> Result<(), T> {\n-        if self.inner.strong_count() == 2 {\n-            let inner = self.inner.get_mut();\n+    pub fn send(self, val: T) -> Result<(), T> {\n+        if Rc::strong_count(&self.inner) == 2 {\n+            let mut inner = self.inner.borrow_mut();\n             inner.value = Some(val);\n             inner.rx_task.wake();\n             Ok(())\n@@ -77,13 +78,13 @@ impl<T> Sender<T> {\n     /// Tests to see whether this `Sender`'s corresponding `Receiver`\n     /// has gone away.\n     pub fn is_canceled(&self) -> bool {\n-        self.inner.strong_count() == 1\n+        Rc::strong_count(&self.inner) == 1\n     }\n }\n \n impl<T> Drop for Sender<T> {\n     fn drop(&mut self) {\n-        self.inner.get_ref().rx_task.wake();\n+        self.inner.borrow().rx_task.wake();\n     }\n }\n \n@@ -94,22 +95,22 @@ impl<T> Future for Receiver<T> {\n         let this = self.get_mut();\n \n         // If we've got a value, then skip the logic below as we're done.\n-        if let Some(val) = this.inner.get_mut().value.take() {\n+        if let Some(val) = this.inner.borrow_mut().value.take() {\n             return Poll::Ready(Ok(val));\n         }\n \n         // Check if sender is dropped and return error if it is.\n-        if this.inner.strong_count() == 1 {\n+        if Rc::strong_count(&this.inner) == 1 {\n             Poll::Ready(Err(Canceled))\n         } else {\n-            this.inner.get_ref().rx_task.register(cx.waker());\n+            this.inner.borrow().rx_task.register(cx.waker());\n             Poll::Pending\n         }\n     }\n }\n \n /// Futures-aware, pool of one-shot's.\n-pub struct Pool<T>(Cell<Slab<PoolInner<T>>>);\n+pub struct Pool<T>(Rc<RefCell<Slab<PoolInner<T>>>>);\n \n bitflags::bitflags! {\n     pub struct Flags: u8 {\n@@ -127,7 +128,7 @@ struct PoolInner<T> {\n \n impl<T> Pool<T> {\n     pub fn channel(&mut self) -> (PSender<T>, PReceiver<T>) {\n-        let token = self.0.get_mut().insert(PoolInner {\n+        let token = self.0.borrow_mut().insert(PoolInner {\n             flags: Flags::all(),\n             value: None,\n             waker: LocalWaker::default(),\n@@ -157,7 +158,7 @@ impl<T> Clone for Pool<T> {\n #[derive(Debug)]\n pub struct PSender<T> {\n     token: usize,\n-    inner: Cell<Slab<PoolInner<T>>>,\n+    inner: Rc<RefCell<Slab<PoolInner<T>>>>,\n }\n \n /// A future representing the completion of a computation happening elsewhere in\n@@ -166,7 +167,7 @@ pub struct PSender<T> {\n #[must_use = \"futures do nothing unless polled\"]\n pub struct PReceiver<T> {\n     token: usize,\n-    inner: Cell<Slab<PoolInner<T>>>,\n+    inner: Rc<RefCell<Slab<PoolInner<T>>>>,\n }\n \n // The oneshots do not ever project Pin to the inner T\n@@ -184,8 +185,9 @@ impl<T> PSender<T> {\n     /// then `Ok(())` is returned. If the receiving end was dropped before\n     /// this function was called, however, then `Err` is returned with the value\n     /// provided.\n-    pub fn send(mut self, val: T) -> Result<(), T> {\n-        let inner = unsafe { self.inner.get_mut().get_unchecked_mut(self.token) };\n+    pub fn send(self, val: T) -> Result<(), T> {\n+        let mut inner = self.inner.borrow_mut();\n+        let inner = unsafe { inner.get_unchecked_mut(self.token) };\n \n         if inner.flags.contains(Flags::RECEIVER) {\n             inner.value = Some(val);\n@@ -199,7 +201,7 @@ impl<T> PSender<T> {\n     /// Tests to see whether this `Sender`'s corresponding `Receiver`\n     /// has gone away.\n     pub fn is_canceled(&self) -> bool {\n-        !unsafe { self.inner.get_ref().get_unchecked(self.token) }\n+        !unsafe { self.inner.borrow().get_unchecked(self.token) }\n             .flags\n             .contains(Flags::RECEIVER)\n     }\n@@ -207,23 +209,25 @@ impl<T> PSender<T> {\n \n impl<T> Drop for PSender<T> {\n     fn drop(&mut self) {\n-        let inner = unsafe { self.inner.get_mut().get_unchecked_mut(self.token) };\n-        if inner.flags.contains(Flags::RECEIVER) {\n-            inner.waker.wake();\n-            inner.flags.remove(Flags::SENDER);\n+        let mut inner = self.inner.borrow_mut();\n+        let inner_token = unsafe { inner.get_unchecked_mut(self.token) };\n+        if inner_token.flags.contains(Flags::RECEIVER) {\n+            inner_token.waker.wake();\n+            inner_token.flags.remove(Flags::SENDER);\n         } else {\n-            self.inner.get_mut().remove(self.token);\n+            inner.remove(self.token);\n         }\n     }\n }\n \n impl<T> Drop for PReceiver<T> {\n     fn drop(&mut self) {\n-        let inner = unsafe { self.inner.get_mut().get_unchecked_mut(self.token) };\n-        if inner.flags.contains(Flags::SENDER) {\n-            inner.flags.remove(Flags::RECEIVER);\n+        let mut inner = self.inner.borrow_mut();\n+        let inner_token = unsafe { inner.get_unchecked_mut(self.token) };\n+        if inner_token.flags.contains(Flags::SENDER) {\n+            inner_token.flags.remove(Flags::RECEIVER);\n         } else {\n-            self.inner.get_mut().remove(self.token);\n+            inner.remove(self.token);\n         }\n     }\n }\n@@ -233,7 +237,8 @@ impl<T> Future for PReceiver<T> {\n \n     fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n         let this = self.get_mut();\n-        let inner = unsafe { this.inner.get_mut().get_unchecked_mut(this.token) };\n+        let mut inner = this.inner.borrow_mut();\n+        let inner = unsafe { inner.get_unchecked_mut(this.token) };\n \n         // If we've got a value, then skip the logic below as we're done.\n         if let Some(val) = inner.value.take() {\n",
    "diff_parsed": "{'added': [(2, 'use std::cell::RefCell;'), (5, 'use std::rc::Rc;'), (15, '    let inner = Rc::new(RefCell::new(Inner {'), (18, '    }));'), (28, '    Pool(Rc::new(RefCell::new(Slab::new())))'), (35, '    inner: Rc<RefCell<Inner<T>>>,'), (43, '    inner: Rc<RefCell<Inner<T>>>,'), (67, '    pub fn send(self, val: T) -> Result<(), T> {'), (68, '        if Rc::strong_count(&self.inner) == 2 {'), (69, '            let mut inner = self.inner.borrow_mut();'), (81, '        Rc::strong_count(&self.inner) == 1'), (87, '        self.inner.borrow().rx_task.wake();'), (98, '        if let Some(val) = this.inner.borrow_mut().value.take() {'), (103, '        if Rc::strong_count(&this.inner) == 1 {'), (106, '            this.inner.borrow().rx_task.register(cx.waker());'), (113, 'pub struct Pool<T>(Rc<RefCell<Slab<PoolInner<T>>>>);'), (131, '        let token = self.0.borrow_mut().insert(PoolInner {'), (161, '    inner: Rc<RefCell<Slab<PoolInner<T>>>>,'), (170, '    inner: Rc<RefCell<Slab<PoolInner<T>>>>,'), (188, '    pub fn send(self, val: T) -> Result<(), T> {'), (189, '        let mut inner = self.inner.borrow_mut();'), (190, '        let inner = unsafe { inner.get_unchecked_mut(self.token) };'), (204, '        !unsafe { self.inner.borrow().get_unchecked(self.token) }'), (212, '        let mut inner = self.inner.borrow_mut();'), (213, '        let inner_token = unsafe { inner.get_unchecked_mut(self.token) };'), (214, '        if inner_token.flags.contains(Flags::RECEIVER) {'), (215, '            inner_token.waker.wake();'), (216, '            inner_token.flags.remove(Flags::SENDER);'), (218, '            inner.remove(self.token);'), (225, '        let mut inner = self.inner.borrow_mut();'), (226, '        let inner_token = unsafe { inner.get_unchecked_mut(self.token) };'), (227, '        if inner_token.flags.contains(Flags::SENDER) {'), (228, '            inner_token.flags.remove(Flags::RECEIVER);'), (230, '            inner.remove(self.token);'), (240, '        let mut inner = this.inner.borrow_mut();'), (241, '        let inner = unsafe { inner.get_unchecked_mut(this.token) };')], 'deleted': [(9, 'use crate::cell::Cell;'), (14, '    let inner = Cell::new(Inner {'), (17, '    });'), (27, '    Pool(Cell::new(Slab::new()))'), (34, '    inner: Cell<Inner<T>>,'), (42, '    inner: Cell<Inner<T>>,'), (66, '    pub fn send(mut self, val: T) -> Result<(), T> {'), (67, '        if self.inner.strong_count() == 2 {'), (68, '            let inner = self.inner.get_mut();'), (80, '        self.inner.strong_count() == 1'), (86, '        self.inner.get_ref().rx_task.wake();'), (97, '        if let Some(val) = this.inner.get_mut().value.take() {'), (102, '        if this.inner.strong_count() == 1 {'), (105, '            this.inner.get_ref().rx_task.register(cx.waker());'), (112, 'pub struct Pool<T>(Cell<Slab<PoolInner<T>>>);'), (130, '        let token = self.0.get_mut().insert(PoolInner {'), (160, '    inner: Cell<Slab<PoolInner<T>>>,'), (169, '    inner: Cell<Slab<PoolInner<T>>>,'), (187, '    pub fn send(mut self, val: T) -> Result<(), T> {'), (188, '        let inner = unsafe { self.inner.get_mut().get_unchecked_mut(self.token) };'), (202, '        !unsafe { self.inner.get_ref().get_unchecked(self.token) }'), (210, '        let inner = unsafe { self.inner.get_mut().get_unchecked_mut(self.token) };'), (211, '        if inner.flags.contains(Flags::RECEIVER) {'), (212, '            inner.waker.wake();'), (213, '            inner.flags.remove(Flags::SENDER);'), (215, '            self.inner.get_mut().remove(self.token);'), (222, '        let inner = unsafe { self.inner.get_mut().get_unchecked_mut(self.token) };'), (223, '        if inner.flags.contains(Flags::SENDER) {'), (224, '            inner.flags.remove(Flags::RECEIVER);'), (226, '            self.inner.get_mut().remove(self.token);'), (236, '        let inner = unsafe { this.inner.get_mut().get_unchecked_mut(this.token) };')]}",
    "num_lines_added": "36",
    "num_lines_deleted": "31",
    "nloc": "246.0"
  },
  {
    "file_change_id": "211209006132348",
    "hash": "3f733cd056098d5e8de6ae8da40950500edc881",
    "old_path": "actix-utils/src/stream.rs",
    "new_path": "actix-utils/src/stream.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -3,7 +3,7 @@ use std::pin::Pin;\n use std::task::{Context, Poll};\n \n use actix_service::{IntoService, Service};\n-use futures_util::{FutureExt, stream::Stream};\n+use futures_util::{stream::Stream, FutureExt};\n \n use crate::mpsc;\n \n",
    "diff_parsed": "{'added': [(6, 'use futures_util::{stream::Stream, FutureExt};')], 'deleted': [(6, 'use futures_util::{FutureExt, stream::Stream};')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "70.0"
  },
  {
    "file_change_id": "261428124037628",
    "hash": "3f733cd056098d5e8de6ae8da40950500edc881",
    "old_path": "actix-utils/src/time.rs",
    "new_path": "actix-utils/src/time.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,4 +1,6 @@\n+use std::cell::RefCell;\n use std::convert::Infallible;\n+use std::rc::Rc;\n use std::task::{Context, Poll};\n use std::time::{self, Duration, Instant};\n \n@@ -6,10 +8,8 @@ use actix_rt::time::delay_for;\n use actix_service::{Service, ServiceFactory};\n use futures_util::future::{ok, ready, FutureExt, Ready};\n \n-use super::cell::Cell;\n-\n #[derive(Clone, Debug)]\n-pub struct LowResTime(Cell<Inner>);\n+pub struct LowResTime(Rc<RefCell<Inner>>);\n \n #[derive(Debug)]\n struct Inner {\n@@ -28,7 +28,7 @@ impl Inner {\n \n impl LowResTime {\n     pub fn with(resolution: Duration) -> LowResTime {\n-        LowResTime(Cell::new(Inner::new(resolution)))\n+        LowResTime(Rc::new(RefCell::new(Inner::new(resolution))))\n     }\n \n     pub fn timer(&self) -> LowResTimeService {\n@@ -38,7 +38,7 @@ impl LowResTime {\n \n impl Default for LowResTime {\n     fn default() -> Self {\n-        LowResTime(Cell::new(Inner::new(Duration::from_secs(1))))\n+        LowResTime(Rc::new(RefCell::new(Inner::new(Duration::from_secs(1)))))\n     }\n }\n \n@@ -57,30 +57,30 @@ impl ServiceFactory for LowResTime {\n }\n \n #[derive(Clone, Debug)]\n-pub struct LowResTimeService(Cell<Inner>);\n+pub struct LowResTimeService(Rc<RefCell<Inner>>);\n \n impl LowResTimeService {\n     pub fn with(resolution: Duration) -> LowResTimeService {\n-        LowResTimeService(Cell::new(Inner::new(resolution)))\n+        LowResTimeService(Rc::new(RefCell::new(Inner::new(resolution))))\n     }\n \n     /// Get current time. This function has to be called from\n     /// future's poll method, otherwise it panics.\n     pub fn now(&self) -> Instant {\n-        let cur = self.0.get_ref().current;\n+        let cur = self.0.borrow().current;\n         if let Some(cur) = cur {\n             cur\n         } else {\n             let now = Instant::now();\n-            let mut inner = self.0.clone();\n+            let inner = self.0.clone();\n             let interval = {\n-                let mut b = inner.get_mut();\n+                let mut b = inner.borrow_mut();\n                 b.current = Some(now);\n                 b.resolution\n             };\n \n             actix_rt::spawn(delay_for(interval).then(move |_| {\n-                inner.get_mut().current.take();\n+                inner.borrow_mut().current.take();\n                 ready(())\n             }));\n             now\n@@ -104,7 +104,7 @@ impl Service for LowResTimeService {\n }\n \n #[derive(Clone, Debug)]\n-pub struct SystemTime(Cell<SystemTimeInner>);\n+pub struct SystemTime(Rc<RefCell<SystemTimeInner>>);\n \n #[derive(Debug)]\n struct SystemTimeInner {\n@@ -122,30 +122,30 @@ impl SystemTimeInner {\n }\n \n #[derive(Clone, Debug)]\n-pub struct SystemTimeService(Cell<SystemTimeInner>);\n+pub struct SystemTimeService(Rc<RefCell<SystemTimeInner>>);\n \n impl SystemTimeService {\n     pub fn with(resolution: Duration) -> SystemTimeService {\n-        SystemTimeService(Cell::new(SystemTimeInner::new(resolution)))\n+        SystemTimeService(Rc::new(RefCell::new(SystemTimeInner::new(resolution))))\n     }\n \n     /// Get current time. This function has to be called from\n     /// future's poll method, otherwise it panics.\n     pub fn now(&self) -> time::SystemTime {\n-        let cur = self.0.get_ref().current;\n+        let cur = self.0.borrow().current;\n         if let Some(cur) = cur {\n             cur\n         } else {\n             let now = time::SystemTime::now();\n-            let mut inner = self.0.clone();\n+            let inner = self.0.clone();\n             let interval = {\n-                let mut b = inner.get_mut();\n+                let mut b = inner.borrow_mut();\n                 b.current = Some(now);\n                 b.resolution\n             };\n \n             actix_rt::spawn(delay_for(interval).then(move |_| {\n-                inner.get_mut().current.take();\n+                inner.borrow_mut().current.take();\n                 ready(())\n             }));\n             now\n",
    "diff_parsed": "{'added': [(1, 'use std::cell::RefCell;'), (3, 'use std::rc::Rc;'), (12, 'pub struct LowResTime(Rc<RefCell<Inner>>);'), (31, '        LowResTime(Rc::new(RefCell::new(Inner::new(resolution))))'), (41, '        LowResTime(Rc::new(RefCell::new(Inner::new(Duration::from_secs(1)))))'), (60, 'pub struct LowResTimeService(Rc<RefCell<Inner>>);'), (64, '        LowResTimeService(Rc::new(RefCell::new(Inner::new(resolution))))'), (70, '        let cur = self.0.borrow().current;'), (75, '            let inner = self.0.clone();'), (77, '                let mut b = inner.borrow_mut();'), (83, '                inner.borrow_mut().current.take();'), (107, 'pub struct SystemTime(Rc<RefCell<SystemTimeInner>>);'), (125, 'pub struct SystemTimeService(Rc<RefCell<SystemTimeInner>>);'), (129, '        SystemTimeService(Rc::new(RefCell::new(SystemTimeInner::new(resolution))))'), (135, '        let cur = self.0.borrow().current;'), (140, '            let inner = self.0.clone();'), (142, '                let mut b = inner.borrow_mut();'), (148, '                inner.borrow_mut().current.take();')], 'deleted': [(9, 'use super::cell::Cell;'), (12, 'pub struct LowResTime(Cell<Inner>);'), (31, '        LowResTime(Cell::new(Inner::new(resolution)))'), (41, '        LowResTime(Cell::new(Inner::new(Duration::from_secs(1))))'), (60, 'pub struct LowResTimeService(Cell<Inner>);'), (64, '        LowResTimeService(Cell::new(Inner::new(resolution)))'), (70, '        let cur = self.0.get_ref().current;'), (75, '            let mut inner = self.0.clone();'), (77, '                let mut b = inner.get_mut();'), (83, '                inner.get_mut().current.take();'), (107, 'pub struct SystemTime(Cell<SystemTimeInner>);'), (125, 'pub struct SystemTimeService(Cell<SystemTimeInner>);'), (129, '        SystemTimeService(Cell::new(SystemTimeInner::new(resolution)))'), (135, '        let cur = self.0.get_ref().current;'), (140, '            let mut inner = self.0.clone();'), (142, '                let mut b = inner.get_mut();'), (148, '                inner.get_mut().current.take();')]}",
    "num_lines_added": "18",
    "num_lines_deleted": "17",
    "nloc": "179.0"
  },
  {
    "file_change_id": "248033864680989",
    "hash": "34c2b9e51cd7b85a3366104092ca4e5e9fab227",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -89,8 +89,8 @@ impl<T: Sized> Drop for AtomicBox<T> {\n     }\n }\n \n-unsafe impl<T: Sized> Sync for AtomicBox<T> {}\n-unsafe impl<T: Sized> Send for AtomicBox<T> {}\n+unsafe impl<T: Sized + Sync> Sync for AtomicBox<T> {}\n+unsafe impl<T: Sized + Send> Send for AtomicBox<T> {}\n \n #[cfg(test)]\n mod tests {\n",
    "diff_parsed": "{'added': [(92, 'unsafe impl<T: Sized + Sync> Sync for AtomicBox<T> {}'), (93, 'unsafe impl<T: Sized + Send> Send for AtomicBox<T> {}')], 'deleted': [(92, 'unsafe impl<T: Sized> Sync for AtomicBox<T> {}'), (93, 'unsafe impl<T: Sized> Send for AtomicBox<T> {}')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "172"
  },
  {
    "file_change_id": "68233068912900",
    "hash": "dede6fef9a50650efdd1ee36b2466911cc1b195",
    "old_path": "actix-http/src/body.rs",
    "new_path": "actix-http/src/body.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -361,10 +361,8 @@ impl MessageBody for String {\n \n /// Type represent streaming body.\n /// Response does not contain `content-length` header and appropriate transfer encoding is used.\n-#[pin_project]\n pub struct BodyStream<S, E> {\n-    #[pin]\n-    stream: S,\n+    stream: Pin<Box<S>>,\n     _t: PhantomData<E>,\n }\n \n@@ -375,7 +373,7 @@ where\n {\n     pub fn new(stream: S) -> Self {\n         BodyStream {\n-            stream,\n+            stream: Box::pin(stream),\n             _t: PhantomData,\n         }\n     }\n@@ -396,7 +394,7 @@ where\n     /// ended on a zero-length chunk, but rather proceed until the underlying\n     /// [`Stream`] ends.\n     fn poll_next(&mut self, cx: &mut Context<'_>) -> Poll<Option<Result<Bytes, Error>>> {\n-        let mut stream = unsafe { Pin::new_unchecked(self) }.project().stream;\n+        let mut stream = self.stream.as_mut();\n         loop {\n             return Poll::Ready(match ready!(stream.as_mut().poll_next(cx)) {\n                 Some(Ok(ref bytes)) if bytes.is_empty() => continue,\n@@ -408,11 +406,9 @@ where\n \n /// Type represent streaming body. This body implementation should be used\n /// if total size of stream is known. Data get sent as is without using transfer encoding.\n-#[pin_project]\n pub struct SizedStream<S> {\n     size: u64,\n-    #[pin]\n-    stream: S,\n+    stream: Pin<Box<S>>,\n }\n \n impl<S> SizedStream<S>\n@@ -420,7 +416,7 @@ where\n     S: Stream<Item = Result<Bytes, Error>>,\n {\n     pub fn new(size: u64, stream: S) -> Self {\n-        SizedStream { size, stream }\n+        SizedStream { size, stream: Box::pin(stream) }\n     }\n }\n \n@@ -438,7 +434,7 @@ where\n     /// ended on a zero-length chunk, but rather proceed until the underlying\n     /// [`Stream`] ends.\n     fn poll_next(&mut self, cx: &mut Context<'_>) -> Poll<Option<Result<Bytes, Error>>> {\n-        let mut stream = unsafe { Pin::new_unchecked(self) }.project().stream;\n+        let mut stream = self.stream.as_mut();\n         loop {\n             return Poll::Ready(match ready!(stream.as_mut().poll_next(cx)) {\n                 Some(Ok(ref bytes)) if bytes.is_empty() => continue,\n",
    "diff_parsed": "{'added': [(365, '    stream: Pin<Box<S>>,'), (376, '            stream: Box::pin(stream),'), (397, '        let mut stream = self.stream.as_mut();'), (411, '    stream: Pin<Box<S>>,'), (419, '        SizedStream { size, stream: Box::pin(stream) }'), (437, '        let mut stream = self.stream.as_mut();')], 'deleted': [(364, '#[pin_project]'), (366, '    #[pin]'), (367, '    stream: S,'), (378, '            stream,'), (399, '        let mut stream = unsafe { Pin::new_unchecked(self) }.project().stream;'), (411, '#[pin_project]'), (414, '    #[pin]'), (415, '    stream: S,'), (423, '        SizedStream { size, stream }'), (441, '        let mut stream = unsafe { Pin::new_unchecked(self) }.project().stream;')]}",
    "num_lines_added": "6",
    "num_lines_deleted": "10",
    "nloc": "583"
  },
  {
    "file_change_id": "254819524883794",
    "hash": "dede6fef9a50650efdd1ee36b2466911cc1b195",
    "old_path": "None",
    "new_path": "tests/test_weird_poll.rs",
    "change_type": "ModificationType.ADD",
    "diff": "@@ -0,0 +1,26 @@\n+// Regression test for #/1321\n+\n+use futures::task::{noop_waker, Context};\n+use futures::stream::once;\n+use actix_http::body::{MessageBody, BodyStream};\n+use bytes::Bytes;\n+\n+#[test]\n+fn weird_poll() {\n+    let (sender, receiver) = futures::channel::oneshot::channel();\n+    let mut body_stream = Ok(BodyStream::new(once(async {\n+        let x = Box::new(0);\n+        let y = &x;\n+        receiver.await.unwrap();\n+        let _z = **y;\n+        Ok::<_, ()>(Bytes::new())\n+    })));\n+\n+    let waker = noop_waker();\n+    let mut context = Context::from_waker(&waker);\n+\n+    let _ = body_stream.as_mut().unwrap().poll_next(&mut context);\n+    sender.send(()).unwrap();\n+    let _ = std::mem::replace(&mut body_stream, Err([0; 32])).unwrap().poll_next(&mut context);\n+}\n+\n",
    "diff_parsed": "{'added': [(3, 'use futures::task::{noop_waker, Context};'), (4, 'use futures::stream::once;'), (5, 'use actix_http::body::{MessageBody, BodyStream};'), (6, 'use bytes::Bytes;'), (8, '#[test]'), (9, 'fn weird_poll() {'), (10, '    let (sender, receiver) = futures::channel::oneshot::channel();'), (11, '    let mut body_stream = Ok(BodyStream::new(once(async {'), (12, '        let x = Box::new(0);'), (13, '        let y = &x;'), (14, '        receiver.await.unwrap();'), (15, '        let _z = **y;'), (16, '        Ok::<_, ()>(Bytes::new())'), (17, '    })));'), (19, '    let waker = noop_waker();'), (20, '    let mut context = Context::from_waker(&waker);'), (22, '    let _ = body_stream.as_mut().unwrap().poll_next(&mut context);'), (23, '    sender.send(()).unwrap();'), (24, '    let _ = std::mem::replace(&mut body_stream, Err([0; 32])).unwrap().poll_next(&mut context);'), (25, '}')], 'deleted': []}",
    "num_lines_added": "20",
    "num_lines_deleted": "0",
    "nloc": "20"
  },
  {
    "file_change_id": "259376577266433",
    "hash": "04731e101fed08a32942d52790e1c8c6ede6188",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -192,7 +192,7 @@ pub type DefaultStringInterner = StringInterner<Sym>;\n \n /// Caches strings efficiently, with minimal memory footprint and associates them with unique symbols.\n /// These symbols allow constant time comparisons and look-ups to the underlying interned strings.\n-#[derive(Debug, Clone, Eq)]\n+#[derive(Debug, Eq)]\n pub struct StringInterner<S, H = RandomState>\n where\n \tS: Symbol,\n@@ -219,6 +219,28 @@ impl Default for StringInterner<Sym, RandomState> {\n \t}\n }\n \n+// Should be manually cloned.\n+// See <https://github.com/Robbepop/string-interner/issues/9>.\n+impl<S, H> Clone for StringInterner<S, H>\n+where\n+\tS: Symbol,\n+\tH: Clone + BuildHasher,\n+{\n+\tfn clone(&self) -> Self {\n+\t\tlet values = self.values.clone();\n+\t\tlet mut map = HashMap::with_capacity_and_hasher(values.len(), self.map.hasher().clone());\n+\t\t// Recreate `InternalStrRef` from the newly cloned `Box<str>`s.\n+\t\t// Use `extend()` to avoid `H: Default` trait bound required by `FromIterator for HashMap`.\n+\t\tmap.extend(\n+\t\t\tvalues\n+\t\t\t.iter()\n+\t\t\t.enumerate()\n+\t\t\t.map(|(i, s)| (InternalStrRef::from_str(s), S::from_usize(i))),\n+\t\t);\n+\t\tSelf { values, map }\n+\t}\n+}\n+\n // About `Send` and `Sync` impls for `StringInterner`\n // --------------------------------------------------\n //\n",
    "diff_parsed": "{'added': [(195, '#[derive(Debug, Eq)]'), (224, 'impl<S, H> Clone for StringInterner<S, H>'), (225, 'where'), (226, '\\tS: Symbol,'), (227, '\\tH: Clone + BuildHasher,'), (228, '{'), (229, '\\tfn clone(&self) -> Self {'), (230, '\\t\\tlet values = self.values.clone();'), (231, '\\t\\tlet mut map = HashMap::with_capacity_and_hasher(values.len(), self.map.hasher().clone());'), (234, '\\t\\tmap.extend('), (235, '\\t\\t\\tvalues'), (236, '\\t\\t\\t.iter()'), (237, '\\t\\t\\t.enumerate()'), (238, '\\t\\t\\t.map(|(i, s)| (InternalStrRef::from_str(s), S::from_usize(i))),'), (239, '\\t\\t);'), (240, '\\t\\tSelf { values, map }'), (241, '\\t}'), (242, '}')], 'deleted': [(195, '#[derive(Debug, Clone, Eq)]')]}",
    "num_lines_added": "18",
    "num_lines_deleted": "1",
    "nloc": "370"
  },
  {
    "file_change_id": "41088827099101",
    "hash": "04731e101fed08a32942d52790e1c8c6ede6188",
    "old_path": "src/tests.rs",
    "new_path": "src/tests.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -398,4 +398,18 @@ mod clone_and_drop {\n \t\t\t\"`foo` should represent the string \\\"foo\\\" so they should be equal\"\n \t\t);\n \t}\n+\n+\t#[test]\n+\t// Test for new (non-`derive`) `Clone` impl.\n+\tfn clone() {\n+\t\tlet mut old = DefaultStringInterner::new();\n+\t\tlet strings = &[\"foo\", \"bar\", \"baz\", \"qux\", \"quux\", \"corge\"];\n+\t\tlet syms = strings.iter().map(|&s| old.get_or_intern(s)).collect::<Vec<_>>();\n+\n+\t\tlet mut new = old.clone();\n+\t\tfor (&s, &sym) in strings.iter().zip(&syms) {\n+\t\t\tassert_eq!(new.resolve(sym), Some(s));\n+\t\t\tassert_eq!(new.get_or_intern(s), sym);\n+\t\t}\n+\t}\n }\n",
    "diff_parsed": "{'added': [(402, '\\t#[test]'), (404, '\\tfn clone() {'), (405, '\\t\\tlet mut old = DefaultStringInterner::new();'), (406, '\\t\\tlet strings = &[\"foo\", \"bar\", \"baz\", \"qux\", \"quux\", \"corge\"];'), (407, '\\t\\tlet syms = strings.iter().map(|&s| old.get_or_intern(s)).collect::<Vec<_>>();'), (409, '\\t\\tlet mut new = old.clone();'), (410, '\\t\\tfor (&s, &sym) in strings.iter().zip(&syms) {'), (411, '\\t\\t\\tassert_eq!(new.resolve(sym), Some(s));'), (412, '\\t\\t\\tassert_eq!(new.get_or_intern(s), sym);'), (413, '\\t\\t}'), (414, '\\t}')], 'deleted': []}",
    "num_lines_added": "11",
    "num_lines_deleted": "0",
    "nloc": "347"
  },
  {
    "file_change_id": "248538935129077",
    "hash": "ae13bdac8b95966a4fdef3b17aa6d2096799f7c",
    "old_path": "quinn/src/platform/unix.rs",
    "new_path": "quinn/src/platform/unix.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -2,7 +2,7 @@ use std::{\n     io,\n     io::IoSliceMut,\n     mem::{self, MaybeUninit},\n-    net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr, SocketAddrV4, SocketAddrV6},\n+    net::{IpAddr, SocketAddr, SocketAddrV4, SocketAddrV6},\n     os::unix::io::AsRawFd,\n     ptr,\n     task::{Context, Poll},\n@@ -375,8 +375,8 @@ fn prepare_msg(\n                 IpAddr::V4(v4) => {\n                     let pktinfo = libc::in_pktinfo {\n                         ipi_ifindex: 0,\n-                        ipi_spec_dst: unsafe {\n-                            *(v4 as *const Ipv4Addr as *const () as *const libc::in_addr)\n+                        ipi_spec_dst: libc::in_addr {\n+                            s_addr: u32::from_ne_bytes(v4.octets()),\n                         },\n                         ipi_addr: libc::in_addr { s_addr: 0 },\n                     };\n@@ -385,8 +385,8 @@ fn prepare_msg(\n                 IpAddr::V6(v6) => {\n                     let pktinfo = libc::in6_pktinfo {\n                         ipi6_ifindex: 0,\n-                        ipi6_addr: unsafe {\n-                            *(v6 as *const Ipv6Addr as *const () as *const libc::in6_addr)\n+                        ipi6_addr: libc::in6_addr {\n+                            s6_addr: v6.octets(),\n                         },\n                     };\n                     encoder.push(libc::IPPROTO_IPV6, libc::IPV6_PKTINFO, pktinfo);\n",
    "diff_parsed": "{'added': [(5, '    net::{IpAddr, SocketAddr, SocketAddrV4, SocketAddrV6},'), (378, '                        ipi_spec_dst: libc::in_addr {'), (379, '                            s_addr: u32::from_ne_bytes(v4.octets()),'), (388, '                        ipi6_addr: libc::in6_addr {'), (389, '                            s6_addr: v6.octets(),')], 'deleted': [(5, '    net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr, SocketAddrV4, SocketAddrV6},'), (378, '                        ipi_spec_dst: unsafe {'), (379, '                            *(v4 as *const Ipv4Addr as *const () as *const libc::in_addr)'), (388, '                        ipi6_addr: unsafe {'), (389, '                            *(v6 as *const Ipv6Addr as *const () as *const libc::in6_addr)')]}",
    "num_lines_added": "5",
    "num_lines_deleted": "5",
    "nloc": "482"
  },
  {
    "file_change_id": "156715422689911",
    "hash": "cd64316558c7faffc7e3669298e81dc9289ac22",
    "old_path": "quinn/src/platform/unix.rs",
    "new_path": "quinn/src/platform/unix.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -198,9 +198,25 @@ fn send(io: &mio::net::UdpSocket, transmits: &[Transmit]) -> io::Result<usize> {\n     let mut msgs: [libc::mmsghdr; BATCH_SIZE] = unsafe { mem::zeroed() };\n     let mut iovecs: [libc::iovec; BATCH_SIZE] = unsafe { mem::zeroed() };\n     let mut cmsgs = [cmsg::Aligned([0u8; CMSG_LEN]); BATCH_SIZE];\n+    // This assume_init looks a bit weird because one might think it\n+    // assumes the SockAddr data to be initialized, but that call\n+    // refers to the whole array, which itself is made up of MaybeUninit\n+    // containers. Their presence protects the SockAddr inside from\n+    // being assumed as initialized by the assume_init call.\n+    // TODO: Replace this with uninit_array once it becomes MSRV-stable\n+    let mut addrs: [MaybeUninit<socket2::SockAddr>; BATCH_SIZE] =\n+        unsafe { MaybeUninit::uninit().assume_init() };\n     for (i, transmit) in transmits.iter().enumerate().take(BATCH_SIZE) {\n+        let dst_addr = unsafe {\n+            std::ptr::write(\n+                addrs[i].as_mut_ptr(),\n+                socket2::SockAddr::from(transmit.destination),\n+            );\n+            &*addrs[i].as_ptr()\n+        };\n         prepare_msg(\n             transmit,\n+            dst_addr,\n             &mut msgs[i].msg_hdr,\n             &mut iovecs[i],\n             &mut cmsgs[i],\n@@ -233,7 +249,8 @@ fn send(io: &mio::net::UdpSocket, transmits: &[Transmit]) -> io::Result<usize> {\n     let mut ctrl = cmsg::Aligned([0u8; CMSG_LEN]);\n     let mut sent = 0;\n     while sent < transmits.len() {\n-        prepare_msg(&transmits[sent], &mut hdr, &mut iov, &mut ctrl);\n+        let addr = socket2::SockAddr::from(transmits[sent].destination);\n+        prepare_msg(&transmits[sent], &addr, &mut hdr, &mut iov, &mut ctrl);\n         let n = unsafe { libc::sendmsg(io.as_raw_fd(), &hdr, 0) };\n         if n == -1 {\n             let e = io::Error::last_os_error();\n@@ -334,6 +351,7 @@ const CMSG_LEN: usize = 80;\n \n fn prepare_msg(\n     transmit: &Transmit,\n+    dst_addr: &socket2::SockAddr,\n     hdr: &mut libc::msghdr,\n     iov: &mut libc::iovec,\n     ctrl: &mut cmsg::Aligned<[u8; CMSG_LEN]>,\n@@ -341,12 +359,15 @@ fn prepare_msg(\n     iov.iov_base = transmit.contents.as_ptr() as *const _ as *mut _;\n     iov.iov_len = transmit.contents.len();\n \n-    let (name, namelen) = match transmit.destination {\n-        SocketAddr::V4(ref addr) => (addr as *const _ as _, mem::size_of::<libc::sockaddr_in>()),\n-        SocketAddr::V6(ref addr) => (addr as *const _ as _, mem::size_of::<libc::sockaddr_in6>()),\n-    };\n-    hdr.msg_name = name;\n-    hdr.msg_namelen = namelen as _;\n+    // SAFETY: Casting the pointer to a mutable one is legal,\n+    // as sendmsg is guaranteed to not alter the mutable pointer\n+    // as per the POSIX spec. See the section on the sys/socket.h\n+    // header for details. The type is only mutable in the first\n+    // place because it is reused by recvmsg as well.\n+    let name = dst_addr.as_ptr() as *mut libc::c_void;\n+    let namelen = dst_addr.len();\n+    hdr.msg_name = name as *mut _;\n+    hdr.msg_namelen = namelen;\n     hdr.msg_iov = iov;\n     hdr.msg_iovlen = 1;\n \n",
    "diff_parsed": "{'added': [(207, '    let mut addrs: [MaybeUninit<socket2::SockAddr>; BATCH_SIZE] ='), (208, '        unsafe { MaybeUninit::uninit().assume_init() };'), (210, '        let dst_addr = unsafe {'), (211, '            std::ptr::write('), (212, '                addrs[i].as_mut_ptr(),'), (213, '                socket2::SockAddr::from(transmit.destination),'), (214, '            );'), (215, '            &*addrs[i].as_ptr()'), (216, '        };'), (219, '            dst_addr,'), (252, '        let addr = socket2::SockAddr::from(transmits[sent].destination);'), (253, '        prepare_msg(&transmits[sent], &addr, &mut hdr, &mut iov, &mut ctrl);'), (354, '    dst_addr: &socket2::SockAddr,'), (367, '    let name = dst_addr.as_ptr() as *mut libc::c_void;'), (368, '    let namelen = dst_addr.len();'), (369, '    hdr.msg_name = name as *mut _;'), (370, '    hdr.msg_namelen = namelen;')], 'deleted': [(236, '        prepare_msg(&transmits[sent], &mut hdr, &mut iov, &mut ctrl);'), (344, '    let (name, namelen) = match transmit.destination {'), (345, '        SocketAddr::V4(ref addr) => (addr as *const _ as _, mem::size_of::<libc::sockaddr_in>()),'), (346, '        SocketAddr::V6(ref addr) => (addr as *const _ as _, mem::size_of::<libc::sockaddr_in6>()),'), (347, '    };'), (348, '    hdr.msg_name = name;'), (349, '    hdr.msg_namelen = namelen as _;')]}",
    "num_lines_added": "17",
    "num_lines_deleted": "7",
    "nloc": "498"
  },
  {
    "file_change_id": "209869829872380",
    "hash": "eb413b3d47baea8e8a0b9ce2ccd8299b354d3b7",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -81,8 +81,18 @@ use core::marker::PhantomData;\n #[cfg(feature = \"alloc\")]\n use std::error::Error;\n \n+/// This is one part of the secret sauce that ensures that indices from\n+/// different arenas cannot be mixed. You should never need to use this type in\n+/// your code.\n #[derive(Copy, Clone, PartialOrd, PartialEq, Eq)]\n-struct InvariantLifetime<'a>(PhantomData<fn(&'a ()) -> &'a ()>);\n+pub struct InvariantLifetime<'a>(PhantomData<fn(&'a ()) -> &'a ()>);\n+\n+/// Create an invariant lifetime. This is one part of the secret sauce that\n+/// ensures that indices from different arenas cannot be mixed. You should\n+/// never need to use this type in your code.\n+pub fn invariant_lifetime<'tag>() -> InvariantLifetime<'tag> {\n+    InvariantLifetime(PhantomData)\n+}\n \n /// An index into the arena. You will not directly use this type, but one of\n /// the aliases this crate provides (`Idx32`, `Idx16` or `Idx8`).\n@@ -201,13 +211,24 @@ pub struct SmallArena<'tag, T> {\n macro_rules! mk_arena {\n     ($name:ident) => { $crate::mk_arena!($name, 128*1024) };\n     ($name:ident, $cap:expr) => {\n-        let mut tag = ();\n+        let tag = $crate::invariant_lifetime();\n+        let _guard;\n         let mut $name = unsafe {\n             // this is not per-se unsafe but we need it to be public and\n             // calling it with a non-unique `tag` would allow arena mixups,\n             // which may introduce UB in `Index`/`IndexMut`\n-            $crate::SmallArena::new(&mut tag, $cap)\n+            $crate::SmallArena::new(tag, $cap)\n         };\n+        // this doesn't make it to MIR, but ensures that borrowck will not\n+        // unify the lifetimes of two macro calls by binding the lifetime to\n+        // drop scope\n+        if false {\n+            struct Guard<'tag>(&'tag $crate::InvariantLifetime<'tag>);\n+            impl<'tag> ::core::ops::Drop for Guard<'tag> {\n+                fn drop(&mut self) { }\n+            }\n+            _guard = Guard(&tag);\n+        }\n     };\n }\n \n@@ -244,13 +265,24 @@ macro_rules! in_arena {\n #[macro_export]\n macro_rules! mk_tiny_arena {\n     ($name:ident) => {\n-        let mut tag = ();\n+        let tag = $crate::invariant_lifetime();\n+        let _guard;\n         let mut $name = unsafe {\n             // this is not per-se unsafe but we need it to be public and\n             // calling it with a non-unique `tag` would allow arena mixups,\n             // which may introduce UB in `Index`/`IndexMut`\n-            $crate::TinyArena::new(&mut tag)\n+            $crate::TinyArena::new(tag)\n         };\n+        // this doesn't make it to MIR, but ensures that borrowck will not\n+        // unify the lifetimes of two macro calls by binding the lifetime to\n+        // drop scope\n+        if false {\n+            struct Guard<'tag>(&'tag $crate::InvariantLifetime<'tag>);\n+            impl<'tag> ::core::ops::Drop for Guard<'tag> {\n+                fn drop(&mut self) { }\n+            }\n+            _guard = Guard(&tag);\n+        }\n     };\n }\n \n@@ -289,13 +321,24 @@ macro_rules! in_tiny_arena {\n #[macro_export]\n macro_rules! mk_nano_arena {\n     ($name:ident) => {\n-        let mut tag = ();\n+        let tag = $crate::invariant_lifetime();\n+        let _guard;\n         let mut $name = unsafe {\n             // this is not per-se unsafe but we need it to be public and\n             // calling it with a non-unique `tag` would allow arena mixups,\n             // which may introduce UB in `Index`/`IndexMut`\n-            $crate::NanoArena::new(&mut tag)\n+            $crate::NanoArena::new(tag)\n         };\n+        // this doesn't make it to MIR, but ensures that borrowck will not\n+        // unify the lifetimes of two macro calls by binding the lifetime to\n+        // drop scope\n+        if false {\n+            struct Guard<'tag>(&'tag $crate::InvariantLifetime<'tag>);\n+            impl<'tag> ::core::ops::Drop for Guard<'tag> {\n+                fn drop(&mut self) { }\n+            }\n+            _guard = Guard(&tag);\n+        }\n     };\n }\n \n@@ -331,9 +374,9 @@ impl<'tag, T> SmallArena<'tag, T> {\n     /// constructor. You must never use this value in another arena, lest you\n     /// might be able to mix up the indices of the two, which could lead to\n     /// out of bounds access and thus **Undefined Behavior**!\n-    pub unsafe fn new(_: &'tag mut (), capacity: usize) -> Self {\n+    pub unsafe fn new(tag: InvariantLifetime<'tag>, capacity: usize) -> Self {\n         SmallArena {\n-            tag: InvariantLifetime(PhantomData),\n+            tag,\n             data: Vec::with_capacity(capacity),\n         }\n     }\n@@ -394,7 +437,6 @@ pub use tiny_arena::{TinyArena, NanoArena};\n mod tiny_arena {\n     use crate::{CapacityExceeded, Idx16, Idx8, InvariantLifetime,\n                 TINY_ARENA_ITEMS, NANO_ARENA_ITEMS};\n-    use core::marker::PhantomData;\n \n     /// A \"tiny\" arena containing up to 65536 elements. This variant only works with\n     /// types implementing `Default`.\n@@ -416,9 +458,9 @@ mod tiny_arena {\n         /// this constructor. You must never use this value in another arena,\n         /// lest you might be able to mix up the indices of the two, which\n         /// could lead to out of bounds access and thus **Undefined Behavior**!\n-        pub unsafe fn new(_: &'tag mut ()) -> TinyArena<'tag, T> {\n+        pub unsafe fn new(tag: InvariantLifetime<'tag>) -> TinyArena<'tag, T> {\n             TinyArena {\n-                tag: InvariantLifetime(PhantomData),\n+                tag,\n                 data: [Default::default(); TINY_ARENA_ITEMS as usize],\n                 len: 0\n             }\n@@ -463,9 +505,9 @@ mod tiny_arena {\n         /// this constructor. You must never use this value in another arena,\n         /// lest you might be able to mix up the indices of the two, which\n         /// could lead to out of bounds access and thus **Undefined Behavior**!\n-        pub unsafe fn new(_: &'tag mut ()) -> NanoArena<'tag, T> {\n+        pub unsafe fn new(tag: InvariantLifetime<'tag>) -> NanoArena<'tag, T> {\n             NanoArena {\n-                tag: InvariantLifetime(PhantomData),\n+                tag,\n                 data: [Default::default(); NANO_ARENA_ITEMS as usize],\n                 len: 0\n             }\n@@ -495,7 +537,6 @@ mod tiny_arena {\n mod tiny_arena {\n     use crate::{CapacityExceeded, Idx16, Idx8, InvariantLifetime,\n                 TINY_ARENA_ITEMS, NANO_ARENA_ITEMS};\n-    use core::marker::PhantomData;\n     use core::mem::{self, ManuallyDrop};\n     use core::ptr;\n \n@@ -508,9 +549,9 @@ mod tiny_arena {\n \n     impl<'tag, T> TinyArena<'tag, T> {\n         /// create a new TinyArena\n-        pub unsafe fn new(_: &'tag mut ()) -> TinyArena<'tag, T> {\n+        pub unsafe fn new(tag: InvariantLifetime<'tag>) -> TinyArena<'tag, T> {\n             TinyArena {\n-                tag: InvariantLifetime(PhantomData),\n+                tag,\n                 data: mem::uninitialized(),\n                 len: 0\n             }\n@@ -566,9 +607,9 @@ mod tiny_arena {\n         /// this constructor. You must never use this value in another arena,\n         /// lest you might be able to mix up the indices of the two, which\n         /// could lead to out of bounds access and thus **Undefined Behavior**!\n-        pub unsafe fn new(_: &'tag mut ()) -> NanoArena<'tag, T> {\n+        pub unsafe fn new(tag: InvariantLifetime<'tag>) -> NanoArena<'tag, T> {\n             NanoArena {\n-                tag: InvariantLifetime(PhantomData),\n+                tag,\n                 data: mem::uninitialized(),\n                 len: 0,\n             }\n",
    "diff_parsed": "{'added': [(88, \"pub struct InvariantLifetime<'a>(PhantomData<fn(&'a ()) -> &'a ()>);\"), (93, \"pub fn invariant_lifetime<'tag>() -> InvariantLifetime<'tag> {\"), (94, '    InvariantLifetime(PhantomData)'), (95, '}'), (214, '        let tag = $crate::invariant_lifetime();'), (215, '        let _guard;'), (220, '            $crate::SmallArena::new(tag, $cap)'), (225, '        if false {'), (226, \"            struct Guard<'tag>(&'tag $crate::InvariantLifetime<'tag>);\"), (227, \"            impl<'tag> ::core::ops::Drop for Guard<'tag> {\"), (228, '                fn drop(&mut self) { }'), (229, '            }'), (230, '            _guard = Guard(&tag);'), (231, '        }'), (268, '        let tag = $crate::invariant_lifetime();'), (269, '        let _guard;'), (274, '            $crate::TinyArena::new(tag)'), (279, '        if false {'), (280, \"            struct Guard<'tag>(&'tag $crate::InvariantLifetime<'tag>);\"), (281, \"            impl<'tag> ::core::ops::Drop for Guard<'tag> {\"), (282, '                fn drop(&mut self) { }'), (283, '            }'), (284, '            _guard = Guard(&tag);'), (285, '        }'), (324, '        let tag = $crate::invariant_lifetime();'), (325, '        let _guard;'), (330, '            $crate::NanoArena::new(tag)'), (335, '        if false {'), (336, \"            struct Guard<'tag>(&'tag $crate::InvariantLifetime<'tag>);\"), (337, \"            impl<'tag> ::core::ops::Drop for Guard<'tag> {\"), (338, '                fn drop(&mut self) { }'), (339, '            }'), (340, '            _guard = Guard(&tag);'), (341, '        }'), (377, \"    pub unsafe fn new(tag: InvariantLifetime<'tag>, capacity: usize) -> Self {\"), (379, '            tag,'), (461, \"        pub unsafe fn new(tag: InvariantLifetime<'tag>) -> TinyArena<'tag, T> {\"), (463, '                tag,'), (508, \"        pub unsafe fn new(tag: InvariantLifetime<'tag>) -> NanoArena<'tag, T> {\"), (510, '                tag,'), (552, \"        pub unsafe fn new(tag: InvariantLifetime<'tag>) -> TinyArena<'tag, T> {\"), (554, '                tag,'), (610, \"        pub unsafe fn new(tag: InvariantLifetime<'tag>) -> NanoArena<'tag, T> {\"), (612, '                tag,')], 'deleted': [(85, \"struct InvariantLifetime<'a>(PhantomData<fn(&'a ()) -> &'a ()>);\"), (204, '        let mut tag = ();'), (209, '            $crate::SmallArena::new(&mut tag, $cap)'), (247, '        let mut tag = ();'), (252, '            $crate::TinyArena::new(&mut tag)'), (292, '        let mut tag = ();'), (297, '            $crate::NanoArena::new(&mut tag)'), (334, \"    pub unsafe fn new(_: &'tag mut (), capacity: usize) -> Self {\"), (336, '            tag: InvariantLifetime(PhantomData),'), (397, '    use core::marker::PhantomData;'), (419, \"        pub unsafe fn new(_: &'tag mut ()) -> TinyArena<'tag, T> {\"), (421, '                tag: InvariantLifetime(PhantomData),'), (466, \"        pub unsafe fn new(_: &'tag mut ()) -> NanoArena<'tag, T> {\"), (468, '                tag: InvariantLifetime(PhantomData),'), (498, '    use core::marker::PhantomData;'), (511, \"        pub unsafe fn new(_: &'tag mut ()) -> TinyArena<'tag, T> {\"), (513, '                tag: InvariantLifetime(PhantomData),'), (569, \"        pub unsafe fn new(_: &'tag mut ()) -> NanoArena<'tag, T> {\"), (571, '                tag: InvariantLifetime(PhantomData),')]}",
    "num_lines_added": "44",
    "num_lines_deleted": "19",
    "nloc": "452"
  },
  {
    "file_change_id": "209779458031992",
    "hash": "eb413b3d47baea8e8a0b9ce2ccd8299b354d3b7",
    "old_path": "tests/threads.rs",
    "new_path": "tests/threads.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -5,7 +5,8 @@ use crossbeam_utils::thread::scope;\n \n // With crossbeam's `scope`d threads, it is even possible to share an arena\n // and its indices between multiple threads.\n-fn main() {\n+#[test]\n+fn test_scoped_arena() {\n     mk_nano_arena!(arena);\n     let i = arena.add(1usize);\n     let v = scope(|s| {\n",
    "diff_parsed": "{'added': [(8, '#[test]'), (9, 'fn test_scoped_arena() {')], 'deleted': [(8, 'fn main() {')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "1",
    "nloc": "16"
  },
  {
    "file_change_id": "114072149675424",
    "hash": "1e462c32e7933821ddb26dc49fd4ffa5aeca97b",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -76,9 +76,9 @@ impl<T> Drop for QueueSender<T> {\n     }\n }\n \n-unsafe impl<T> Sync for QueueSender<T> {}\n+unsafe impl<T: Send> Sync for QueueSender<T> {}\n \n-unsafe impl<T> Send for QueueSender<T> {}\n+unsafe impl<T: Send> Send for QueueSender<T> {}\n \n /// A `QueueReceiver` is used to pop previously\n /// pushed items from the queue.\n@@ -181,7 +181,7 @@ impl<T> Drop for QueueReceiver<T> {\n     }\n }\n \n-unsafe impl<T> Send for QueueReceiver<T> {}\n+unsafe impl<T: Send> Send for QueueReceiver<T> {}\n \n pub struct Queue;\n \n",
    "diff_parsed": "{'added': [(79, 'unsafe impl<T: Send> Sync for QueueSender<T> {}'), (81, 'unsafe impl<T: Send> Send for QueueSender<T> {}'), (184, 'unsafe impl<T: Send> Send for QueueReceiver<T> {}')], 'deleted': [(79, 'unsafe impl<T> Sync for QueueSender<T> {}'), (81, 'unsafe impl<T> Send for QueueSender<T> {}'), (184, 'unsafe impl<T> Send for QueueReceiver<T> {}')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "3",
    "nloc": "295"
  },
  {
    "file_change_id": "225654481973054",
    "hash": "416a2d480547f6b88ef6d23aa34b1fea292f65f",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -684,7 +684,7 @@ impl<K: Hash + Eq, V, S: BuildHasher> LruCache<K, V, S> {\n     }\n \n     /// An iterator visiting all entries in most-recently used order. The iterator element type is\n-    /// `(&'a K, &'a V)`.\n+    /// `(&K, &V)`.\n     ///\n     /// # Examples\n     ///\n@@ -700,7 +700,7 @@ impl<K: Hash + Eq, V, S: BuildHasher> LruCache<K, V, S> {\n     ///     println!(\"key: {} val: {}\", key, val);\n     /// }\n     /// ```\n-    pub fn iter<'a>(&'_ self) -> Iter<'a, K, V> {\n+    pub fn iter(&self) -> Iter<'_, K, V> {\n         Iter {\n             len: self.len(),\n             ptr: unsafe { (*self.head).next },\n@@ -710,7 +710,7 @@ impl<K: Hash + Eq, V, S: BuildHasher> LruCache<K, V, S> {\n     }\n \n     /// An iterator visiting all entries in most-recently-used order, giving a mutable reference on\n-    /// V.  The iterator element type is `(&'a K, &'a mut V)`.\n+    /// V.  The iterator element type is `(&K, &mut V)`.\n     ///\n     /// # Examples\n     ///\n@@ -735,7 +735,7 @@ impl<K: Hash + Eq, V, S: BuildHasher> LruCache<K, V, S> {\n     ///     }\n     /// }\n     /// ```\n-    pub fn iter_mut<'a>(&'_ mut self) -> IterMut<'a, K, V> {\n+    pub fn iter_mut(&mut self) -> IterMut<'_, K, V> {\n         IterMut {\n             len: self.len(),\n             ptr: unsafe { (*self.head).next },\n",
    "diff_parsed": "{'added': [(703, \"    pub fn iter(&self) -> Iter<'_, K, V> {\"), (738, \"    pub fn iter_mut(&mut self) -> IterMut<'_, K, V> {\")], 'deleted': [(703, \"    pub fn iter<'a>(&'_ self) -> Iter<'a, K, V> {\"), (738, \"    pub fn iter_mut<'a>(&'_ mut self) -> IterMut<'a, K, V> {\")]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "1065"
  },
  {
    "file_change_id": "89082207400243",
    "hash": "3850b645a89666f3efa84c47fad17976e4702c0",
    "old_path": "crates/server/src/store/file/authority.rs",
    "new_path": "crates/server/src/store/file/authority.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -92,6 +92,7 @@ impl FileAuthority {\n             origin,\n             records.len()\n         );\n+        debug!(\"zone: {:#?}\", records);\n \n         FileAuthority::new(origin, records, zone_type, allow_axfr)\n     }\n",
    "diff_parsed": "{'added': [(95, '        debug!(\"zone: {:#?}\", records);')], 'deleted': []}",
    "num_lines_added": "1",
    "num_lines_deleted": "0",
    "nloc": "178"
  },
  {
    "file_change_id": "86723067112353",
    "hash": "3850b645a89666f3efa84c47fad17976e4702c0",
    "old_path": "crates/server/src/store/in_memory/authority.rs",
    "new_path": "crates/server/src/store/in_memory/authority.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -227,7 +227,8 @@ impl InMemoryAuthority {\n         and_rrsigs: bool,\n         supported_algorithms: SupportedAlgorithms,\n     ) -> Option<Arc<RecordSet>> {\n-        let wildcard = if name.is_wildcard() {\n+        // if this is a wildcard or a root, both should break continued lookups\n+        let wildcard = if name.is_wildcard() || name.is_root() {\n             return None;\n         } else {\n             name.clone().into_wildcard()\n",
    "diff_parsed": "{'added': [(231, '        let wildcard = if name.is_wildcard() || name.is_root() {')], 'deleted': [(230, '        let wildcard = if name.is_wildcard() {')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "773"
  },
  {
    "file_change_id": "189351705962114",
    "hash": "3850b645a89666f3efa84c47fad17976e4702c0",
    "old_path": "crates/server/tests/authority_battery/basic.rs",
    "new_path": "crates/server/tests/authority_battery/basic.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -146,6 +146,29 @@ pub fn test_mx<A: Authority<Lookup = AuthLookup>>(authority: A) {\n     assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), *aaaa);\n }\n \n+pub fn test_mx_to_null<A: Authority<Lookup = AuthLookup>>(authority: A) {\n+    let query = Query::query(\n+        Name::from_str(\"no-service.example.com.\").unwrap(),\n+        RecordType::MX,\n+    );\n+\n+    let mut lookup =\n+        block_on(authority.search(&query.into(), false, SupportedAlgorithms::new())).unwrap();\n+\n+    // In this case there should be no additional records\n+    assert!(lookup.take_additionals().is_none());\n+\n+    let mx = lookup\n+        .into_iter()\n+        .next()\n+        .expect(\"MX record not found in authority\")\n+        .rdata()\n+        .as_mx()\n+        .expect(\"Not an MX record\");\n+\n+    assert_eq!(Name::from_str(\".\").unwrap(), *mx.exchange());\n+}\n+\n pub fn test_cname<A: Authority<Lookup = AuthLookup>>(authority: A) {\n     let query = Query::query(\n         Name::from_str(\"alias.example.com.\").unwrap(),\n@@ -565,6 +588,9 @@ macro_rules! define_basic_test {\n         $(\n             #[test]\n             fn $f () {\n+                // Useful for getting debug logs\n+                // env_logger::init();\n+\n                 let authority = crate::$new(\"../../tests/test-data/named_test_configs/example.com.zone\", module_path!(), stringify!($f));\n                 crate::authority_battery::basic::$f(authority);\n             }\n@@ -583,6 +609,7 @@ macro_rules! basic_battery {\n                     test_ns,\n                     test_ns_lookup,\n                     test_mx,\n+                    test_mx_to_null,\n                     test_cname,\n                     test_cname_alias,\n                     test_cname_chain,\n",
    "diff_parsed": "{'added': [(149, 'pub fn test_mx_to_null<A: Authority<Lookup = AuthLookup>>(authority: A) {'), (150, '    let query = Query::query('), (151, '        Name::from_str(\"no-service.example.com.\").unwrap(),'), (152, '        RecordType::MX,'), (153, '    );'), (155, '    let mut lookup ='), (156, '        block_on(authority.search(&query.into(), false, SupportedAlgorithms::new())).unwrap();'), (159, '    assert!(lookup.take_additionals().is_none());'), (161, '    let mx = lookup'), (162, '        .into_iter()'), (163, '        .next()'), (164, '        .expect(\"MX record not found in authority\")'), (165, '        .rdata()'), (166, '        .as_mx()'), (167, '        .expect(\"Not an MX record\");'), (169, '    assert_eq!(Name::from_str(\".\").unwrap(), *mx.exchange());'), (170, '}'), (612, '                    test_mx_to_null,')], 'deleted': []}",
    "num_lines_added": "18",
    "num_lines_deleted": "0",
    "nloc": "494"
  },
  {
    "file_change_id": "114561920173863",
    "hash": "565d508993936821950009ec4c7c1e33301db81",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -159,12 +159,16 @@ macro_rules! impl_arrays {\n         $(\n         impl<T: Random> Random for [T; $s] {\n             fn random() -> Self {\n+                use std::mem::{MaybeUninit, transmute_copy, size_of};\n                 unsafe {\n-                    let mut array: [T; $s] = std::mem::uninitialized();\n-                    for i in 0..$s {\n-                        std::ptr::write(&mut array[i], T::random());\n+                    let mut array: [MaybeUninit<T>; $s] = MaybeUninit::uninit().assume_init();\n+                    for elem in &mut array[..] {\n+                        *elem = MaybeUninit::new(T::random());\n                     }\n-                    array\n+\n+                    // See https://github.com/rust-lang/rust/issues/47966\n+                    debug_assert!(size_of::<[MaybeUninit<T>; $s]>() == size_of::<[T; $s]>());\n+                    transmute_copy::<_, [T; $s]>(&array)\n                 }\n             }\n         }\n",
    "diff_parsed": "{'added': [(162, '                use std::mem::{MaybeUninit, transmute_copy, size_of};'), (164, '                    let mut array: [MaybeUninit<T>; $s] = MaybeUninit::uninit().assume_init();'), (165, '                    for elem in &mut array[..] {'), (166, '                        *elem = MaybeUninit::new(T::random());'), (170, '                    debug_assert!(size_of::<[MaybeUninit<T>; $s]>() == size_of::<[T; $s]>());'), (171, '                    transmute_copy::<_, [T; $s]>(&array)')], 'deleted': [(163, '                    let mut array: [T; $s] = std::mem::uninitialized();'), (164, '                    for i in 0..$s {'), (165, '                        std::ptr::write(&mut array[i], T::random());'), (167, '                    array')]}",
    "num_lines_added": "6",
    "num_lines_deleted": "4",
    "nloc": "217"
  },
  {
    "file_change_id": "232158534616821",
    "hash": "15b282877d1e576de2b337d8162bbf43ed1a0f2",
    "old_path": "syncpool/src/bucket.rs",
    "new_path": "syncpool/src/bucket.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -333,7 +333,7 @@ impl<T> Drop for Bucket2<T> {\n     }\n }\n \n-unsafe impl<T> Send for Bucket2<T> {}\n+unsafe impl<T: Send> Send for Bucket2<T> {}\n \n pub(crate) struct RingBucket<T> {\n     /// The actual data store. Data are stored in heap and not managed by the runtime, so we must\n",
    "diff_parsed": "{'added': [(336, 'unsafe impl<T: Send> Send for Bucket2<T> {}')], 'deleted': [(336, 'unsafe impl<T> Send for Bucket2<T> {}')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "196"
  },
  {
    "file_change_id": "104100910063778",
    "hash": "a34d6e10f6f5654ed01a35288cf683d014ebc9c",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -33,7 +33,7 @@ where\n \n unsafe impl<R> Send for Decoder<R>\n where\n-        R: Read,\n+        R: Read + Send,\n {\n }\n \n",
    "diff_parsed": "{'added': [(36, '        R: Read + Send,')], 'deleted': [(36, '        R: Read,')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "109"
  },
  {
    "file_change_id": "179280840825427",
    "hash": "8e6daabbc6fb14972a9db5fc94f06801b2d41c2",
    "old_path": "metrics-util/src/bucket.rs",
    "new_path": "metrics-util/src/bucket.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -96,8 +96,8 @@ impl<T> Block<T> {\n     }\n }\n \n-unsafe impl<T> Send for Block<T> {}\n-unsafe impl<T> Sync for Block<T> {}\n+unsafe impl<T: Send> Send for Block<T> {}\n+unsafe impl<T: Sync> Sync for Block<T> {}\n \n impl<T> std::fmt::Debug for Block<T> {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n",
    "diff_parsed": "{'added': [(99, 'unsafe impl<T: Send> Send for Block<T> {}'), (100, 'unsafe impl<T: Sync> Sync for Block<T> {}')], 'deleted': [(99, 'unsafe impl<T> Send for Block<T> {}'), (100, 'unsafe impl<T> Sync for Block<T> {}')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "409"
  },
  {
    "file_change_id": "78569255007772",
    "hash": "5ba266a853bc8232993c84fe736cb87241f9506",
    "old_path": "protocols/deflate/src/lib.rs",
    "new_path": "protocols/deflate/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -133,10 +133,7 @@ impl<S> AsyncRead for DeflateOutput<S>\n         loop {\n             // Read from `self.inner` into `self.read_interm` if necessary.\n             if this.read_interm.is_empty() && !this.inner_read_eof {\n-                unsafe {\n-                    this.read_interm.reserve(256);\n-                    this.read_interm.set_len(this.read_interm.capacity());\n-                }\n+                this.read_interm.resize(this.read_interm.capacity() + 256, 0);\n \n                 match AsyncRead::poll_read(Pin::new(&mut this.inner), cx, &mut this.read_interm) {\n                     Poll::Ready(Ok(0)) => {\n",
    "diff_parsed": "{'added': [(136, '                this.read_interm.resize(this.read_interm.capacity() + 256, 0);')], 'deleted': [(136, '                unsafe {'), (137, '                    this.read_interm.reserve(256);'), (138, '                    this.read_interm.set_len(this.read_interm.capacity());'), (139, '                }')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "4",
    "nloc": "188"
  },
  {
    "file_change_id": "160538942802745",
    "hash": "1f3709632dccdfd49cbcb152a2f81b95c0b1a3e",
    "old_path": "src/rayon/map.rs",
    "new_path": "src/rayon/map.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -149,7 +149,7 @@ where\n                 let guard = Arc::new(guard);\n                 sref.iter().map(move |(k, v)| {\n                     let guard = Arc::clone(&guard);\n-                    RefMulti::new(guard, k, v.get())\n+                    unsafe { RefMulti::new(guard, k, v.get()) }\n                 })\n             })\n             .drive_unindexed(consumer)\n@@ -213,7 +213,7 @@ where\n                 let guard = Arc::new(guard);\n                 sref.iter_mut().map(move |(k, v)| {\n                     let guard = Arc::clone(&guard);\n-                    RefMutMulti::new(guard, k, v.get_mut())\n+                    unsafe { RefMutMulti::new(guard, k, v.get_mut()) }\n                 })\n             })\n             .drive_unindexed(consumer)\n",
    "diff_parsed": "{'added': [(152, '                    unsafe { RefMulti::new(guard, k, v.get()) }'), (216, '                    unsafe { RefMutMulti::new(guard, k, v.get_mut()) }')], 'deleted': [(152, '                    RefMulti::new(guard, k, v.get())'), (216, '                    RefMutMulti::new(guard, k, v.get_mut())')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "198"
  },
  {
    "file_change_id": "47055322476765",
    "hash": "fbb6ffb1d70ae520889062728476d7d607c9309e",
    "old_path": "src/mapref/entry.rs",
    "new_path": "src/mapref/entry.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -28,7 +28,7 @@ impl<'a, K: Eq + Hash, V, S: BuildHasher> Entry<'a, K, V, S> {\n     }\n \n     /// Get the key of the entry.\n-    pub fn key(&self) -> &K {\n+    pub fn key<'r>(&'r self) -> &'r K {\n         match *self {\n             Entry::Occupied(ref entry) => entry.key(),\n             Entry::Vacant(ref entry) => entry.key(),\n@@ -125,7 +125,7 @@ impl<'a, K: Eq + Hash, V, S: BuildHasher> VacantEntry<'a, K, V, S> {\n         self.key\n     }\n \n-    pub fn key(&self) -> &K {\n+    pub fn key<'r>(&'r self) -> &'r K {\n         &self.key\n     }\n }\n@@ -152,11 +152,11 @@ impl<'a, K: Eq + Hash, V, S: BuildHasher> OccupiedEntry<'a, K, V, S> {\n         Self { shard, elem, key }\n     }\n \n-    pub fn get(&self) -> &V {\n+    pub fn get<'r>(&'r self) -> &'r V {\n         self.elem.1\n     }\n \n-    pub fn get_mut(&mut self) -> &mut V {\n+    pub fn get_mut<'r>(&'r mut self) -> &'r mut V {\n         self.elem.1\n     }\n \n@@ -172,7 +172,7 @@ impl<'a, K: Eq + Hash, V, S: BuildHasher> OccupiedEntry<'a, K, V, S> {\n         self.key\n     }\n \n-    pub fn key(&self) -> &K {\n+    pub fn key<'r>(&'r self) -> &'r K {\n         self.elem.0\n     }\n \n",
    "diff_parsed": "{'added': [(31, \"    pub fn key<'r>(&'r self) -> &'r K {\"), (128, \"    pub fn key<'r>(&'r self) -> &'r K {\"), (155, \"    pub fn get<'r>(&'r self) -> &'r V {\"), (159, \"    pub fn get_mut<'r>(&'r mut self) -> &'r mut V {\"), (175, \"    pub fn key<'r>(&'r self) -> &'r K {\")], 'deleted': [(31, '    pub fn key(&self) -> &K {'), (128, '    pub fn key(&self) -> &K {'), (155, '    pub fn get(&self) -> &V {'), (159, '    pub fn get_mut(&mut self) -> &mut V {'), (175, '    pub fn key(&self) -> &K {')]}",
    "num_lines_added": "5",
    "num_lines_deleted": "5",
    "nloc": "166"
  },
  {
    "file_change_id": "91301242923059",
    "hash": "fbb6ffb1d70ae520889062728476d7d607c9309e",
    "old_path": "src/mapref/multiple.rs",
    "new_path": "src/mapref/multiple.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -6,7 +6,6 @@ use parking_lot::{RwLockReadGuard, RwLockWriteGuard};\n use std::collections::hash_map::RandomState;\n use std::sync::Arc;\n \n-// -- Shared\n pub struct RefMulti<'a, K, V, S = RandomState> {\n     _guard: Arc<RwLockReadGuard<'a, HashMap<K, V, S>>>,\n     k: &'a K,\n@@ -33,15 +32,15 @@ impl<'a, K: Eq + Hash, V, S: BuildHasher> RefMulti<'a, K, V, S> {\n         }\n     }\n \n-    pub fn key(&self) -> &'a K {\n+    pub fn key<'r>(&'r self) -> &'r K {\n         self.k\n     }\n \n-    pub fn value(&self) -> &'a V {\n+    pub fn value<'r>(&'r self) -> &'r V {\n         self.v\n     }\n \n-    pub fn pair(&self) -> (&'a K, &'a V) {\n+    pub fn pair<'r>(&'r self) -> (&'r K, &'r V) {\n         (self.k, self.v)\n     }\n }\n@@ -54,8 +53,6 @@ impl<'a, K: Eq + Hash, V, S: BuildHasher> Deref for RefMulti<'a, K, V, S> {\n     }\n }\n \n-// --\n-// -- Unique\n pub struct RefMutMulti<'a, K, V, S = RandomState> {\n     _guard: Arc<RwLockWriteGuard<'a, HashMap<K, V, S>>>,\n     k: &'a K,\n@@ -82,23 +79,23 @@ impl<'a, K: Eq + Hash, V, S: BuildHasher> RefMutMulti<'a, K, V, S> {\n         }\n     }\n \n-    pub fn key(&self) -> &'a K {\n+    pub fn key<'r>(&'r self) -> &'r K {\n         self.k\n     }\n \n-    pub fn value(&self) -> &V {\n+    pub fn value<'r>(&'r self) -> &'r V {\n         self.v\n     }\n \n-    pub fn value_mut(&mut self) -> &mut V {\n+    pub fn value_mut<'r>(&'r mut self) -> &'r mut V {\n         self.v\n     }\n \n-    pub fn pair(&self) -> (&'a K, &V) {\n+    pub fn pair<'r>(&'r self) -> (&'r K, &'r V) {\n         (self.k, self.v)\n     }\n \n-    pub fn pair_mut(&mut self) -> (&'a K, &mut V) {\n+    pub fn pair_mut<'r>(&'r mut self) -> (&'r K, &'r mut V) {\n         (self.k, self.v)\n     }\n }\n@@ -116,5 +113,3 @@ impl<'a, K: Eq + Hash, V, S: BuildHasher> DerefMut for RefMutMulti<'a, K, V, S>\n         self.value_mut()\n     }\n }\n-\n-// --\n",
    "diff_parsed": "{'added': [(35, \"    pub fn key<'r>(&'r self) -> &'r K {\"), (39, \"    pub fn value<'r>(&'r self) -> &'r V {\"), (43, \"    pub fn pair<'r>(&'r self) -> (&'r K, &'r V) {\"), (82, \"    pub fn key<'r>(&'r self) -> &'r K {\"), (86, \"    pub fn value<'r>(&'r self) -> &'r V {\"), (90, \"    pub fn value_mut<'r>(&'r mut self) -> &'r mut V {\"), (94, \"    pub fn pair<'r>(&'r self) -> (&'r K, &'r V) {\"), (98, \"    pub fn pair_mut<'r>(&'r mut self) -> (&'r K, &'r mut V) {\")], 'deleted': [(36, \"    pub fn key(&self) -> &'a K {\"), (40, \"    pub fn value(&self) -> &'a V {\"), (44, \"    pub fn pair(&self) -> (&'a K, &'a V) {\"), (85, \"    pub fn key(&self) -> &'a K {\"), (89, '    pub fn value(&self) -> &V {'), (93, '    pub fn value_mut(&mut self) -> &mut V {'), (97, \"    pub fn pair(&self) -> (&'a K, &V) {\"), (101, \"    pub fn pair_mut(&mut self) -> (&'a K, &mut V) {\")]}",
    "num_lines_added": "8",
    "num_lines_deleted": "8",
    "nloc": "108"
  },
  {
    "file_change_id": "87076986701541",
    "hash": "fbb6ffb1d70ae520889062728476d7d607c9309e",
    "old_path": "src/mapref/one.rs",
    "new_path": "src/mapref/one.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -4,7 +4,6 @@ use core::ops::{Deref, DerefMut};\n use parking_lot::{RwLockReadGuard, RwLockWriteGuard};\n use std::collections::hash_map::RandomState;\n \n-// -- Shared\n pub struct Ref<'a, K, V, S = RandomState> {\n     _guard: RwLockReadGuard<'a, HashMap<K, V, S>>,\n     k: &'a K,\n@@ -27,15 +26,15 @@ impl<'a, K: Eq + Hash, V, S: BuildHasher> Ref<'a, K, V, S> {\n         }\n     }\n \n-    pub fn key(&self) -> &'a K {\n+    pub fn key<'r>(&'r self) -> &'r K {\n         self.k\n     }\n \n-    pub fn value(&self) -> &'a V {\n+    pub fn value<'r>(&'r self) -> &'r V {\n         self.v\n     }\n \n-    pub fn pair(&self) -> (&'a K, &'a V) {\n+    pub fn pair<'r>(&'r self) -> (&'r K, &'r V) {\n         (self.k, self.v)\n     }\n }\n@@ -48,8 +47,6 @@ impl<'a, K: Eq + Hash, V, S: BuildHasher> Deref for Ref<'a, K, V, S> {\n     }\n }\n \n-// --\n-// -- Unique\n pub struct RefMut<'a, K, V, S = RandomState> {\n     guard: RwLockWriteGuard<'a, HashMap<K, V, S>>,\n     k: &'a K,\n@@ -72,23 +69,23 @@ impl<'a, K: Eq + Hash, V, S: BuildHasher> RefMut<'a, K, V, S> {\n         Self { guard, k, v }\n     }\n \n-    pub fn key(&self) -> &'a K {\n+    pub fn key<'r>(&'r self) -> &'r K {\n         self.k\n     }\n \n-    pub fn value(&self) -> &V {\n+    pub fn value<'r>(&'r self) -> &'r V {\n         self.v\n     }\n \n-    pub fn value_mut(&mut self) -> &mut V {\n+    pub fn value_mut<'r>(&'r mut self) -> &'r mut V {\n         self.v\n     }\n \n-    pub fn pair(&self) -> (&'a K, &V) {\n+    pub fn pair<'r>(&'r self) -> (&'r K, &'r V) {\n         (self.k, self.v)\n     }\n \n-    pub fn pair_mut(&mut self) -> (&'a K, &mut V) {\n+    pub fn pair_mut<'r>(&'r mut self) -> (&'r K, &'r mut V) {\n         (self.k, self.v)\n     }\n \n@@ -114,5 +111,3 @@ impl<'a, K: Eq + Hash, V, S: BuildHasher> DerefMut for RefMut<'a, K, V, S> {\n         self.value_mut()\n     }\n }\n-\n-// --\n",
    "diff_parsed": "{'added': [(29, \"    pub fn key<'r>(&'r self) -> &'r K {\"), (33, \"    pub fn value<'r>(&'r self) -> &'r V {\"), (37, \"    pub fn pair<'r>(&'r self) -> (&'r K, &'r V) {\"), (72, \"    pub fn key<'r>(&'r self) -> &'r K {\"), (76, \"    pub fn value<'r>(&'r self) -> &'r V {\"), (80, \"    pub fn value_mut<'r>(&'r mut self) -> &'r mut V {\"), (84, \"    pub fn pair<'r>(&'r self) -> (&'r K, &'r V) {\"), (88, \"    pub fn pair_mut<'r>(&'r mut self) -> (&'r K, &'r mut V) {\")], 'deleted': [(30, \"    pub fn key(&self) -> &'a K {\"), (34, \"    pub fn value(&self) -> &'a V {\"), (38, \"    pub fn pair(&self) -> (&'a K, &'a V) {\"), (75, \"    pub fn key(&self) -> &'a K {\"), (79, '    pub fn value(&self) -> &V {'), (83, '    pub fn value_mut(&mut self) -> &mut V {'), (87, \"    pub fn pair(&self) -> (&'a K, &V) {\"), (91, \"    pub fn pair_mut(&mut self) -> (&'a K, &mut V) {\")]}",
    "num_lines_added": "8",
    "num_lines_deleted": "8",
    "nloc": "103"
  },
  {
    "file_change_id": "79712098488626",
    "hash": "fbb6ffb1d70ae520889062728476d7d607c9309e",
    "old_path": "src/setref/multiple.rs",
    "new_path": "src/setref/multiple.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -11,7 +11,7 @@ impl<'a, K: Eq + Hash, S: BuildHasher> RefMulti<'a, K, S> {\n         Self { inner }\n     }\n \n-    pub fn key(&self) -> &'a K {\n+    pub fn key<'r>(&'r self) -> &'r K {\n         self.inner.key()\n     }\n }\n",
    "diff_parsed": "{'added': [(14, \"    pub fn key<'r>(&'r self) -> &'r K {\")], 'deleted': [(14, \"    pub fn key(&self) -> &'a K {\")]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "22"
  },
  {
    "file_change_id": "208275918209448",
    "hash": "fbb6ffb1d70ae520889062728476d7d607c9309e",
    "old_path": "src/setref/one.rs",
    "new_path": "src/setref/one.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -15,7 +15,7 @@ impl<'a, K: Eq + Hash, S: BuildHasher> Ref<'a, K, S> {\n         Self { inner }\n     }\n \n-    pub fn key(&self) -> &'a K {\n+    pub fn key<'r>(&'r self) -> &'r K {\n         self.inner.key()\n     }\n }\n",
    "diff_parsed": "{'added': [(18, \"    pub fn key<'r>(&'r self) -> &'r K {\")], 'deleted': [(18, \"    pub fn key(&self) -> &'a K {\")]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "24"
  },
  {
    "file_change_id": "110824705955354",
    "hash": "b0d2bd20eb40b9cbc2958b981ba2dcd9e6f9396",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -81,8 +81,10 @@ pub struct Singleton<T: 'static> {\n \n // The Singleton need to implement Send & Sync to ensure cross core compile check mechanics\n // this is safe as the inner RWLock ensures cross core safety\n-unsafe impl<T> Sync for Singleton<T> {}\n-unsafe impl<T> Send for Singleton<T> {}\n+// but we need to be conditional on the inner type to prevent interior mutable types beeing used\n+// inside a singleton\n+unsafe impl<T> Sync for Singleton<T> where T: Sync {}\n+unsafe impl<T> Send for Singleton<T> where T: Send {}\n \n impl<T: 'static> Singleton<T> {\n     /// Create a new [Singleton] instance to be used in a static variable. Only ``const fn`` constructors are allowed\n",
    "diff_parsed": "{'added': [(86, 'unsafe impl<T> Sync for Singleton<T> where T: Sync {}'), (87, 'unsafe impl<T> Send for Singleton<T> where T: Send {}')], 'deleted': [(84, 'unsafe impl<T> Sync for Singleton<T> {}'), (85, 'unsafe impl<T> Send for Singleton<T> {}')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "51"
  },
  {
    "file_change_id": "195806979916385",
    "hash": "c8f82d45060c9e936ab49cd3838135208de0924",
    "old_path": "tokio/src/sync/oneshot.rs",
    "new_path": "tokio/src/sync/oneshot.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -839,13 +839,15 @@ impl<T> Receiver<T> {\n         let result = if let Some(inner) = self.inner.as_ref() {\n             let state = State::load(&inner.state, Acquire);\n \n-            if state.is_complete() {\n+            // First, check if the channel has been closed. If the channel is\n+            // closed, return an error.\n+            if state.is_closed() {\n+                Err(TryRecvError::Closed)\n+            } else if state.is_complete() {\n                 match unsafe { inner.consume_value() } {\n                     Some(value) => Ok(value),\n                     None => Err(TryRecvError::Closed),\n                 }\n-            } else if state.is_closed() {\n-                Err(TryRecvError::Closed)\n             } else {\n                 // Not ready, this does not clear `inner`\n                 return Err(TryRecvError::Empty);\n",
    "diff_parsed": "{'added': [(844, '            if state.is_closed() {'), (845, '                Err(TryRecvError::Closed)'), (846, '            } else if state.is_complete() {')], 'deleted': [(842, '            if state.is_complete() {'), (847, '            } else if state.is_closed() {'), (848, '                Err(TryRecvError::Closed)')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "3",
    "nloc": "543"
  },
  {
    "file_change_id": "41915293770951",
    "hash": "d08bc37de3dd471ea564a954a2de1d0caf045f6",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1130,7 +1130,7 @@ unsafe impl<'a> alloc::Alloc for &'a Bump {\n             if let Some(p) =\n                 self.try_alloc_layout_fast(layout_from_size_align(delta, layout.align()))\n             {\n-                ptr::copy(ptr.as_ptr(), p.as_ptr(), new_size);\n+                ptr::copy(ptr.as_ptr(), p.as_ptr(), old_size);\n                 return Ok(p);\n             }\n         }\n@@ -1200,4 +1200,23 @@ mod tests {\n             b.reset();\n         }\n     }\n+\n+    #[test]\n+    fn invalid_read() {\n+        use alloc::Alloc;\n+\n+        let mut b = &Bump::new();\n+\n+        unsafe {\n+            let l1 = Layout::from_size_align(12000, 4).unwrap();\n+            let p1 = Alloc::alloc(&mut b, l1).unwrap();\n+\n+            let l2 = Layout::from_size_align(1000, 4).unwrap();\n+            Alloc::alloc(&mut b, l2).unwrap();\n+\n+            let p1 = b.realloc(p1, l1, 24000).unwrap();\n+            let l3 = Layout::from_size_align(24000, 4).unwrap();\n+            b.realloc(p1, l3, 48000).unwrap();\n+        }\n+    }\n }\n",
    "diff_parsed": "{'added': [(1133, '                ptr::copy(ptr.as_ptr(), p.as_ptr(), old_size);'), (1204, '    #[test]'), (1205, '    fn invalid_read() {'), (1206, '        use alloc::Alloc;'), (1208, '        let mut b = &Bump::new();'), (1210, '        unsafe {'), (1211, '            let l1 = Layout::from_size_align(12000, 4).unwrap();'), (1212, '            let p1 = Alloc::alloc(&mut b, l1).unwrap();'), (1214, '            let l2 = Layout::from_size_align(1000, 4).unwrap();'), (1215, '            Alloc::alloc(&mut b, l2).unwrap();'), (1217, '            let p1 = b.realloc(p1, l1, 24000).unwrap();'), (1218, '            let l3 = Layout::from_size_align(24000, 4).unwrap();'), (1219, '            b.realloc(p1, l3, 48000).unwrap();'), (1220, '        }'), (1221, '    }')], 'deleted': [(1133, '                ptr::copy(ptr.as_ptr(), p.as_ptr(), new_size);')]}",
    "num_lines_added": "15",
    "num_lines_deleted": "1",
    "nloc": "514"
  },
  {
    "file_change_id": "181470185595000",
    "hash": "d08bc37de3dd471ea564a954a2de1d0caf045f6",
    "old_path": "tests/vec.rs",
    "new_path": "tests/vec.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -57,3 +57,29 @@ fn test_into_bump_slice_mut() {\n \n     assert_eq!(slice, [3, 2, 1]);\n }\n+\n+quickcheck::quickcheck! {\n+    fn vec_resizes_causing_reallocs(sizes: std::vec::Vec<usize>) -> () {\n+        // Exercise `realloc` by doing a bunch of `resize`s followed by\n+        // `shrink_to_fit`s.\n+\n+        let b = Bump::new();\n+        let mut v = bumpalo::vec![in &b];\n+\n+        for len in sizes {\n+            // We don't want to get too big and OOM.\n+            const MAX_SIZE: usize = 1 << 15;\n+\n+            // But we want allocations to get fairly close to the minimum chunk\n+            // size, so that we are exercising both realloc'ing within a chunk\n+            // and when we need new chunks.\n+            const MIN_SIZE: usize = 1 << 7;\n+\n+            let len = std::cmp::min(len, MAX_SIZE);\n+            let len = std::cmp::max(len, MIN_SIZE);\n+\n+            v.resize(len, 0);\n+            v.shrink_to_fit();\n+        }\n+    }\n+}\n",
    "diff_parsed": "{'added': [(61, 'quickcheck::quickcheck! {'), (62, '    fn vec_resizes_causing_reallocs(sizes: std::vec::Vec<usize>) -> () {'), (66, '        let b = Bump::new();'), (67, '        let mut v = bumpalo::vec![in &b];'), (69, '        for len in sizes {'), (71, '            const MAX_SIZE: usize = 1 << 15;'), (76, '            const MIN_SIZE: usize = 1 << 7;'), (78, '            let len = std::cmp::min(len, MAX_SIZE);'), (79, '            let len = std::cmp::max(len, MIN_SIZE);'), (81, '            v.resize(len, 0);'), (82, '            v.shrink_to_fit();'), (83, '        }'), (84, '    }'), (85, '}')], 'deleted': []}",
    "num_lines_added": "14",
    "num_lines_deleted": "0",
    "nloc": "60"
  },
  {
    "file_change_id": "79857628343793",
    "hash": "0562cbfe79f68e061628e5cf0d29d9f879b6913",
    "old_path": "src/demuxer.rs",
    "new_path": "src/demuxer.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -262,7 +262,7 @@ where\n     events: T,\n }\n \n-unsafe impl<T> Send for Demuxer<T> where T: DemuxerEvents {}\n+unsafe impl<T> Send for Demuxer<T> where T: DemuxerEvents + Send {}\n \n impl<T> Demuxer<T>\n where\n",
    "diff_parsed": "{'added': [(265, 'unsafe impl<T> Send for Demuxer<T> where T: DemuxerEvents + Send {}')], 'deleted': [(265, 'unsafe impl<T> Send for Demuxer<T> where T: DemuxerEvents {}')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "430"
  },
  {
    "file_change_id": "279045770432732",
    "hash": "e7fb2f5b5f95437a37d99b8c430c8adc9045f35",
    "old_path": "src/processing/image.rs",
    "new_path": "src/processing/image.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -157,8 +157,8 @@ impl<T> ImageChunkMut<'_, T> {\n     }\n }\n \n-unsafe impl<T> Send for ImageChunkMut<'_, T> {}\n-unsafe impl<T> Sync for ImageChunkMut<'_, T> {}\n+unsafe impl<T: Send> Send for ImageChunkMut<'_, T> {}\n+unsafe impl<T: Sync> Sync for ImageChunkMut<'_, T> {}\n \n impl<T> Index<(usize, usize)> for ImageChunkMut<'_, T> {\n     type Output = T;\n",
    "diff_parsed": "{'added': [(160, \"unsafe impl<T: Send> Send for ImageChunkMut<'_, T> {}\"), (161, \"unsafe impl<T: Sync> Sync for ImageChunkMut<'_, T> {}\")], 'deleted': [(160, \"unsafe impl<T> Send for ImageChunkMut<'_, T> {}\"), (161, \"unsafe impl<T> Sync for ImageChunkMut<'_, T> {}\")]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "206"
  },
  {
    "file_change_id": "276444871910261",
    "hash": "ef4aa05cdd3b81ae9f8a42acd211e95530b1ab7",
    "old_path": "async-coap/src/arc_guard.rs",
    "new_path": "async-coap/src/arc_guard.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -160,8 +160,8 @@ impl<RC, T> ArcGuard<RC, T> {\n     }\n }\n \n-unsafe impl<RC, T: Send> Send for ArcGuard<RC, T> {}\n-unsafe impl<RC, T: Sync> Sync for ArcGuard<RC, T> {}\n+unsafe impl<RC: Send, T: Send> Send for ArcGuard<RC, T> {}\n+unsafe impl<RC: Sync, T: Sync> Sync for ArcGuard<RC, T> {}\n \n impl<RC, T> Deref for ArcGuard<RC, T> {\n     type Target = T;\n",
    "diff_parsed": "{'added': [(163, 'unsafe impl<RC: Send, T: Send> Send for ArcGuard<RC, T> {}'), (164, 'unsafe impl<RC: Sync, T: Sync> Sync for ArcGuard<RC, T> {}')], 'deleted': [(163, 'unsafe impl<RC, T: Send> Send for ArcGuard<RC, T> {}'), (164, 'unsafe impl<RC, T: Sync> Sync for ArcGuard<RC, T> {}')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "112"
  },
  {
    "file_change_id": "43353967301084",
    "hash": "5bff5368bf38ddfa31416e4ae9897b163031a51",
    "old_path": "src/base/vec_storage.rs",
    "new_path": "src/base/vec_storage.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -13,6 +13,12 @@ use crate::base::storage::{\n };\n use crate::base::{Scalar, Vector};\n \n+#[cfg(feature = \"serde-serialize-no-std\")]\n+use serde::{\n+    de::{Deserialize, Deserializer, Error},\n+    ser::{Serialize, Serializer},\n+};\n+\n #[cfg(feature = \"abomonation-serialize\")]\n use abomonation::Abomonation;\n \n@@ -24,13 +30,54 @@ use abomonation::Abomonation;\n /// A Vec-based matrix data storage. It may be dynamically-sized.\n #[repr(C)]\n #[derive(Eq, Debug, Clone, PartialEq)]\n-#[cfg_attr(feature = \"serde-serialize\", derive(Serialize, Deserialize))]\n pub struct VecStorage<T, R: Dim, C: Dim> {\n     data: Vec<T>,\n     nrows: R,\n     ncols: C,\n }\n \n+#[cfg(feature = \"serde-serialize\")]\n+impl<T, R: Dim, C: Dim> Serialize for VecStorage<T, R, C>\n+where\n+    T: Serialize,\n+    R: Serialize,\n+    C: Serialize,\n+{\n+    fn serialize<Ser>(&self, serializer: Ser) -> Result<Ser::Ok, Ser::Error>\n+    where\n+        Ser: Serializer,\n+    {\n+        (&self.data, &self.nrows, &self.ncols).serialize(serializer)\n+    }\n+}\n+\n+#[cfg(feature = \"serde-serialize\")]\n+impl<'a, T, R: Dim, C: Dim> Deserialize<'a> for VecStorage<T, R, C>\n+where\n+    T: Deserialize<'a>,\n+    R: Deserialize<'a>,\n+    C: Deserialize<'a>,\n+{\n+    fn deserialize<Des>(deserializer: Des) -> Result<Self, Des::Error>\n+    where\n+        Des: Deserializer<'a>,\n+    {\n+        let (data, nrows, ncols): (Vec<T>, R, C) = Deserialize::deserialize(deserializer)?;\n+\n+        // SAFETY: make sure the data we deserialize have the\n+        //         correct number of elements.\n+        if nrows.value() * ncols.value() != data.len() {\n+            return Err(Des::Error::custom(format!(\n+                \"Expected {} components, found {}\",\n+                nrows.value() * ncols.value(),\n+                data.len()\n+            )));\n+        }\n+\n+        Ok(Self { data, nrows, ncols })\n+    }\n+}\n+\n #[deprecated(note = \"renamed to `VecStorage`\")]\n /// Renamed to [VecStorage].\n pub type MatrixVec<T, R, C> = VecStorage<T, R, C>;\n",
    "diff_parsed": "{'added': [(16, '#[cfg(feature = \"serde-serialize-no-std\")]'), (17, 'use serde::{'), (18, '    de::{Deserialize, Deserializer, Error},'), (19, '    ser::{Serialize, Serializer},'), (20, '};'), (39, '#[cfg(feature = \"serde-serialize\")]'), (40, 'impl<T, R: Dim, C: Dim> Serialize for VecStorage<T, R, C>'), (41, 'where'), (42, '    T: Serialize,'), (43, '    R: Serialize,'), (44, '    C: Serialize,'), (45, '{'), (46, '    fn serialize<Ser>(&self, serializer: Ser) -> Result<Ser::Ok, Ser::Error>'), (47, '    where'), (48, '        Ser: Serializer,'), (49, '    {'), (50, '        (&self.data, &self.nrows, &self.ncols).serialize(serializer)'), (51, '    }'), (52, '}'), (54, '#[cfg(feature = \"serde-serialize\")]'), (55, \"impl<'a, T, R: Dim, C: Dim> Deserialize<'a> for VecStorage<T, R, C>\"), (56, 'where'), (57, \"    T: Deserialize<'a>,\"), (58, \"    R: Deserialize<'a>,\"), (59, \"    C: Deserialize<'a>,\"), (60, '{'), (61, '    fn deserialize<Des>(deserializer: Des) -> Result<Self, Des::Error>'), (62, '    where'), (63, \"        Des: Deserializer<'a>,\"), (64, '    {'), (65, '        let (data, nrows, ncols): (Vec<T>, R, C) = Deserialize::deserialize(deserializer)?;'), (69, '        if nrows.value() * ncols.value() != data.len() {'), (70, '            return Err(Des::Error::custom(format!('), (71, '                \"Expected {} components, found {}\",'), (72, '                nrows.value() * ncols.value(),'), (73, '                data.len()'), (74, '            )));'), (75, '        }'), (77, '        Ok(Self { data, nrows, ncols })'), (78, '    }'), (79, '}')], 'deleted': [(27, '#[cfg_attr(feature = \"serde-serialize\", derive(Serialize, Deserialize))]')]}",
    "num_lines_added": "41",
    "num_lines_deleted": "1",
    "nloc": "358"
  },
  {
    "file_change_id": "93022031845479",
    "hash": "5bff5368bf38ddfa31416e4ae9897b163031a51",
    "old_path": "tests/core/serde.rs",
    "new_path": "tests/core/serde.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,8 +1,8 @@\n #![cfg(feature = \"serde-serialize\")]\n \n use na::{\n-    DMatrix, Isometry2, Isometry3, IsometryMatrix2, IsometryMatrix3, Matrix3x4, Point2, Point3,\n-    Quaternion, Rotation2, Rotation3, Similarity2, Similarity3, SimilarityMatrix2,\n+    DMatrix, Isometry2, Isometry3, IsometryMatrix2, IsometryMatrix3, Matrix2x3, Matrix3x4, Point2,\n+    Point3, Quaternion, Rotation2, Rotation3, Similarity2, Similarity3, SimilarityMatrix2,\n     SimilarityMatrix3, Translation2, Translation3, Unit, Vector2,\n };\n use rand;\n@@ -27,6 +27,32 @@ fn serde_dmatrix() {\n     let serialized = serde_json::to_string(&v).unwrap();\n     let deserialized: DMatrix<f32> = serde_json::from_str(&serialized).unwrap();\n     assert_eq!(v, deserialized);\n+\n+    let m = DMatrix::from_column_slice(2, 3, &[1.0, 2.0, 3.0, 4.0, 5.0, 6.0]);\n+    let mat_str = \"[[1.0, 2.0, 3.0, 4.0, 5.0, 6.0],2,3]\";\n+    let deserialized: DMatrix<f32> = serde_json::from_str(&mat_str).unwrap();\n+    assert_eq!(m, deserialized);\n+\n+    let m = Matrix2x3::from_column_slice(&[1.0, 2.0, 3.0, 4.0, 5.0, 6.0]);\n+    let mat_str = \"[1.0, 2.0, 3.0, 4.0, 5.0, 6.0]\";\n+    let deserialized: Matrix2x3<f32> = serde_json::from_str(&mat_str).unwrap();\n+    assert_eq!(m, deserialized);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn serde_dmatrix_invalid_len() {\n+    // This must fail: we attempt to deserialize a 2x3 with only 5 elements.\n+    let mat_str = \"[[1.0, 2.0, 3.0, 4.0, 5.0],2,3]\";\n+    let _: DMatrix<f32> = serde_json::from_str(&mat_str).unwrap();\n+}\n+\n+#[test]\n+#[should_panic]\n+fn serde_smatrix_invalid_len() {\n+    // This must fail: we attempt to deserialize a 2x3 with only 5 elements.\n+    let mat_str = \"[1.0, 2.0, 3.0, 4.0, 5.0]\";\n+    let _: Matrix2x3<f32> = serde_json::from_str(&mat_str).unwrap();\n }\n \n test_serde!(\n",
    "diff_parsed": "{'added': [(4, '    DMatrix, Isometry2, Isometry3, IsometryMatrix2, IsometryMatrix3, Matrix2x3, Matrix3x4, Point2,'), (5, '    Point3, Quaternion, Rotation2, Rotation3, Similarity2, Similarity3, SimilarityMatrix2,'), (31, '    let m = DMatrix::from_column_slice(2, 3, &[1.0, 2.0, 3.0, 4.0, 5.0, 6.0]);'), (32, '    let mat_str = \"[[1.0, 2.0, 3.0, 4.0, 5.0, 6.0],2,3]\";'), (33, '    let deserialized: DMatrix<f32> = serde_json::from_str(&mat_str).unwrap();'), (34, '    assert_eq!(m, deserialized);'), (36, '    let m = Matrix2x3::from_column_slice(&[1.0, 2.0, 3.0, 4.0, 5.0, 6.0]);'), (37, '    let mat_str = \"[1.0, 2.0, 3.0, 4.0, 5.0, 6.0]\";'), (38, '    let deserialized: Matrix2x3<f32> = serde_json::from_str(&mat_str).unwrap();'), (39, '    assert_eq!(m, deserialized);'), (40, '}'), (42, '#[test]'), (43, '#[should_panic]'), (44, 'fn serde_dmatrix_invalid_len() {'), (46, '    let mat_str = \"[[1.0, 2.0, 3.0, 4.0, 5.0],2,3]\";'), (47, '    let _: DMatrix<f32> = serde_json::from_str(&mat_str).unwrap();'), (48, '}'), (50, '#[test]'), (51, '#[should_panic]'), (52, 'fn serde_smatrix_invalid_len() {'), (54, '    let mat_str = \"[1.0, 2.0, 3.0, 4.0, 5.0]\";'), (55, '    let _: Matrix2x3<f32> = serde_json::from_str(&mat_str).unwrap();')], 'deleted': [(4, '    DMatrix, Isometry2, Isometry3, IsometryMatrix2, IsometryMatrix3, Matrix3x4, Point2, Point3,'), (5, '    Quaternion, Rotation2, Rotation3, Similarity2, Similarity3, SimilarityMatrix2,')]}",
    "num_lines_added": "22",
    "num_lines_deleted": "2",
    "nloc": "82"
  },
  {
    "file_change_id": "163495032254485",
    "hash": "55dd22f447492e272b75230c3d8108faa10c6fc",
    "old_path": "src/pcap.rs",
    "new_path": "src/pcap.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -19,7 +19,7 @@ pub struct Input<R: Read> {\n     iter: Box<dyn PcapReaderIterator<R>>,\n }\n \n-unsafe impl<R: Read> std::marker::Send for Input<R> {}\n+unsafe impl<R: Read + Send> Send for Input<R> {}\n \n impl<R: Read + 'static> Input<R> {\n     pub fn with_read(\n",
    "diff_parsed": "{'added': [(22, 'unsafe impl<R: Read + Send> Send for Input<R> {}')], 'deleted': [(22, 'unsafe impl<R: Read> std::marker::Send for Input<R> {}')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "152"
  },
  {
    "file_change_id": "239075293568377",
    "hash": "5f8e17b1c144e49d244e4e15b985ffa498c4ede",
    "old_path": "src/ffi/generated.rs",
    "new_path": "src/ffi/generated.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -2,7 +2,7 @@\n \n /// ABI-compatible struct for [`ArrowSchema`](https://arrow.apache.org/docs/format/CDataInterface.html#structure-definitions)\n #[repr(C)]\n-#[derive(Debug, Clone)]\n+#[derive(Debug)]\n pub struct ArrowSchema {\n     pub(super) format: *const ::std::os::raw::c_char,\n     pub(super) name: *const ::std::os::raw::c_char,\n@@ -17,7 +17,7 @@ pub struct ArrowSchema {\n \n /// ABI-compatible struct for [`ArrowArray`](https://arrow.apache.org/docs/format/CDataInterface.html#structure-definitions)\n #[repr(C)]\n-#[derive(Debug, Clone)]\n+#[derive(Debug)]\n pub struct ArrowArray {\n     pub(super) length: i64,\n     pub(super) null_count: i64,\n@@ -33,7 +33,7 @@ pub struct ArrowArray {\n \n /// ABI-compatible struct for [`ArrowArrayStream`](https://arrow.apache.org/docs/format/CStreamInterface.html).\n #[repr(C)]\n-#[derive(Debug, Clone)]\n+#[derive(Debug)]\n pub struct ArrowArrayStream {\n     pub(super) get_schema: ::std::option::Option<\n         unsafe extern \"C\" fn(\n",
    "diff_parsed": "{'added': [(5, '#[derive(Debug)]'), (20, '#[derive(Debug)]'), (36, '#[derive(Debug)]')], 'deleted': [(5, '#[derive(Debug, Clone)]'), (20, '#[derive(Debug, Clone)]'), (36, '#[derive(Debug, Clone)]')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "3",
    "nloc": "48"
  },
  {
    "file_change_id": "255216711446821",
    "hash": "8bfc20506cc5e098fe6eb3d1cafe3bea791215ce",
    "old_path": "lettre/src/smtp/client/mod.rs",
    "new_path": "lettre/src/smtp/client/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -51,7 +51,15 @@ impl ClientCodec {\n                     match self.escape_count {\n                         0 => self.escape_count = if *byte == b'\\r' { 1 } else { 0 },\n                         1 => self.escape_count = if *byte == b'\\n' { 2 } else { 0 },\n-                        2 => self.escape_count = if *byte == b'.' { 3 } else { 0 },\n+                        2 => {\n+                            self.escape_count = if *byte == b'.' {\n+                                3\n+                            } else if *byte == b'\\r' {\n+                                1\n+                            } else {\n+                                0\n+                            }\n+                        }\n                         _ => unreachable!(),\n                     }\n                     if self.escape_count == 3 {\n@@ -286,6 +294,7 @@ mod test {\n         let mut buf: Vec<u8> = vec![];\n \n         assert!(codec.encode(b\"test\\r\\n\", &mut buf).is_ok());\n+        assert!(codec.encode(b\"test\\r\\n\\r\\n\", &mut buf).is_ok());\n         assert!(codec.encode(b\".\\r\\n\", &mut buf).is_ok());\n         assert!(codec.encode(b\"\\r\\ntest\", &mut buf).is_ok());\n         assert!(codec.encode(b\"te\\r\\n.\\r\\nst\", &mut buf).is_ok());\n@@ -296,7 +305,7 @@ mod test {\n         assert!(codec.encode(b\"test\", &mut buf).is_ok());\n         assert_eq!(\n             String::from_utf8(buf).unwrap(),\n-            \"test\\r\\n..\\r\\n\\r\\ntestte\\r\\n..\\r\\nsttesttest.test\\n.test\\ntest\"\n+            \"test\\r\\ntest\\r\\n\\r\\n..\\r\\n\\r\\ntestte\\r\\n..\\r\\nsttesttest.test\\n.test\\ntest\"\n         );\n     }\n \n",
    "diff_parsed": "{'added': [(54, '                        2 => {'), (55, \"                            self.escape_count = if *byte == b'.' {\"), (56, '                                3'), (57, \"                            } else if *byte == b'\\\\r' {\"), (58, '                                1'), (59, '                            } else {'), (60, '                                0'), (61, '                            }'), (62, '                        }'), (297, '        assert!(codec.encode(b\"test\\\\r\\\\n\\\\r\\\\n\", &mut buf).is_ok());'), (308, '            \"test\\\\r\\\\ntest\\\\r\\\\n\\\\r\\\\n..\\\\r\\\\n\\\\r\\\\ntestte\\\\r\\\\n..\\\\r\\\\nsttesttest.test\\\\n.test\\\\ntest\"')], 'deleted': [(54, \"                        2 => self.escape_count = if *byte == b'.' { 3 } else { 0 },\"), (299, '            \"test\\\\r\\\\n..\\\\r\\\\n\\\\r\\\\ntestte\\\\r\\\\n..\\\\r\\\\nsttesttest.test\\\\n.test\\\\ntest\"')]}",
    "num_lines_added": "11",
    "num_lines_deleted": "2",
    "nloc": "245"
  },
  {
    "file_change_id": "195215873072467",
    "hash": "34c2b9e",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -89,8 +89,8 @@ impl<T: Sized> Drop for AtomicBox<T> {\n     }\n }\n \n-unsafe impl<T: Sized> Sync for AtomicBox<T> {}\n-unsafe impl<T: Sized> Send for AtomicBox<T> {}\n+unsafe impl<T: Sized + Sync> Sync for AtomicBox<T> {}\n+unsafe impl<T: Sized + Send> Send for AtomicBox<T> {}\n \n #[cfg(test)]\n mod tests {\n",
    "diff_parsed": "{'added': [(92, 'unsafe impl<T: Sized + Sync> Sync for AtomicBox<T> {}'), (93, 'unsafe impl<T: Sized + Send> Send for AtomicBox<T> {}')], 'deleted': [(92, 'unsafe impl<T: Sized> Sync for AtomicBox<T> {}'), (93, 'unsafe impl<T: Sized> Send for AtomicBox<T> {}')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "172"
  },
  {
    "file_change_id": "150535742575427",
    "hash": "886ecc562040bef61faf19438c22285c2d62403a",
    "old_path": "crates/runtime/src/instance.rs",
    "new_path": "crates/runtime/src/instance.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -92,6 +92,10 @@ pub(crate) struct Instance {\n     /// allocation, but some host-defined objects will store their state here.\n     host_state: Box<dyn Any + Send + Sync>,\n \n+    /// Flag to track when the vmctx has been initialized.\n+    /// The pooling allocator may drop an instance before `vmctx` is initialized.\n+    vmctx_initialized: bool,\n+\n     /// Additional context used by compiled wasm code. This field is last, and\n     /// represents a dynamically-sized array that extends beyond the nominal\n     /// end of the struct (similar to a flexible array member).\n@@ -119,6 +123,7 @@ impl Instance {\n             dropped_data: EntitySet::with_capacity(module.passive_data_map.len()),\n             host_state,\n             wasm_data,\n+            vmctx_initialized: false,\n             vmctx: VMContext {\n                 _marker: std::marker::PhantomPinned,\n             },\n@@ -733,13 +738,18 @@ impl Instance {\n     }\n \n     fn drop_globals(&mut self) {\n+        // Dropping globals requires that the vmctx be fully initialized\n+        if !self.vmctx_initialized {\n+            return;\n+        }\n+\n         for (idx, global) in self.module.globals.iter() {\n             let idx = match self.module.defined_global_index(idx) {\n                 Some(idx) => idx,\n                 None => continue,\n             };\n             match global.wasm_ty {\n-                // For now only externref gloabls need to get destroyed\n+                // For now only externref globals need to get destroyed\n                 WasmType::ExternRef => {}\n                 _ => continue,\n             }\n",
    "diff_parsed": "{'added': [(97, '    vmctx_initialized: bool,'), (126, '            vmctx_initialized: false,'), (742, '        if !self.vmctx_initialized {'), (743, '            return;'), (744, '        }')], 'deleted': []}",
    "num_lines_added": "5",
    "num_lines_deleted": "0",
    "nloc": "598"
  },
  {
    "file_change_id": "15841128621487",
    "hash": "886ecc562040bef61faf19438c22285c2d62403a",
    "old_path": "crates/runtime/src/instance/allocator.rs",
    "new_path": "crates/runtime/src/instance/allocator.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -475,6 +475,8 @@ fn initialize_instance(\n }\n \n unsafe fn initialize_vmcontext(instance: &mut Instance, req: InstanceAllocationRequest) {\n+    assert!(!instance.vmctx_initialized);\n+\n     if let Some(store) = req.store.as_raw() {\n         *instance.interrupts() = (*store).vminterrupts();\n         *instance.epoch_ptr() = (*store).epoch_ptr();\n@@ -570,6 +572,9 @@ unsafe fn initialize_vmcontext(instance: &mut Instance, req: InstanceAllocationR\n \n     // Initialize the defined globals\n     initialize_vmcontext_globals(instance);\n+\n+    // Mark the vmctx as initialized\n+    instance.vmctx_initialized = true;\n }\n \n unsafe fn initialize_vmcontext_globals(instance: &Instance) {\n",
    "diff_parsed": "{'added': [(478, '    assert!(!instance.vmctx_initialized);'), (577, '    instance.vmctx_initialized = true;')], 'deleted': []}",
    "num_lines_added": "2",
    "num_lines_deleted": "0",
    "nloc": "570"
  },
  {
    "file_change_id": "83008037241094",
    "hash": "886ecc562040bef61faf19438c22285c2d62403a",
    "old_path": "tests/all/pooling_allocator.rs",
    "new_path": "tests/all/pooling_allocator.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -511,3 +511,61 @@ fn preserve_data_segments() -> Result<()> {\n \n     Ok(())\n }\n+\n+#[test]\n+fn drop_externref_global_during_module_init() -> Result<()> {\n+    struct Limiter;\n+\n+    impl ResourceLimiter for Limiter {\n+        fn memory_growing(&mut self, _: usize, _: usize, _: Option<usize>) -> bool {\n+            false\n+        }\n+\n+        fn table_growing(&mut self, _: u32, _: u32, _: Option<u32>) -> bool {\n+            false\n+        }\n+    }\n+\n+    let mut config = Config::new();\n+    config.wasm_reference_types(true);\n+    config.allocation_strategy(InstanceAllocationStrategy::Pooling {\n+        strategy: PoolingAllocationStrategy::NextAvailable,\n+        module_limits: Default::default(),\n+        instance_limits: InstanceLimits { count: 1 },\n+    });\n+\n+    let engine = Engine::new(&config)?;\n+\n+    let module = Module::new(\n+        &engine,\n+        r#\"\n+            (module\n+                (global i32 (i32.const 1))\n+                (global i32 (i32.const 2))\n+                (global i32 (i32.const 3))\n+                (global i32 (i32.const 4))\n+                (global i32 (i32.const 5))\n+            )\n+        \"#,\n+    )?;\n+\n+    let mut store = Store::new(&engine, Limiter);\n+    drop(Instance::new(&mut store, &module, &[])?);\n+    drop(store);\n+\n+    let module = Module::new(\n+        &engine,\n+        r#\"\n+            (module\n+                (memory 1)\n+                (global (mut externref) (ref.null extern))\n+            )\n+        \"#,\n+    )?;\n+\n+    let mut store = Store::new(&engine, Limiter);\n+    store.limiter(|s| s);\n+    assert!(Instance::new(&mut store, &module, &[]).is_err());\n+\n+    Ok(())\n+}\n",
    "diff_parsed": "{'added': [(515, '#[test]'), (516, 'fn drop_externref_global_during_module_init() -> Result<()> {'), (517, '    struct Limiter;'), (519, '    impl ResourceLimiter for Limiter {'), (520, '        fn memory_growing(&mut self, _: usize, _: usize, _: Option<usize>) -> bool {'), (521, '            false'), (522, '        }'), (524, '        fn table_growing(&mut self, _: u32, _: u32, _: Option<u32>) -> bool {'), (525, '            false'), (526, '        }'), (527, '    }'), (529, '    let mut config = Config::new();'), (530, '    config.wasm_reference_types(true);'), (531, '    config.allocation_strategy(InstanceAllocationStrategy::Pooling {'), (532, '        strategy: PoolingAllocationStrategy::NextAvailable,'), (533, '        module_limits: Default::default(),'), (534, '        instance_limits: InstanceLimits { count: 1 },'), (535, '    });'), (537, '    let engine = Engine::new(&config)?;'), (539, '    let module = Module::new('), (540, '        &engine,'), (541, '        r#\"'), (542, '            (module'), (543, '                (global i32 (i32.const 1))'), (544, '                (global i32 (i32.const 2))'), (545, '                (global i32 (i32.const 3))'), (546, '                (global i32 (i32.const 4))'), (547, '                (global i32 (i32.const 5))'), (548, '            )'), (549, '        \"#,'), (550, '    )?;'), (552, '    let mut store = Store::new(&engine, Limiter);'), (553, '    drop(Instance::new(&mut store, &module, &[])?);'), (554, '    drop(store);'), (556, '    let module = Module::new('), (557, '        &engine,'), (558, '        r#\"'), (559, '            (module'), (560, '                (memory 1)'), (561, '                (global (mut externref) (ref.null extern))'), (562, '            )'), (563, '        \"#,'), (564, '    )?;'), (566, '    let mut store = Store::new(&engine, Limiter);'), (567, '    store.limiter(|s| s);'), (568, '    assert!(Instance::new(&mut store, &module, &[]).is_err());'), (570, '    Ok(())'), (571, '}')], 'deleted': []}",
    "num_lines_added": "48",
    "num_lines_deleted": "0",
    "nloc": "458"
  },
  {
    "file_change_id": "277241159425393",
    "hash": "24c7a5550807ac8a09648b5878f19d14c3a69135",
    "old_path": "src/crypto/scalarmult/curve25519.rs",
    "new_path": "src/crypto/scalarmult/curve25519.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -23,14 +23,20 @@ new_type! {\n \n /// `scalarmult()` multiplies a group element `p`\n /// by an integer `n`. It returns the resulting group element\n-/// `q`.\n+/// `Ok(q)`.\n+/// If the the `GroupElement` is all zero, `scalarmult()` returns `Err(())` since\n+/// the resulting `GroupElement` would be all zero, no matter the `Scalar`.\n pub fn scalarmult(&Scalar(ref n): &Scalar,\n-                  &GroupElement(ref p): &GroupElement) -> GroupElement {\n+                  &GroupElement(ref p): &GroupElement)\n+                  -> Result<GroupElement, ()> {\n     let mut q = [0; GROUPELEMENTBYTES];\n     unsafe {\n-        ffi::crypto_scalarmult_curve25519(&mut q, n, p);\n+        if ffi::crypto_scalarmult_curve25519(&mut q, n, p) != 0 {\n+            Err(())\n+        } else {\n+            Ok(GroupElement(q))\n+        }\n     }\n-    GroupElement(q)\n }\n \n /// `scalarmult_base()` computes the scalar product of a standard\n@@ -47,18 +53,17 @@ pub fn scalarmult_base(&Scalar(ref n): &Scalar) -> GroupElement {\n #[cfg(test)]\n mod test {\n     use super::*;\n+    use randombytes::randombytes_into;\n \n     #[test]\n     fn test_vector_1() {\n         // corresponding to tests/scalarmult.c and tests/scalarmult3.cpp from NaCl\n-        let alicesk = Scalar([0x77,0x07,0x6d,0x0a,0x73,0x18,0xa5,0x7d\n-                             ,0x3c,0x16,0xc1,0x72,0x51,0xb2,0x66,0x45\n-                             ,0xdf,0x4c,0x2f,0x87,0xeb,0xc0,0x99,0x2a\n-                             ,0xb1,0x77,0xfb,0xa5,0x1d,0xb9,0x2c,0x2a]);\n-        let alicepk_expected = [0x85,0x20,0xf0,0x09,0x89,0x30,0xa7,0x54\n-                               ,0x74,0x8b,0x7d,0xdc,0xb4,0x3e,0xf7,0x5a\n-                               ,0x0d,0xbf,0x3a,0x0d,0x26,0x38,0x1a,0xf4\n-                               ,0xeb,0xa4,0xa9,0x8e,0xaa,0x9b,0x4e,0x6a];\n+        let alicesk = Scalar([0x77, 0x07, 0x6d, 0x0a, 0x73, 0x18, 0xa5, 0x7d, 0x3c, 0x16, 0xc1,\n+                              0x72, 0x51, 0xb2, 0x66, 0x45, 0xdf, 0x4c, 0x2f, 0x87, 0xeb, 0xc0,\n+                              0x99, 0x2a, 0xb1, 0x77, 0xfb, 0xa5, 0x1d, 0xb9, 0x2c, 0x2a]);\n+        let alicepk_expected = [0x85, 0x20, 0xf0, 0x09, 0x89, 0x30, 0xa7, 0x54, 0x74, 0x8b, 0x7d,\n+                                0xdc, 0xb4, 0x3e, 0xf7, 0x5a, 0x0d, 0xbf, 0x3a, 0x0d, 0x26, 0x38,\n+                                0x1a, 0xf4, 0xeb, 0xa4, 0xa9, 0x8e, 0xaa, 0x9b, 0x4e, 0x6a];\n         let GroupElement(alicepk) = scalarmult_base(&alicesk);\n         assert!(alicepk == alicepk_expected);\n     }\n@@ -66,14 +71,12 @@ mod test {\n     #[test]\n     fn test_vector_2() {\n         // corresponding to tests/scalarmult2.c and tests/scalarmult4.cpp from NaCl\n-        let bobsk = Scalar([0x5d,0xab,0x08,0x7e,0x62,0x4a,0x8a,0x4b\n-                           ,0x79,0xe1,0x7f,0x8b,0x83,0x80,0x0e,0xe6\n-                           ,0x6f,0x3b,0xb1,0x29,0x26,0x18,0xb6,0xfd\n-                           ,0x1c,0x2f,0x8b,0x27,0xff,0x88,0xe0,0xeb]);\n-        let bobpk_expected = [0xde,0x9e,0xdb,0x7d,0x7b,0x7d,0xc1,0xb4\n-                             ,0xd3,0x5b,0x61,0xc2,0xec,0xe4,0x35,0x37\n-                             ,0x3f,0x83,0x43,0xc8,0x5b,0x78,0x67,0x4d\n-                             ,0xad,0xfc,0x7e,0x14,0x6f,0x88,0x2b,0x4f];\n+        let bobsk = Scalar([0x5d, 0xab, 0x08, 0x7e, 0x62, 0x4a, 0x8a, 0x4b, 0x79, 0xe1, 0x7f,\n+                            0x8b, 0x83, 0x80, 0x0e, 0xe6, 0x6f, 0x3b, 0xb1, 0x29, 0x26, 0x18,\n+                            0xb6, 0xfd, 0x1c, 0x2f, 0x8b, 0x27, 0xff, 0x88, 0xe0, 0xeb]);\n+        let bobpk_expected = [0xde, 0x9e, 0xdb, 0x7d, 0x7b, 0x7d, 0xc1, 0xb4, 0xd3, 0x5b, 0x61,\n+                              0xc2, 0xec, 0xe4, 0x35, 0x37, 0x3f, 0x83, 0x43, 0xc8, 0x5b, 0x78,\n+                              0x67, 0x4d, 0xad, 0xfc, 0x7e, 0x14, 0x6f, 0x88, 0x2b, 0x4f];\n         let GroupElement(bobpk) = scalarmult_base(&bobsk);\n         assert!(bobpk == bobpk_expected);\n     }\n@@ -81,40 +84,46 @@ mod test {\n     #[test]\n     fn test_vector_3() {\n         // corresponding to tests/scalarmult5.c and tests/scalarmult7.cpp from NaCl\n-        let alicesk = Scalar([0x77,0x07,0x6d,0x0a,0x73,0x18,0xa5,0x7d\n-                             ,0x3c,0x16,0xc1,0x72,0x51,0xb2,0x66,0x45\n-                             ,0xdf,0x4c,0x2f,0x87,0xeb,0xc0,0x99,0x2a\n-                             ,0xb1,0x77,0xfb,0xa5,0x1d,0xb9,0x2c,0x2a]);\n-        let bobpk = GroupElement([0xde,0x9e,0xdb,0x7d,0x7b,0x7d,0xc1,0xb4\n-                                 ,0xd3,0x5b,0x61,0xc2,0xec,0xe4,0x35,0x37\n-                                 ,0x3f,0x83,0x43,0xc8,0x5b,0x78,0x67,0x4d\n-                                 ,0xad,0xfc,0x7e,0x14,0x6f,0x88,0x2b,0x4f]);\n-        let k_expected = [0x4a,0x5d,0x9d,0x5b,0xa4,0xce,0x2d,0xe1\n-                         ,0x72,0x8e,0x3b,0xf4,0x80,0x35,0x0f,0x25\n-                         ,0xe0,0x7e,0x21,0xc9,0x47,0xd1,0x9e,0x33\n-                         ,0x76,0xf0,0x9b,0x3c,0x1e,0x16,0x17,0x42];\n-        let GroupElement(k) = scalarmult(&alicesk, &bobpk);\n+        let alicesk = Scalar([0x77, 0x07, 0x6d, 0x0a, 0x73, 0x18, 0xa5, 0x7d, 0x3c, 0x16, 0xc1,\n+                              0x72, 0x51, 0xb2, 0x66, 0x45, 0xdf, 0x4c, 0x2f, 0x87, 0xeb, 0xc0,\n+                              0x99, 0x2a, 0xb1, 0x77, 0xfb, 0xa5, 0x1d, 0xb9, 0x2c, 0x2a]);\n+        let bobpk = GroupElement([0xde, 0x9e, 0xdb, 0x7d, 0x7b, 0x7d, 0xc1, 0xb4, 0xd3, 0x5b,\n+                                  0x61, 0xc2, 0xec, 0xe4, 0x35, 0x37, 0x3f, 0x83, 0x43, 0xc8,\n+                                  0x5b, 0x78, 0x67, 0x4d, 0xad, 0xfc, 0x7e, 0x14, 0x6f, 0x88,\n+                                  0x2b, 0x4f]);\n+        let k_expected = [0x4a, 0x5d, 0x9d, 0x5b, 0xa4, 0xce, 0x2d, 0xe1, 0x72, 0x8e, 0x3b, 0xf4,\n+                          0x80, 0x35, 0x0f, 0x25, 0xe0, 0x7e, 0x21, 0xc9, 0x47, 0xd1, 0x9e, 0x33,\n+                          0x76, 0xf0, 0x9b, 0x3c, 0x1e, 0x16, 0x17, 0x42];\n+        let GroupElement(k) = scalarmult(&alicesk, &bobpk).unwrap();\n         assert!(k == k_expected);\n     }\n \n     #[test]\n     fn test_vector_4() {\n         // corresponding to tests/scalarmult6.c from NaCl\n-        let bobsk = Scalar([0x5d,0xab,0x08,0x7e,0x62,0x4a,0x8a,0x4b\n-                           ,0x79,0xe1,0x7f,0x8b,0x83,0x80,0x0e,0xe6\n-                           ,0x6f,0x3b,0xb1,0x29,0x26,0x18,0xb6,0xfd\n-                           ,0x1c,0x2f,0x8b,0x27,0xff,0x88,0xe0,0xeb]);\n-        let alicepk = GroupElement([0x85,0x20,0xf0,0x09,0x89,0x30,0xa7,0x54\n-                                   ,0x74,0x8b,0x7d,0xdc,0xb4,0x3e,0xf7,0x5a\n-                                   ,0x0d,0xbf,0x3a,0x0d,0x26,0x38,0x1a,0xf4\n-                                   ,0xeb,0xa4,0xa9,0x8e,0xaa,0x9b,0x4e,0x6a]);\n-        let k_expected = [0x4a,0x5d,0x9d,0x5b,0xa4,0xce,0x2d,0xe1\n-                         ,0x72,0x8e,0x3b,0xf4,0x80,0x35,0x0f,0x25\n-                         ,0xe0,0x7e,0x21,0xc9,0x47,0xd1,0x9e,0x33\n-                         ,0x76,0xf0,0x9b,0x3c,0x1e,0x16,0x17,0x42];\n-        let GroupElement(k) = scalarmult(&bobsk, &alicepk);\n+        let bobsk = Scalar([0x5d, 0xab, 0x08, 0x7e, 0x62, 0x4a, 0x8a, 0x4b, 0x79, 0xe1, 0x7f,\n+                            0x8b, 0x83, 0x80, 0x0e, 0xe6, 0x6f, 0x3b, 0xb1, 0x29, 0x26, 0x18,\n+                            0xb6, 0xfd, 0x1c, 0x2f, 0x8b, 0x27, 0xff, 0x88, 0xe0, 0xeb]);\n+        let alicepk = GroupElement([0x85, 0x20, 0xf0, 0x09, 0x89, 0x30, 0xa7, 0x54, 0x74, 0x8b,\n+                                    0x7d, 0xdc, 0xb4, 0x3e, 0xf7, 0x5a, 0x0d, 0xbf, 0x3a, 0x0d,\n+                                    0x26, 0x38, 0x1a, 0xf4, 0xeb, 0xa4, 0xa9, 0x8e, 0xaa, 0x9b,\n+                                    0x4e, 0x6a]);\n+        let k_expected = [0x4a, 0x5d, 0x9d, 0x5b, 0xa4, 0xce, 0x2d, 0xe1, 0x72, 0x8e, 0x3b, 0xf4,\n+                          0x80, 0x35, 0x0f, 0x25, 0xe0, 0x7e, 0x21, 0xc9, 0x47, 0xd1, 0x9e, 0x33,\n+                          0x76, 0xf0, 0x9b, 0x3c, 0x1e, 0x16, 0x17, 0x42];\n+        let GroupElement(k) = scalarmult(&bobsk, &alicepk).unwrap();\n         assert!(k == k_expected);\n     }\n+\n+    #[test]\n+    #[should_panic]\n+    fn test_all_zero() {\n+        let mut sk = [0; SCALARBYTES];\n+        randombytes_into(&mut sk);\n+        let sk = Scalar(sk);\n+        let pk = GroupElement([0; GROUPELEMENTBYTES]);\n+        let _ = scalarmult(&sk, &pk).unwrap();\n+    }\n }\n \n #[cfg(feature = \"benchmarks\")]\n",
    "diff_parsed": "{'added': [(30, '                  &GroupElement(ref p): &GroupElement)'), (31, '                  -> Result<GroupElement, ()> {'), (34, '        if ffi::crypto_scalarmult_curve25519(&mut q, n, p) != 0 {'), (35, '            Err(())'), (36, '        } else {'), (37, '            Ok(GroupElement(q))'), (38, '        }'), (56, '    use randombytes::randombytes_into;'), (61, '        let alicesk = Scalar([0x77, 0x07, 0x6d, 0x0a, 0x73, 0x18, 0xa5, 0x7d, 0x3c, 0x16, 0xc1,'), (62, '                              0x72, 0x51, 0xb2, 0x66, 0x45, 0xdf, 0x4c, 0x2f, 0x87, 0xeb, 0xc0,'), (63, '                              0x99, 0x2a, 0xb1, 0x77, 0xfb, 0xa5, 0x1d, 0xb9, 0x2c, 0x2a]);'), (64, '        let alicepk_expected = [0x85, 0x20, 0xf0, 0x09, 0x89, 0x30, 0xa7, 0x54, 0x74, 0x8b, 0x7d,'), (65, '                                0xdc, 0xb4, 0x3e, 0xf7, 0x5a, 0x0d, 0xbf, 0x3a, 0x0d, 0x26, 0x38,'), (66, '                                0x1a, 0xf4, 0xeb, 0xa4, 0xa9, 0x8e, 0xaa, 0x9b, 0x4e, 0x6a];'), (74, '        let bobsk = Scalar([0x5d, 0xab, 0x08, 0x7e, 0x62, 0x4a, 0x8a, 0x4b, 0x79, 0xe1, 0x7f,'), (75, '                            0x8b, 0x83, 0x80, 0x0e, 0xe6, 0x6f, 0x3b, 0xb1, 0x29, 0x26, 0x18,'), (76, '                            0xb6, 0xfd, 0x1c, 0x2f, 0x8b, 0x27, 0xff, 0x88, 0xe0, 0xeb]);'), (77, '        let bobpk_expected = [0xde, 0x9e, 0xdb, 0x7d, 0x7b, 0x7d, 0xc1, 0xb4, 0xd3, 0x5b, 0x61,'), (78, '                              0xc2, 0xec, 0xe4, 0x35, 0x37, 0x3f, 0x83, 0x43, 0xc8, 0x5b, 0x78,'), (79, '                              0x67, 0x4d, 0xad, 0xfc, 0x7e, 0x14, 0x6f, 0x88, 0x2b, 0x4f];'), (87, '        let alicesk = Scalar([0x77, 0x07, 0x6d, 0x0a, 0x73, 0x18, 0xa5, 0x7d, 0x3c, 0x16, 0xc1,'), (88, '                              0x72, 0x51, 0xb2, 0x66, 0x45, 0xdf, 0x4c, 0x2f, 0x87, 0xeb, 0xc0,'), (89, '                              0x99, 0x2a, 0xb1, 0x77, 0xfb, 0xa5, 0x1d, 0xb9, 0x2c, 0x2a]);'), (90, '        let bobpk = GroupElement([0xde, 0x9e, 0xdb, 0x7d, 0x7b, 0x7d, 0xc1, 0xb4, 0xd3, 0x5b,'), (91, '                                  0x61, 0xc2, 0xec, 0xe4, 0x35, 0x37, 0x3f, 0x83, 0x43, 0xc8,'), (92, '                                  0x5b, 0x78, 0x67, 0x4d, 0xad, 0xfc, 0x7e, 0x14, 0x6f, 0x88,'), (93, '                                  0x2b, 0x4f]);'), (94, '        let k_expected = [0x4a, 0x5d, 0x9d, 0x5b, 0xa4, 0xce, 0x2d, 0xe1, 0x72, 0x8e, 0x3b, 0xf4,'), (95, '                          0x80, 0x35, 0x0f, 0x25, 0xe0, 0x7e, 0x21, 0xc9, 0x47, 0xd1, 0x9e, 0x33,'), (96, '                          0x76, 0xf0, 0x9b, 0x3c, 0x1e, 0x16, 0x17, 0x42];'), (97, '        let GroupElement(k) = scalarmult(&alicesk, &bobpk).unwrap();'), (104, '        let bobsk = Scalar([0x5d, 0xab, 0x08, 0x7e, 0x62, 0x4a, 0x8a, 0x4b, 0x79, 0xe1, 0x7f,'), (105, '                            0x8b, 0x83, 0x80, 0x0e, 0xe6, 0x6f, 0x3b, 0xb1, 0x29, 0x26, 0x18,'), (106, '                            0xb6, 0xfd, 0x1c, 0x2f, 0x8b, 0x27, 0xff, 0x88, 0xe0, 0xeb]);'), (107, '        let alicepk = GroupElement([0x85, 0x20, 0xf0, 0x09, 0x89, 0x30, 0xa7, 0x54, 0x74, 0x8b,'), (108, '                                    0x7d, 0xdc, 0xb4, 0x3e, 0xf7, 0x5a, 0x0d, 0xbf, 0x3a, 0x0d,'), (109, '                                    0x26, 0x38, 0x1a, 0xf4, 0xeb, 0xa4, 0xa9, 0x8e, 0xaa, 0x9b,'), (110, '                                    0x4e, 0x6a]);'), (111, '        let k_expected = [0x4a, 0x5d, 0x9d, 0x5b, 0xa4, 0xce, 0x2d, 0xe1, 0x72, 0x8e, 0x3b, 0xf4,'), (112, '                          0x80, 0x35, 0x0f, 0x25, 0xe0, 0x7e, 0x21, 0xc9, 0x47, 0xd1, 0x9e, 0x33,'), (113, '                          0x76, 0xf0, 0x9b, 0x3c, 0x1e, 0x16, 0x17, 0x42];'), (114, '        let GroupElement(k) = scalarmult(&bobsk, &alicepk).unwrap();'), (118, '    #[test]'), (119, '    #[should_panic]'), (120, '    fn test_all_zero() {'), (121, '        let mut sk = [0; SCALARBYTES];'), (122, '        randombytes_into(&mut sk);'), (123, '        let sk = Scalar(sk);'), (124, '        let pk = GroupElement([0; GROUPELEMENTBYTES]);'), (125, '        let _ = scalarmult(&sk, &pk).unwrap();'), (126, '    }')], 'deleted': [(28, '                  &GroupElement(ref p): &GroupElement) -> GroupElement {'), (31, '        ffi::crypto_scalarmult_curve25519(&mut q, n, p);'), (33, '    GroupElement(q)'), (54, '        let alicesk = Scalar([0x77,0x07,0x6d,0x0a,0x73,0x18,0xa5,0x7d'), (55, '                             ,0x3c,0x16,0xc1,0x72,0x51,0xb2,0x66,0x45'), (56, '                             ,0xdf,0x4c,0x2f,0x87,0xeb,0xc0,0x99,0x2a'), (57, '                             ,0xb1,0x77,0xfb,0xa5,0x1d,0xb9,0x2c,0x2a]);'), (58, '        let alicepk_expected = [0x85,0x20,0xf0,0x09,0x89,0x30,0xa7,0x54'), (59, '                               ,0x74,0x8b,0x7d,0xdc,0xb4,0x3e,0xf7,0x5a'), (60, '                               ,0x0d,0xbf,0x3a,0x0d,0x26,0x38,0x1a,0xf4'), (61, '                               ,0xeb,0xa4,0xa9,0x8e,0xaa,0x9b,0x4e,0x6a];'), (69, '        let bobsk = Scalar([0x5d,0xab,0x08,0x7e,0x62,0x4a,0x8a,0x4b'), (70, '                           ,0x79,0xe1,0x7f,0x8b,0x83,0x80,0x0e,0xe6'), (71, '                           ,0x6f,0x3b,0xb1,0x29,0x26,0x18,0xb6,0xfd'), (72, '                           ,0x1c,0x2f,0x8b,0x27,0xff,0x88,0xe0,0xeb]);'), (73, '        let bobpk_expected = [0xde,0x9e,0xdb,0x7d,0x7b,0x7d,0xc1,0xb4'), (74, '                             ,0xd3,0x5b,0x61,0xc2,0xec,0xe4,0x35,0x37'), (75, '                             ,0x3f,0x83,0x43,0xc8,0x5b,0x78,0x67,0x4d'), (76, '                             ,0xad,0xfc,0x7e,0x14,0x6f,0x88,0x2b,0x4f];'), (84, '        let alicesk = Scalar([0x77,0x07,0x6d,0x0a,0x73,0x18,0xa5,0x7d'), (85, '                             ,0x3c,0x16,0xc1,0x72,0x51,0xb2,0x66,0x45'), (86, '                             ,0xdf,0x4c,0x2f,0x87,0xeb,0xc0,0x99,0x2a'), (87, '                             ,0xb1,0x77,0xfb,0xa5,0x1d,0xb9,0x2c,0x2a]);'), (88, '        let bobpk = GroupElement([0xde,0x9e,0xdb,0x7d,0x7b,0x7d,0xc1,0xb4'), (89, '                                 ,0xd3,0x5b,0x61,0xc2,0xec,0xe4,0x35,0x37'), (90, '                                 ,0x3f,0x83,0x43,0xc8,0x5b,0x78,0x67,0x4d'), (91, '                                 ,0xad,0xfc,0x7e,0x14,0x6f,0x88,0x2b,0x4f]);'), (92, '        let k_expected = [0x4a,0x5d,0x9d,0x5b,0xa4,0xce,0x2d,0xe1'), (93, '                         ,0x72,0x8e,0x3b,0xf4,0x80,0x35,0x0f,0x25'), (94, '                         ,0xe0,0x7e,0x21,0xc9,0x47,0xd1,0x9e,0x33'), (95, '                         ,0x76,0xf0,0x9b,0x3c,0x1e,0x16,0x17,0x42];'), (96, '        let GroupElement(k) = scalarmult(&alicesk, &bobpk);'), (103, '        let bobsk = Scalar([0x5d,0xab,0x08,0x7e,0x62,0x4a,0x8a,0x4b'), (104, '                           ,0x79,0xe1,0x7f,0x8b,0x83,0x80,0x0e,0xe6'), (105, '                           ,0x6f,0x3b,0xb1,0x29,0x26,0x18,0xb6,0xfd'), (106, '                           ,0x1c,0x2f,0x8b,0x27,0xff,0x88,0xe0,0xeb]);'), (107, '        let alicepk = GroupElement([0x85,0x20,0xf0,0x09,0x89,0x30,0xa7,0x54'), (108, '                                   ,0x74,0x8b,0x7d,0xdc,0xb4,0x3e,0xf7,0x5a'), (109, '                                   ,0x0d,0xbf,0x3a,0x0d,0x26,0x38,0x1a,0xf4'), (110, '                                   ,0xeb,0xa4,0xa9,0x8e,0xaa,0x9b,0x4e,0x6a]);'), (111, '        let k_expected = [0x4a,0x5d,0x9d,0x5b,0xa4,0xce,0x2d,0xe1'), (112, '                         ,0x72,0x8e,0x3b,0xf4,0x80,0x35,0x0f,0x25'), (113, '                         ,0xe0,0x7e,0x21,0xc9,0x47,0xd1,0x9e,0x33'), (114, '                         ,0x76,0xf0,0x9b,0x3c,0x1e,0x16,0x17,0x42];'), (115, '        let GroupElement(k) = scalarmult(&bobsk, &alicepk);')]}",
    "num_lines_added": "51",
    "num_lines_deleted": "45",
    "nloc": "122"
  },
  {
    "file_change_id": "125555180047865",
    "hash": "ac30e169ae51b262bc8cf7026469851ce39b23c6",
    "old_path": "src/inner_connection.rs",
    "new_path": "src/inner_connection.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,4 +1,4 @@\n-use std::ffi::CString;\n+use std::ffi::CStr;\n use std::os::raw::{c_char, c_int};\n #[cfg(feature = \"load_extension\")]\n use std::path::Path;\n@@ -8,7 +8,7 @@ use std::sync::atomic::{AtomicBool, Ordering};\n use std::sync::{Arc, Mutex};\n \n use super::ffi;\n-use super::{str_for_sqlite, str_to_cstring};\n+use super::str_for_sqlite;\n use super::{Connection, InterruptHandle, OpenFlags, Result};\n use crate::error::{error_from_handle, error_from_sqlite_code, Error};\n use crate::raw_statement::RawStatement;\n@@ -51,9 +51,9 @@ impl InnerConnection {\n     }\n \n     pub fn open_with_flags(\n-        c_path: &CString,\n+        c_path: &CStr,\n         flags: OpenFlags,\n-        vfs: Option<&CString>,\n+        vfs: Option<&CStr>,\n     ) -> Result<InnerConnection> {\n         #[cfg(not(feature = \"bundled\"))]\n         ensure_valid_sqlite_version();\n@@ -171,7 +171,8 @@ impl InnerConnection {\n     }\n \n     pub fn execute_batch(&mut self, sql: &str) -> Result<()> {\n-        let c_sql = str_to_cstring(sql)?;\n+        // use CString instead of SmallCString because it's probably big.\n+        let c_sql = std::ffi::CString::new(sql)?;\n         unsafe {\n             let r = ffi::sqlite3_exec(\n                 self.db(),\n@@ -196,7 +197,7 @@ impl InnerConnection {\n         unsafe {\n             let mut errmsg: *mut c_char = ptr::null_mut();\n             let r = if let Some(entry_point) = entry_point {\n-                let c_entry = str_to_cstring(entry_point)?;\n+                let c_entry = crate::str_to_cstring(entry_point)?;\n                 ffi::sqlite3_load_extension(\n                     self.db,\n                     dylib_str.as_ptr(),\n",
    "diff_parsed": "{'added': [(1, 'use std::ffi::CStr;'), (11, 'use super::str_for_sqlite;'), (54, '        c_path: &CStr,'), (56, '        vfs: Option<&CStr>,'), (175, '        let c_sql = std::ffi::CString::new(sql)?;'), (200, '                let c_entry = crate::str_to_cstring(entry_point)?;')], 'deleted': [(1, 'use std::ffi::CString;'), (11, 'use super::{str_for_sqlite, str_to_cstring};'), (54, '        c_path: &CString,'), (56, '        vfs: Option<&CString>,'), (174, '        let c_sql = str_to_cstring(sql)?;'), (199, '                let c_entry = str_to_cstring(entry_point)?;')]}",
    "num_lines_added": "6",
    "num_lines_deleted": "6",
    "nloc": "402"
  },
  {
    "file_change_id": "244123576375378",
    "hash": "ac30e169ae51b262bc8cf7026469851ce39b23c6",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -129,6 +129,7 @@ mod version;\n pub mod vtab;\n \n pub(crate) mod util;\n+pub(crate) use util::SmallCString;\n \n // Number of cached prepared statements we'll hold on to.\n const STATEMENT_CACHE_DEFAULT_CAPACITY: usize = 16;\n@@ -233,8 +234,8 @@ unsafe fn errmsg_to_string(errmsg: *const c_char) -> String {\n     String::from_utf8_lossy(c_slice).into_owned()\n }\n \n-fn str_to_cstring(s: &str) -> Result<CString> {\n-    Ok(CString::new(s)?)\n+fn str_to_cstring(s: &str) -> Result<SmallCString> {\n+    Ok(SmallCString::new(s)?)\n }\n \n /// Returns `Ok((string ptr, len as c_int, SQLITE_STATIC | SQLITE_TRANSIENT))`\n@@ -301,7 +302,7 @@ pub enum DatabaseName<'a> {\n     feature = \"modern_sqlite\"\n ))]\n impl DatabaseName<'_> {\n-    fn to_cstring(&self) -> Result<CString> {\n+    fn to_cstring(&self) -> Result<util::SmallCString> {\n         use self::DatabaseName::{Attached, Main, Temp};\n         match *self {\n             Main => str_to_cstring(\"main\"),\n",
    "diff_parsed": "{'added': [(132, 'pub(crate) use util::SmallCString;'), (237, 'fn str_to_cstring(s: &str) -> Result<SmallCString> {'), (238, '    Ok(SmallCString::new(s)?)'), (305, '    fn to_cstring(&self) -> Result<util::SmallCString> {')], 'deleted': [(236, 'fn str_to_cstring(s: &str) -> Result<CString> {'), (237, '    Ok(CString::new(s)?)'), (304, '    fn to_cstring(&self) -> Result<CString> {')]}",
    "num_lines_added": "4",
    "num_lines_deleted": "3",
    "nloc": "1416"
  },
  {
    "file_change_id": "196638160731892",
    "hash": "ac30e169ae51b262bc8cf7026469851ce39b23c6",
    "old_path": "src/session.rs",
    "new_path": "src/session.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -102,10 +102,11 @@ impl Session<'_> {\n     /// Attach a table. `None` means all tables.\n     pub fn attach(&mut self, table: Option<&str>) -> Result<()> {\n         let table = if let Some(table) = table {\n-            str_to_cstring(table)?.as_ptr()\n+            Some(str_to_cstring(table)?)\n         } else {\n-            ptr::null()\n+            None\n         };\n+        let table = table.as_ref().map(|s| s.as_ptr()).unwrap_or(ptr::null());\n         unsafe { check!(ffi::sqlite3session_attach(self.s, table)) };\n         Ok(())\n     }\n@@ -156,7 +157,8 @@ impl Session<'_> {\n     /// Load the difference between tables.\n     pub fn diff(&mut self, from: DatabaseName<'_>, table: &str) -> Result<()> {\n         let from = from.to_cstring()?;\n-        let table = str_to_cstring(table)?.as_ptr();\n+        let table = str_to_cstring(table)?;\n+        let table = table.as_ptr();\n         unsafe {\n             let mut errmsg = ptr::null_mut();\n             let r =\n",
    "diff_parsed": "{'added': [(105, '            Some(str_to_cstring(table)?)'), (107, '            None'), (109, '        let table = table.as_ref().map(|s| s.as_ptr()).unwrap_or(ptr::null());'), (160, '        let table = str_to_cstring(table)?;'), (161, '        let table = table.as_ptr();')], 'deleted': [(105, '            str_to_cstring(table)?.as_ptr()'), (107, '            ptr::null()'), (159, '        let table = str_to_cstring(table)?.as_ptr();')]}",
    "num_lines_added": "5",
    "num_lines_deleted": "3",
    "nloc": "818"
  },
  {
    "file_change_id": "196236214554349",
    "hash": "7ab8a264980d23c2ed64e72f4636f38b7381eb39",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -178,7 +178,7 @@ pub fn time_remaining(timeout_point: std::time::Instant) -> std::time::Duration\n /// Creates a future for `job` and runs `job`. The result of `job` will be set as result into the\n /// future. The parameter passed to `job` is a function that returns if the future is still waiting\n /// so that `job` can check for cancellation.\n-pub fn async_with_state<T: 'static, U: 'static, F: FnOnce(Future<T, U>) + Send + 'static>(job: F, shared_state: U) -> Future<T, U> {\n+pub fn async_with_state<T: 'static + Send, U: 'static + Send, F: FnOnce(Future<T, U>) + Send + 'static>(job: F, shared_state: U) -> Future<T, U> {\n \tuse std::clone::Clone;\n \t\n \t// Create future and spawn job\n@@ -192,7 +192,7 @@ pub fn async_with_state<T: 'static, U: 'static, F: FnOnce(Future<T, U>) + Send +\n /// Creates a future for `job` and runs `job`. The result of `job` will be set as result into the\n /// future. The parameter passed to `job` is a function that returns if the future is still waiting\n /// so that `job` can check for cancellation.\n-pub fn async<T: 'static, F: FnOnce(Future<T, ()>) + Send + 'static>(job: F) -> Future<T, ()> {\n+pub fn async<T: 'static + Send, F: FnOnce(Future<T, ()>) + Send + 'static>(job: F) -> Future<T, ()> {\n \tasync_with_state(job, ())\n }\n \n",
    "diff_parsed": "{'added': [(181, \"pub fn async_with_state<T: 'static + Send, U: 'static + Send, F: FnOnce(Future<T, U>) + Send + 'static>(job: F, shared_state: U) -> Future<T, U> {\"), (195, \"pub fn async<T: 'static + Send, F: FnOnce(Future<T, ()>) + Send + 'static>(job: F) -> Future<T, ()> {\")], 'deleted': [(181, \"pub fn async_with_state<T: 'static, U: 'static, F: FnOnce(Future<T, U>) + Send + 'static>(job: F, shared_state: U) -> Future<T, U> {\"), (195, \"pub fn async<T: 'static, F: FnOnce(Future<T, ()>) + Send + 'static>(job: F) -> Future<T, ()> {\")]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "193"
  },
  {
    "file_change_id": "13032585336021",
    "hash": "c7919199a0f6d1ce0e3c33499d1b37f862c990e4",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -162,7 +162,7 @@ impl<T, U> Clone for Future<T, U> {\n \t\tFuture(self.0.clone())\n \t}\n }\n-unsafe impl<T, U> Send for Future<T, U> {}\n+unsafe impl<T: Send, U: Send> Send for Future<T, U> {}\n unsafe impl<T, U> Sync for Future<T, U> {}\n \n \n",
    "diff_parsed": "{'added': [(165, 'unsafe impl<T: Send, U: Send> Send for Future<T, U> {}')], 'deleted': [(165, 'unsafe impl<T, U> Send for Future<T, U> {}')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "193"
  },
  {
    "file_change_id": "63544457081278",
    "hash": "2ef3628dac35aeba0a97d5fb3a57746b4e1d62b3",
    "old_path": "src/functions.rs",
    "new_path": "src/functions.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -12,6 +12,8 @@\n //! use regex::Regex;\n //! use rusqlite::functions::FunctionFlags;\n //! use rusqlite::{Connection, Error, Result, NO_PARAMS};\n+//! use std::sync::Arc;\n+//! type BoxError = Box<dyn std::error::Error + Send + Sync + 'static>;\n //!\n //! fn add_regexp_function(db: &Connection) -> Result<()> {\n //!     db.create_scalar_function(\n@@ -20,34 +22,19 @@\n //!         FunctionFlags::SQLITE_UTF8 | FunctionFlags::SQLITE_DETERMINISTIC,\n //!         move |ctx| {\n //!             assert_eq!(ctx.len(), 2, \"called with unexpected number of arguments\");\n-//!\n-//!             let saved_re: Option<&Regex> = ctx.get_aux(0)?;\n-//!             let new_re = match saved_re {\n-//!                 None => {\n-//!                     let s = ctx.get::<String>(0)?;\n-//!                     match Regex::new(&s) {\n-//!                         Ok(r) => Some(r),\n-//!                         Err(err) => return Err(Error::UserFunctionError(Box::new(err))),\n-//!                     }\n-//!                 }\n-//!                 Some(_) => None,\n-//!             };\n-//!\n+//!             let regexp: Arc<Regex> = ctx\n+//!                 .get_or_create_aux(0, |vr| -> Result<_, BoxError> {\n+//!                     Ok(Regex::new(vr.as_str()?)?)\n+//!                 })?;\n //!             let is_match = {\n-//!                 let re = saved_re.unwrap_or_else(|| new_re.as_ref().unwrap());\n-//!\n //!                 let text = ctx\n //!                     .get_raw(1)\n //!                     .as_str()\n //!                     .map_err(|e| Error::UserFunctionError(e.into()))?;\n //!\n-//!                 re.is_match(text)\n+//!                 regexp.is_match(text)\n //!             };\n //!\n-//!             if let Some(re) = new_re {\n-//!                 ctx.set_aux(0, re);\n-//!             }\n-//!\n //!             Ok(is_match)\n //!         },\n //!     )\n@@ -67,11 +54,12 @@\n //!     Ok(())\n //! }\n //! ```\n-use std::any::TypeId;\n+use std::any::Any;\n use std::os::raw::{c_int, c_void};\n use std::panic::{catch_unwind, RefUnwindSafe, UnwindSafe};\n use std::ptr;\n use std::slice;\n+use std::sync::Arc;\n \n use crate::ffi;\n use crate::ffi::sqlite3_context;\n@@ -121,6 +109,7 @@ unsafe extern \"C\" fn free_boxed_value<T>(p: *mut c_void) {\n pub struct Context<'a> {\n     ctx: *mut sqlite3_context,\n     args: &'a [*mut sqlite3_value],\n+    // conn: PhantomData<&'conn mut Connection>,\n }\n \n impl Context<'_> {\n@@ -174,47 +163,60 @@ impl Context<'_> {\n         unsafe { ValueRef::from_value(arg) }\n     }\n \n+    pub fn get_or_create_aux<T, E, F>(&self, arg: c_int, func: F) -> Result<Arc<T>>\n+    where\n+        T: Send + Sync + 'static,\n+        E: Into<Box<dyn std::error::Error + Send + Sync + 'static>>,\n+        F: FnOnce(ValueRef<'_>) -> Result<T, E>,\n+    {\n+        if let Some(v) = self.get_aux(arg)? {\n+            Ok(v)\n+        } else {\n+            let vr = self.get_raw(arg as usize);\n+            self.set_aux(\n+                arg,\n+                func(vr).map_err(|e| Error::UserFunctionError(e.into()))?,\n+            )\n+        }\n+    }\n+\n     /// Sets the auxilliary data associated with a particular parameter. See\n     /// https://www.sqlite.org/c3ref/get_auxdata.html for a discussion of\n     /// this feature, or the unit tests of this module for an example.\n-    pub fn set_aux<T: 'static>(&self, arg: c_int, value: T) {\n-        let boxed = Box::into_raw(Box::new(AuxData {\n-            id: TypeId::of::<T>(),\n-            value,\n-        }));\n+    pub fn set_aux<T: Send + Sync + 'static>(&self, arg: c_int, value: T) -> Result<Arc<T>> {\n+        let orig: Arc<T> = Arc::new(value);\n+        let inner: AuxInner = orig.clone();\n+        let outer = Box::new(inner);\n+        let raw: *mut AuxInner = Box::into_raw(outer);\n         unsafe {\n             ffi::sqlite3_set_auxdata(\n                 self.ctx,\n                 arg,\n-                boxed as *mut c_void,\n-                Some(free_boxed_value::<AuxData<T>>),\n+                raw as *mut _,\n+                Some(free_boxed_value::<AuxInner>),\n             )\n         };\n+        Ok(orig)\n     }\n \n-    /// Gets the auxilliary data that was associated with a given parameter\n-    /// via `set_aux`. Returns `Ok(None)` if no data has been associated,\n-    /// and .\n-    pub fn get_aux<T: 'static>(&self, arg: c_int) -> Result<Option<&T>> {\n-        let p = unsafe { ffi::sqlite3_get_auxdata(self.ctx, arg) as *const AuxData<T> };\n+    /// Gets the auxilliary data that was associated with a given parameter via\n+    /// `set_aux`. Returns `Ok(None)` if no data has been associated, and\n+    /// Ok(Some(v)) if it has. Returns an error if the requested type does not\n+    /// match.\n+    pub fn get_aux<T: Send + Sync + 'static>(&self, arg: c_int) -> Result<Option<Arc<T>>> {\n+        let p = unsafe { ffi::sqlite3_get_auxdata(self.ctx, arg) as *const AuxInner };\n         if p.is_null() {\n             Ok(None)\n         } else {\n-            let id = unsafe { (*p).id };\n-            if TypeId::of::<T>() != id {\n-                Err(Error::GetAuxWrongType)\n-            } else {\n-                Ok(Some(unsafe { &(*p).value }))\n-            }\n+            let v: AuxInner = AuxInner::clone(unsafe { &*p });\n+            v.downcast::<T>()\n+                .map(Some)\n+                .map_err(|_| Error::GetAuxWrongType)\n         }\n     }\n }\n \n-#[repr(C)]\n-struct AuxData<T: 'static> {\n-    id: TypeId,\n-    value: T,\n-}\n+type AuxInner = Arc<dyn Any + Send + Sync + 'static>;\n \n /// `feature = \"functions\"` Aggregate is the callback interface for user-defined\n /// aggregate function.\n@@ -776,34 +778,21 @@ mod test {\n     // expression multiple times within one query.\n     fn regexp_with_auxilliary(ctx: &Context<'_>) -> Result<bool> {\n         assert_eq!(ctx.len(), 2, \"called with unexpected number of arguments\");\n-\n-        let saved_re: Option<&Regex> = ctx.get_aux(0)?;\n-        let new_re = match saved_re {\n-            None => {\n-                let s = ctx.get::<String>(0)?;\n-                match Regex::new(&s) {\n-                    Ok(r) => Some(r),\n-                    Err(err) => return Err(Error::UserFunctionError(Box::new(err))),\n-                }\n-            }\n-            Some(_) => None,\n-        };\n+        type BoxError = Box<dyn std::error::Error + Send + Sync + 'static>;\n+        let regexp: std::sync::Arc<Regex> = ctx\n+            .get_or_create_aux(0, |vr| -> Result<_, BoxError> {\n+                Ok(Regex::new(vr.as_str()?)?)\n+            })?;\n \n         let is_match = {\n-            let re = saved_re.unwrap_or_else(|| new_re.as_ref().unwrap());\n-\n             let text = ctx\n                 .get_raw(1)\n                 .as_str()\n                 .map_err(|e| Error::UserFunctionError(e.into()))?;\n \n-            re.is_match(text)\n+            regexp.is_match(text)\n         };\n \n-        if let Some(re) = new_re {\n-            ctx.set_aux(0, re);\n-        }\n-\n         Ok(is_match)\n     }\n \n@@ -878,10 +867,10 @@ mod test {\n         let db = Connection::open_in_memory().unwrap();\n         db.create_scalar_function(\"example\", 2, FunctionFlags::default(), |ctx| {\n             if !ctx.get::<bool>(1)? {\n-                ctx.set_aux::<i64>(0, 100);\n+                ctx.set_aux::<i64>(0, 100)?;\n             } else {\n                 assert_eq!(ctx.get_aux::<String>(0), Err(Error::GetAuxWrongType));\n-                assert_eq!(ctx.get_aux::<i64>(0), Ok(Some(&100)));\n+                assert_eq!(*ctx.get_aux::<i64>(0).unwrap().unwrap(), 100);\n             }\n             Ok(true)\n         })\n",
    "diff_parsed": "{'added': [(57, 'use std::any::Any;'), (62, 'use std::sync::Arc;'), (166, '    pub fn get_or_create_aux<T, E, F>(&self, arg: c_int, func: F) -> Result<Arc<T>>'), (167, '    where'), (168, \"        T: Send + Sync + 'static,\"), (169, \"        E: Into<Box<dyn std::error::Error + Send + Sync + 'static>>,\"), (170, \"        F: FnOnce(ValueRef<'_>) -> Result<T, E>,\"), (171, '    {'), (172, '        if let Some(v) = self.get_aux(arg)? {'), (173, '            Ok(v)'), (174, '        } else {'), (175, '            let vr = self.get_raw(arg as usize);'), (176, '            self.set_aux('), (177, '                arg,'), (178, '                func(vr).map_err(|e| Error::UserFunctionError(e.into()))?,'), (179, '            )'), (180, '        }'), (181, '    }'), (186, \"    pub fn set_aux<T: Send + Sync + 'static>(&self, arg: c_int, value: T) -> Result<Arc<T>> {\"), (187, '        let orig: Arc<T> = Arc::new(value);'), (188, '        let inner: AuxInner = orig.clone();'), (189, '        let outer = Box::new(inner);'), (190, '        let raw: *mut AuxInner = Box::into_raw(outer);'), (195, '                raw as *mut _,'), (196, '                Some(free_boxed_value::<AuxInner>),'), (199, '        Ok(orig)'), (206, \"    pub fn get_aux<T: Send + Sync + 'static>(&self, arg: c_int) -> Result<Option<Arc<T>>> {\"), (207, '        let p = unsafe { ffi::sqlite3_get_auxdata(self.ctx, arg) as *const AuxInner };'), (211, '            let v: AuxInner = AuxInner::clone(unsafe { &*p });'), (212, '            v.downcast::<T>()'), (213, '                .map(Some)'), (214, '                .map_err(|_| Error::GetAuxWrongType)'), (219, \"type AuxInner = Arc<dyn Any + Send + Sync + 'static>;\"), (781, \"        type BoxError = Box<dyn std::error::Error + Send + Sync + 'static>;\"), (782, '        let regexp: std::sync::Arc<Regex> = ctx'), (783, '            .get_or_create_aux(0, |vr| -> Result<_, BoxError> {'), (784, '                Ok(Regex::new(vr.as_str()?)?)'), (785, '            })?;'), (793, '            regexp.is_match(text)'), (870, '                ctx.set_aux::<i64>(0, 100)?;'), (873, '                assert_eq!(*ctx.get_aux::<i64>(0).unwrap().unwrap(), 100);')], 'deleted': [(70, 'use std::any::TypeId;'), (180, \"    pub fn set_aux<T: 'static>(&self, arg: c_int, value: T) {\"), (181, '        let boxed = Box::into_raw(Box::new(AuxData {'), (182, '            id: TypeId::of::<T>(),'), (183, '            value,'), (184, '        }));'), (189, '                boxed as *mut c_void,'), (190, '                Some(free_boxed_value::<AuxData<T>>),'), (198, \"    pub fn get_aux<T: 'static>(&self, arg: c_int) -> Result<Option<&T>> {\"), (199, '        let p = unsafe { ffi::sqlite3_get_auxdata(self.ctx, arg) as *const AuxData<T> };'), (203, '            let id = unsafe { (*p).id };'), (204, '            if TypeId::of::<T>() != id {'), (205, '                Err(Error::GetAuxWrongType)'), (206, '            } else {'), (207, '                Ok(Some(unsafe { &(*p).value }))'), (208, '            }'), (213, '#[repr(C)]'), (214, \"struct AuxData<T: 'static> {\"), (215, '    id: TypeId,'), (216, '    value: T,'), (217, '}'), (780, '        let saved_re: Option<&Regex> = ctx.get_aux(0)?;'), (781, '        let new_re = match saved_re {'), (782, '            None => {'), (783, '                let s = ctx.get::<String>(0)?;'), (784, '                match Regex::new(&s) {'), (785, '                    Ok(r) => Some(r),'), (786, '                    Err(err) => return Err(Error::UserFunctionError(Box::new(err))),'), (787, '                }'), (788, '            }'), (789, '            Some(_) => None,'), (790, '        };'), (793, '            let re = saved_re.unwrap_or_else(|| new_re.as_ref().unwrap());'), (800, '            re.is_match(text)'), (803, '        if let Some(re) = new_re {'), (804, '            ctx.set_aux(0, re);'), (805, '        }'), (881, '                ctx.set_aux::<i64>(0, 100);'), (884, '                assert_eq!(ctx.get_aux::<i64>(0), Ok(Some(&100)));')]}",
    "num_lines_added": "41",
    "num_lines_deleted": "39",
    "nloc": "842"
  },
  {
    "file_change_id": "182910840050658",
    "hash": "bf2b2df9c9e218e35e5a38ce3d03cffb7c363956",
    "old_path": "src/less.rs",
    "new_path": "src/less.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -4,7 +4,9 @@ use std::ffi::OsStr;\n use std::process::Command;\n \n pub fn retrieve_less_version(less_path: &dyn AsRef<OsStr>) -> Option<usize> {\n-    let cmd = Command::new(less_path).arg(\"--version\").output().ok()?;\n+    let resolved_path = grep_cli::resolve_binary(less_path.as_ref()).ok()?;\n+\n+    let cmd = Command::new(resolved_path).arg(\"--version\").output().ok()?;\n     parse_less_version(&cmd.stdout)\n }\n \n",
    "diff_parsed": "{'added': [(7, '    let resolved_path = grep_cli::resolve_binary(less_path.as_ref()).ok()?;'), (9, '    let cmd = Command::new(resolved_path).arg(\"--version\").output().ok()?;')], 'deleted': [(7, '    let cmd = Command::new(less_path).arg(\"--version\").output().ok()?;')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "1",
    "nloc": "66"
  },
  {
    "file_change_id": "164478871683636",
    "hash": "bf2b2df9c9e218e35e5a38ce3d03cffb7c363956",
    "old_path": "src/output.rs",
    "new_path": "src/output.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -63,7 +63,14 @@ impl OutputType {\n             return Err(ErrorKind::InvalidPagerValueBat.into());\n         }\n \n-        let mut p = Command::new(&pager.bin);\n+        let resolved_path = match grep_cli::resolve_binary(&pager.bin) {\n+            Ok(path) => path,\n+            Err(_) => {\n+                return Ok(OutputType::stdout());\n+            }\n+        };\n+\n+        let mut p = Command::new(resolved_path);\n         let args = pager.args;\n \n         if pager.kind == PagerKind::Less {\n",
    "diff_parsed": "{'added': [(66, '        let resolved_path = match grep_cli::resolve_binary(&pager.bin) {'), (67, '            Ok(path) => path,'), (68, '            Err(_) => {'), (69, '                return Ok(OutputType::stdout());'), (70, '            }'), (71, '        };'), (73, '        let mut p = Command::new(resolved_path);')], 'deleted': [(66, '        let mut p = Command::new(&pager.bin);')]}",
    "num_lines_added": "7",
    "num_lines_deleted": "1",
    "nloc": "124"
  },
  {
    "file_change_id": "248712374326501",
    "hash": "a34d6e1",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -33,7 +33,7 @@ where\n \n unsafe impl<R> Send for Decoder<R>\n where\n-        R: Read,\n+        R: Read + Send,\n {\n }\n \n",
    "diff_parsed": "{'added': [(36, '        R: Read + Send,')], 'deleted': [(36, '        R: Read,')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "109"
  },
  {
    "file_change_id": "50353082589092",
    "hash": "92f40b4a2c671553dfa96feacff0265206c44ce5",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -377,8 +377,8 @@ where\n     _marker: marker::PhantomData<S>,\n }\n \n-unsafe impl<T, S> Send for Unordered<T, S> where S: Sentinel {}\n-unsafe impl<T, S> Sync for Unordered<T, S> where S: Sentinel {}\n+unsafe impl<T, S> Send for Unordered<T, S> where S: Send + Sentinel {}\n+unsafe impl<T, S> Sync for Unordered<T, S> where S: Sync + Sentinel {}\n \n impl<T, S> Unpin for Unordered<T, S> where S: Sentinel {}\n \n",
    "diff_parsed": "{'added': [(380, 'unsafe impl<T, S> Send for Unordered<T, S> where S: Send + Sentinel {}'), (381, 'unsafe impl<T, S> Sync for Unordered<T, S> where S: Sync + Sentinel {}')], 'deleted': [(380, 'unsafe impl<T, S> Send for Unordered<T, S> where S: Sentinel {}'), (381, 'unsafe impl<T, S> Sync for Unordered<T, S> where S: Sentinel {}')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "419"
  },
  {
    "file_change_id": "3257296433400",
    "hash": "92f40b4a2c671553dfa96feacff0265206c44ce5",
    "old_path": "src/pin_slab.rs",
    "new_path": "src/pin_slab.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -40,8 +40,8 @@ pub struct PinSlab<T> {\n     next: usize,\n }\n \n-unsafe impl<T> Send for PinSlab<T> {}\n-unsafe impl<T> Sync for PinSlab<T> {}\n+unsafe impl<T> Send for PinSlab<T> where T: Send {}\n+unsafe impl<T> Sync for PinSlab<T> where T: Sync {}\n \n enum Entry<T> {\n     // Each slot is pre-allocated with entries of `None`.\n",
    "diff_parsed": "{'added': [(43, 'unsafe impl<T> Send for PinSlab<T> where T: Send {}'), (44, 'unsafe impl<T> Sync for PinSlab<T> where T: Sync {}')], 'deleted': [(43, 'unsafe impl<T> Send for PinSlab<T> {}'), (44, 'unsafe impl<T> Sync for PinSlab<T> {}')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "207"
  },
  {
    "file_change_id": "172909470768061",
    "hash": "7c7757c772fb709c61b1442bcc1e1fbee97bf4a8",
    "old_path": "lucet-runtime/lucet-runtime-internals/src/instance.rs",
    "new_path": "lucet-runtime/lucet-runtime-internals/src/instance.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -14,7 +14,6 @@ use crate::error::Error;\n #[cfg(feature = \"concurrent_testpoints\")]\n use crate::lock_testpoints::LockTestpoints;\n use crate::module::{self, FunctionHandle, Global, GlobalValue, Module, TrapCode};\n-use crate::region::RegionInternal;\n use crate::sysdeps::HOST_PAGE_SIZE_EXPECTED;\n use crate::val::{UntypedRetVal, Val};\n use crate::vmctx::Vmctx;\n@@ -27,6 +26,7 @@ use std::cell::{BorrowError, BorrowMutError, Ref, RefCell, RefMut, UnsafeCell};\n use std::convert::TryFrom;\n use std::marker::PhantomData;\n use std::mem;\n+use std::mem::ManuallyDrop;\n use std::ops::{Deref, DerefMut};\n use std::ptr::{self, NonNull};\n use std::sync::Arc;\n@@ -147,20 +147,29 @@ impl Drop for InstanceHandle {\n             unsafe {\n                 let inst = self.inst.as_mut();\n \n-                // Grab a handle to the region to ensure it outlives `inst`.\n+                // The `inst.alloc` field manages the memory of the instance\n+                // itself. Note, though, that this field is in a `ManuallyDrop`\n+                // so it won't get dropped automatically in `drop_in_place`.\n+                // This is the point where we take over that precise drop.\n                 //\n-                // This ensures that the region won't be dropped by `inst` being\n-                // dropped, which could result in `inst` being unmapped by the\n-                // Region *during* drop of the Instance's fields.\n-                let region: Arc<dyn RegionInternal> = inst.alloc().region.clone();\n+                // By using `take` here we're basically calling `ptr::read`\n+                // which \"duplicates\" the `alloc` since the `alloc` local\n+                // variable here is the exact same as `inst.alloc`. All we do\n+                // with `inst`, though, is call `drop_in_place`, which\n+                // invalidates every other field in `inst`.\n+                let alloc: Alloc = ManuallyDrop::take(&mut inst.alloc);\n \n                 // drop the actual instance\n                 std::ptr::drop_in_place(inst);\n \n-                // and now we can drop what may be the last Arc<Region>. If it is\n-                // it can safely do what it needs with memory; we're not running\n-                // destructors on it anymore.\n-                mem::drop(region);\n+                // Now that we're 100% done with the instance, destructors and\n+                // all, we can release the memory of the instance back to the\n+                // original allocator from whence it came (be it mmap or uffd\n+                // based). This will run the \"official\" destructor for `Alloc`\n+                // which internally does the release. Note that after this\n+                // operation the `inst` pointer is invalid and can no longer be\n+                // used.\n+                drop(alloc);\n             }\n         }\n     }\n@@ -233,8 +242,12 @@ pub struct Instance {\n     /// Conditionally-present helpers to force permutations of possible races in testing.\n     pub lock_testpoints: Arc<LockTestpoints>,\n \n-    /// The memory allocated for this instance\n-    alloc: Alloc,\n+    /// The memory allocated for this instance.\n+    ///\n+    /// Note that this is in a `ManuallyDrop` because this manages the memory of\n+    /// this `Instance` itself. To have precise control over this memory we\n+    /// handle this in `Drop for InstanceHandle`.\n+    alloc: ManuallyDrop<Alloc>,\n \n     /// Handler run for signals that do not arise from a known WebAssembly trap, or that involve\n     /// memory outside of the current instance.\n@@ -1055,7 +1068,7 @@ impl Instance {\n             kill_state,\n             #[cfg(feature = \"concurrent_testpoints\")]\n             lock_testpoints,\n-            alloc,\n+            alloc: ManuallyDrop::new(alloc),\n             fatal_handler: default_fatal_handler,\n             c_fatal_handler: None,\n             signal_handler: Box::new(signal_handler_none) as Box<SignalHandler>,\n",
    "diff_parsed": "{'added': [(29, 'use std::mem::ManuallyDrop;'), (160, '                let alloc: Alloc = ManuallyDrop::take(&mut inst.alloc);'), (172, '                drop(alloc);'), (250, '    alloc: ManuallyDrop<Alloc>,'), (1071, '            alloc: ManuallyDrop::new(alloc),')], 'deleted': [(17, 'use crate::region::RegionInternal;'), (155, '                let region: Arc<dyn RegionInternal> = inst.alloc().region.clone();'), (163, '                mem::drop(region);'), (237, '    alloc: Alloc,'), (1058, '            alloc,')]}",
    "num_lines_added": "5",
    "num_lines_deleted": "5",
    "nloc": "975"
  },
  {
    "file_change_id": "1130472829314",
    "hash": "b0d2bd20eb40b9cbc2958b981ba2dcd9e6f9396e",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -81,8 +81,10 @@ pub struct Singleton<T: 'static> {\n \n // The Singleton need to implement Send & Sync to ensure cross core compile check mechanics\n // this is safe as the inner RWLock ensures cross core safety\n-unsafe impl<T> Sync for Singleton<T> {}\n-unsafe impl<T> Send for Singleton<T> {}\n+// but we need to be conditional on the inner type to prevent interior mutable types beeing used\n+// inside a singleton\n+unsafe impl<T> Sync for Singleton<T> where T: Sync {}\n+unsafe impl<T> Send for Singleton<T> where T: Send {}\n \n impl<T: 'static> Singleton<T> {\n     /// Create a new [Singleton] instance to be used in a static variable. Only ``const fn`` constructors are allowed\n",
    "diff_parsed": "{'added': [(86, 'unsafe impl<T> Sync for Singleton<T> where T: Sync {}'), (87, 'unsafe impl<T> Send for Singleton<T> where T: Send {}')], 'deleted': [(84, 'unsafe impl<T> Sync for Singleton<T> {}'), (85, 'unsafe impl<T> Send for Singleton<T> {}')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "51"
  },
  {
    "file_change_id": "146229752741992",
    "hash": "0a1da873ddb29bca926bad8301f8d7ab8aa97c52",
    "old_path": "src/config.rs",
    "new_path": "src/config.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -130,13 +130,13 @@ impl From<ExpanderConfig> for u8 {\n ///     .unwrap();\n /// ```\n #[must_use = \"Configuration changes are not applied unless committed\"]\n-pub struct Configurator<'e, EI: ExpanderInterface> {\n+pub struct Configurator<'e, EI: ExpanderInterface + Send> {\n     expander: &'e mut Expander<EI>,\n     expander_config_dirty: bool,\n     banks: [BankConfig; 7],\n }\n \n-impl<'e, EI: ExpanderInterface> Configurator<'e, EI> {\n+impl<'e, EI: ExpanderInterface + Send> Configurator<'e, EI> {\n     pub(crate) fn new(expander: &'e mut Expander<EI>) -> Self {\n         Self {\n             expander,\n",
    "diff_parsed": "{'added': [(133, \"pub struct Configurator<'e, EI: ExpanderInterface + Send> {\"), (139, \"impl<'e, EI: ExpanderInterface + Send> Configurator<'e, EI> {\")], 'deleted': [(133, \"pub struct Configurator<'e, EI: ExpanderInterface> {\"), (139, \"impl<'e, EI: ExpanderInterface> Configurator<'e, EI> {\")]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "237"
  },
  {
    "file_change_id": "38950680103375",
    "hash": "0a1da873ddb29bca926bad8301f8d7ab8aa97c52",
    "old_path": "src/expander/immediate.rs",
    "new_path": "src/expander/immediate.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -14,23 +14,12 @@ use registers::valid_port;\n pub struct ImmediateIO<M, EI>(M, PhantomData<EI>)\n where\n     M: IOMutex<Expander<EI>>,\n-    EI: ExpanderInterface;\n-\n-// Unsafety: This is only needed because the presence of PhantomData<EI> causes the struct to no\n-// longer be Sync, because EI is often not Sync since it owns a global resource (e.g. SPI device).\n-// However, the EI is actually owned by the Expander which is in the mutex which normally\n-// re-instates Sync-ness. PhantomData is there to shut up the unused type parameter error.\n-unsafe impl<M, EI> Sync for ImmediateIO<M, EI>\n-where\n-    M: IOMutex<Expander<EI>>,\n-    EI: ExpanderInterface,\n-{\n-}\n+    EI: ExpanderInterface + Send;\n \n impl<M, EI> ImmediateIO<M, EI>\n where\n     M: IOMutex<Expander<EI>>,\n-    EI: ExpanderInterface,\n+    EI: ExpanderInterface + Send,\n {\n     pub(crate) fn new(expander: Expander<EI>) -> Self {\n         ImmediateIO(M::new(expander), PhantomData)\n@@ -54,7 +43,7 @@ where\n impl<M, EI> ExpanderIO for ImmediateIO<M, EI>\n where\n     M: IOMutex<Expander<EI>>,\n-    EI: ExpanderInterface,\n+    EI: ExpanderInterface + Send,\n {\n     fn write_port(&self, port: u8, bit: bool) {\n         self.0.lock(|ex| ex.write_port(port, bit).unwrap())\n",
    "diff_parsed": "{'added': [(17, '    EI: ExpanderInterface + Send;'), (22, '    EI: ExpanderInterface + Send,'), (46, '    EI: ExpanderInterface + Send,')], 'deleted': [(17, '    EI: ExpanderInterface;'), (23, 'unsafe impl<M, EI> Sync for ImmediateIO<M, EI>'), (24, 'where'), (25, '    M: IOMutex<Expander<EI>>,'), (26, '    EI: ExpanderInterface,'), (27, '{'), (28, '}'), (33, '    EI: ExpanderInterface,'), (57, '    EI: ExpanderInterface,')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "9",
    "nloc": "73"
  },
  {
    "file_change_id": "42637396462256",
    "hash": "0a1da873ddb29bca926bad8301f8d7ab8aa97c52",
    "old_path": "src/expander/mod.rs",
    "new_path": "src/expander/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -18,7 +18,7 @@ pub struct Expander<EI: ExpanderInterface> {\n     pub(crate) config: ExpanderConfig,\n }\n \n-impl<EI: ExpanderInterface> Expander<EI> {\n+impl<EI: ExpanderInterface + Send> Expander<EI> {\n     /// Create a new `Expander`.\n     ///\n     /// Takes ownership of the `ExpanderInterface` which it should use to communicate with the\n",
    "diff_parsed": "{'added': [(21, 'impl<EI: ExpanderInterface + Send> Expander<EI> {')], 'deleted': [(21, 'impl<EI: ExpanderInterface> Expander<EI> {')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "239"
  },
  {
    "file_change_id": "9324400335910",
    "hash": "0a1da873ddb29bca926bad8301f8d7ab8aa97c52",
    "old_path": "src/expander/transactional.rs",
    "new_path": "src/expander/transactional.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -48,7 +48,7 @@ pub enum Strategy {\n pub struct TransactionalIO<M, EI>\n where\n     M: IOMutex<Expander<EI>>,\n-    EI: ExpanderInterface,\n+    EI: ExpanderInterface + Send,\n {\n     expander: M,\n     issued: AtomicUsize,\n@@ -58,21 +58,10 @@ where\n     _ei: PhantomData<EI>,\n }\n \n-// NOTE(unsafe): This is only needed because the presence of PhantomData<EI> causes the struct to\n-// no longer be Sync, because EI is often not Sync since it owns a global resource (e.g. SPI\n-// device).  However, the EI is actually owned by the Expander which is in the mutex which normally\n-// re-instates Sync-ness. PhantomData is there to shut up the unused type parameter error.\n-unsafe impl<M, EI> Sync for TransactionalIO<M, EI>\n-where\n-    M: IOMutex<Expander<EI>>,\n-    EI: ExpanderInterface,\n-{\n-}\n-\n impl<M, EI> TransactionalIO<M, EI>\n where\n     M: IOMutex<Expander<EI>>,\n-    EI: ExpanderInterface,\n+    EI: ExpanderInterface + Send,\n {\n     pub(crate) fn new(expander: Expander<EI>) -> Self {\n         TransactionalIO {\n@@ -160,7 +149,7 @@ where\n impl<M, EI> ExpanderIO for TransactionalIO<M, EI>\n where\n     M: IOMutex<Expander<EI>>,\n-    EI: ExpanderInterface,\n+    EI: ExpanderInterface + Send,\n {\n     fn write_port(&self, port: u8, bit: bool) {\n         let or_bit = 1 << port;\n",
    "diff_parsed": "{'added': [(51, '    EI: ExpanderInterface + Send,'), (64, '    EI: ExpanderInterface + Send,'), (152, '    EI: ExpanderInterface + Send,')], 'deleted': [(51, '    EI: ExpanderInterface,'), (65, 'unsafe impl<M, EI> Sync for TransactionalIO<M, EI>'), (66, 'where'), (67, '    M: IOMutex<Expander<EI>>,'), (68, '    EI: ExpanderInterface,'), (69, '{'), (70, '}'), (75, '    EI: ExpanderInterface,'), (163, '    EI: ExpanderInterface,')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "9",
    "nloc": "375"
  },
  {
    "file_change_id": "11259298012896",
    "hash": "0a1da873ddb29bca926bad8301f8d7ab8aa97c52",
    "old_path": "src/interface.rs",
    "new_path": "src/interface.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -121,9 +121,8 @@ pub(crate) mod test_spy {\n \n     use super::ExpanderInterface;\n     use registers::RegisterAddress;\n-    use std::cell::RefCell;\n     use std::fmt;\n-    use std::rc::Rc;\n+    use std::sync::{Arc, Mutex};\n \n     #[derive(Clone, Copy, Debug, PartialEq)]\n     pub enum TestRegister {\n@@ -134,15 +133,15 @@ pub(crate) mod test_spy {\n     }\n \n     pub struct TestSpyInterface {\n-        registers: Rc<RefCell<Vec<TestRegister>>>,\n-        reads: Rc<RefCell<Vec<u8>>>,\n+        registers: Arc<Mutex<Vec<TestRegister>>>,\n+        reads: Arc<Mutex<Vec<u8>>>,\n     }\n \n     impl TestSpyInterface {\n         pub fn new() -> Self {\n             let mut new = Self {\n-                registers: Rc::new(RefCell::new(Vec::new())),\n-                reads: Rc::new(RefCell::new(Vec::new())),\n+                registers: Arc::new(Mutex::new(Vec::new())),\n+                reads: Arc::new(Mutex::new(Vec::new())),\n             };\n             new.reset();\n             new\n@@ -151,8 +150,8 @@ pub(crate) mod test_spy {\n         pub fn reset(&mut self) {\n             use self::TestRegister::*;\n \n-            self.reads.borrow_mut().clear();\n-            let mut regs = self.registers.borrow_mut();\n+            self.reads.lock().unwrap().clear();\n+            let mut regs = self.registers.lock().unwrap();\n             regs.clear();\n             regs.resize(0x60, Forbidden);\n \n@@ -179,21 +178,21 @@ pub(crate) mod test_spy {\n         }\n \n         pub fn get(&self, addr: u8) -> TestRegister {\n-            self.registers.borrow()[addr as usize]\n+            self.registers.lock().unwrap()[addr as usize]\n         }\n \n         pub fn set(&mut self, addr: u8, val: TestRegister) {\n-            self.registers.borrow_mut()[addr as usize] = val;\n+            self.registers.lock().unwrap()[addr as usize] = val;\n         }\n \n         pub fn reads(&self) -> Vec<u8> {\n-            self.reads.borrow().clone()\n+            self.reads.lock().unwrap().clone()\n         }\n     }\n \n     impl ExpanderInterface for TestSpyInterface {\n         fn write_register(&mut self, addr: RegisterAddress, value: u8) -> Result<(), ()> {\n-            let mut regs = self.registers.borrow_mut();\n+            let mut regs = self.registers.lock().unwrap();\n             let enc_addr = u8::from(addr);\n             assert!(enc_addr <= 0x5F);\n             match regs[enc_addr as usize] {\n@@ -204,8 +203,8 @@ pub(crate) mod test_spy {\n             Ok(())\n         }\n         fn read_register(&mut self, addr: RegisterAddress) -> Result<u8, ()> {\n-            self.reads.borrow_mut().push(addr.into());\n-            let regs = self.registers.borrow();\n+            self.reads.lock().unwrap().push(addr.into());\n+            let regs = self.registers.lock().unwrap();\n             let enc_addr = u8::from(addr);\n             assert!(enc_addr <= 0x5F);\n             match regs[enc_addr as usize] {\n@@ -240,14 +239,14 @@ pub(crate) mod test_spy {\n     }\n \n     pub struct SemanticTestSpyInterface {\n-        ports: Rc<RefCell<Vec<TestPort>>>,\n+        ports: Arc<Mutex<Vec<TestPort>>>,\n     }\n \n     impl SemanticTestSpyInterface {\n         pub fn new(init: Vec<bool>) -> Self {\n             assert!(init.len() == 32 - 4);\n             Self {\n-                ports: Rc::new(RefCell::new(\n+                ports: Arc::new(Mutex::new(\n                     init.into_iter()\n                         .map(|b| TestPort::Reset(b))\n                         .collect::<Vec<_>>(),\n@@ -264,7 +263,8 @@ pub(crate) mod test_spy {\n         pub fn peek_all(&self) -> Vec<TestPort> {\n             use self::TestPort::*;\n             self.ports\n-                .borrow()\n+                .lock()\n+                .unwrap()\n                 .iter()\n                 .cloned()\n                 .map(|v| match v {\n@@ -277,7 +277,8 @@ pub(crate) mod test_spy {\n         pub fn peek_bits(&self) -> Vec<bool> {\n             use self::TestPort::*;\n             self.ports\n-                .borrow()\n+                .lock()\n+                .unwrap()\n                 .iter()\n                 .cloned()\n                 .map(|v| match v {\n@@ -289,7 +290,7 @@ pub(crate) mod test_spy {\n         fn write_port(&self, port: u8, bit: bool) {\n             use self::TestPort::*;\n             let idx = port as usize - 4;\n-            let slot_ref = &mut self.ports.borrow_mut()[idx];\n+            let slot_ref = &mut self.ports.lock().unwrap()[idx];\n             *slot_ref = match slot_ref {\n                 Reset(_) | BlindWrite(_) => BlindWrite(bit),\n                 Read(_) | ReadWrite(_) => ReadWrite(bit),\n@@ -299,7 +300,7 @@ pub(crate) mod test_spy {\n         fn read_port(&self, port: u8) -> bool {\n             use self::TestPort::*;\n             let idx = port as usize - 4;\n-            let slot_ref = &mut self.ports.borrow_mut()[idx];\n+            let slot_ref = &mut self.ports.lock().unwrap()[idx];\n             let (upd, ret) = match slot_ref {\n                 Reset(b) | Read(b) => (Read(*b), *b),\n                 ReadWrite(b) => (ReadWrite(*b), *b),\n@@ -316,7 +317,8 @@ pub(crate) mod test_spy {\n                 f,\n                 \"[ {} ]\",\n                 self.ports\n-                    .borrow()\n+                    .lock()\n+                    .unwrap()\n                     .iter()\n                     .map(|&v| format!(\"{:?}\", v))\n                     .collect::<Vec<_>>()\n",
    "diff_parsed": "{'added': [(125, '    use std::sync::{Arc, Mutex};'), (136, '        registers: Arc<Mutex<Vec<TestRegister>>>,'), (137, '        reads: Arc<Mutex<Vec<u8>>>,'), (143, '                registers: Arc::new(Mutex::new(Vec::new())),'), (144, '                reads: Arc::new(Mutex::new(Vec::new())),'), (153, '            self.reads.lock().unwrap().clear();'), (154, '            let mut regs = self.registers.lock().unwrap();'), (181, '            self.registers.lock().unwrap()[addr as usize]'), (185, '            self.registers.lock().unwrap()[addr as usize] = val;'), (189, '            self.reads.lock().unwrap().clone()'), (195, '            let mut regs = self.registers.lock().unwrap();'), (206, '            self.reads.lock().unwrap().push(addr.into());'), (207, '            let regs = self.registers.lock().unwrap();'), (242, '        ports: Arc<Mutex<Vec<TestPort>>>,'), (249, '                ports: Arc::new(Mutex::new('), (266, '                .lock()'), (267, '                .unwrap()'), (280, '                .lock()'), (281, '                .unwrap()'), (293, '            let slot_ref = &mut self.ports.lock().unwrap()[idx];'), (303, '            let slot_ref = &mut self.ports.lock().unwrap()[idx];'), (320, '                    .lock()'), (321, '                    .unwrap()')], 'deleted': [(124, '    use std::cell::RefCell;'), (126, '    use std::rc::Rc;'), (137, '        registers: Rc<RefCell<Vec<TestRegister>>>,'), (138, '        reads: Rc<RefCell<Vec<u8>>>,'), (144, '                registers: Rc::new(RefCell::new(Vec::new())),'), (145, '                reads: Rc::new(RefCell::new(Vec::new())),'), (154, '            self.reads.borrow_mut().clear();'), (155, '            let mut regs = self.registers.borrow_mut();'), (182, '            self.registers.borrow()[addr as usize]'), (186, '            self.registers.borrow_mut()[addr as usize] = val;'), (190, '            self.reads.borrow().clone()'), (196, '            let mut regs = self.registers.borrow_mut();'), (207, '            self.reads.borrow_mut().push(addr.into());'), (208, '            let regs = self.registers.borrow();'), (243, '        ports: Rc<RefCell<Vec<TestPort>>>,'), (250, '                ports: Rc::new(RefCell::new('), (267, '                .borrow()'), (280, '                .borrow()'), (292, '            let slot_ref = &mut self.ports.borrow_mut()[idx];'), (302, '            let slot_ref = &mut self.ports.borrow_mut()[idx];'), (319, '                    .borrow()')]}",
    "num_lines_added": "23",
    "num_lines_deleted": "21",
    "nloc": "312"
  },
  {
    "file_change_id": "45075621085870",
    "hash": "2820cf12f2e08645fd6d1f15b4a90a54d6082a81",
    "old_path": "src/keyed.rs",
    "new_path": "src/keyed.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -14,7 +14,7 @@ use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::marker::PhantomData;\n use std::mem::size_of;\n \n-use misc::{Flatten, LinearBuckets, SerializationFormat, vec_resize, vec_with_size};\n+use misc::{Flatten, LinearBuckets, SerializationFormat, vec_with_size};\n use task::{BackEnd, Op, KeyedRawStorage};\n use service::{Service, PrivateAccess};\n use indexing::*;\n@@ -448,12 +448,12 @@ impl KeyedRawStorage for KeyedEnumStorage {\n         match self.values.entry(key) {\n             Occupied(mut e) => {\n                 let mut vec = e.get_mut();\n-                vec_resize(&mut vec, value as usize + 1, 0);\n+                vec.resize(value as usize + 1, 0);\n                 vec[value as usize] += 1;\n             }\n             Vacant(e) => {\n                 let mut vec = Vec::new();\n-                vec_resize(&mut vec, value as usize + 1, 0);\n+                vec.resize(value as usize + 1, 0);\n                 vec[value as usize] = 1;\n                 e.insert(vec);\n             }\n",
    "diff_parsed": "{'added': [(17, 'use misc::{Flatten, LinearBuckets, SerializationFormat, vec_with_size};'), (451, '                vec.resize(value as usize + 1, 0);'), (456, '                vec.resize(value as usize + 1, 0);')], 'deleted': [(17, 'use misc::{Flatten, LinearBuckets, SerializationFormat, vec_resize, vec_with_size};'), (451, '                vec_resize(&mut vec, value as usize + 1, 0);'), (456, '                vec_resize(&mut vec, value as usize + 1, 0);')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "3",
    "nloc": "284"
  },
  {
    "file_change_id": "56786115403185",
    "hash": "2820cf12f2e08645fd6d1f15b4a90a54d6082a81",
    "old_path": "src/misc.rs",
    "new_path": "src/misc.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -108,44 +108,10 @@ impl LinearBuckets {\n     }\n }\n \n-/// Partial reimplementation of `Vec::resize`, until this method has\n-/// reached the stable version of Rust.\n-pub fn vec_resize<T>(vec: &mut Vec<T>, min_len: usize, value: T)\n-    where T: Clone\n-{\n-    let len = vec.len();\n-    if min_len <= len {\n-        return;\n-    }\n-    let delta = min_len - len;\n-    vec.reserve(delta);\n-    unsafe {\n-        let mut ptr = vec.as_mut_ptr().offset(len as isize);\n-        // Write all elements except the last one\n-        for i in 1..delta {\n-            ptr::write(ptr, value.clone());\n-            ptr = ptr.offset(1);\n-            // Increment the length in every step in case clone() panics\n-            vec.set_len(len + i);\n-        }\n-\n-        // We can write the last element directly without cloning needlessly\n-        ptr::write(ptr, value);\n-        vec.set_len(len + delta);\n-    }\n-}\n-\n pub fn vec_with_size<T>(size: usize, value: T) -> Vec<T>\n     where T: Clone\n {\n     let mut vec = Vec::with_capacity(size);\n-    unsafe {\n-        // Resize. In future versions of Rust, we should\n-        // be able to use `vec.resize`.\n-        vec.set_len(size);\n-        for i in 0 .. size {\n-            vec[i] = value.clone();\n-        }\n-    }\n+    vec.resize(size, value);\n     vec\n }\n",
    "diff_parsed": "{'added': [(115, '    vec.resize(size, value);')], 'deleted': [(113, 'pub fn vec_resize<T>(vec: &mut Vec<T>, min_len: usize, value: T)'), (114, '    where T: Clone'), (115, '{'), (116, '    let len = vec.len();'), (117, '    if min_len <= len {'), (118, '        return;'), (119, '    }'), (120, '    let delta = min_len - len;'), (121, '    vec.reserve(delta);'), (122, '    unsafe {'), (123, '        let mut ptr = vec.as_mut_ptr().offset(len as isize);'), (125, '        for i in 1..delta {'), (126, '            ptr::write(ptr, value.clone());'), (127, '            ptr = ptr.offset(1);'), (129, '            vec.set_len(len + i);'), (130, '        }'), (133, '        ptr::write(ptr, value);'), (134, '        vec.set_len(len + delta);'), (135, '    }'), (136, '}'), (142, '    unsafe {'), (145, '        vec.set_len(size);'), (146, '        for i in 0 .. size {'), (147, '            vec[i] = value.clone();'), (148, '        }'), (149, '    }')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "26",
    "nloc": "70"
  },
  {
    "file_change_id": "126579451132673",
    "hash": "2820cf12f2e08645fd6d1f15b4a90a54d6082a81",
    "old_path": "src/plain.rs",
    "new_path": "src/plain.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -13,7 +13,7 @@ use std::marker::PhantomData;\n use std::mem::size_of;\n use std::sync::atomic::{AtomicBool, Ordering};\n \n-use misc::{Flatten, LinearBuckets, SerializationFormat, vec_resize, vec_with_size};\n+use misc::{Flatten, LinearBuckets, SerializationFormat, vec_with_size};\n use task::{BackEnd, Op, PlainRawStorage};\n use service::{Service, PrivateAccess};\n use indexing::*;\n@@ -409,7 +409,7 @@ struct EnumStorage {\n \n impl PlainRawStorage for EnumStorage {\n     fn store(&mut self, value: u32) {\n-        vec_resize(&mut self.values, value as usize + 1, 0);\n+        self.values.resize(value as usize + 1, 0);\n         self.values[value as usize] += 1;\n     }\n     fn to_json(&self, format: &SerializationFormat) -> Json {\n",
    "diff_parsed": "{'added': [(16, 'use misc::{Flatten, LinearBuckets, SerializationFormat, vec_with_size};'), (412, '        self.values.resize(value as usize + 1, 0);')], 'deleted': [(16, 'use misc::{Flatten, LinearBuckets, SerializationFormat, vec_resize, vec_with_size};'), (412, '        vec_resize(&mut self.values, value as usize + 1, 0);')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "230"
  },
  {
    "file_change_id": "137078402882089",
    "hash": "71b2f5187b0cbace3f8b6ff53432ff2ca0defcf0",
    "old_path": "src/functions.rs",
    "new_path": "src/functions.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -67,6 +67,7 @@\n //!     Ok(())\n //! }\n //! ```\n+use std::any::TypeId;\n use std::os::raw::{c_int, c_void};\n use std::panic::{catch_unwind, RefUnwindSafe, UnwindSafe};\n use std::ptr;\n@@ -177,13 +178,16 @@ impl Context<'_> {\n     /// https://www.sqlite.org/c3ref/get_auxdata.html for a discussion of\n     /// this feature, or the unit tests of this module for an example.\n     pub fn set_aux<T: 'static>(&self, arg: c_int, value: T) {\n-        let boxed = Box::into_raw(Box::new((std::any::TypeId::of::<T>(), value)));\n+        let boxed = Box::into_raw(Box::new(AuxData {\n+            id: TypeId::of::<T>(),\n+            value,\n+        }));\n         unsafe {\n             ffi::sqlite3_set_auxdata(\n                 self.ctx,\n                 arg,\n                 boxed as *mut c_void,\n-                Some(free_boxed_value::<(std::any::TypeId, T)>),\n+                Some(free_boxed_value::<AuxData<T>>),\n             )\n         };\n     }\n@@ -192,20 +196,26 @@ impl Context<'_> {\n     /// via `set_aux`. Returns `Ok(None)` if no data has been associated,\n     /// and .\n     pub fn get_aux<T: 'static>(&self, arg: c_int) -> Result<Option<&T>> {\n-        let p = unsafe { ffi::sqlite3_get_auxdata(self.ctx, arg) as *mut (std::any::TypeId, T) };\n+        let p = unsafe { ffi::sqlite3_get_auxdata(self.ctx, arg) as *const AuxData<T> };\n         if p.is_null() {\n             Ok(None)\n         } else {\n-            let id_val = unsafe { &*p };\n-            if std::any::TypeId::of::<T>() != id_val.0 {\n+            let id = unsafe { (*p).id };\n+            if TypeId::of::<T>() != id {\n                 Err(Error::GetAuxWrongType)\n             } else {\n-                Ok(Some(&id_val.1))\n+                Ok(Some(unsafe { &(*p).value }))\n             }\n         }\n     }\n }\n \n+#[repr(C)]\n+struct AuxData<T: 'static> {\n+    id: TypeId,\n+    value: T,\n+}\n+\n /// `feature = \"functions\"` Aggregate is the callback interface for user-defined\n /// aggregate function.\n ///\n",
    "diff_parsed": "{'added': [(70, 'use std::any::TypeId;'), (181, '        let boxed = Box::into_raw(Box::new(AuxData {'), (182, '            id: TypeId::of::<T>(),'), (183, '            value,'), (184, '        }));'), (190, '                Some(free_boxed_value::<AuxData<T>>),'), (199, '        let p = unsafe { ffi::sqlite3_get_auxdata(self.ctx, arg) as *const AuxData<T> };'), (203, '            let id = unsafe { (*p).id };'), (204, '            if TypeId::of::<T>() != id {'), (207, '                Ok(Some(unsafe { &(*p).value }))'), (213, '#[repr(C)]'), (214, \"struct AuxData<T: 'static> {\"), (215, '    id: TypeId,'), (216, '    value: T,'), (217, '}')], 'deleted': [(180, '        let boxed = Box::into_raw(Box::new((std::any::TypeId::of::<T>(), value)));'), (186, '                Some(free_boxed_value::<(std::any::TypeId, T)>),'), (195, '        let p = unsafe { ffi::sqlite3_get_auxdata(self.ctx, arg) as *mut (std::any::TypeId, T) };'), (199, '            let id_val = unsafe { &*p };'), (200, '            if std::any::TypeId::of::<T>() != id_val.0 {'), (203, '                Ok(Some(&id_val.1))')]}",
    "num_lines_added": "15",
    "num_lines_deleted": "6",
    "nloc": "904"
  },
  {
    "file_change_id": "65939416013616",
    "hash": "d2ce1ac753afc059e32798bac3383b81a6d04456",
    "old_path": "cranelift/wasm/src/environ/dummy.rs",
    "new_path": "cranelift/wasm/src/environ/dummy.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -688,8 +688,8 @@ impl<'data> ModuleEnvironment<'data> for DummyEnvironment {\n                 WasmType::FuncRef | WasmType::ExternRef | WasmType::ExnRef => reference_type,\n             })\n         };\n-        sig.params.extend(wasm.params.iter().map(&mut cvt));\n-        sig.returns.extend(wasm.returns.iter().map(&mut cvt));\n+        sig.params.extend(wasm.params().iter().map(&mut cvt));\n+        sig.returns.extend(wasm.returns().iter().map(&mut cvt));\n         self.info.signatures.push(sig);\n         Ok(())\n     }\n",
    "diff_parsed": "{'added': [(691, '        sig.params.extend(wasm.params().iter().map(&mut cvt));'), (692, '        sig.returns.extend(wasm.returns().iter().map(&mut cvt));')], 'deleted': [(691, '        sig.params.extend(wasm.params.iter().map(&mut cvt));'), (692, '        sig.returns.extend(wasm.returns.iter().map(&mut cvt));')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "762"
  },
  {
    "file_change_id": "154325189412632",
    "hash": "d2ce1ac753afc059e32798bac3383b81a6d04456",
    "old_path": "crates/cranelift/src/compiler.rs",
    "new_path": "crates/cranelift/src/compiler.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -465,7 +465,7 @@ impl Compiler {\n \n         // Compute the size of the values vector. The vmctx and caller vmctx are passed separately.\n         let value_size = mem::size_of::<u128>();\n-        let values_vec_len = (value_size * cmp::max(ty.params.len(), ty.returns.len())) as u32;\n+        let values_vec_len = (value_size * cmp::max(ty.params().len(), ty.returns().len())) as u32;\n \n         let mut context = Context::new();\n         context.func =\n@@ -486,7 +486,7 @@ impl Compiler {\n \n         let values_vec_ptr_val = builder.ins().stack_addr(pointer_type, ss, 0);\n         let mflags = MemFlags::trusted();\n-        for i in 0..ty.params.len() {\n+        for i in 0..ty.params().len() {\n             let val = builder.func.dfg.block_params(block0)[i + 2];\n             builder\n                 .ins()\n@@ -508,7 +508,7 @@ impl Compiler {\n \n         let mflags = MemFlags::trusted();\n         let mut results = Vec::new();\n-        for (i, r) in ty.returns.iter().enumerate() {\n+        for (i, r) in ty.returns().iter().enumerate() {\n             let load = builder.ins().load(\n                 value_type(isa, *r),\n                 mflags,\n",
    "diff_parsed": "{'added': [(468, '        let values_vec_len = (value_size * cmp::max(ty.params().len(), ty.returns().len())) as u32;'), (489, '        for i in 0..ty.params().len() {'), (511, '        for (i, r) in ty.returns().iter().enumerate() {')], 'deleted': [(468, '        let values_vec_len = (value_size * cmp::max(ty.params.len(), ty.returns.len())) as u32;'), (489, '        for i in 0..ty.params.len() {'), (511, '        for (i, r) in ty.returns.iter().enumerate() {')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "3",
    "nloc": "715"
  },
  {
    "file_change_id": "178377189883823",
    "hash": "d2ce1ac753afc059e32798bac3383b81a6d04456",
    "old_path": "crates/cranelift/src/lib.rs",
    "new_path": "crates/cranelift/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -220,8 +220,8 @@ fn wasmtime_call_conv(isa: &dyn TargetIsa) -> CallConv {\n /// above.\n fn push_types(isa: &dyn TargetIsa, sig: &mut ir::Signature, wasm: &WasmFuncType) {\n     let cvt = |ty: &WasmType| ir::AbiParam::new(value_type(isa, *ty));\n-    sig.params.extend(wasm.params.iter().map(&cvt));\n-    sig.returns.extend(wasm.returns.iter().map(&cvt));\n+    sig.params.extend(wasm.params().iter().map(&cvt));\n+    sig.returns.extend(wasm.returns().iter().map(&cvt));\n }\n \n /// Returns the corresponding cranelift type for the provided wasm type.\n",
    "diff_parsed": "{'added': [(223, '    sig.params.extend(wasm.params().iter().map(&cvt));'), (224, '    sig.returns.extend(wasm.returns().iter().map(&cvt));')], 'deleted': [(223, '    sig.params.extend(wasm.params.iter().map(&cvt));'), (224, '    sig.returns.extend(wasm.returns.iter().map(&cvt));')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "117"
  },
  {
    "file_change_id": "62374920818443",
    "hash": "d2ce1ac753afc059e32798bac3383b81a6d04456",
    "old_path": "crates/environ/src/module_environ.rs",
    "new_path": "crates/environ/src/module_environ.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -608,7 +608,7 @@ impl<'data> ModuleEnvironment<'data> {\n                         .funcs\n                         .push(FunctionMetadata {\n                             locals: locals.into_boxed_slice(),\n-                            params: sig.params.iter().cloned().map(|i| i.into()).collect(),\n+                            params: sig.params().iter().cloned().map(|i| i.into()).collect(),\n                         });\n                 }\n                 body.allow_memarg64(self.features.memory64);\n",
    "diff_parsed": "{'added': [(611, '                            params: sig.params().iter().cloned().map(|i| i.into()).collect(),')], 'deleted': [(611, '                            params: sig.params.iter().cloned().map(|i| i.into()).collect(),')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "1059"
  },
  {
    "file_change_id": "183367878595415",
    "hash": "d2ce1ac753afc059e32798bac3383b81a6d04456",
    "old_path": "crates/fuzzing/src/generators/table_ops.rs",
    "new_path": "crates/fuzzing/src/generators/table_ops.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -18,7 +18,7 @@ pub struct TableOps {\n \n const NUM_PARAMS_RANGE: Range<u8> = 1..10;\n const TABLE_SIZE_RANGE: Range<u32> = 1..100;\n-const MAX_OPS: usize = 1000;\n+const MAX_OPS: usize = 100;\n \n impl TableOps {\n     /// Get the number of parameters this module's \"run\" function takes.\n@@ -49,9 +49,46 @@ impl TableOps {\n     pub fn to_wasm_binary(&self) -> Vec<u8> {\n         let mut module = Module::new();\n \n+        // Encode the types for all functions that we are using.\n+        let mut types = TypeSection::new();\n+\n+        // 0: \"gc\"\n+        types.function(\n+            vec![],\n+            // Return a bunch of stuff from `gc` so that we exercise GCing when\n+            // there is return pointer space allocated on the stack. This is\n+            // especially important because the x64 backend currently\n+            // dynamically adjusts the stack pointer for each call that uses\n+            // return pointers rather than statically allocating space in the\n+            // stack frame.\n+            vec![ValType::ExternRef, ValType::ExternRef, ValType::ExternRef],\n+        );\n+\n+        // 1: \"run\"\n+        let mut params: Vec<ValType> = Vec::with_capacity(self.num_params() as usize);\n+        for _i in 0..self.num_params() {\n+            params.push(ValType::ExternRef);\n+        }\n+        let results = vec![];\n+        types.function(params, results);\n+\n+        // 2: `take_refs`\n+        types.function(\n+            vec![ValType::ExternRef, ValType::ExternRef, ValType::ExternRef],\n+            vec![],\n+        );\n+\n+        // 3: `make_refs`\n+        types.function(\n+            vec![],\n+            vec![ValType::ExternRef, ValType::ExternRef, ValType::ExternRef],\n+        );\n+\n         // Import the GC function.\n         let mut imports = ImportSection::new();\n         imports.import(\"\", Some(\"gc\"), EntityType::Function(0));\n+        imports.import(\"\", Some(\"take_refs\"), EntityType::Function(2));\n+        imports.import(\"\", Some(\"make_refs\"), EntityType::Function(3));\n \n         // Define our table.\n         let mut tables = TableSection::new();\n@@ -61,32 +98,24 @@ impl TableOps {\n             maximum: None,\n         });\n \n-        // Encode the types for all functions that we are using.\n-        let mut types = TypeSection::new();\n-        types.function(vec![], vec![]); // 0: \"gc\"\n-        let mut params: Vec<ValType> = Vec::with_capacity(self.num_params() as usize);\n-        for _i in 0..self.num_params() {\n-            params.push(ValType::ExternRef);\n-        }\n-        let results = vec![];\n-        types.function(params, results); // 1: \"run\"\n-\n         // Define the \"run\" function export.\n         let mut functions = FunctionSection::new();\n         functions.function(1);\n \n         let mut exports = ExportSection::new();\n-        exports.export(\"run\", Export::Function(1));\n+        exports.export(\"run\", Export::Function(3));\n \n-        let mut params: Vec<(u32, ValType)> = Vec::with_capacity(self.num_params() as usize);\n-        for _i in 0..self.num_params() {\n-            params.push((0, ValType::ExternRef));\n-        }\n-        let mut func = Function::new(params);\n+        // Give ourselves one scratch local that we can use in various `TableOp`\n+        // implementations.\n+        let mut func = Function::new(vec![(1, ValType::ExternRef)]);\n \n+        func.instruction(Instruction::Loop(wasm_encoder::BlockType::Empty));\n         for op in self.ops.iter().take(MAX_OPS) {\n-            op.insert(&mut func);\n+            op.insert(&mut func, self.num_params() as u32, self.table_size());\n         }\n+        func.instruction(Instruction::Br(0));\n+        func.instruction(Instruction::End);\n+        func.instruction(Instruction::End);\n \n         let mut code = CodeSection::new();\n         code.function(&func);\n@@ -105,7 +134,7 @@ impl TableOps {\n \n #[derive(Arbitrary, Debug)]\n pub(crate) enum TableOp {\n-    // `(call 0)`\n+    // `call $gc; drop; drop; drop;`\n     Gc,\n     // `(drop (table.get x))`\n     Get(i32),\n@@ -113,30 +142,102 @@ pub(crate) enum TableOp {\n     SetFromParam(i32, u32),\n     // `(table.set x (table.get y))`\n     SetFromGet(i32, i32),\n+    // `call $make_refs; table.set x; table.set y; table.set z`\n+    SetFromMake(i32, i32, i32),\n+    // `call $make_refs; drop; drop; drop;`\n+    Make,\n+    // `local.get x; local.get y; local.get z; call $take_refs`\n+    TakeFromParams(u32, u32, u32),\n+    // `table.get x; table.get y; table.get z; call $take_refs`\n+    TakeFromGet(i32, i32, i32),\n+    // `call $make_refs; call $take_refs`\n+    TakeFromMake,\n+    // `call $gc; call $take_refs`\n+    TakeFromGc,\n }\n \n impl TableOp {\n-    fn insert(&self, func: &mut Function) {\n+    fn insert(&self, func: &mut Function, num_params: u32, table_size: u32) {\n+        assert!(num_params > 0);\n+        assert!(table_size > 0);\n+\n+        // Add one to make sure that out of bounds table accesses are possible,\n+        // but still rare.\n+        let table_mod = table_size as i32 + 1;\n+\n         match self {\n             Self::Gc => {\n                 func.instruction(Instruction::Call(0));\n+                func.instruction(Instruction::Drop);\n+                func.instruction(Instruction::Drop);\n+                func.instruction(Instruction::Drop);\n             }\n             Self::Get(x) => {\n-                func.instruction(Instruction::I32Const(*x));\n+                func.instruction(Instruction::I32Const(*x % table_mod));\n                 func.instruction(Instruction::TableGet { table: 0 });\n                 func.instruction(Instruction::Drop);\n             }\n             Self::SetFromParam(x, y) => {\n-                func.instruction(Instruction::I32Const(*x));\n-                func.instruction(Instruction::LocalGet(*y));\n+                func.instruction(Instruction::I32Const(*x % table_mod));\n+                func.instruction(Instruction::LocalGet(*y % num_params));\n                 func.instruction(Instruction::TableSet { table: 0 });\n             }\n             Self::SetFromGet(x, y) => {\n-                func.instruction(Instruction::I32Const(*x));\n-                func.instruction(Instruction::I32Const(*y));\n+                func.instruction(Instruction::I32Const(*x % table_mod));\n+                func.instruction(Instruction::I32Const(*y % table_mod));\n                 func.instruction(Instruction::TableGet { table: 0 });\n                 func.instruction(Instruction::TableSet { table: 0 });\n             }\n+            Self::SetFromMake(x, y, z) => {\n+                func.instruction(Instruction::Call(2));\n+\n+                func.instruction(Instruction::LocalSet(num_params));\n+                func.instruction(Instruction::I32Const(*x % table_mod));\n+                func.instruction(Instruction::LocalGet(num_params));\n+                func.instruction(Instruction::TableSet { table: 0 });\n+\n+                func.instruction(Instruction::LocalSet(num_params));\n+                func.instruction(Instruction::I32Const(*y % table_mod));\n+                func.instruction(Instruction::LocalGet(num_params));\n+                func.instruction(Instruction::TableSet { table: 0 });\n+\n+                func.instruction(Instruction::LocalSet(num_params));\n+                func.instruction(Instruction::I32Const(*z % table_mod));\n+                func.instruction(Instruction::LocalGet(num_params));\n+                func.instruction(Instruction::TableSet { table: 0 });\n+            }\n+            TableOp::Make => {\n+                func.instruction(Instruction::Call(2));\n+                func.instruction(Instruction::Drop);\n+                func.instruction(Instruction::Drop);\n+                func.instruction(Instruction::Drop);\n+            }\n+            TableOp::TakeFromParams(x, y, z) => {\n+                func.instruction(Instruction::LocalGet(x % num_params));\n+                func.instruction(Instruction::LocalGet(y % num_params));\n+                func.instruction(Instruction::LocalGet(z % num_params));\n+                func.instruction(Instruction::Call(1));\n+            }\n+            TableOp::TakeFromGet(x, y, z) => {\n+                func.instruction(Instruction::I32Const(*x % table_mod));\n+                func.instruction(Instruction::TableGet { table: 0 });\n+\n+                func.instruction(Instruction::I32Const(*y % table_mod));\n+                func.instruction(Instruction::TableGet { table: 0 });\n+\n+                func.instruction(Instruction::I32Const(*z % table_mod));\n+                func.instruction(Instruction::TableGet { table: 0 });\n+\n+                func.instruction(Instruction::Call(1));\n+            }\n+            TableOp::TakeFromMake => {\n+                func.instruction(Instruction::Call(2));\n+                func.instruction(Instruction::Call(1));\n+            }\n+            Self::TakeFromGc => {\n+                func.instruction(Instruction::Call(0));\n+                func.instruction(Instruction::Call(1));\n+            }\n         }\n     }\n }\n@@ -148,38 +249,95 @@ mod tests {\n     #[test]\n     fn test_wat_string() {\n         let ops = TableOps {\n-            num_params: 2,\n-            table_size: 10,\n+            num_params: 5,\n+            table_size: 20,\n             ops: vec![\n                 TableOp::Gc,\n                 TableOp::Get(0),\n                 TableOp::SetFromParam(1, 2),\n                 TableOp::SetFromGet(3, 4),\n+                TableOp::SetFromMake(5, 6, 7),\n+                TableOp::Make,\n+                TableOp::TakeFromParams(8, 9, 10),\n+                TableOp::TakeFromGet(11, 12, 13),\n+                TableOp::TakeFromMake,\n             ],\n         };\n \n         let expected = r#\"\n (module\n   (type (;0;) (func))\n-  (type (;1;) (func (param externref externref)))\n+  (type (;1;) (func (param externref externref externref externref externref)))\n+  (type (;2;) (func (param externref externref externref)))\n+  (type (;3;) (func (result externref externref externref)))\n   (import \"\" \"gc\" (func (;0;) (type 0)))\n-  (func (;1;) (type 1) (param externref externref)\n-    call 0\n-    i32.const 0\n-    table.get 0\n-    drop\n-    i32.const 1\n-    local.get 2\n-    table.set 0\n-    i32.const 3\n-    i32.const 4\n-    table.get 0\n-    table.set 0)\n-  (table (;0;) 10 externref)\n-  (export \"run\" (func 1)))\n+  (import \"\" \"take_refs\" (func (;1;) (type 2)))\n+  (import \"\" \"make_refs\" (func (;2;) (type 3)))\n+  (func (;3;) (type 1) (param externref externref externref externref externref)\n+    (local externref i32)\n+    i32.const 100\n+    local.set 6\n+    loop  ;; label = @1\n+      call 0\n+      i32.const 0\n+      table.get 0\n+      drop\n+      i32.const 1\n+      local.get 2\n+      table.set 0\n+      i32.const 3\n+      i32.const 4\n+      table.get 0\n+      table.set 0\n+      call 2\n+      local.set 5\n+      i32.const 5\n+      local.get 5\n+      table.set 0\n+      local.set 5\n+      i32.const 6\n+      local.get 5\n+      table.set 0\n+      local.set 5\n+      i32.const 7\n+      local.get 5\n+      table.set 0\n+      call 2\n+      drop\n+      drop\n+      drop\n+      local.get 3\n+      local.get 4\n+      local.get 0\n+      call 1\n+      i32.const 11\n+      table.get 0\n+      i32.const 12\n+      table.get 0\n+      i32.const 13\n+      table.get 0\n+      call 1\n+      call 2\n+      call 1\n+      local.get 6\n+      i32.const -1\n+      i32.add\n+      local.tee 6\n+      br_if 0 (;@1;)\n+    end)\n+  (table (;0;) 20 externref)\n+  (export \"run\" (func 3)))\n \"#;\n+        eprintln!(\"expected WAT = {}\", expected);\n+\n         let actual = ops.to_wasm_binary();\n+        if let Err(e) = wasmparser::validate(&actual) {\n+            panic!(\"TableOps should generate valid Wasm; got error: {}\", e);\n+        }\n+\n         let actual = wasmprinter::print_bytes(&actual).unwrap();\n+        eprintln!(\"actual WAT = {}\", actual);\n+\n         assert_eq!(actual.trim(), expected.trim());\n     }\n }\n",
    "diff_parsed": "{'added': [(21, 'const MAX_OPS: usize = 100;'), (53, '        let mut types = TypeSection::new();'), (56, '        types.function('), (57, '            vec![],'), (64, '            vec![ValType::ExternRef, ValType::ExternRef, ValType::ExternRef],'), (65, '        );'), (68, '        let mut params: Vec<ValType> = Vec::with_capacity(self.num_params() as usize);'), (69, '        for _i in 0..self.num_params() {'), (70, '            params.push(ValType::ExternRef);'), (71, '        }'), (72, '        let results = vec![];'), (73, '        types.function(params, results);'), (76, '        types.function('), (77, '            vec![ValType::ExternRef, ValType::ExternRef, ValType::ExternRef],'), (78, '            vec![],'), (79, '        );'), (82, '        types.function('), (83, '            vec![],'), (84, '            vec![ValType::ExternRef, ValType::ExternRef, ValType::ExternRef],'), (85, '        );'), (90, '        imports.import(\"\", Some(\"take_refs\"), EntityType::Function(2));'), (91, '        imports.import(\"\", Some(\"make_refs\"), EntityType::Function(3));'), (106, '        exports.export(\"run\", Export::Function(3));'), (110, '        let mut func = Function::new(vec![(1, ValType::ExternRef)]);'), (112, '        func.instruction(Instruction::Loop(wasm_encoder::BlockType::Empty));'), (114, '            op.insert(&mut func, self.num_params() as u32, self.table_size());'), (116, '        func.instruction(Instruction::Br(0));'), (117, '        func.instruction(Instruction::End);'), (118, '        func.instruction(Instruction::End);'), (146, '    SetFromMake(i32, i32, i32),'), (148, '    Make,'), (150, '    TakeFromParams(u32, u32, u32),'), (152, '    TakeFromGet(i32, i32, i32),'), (154, '    TakeFromMake,'), (156, '    TakeFromGc,'), (160, '    fn insert(&self, func: &mut Function, num_params: u32, table_size: u32) {'), (161, '        assert!(num_params > 0);'), (162, '        assert!(table_size > 0);'), (166, '        let table_mod = table_size as i32 + 1;'), (171, '                func.instruction(Instruction::Drop);'), (172, '                func.instruction(Instruction::Drop);'), (173, '                func.instruction(Instruction::Drop);'), (176, '                func.instruction(Instruction::I32Const(*x % table_mod));'), (181, '                func.instruction(Instruction::I32Const(*x % table_mod));'), (182, '                func.instruction(Instruction::LocalGet(*y % num_params));'), (186, '                func.instruction(Instruction::I32Const(*x % table_mod));'), (187, '                func.instruction(Instruction::I32Const(*y % table_mod));'), (191, '            Self::SetFromMake(x, y, z) => {'), (192, '                func.instruction(Instruction::Call(2));'), (194, '                func.instruction(Instruction::LocalSet(num_params));'), (195, '                func.instruction(Instruction::I32Const(*x % table_mod));'), (196, '                func.instruction(Instruction::LocalGet(num_params));'), (197, '                func.instruction(Instruction::TableSet { table: 0 });'), (199, '                func.instruction(Instruction::LocalSet(num_params));'), (200, '                func.instruction(Instruction::I32Const(*y % table_mod));'), (201, '                func.instruction(Instruction::LocalGet(num_params));'), (202, '                func.instruction(Instruction::TableSet { table: 0 });'), (204, '                func.instruction(Instruction::LocalSet(num_params));'), (205, '                func.instruction(Instruction::I32Const(*z % table_mod));'), (206, '                func.instruction(Instruction::LocalGet(num_params));'), (207, '                func.instruction(Instruction::TableSet { table: 0 });'), (208, '            }'), (209, '            TableOp::Make => {'), (210, '                func.instruction(Instruction::Call(2));'), (211, '                func.instruction(Instruction::Drop);'), (212, '                func.instruction(Instruction::Drop);'), (213, '                func.instruction(Instruction::Drop);'), (214, '            }'), (215, '            TableOp::TakeFromParams(x, y, z) => {'), (216, '                func.instruction(Instruction::LocalGet(x % num_params));'), (217, '                func.instruction(Instruction::LocalGet(y % num_params));'), (218, '                func.instruction(Instruction::LocalGet(z % num_params));'), (219, '                func.instruction(Instruction::Call(1));'), (220, '            }'), (221, '            TableOp::TakeFromGet(x, y, z) => {'), (222, '                func.instruction(Instruction::I32Const(*x % table_mod));'), (223, '                func.instruction(Instruction::TableGet { table: 0 });'), (225, '                func.instruction(Instruction::I32Const(*y % table_mod));'), (226, '                func.instruction(Instruction::TableGet { table: 0 });'), (228, '                func.instruction(Instruction::I32Const(*z % table_mod));'), (229, '                func.instruction(Instruction::TableGet { table: 0 });'), (231, '                func.instruction(Instruction::Call(1));'), (232, '            }'), (233, '            TableOp::TakeFromMake => {'), (234, '                func.instruction(Instruction::Call(2));'), (235, '                func.instruction(Instruction::Call(1));'), (236, '            }'), (237, '            Self::TakeFromGc => {'), (238, '                func.instruction(Instruction::Call(0));'), (239, '                func.instruction(Instruction::Call(1));'), (240, '            }'), (252, '            num_params: 5,'), (253, '            table_size: 20,'), (259, '                TableOp::SetFromMake(5, 6, 7),'), (260, '                TableOp::Make,'), (261, '                TableOp::TakeFromParams(8, 9, 10),'), (262, '                TableOp::TakeFromGet(11, 12, 13),'), (263, '                TableOp::TakeFromMake,'), (270, '  (type (;1;) (func (param externref externref externref externref externref)))'), (271, '  (type (;2;) (func (param externref externref externref)))'), (272, '  (type (;3;) (func (result externref externref externref)))'), (274, '  (import \"\" \"take_refs\" (func (;1;) (type 2)))'), (275, '  (import \"\" \"make_refs\" (func (;2;) (type 3)))'), (276, '  (func (;3;) (type 1) (param externref externref externref externref externref)'), (277, '    (local externref i32)'), (278, '    i32.const 100'), (279, '    local.set 6'), (280, '    loop  ;; label = @1'), (281, '      call 0'), (282, '      i32.const 0'), (283, '      table.get 0'), (284, '      drop'), (285, '      i32.const 1'), (286, '      local.get 2'), (287, '      table.set 0'), (288, '      i32.const 3'), (289, '      i32.const 4'), (290, '      table.get 0'), (291, '      table.set 0'), (292, '      call 2'), (293, '      local.set 5'), (294, '      i32.const 5'), (295, '      local.get 5'), (296, '      table.set 0'), (297, '      local.set 5'), (298, '      i32.const 6'), (299, '      local.get 5'), (300, '      table.set 0'), (301, '      local.set 5'), (302, '      i32.const 7'), (303, '      local.get 5'), (304, '      table.set 0'), (305, '      call 2'), (306, '      drop'), (307, '      drop'), (308, '      drop'), (309, '      local.get 3'), (310, '      local.get 4'), (311, '      local.get 0'), (312, '      call 1'), (313, '      i32.const 11'), (314, '      table.get 0'), (315, '      i32.const 12'), (316, '      table.get 0'), (317, '      i32.const 13'), (318, '      table.get 0'), (319, '      call 1'), (320, '      call 2'), (321, '      call 1'), (322, '      local.get 6'), (323, '      i32.const -1'), (324, '      i32.add'), (325, '      local.tee 6'), (326, '      br_if 0 (;@1;)'), (327, '    end)'), (328, '  (table (;0;) 20 externref)'), (329, '  (export \"run\" (func 3)))'), (331, '        eprintln!(\"expected WAT = {}\", expected);'), (334, '        if let Err(e) = wasmparser::validate(&actual) {'), (335, '            panic!(\"TableOps should generate valid Wasm; got error: {}\", e);'), (336, '        }'), (339, '        eprintln!(\"actual WAT = {}\", actual);')], 'deleted': [(21, 'const MAX_OPS: usize = 1000;'), (65, '        let mut types = TypeSection::new();'), (66, '        types.function(vec![], vec![]); // 0: \"gc\"'), (67, '        let mut params: Vec<ValType> = Vec::with_capacity(self.num_params() as usize);'), (68, '        for _i in 0..self.num_params() {'), (69, '            params.push(ValType::ExternRef);'), (70, '        }'), (71, '        let results = vec![];'), (72, '        types.function(params, results); // 1: \"run\"'), (79, '        exports.export(\"run\", Export::Function(1));'), (81, '        let mut params: Vec<(u32, ValType)> = Vec::with_capacity(self.num_params() as usize);'), (82, '        for _i in 0..self.num_params() {'), (83, '            params.push((0, ValType::ExternRef));'), (84, '        }'), (85, '        let mut func = Function::new(params);'), (88, '            op.insert(&mut func);'), (119, '    fn insert(&self, func: &mut Function) {'), (125, '                func.instruction(Instruction::I32Const(*x));'), (130, '                func.instruction(Instruction::I32Const(*x));'), (131, '                func.instruction(Instruction::LocalGet(*y));'), (135, '                func.instruction(Instruction::I32Const(*x));'), (136, '                func.instruction(Instruction::I32Const(*y));'), (151, '            num_params: 2,'), (152, '            table_size: 10,'), (164, '  (type (;1;) (func (param externref externref)))'), (166, '  (func (;1;) (type 1) (param externref externref)'), (167, '    call 0'), (168, '    i32.const 0'), (169, '    table.get 0'), (170, '    drop'), (171, '    i32.const 1'), (172, '    local.get 2'), (173, '    table.set 0'), (174, '    i32.const 3'), (175, '    i32.const 4'), (176, '    table.get 0'), (177, '    table.set 0)'), (178, '  (table (;0;) 10 externref)'), (179, '  (export \"run\" (func 1)))')]}",
    "num_lines_added": "162",
    "num_lines_deleted": "39",
    "nloc": "263"
  },
  {
    "file_change_id": "219936507364280",
    "hash": "d2ce1ac753afc059e32798bac3383b81a6d04456",
    "old_path": "crates/fuzzing/src/oracles.rs",
    "new_path": "crates/fuzzing/src/oracles.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -514,16 +514,17 @@ pub fn table_ops(\n ) {\n     let _ = env_logger::try_init();\n \n+    let expected_drops = Arc::new(AtomicUsize::new(ops.num_params() as usize));\n     let num_dropped = Arc::new(AtomicUsize::new(0));\n \n     {\n         let mut config = fuzz_config.to_wasmtime();\n         config.wasm_reference_types(true);\n+        config.consume_fuel(true);\n+\n         let engine = Engine::new(&config).unwrap();\n         let mut store = create_store(&engine);\n-        if fuzz_config.consume_fuel {\n-            store.add_fuel(u64::max_value()).unwrap();\n-        }\n+        store.add_fuel(100).unwrap();\n \n         let wasm = ops.to_wasm_binary();\n         log_wasm(&wasm);\n@@ -532,18 +533,104 @@ pub fn table_ops(\n             Err(_) => return,\n         };\n \n+        let mut linker = Linker::new(&engine);\n+\n         // To avoid timeouts, limit the number of explicit GCs we perform per\n         // test case.\n         const MAX_GCS: usize = 5;\n \n         let num_gcs = AtomicUsize::new(0);\n-        let gc = Func::wrap(&mut store, move |mut caller: Caller<'_, StoreLimits>| {\n-            if num_gcs.fetch_add(1, SeqCst) < MAX_GCS {\n-                caller.gc();\n-            }\n-        });\n+        linker\n+            .define(\n+                \"\",\n+                \"gc\",\n+                // NB: use `Func::new` so that this can still compile on the old x86\n+                // backend, where `IntoFunc` isn't implemented for multi-value\n+                // returns.\n+                Func::new(\n+                    &mut store,\n+                    FuncType::new(\n+                        vec![],\n+                        vec![ValType::ExternRef, ValType::ExternRef, ValType::ExternRef],\n+                    ),\n+                    {\n+                        let num_dropped = num_dropped.clone();\n+                        let expected_drops = expected_drops.clone();\n+                        move |mut caller: Caller<'_, StoreLimits>, _params, results| {\n+                            if num_gcs.fetch_add(1, SeqCst) < MAX_GCS {\n+                                caller.gc();\n+                            }\n+\n+                            expected_drops.fetch_add(3, SeqCst);\n+                            results[0] =\n+                                Some(ExternRef::new(CountDrops(num_dropped.clone()))).into();\n+                            results[1] =\n+                                Some(ExternRef::new(CountDrops(num_dropped.clone()))).into();\n+                            results[2] =\n+                                Some(ExternRef::new(CountDrops(num_dropped.clone()))).into();\n+                            Ok(())\n+                        }\n+                    },\n+                ),\n+            )\n+            .unwrap();\n+\n+        linker\n+            .func_wrap(\"\", \"take_refs\", {\n+                let expected_drops = expected_drops.clone();\n+                move |a: Option<ExternRef>, b: Option<ExternRef>, c: Option<ExternRef>| {\n+                    // Do the assertion on each ref's inner data, even though it\n+                    // all points to the same atomic, so that if we happen to\n+                    // run into a use-after-free bug with one of these refs we\n+                    // are more likely to trigger a segfault.\n+                    if let Some(a) = a {\n+                        let a = a.data().downcast_ref::<CountDrops>().unwrap();\n+                        assert!(a.0.load(SeqCst) <= expected_drops.load(SeqCst));\n+                    }\n+                    if let Some(b) = b {\n+                        let b = b.data().downcast_ref::<CountDrops>().unwrap();\n+                        assert!(b.0.load(SeqCst) <= expected_drops.load(SeqCst));\n+                    }\n+                    if let Some(c) = c {\n+                        let c = c.data().downcast_ref::<CountDrops>().unwrap();\n+                        assert!(c.0.load(SeqCst) <= expected_drops.load(SeqCst));\n+                    }\n+                }\n+            })\n+            .unwrap();\n+\n+        linker\n+            .define(\n+                \"\",\n+                \"make_refs\",\n+                // NB: use `Func::new` so that this can still compile on the old\n+                // x86 backend, where `IntoFunc` isn't implemented for\n+                // multi-value returns.\n+                Func::new(\n+                    &mut store,\n+                    FuncType::new(\n+                        vec![],\n+                        vec![ValType::ExternRef, ValType::ExternRef, ValType::ExternRef],\n+                    ),\n+                    {\n+                        let num_dropped = num_dropped.clone();\n+                        let expected_drops = expected_drops.clone();\n+                        move |_caller, _params, results| {\n+                            expected_drops.fetch_add(3, SeqCst);\n+                            results[0] =\n+                                Some(ExternRef::new(CountDrops(num_dropped.clone()))).into();\n+                            results[1] =\n+                                Some(ExternRef::new(CountDrops(num_dropped.clone()))).into();\n+                            results[2] =\n+                                Some(ExternRef::new(CountDrops(num_dropped.clone()))).into();\n+                            Ok(())\n+                        }\n+                    },\n+                ),\n+            )\n+            .unwrap();\n \n-        let instance = Instance::new(&mut store, &module, &[gc.into()]).unwrap();\n+        let instance = linker.instantiate(&mut store, &module).unwrap();\n         let run = instance.get_func(&mut store, \"run\").unwrap();\n \n         let args: Vec<_> = (0..ops.num_params())\n@@ -552,7 +639,7 @@ pub fn table_ops(\n         let _ = run.call(&mut store, &args);\n     }\n \n-    assert_eq!(num_dropped.load(SeqCst), ops.num_params() as usize);\n+    assert_eq!(num_dropped.load(SeqCst), expected_drops.load(SeqCst));\n     return;\n \n     struct CountDrops(Arc<AtomicUsize>);\n",
    "diff_parsed": "{'added': [(517, '    let expected_drops = Arc::new(AtomicUsize::new(ops.num_params() as usize));'), (523, '        config.consume_fuel(true);'), (527, '        store.add_fuel(100).unwrap();'), (536, '        let mut linker = Linker::new(&engine);'), (543, '        linker'), (544, '            .define('), (545, '                \"\",'), (546, '                \"gc\",'), (550, '                Func::new('), (551, '                    &mut store,'), (552, '                    FuncType::new('), (553, '                        vec![],'), (554, '                        vec![ValType::ExternRef, ValType::ExternRef, ValType::ExternRef],'), (555, '                    ),'), (556, '                    {'), (557, '                        let num_dropped = num_dropped.clone();'), (558, '                        let expected_drops = expected_drops.clone();'), (559, \"                        move |mut caller: Caller<'_, StoreLimits>, _params, results| {\"), (560, '                            if num_gcs.fetch_add(1, SeqCst) < MAX_GCS {'), (561, '                                caller.gc();'), (562, '                            }'), (564, '                            expected_drops.fetch_add(3, SeqCst);'), (565, '                            results[0] ='), (566, '                                Some(ExternRef::new(CountDrops(num_dropped.clone()))).into();'), (567, '                            results[1] ='), (568, '                                Some(ExternRef::new(CountDrops(num_dropped.clone()))).into();'), (569, '                            results[2] ='), (570, '                                Some(ExternRef::new(CountDrops(num_dropped.clone()))).into();'), (571, '                            Ok(())'), (572, '                        }'), (573, '                    },'), (574, '                ),'), (575, '            )'), (576, '            .unwrap();'), (578, '        linker'), (579, '            .func_wrap(\"\", \"take_refs\", {'), (580, '                let expected_drops = expected_drops.clone();'), (581, '                move |a: Option<ExternRef>, b: Option<ExternRef>, c: Option<ExternRef>| {'), (586, '                    if let Some(a) = a {'), (587, '                        let a = a.data().downcast_ref::<CountDrops>().unwrap();'), (588, '                        assert!(a.0.load(SeqCst) <= expected_drops.load(SeqCst));'), (589, '                    }'), (590, '                    if let Some(b) = b {'), (591, '                        let b = b.data().downcast_ref::<CountDrops>().unwrap();'), (592, '                        assert!(b.0.load(SeqCst) <= expected_drops.load(SeqCst));'), (593, '                    }'), (594, '                    if let Some(c) = c {'), (595, '                        let c = c.data().downcast_ref::<CountDrops>().unwrap();'), (596, '                        assert!(c.0.load(SeqCst) <= expected_drops.load(SeqCst));'), (597, '                    }'), (598, '                }'), (599, '            })'), (600, '            .unwrap();'), (602, '        linker'), (603, '            .define('), (604, '                \"\",'), (605, '                \"make_refs\",'), (609, '                Func::new('), (610, '                    &mut store,'), (611, '                    FuncType::new('), (612, '                        vec![],'), (613, '                        vec![ValType::ExternRef, ValType::ExternRef, ValType::ExternRef],'), (614, '                    ),'), (615, '                    {'), (616, '                        let num_dropped = num_dropped.clone();'), (617, '                        let expected_drops = expected_drops.clone();'), (618, '                        move |_caller, _params, results| {'), (619, '                            expected_drops.fetch_add(3, SeqCst);'), (620, '                            results[0] ='), (621, '                                Some(ExternRef::new(CountDrops(num_dropped.clone()))).into();'), (622, '                            results[1] ='), (623, '                                Some(ExternRef::new(CountDrops(num_dropped.clone()))).into();'), (624, '                            results[2] ='), (625, '                                Some(ExternRef::new(CountDrops(num_dropped.clone()))).into();'), (626, '                            Ok(())'), (627, '                        }'), (628, '                    },'), (629, '                ),'), (630, '            )'), (631, '            .unwrap();'), (633, '        let instance = linker.instantiate(&mut store, &module).unwrap();'), (642, '    assert_eq!(num_dropped.load(SeqCst), expected_drops.load(SeqCst));')], 'deleted': [(524, '        if fuzz_config.consume_fuel {'), (525, '            store.add_fuel(u64::max_value()).unwrap();'), (526, '        }'), (540, \"        let gc = Func::wrap(&mut store, move |mut caller: Caller<'_, StoreLimits>| {\"), (541, '            if num_gcs.fetch_add(1, SeqCst) < MAX_GCS {'), (542, '                caller.gc();'), (543, '            }'), (544, '        });'), (546, '        let instance = Instance::new(&mut store, &module, &[gc.into()]).unwrap();'), (555, '    assert_eq!(num_dropped.load(SeqCst), ops.num_params() as usize);')]}",
    "num_lines_added": "82",
    "num_lines_deleted": "10",
    "nloc": "721"
  },
  {
    "file_change_id": "116218434146631",
    "hash": "d2ce1ac753afc059e32798bac3383b81a6d04456",
    "old_path": "crates/runtime/src/externref.rs",
    "new_path": "crates/runtime/src/externref.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -489,7 +489,7 @@ type TableElem = UnsafeCell<Option<VMExternRef>>;\n ///\n /// Under the covers, this is a simple bump allocator that allows duplicate\n /// entries. Deduplication happens at GC time.\n-#[repr(C)] // `alloc` must be the first member, it's accessed from JIT code\n+#[repr(C)] // `alloc` must be the first member, it's accessed from JIT code.\n pub struct VMExternRefActivationsTable {\n     /// Structures used to perform fast bump allocation of storage of externref\n     /// values.\n@@ -521,9 +521,14 @@ pub struct VMExternRefActivationsTable {\n     /// inside-a-Wasm-frame roots, and doing a GC could lead to freeing one of\n     /// those missed roots, and use after free.\n     stack_canary: Option<usize>,\n+\n+    /// A debug-only field for asserting that we are in a region of code where\n+    /// GC is okay to preform.\n+    #[cfg(debug_assertions)]\n+    gc_okay: bool,\n }\n \n-#[repr(C)] // this is accessed from JTI code\n+#[repr(C)] // This is accessed from JIT code.\n struct VMExternRefTableAlloc {\n     /// Bump-allocation finger within the `chunk`.\n     ///\n@@ -573,6 +578,8 @@ impl VMExternRefActivationsTable {\n             over_approximated_stack_roots: HashSet::with_capacity(Self::CHUNK_SIZE),\n             precise_stack_roots: HashSet::with_capacity(Self::CHUNK_SIZE),\n             stack_canary: None,\n+            #[cfg(debug_assertions)]\n+            gc_okay: true,\n         }\n     }\n \n@@ -581,6 +588,14 @@ impl VMExternRefActivationsTable {\n         (0..size).map(|_| UnsafeCell::new(None)).collect()\n     }\n \n+    /// Get the available capacity in the bump allocation chunk.\n+    #[inline]\n+    pub fn bump_capacity_remaining(&self) -> usize {\n+        let end = self.alloc.end.as_ptr() as usize;\n+        let next = unsafe { *self.alloc.next.get() };\n+        end - next.as_ptr() as usize\n+    }\n+\n     /// Try and insert a `VMExternRef` into this table.\n     ///\n     /// This is a fast path that only succeeds when the bump chunk has the\n@@ -624,6 +639,9 @@ impl VMExternRefActivationsTable {\n         externref: VMExternRef,\n         module_info_lookup: &dyn ModuleInfoLookup,\n     ) {\n+        #[cfg(debug_assertions)]\n+        assert!(self.gc_okay);\n+\n         if let Err(externref) = self.try_insert(externref) {\n             self.gc_and_insert_slow(externref, module_info_lookup);\n         }\n@@ -644,6 +662,20 @@ impl VMExternRefActivationsTable {\n             .insert(VMExternRefWithTraits(externref));\n     }\n \n+    /// Insert a reference into the table, without ever performing GC.\n+    #[inline]\n+    pub fn insert_without_gc(&mut self, externref: VMExternRef) {\n+        if let Err(externref) = self.try_insert(externref) {\n+            self.insert_slow_without_gc(externref);\n+        }\n+    }\n+\n+    #[inline(never)]\n+    fn insert_slow_without_gc(&mut self, externref: VMExternRef) {\n+        self.over_approximated_stack_roots\n+            .insert(VMExternRefWithTraits(externref));\n+    }\n+\n     fn num_filled_in_bump_chunk(&self) -> usize {\n         let next = unsafe { *self.alloc.next.get() };\n         let bytes_unused = (self.alloc.end.as_ptr() as usize) - (next.as_ptr() as usize);\n@@ -742,6 +774,24 @@ impl VMExternRefActivationsTable {\n     pub fn set_stack_canary(&mut self, canary: Option<usize>) {\n         self.stack_canary = canary;\n     }\n+\n+    /// Set whether it is okay to GC or not right now.\n+    ///\n+    /// This is provided as a helper for enabling various debug-only assertions\n+    /// and checking places where the `wasmtime-runtime` user expects there not\n+    /// to be any GCs.\n+    #[inline]\n+    pub fn set_gc_okay(&mut self, okay: bool) -> bool {\n+        #[cfg(debug_assertions)]\n+        {\n+            return std::mem::replace(&mut self.gc_okay, okay);\n+        }\n+        #[cfg(not(debug_assertions))]\n+        {\n+            let _ = okay;\n+            return true;\n+        }\n+    }\n }\n \n /// Used by the runtime to lookup information about a module given a\n@@ -807,6 +857,9 @@ pub unsafe fn gc(\n ) {\n     log::debug!(\"start GC\");\n \n+    #[cfg(debug_assertions)]\n+    assert!(externref_activations_table.gc_okay);\n+\n     debug_assert!({\n         // This set is only non-empty within this function. It is built up when\n         // walking the stack and interpreting stack maps, and then drained back\n",
    "diff_parsed": "{'added': [(492, \"#[repr(C)] // `alloc` must be the first member, it's accessed from JIT code.\"), (527, '    #[cfg(debug_assertions)]'), (528, '    gc_okay: bool,'), (531, '#[repr(C)] // This is accessed from JIT code.'), (581, '            #[cfg(debug_assertions)]'), (582, '            gc_okay: true,'), (592, '    #[inline]'), (593, '    pub fn bump_capacity_remaining(&self) -> usize {'), (594, '        let end = self.alloc.end.as_ptr() as usize;'), (595, '        let next = unsafe { *self.alloc.next.get() };'), (596, '        end - next.as_ptr() as usize'), (597, '    }'), (642, '        #[cfg(debug_assertions)]'), (643, '        assert!(self.gc_okay);'), (666, '    #[inline]'), (667, '    pub fn insert_without_gc(&mut self, externref: VMExternRef) {'), (668, '        if let Err(externref) = self.try_insert(externref) {'), (669, '            self.insert_slow_without_gc(externref);'), (670, '        }'), (671, '    }'), (673, '    #[inline(never)]'), (674, '    fn insert_slow_without_gc(&mut self, externref: VMExternRef) {'), (675, '        self.over_approximated_stack_roots'), (676, '            .insert(VMExternRefWithTraits(externref));'), (677, '    }'), (783, '    #[inline]'), (784, '    pub fn set_gc_okay(&mut self, okay: bool) -> bool {'), (785, '        #[cfg(debug_assertions)]'), (786, '        {'), (787, '            return std::mem::replace(&mut self.gc_okay, okay);'), (788, '        }'), (789, '        #[cfg(not(debug_assertions))]'), (790, '        {'), (791, '            let _ = okay;'), (792, '            return true;'), (793, '        }'), (794, '    }'), (860, '    #[cfg(debug_assertions)]'), (861, '    assert!(externref_activations_table.gc_okay);')], 'deleted': [(492, \"#[repr(C)] // `alloc` must be the first member, it's accessed from JIT code\"), (526, '#[repr(C)] // this is accessed from JTI code')]}",
    "num_lines_added": "39",
    "num_lines_deleted": "2",
    "nloc": "559"
  },
  {
    "file_change_id": "277904830363360",
    "hash": "d2ce1ac753afc059e32798bac3383b81a6d04456",
    "old_path": "crates/types/src/lib.rs",
    "new_path": "crates/types/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -71,29 +71,66 @@ impl From<WasmType> for wasmparser::Type {\n /// WebAssembly function type -- equivalent of `wasmparser`'s FuncType.\n #[derive(Debug, Clone, Eq, PartialEq, Hash, Serialize, Deserialize)]\n pub struct WasmFuncType {\n+    params: Box<[WasmType]>,\n+    externref_params_count: usize,\n+    returns: Box<[WasmType]>,\n+    externref_returns_count: usize,\n+}\n+\n+impl WasmFuncType {\n+    #[inline]\n+    pub fn new(params: Box<[WasmType]>, returns: Box<[WasmType]>) -> Self {\n+        let externref_params_count = params.iter().filter(|p| **p == WasmType::ExternRef).count();\n+        let externref_returns_count = params.iter().filter(|r| **r == WasmType::ExternRef).count();\n+        WasmFuncType {\n+            params,\n+            externref_params_count,\n+            returns,\n+            externref_returns_count,\n+        }\n+    }\n+\n     /// Function params types.\n-    pub params: Box<[WasmType]>,\n+    #[inline]\n+    pub fn params(&self) -> &[WasmType] {\n+        &self.params\n+    }\n+\n+    /// How many `externref`s are in this function's params?\n+    #[inline]\n+    pub fn externref_params_count(&self) -> usize {\n+        self.externref_params_count\n+    }\n+\n     /// Returns params types.\n-    pub returns: Box<[WasmType]>,\n+    #[inline]\n+    pub fn returns(&self) -> &[WasmType] {\n+        &self.returns\n+    }\n+\n+    /// How many `externref`s are in this function's returns?\n+    #[inline]\n+    pub fn externref_returns_count(&self) -> usize {\n+        self.externref_returns_count\n+    }\n }\n \n impl TryFrom<wasmparser::FuncType> for WasmFuncType {\n     type Error = WasmError;\n     fn try_from(ty: wasmparser::FuncType) -> Result<Self, Self::Error> {\n-        Ok(Self {\n-            params: ty\n-                .params\n-                .into_vec()\n-                .into_iter()\n-                .map(WasmType::try_from)\n-                .collect::<Result<_, Self::Error>>()?,\n-            returns: ty\n-                .returns\n-                .into_vec()\n-                .into_iter()\n-                .map(WasmType::try_from)\n-                .collect::<Result<_, Self::Error>>()?,\n-        })\n+        let params = ty\n+            .params\n+            .into_vec()\n+            .into_iter()\n+            .map(WasmType::try_from)\n+            .collect::<Result<_, Self::Error>>()?;\n+        let returns = ty\n+            .returns\n+            .into_vec()\n+            .into_iter()\n+            .map(WasmType::try_from)\n+            .collect::<Result<_, Self::Error>>()?;\n+        Ok(Self::new(params, returns))\n     }\n }\n \n",
    "diff_parsed": "{'added': [(74, '    params: Box<[WasmType]>,'), (75, '    externref_params_count: usize,'), (76, '    returns: Box<[WasmType]>,'), (77, '    externref_returns_count: usize,'), (78, '}'), (80, 'impl WasmFuncType {'), (81, '    #[inline]'), (82, '    pub fn new(params: Box<[WasmType]>, returns: Box<[WasmType]>) -> Self {'), (83, '        let externref_params_count = params.iter().filter(|p| **p == WasmType::ExternRef).count();'), (84, '        let externref_returns_count = params.iter().filter(|r| **r == WasmType::ExternRef).count();'), (85, '        WasmFuncType {'), (86, '            params,'), (87, '            externref_params_count,'), (88, '            returns,'), (89, '            externref_returns_count,'), (90, '        }'), (91, '    }'), (94, '    #[inline]'), (95, '    pub fn params(&self) -> &[WasmType] {'), (96, '        &self.params'), (97, '    }'), (100, '    #[inline]'), (101, '    pub fn externref_params_count(&self) -> usize {'), (102, '        self.externref_params_count'), (103, '    }'), (106, '    #[inline]'), (107, '    pub fn returns(&self) -> &[WasmType] {'), (108, '        &self.returns'), (109, '    }'), (112, '    #[inline]'), (113, '    pub fn externref_returns_count(&self) -> usize {'), (114, '        self.externref_returns_count'), (115, '    }'), (121, '        let params = ty'), (122, '            .params'), (123, '            .into_vec()'), (124, '            .into_iter()'), (125, '            .map(WasmType::try_from)'), (126, '            .collect::<Result<_, Self::Error>>()?;'), (127, '        let returns = ty'), (128, '            .returns'), (129, '            .into_vec()'), (130, '            .into_iter()'), (131, '            .map(WasmType::try_from)'), (132, '            .collect::<Result<_, Self::Error>>()?;'), (133, '        Ok(Self::new(params, returns))')], 'deleted': [(75, '    pub params: Box<[WasmType]>,'), (77, '    pub returns: Box<[WasmType]>,'), (83, '        Ok(Self {'), (84, '            params: ty'), (85, '                .params'), (86, '                .into_vec()'), (87, '                .into_iter()'), (88, '                .map(WasmType::try_from)'), (89, '                .collect::<Result<_, Self::Error>>()?,'), (90, '            returns: ty'), (91, '                .returns'), (92, '                .into_vec()'), (93, '                .into_iter()'), (94, '                .map(WasmType::try_from)'), (95, '                .collect::<Result<_, Self::Error>>()?,'), (96, '        })')]}",
    "num_lines_added": "46",
    "num_lines_deleted": "16",
    "nloc": "247"
  },
  {
    "file_change_id": "15308249036122",
    "hash": "d2ce1ac753afc059e32798bac3383b81a6d04456",
    "old_path": "crates/wasmtime/src/func.rs",
    "new_path": "crates/wasmtime/src/func.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -774,6 +774,21 @@ impl Func {\n \n             let mut values_vec = vec![0; max(params.len(), ty.results().len())];\n \n+            // Whenever we pass `externref`s from host code to Wasm code, they\n+            // go into the `VMExternRefActivationsTable`. But the table might be\n+            // at capacity already, so check for that. If it is at capacity\n+            // (unlikely) then do a GC to free up space. This is necessary\n+            // because otherwise we would either keep filling up the bump chunk\n+            // and making it larger and larger or we would always take the slow\n+            // path when inserting references into the table.\n+            if ty.as_wasm_func_type().externref_params_count()\n+                > store\n+                    .externref_activations_table()\n+                    .bump_capacity_remaining()\n+            {\n+                store.gc();\n+            }\n+\n             // Store the argument values into `values_vec`.\n             let param_tys = ty.params();\n             for ((arg, slot), ty) in params.iter().cloned().zip(&mut values_vec).zip(param_tys) {\n@@ -788,7 +803,7 @@ impl Func {\n                     bail!(\"cross-`Store` values are not currently supported\");\n                 }\n                 unsafe {\n-                    arg.write_value_to(store, slot);\n+                    arg.write_value_without_gc(store, slot);\n                 }\n             }\n \n@@ -871,6 +886,17 @@ impl Func {\n         let (params, results) = val_vec.split_at_mut(nparams);\n         func(caller.sub_caller(), params, results)?;\n \n+        // See the comment in `Func::call_impl`'s `write_params` function.\n+        if ty.as_wasm_func_type().externref_returns_count()\n+            > caller\n+                .store\n+                .0\n+                .externref_activations_table()\n+                .bump_capacity_remaining()\n+        {\n+            caller.store.gc();\n+        }\n+\n         // Unlike our arguments we need to dynamically check that the return\n         // values produced are correct. There could be a bug in `func` that\n         // produces the wrong number, wrong types, or wrong stores of\n@@ -887,7 +913,7 @@ impl Func {\n                 ));\n             }\n             unsafe {\n-                ret.write_value_to(caller.store.0, values_vec.add(i));\n+                ret.write_value_without_gc(caller.store.0, values_vec.add(i));\n             }\n         }\n \n",
    "diff_parsed": "{'added': [(784, '            if ty.as_wasm_func_type().externref_params_count()'), (785, '                > store'), (786, '                    .externref_activations_table()'), (787, '                    .bump_capacity_remaining()'), (788, '            {'), (789, '                store.gc();'), (790, '            }'), (806, '                    arg.write_value_without_gc(store, slot);'), (890, '        if ty.as_wasm_func_type().externref_returns_count()'), (891, '            > caller'), (892, '                .store'), (893, '                .0'), (894, '                .externref_activations_table()'), (895, '                .bump_capacity_remaining()'), (896, '        {'), (897, '            caller.store.gc();'), (898, '        }'), (916, '                ret.write_value_without_gc(caller.store.0, values_vec.add(i));')], 'deleted': [(791, '                    arg.write_value_to(store, slot);'), (890, '                ret.write_value_to(caller.store.0, values_vec.add(i));')]}",
    "num_lines_added": "18",
    "num_lines_deleted": "2",
    "nloc": "994"
  },
  {
    "file_change_id": "47447892372512",
    "hash": "d2ce1ac753afc059e32798bac3383b81a6d04456",
    "old_path": "crates/wasmtime/src/func/typed.rs",
    "new_path": "crates/wasmtime/src/func/typed.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,5 +1,5 @@\n use super::{invoke_wasm_and_catch_traps, HostAbi};\n-use crate::store::StoreOpaque;\n+use crate::store::{AutoAssertNoGc, StoreOpaque};\n use crate::{AsContextMut, ExternRef, Func, StoreContextMut, Trap, ValType};\n use anyhow::{bail, Result};\n use std::marker;\n@@ -115,15 +115,33 @@ where\n         store: &mut StoreContextMut<'_, T>,\n         params: Params,\n     ) -> Result<Results, Trap> {\n+        // See the comment in `Func::call_impl`'s `write_params` function.\n+        if params.externrefs_count()\n+            > store\n+                .0\n+                .externref_activations_table()\n+                .bump_capacity_remaining()\n+        {\n+            store.gc();\n+        }\n+\n         // Validate that all runtime values flowing into this store indeed\n         // belong within this store, otherwise it would be unsafe for store\n         // values to cross each other.\n-        let params = match params.into_abi(store.0) {\n-            Some(abi) => abi,\n-            None => {\n-                return Err(Trap::new(\n-                    \"attempt to pass cross-`Store` value to Wasm as function argument\",\n-                ))\n+\n+        let params = {\n+            // GC is not safe here, since we move refs into the activations\n+            // table but don't hold a strong reference onto them until we enter\n+            // the Wasm frame and they get referenced from the stack maps.\n+            let mut store = AutoAssertNoGc::new(&mut **store.as_context_mut().0);\n+\n+            match params.into_abi(&mut store) {\n+                Some(abi) => abi,\n+                None => {\n+                    return Err(Trap::new(\n+                        \"attempt to pass cross-`Store` value to Wasm as function argument\",\n+                    ))\n+                }\n             }\n         };\n \n@@ -183,6 +201,8 @@ pub unsafe trait WasmTy: Send {\n     #[doc(hidden)]\n     fn compatible_with_store(&self, store: &StoreOpaque) -> bool;\n     #[doc(hidden)]\n+    fn is_externref(&self) -> bool;\n+    #[doc(hidden)]\n     fn into_abi(self, store: &mut StoreOpaque) -> Self::Abi;\n     #[doc(hidden)]\n     unsafe fn from_abi(abi: Self::Abi, store: &mut StoreOpaque) -> Self;\n@@ -201,6 +221,10 @@ macro_rules! primitives {\n                 true\n             }\n             #[inline]\n+            fn is_externref(&self) -> bool {\n+                false\n+            }\n+            #[inline]\n             fn into_abi(self, _store: &mut StoreOpaque) -> Self::Abi {\n                 self\n             }\n@@ -234,12 +258,46 @@ unsafe impl WasmTy for Option<ExternRef> {\n         true\n     }\n \n+    #[inline]\n+    fn is_externref(&self) -> bool {\n+        true\n+    }\n+\n     #[inline]\n     fn into_abi(self, store: &mut StoreOpaque) -> Self::Abi {\n         if let Some(x) = self {\n             let abi = x.inner.as_raw();\n             unsafe {\n-                store.insert_vmexternref(x.inner);\n+                // NB: We _must not_ trigger a GC when passing refs from host\n+                // code into Wasm (e.g. returned from a host function or passed\n+                // as arguments to a Wasm function). After insertion into the\n+                // table, this reference is no longer rooted. If multiple\n+                // references are being sent from the host into Wasm and we\n+                // allowed GCs during insertion, then the following events could\n+                // happen:\n+                //\n+                // * Reference A is inserted into the activations\n+                //   table. This does not trigger a GC, but does fill the table\n+                //   to capacity.\n+                //\n+                // * The caller's reference to A is removed. Now the only\n+                //   reference to A is from the activations table.\n+                //\n+                // * Reference B is inserted into the activations table. Because\n+                //   the table is at capacity, a GC is triggered.\n+                //\n+                // * A is reclaimed because the only reference keeping it alive\n+                //   was the activation table's reference (it isn't inside any\n+                //   Wasm frames on the stack yet, so stack scanning and stack\n+                //   maps don't increment its reference count).\n+                //\n+                // * We transfer control to Wasm, giving it A and B. Wasm uses\n+                //   A. That's a use after free.\n+                //\n+                // In conclusion, to prevent uses after free, we cannot GC\n+                // during this insertion.\n+                let mut store = AutoAssertNoGc::new(store);\n+                store.insert_vmexternref_without_gc(x.inner);\n             }\n             abi\n         } else {\n@@ -276,6 +334,11 @@ unsafe impl WasmTy for Option<Func> {\n         }\n     }\n \n+    #[inline]\n+    fn is_externref(&self) -> bool {\n+        false\n+    }\n+\n     #[inline]\n     fn into_abi(self, store: &mut StoreOpaque) -> Self::Abi {\n         if let Some(f) = self {\n@@ -299,10 +362,16 @@ unsafe impl WasmTy for Option<Func> {\n pub unsafe trait WasmParams: Send {\n     #[doc(hidden)]\n     type Abi: Copy;\n+\n     #[doc(hidden)]\n     fn typecheck(params: impl ExactSizeIterator<Item = crate::ValType>) -> Result<()>;\n+\n+    #[doc(hidden)]\n+    fn externrefs_count(&self) -> usize;\n+\n     #[doc(hidden)]\n     fn into_abi(self, store: &mut StoreOpaque) -> Option<Self::Abi>;\n+\n     #[doc(hidden)]\n     unsafe fn invoke<R: WasmResults>(\n         func: *const VMFunctionBody,\n@@ -323,10 +392,17 @@ where\n     fn typecheck(params: impl ExactSizeIterator<Item = crate::ValType>) -> Result<()> {\n         <(T,) as WasmParams>::typecheck(params)\n     }\n+\n+    #[inline]\n+    fn externrefs_count(&self) -> usize {\n+        T::is_externref(self) as usize\n+    }\n+\n     #[inline]\n     fn into_abi(self, store: &mut StoreOpaque) -> Option<Self::Abi> {\n         <(T,) as WasmParams>::into_abi((self,), store)\n     }\n+\n     unsafe fn invoke<R: WasmResults>(\n         func: *const VMFunctionBody,\n         vmctx1: *mut VMContext,\n@@ -365,6 +441,15 @@ macro_rules! impl_wasm_params {\n                 }\n             }\n \n+            #[inline]\n+            fn externrefs_count(&self) -> usize {\n+                let ($(ref $t,)*) = self;\n+                0 $(\n+                    + $t.is_externref() as usize\n+                )*\n+            }\n+\n+\n             #[inline]\n             fn into_abi(self, _store: &mut StoreOpaque) -> Option<Self::Abi> {\n                 let ($($t,)*) = self;\n",
    "diff_parsed": "{'added': [(2, 'use crate::store::{AutoAssertNoGc, StoreOpaque};'), (119, '        if params.externrefs_count()'), (120, '            > store'), (121, '                .0'), (122, '                .externref_activations_table()'), (123, '                .bump_capacity_remaining()'), (124, '        {'), (125, '            store.gc();'), (126, '        }'), (132, '        let params = {'), (136, '            let mut store = AutoAssertNoGc::new(&mut **store.as_context_mut().0);'), (138, '            match params.into_abi(&mut store) {'), (139, '                Some(abi) => abi,'), (140, '                None => {'), (141, '                    return Err(Trap::new('), (142, '                        \"attempt to pass cross-`Store` value to Wasm as function argument\",'), (143, '                    ))'), (144, '                }'), (204, '    fn is_externref(&self) -> bool;'), (205, '    #[doc(hidden)]'), (224, '            fn is_externref(&self) -> bool {'), (225, '                false'), (226, '            }'), (227, '            #[inline]'), (261, '    #[inline]'), (262, '    fn is_externref(&self) -> bool {'), (263, '        true'), (264, '    }'), (299, '                let mut store = AutoAssertNoGc::new(store);'), (300, '                store.insert_vmexternref_without_gc(x.inner);'), (337, '    #[inline]'), (338, '    fn is_externref(&self) -> bool {'), (339, '        false'), (340, '    }'), (369, '    #[doc(hidden)]'), (370, '    fn externrefs_count(&self) -> usize;'), (396, '    #[inline]'), (397, '    fn externrefs_count(&self) -> usize {'), (398, '        T::is_externref(self) as usize'), (399, '    }'), (444, '            #[inline]'), (445, '            fn externrefs_count(&self) -> usize {'), (446, '                let ($(ref $t,)*) = self;'), (447, '                0 $('), (448, '                    + $t.is_externref() as usize'), (449, '                )*'), (450, '            }')], 'deleted': [(2, 'use crate::store::StoreOpaque;'), (121, '        let params = match params.into_abi(store.0) {'), (122, '            Some(abi) => abi,'), (123, '            None => {'), (124, '                return Err(Trap::new('), (125, '                    \"attempt to pass cross-`Store` value to Wasm as function argument\",'), (126, '                ))'), (242, '                store.insert_vmexternref(x.inner);')]}",
    "num_lines_added": "47",
    "num_lines_deleted": "8",
    "nloc": "391"
  },
  {
    "file_change_id": "69480198736280",
    "hash": "d2ce1ac753afc059e32798bac3383b81a6d04456",
    "old_path": "crates/wasmtime/src/store.rs",
    "new_path": "crates/wasmtime/src/store.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -290,6 +290,67 @@ unsafe impl Send for AsyncState {}\n #[cfg(feature = \"async\")]\n unsafe impl Sync for AsyncState {}\n \n+/// An RAII type to automatically mark a region of code as unsafe for GC.\n+pub(crate) struct AutoAssertNoGc<T>\n+where\n+    T: std::ops::DerefMut<Target = StoreOpaque>,\n+{\n+    #[cfg(debug_assertions)]\n+    prev_okay: bool,\n+    store: T,\n+}\n+\n+impl<T> AutoAssertNoGc<T>\n+where\n+    T: std::ops::DerefMut<Target = StoreOpaque>,\n+{\n+    pub fn new(mut store: T) -> Self {\n+        #[cfg(debug_assertions)]\n+        {\n+            let prev_okay = store.externref_activations_table.set_gc_okay(false);\n+            return AutoAssertNoGc { store, prev_okay };\n+        }\n+        #[cfg(not(debug_assertions))]\n+        {\n+            return AutoAssertNoGc { store };\n+        }\n+    }\n+}\n+\n+impl<T> std::ops::Deref for AutoAssertNoGc<T>\n+where\n+    T: std::ops::DerefMut<Target = StoreOpaque>,\n+{\n+    type Target = T;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.store\n+    }\n+}\n+\n+impl<T> std::ops::DerefMut for AutoAssertNoGc<T>\n+where\n+    T: std::ops::DerefMut<Target = StoreOpaque>,\n+{\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.store\n+    }\n+}\n+\n+impl<T> Drop for AutoAssertNoGc<T>\n+where\n+    T: std::ops::DerefMut<Target = StoreOpaque>,\n+{\n+    fn drop(&mut self) {\n+        #[cfg(debug_assertions)]\n+        {\n+            self.store\n+                .externref_activations_table\n+                .set_gc_okay(self.prev_okay);\n+        }\n+    }\n+}\n+\n /// Used to associate instances with the store.\n ///\n /// This is needed to track if the instance was allocated explicitly with the on-demand\n@@ -1039,9 +1100,8 @@ impl StoreOpaque {\n         &*self.interrupts as *const VMInterrupts as *mut VMInterrupts\n     }\n \n-    pub unsafe fn insert_vmexternref(&mut self, r: VMExternRef) {\n-        self.externref_activations_table\n-            .insert_with_gc(r, &self.modules)\n+    pub unsafe fn insert_vmexternref_without_gc(&mut self, r: VMExternRef) {\n+        self.externref_activations_table.insert_without_gc(r);\n     }\n \n     #[inline]\n",
    "diff_parsed": "{'added': [(294, 'pub(crate) struct AutoAssertNoGc<T>'), (295, 'where'), (296, '    T: std::ops::DerefMut<Target = StoreOpaque>,'), (297, '{'), (298, '    #[cfg(debug_assertions)]'), (299, '    prev_okay: bool,'), (300, '    store: T,'), (301, '}'), (303, 'impl<T> AutoAssertNoGc<T>'), (304, 'where'), (305, '    T: std::ops::DerefMut<Target = StoreOpaque>,'), (306, '{'), (307, '    pub fn new(mut store: T) -> Self {'), (308, '        #[cfg(debug_assertions)]'), (309, '        {'), (310, '            let prev_okay = store.externref_activations_table.set_gc_okay(false);'), (311, '            return AutoAssertNoGc { store, prev_okay };'), (312, '        }'), (313, '        #[cfg(not(debug_assertions))]'), (314, '        {'), (315, '            return AutoAssertNoGc { store };'), (316, '        }'), (317, '    }'), (318, '}'), (320, 'impl<T> std::ops::Deref for AutoAssertNoGc<T>'), (321, 'where'), (322, '    T: std::ops::DerefMut<Target = StoreOpaque>,'), (323, '{'), (324, '    type Target = T;'), (326, '    fn deref(&self) -> &Self::Target {'), (327, '        &self.store'), (328, '    }'), (329, '}'), (331, 'impl<T> std::ops::DerefMut for AutoAssertNoGc<T>'), (332, 'where'), (333, '    T: std::ops::DerefMut<Target = StoreOpaque>,'), (334, '{'), (335, '    fn deref_mut(&mut self) -> &mut Self::Target {'), (336, '        &mut self.store'), (337, '    }'), (338, '}'), (340, 'impl<T> Drop for AutoAssertNoGc<T>'), (341, 'where'), (342, '    T: std::ops::DerefMut<Target = StoreOpaque>,'), (343, '{'), (344, '    fn drop(&mut self) {'), (345, '        #[cfg(debug_assertions)]'), (346, '        {'), (347, '            self.store'), (348, '                .externref_activations_table'), (349, '                .set_gc_okay(self.prev_okay);'), (350, '        }'), (351, '    }'), (352, '}'), (1103, '    pub unsafe fn insert_vmexternref_without_gc(&mut self, r: VMExternRef) {'), (1104, '        self.externref_activations_table.insert_without_gc(r);')], 'deleted': [(1042, '    pub unsafe fn insert_vmexternref(&mut self, r: VMExternRef) {'), (1043, '        self.externref_activations_table'), (1044, '            .insert_with_gc(r, &self.modules)')]}",
    "num_lines_added": "56",
    "num_lines_deleted": "3",
    "nloc": "852"
  },
  {
    "file_change_id": "239963659173073",
    "hash": "d2ce1ac753afc059e32798bac3383b81a6d04456",
    "old_path": "crates/wasmtime/src/types.rs",
    "new_path": "crates/wasmtime/src/types.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -230,21 +230,21 @@ impl FuncType {\n         results: impl IntoIterator<Item = ValType>,\n     ) -> FuncType {\n         FuncType {\n-            sig: WasmFuncType {\n-                params: params.into_iter().map(|t| t.to_wasm_type()).collect(),\n-                returns: results.into_iter().map(|t| t.to_wasm_type()).collect(),\n-            },\n+            sig: WasmFuncType::new(\n+                params.into_iter().map(|t| t.to_wasm_type()).collect(),\n+                results.into_iter().map(|t| t.to_wasm_type()).collect(),\n+            ),\n         }\n     }\n \n     /// Returns the list of parameter types for this function.\n     pub fn params(&self) -> impl ExactSizeIterator<Item = ValType> + '_ {\n-        self.sig.params.iter().map(ValType::from_wasm_type)\n+        self.sig.params().iter().map(ValType::from_wasm_type)\n     }\n \n     /// Returns the list of result types for this function.\n     pub fn results(&self) -> impl ExactSizeIterator<Item = ValType> + '_ {\n-        self.sig.returns.iter().map(ValType::from_wasm_type)\n+        self.sig.returns().iter().map(ValType::from_wasm_type)\n     }\n \n     pub(crate) fn as_wasm_func_type(&self) -> &WasmFuncType {\n",
    "diff_parsed": "{'added': [(233, '            sig: WasmFuncType::new('), (234, '                params.into_iter().map(|t| t.to_wasm_type()).collect(),'), (235, '                results.into_iter().map(|t| t.to_wasm_type()).collect(),'), (236, '            ),'), (242, '        self.sig.params().iter().map(ValType::from_wasm_type)'), (247, '        self.sig.returns().iter().map(ValType::from_wasm_type)')], 'deleted': [(233, '            sig: WasmFuncType {'), (234, '                params: params.into_iter().map(|t| t.to_wasm_type()).collect(),'), (235, '                returns: results.into_iter().map(|t| t.to_wasm_type()).collect(),'), (236, '            },'), (242, '        self.sig.params.iter().map(ValType::from_wasm_type)'), (247, '        self.sig.returns.iter().map(ValType::from_wasm_type)')]}",
    "num_lines_added": "6",
    "num_lines_deleted": "6",
    "nloc": "472"
  },
  {
    "file_change_id": "168645576104654",
    "hash": "d2ce1ac753afc059e32798bac3383b81a6d04456",
    "old_path": "crates/wasmtime/src/values.rs",
    "new_path": "crates/wasmtime/src/values.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -93,17 +93,17 @@ impl Val {\n         }\n     }\n \n-    pub(crate) unsafe fn write_value_to(&self, store: &mut StoreOpaque, p: *mut u128) {\n-        match self {\n-            Val::I32(i) => ptr::write(p as *mut i32, *i),\n-            Val::I64(i) => ptr::write(p as *mut i64, *i),\n-            Val::F32(u) => ptr::write(p as *mut u32, *u),\n-            Val::F64(u) => ptr::write(p as *mut u64, *u),\n-            Val::V128(b) => ptr::write(p as *mut u128, *b),\n+    pub(crate) unsafe fn write_value_without_gc(&self, store: &mut StoreOpaque, p: *mut u128) {\n+        match *self {\n+            Val::I32(i) => ptr::write(p as *mut i32, i),\n+            Val::I64(i) => ptr::write(p as *mut i64, i),\n+            Val::F32(u) => ptr::write(p as *mut u32, u),\n+            Val::F64(u) => ptr::write(p as *mut u64, u),\n+            Val::V128(b) => ptr::write(p as *mut u128, b),\n             Val::ExternRef(None) => ptr::write(p, 0),\n-            Val::ExternRef(Some(x)) => {\n+            Val::ExternRef(Some(ref x)) => {\n                 let externref_ptr = x.inner.as_raw();\n-                store.insert_vmexternref(x.inner.clone());\n+                store.insert_vmexternref_without_gc(x.clone().inner);\n                 ptr::write(p as *mut *mut u8, externref_ptr)\n             }\n             Val::FuncRef(f) => ptr::write(\n",
    "diff_parsed": "{'added': [(96, '    pub(crate) unsafe fn write_value_without_gc(&self, store: &mut StoreOpaque, p: *mut u128) {'), (97, '        match *self {'), (98, '            Val::I32(i) => ptr::write(p as *mut i32, i),'), (99, '            Val::I64(i) => ptr::write(p as *mut i64, i),'), (100, '            Val::F32(u) => ptr::write(p as *mut u32, u),'), (101, '            Val::F64(u) => ptr::write(p as *mut u64, u),'), (102, '            Val::V128(b) => ptr::write(p as *mut u128, b),'), (104, '            Val::ExternRef(Some(ref x)) => {'), (106, '                store.insert_vmexternref_without_gc(x.clone().inner);')], 'deleted': [(96, '    pub(crate) unsafe fn write_value_to(&self, store: &mut StoreOpaque, p: *mut u128) {'), (97, '        match self {'), (98, '            Val::I32(i) => ptr::write(p as *mut i32, *i),'), (99, '            Val::I64(i) => ptr::write(p as *mut i64, *i),'), (100, '            Val::F32(u) => ptr::write(p as *mut u32, *u),'), (101, '            Val::F64(u) => ptr::write(p as *mut u64, *u),'), (102, '            Val::V128(b) => ptr::write(p as *mut u128, *b),'), (104, '            Val::ExternRef(Some(x)) => {'), (106, '                store.insert_vmexternref(x.inner.clone());')]}",
    "num_lines_added": "9",
    "num_lines_deleted": "9",
    "nloc": "232"
  },
  {
    "file_change_id": "103096184262624",
    "hash": "d2ce1ac753afc059e32798bac3383b81a6d04456",
    "old_path": "tests/all/gc.rs",
    "new_path": "tests/all/gc.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -424,3 +424,56 @@ fn global_init_no_leak() -> anyhow::Result<()> {\n \n     Ok(())\n }\n+\n+#[test]\n+fn no_gc_middle_of_args() -> anyhow::Result<()> {\n+    let (mut store, module) = ref_types_module(\n+        r#\"\n+            (module\n+                (import \"\" \"return_some\" (func $return (result externref externref externref)))\n+                (import \"\" \"take_some\" (func $take (param externref externref externref)))\n+                (func (export \"run\")\n+                    (local i32)\n+                    i32.const 1000\n+                    local.set 0\n+                    loop\n+                        call $return\n+                        call $take\n+                        local.get 0\n+                        i32.const -1\n+                        i32.add\n+                        local.tee 0\n+                        br_if 0\n+                    end\n+                )\n+            )\n+        \"#,\n+    )?;\n+\n+    let mut linker = Linker::new(store.engine());\n+    linker.func_wrap(\"\", \"return_some\", || {\n+        (\n+            Some(ExternRef::new(\"a\".to_string())),\n+            Some(ExternRef::new(\"b\".to_string())),\n+            Some(ExternRef::new(\"c\".to_string())),\n+        )\n+    })?;\n+    linker.func_wrap(\n+        \"\",\n+        \"take_some\",\n+        |a: Option<ExternRef>, b: Option<ExternRef>, c: Option<ExternRef>| {\n+            let a = a.unwrap();\n+            let b = b.unwrap();\n+            let c = c.unwrap();\n+            assert_eq!(a.data().downcast_ref::<String>().unwrap(), \"a\");\n+            assert_eq!(b.data().downcast_ref::<String>().unwrap(), \"b\");\n+            assert_eq!(c.data().downcast_ref::<String>().unwrap(), \"c\");\n+        },\n+    )?;\n+\n+    let instance = linker.instantiate(&mut store, &module)?;\n+    let func = instance.get_typed_func::<(), (), _>(&mut store, \"run\")?;\n+    func.call(&mut store, ())?;\n+\n+    Ok(())\n+}\n",
    "diff_parsed": "{'added': [(428, '#[test]'), (429, 'fn no_gc_middle_of_args() -> anyhow::Result<()> {'), (430, '    let (mut store, module) = ref_types_module('), (431, '        r#\"'), (432, '            (module'), (433, '                (import \"\" \"return_some\" (func $return (result externref externref externref)))'), (434, '                (import \"\" \"take_some\" (func $take (param externref externref externref)))'), (435, '                (func (export \"run\")'), (436, '                    (local i32)'), (437, '                    i32.const 1000'), (438, '                    local.set 0'), (439, '                    loop'), (440, '                        call $return'), (441, '                        call $take'), (442, '                        local.get 0'), (443, '                        i32.const -1'), (444, '                        i32.add'), (445, '                        local.tee 0'), (446, '                        br_if 0'), (447, '                    end'), (448, '                )'), (449, '            )'), (450, '        \"#,'), (451, '    )?;'), (453, '    let mut linker = Linker::new(store.engine());'), (454, '    linker.func_wrap(\"\", \"return_some\", || {'), (455, '        ('), (456, '            Some(ExternRef::new(\"a\".to_string())),'), (457, '            Some(ExternRef::new(\"b\".to_string())),'), (458, '            Some(ExternRef::new(\"c\".to_string())),'), (459, '        )'), (460, '    })?;'), (461, '    linker.func_wrap('), (462, '        \"\",'), (463, '        \"take_some\",'), (464, '        |a: Option<ExternRef>, b: Option<ExternRef>, c: Option<ExternRef>| {'), (465, '            let a = a.unwrap();'), (466, '            let b = b.unwrap();'), (467, '            let c = c.unwrap();'), (468, '            assert_eq!(a.data().downcast_ref::<String>().unwrap(), \"a\");'), (469, '            assert_eq!(b.data().downcast_ref::<String>().unwrap(), \"b\");'), (470, '            assert_eq!(c.data().downcast_ref::<String>().unwrap(), \"c\");'), (471, '        },'), (472, '    )?;'), (474, '    let instance = linker.instantiate(&mut store, &module)?;'), (475, '    let func = instance.get_typed_func::<(), (), _>(&mut store, \"run\")?;'), (476, '    func.call(&mut store, ())?;'), (478, '    Ok(())'), (479, '}')], 'deleted': []}",
    "num_lines_added": "49",
    "num_lines_deleted": "0",
    "nloc": "405"
  },
  {
    "file_change_id": "176650478407881",
    "hash": "11ba23a9766a5079918cd9f515bc100bc8164b50",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -7,7 +7,7 @@\n         unused_variables, non_shorthand_field_patterns,\n         unreachable_code, unused_parens)]\n \n-#![no_std]\n+#![cfg_attr(not(feature = \"std\"), no_std)]\n \n #[macro_use]\n mod field;\n",
    "diff_parsed": "{'added': [(10, '#![cfg_attr(not(feature = \"std\"), no_std)]')], 'deleted': [(10, '#![no_std]')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "489"
  },
  {
    "file_change_id": "9134450890701",
    "hash": "11ba23a9766a5079918cd9f515bc100bc8164b50",
    "old_path": "src/scalar.rs",
    "new_path": "src/scalar.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,4 +1,5 @@\n use core::ops::{Add, AddAssign, Mul, MulAssign};\n+use subtle::Choice;\n \n const SECP256K1_N_0: u32 = 0xD0364141;\n const SECP256K1_N_1: u32 = 0xBFD25E8C;\n@@ -69,21 +70,21 @@ impl Scalar {\n \n     #[must_use]\n     fn check_overflow(&self) -> bool {\n-        let mut yes: bool = false;\n-        let mut no: bool = false;\n-        no = no || (self.0[7] < SECP256K1_N_7); /* No need for a > check. */\n-        no = no || (self.0[6] < SECP256K1_N_6); /* No need for a > check. */\n-        no = no || (self.0[5] < SECP256K1_N_5); /* No need for a > check. */\n-        no = no || (self.0[4] < SECP256K1_N_4);\n-        yes = yes || ((self.0[4] > SECP256K1_N_4) && !no);\n-        no = no || ((self.0[3] < SECP256K1_N_3) && !yes);\n-        yes = yes || ((self.0[3] > SECP256K1_N_3) && !no);\n-        no = no || ((self.0[2] < SECP256K1_N_2) && !yes);\n-        yes = yes || ((self.0[2] > SECP256K1_N_2) && !no);\n-        no = no || ((self.0[1] < SECP256K1_N_1) && !yes);\n-        yes = yes || ((self.0[1] > SECP256K1_N_1) && !no);\n-        yes = yes || ((self.0[0] >= SECP256K1_N_0) && !no);\n-        return yes;\n+        let mut yes: Choice = 0.into();\n+        let mut no: Choice = 0.into();\n+        no |= Choice::from((self.0[7] < SECP256K1_N_7) as u8); /* No need for a > check. */\n+        no |= Choice::from((self.0[6] < SECP256K1_N_6) as u8); /* No need for a > check. */\n+        no |= Choice::from((self.0[5] < SECP256K1_N_5) as u8); /* No need for a > check. */\n+        no |= Choice::from((self.0[4] < SECP256K1_N_4) as u8);\n+        yes |= Choice::from((self.0[4] > SECP256K1_N_4) as u8) & !no;\n+        no |= Choice::from((self.0[3] < SECP256K1_N_3) as u8) & !yes;\n+        yes |= Choice::from((self.0[3] > SECP256K1_N_3) as u8) & !no;\n+        no |= Choice::from((self.0[2] < SECP256K1_N_2) as u8) & !yes;\n+        yes |= Choice::from((self.0[2] > SECP256K1_N_2) as u8) & !no;\n+        no |= Choice::from((self.0[1] < SECP256K1_N_1) as u8) & !yes;\n+        yes |= Choice::from((self.0[1] > SECP256K1_N_1) as u8) & !no;\n+        yes |= Choice::from((self.0[0] >= SECP256K1_N_0) as u8) & !no;\n+        return yes.into();\n     }\n \n     #[must_use]\n",
    "diff_parsed": "{'added': [(2, 'use subtle::Choice;'), (73, '        let mut yes: Choice = 0.into();'), (74, '        let mut no: Choice = 0.into();'), (75, '        no |= Choice::from((self.0[7] < SECP256K1_N_7) as u8); /* No need for a > check. */'), (76, '        no |= Choice::from((self.0[6] < SECP256K1_N_6) as u8); /* No need for a > check. */'), (77, '        no |= Choice::from((self.0[5] < SECP256K1_N_5) as u8); /* No need for a > check. */'), (78, '        no |= Choice::from((self.0[4] < SECP256K1_N_4) as u8);'), (79, '        yes |= Choice::from((self.0[4] > SECP256K1_N_4) as u8) & !no;'), (80, '        no |= Choice::from((self.0[3] < SECP256K1_N_3) as u8) & !yes;'), (81, '        yes |= Choice::from((self.0[3] > SECP256K1_N_3) as u8) & !no;'), (82, '        no |= Choice::from((self.0[2] < SECP256K1_N_2) as u8) & !yes;'), (83, '        yes |= Choice::from((self.0[2] > SECP256K1_N_2) as u8) & !no;'), (84, '        no |= Choice::from((self.0[1] < SECP256K1_N_1) as u8) & !yes;'), (85, '        yes |= Choice::from((self.0[1] > SECP256K1_N_1) as u8) & !no;'), (86, '        yes |= Choice::from((self.0[0] >= SECP256K1_N_0) as u8) & !no;'), (87, '        return yes.into();')], 'deleted': [(72, '        let mut yes: bool = false;'), (73, '        let mut no: bool = false;'), (74, '        no = no || (self.0[7] < SECP256K1_N_7); /* No need for a > check. */'), (75, '        no = no || (self.0[6] < SECP256K1_N_6); /* No need for a > check. */'), (76, '        no = no || (self.0[5] < SECP256K1_N_5); /* No need for a > check. */'), (77, '        no = no || (self.0[4] < SECP256K1_N_4);'), (78, '        yes = yes || ((self.0[4] > SECP256K1_N_4) && !no);'), (79, '        no = no || ((self.0[3] < SECP256K1_N_3) && !yes);'), (80, '        yes = yes || ((self.0[3] > SECP256K1_N_3) && !no);'), (81, '        no = no || ((self.0[2] < SECP256K1_N_2) && !yes);'), (82, '        yes = yes || ((self.0[2] > SECP256K1_N_2) && !no);'), (83, '        no = no || ((self.0[1] < SECP256K1_N_1) && !yes);'), (84, '        yes = yes || ((self.0[1] > SECP256K1_N_1) && !no);'), (85, '        yes = yes || ((self.0[0] >= SECP256K1_N_0) && !no);'), (86, '        return yes;')]}",
    "num_lines_added": "16",
    "num_lines_deleted": "15",
    "nloc": "859"
  },
  {
    "file_change_id": "155826202382798",
    "hash": "19ade85",
    "old_path": "core/src/memory.rs",
    "new_path": "core/src/memory.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -105,6 +105,10 @@ impl Memory {\n \t\tvalue: &[u8],\n \t\ttarget_size: Option<usize>\n \t) -> Result<(), ExitFatal> {\n+\t\tif value.is_empty() {\n+\t\t\treturn Ok(())\n+\t\t}\n+\t\t\n \t\tlet target_size = target_size.unwrap_or(value.len());\n \n \t\tif offset.checked_add(target_size)\n",
    "diff_parsed": "{'added': [(108, '\\t\\tif value.is_empty() {'), (109, '\\t\\t\\treturn Ok(())'), (110, '\\t\\t}')], 'deleted': []}",
    "num_lines_added": "3",
    "num_lines_deleted": "0",
    "nloc": "127"
  },
  {
    "file_change_id": "77918237733614",
    "hash": "2a4d53809e3000f40085f2b229b6b1a33759881d",
    "old_path": "src/stack.rs",
    "new_path": "src/stack.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -53,7 +53,8 @@ impl<T: ?Sized, D: ::DataBuf> StackA<T, D> {\n         mem::size_of::<&T>() / mem::size_of::<usize>() - 1\n     }\n \n-    fn push_inner(&mut self, fat_ptr: &T) -> Result<&mut [usize], ()> {\n+\t/// Returns the metadata and data slots\n+    fn push_inner(&mut self, fat_ptr: &T) -> Result<(&mut [usize],&mut [usize]), ()> {\n         let bytes = mem::size_of_val(fat_ptr);\n         let words = super::round_to_words(bytes) + Self::meta_words();\n         // Check if there is sufficient space for the new item\n@@ -71,7 +72,7 @@ impl<T: ?Sized, D: ::DataBuf> StackA<T, D> {\n             meta.clone_from_slice(&ptr_words[1..]);\n \n             // Increment offset and return\n-            Ok(rv)\n+            Ok( (meta, rv) )\n         } else {\n             Err(())\n         }\n@@ -94,7 +95,7 @@ impl<T: ?Sized, D: ::DataBuf> StackA<T, D> {\n         );\n \n         match self.push_inner(f(&v)) {\n-            Ok(d) => {\n+            Ok((_,d)) => {\n                 // SAFE: Destination address is valid\n                 unsafe {\n                     ptr::write(d.as_mut_ptr() as *mut U, v);\n@@ -143,7 +144,7 @@ impl<T: ?Sized, D: ::DataBuf> StackA<T, D> {\n impl<D: ::DataBuf> StackA<str, D> {\n     /// Push the contents of a string slice as an item onto the stack\n     pub fn push_str(&mut self, v: &str) -> Result<(), ()> {\n-        self.push_inner(v).map(|d| unsafe {\n+        self.push_inner(v).map(|(_,d)| unsafe {\n             ptr::copy(v.as_bytes().as_ptr(), d.as_mut_ptr() as *mut u8, v.len());\n         })\n     }\n@@ -151,12 +152,24 @@ impl<D: ::DataBuf> StackA<str, D> {\n impl<D: ::DataBuf, T: Clone> StackA<[T], D> {\n     /// Pushes a set of items (cloning out of the input slice)\n     pub fn push_cloned(&mut self, v: &[T]) -> Result<(), ()> {\n-        self.push_inner(&v).map(|d| unsafe {\n-            let mut ptr = d.as_mut_ptr() as *mut T;\n-            for val in v {\n-                ptr::write(ptr, val.clone());\n-                ptr = ptr.offset(1);\n-            }\n-        })\n+        let (meta,d) = self.push_inner(&v)?;\n+\t\t// Prepare the slot with zeros (as if it's an empty slice)\n+\t\t// The length is updated as each item is written\n+\t\t// - This ensures that there's no drop issues during write\n+\t\tmeta[0] = 0;\n+\t\tfor v in d.iter_mut() {\n+\t\t\t*v = 0;\n+\t\t}\n+\n+\t\tunsafe {\n+\t\t\tlet mut ptr = d.as_mut_ptr() as *mut T;\n+\t\t\tfor val in v {\n+\t\t\t\tptr::write(ptr, val.clone());\n+\t\t\t\tmeta[0] += 1;\n+\t\t\t\tptr = ptr.offset(1);\n+\t\t\t}\n+\t\t}\n+\n+\t\tOk( () )\n     }\n }\n",
    "diff_parsed": "{'added': [(57, '    fn push_inner(&mut self, fat_ptr: &T) -> Result<(&mut [usize],&mut [usize]), ()> {'), (75, '            Ok( (meta, rv) )'), (98, '            Ok((_,d)) => {'), (147, '        self.push_inner(v).map(|(_,d)| unsafe {'), (155, '        let (meta,d) = self.push_inner(&v)?;'), (159, '\\t\\tmeta[0] = 0;'), (160, '\\t\\tfor v in d.iter_mut() {'), (161, '\\t\\t\\t*v = 0;'), (162, '\\t\\t}'), (164, '\\t\\tunsafe {'), (165, '\\t\\t\\tlet mut ptr = d.as_mut_ptr() as *mut T;'), (166, '\\t\\t\\tfor val in v {'), (167, '\\t\\t\\t\\tptr::write(ptr, val.clone());'), (168, '\\t\\t\\t\\tmeta[0] += 1;'), (169, '\\t\\t\\t\\tptr = ptr.offset(1);'), (170, '\\t\\t\\t}'), (171, '\\t\\t}'), (173, '\\t\\tOk( () )')], 'deleted': [(56, '    fn push_inner(&mut self, fat_ptr: &T) -> Result<&mut [usize], ()> {'), (74, '            Ok(rv)'), (97, '            Ok(d) => {'), (146, '        self.push_inner(v).map(|d| unsafe {'), (154, '        self.push_inner(&v).map(|d| unsafe {'), (155, '            let mut ptr = d.as_mut_ptr() as *mut T;'), (156, '            for val in v {'), (157, '                ptr::write(ptr, val.clone());'), (158, '                ptr = ptr.offset(1);'), (159, '            }'), (160, '        })')]}",
    "num_lines_added": "18",
    "num_lines_deleted": "11",
    "nloc": "123"
  },
  {
    "file_change_id": "89010655123192",
    "hash": "2a4d53809e3000f40085f2b229b6b1a33759881d",
    "old_path": "tests/stack.rs",
    "new_path": "tests/stack.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -114,3 +114,34 @@ fn destructors() {\n     drop(stack);\n     assert_eq!(v.get(), 2 + 3);\n }\n+\n+#[test]\n+fn slice_push_panic_safety() {\n+\tuse std::sync::atomic::{AtomicUsize,Ordering};\n+\tstatic COUNT: AtomicUsize = AtomicUsize::new(0);\n+\tstruct Sentinel(bool);\n+\timpl Clone for Sentinel {\n+\t\tfn clone(&self) -> Self {\n+\t\t\tif self.0 {\n+\t\t\t\tpanic!();\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tSentinel(self.0)\n+\t\t\t}\n+\t\t}\n+\t}\n+\timpl Drop for Sentinel {\n+\t\tfn drop(&mut self) {\n+\t\t\tCOUNT.fetch_add(1, Ordering::SeqCst);\n+\t\t}\n+\t}\n+\tlet input = [Sentinel(false), Sentinel(true)];\n+\n+\n+\tlet _ = ::std::panic::catch_unwind(::std::panic::AssertUnwindSafe(|| {\n+\t\tlet mut stack = ::stack_dst::StackA::<[Sentinel], [usize; 8]>::new();\n+\t\tlet _ = stack.push_cloned(&input);\n+\t\t}));\n+\tassert_eq!(COUNT.load(Ordering::SeqCst), 1);\n+}\n+\n",
    "diff_parsed": "{'added': [(118, '#[test]'), (119, 'fn slice_push_panic_safety() {'), (120, '\\tuse std::sync::atomic::{AtomicUsize,Ordering};'), (121, '\\tstatic COUNT: AtomicUsize = AtomicUsize::new(0);'), (122, '\\tstruct Sentinel(bool);'), (123, '\\timpl Clone for Sentinel {'), (124, '\\t\\tfn clone(&self) -> Self {'), (125, '\\t\\t\\tif self.0 {'), (126, '\\t\\t\\t\\tpanic!();'), (127, '\\t\\t\\t}'), (128, '\\t\\t\\telse {'), (129, '\\t\\t\\t\\tSentinel(self.0)'), (130, '\\t\\t\\t}'), (131, '\\t\\t}'), (132, '\\t}'), (133, '\\timpl Drop for Sentinel {'), (134, '\\t\\tfn drop(&mut self) {'), (135, '\\t\\t\\tCOUNT.fetch_add(1, Ordering::SeqCst);'), (136, '\\t\\t}'), (137, '\\t}'), (138, '\\tlet input = [Sentinel(false), Sentinel(true)];'), (141, '\\tlet _ = ::std::panic::catch_unwind(::std::panic::AssertUnwindSafe(|| {'), (142, '\\t\\tlet mut stack = ::stack_dst::StackA::<[Sentinel], [usize; 8]>::new();'), (143, '\\t\\tlet _ = stack.push_cloned(&input);'), (144, '\\t\\t}));'), (145, '\\tassert_eq!(COUNT.load(Ordering::SeqCst), 1);'), (146, '}')], 'deleted': []}",
    "num_lines_added": "27",
    "num_lines_deleted": "0",
    "nloc": "119"
  },
  {
    "file_change_id": "91151474712638",
    "hash": "5ba218ac29df4786b002d7d12b47fa0c04a331f2",
    "old_path": "nanorand/src/gen.rs",
    "new_path": "nanorand/src/gen.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -101,44 +101,44 @@ impl<R: RNG> RandomRange<R> for usize {\n \n impl<R: RNG> RandomGen<R> for u32 {\n \tfn random(r: &mut R) -> Self {\n-\t\t(r.generate::<u64>() >> 32) as u32\n+\t\tr.generate::<u64>() as u32\n \t}\n }\n \n impl<R: RNG> RandomRange<R> for u32 {\n \tfn random_range(r: &mut R, lower: u32, upper: u32) -> Self {\n-\t\t(r.generate_range::<u64>(lower as u64, upper as u64) >> 32) as u32\n+\t\tr.generate_range::<u64>(lower as u64, upper as u64) as u32\n \t}\n }\n \n impl<R: RNG> RandomGen<R> for u16 {\n \tfn random(r: &mut R) -> Self {\n-\t\t(r.generate::<u64>() >> 16) as u16\n+\t\tr.generate::<u64>() as u16\n \t}\n }\n \n impl<R: RNG> RandomRange<R> for u16 {\n \tfn random_range(r: &mut R, lower: u16, upper: u16) -> Self {\n-\t\t(r.generate_range::<u64>(lower as u64, upper as u64) >> 16) as u16\n+\t\tr.generate_range::<u64>(lower as u64, upper as u64) as u16\n \t}\n }\n \n impl<R: RNG> RandomGen<R> for u8 {\n \tfn random(r: &mut R) -> Self {\n-\t\t(r.generate::<u64>() >> 8) as u8\n+\t\tr.generate::<u64>() as u8\n \t}\n }\n \n impl<R: RNG> RandomRange<R> for u8 {\n \tfn random_range(r: &mut R, lower: u8, upper: u8) -> Self {\n-\t\t(r.generate_range::<u64>(lower as u64, upper as u64) >> 8) as u8\n+\t\tr.generate_range::<u64>(lower as u64, upper as u64) as u8\n \t}\n }\n \n impl<R: RNG> RandomRange<R> for char {\n \tfn random_range(r: &mut R, lower: char, upper: char) -> Self {\n \t\tloop {\n-\t\t\tlet ret = (r.generate_range::<u64>(lower as u64, upper as u64) >> 32) as u32;\n+\t\t\tlet ret = r.generate_range::<u64>(lower as u64, upper as u64) as u32;\n \t\t\tif let Some(c) = core::char::from_u32(ret) {\n \t\t\t\tbreak c;\n \t\t\t}\n",
    "diff_parsed": "{'added': [(104, '\\t\\tr.generate::<u64>() as u32'), (110, '\\t\\tr.generate_range::<u64>(lower as u64, upper as u64) as u32'), (116, '\\t\\tr.generate::<u64>() as u16'), (122, '\\t\\tr.generate_range::<u64>(lower as u64, upper as u64) as u16'), (128, '\\t\\tr.generate::<u64>() as u8'), (134, '\\t\\tr.generate_range::<u64>(lower as u64, upper as u64) as u8'), (141, '\\t\\t\\tlet ret = r.generate_range::<u64>(lower as u64, upper as u64) as u32;')], 'deleted': [(104, '\\t\\t(r.generate::<u64>() >> 32) as u32'), (110, '\\t\\t(r.generate_range::<u64>(lower as u64, upper as u64) >> 32) as u32'), (116, '\\t\\t(r.generate::<u64>() >> 16) as u16'), (122, '\\t\\t(r.generate_range::<u64>(lower as u64, upper as u64) >> 16) as u16'), (128, '\\t\\t(r.generate::<u64>() >> 8) as u8'), (134, '\\t\\t(r.generate_range::<u64>(lower as u64, upper as u64) >> 8) as u8'), (141, '\\t\\t\\tlet ret = (r.generate_range::<u64>(lower as u64, upper as u64) >> 32) as u32;')]}",
    "num_lines_added": "7",
    "num_lines_deleted": "7",
    "nloc": "127"
  },
  {
    "file_change_id": "223747141522145",
    "hash": "7fd282aef7787577c385aed88cb25d004b85f494",
    "old_path": "pulse-binding/src/context/ext_device_manager.rs",
    "new_path": "pulse-binding/src/context/ext_device_manager.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -15,6 +15,7 @@\n \n //! Routines for controlling module-device-manager.\n \n+use std;\n use capi;\n use std::ffi::{CStr, CString};\n use std::borrow::Cow;\n@@ -308,13 +309,15 @@ extern \"C\"\n fn read_list_cb_proxy(_: *mut ContextInternal, i: *const InfoInternal, eol: i32,\n     userdata: *mut c_void)\n {\n-    match callback_for_list_instance::<dyn FnMut(ListResult<&Info>)>(eol, userdata) {\n-        ListInstanceCallback::Entry(callback) => {\n-            assert!(!i.is_null());\n-            let obj = Info::new_from_raw(i);\n-            callback(ListResult::Item(&obj));\n-        },\n-        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },\n-        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },\n-    }\n+    let _ = std::panic::catch_unwind(|| {\n+        match callback_for_list_instance::<dyn FnMut(ListResult<&Info>)>(eol, userdata) {\n+            ListInstanceCallback::Entry(callback) => {\n+                assert!(!i.is_null());\n+                let obj = Info::new_from_raw(i);\n+                (callback)(ListResult::Item(&obj));\n+            },\n+            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },\n+            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },\n+        }\n+    });\n }\n",
    "diff_parsed": "{'added': [(18, 'use std;'), (312, '    let _ = std::panic::catch_unwind(|| {'), (313, '        match callback_for_list_instance::<dyn FnMut(ListResult<&Info>)>(eol, userdata) {'), (314, '            ListInstanceCallback::Entry(callback) => {'), (315, '                assert!(!i.is_null());'), (316, '                let obj = Info::new_from_raw(i);'), (317, '                (callback)(ListResult::Item(&obj));'), (318, '            },'), (319, '            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },'), (320, '            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },'), (321, '        }'), (322, '    });')], 'deleted': [(311, '    match callback_for_list_instance::<dyn FnMut(ListResult<&Info>)>(eol, userdata) {'), (312, '        ListInstanceCallback::Entry(callback) => {'), (313, '            assert!(!i.is_null());'), (314, '            let obj = Info::new_from_raw(i);'), (315, '            callback(ListResult::Item(&obj));'), (316, '        },'), (317, '        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },'), (318, '        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },'), (319, '    }')]}",
    "num_lines_added": "12",
    "num_lines_deleted": "9",
    "nloc": "272"
  },
  {
    "file_change_id": "148818967632447",
    "hash": "7fd282aef7787577c385aed88cb25d004b85f494",
    "old_path": "pulse-binding/src/context/ext_device_restore.rs",
    "new_path": "pulse-binding/src/context/ext_device_restore.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -208,8 +208,10 @@ extern \"C\"\n fn ext_subscribe_cb_proxy(_: *mut ContextInternal, type_: ::def::Device, index: u32,\n     userdata: *mut c_void)\n {\n-    let callback = SubscribeCb::get_callback(userdata);\n-    callback(type_, index);\n+    let _ = std::panic::catch_unwind(|| {\n+        let callback = SubscribeCb::get_callback(userdata);\n+        (callback)(type_, index);\n+    });\n }\n \n /// Proxy for read list callbacks.\n@@ -218,13 +220,15 @@ extern \"C\"\n fn read_list_cb_proxy(_: *mut ContextInternal, i: *const InfoInternal, eol: i32,\n     userdata: *mut c_void)\n {\n-    match callback_for_list_instance::<dyn FnMut(ListResult<&Info>)>(eol, userdata) {\n-        ListInstanceCallback::Entry(callback) => {\n-            assert!(!i.is_null());\n-            let obj = Info::new_from_raw(i);\n-            callback(ListResult::Item(&obj));\n-        },\n-        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },\n-        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },\n-    }\n+    let _ = std::panic::catch_unwind(|| {\n+        match callback_for_list_instance::<dyn FnMut(ListResult<&Info>)>(eol, userdata) {\n+            ListInstanceCallback::Entry(callback) => {\n+                assert!(!i.is_null());\n+                let obj = Info::new_from_raw(i);\n+                (callback)(ListResult::Item(&obj));\n+            },\n+            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },\n+            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },\n+        }\n+    });\n }\n",
    "diff_parsed": "{'added': [(211, '    let _ = std::panic::catch_unwind(|| {'), (212, '        let callback = SubscribeCb::get_callback(userdata);'), (213, '        (callback)(type_, index);'), (214, '    });'), (223, '    let _ = std::panic::catch_unwind(|| {'), (224, '        match callback_for_list_instance::<dyn FnMut(ListResult<&Info>)>(eol, userdata) {'), (225, '            ListInstanceCallback::Entry(callback) => {'), (226, '                assert!(!i.is_null());'), (227, '                let obj = Info::new_from_raw(i);'), (228, '                (callback)(ListResult::Item(&obj));'), (229, '            },'), (230, '            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },'), (231, '            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },'), (232, '        }'), (233, '    });')], 'deleted': [(211, '    let callback = SubscribeCb::get_callback(userdata);'), (212, '    callback(type_, index);'), (221, '    match callback_for_list_instance::<dyn FnMut(ListResult<&Info>)>(eol, userdata) {'), (222, '        ListInstanceCallback::Entry(callback) => {'), (223, '            assert!(!i.is_null());'), (224, '            let obj = Info::new_from_raw(i);'), (225, '            callback(ListResult::Item(&obj));'), (226, '        },'), (227, '        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },'), (228, '        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },'), (229, '    }')]}",
    "num_lines_added": "15",
    "num_lines_deleted": "11",
    "nloc": "165"
  },
  {
    "file_change_id": "241217155702035",
    "hash": "7fd282aef7787577c385aed88cb25d004b85f494",
    "old_path": "pulse-binding/src/context/ext_stream_restore.rs",
    "new_path": "pulse-binding/src/context/ext_stream_restore.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -214,13 +214,15 @@ extern \"C\"\n fn read_list_cb_proxy(_: *mut ContextInternal, i: *const InfoInternal, eol: i32,\n     userdata: *mut c_void)\n {\n-    match callback_for_list_instance::<dyn FnMut(ListResult<&Info>)>(eol, userdata) {\n-        ListInstanceCallback::Entry(callback) => {\n-            assert!(!i.is_null());\n-            let obj = Info::new_from_raw(i);\n-            callback(ListResult::Item(&obj));\n-        },\n-        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },\n-        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },\n-    }\n+    let _ = std::panic::catch_unwind(|| {\n+        match callback_for_list_instance::<dyn FnMut(ListResult<&Info>)>(eol, userdata) {\n+            ListInstanceCallback::Entry(callback) => {\n+                assert!(!i.is_null());\n+                let obj = Info::new_from_raw(i);\n+                (callback)(ListResult::Item(&obj));\n+            },\n+            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },\n+            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },\n+        }\n+    });\n }\n",
    "diff_parsed": "{'added': [(217, '    let _ = std::panic::catch_unwind(|| {'), (218, '        match callback_for_list_instance::<dyn FnMut(ListResult<&Info>)>(eol, userdata) {'), (219, '            ListInstanceCallback::Entry(callback) => {'), (220, '                assert!(!i.is_null());'), (221, '                let obj = Info::new_from_raw(i);'), (222, '                (callback)(ListResult::Item(&obj));'), (223, '            },'), (224, '            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },'), (225, '            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },'), (226, '        }'), (227, '    });')], 'deleted': [(217, '    match callback_for_list_instance::<dyn FnMut(ListResult<&Info>)>(eol, userdata) {'), (218, '        ListInstanceCallback::Entry(callback) => {'), (219, '            assert!(!i.is_null());'), (220, '            let obj = Info::new_from_raw(i);'), (221, '            callback(ListResult::Item(&obj));'), (222, '        },'), (223, '        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },'), (224, '        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },'), (225, '    }')]}",
    "num_lines_added": "11",
    "num_lines_deleted": "9",
    "nloc": "188"
  },
  {
    "file_change_id": "7667659349224",
    "hash": "7fd282aef7787577c385aed88cb25d004b85f494",
    "old_path": "pulse-binding/src/context/introspect.rs",
    "new_path": "pulse-binding/src/context/introspect.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -652,15 +652,17 @@ extern \"C\"\n fn get_sink_info_list_cb_proxy(_: *mut ContextInternal, i: *const SinkInfoInternal, eol: i32,\n     userdata: *mut c_void)\n {\n-    match callback_for_list_instance::<dyn FnMut(ListResult<&SinkInfo>)>(eol, userdata) {\n-        ListInstanceCallback::Entry(callback) => {\n-            assert!(!i.is_null());\n-            let obj = SinkInfo::new_from_raw(i);\n-            callback(ListResult::Item(&obj));\n-        },\n-        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },\n-        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },\n-    }\n+    let _ = std::panic::catch_unwind(|| {\n+        match callback_for_list_instance::<dyn FnMut(ListResult<&SinkInfo>)>(eol, userdata) {\n+            ListInstanceCallback::Entry(callback) => {\n+                assert!(!i.is_null());\n+                let obj = SinkInfo::new_from_raw(i);\n+                (callback)(ListResult::Item(&obj));\n+            },\n+            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },\n+            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },\n+        }\n+    });\n }\n \n ////////////////////////////////////////////////////////////////////////////////////////////////////\n@@ -1036,15 +1038,17 @@ extern \"C\"\n fn get_source_info_list_cb_proxy(_: *mut ContextInternal, i: *const SourceInfoInternal, eol: i32,\n     userdata: *mut c_void)\n {\n-    match callback_for_list_instance::<dyn FnMut(ListResult<&SourceInfo>)>(eol, userdata) {\n-        ListInstanceCallback::Entry(callback) => {\n-            assert!(!i.is_null());\n-            let obj = SourceInfo::new_from_raw(i);\n-            callback(ListResult::Item(&obj));\n-        },\n-        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },\n-        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },\n-    }\n+    let _ = std::panic::catch_unwind(|| {\n+        match callback_for_list_instance::<dyn FnMut(ListResult<&SourceInfo>)>(eol, userdata) {\n+            ListInstanceCallback::Entry(callback) => {\n+                assert!(!i.is_null());\n+                let obj = SourceInfo::new_from_raw(i);\n+                (callback)(ListResult::Item(&obj));\n+            },\n+            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },\n+            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },\n+        }\n+    });\n }\n \n ////////////////////////////////////////////////////////////////////////////////////////////////////\n@@ -1136,12 +1140,14 @@ extern \"C\"\n fn get_server_info_cb_proxy(_: *mut ContextInternal, i: *const ServerInfoInternal,\n     userdata: *mut c_void)\n {\n-    assert!(!i.is_null());\n-    let obj = ServerInfo::new_from_raw(i);\n-\n-    // Note, destroys closure callback after use - restoring outer box means it gets dropped\n-    let mut callback = ::callbacks::get_su_callback::<dyn FnMut(&ServerInfo)>(userdata);\n-    callback(&obj);\n+    let _ = std::panic::catch_unwind(|| {\n+        assert!(!i.is_null());\n+        let obj = ServerInfo::new_from_raw(i);\n+\n+        // Note, destroys closure callback after use - restoring outer box means it gets dropped\n+        let mut callback = ::callbacks::get_su_callback::<dyn FnMut(&ServerInfo)>(userdata);\n+        (callback)(&obj);\n+    });\n }\n \n ////////////////////////////////////////////////////////////////////////////////////////////////////\n@@ -1262,24 +1268,28 @@ extern \"C\"\n fn mod_info_list_cb_proxy(_: *mut ContextInternal, i: *const ModuleInfoInternal, eol: i32,\n     userdata: *mut c_void)\n {\n-    match callback_for_list_instance::<dyn FnMut(ListResult<&ModuleInfo>)>(eol, userdata) {\n-        ListInstanceCallback::Entry(callback) => {\n-            assert!(!i.is_null());\n-            let obj = ModuleInfo::new_from_raw(i);\n-            callback(ListResult::Item(&obj));\n-        },\n-        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },\n-        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },\n-    }\n+    let _ = std::panic::catch_unwind(|| {\n+        match callback_for_list_instance::<dyn FnMut(ListResult<&ModuleInfo>)>(eol, userdata) {\n+            ListInstanceCallback::Entry(callback) => {\n+                assert!(!i.is_null());\n+                let obj = ModuleInfo::new_from_raw(i);\n+                (callback)(ListResult::Item(&obj));\n+            },\n+            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },\n+            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },\n+        }\n+    });\n }\n \n /// Proxy for context index callbacks.\n /// Warning: This is for single-use cases only! It destroys the actual closure callback.\n extern \"C\"\n fn context_index_cb_proxy(_: *mut ContextInternal, index: u32, userdata: *mut c_void) {\n-    // Note, destroys closure callback after use - restoring outer box means it gets dropped\n-    let mut callback = ::callbacks::get_su_callback::<dyn FnMut(u32)>(userdata);\n-    callback(index);\n+    let _ = std::panic::catch_unwind(|| {\n+        // Note, destroys closure callback after use - restoring outer box means it gets dropped\n+        let mut callback = ::callbacks::get_su_callback::<dyn FnMut(u32)>(userdata);\n+        (callback)(index);\n+    });\n }\n \n ////////////////////////////////////////////////////////////////////////////////////////////////////\n@@ -1380,15 +1390,17 @@ extern \"C\"\n fn get_client_info_list_cb_proxy(_: *mut ContextInternal, i: *const ClientInfoInternal, eol: i32,\n     userdata: *mut c_void)\n {\n-    match callback_for_list_instance::<dyn FnMut(ListResult<&ClientInfo>)>(eol, userdata) {\n-        ListInstanceCallback::Entry(callback) => {\n-            assert!(!i.is_null());\n-            let obj = ClientInfo::new_from_raw(i);\n-            callback(ListResult::Item(&obj));\n-        },\n-        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },\n-        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },\n-    }\n+    let _ = std::panic::catch_unwind(|| {\n+        match callback_for_list_instance::<dyn FnMut(ListResult<&ClientInfo>)>(eol, userdata) {\n+            ListInstanceCallback::Entry(callback) => {\n+                assert!(!i.is_null());\n+                let obj = ClientInfo::new_from_raw(i);\n+                (callback)(ListResult::Item(&obj));\n+            },\n+            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },\n+            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },\n+        }\n+    });\n }\n \n ////////////////////////////////////////////////////////////////////////////////////////////////////\n@@ -1690,15 +1702,17 @@ extern \"C\"\n fn get_card_info_list_cb_proxy(_: *mut ContextInternal, i: *const CardInfoInternal, eol: i32,\n     userdata: *mut c_void)\n {\n-    match callback_for_list_instance::<dyn FnMut(ListResult<&CardInfo>)>(eol, userdata) {\n-        ListInstanceCallback::Entry(callback) => {\n-            assert!(!i.is_null());\n-            let obj = CardInfo::new_from_raw(i);\n-            callback(ListResult::Item(&obj));\n-        },\n-        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },\n-        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },\n-    }\n+    let _ = std::panic::catch_unwind(|| {\n+        match callback_for_list_instance::<dyn FnMut(ListResult<&CardInfo>)>(eol, userdata) {\n+            ListInstanceCallback::Entry(callback) => {\n+                assert!(!i.is_null());\n+                let obj = CardInfo::new_from_raw(i);\n+                (callback)(ListResult::Item(&obj));\n+            },\n+            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },\n+            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },\n+        }\n+    });\n }\n \n ////////////////////////////////////////////////////////////////////////////////////////////////////\n@@ -1919,15 +1933,17 @@ extern \"C\"\n fn get_sink_input_info_list_cb_proxy(_: *mut ContextInternal, i: *const SinkInputInfoInternal,\n     eol: i32, userdata: *mut c_void)\n {\n-    match callback_for_list_instance::<dyn FnMut(ListResult<&SinkInputInfo>)>(eol, userdata) {\n-        ListInstanceCallback::Entry(callback) => {\n-            assert!(!i.is_null());\n-            let obj = SinkInputInfo::new_from_raw(i);\n-            callback(ListResult::Item(&obj));\n-        },\n-        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },\n-        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },\n-    }\n+    let _ = std::panic::catch_unwind(|| {\n+        match callback_for_list_instance::<dyn FnMut(ListResult<&SinkInputInfo>)>(eol, userdata) {\n+            ListInstanceCallback::Entry(callback) => {\n+                assert!(!i.is_null());\n+                let obj = SinkInputInfo::new_from_raw(i);\n+                (callback)(ListResult::Item(&obj));\n+            },\n+            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },\n+            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },\n+        }\n+    });\n }\n \n ////////////////////////////////////////////////////////////////////////////////////////////////////\n@@ -2148,15 +2164,17 @@ extern \"C\"\n fn get_source_output_info_list_cb_proxy(_: *mut ContextInternal, i: *const SourceOutputInfoInternal,\n     eol: i32, userdata: *mut c_void)\n {\n-    match callback_for_list_instance::<dyn FnMut(ListResult<&SourceOutputInfo>)>(eol, userdata) {\n-        ListInstanceCallback::Entry(callback) => {\n-            assert!(!i.is_null());\n-            let obj = SourceOutputInfo::new_from_raw(i);\n-            callback(ListResult::Item(&obj));\n-        },\n-        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },\n-        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },\n-    }\n+    let _ = std::panic::catch_unwind(|| {\n+        match callback_for_list_instance::<dyn FnMut(ListResult<&SourceOutputInfo>)>(eol, userdata) {\n+            ListInstanceCallback::Entry(callback) => {\n+                assert!(!i.is_null());\n+                let obj = SourceOutputInfo::new_from_raw(i);\n+                (callback)(ListResult::Item(&obj));\n+            },\n+            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },\n+            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },\n+        }\n+    });\n }\n \n ////////////////////////////////////////////////////////////////////////////////////////////////////\n@@ -2182,10 +2200,12 @@ impl Introspector {\n /// Warning: This is for single-use cases only! It destroys the actual closure callback.\n extern \"C\"\n fn get_stat_info_cb_proxy(_: *mut ContextInternal, i: *const StatInfo, userdata: *mut c_void) {\n-    assert!(!i.is_null());\n-    // Note, destroys closure callback after use - restoring outer box means it gets dropped\n-    let mut callback = ::callbacks::get_su_callback::<dyn FnMut(&StatInfo)>(userdata);\n-    callback(unsafe { i.as_ref().unwrap() });\n+    let _ = std::panic::catch_unwind(|| {\n+        assert!(!i.is_null());\n+        // Note, destroys closure callback after use - restoring outer box means it gets dropped\n+        let mut callback = ::callbacks::get_su_callback::<dyn FnMut(&StatInfo)>(userdata);\n+        (callback)(unsafe { i.as_ref().unwrap() });\n+    });\n }\n \n ////////////////////////////////////////////////////////////////////////////////////////////////////\n@@ -2301,13 +2321,15 @@ extern \"C\"\n fn get_sample_info_list_cb_proxy(_: *mut ContextInternal, i: *const SampleInfoInternal, eol: i32,\n     userdata: *mut c_void)\n {\n-    match callback_for_list_instance::<dyn FnMut(ListResult<&SampleInfo>)>(eol, userdata) {\n-        ListInstanceCallback::Entry(callback) => {\n-            assert!(!i.is_null());\n-            let obj = SampleInfo::new_from_raw(i);\n-            callback(ListResult::Item(&obj));\n-        },\n-        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },\n-        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },\n-    }\n+    let _ = std::panic::catch_unwind(|| {\n+        match callback_for_list_instance::<dyn FnMut(ListResult<&SampleInfo>)>(eol, userdata) {\n+            ListInstanceCallback::Entry(callback) => {\n+                assert!(!i.is_null());\n+                let obj = SampleInfo::new_from_raw(i);\n+                (callback)(ListResult::Item(&obj));\n+            },\n+            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },\n+            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },\n+        }\n+    });\n }\n",
    "diff_parsed": "{'added': [(655, '    let _ = std::panic::catch_unwind(|| {'), (656, '        match callback_for_list_instance::<dyn FnMut(ListResult<&SinkInfo>)>(eol, userdata) {'), (657, '            ListInstanceCallback::Entry(callback) => {'), (658, '                assert!(!i.is_null());'), (659, '                let obj = SinkInfo::new_from_raw(i);'), (660, '                (callback)(ListResult::Item(&obj));'), (661, '            },'), (662, '            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },'), (663, '            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },'), (664, '        }'), (665, '    });'), (1041, '    let _ = std::panic::catch_unwind(|| {'), (1042, '        match callback_for_list_instance::<dyn FnMut(ListResult<&SourceInfo>)>(eol, userdata) {'), (1043, '            ListInstanceCallback::Entry(callback) => {'), (1044, '                assert!(!i.is_null());'), (1045, '                let obj = SourceInfo::new_from_raw(i);'), (1046, '                (callback)(ListResult::Item(&obj));'), (1047, '            },'), (1048, '            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },'), (1049, '            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },'), (1050, '        }'), (1051, '    });'), (1143, '    let _ = std::panic::catch_unwind(|| {'), (1144, '        assert!(!i.is_null());'), (1145, '        let obj = ServerInfo::new_from_raw(i);'), (1148, '        let mut callback = ::callbacks::get_su_callback::<dyn FnMut(&ServerInfo)>(userdata);'), (1149, '        (callback)(&obj);'), (1150, '    });'), (1271, '    let _ = std::panic::catch_unwind(|| {'), (1272, '        match callback_for_list_instance::<dyn FnMut(ListResult<&ModuleInfo>)>(eol, userdata) {'), (1273, '            ListInstanceCallback::Entry(callback) => {'), (1274, '                assert!(!i.is_null());'), (1275, '                let obj = ModuleInfo::new_from_raw(i);'), (1276, '                (callback)(ListResult::Item(&obj));'), (1277, '            },'), (1278, '            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },'), (1279, '            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },'), (1280, '        }'), (1281, '    });'), (1288, '    let _ = std::panic::catch_unwind(|| {'), (1290, '        let mut callback = ::callbacks::get_su_callback::<dyn FnMut(u32)>(userdata);'), (1291, '        (callback)(index);'), (1292, '    });'), (1393, '    let _ = std::panic::catch_unwind(|| {'), (1394, '        match callback_for_list_instance::<dyn FnMut(ListResult<&ClientInfo>)>(eol, userdata) {'), (1395, '            ListInstanceCallback::Entry(callback) => {'), (1396, '                assert!(!i.is_null());'), (1397, '                let obj = ClientInfo::new_from_raw(i);'), (1398, '                (callback)(ListResult::Item(&obj));'), (1399, '            },'), (1400, '            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },'), (1401, '            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },'), (1402, '        }'), (1403, '    });'), (1705, '    let _ = std::panic::catch_unwind(|| {'), (1706, '        match callback_for_list_instance::<dyn FnMut(ListResult<&CardInfo>)>(eol, userdata) {'), (1707, '            ListInstanceCallback::Entry(callback) => {'), (1708, '                assert!(!i.is_null());'), (1709, '                let obj = CardInfo::new_from_raw(i);'), (1710, '                (callback)(ListResult::Item(&obj));'), (1711, '            },'), (1712, '            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },'), (1713, '            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },'), (1714, '        }'), (1715, '    });'), (1936, '    let _ = std::panic::catch_unwind(|| {'), (1937, '        match callback_for_list_instance::<dyn FnMut(ListResult<&SinkInputInfo>)>(eol, userdata) {'), (1938, '            ListInstanceCallback::Entry(callback) => {'), (1939, '                assert!(!i.is_null());'), (1940, '                let obj = SinkInputInfo::new_from_raw(i);'), (1941, '                (callback)(ListResult::Item(&obj));'), (1942, '            },'), (1943, '            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },'), (1944, '            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },'), (1945, '        }'), (1946, '    });'), (2167, '    let _ = std::panic::catch_unwind(|| {'), (2168, '        match callback_for_list_instance::<dyn FnMut(ListResult<&SourceOutputInfo>)>(eol, userdata) {'), (2169, '            ListInstanceCallback::Entry(callback) => {'), (2170, '                assert!(!i.is_null());'), (2171, '                let obj = SourceOutputInfo::new_from_raw(i);'), (2172, '                (callback)(ListResult::Item(&obj));'), (2173, '            },'), (2174, '            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },'), (2175, '            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },'), (2176, '        }'), (2177, '    });'), (2203, '    let _ = std::panic::catch_unwind(|| {'), (2204, '        assert!(!i.is_null());'), (2206, '        let mut callback = ::callbacks::get_su_callback::<dyn FnMut(&StatInfo)>(userdata);'), (2207, '        (callback)(unsafe { i.as_ref().unwrap() });'), (2208, '    });'), (2324, '    let _ = std::panic::catch_unwind(|| {'), (2325, '        match callback_for_list_instance::<dyn FnMut(ListResult<&SampleInfo>)>(eol, userdata) {'), (2326, '            ListInstanceCallback::Entry(callback) => {'), (2327, '                assert!(!i.is_null());'), (2328, '                let obj = SampleInfo::new_from_raw(i);'), (2329, '                (callback)(ListResult::Item(&obj));'), (2330, '            },'), (2331, '            ListInstanceCallback::End(mut callback) => { (callback)(ListResult::End); },'), (2332, '            ListInstanceCallback::Error(mut callback) => { (callback)(ListResult::Error); },'), (2333, '        }'), (2334, '    });')], 'deleted': [(655, '    match callback_for_list_instance::<dyn FnMut(ListResult<&SinkInfo>)>(eol, userdata) {'), (656, '        ListInstanceCallback::Entry(callback) => {'), (657, '            assert!(!i.is_null());'), (658, '            let obj = SinkInfo::new_from_raw(i);'), (659, '            callback(ListResult::Item(&obj));'), (660, '        },'), (661, '        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },'), (662, '        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },'), (663, '    }'), (1039, '    match callback_for_list_instance::<dyn FnMut(ListResult<&SourceInfo>)>(eol, userdata) {'), (1040, '        ListInstanceCallback::Entry(callback) => {'), (1041, '            assert!(!i.is_null());'), (1042, '            let obj = SourceInfo::new_from_raw(i);'), (1043, '            callback(ListResult::Item(&obj));'), (1044, '        },'), (1045, '        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },'), (1046, '        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },'), (1047, '    }'), (1139, '    assert!(!i.is_null());'), (1140, '    let obj = ServerInfo::new_from_raw(i);'), (1143, '    let mut callback = ::callbacks::get_su_callback::<dyn FnMut(&ServerInfo)>(userdata);'), (1144, '    callback(&obj);'), (1265, '    match callback_for_list_instance::<dyn FnMut(ListResult<&ModuleInfo>)>(eol, userdata) {'), (1266, '        ListInstanceCallback::Entry(callback) => {'), (1267, '            assert!(!i.is_null());'), (1268, '            let obj = ModuleInfo::new_from_raw(i);'), (1269, '            callback(ListResult::Item(&obj));'), (1270, '        },'), (1271, '        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },'), (1272, '        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },'), (1273, '    }'), (1281, '    let mut callback = ::callbacks::get_su_callback::<dyn FnMut(u32)>(userdata);'), (1282, '    callback(index);'), (1383, '    match callback_for_list_instance::<dyn FnMut(ListResult<&ClientInfo>)>(eol, userdata) {'), (1384, '        ListInstanceCallback::Entry(callback) => {'), (1385, '            assert!(!i.is_null());'), (1386, '            let obj = ClientInfo::new_from_raw(i);'), (1387, '            callback(ListResult::Item(&obj));'), (1388, '        },'), (1389, '        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },'), (1390, '        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },'), (1391, '    }'), (1693, '    match callback_for_list_instance::<dyn FnMut(ListResult<&CardInfo>)>(eol, userdata) {'), (1694, '        ListInstanceCallback::Entry(callback) => {'), (1695, '            assert!(!i.is_null());'), (1696, '            let obj = CardInfo::new_from_raw(i);'), (1697, '            callback(ListResult::Item(&obj));'), (1698, '        },'), (1699, '        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },'), (1700, '        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },'), (1701, '    }'), (1922, '    match callback_for_list_instance::<dyn FnMut(ListResult<&SinkInputInfo>)>(eol, userdata) {'), (1923, '        ListInstanceCallback::Entry(callback) => {'), (1924, '            assert!(!i.is_null());'), (1925, '            let obj = SinkInputInfo::new_from_raw(i);'), (1926, '            callback(ListResult::Item(&obj));'), (1927, '        },'), (1928, '        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },'), (1929, '        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },'), (1930, '    }'), (2151, '    match callback_for_list_instance::<dyn FnMut(ListResult<&SourceOutputInfo>)>(eol, userdata) {'), (2152, '        ListInstanceCallback::Entry(callback) => {'), (2153, '            assert!(!i.is_null());'), (2154, '            let obj = SourceOutputInfo::new_from_raw(i);'), (2155, '            callback(ListResult::Item(&obj));'), (2156, '        },'), (2157, '        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },'), (2158, '        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },'), (2159, '    }'), (2185, '    assert!(!i.is_null());'), (2187, '    let mut callback = ::callbacks::get_su_callback::<dyn FnMut(&StatInfo)>(userdata);'), (2188, '    callback(unsafe { i.as_ref().unwrap() });'), (2304, '    match callback_for_list_instance::<dyn FnMut(ListResult<&SampleInfo>)>(eol, userdata) {'), (2305, '        ListInstanceCallback::Entry(callback) => {'), (2306, '            assert!(!i.is_null());'), (2307, '            let obj = SampleInfo::new_from_raw(i);'), (2308, '            callback(ListResult::Item(&obj));'), (2309, '        },'), (2310, '        ListInstanceCallback::End(mut callback) => { callback(ListResult::End); },'), (2311, '        ListInstanceCallback::Error(mut callback) => { callback(ListResult::Error); },'), (2312, '    }')]}",
    "num_lines_added": "103",
    "num_lines_deleted": "81",
    "nloc": "1761"
  },
  {
    "file_change_id": "18943146059729",
    "hash": "7fd282aef7787577c385aed88cb25d004b85f494",
    "old_path": "pulse-binding/src/context/mod.rs",
    "new_path": "pulse-binding/src/context/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -599,21 +599,25 @@ impl Drop for Context {\n /// Warning: This is for single-use cases only! It destroys the actual closure callback.\n extern \"C\"\n fn success_cb_proxy(_: *mut ContextInternal, success: i32, userdata: *mut c_void) {\n-    assert!(!userdata.is_null());\n-    // Note, destroys closure callback after use - restoring outer box means it gets dropped\n-    let mut callback = unsafe { Box::from_raw(userdata as *mut Box<dyn FnMut(bool)>) };\n     let success_actual = match success { 0 => false, _ => true };\n-    callback(success_actual);\n+    let _ = std::panic::catch_unwind(|| {\n+        assert!(!userdata.is_null());\n+        // Note, destroys closure callback after use - restoring outer box means it gets dropped\n+        let mut callback = unsafe { Box::from_raw(userdata as *mut Box<dyn FnMut(bool)>) };\n+        (callback)(success_actual);\n+    });\n }\n \n /// Proxy for notification callbacks (single use).\n /// Warning: This is for single-use cases only! It destroys the actual closure callback.\n extern \"C\"\n fn notify_cb_proxy_single(_: *mut ContextInternal, userdata: *mut c_void) {\n-    assert!(!userdata.is_null());\n-    // Note, destroys closure callback after use - restoring outer box means it gets dropped\n-    let mut callback = unsafe { Box::from_raw(userdata as *mut Box<dyn FnMut()>) };\n-    callback();\n+    let _ = std::panic::catch_unwind(|| {\n+        assert!(!userdata.is_null());\n+        // Note, destroys closure callback after use - restoring outer box means it gets dropped\n+        let mut callback = unsafe { Box::from_raw(userdata as *mut Box<dyn FnMut()>) };\n+        (callback)();\n+    });\n }\n \n /// Proxy for notification callbacks (multi use).\n@@ -621,8 +625,10 @@ fn notify_cb_proxy_single(_: *mut ContextInternal, userdata: *mut c_void) {\n /// must be accomplished separately to avoid a memory leak.\n extern \"C\"\n fn notify_cb_proxy_multi(_: *mut ContextInternal, userdata: *mut c_void) {\n-    let callback = NotifyCb::get_callback(userdata);\n-    callback();\n+    let _ = std::panic::catch_unwind(|| {\n+        let callback = NotifyCb::get_callback(userdata);\n+        (callback)();\n+    });\n }\n \n /// Proxy for event callbacks.\n@@ -632,24 +638,28 @@ extern \"C\"\n fn event_cb_proxy(_: *mut ContextInternal, name: *const c_char,\n     proplist: *mut ::proplist::ProplistInternal, userdata: *mut c_void)\n {\n-    assert!(!name.is_null());\n-    let n = {\n-        let tmp = unsafe { CStr::from_ptr(name) };\n-        tmp.to_string_lossy().into_owned()\n-    };\n-    let pl = Proplist::from_raw_weak(proplist);\n-\n-    let callback = EventCb::get_callback(userdata);\n-    callback(n, pl);\n+    let _ = std::panic::catch_unwind(|| {\n+        assert!(!name.is_null());\n+        let n = {\n+            let tmp = unsafe { CStr::from_ptr(name) };\n+            tmp.to_string_lossy().into_owned()\n+        };\n+        let pl = Proplist::from_raw_weak(proplist);\n+\n+        let callback = EventCb::get_callback(userdata);\n+        (callback)(n, pl);\n+    });\n }\n \n /// Proxy for extension test callbacks.\n /// Warning: This is for single-use cases only! It destroys the actual closure callback.\n extern \"C\"\n fn ext_test_cb_proxy(_: *mut ContextInternal, version: u32, userdata: *mut c_void) {\n-    // Note, destroys closure callback after use - restoring outer box means it gets dropped\n-    let mut callback = ::callbacks::get_su_callback::<dyn FnMut(u32)>(userdata);\n-    callback(version);\n+    let _ = std::panic::catch_unwind(|| {\n+        // Note, destroys closure callback after use - restoring outer box means it gets dropped\n+        let mut callback = ::callbacks::get_su_callback::<dyn FnMut(u32)>(userdata);\n+        (callback)(version);\n+    });\n }\n \n /// Proxy for extension subscribe callbacks.\n@@ -657,6 +667,8 @@ fn ext_test_cb_proxy(_: *mut ContextInternal, version: u32, userdata: *mut c_voi\n /// must be accomplished separately to avoid a memory leak.\n extern \"C\"\n fn ext_subscribe_cb_proxy(_: *mut ContextInternal, userdata: *mut c_void) {\n-    let callback = ExtSubscribeCb::get_callback(userdata);\n-    callback();\n+    let _ = std::panic::catch_unwind(|| {\n+        let callback = ExtSubscribeCb::get_callback(userdata);\n+        (callback)();\n+    });\n }\n",
    "diff_parsed": "{'added': [(603, '    let _ = std::panic::catch_unwind(|| {'), (604, '        assert!(!userdata.is_null());'), (606, '        let mut callback = unsafe { Box::from_raw(userdata as *mut Box<dyn FnMut(bool)>) };'), (607, '        (callback)(success_actual);'), (608, '    });'), (615, '    let _ = std::panic::catch_unwind(|| {'), (616, '        assert!(!userdata.is_null());'), (618, '        let mut callback = unsafe { Box::from_raw(userdata as *mut Box<dyn FnMut()>) };'), (619, '        (callback)();'), (620, '    });'), (628, '    let _ = std::panic::catch_unwind(|| {'), (629, '        let callback = NotifyCb::get_callback(userdata);'), (630, '        (callback)();'), (631, '    });'), (641, '    let _ = std::panic::catch_unwind(|| {'), (642, '        assert!(!name.is_null());'), (643, '        let n = {'), (644, '            let tmp = unsafe { CStr::from_ptr(name) };'), (645, '            tmp.to_string_lossy().into_owned()'), (646, '        };'), (647, '        let pl = Proplist::from_raw_weak(proplist);'), (649, '        let callback = EventCb::get_callback(userdata);'), (650, '        (callback)(n, pl);'), (651, '    });'), (658, '    let _ = std::panic::catch_unwind(|| {'), (660, '        let mut callback = ::callbacks::get_su_callback::<dyn FnMut(u32)>(userdata);'), (661, '        (callback)(version);'), (662, '    });'), (670, '    let _ = std::panic::catch_unwind(|| {'), (671, '        let callback = ExtSubscribeCb::get_callback(userdata);'), (672, '        (callback)();'), (673, '    });')], 'deleted': [(602, '    assert!(!userdata.is_null());'), (604, '    let mut callback = unsafe { Box::from_raw(userdata as *mut Box<dyn FnMut(bool)>) };'), (606, '    callback(success_actual);'), (613, '    assert!(!userdata.is_null());'), (615, '    let mut callback = unsafe { Box::from_raw(userdata as *mut Box<dyn FnMut()>) };'), (616, '    callback();'), (624, '    let callback = NotifyCb::get_callback(userdata);'), (625, '    callback();'), (635, '    assert!(!name.is_null());'), (636, '    let n = {'), (637, '        let tmp = unsafe { CStr::from_ptr(name) };'), (638, '        tmp.to_string_lossy().into_owned()'), (639, '    };'), (640, '    let pl = Proplist::from_raw_weak(proplist);'), (642, '    let callback = EventCb::get_callback(userdata);'), (643, '    callback(n, pl);'), (651, '    let mut callback = ::callbacks::get_su_callback::<dyn FnMut(u32)>(userdata);'), (652, '    callback(version);'), (660, '    let callback = ExtSubscribeCb::get_callback(userdata);'), (661, '    callback();')]}",
    "num_lines_added": "32",
    "num_lines_deleted": "20",
    "nloc": "434"
  },
  {
    "file_change_id": "241838442820553",
    "hash": "7fd282aef7787577c385aed88cb25d004b85f494",
    "old_path": "pulse-binding/src/context/scache.rs",
    "new_path": "pulse-binding/src/context/scache.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -62,6 +62,7 @@\n //! [`::context::Context::play_sample`]: ../struct.Context.html#method.play_sample\n //! [`::context::Context::remove_sample`]: ../struct.Context.html#method.remove_sample\n \n+use std;\n use capi;\n use std::os::raw::{c_char, c_void};\n use std::ffi::CString;\n@@ -187,8 +188,9 @@ impl Context {\n extern \"C\"\n fn play_sample_success_cb_proxy(_: *mut ContextInternal, index: u32, userdata: *mut c_void) {\n     let index_actual = match index { ::def::INVALID_INDEX => Err(()), i => Ok(i) };\n-\n-    // Note, destroys closure callback after use - restoring outer box means it gets dropped\n-    let mut callback = ::callbacks::get_su_callback::<dyn FnMut(Result<u32, ()>)>(userdata);\n-    callback(index_actual);\n+    let _ = std::panic::catch_unwind(|| {\n+        // Note, destroys closure callback after use - restoring outer box means it gets dropped\n+        let mut callback = ::callbacks::get_su_callback::<dyn FnMut(Result<u32, ()>)>(userdata);\n+        (callback)(index_actual);\n+    });\n }\n",
    "diff_parsed": "{'added': [(65, 'use std;'), (191, '    let _ = std::panic::catch_unwind(|| {'), (193, '        let mut callback = ::callbacks::get_su_callback::<dyn FnMut(Result<u32, ()>)>(userdata);'), (194, '        (callback)(index_actual);'), (195, '    });')], 'deleted': [(192, '    let mut callback = ::callbacks::get_su_callback::<dyn FnMut(Result<u32, ()>)>(userdata);'), (193, '    callback(index_actual);')]}",
    "num_lines_added": "5",
    "num_lines_deleted": "2",
    "nloc": "90"
  },
  {
    "file_change_id": "37052716799324",
    "hash": "7fd282aef7787577c385aed88cb25d004b85f494",
    "old_path": "pulse-binding/src/context/subscribe.rs",
    "new_path": "pulse-binding/src/context/subscribe.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -56,6 +56,7 @@\n //! [`::context::Context::set_subscribe_callback`]: ../struct.Context.html#method.set_subscribe_callback\n //! [`subscription_masks`]: subscription_masks/index.html\n \n+use std;\n use capi;\n use std::os::raw::c_void;\n use super::{ContextInternal, Context};\n@@ -211,8 +212,10 @@ impl Context {\n /// must be accomplished separately to avoid a memory leak.\n extern \"C\"\n fn cb_proxy(_: *mut ContextInternal, et: EventType, index: u32, userdata: *mut c_void) {\n-    let facility = get_facility(et);\n-    let operation = get_operation(et);\n-    let callback = Callback::get_callback(userdata);\n-    callback(facility, operation, index);\n+    let _ = std::panic::catch_unwind(|| {\n+        let facility = get_facility(et);\n+        let operation = get_operation(et);\n+        let callback = Callback::get_callback(userdata);\n+        (callback)(facility, operation, index);\n+    });\n }\n",
    "diff_parsed": "{'added': [(59, 'use std;'), (215, '    let _ = std::panic::catch_unwind(|| {'), (216, '        let facility = get_facility(et);'), (217, '        let operation = get_operation(et);'), (218, '        let callback = Callback::get_callback(userdata);'), (219, '        (callback)(facility, operation, index);'), (220, '    });')], 'deleted': [(214, '    let facility = get_facility(et);'), (215, '    let operation = get_operation(et);'), (216, '    let callback = Callback::get_callback(userdata);'), (217, '    callback(facility, operation, index);')]}",
    "num_lines_added": "7",
    "num_lines_deleted": "4",
    "nloc": "122"
  },
  {
    "file_change_id": "179680611671943",
    "hash": "7fd282aef7787577c385aed88cb25d004b85f494",
    "old_path": "pulse-binding/src/mainloop/api.rs",
    "new_path": "pulse-binding/src/mainloop/api.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -378,7 +378,9 @@ impl<'a> From<&'a MainloopApi> for *const ApiInternal {\n /// Warning: This is for single-use cases only! It destroys the actual closure callback.\n extern \"C\"\n fn once_cb_proxy(_: *const ApiInternal, userdata: *mut c_void) {\n-    // Note, destroys closure callback after use - restoring outer box means it gets dropped\n-    let mut callback = ::callbacks::get_su_callback::<dyn FnMut()>(userdata);\n-    callback();\n+    let _ = std::panic::catch_unwind(|| {\n+        // Note, destroys closure callback after use - restoring outer box means it gets dropped\n+        let mut callback = ::callbacks::get_su_callback::<dyn FnMut()>(userdata);\n+        (callback)();\n+    });\n }\n",
    "diff_parsed": "{'added': [(381, '    let _ = std::panic::catch_unwind(|| {'), (383, '        let mut callback = ::callbacks::get_su_callback::<dyn FnMut()>(userdata);'), (384, '        (callback)();'), (385, '    });')], 'deleted': [(382, '    let mut callback = ::callbacks::get_su_callback::<dyn FnMut()>(userdata);'), (383, '    callback();')]}",
    "num_lines_added": "4",
    "num_lines_deleted": "2",
    "nloc": "273"
  },
  {
    "file_change_id": "275801026587540",
    "hash": "7fd282aef7787577c385aed88cb25d004b85f494",
    "old_path": "pulse-binding/src/mainloop/events/deferred.rs",
    "new_path": "pulse-binding/src/mainloop/events/deferred.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -15,6 +15,7 @@\n \n //! Main loop deferred events.\n \n+use std;\n use std::os::raw::c_void;\n use std::rc::Rc;\n use super::super::api::{MainloopApi, MainloopInnerType};\n@@ -104,6 +105,8 @@ impl<T> Drop for DeferEvent<T>\n pub(crate)\n extern \"C\"\n fn event_cb_proxy(_: *const MainloopApi, e: *mut DeferEventInternal, userdata: *mut c_void) {\n-    let callback = EventCb::get_callback(userdata);\n-    callback(e);\n+    let _ = std::panic::catch_unwind(|| {\n+        let callback = EventCb::get_callback(userdata);\n+        (callback)(e);\n+    });\n }\n",
    "diff_parsed": "{'added': [(18, 'use std;'), (108, '    let _ = std::panic::catch_unwind(|| {'), (109, '        let callback = EventCb::get_callback(userdata);'), (110, '        (callback)(e);'), (111, '    });')], 'deleted': [(107, '    let callback = EventCb::get_callback(userdata);'), (108, '    callback(e);')]}",
    "num_lines_added": "5",
    "num_lines_deleted": "2",
    "nloc": "70"
  },
  {
    "file_change_id": "37618262102694",
    "hash": "7fd282aef7787577c385aed88cb25d004b85f494",
    "old_path": "pulse-binding/src/mainloop/events/io.rs",
    "new_path": "pulse-binding/src/mainloop/events/io.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -15,6 +15,7 @@\n \n //! Main loop IO events.\n \n+use std;\n use capi;\n use std::os::raw::c_void;\n use std::rc::Rc;\n@@ -116,6 +117,8 @@ extern \"C\"\n fn event_cb_proxy(_: *const MainloopApi, e: *mut IoEventInternal, fd: i32, events: IoEventFlagSet,\n     userdata: *mut c_void)\n {\n-    let callback = EventCb::get_callback(userdata);\n-    callback(e, fd, events);\n+    let _ = std::panic::catch_unwind(|| {\n+        let callback = EventCb::get_callback(userdata);\n+        (callback)(e, fd, events);\n+    });\n }\n",
    "diff_parsed": "{'added': [(18, 'use std;'), (120, '    let _ = std::panic::catch_unwind(|| {'), (121, '        let callback = EventCb::get_callback(userdata);'), (122, '        (callback)(e, fd, events);'), (123, '    });')], 'deleted': [(119, '    let callback = EventCb::get_callback(userdata);'), (120, '    callback(e, fd, events);')]}",
    "num_lines_added": "5",
    "num_lines_deleted": "2",
    "nloc": "77"
  },
  {
    "file_change_id": "98535657875462",
    "hash": "7fd282aef7787577c385aed88cb25d004b85f494",
    "old_path": "pulse-binding/src/mainloop/events/timer.rs",
    "new_path": "pulse-binding/src/mainloop/events/timer.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -24,6 +24,7 @@\n //! Note that time events created with one form of time value can be freely restarted with the other\n //! form of time value.\n \n+use std;\n use std::os::raw::c_void;\n use std::rc::Rc;\n use libc::timeval;\n@@ -130,6 +131,8 @@ extern \"C\"\n fn event_cb_proxy(_: *const MainloopApi, e: *mut TimeEventInternal, _: *const timeval,\n     userdata: *mut c_void)\n {\n-    let callback = EventCb::get_callback(userdata);\n-    callback(e);\n+    let _ = std::panic::catch_unwind(|| {\n+        let callback = EventCb::get_callback(userdata);\n+        (callback)(e);\n+    });\n }\n",
    "diff_parsed": "{'added': [(27, 'use std;'), (134, '    let _ = std::panic::catch_unwind(|| {'), (135, '        let callback = EventCb::get_callback(userdata);'), (136, '        (callback)(e);'), (137, '    });')], 'deleted': [(133, '    let callback = EventCb::get_callback(userdata);'), (134, '    callback(e);')]}",
    "num_lines_added": "5",
    "num_lines_deleted": "2",
    "nloc": "81"
  },
  {
    "file_change_id": "272259460806206",
    "hash": "7fd282aef7787577c385aed88cb25d004b85f494",
    "old_path": "pulse-binding/src/mainloop/signal.rs",
    "new_path": "pulse-binding/src/mainloop/signal.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -23,6 +23,7 @@\n //! support for UNIX signals. However, you may hook signal support into an abstract main loop via\n //! the routines defined herein.\n \n+use std;\n use capi;\n use std::os::raw::c_void;\n use std::ptr::null_mut;\n@@ -89,6 +90,8 @@ extern \"C\"\n fn signal_cb_proxy(_api: *const ApiInternal, _e: *mut EventInternal, sig: i32,\n     userdata: *mut c_void)\n {\n-    let callback = SignalCb::get_callback(userdata);\n-    callback(sig);\n+    let _ = std::panic::catch_unwind(|| {\n+        let callback = SignalCb::get_callback(userdata);\n+        (callback)(sig);\n+    });\n }\n",
    "diff_parsed": "{'added': [(26, 'use std;'), (93, '    let _ = std::panic::catch_unwind(|| {'), (94, '        let callback = SignalCb::get_callback(userdata);'), (95, '        (callback)(sig);'), (96, '    });')], 'deleted': [(92, '    let callback = SignalCb::get_callback(userdata);'), (93, '    callback(sig);')]}",
    "num_lines_added": "5",
    "num_lines_deleted": "2",
    "nloc": "51"
  },
  {
    "file_change_id": "147002340763242",
    "hash": "7fd282aef7787577c385aed88cb25d004b85f494",
    "old_path": "pulse-binding/src/operation.rs",
    "new_path": "pulse-binding/src/operation.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -15,6 +15,7 @@\n \n //! Asynchronous operations.\n \n+use std;\n use capi;\n use std::os::raw::c_void;\n use std::ptr::null_mut;\n@@ -115,6 +116,8 @@ impl<ClosureProto: ?Sized> Drop for Operation<ClosureProto> {\n /// must be accomplished separately to avoid a memory leak.\n extern \"C\"\n fn notify_cb_proxy(_: *mut OperationInternal, userdata: *mut c_void) {\n-    let callback = NotifyCb::get_callback(userdata);\n-    callback();\n+    let _ = std::panic::catch_unwind(|| {\n+        let callback = NotifyCb::get_callback(userdata);\n+        (callback)();\n+    });\n }\n",
    "diff_parsed": "{'added': [(18, 'use std;'), (119, '    let _ = std::panic::catch_unwind(|| {'), (120, '        let callback = NotifyCb::get_callback(userdata);'), (121, '        (callback)();'), (122, '    });')], 'deleted': [(118, '    let callback = NotifyCb::get_callback(userdata);'), (119, '    callback();')]}",
    "num_lines_added": "5",
    "num_lines_deleted": "2",
    "nloc": "58"
  },
  {
    "file_change_id": "206465864631268",
    "hash": "7fd282aef7787577c385aed88cb25d004b85f494",
    "old_path": "pulse-binding/src/stream.rs",
    "new_path": "pulse-binding/src/stream.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1663,10 +1663,12 @@ impl Drop for Stream {\n /// Warning: This is for single-use cases only! It destroys the actual closure callback.\n extern \"C\"\n fn success_cb_proxy(_: *mut StreamInternal, success: i32, userdata: *mut c_void) {\n-    // Note, destroys closure callback after use - restoring outer box means it gets dropped\n-    let mut callback = ::callbacks::get_su_callback::<dyn FnMut(bool)>(userdata);\n     let success_actual = match success { 0 => false, _ => true };\n-    callback(success_actual);\n+    let _ = std::panic::catch_unwind(|| {\n+        // Note, destroys closure callback after use - restoring outer box means it gets dropped\n+        let mut callback = ::callbacks::get_su_callback::<dyn FnMut(bool)>(userdata);\n+        (callback)(success_actual);\n+    });\n }\n \n /// Proxy for request callbacks.\n@@ -1674,8 +1676,10 @@ fn success_cb_proxy(_: *mut StreamInternal, success: i32, userdata: *mut c_void)\n /// must be accomplished separately to avoid a memory leak.\n extern \"C\"\n fn request_cb_proxy(_: *mut StreamInternal, nbytes: usize, userdata: *mut c_void) {\n-    let callback = RequestCb::get_callback(userdata);\n-    callback(nbytes);\n+    let _ = std::panic::catch_unwind(|| {\n+        let callback = RequestCb::get_callback(userdata);\n+        (callback)(nbytes);\n+    });\n }\n \n /// Proxy for notify callbacks.\n@@ -1683,8 +1687,10 @@ fn request_cb_proxy(_: *mut StreamInternal, nbytes: usize, userdata: *mut c_void\n /// must be accomplished separately to avoid a memory leak.\n extern \"C\"\n fn notify_cb_proxy(_: *mut StreamInternal, userdata: *mut c_void) {\n-    let callback = NotifyCb::get_callback(userdata);\n-    callback();\n+    let _ = std::panic::catch_unwind(|| {\n+        let callback = NotifyCb::get_callback(userdata);\n+        (callback)();\n+    });\n }\n \n /// Proxy for event callbacks.\n@@ -1694,13 +1700,15 @@ extern \"C\"\n fn event_cb_proxy(_: *mut StreamInternal, name: *const c_char,\n     proplist: *mut ::proplist::ProplistInternal, userdata: *mut c_void)\n {\n-    assert!(!name.is_null());\n-    let n = {\n-        let tmp = unsafe { CStr::from_ptr(name) };\n-        tmp.to_string_lossy().into_owned()\n-    };\n-    let pl = Proplist::from_raw_weak(proplist);\n-\n-    let callback = EventCb::get_callback(userdata);\n-    callback(n, pl);\n+    let _ = std::panic::catch_unwind(|| {\n+        assert!(!name.is_null());\n+        let n = {\n+            let tmp = unsafe { CStr::from_ptr(name) };\n+            tmp.to_string_lossy().into_owned()\n+        };\n+        let pl = Proplist::from_raw_weak(proplist);\n+\n+        let callback = EventCb::get_callback(userdata);\n+        (callback)(n, pl);\n+    });\n }\n",
    "diff_parsed": "{'added': [(1667, '    let _ = std::panic::catch_unwind(|| {'), (1669, '        let mut callback = ::callbacks::get_su_callback::<dyn FnMut(bool)>(userdata);'), (1670, '        (callback)(success_actual);'), (1671, '    });'), (1679, '    let _ = std::panic::catch_unwind(|| {'), (1680, '        let callback = RequestCb::get_callback(userdata);'), (1681, '        (callback)(nbytes);'), (1682, '    });'), (1690, '    let _ = std::panic::catch_unwind(|| {'), (1691, '        let callback = NotifyCb::get_callback(userdata);'), (1692, '        (callback)();'), (1693, '    });'), (1703, '    let _ = std::panic::catch_unwind(|| {'), (1704, '        assert!(!name.is_null());'), (1705, '        let n = {'), (1706, '            let tmp = unsafe { CStr::from_ptr(name) };'), (1707, '            tmp.to_string_lossy().into_owned()'), (1708, '        };'), (1709, '        let pl = Proplist::from_raw_weak(proplist);'), (1711, '        let callback = EventCb::get_callback(userdata);'), (1712, '        (callback)(n, pl);'), (1713, '    });')], 'deleted': [(1667, '    let mut callback = ::callbacks::get_su_callback::<dyn FnMut(bool)>(userdata);'), (1669, '    callback(success_actual);'), (1677, '    let callback = RequestCb::get_callback(userdata);'), (1678, '    callback(nbytes);'), (1686, '    let callback = NotifyCb::get_callback(userdata);'), (1687, '    callback();'), (1697, '    assert!(!name.is_null());'), (1698, '    let n = {'), (1699, '        let tmp = unsafe { CStr::from_ptr(name) };'), (1700, '        tmp.to_string_lossy().into_owned()'), (1701, '    };'), (1702, '    let pl = Proplist::from_raw_weak(proplist);'), (1704, '    let callback = EventCb::get_callback(userdata);'), (1705, '    callback(n, pl);')]}",
    "num_lines_added": "22",
    "num_lines_deleted": "14",
    "nloc": "963"
  },
  {
    "file_change_id": "228258081341040",
    "hash": "f01846bd443aaf92fdd5ac20f461beac3f6ee3fd",
    "old_path": "src/bat_utils/less.rs",
    "new_path": "src/bat_utils/less.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,8 +1,12 @@\n use std::process::Command;\n \n pub fn retrieve_less_version() -> Option<usize> {\n-    let cmd = Command::new(\"less\").arg(\"--version\").output().ok()?;\n-    parse_less_version(&cmd.stdout)\n+    if let Ok(less_path) = grep_cli::resolve_binary(\"less\") {\n+        let cmd = Command::new(less_path).arg(\"--version\").output().ok()?;\n+        parse_less_version(&cmd.stdout)\n+    } else {\n+        None\n+    }\n }\n \n fn parse_less_version(output: &[u8]) -> Option<usize> {\n",
    "diff_parsed": "{'added': [(4, '    if let Ok(less_path) = grep_cli::resolve_binary(\"less\") {'), (5, '        let cmd = Command::new(less_path).arg(\"--version\").output().ok()?;'), (6, '        parse_less_version(&cmd.stdout)'), (7, '    } else {'), (8, '        None'), (9, '    }')], 'deleted': [(4, '    let cmd = Command::new(\"less\").arg(\"--version\").output().ok()?;'), (5, '    parse_less_version(&cmd.stdout)')]}",
    "num_lines_added": "6",
    "num_lines_deleted": "2",
    "nloc": "56"
  },
  {
    "file_change_id": "11548378481065",
    "hash": "f01846bd443aaf92fdd5ac20f461beac3f6ee3fd",
    "old_path": "src/bat_utils/output.rs",
    "new_path": "src/bat_utils/output.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -77,78 +77,35 @@ impl OutputType {\n         let pagerflags =\n             shell_words::split(&pager).chain_err(|| \"Could not parse pager command.\")?;\n \n-        match pagerflags.split_first() {\n+        Ok(match pagerflags.split_first() {\n             Some((pager_name, args)) => {\n                 let pager_path = PathBuf::from(pager_name);\n \n                 let is_less = pager_path.file_stem() == Some(&OsString::from(\"less\"));\n \n-                let mut process = if is_less {\n-                    let mut p = Command::new(&pager_path);\n-                    if args.is_empty() || replace_arguments_to_less {\n-                        p.args(vec![\"--RAW-CONTROL-CHARS\"]);\n-\n-                        // Passing '--no-init' fixes a bug with '--quit-if-one-screen' in older\n-                        // versions of 'less'. Unfortunately, it also breaks mouse-wheel support.\n-                        //\n-                        // See: http://www.greenwoodsoftware.com/less/news.530.html\n-                        //\n-                        // For newer versions (530 or 558 on Windows), we omit '--no-init' as it\n-                        // is not needed anymore.\n-                        match retrieve_less_version() {\n-                            None => {\n-                                p.arg(\"--no-init\");\n-                            }\n-                            Some(version)\n-                                if (version < 530 || (cfg!(windows) && version < 558)) =>\n-                            {\n-                                p.arg(\"--no-init\");\n-                            }\n-                            _ => {}\n-                        }\n-\n-                        if quit_if_one_screen {\n-                            p.arg(\"--quit-if-one-screen\");\n-                        }\n-                    } else {\n-                        p.args(args);\n-                    }\n-                    p.env(\"LESSCHARSET\", \"UTF-8\");\n-                    p\n+                let process = if is_less {\n+                    _make_process_from_less_path(\n+                        pager_path,\n+                        args,\n+                        replace_arguments_to_less,\n+                        quit_if_one_screen,\n+                        config,\n+                    )\n                 } else {\n-                    if pager_path.file_stem() == Some(&OsString::from(\"delta\")) {\n-                        eprintln!(\n-                            \"\\\n-It looks like you have set delta as the value of $PAGER. \\\n-This would result in a non-terminating recursion. \\\n-delta is not an appropriate value for $PAGER \\\n-(but it is an appropriate value for $GIT_PAGER).\"\n-                        );\n-                        std::process::exit(1);\n-                    }\n-                    let mut p = Command::new(&pager_path);\n-                    p.args(args);\n-                    p\n+                    _make_process_from_pager_path(pager_path, args)\n                 };\n-                if is_less && config.navigate {\n-                    if let Ok(hist_file) =\n-                        navigate::copy_less_hist_file_and_append_navigate_regexp(config)\n-                    {\n-                        process.env(\"LESSHISTFILE\", hist_file);\n-                        if config.show_themes {\n-                            process.arg(\"+n\");\n-                        }\n-                    }\n+                if let Some(mut process) = process {\n+                    process\n+                        .stdin(Stdio::piped())\n+                        .spawn()\n+                        .map(OutputType::Pager)\n+                        .unwrap_or_else(|_| OutputType::stdout())\n+                } else {\n+                    OutputType::stdout()\n                 }\n-                Ok(process\n-                    .env(\"LESSANSIENDCHARS\", \"mK\")\n-                    .stdin(Stdio::piped())\n-                    .spawn()\n-                    .map(OutputType::Pager)\n-                    .unwrap_or_else(|_| OutputType::stdout()))\n             }\n-            None => Ok(OutputType::stdout()),\n-        }\n+            None => OutputType::stdout(),\n+        })\n     }\n \n     fn stdout() -> Self {\n@@ -166,6 +123,78 @@ delta is not an appropriate value for $PAGER \\\n     }\n }\n \n+fn _make_process_from_less_path(\n+    less_path: PathBuf,\n+    args: &[String],\n+    replace_arguments_to_less: bool,\n+    quit_if_one_screen: bool,\n+    config: &config::Config,\n+) -> Option<Command> {\n+    if let Ok(less_path) = grep_cli::resolve_binary(less_path) {\n+        let mut p = Command::new(&less_path);\n+        if args.is_empty() || replace_arguments_to_less {\n+            p.args(vec![\"--RAW-CONTROL-CHARS\"]);\n+\n+            // Passing '--no-init' fixes a bug with '--quit-if-one-screen' in older\n+            // versions of 'less'. Unfortunately, it also breaks mouse-wheel support.\n+            //\n+            // See: http://www.greenwoodsoftware.com/less/news.530.html\n+            //\n+            // For newer versions (530 or 558 on Windows), we omit '--no-init' as it\n+            // is not needed anymore.\n+            match retrieve_less_version() {\n+                None => {\n+                    p.arg(\"--no-init\");\n+                }\n+                Some(version) if (version < 530 || (cfg!(windows) && version < 558)) => {\n+                    p.arg(\"--no-init\");\n+                }\n+                _ => {}\n+            }\n+\n+            if quit_if_one_screen {\n+                p.arg(\"--quit-if-one-screen\");\n+            }\n+        } else {\n+            p.args(args);\n+        }\n+        p.env(\"LESSCHARSET\", \"UTF-8\");\n+        p.env(\"LESSANSIENDCHARS\", \"mK\");\n+        if config.navigate {\n+            if let Ok(hist_file) = navigate::copy_less_hist_file_and_append_navigate_regexp(config)\n+            {\n+                p.env(\"LESSHISTFILE\", hist_file);\n+                if config.show_themes {\n+                    p.arg(\"+n\");\n+                }\n+            }\n+        }\n+        Some(p)\n+    } else {\n+        None\n+    }\n+}\n+\n+fn _make_process_from_pager_path(pager_path: PathBuf, args: &[String]) -> Option<Command> {\n+    if pager_path.file_stem() == Some(&OsString::from(\"delta\")) {\n+        eprintln!(\n+            \"\\\n+It looks like you have set delta as the value of $PAGER. \\\n+This would result in a non-terminating recursion. \\\n+delta is not an appropriate value for $PAGER \\\n+(but it is an appropriate value for $GIT_PAGER).\"\n+        );\n+        std::process::exit(1);\n+    }\n+    if let Ok(pager_path) = grep_cli::resolve_binary(pager_path) {\n+        let mut p = Command::new(&pager_path);\n+        p.args(args);\n+        Some(p)\n+    } else {\n+        None\n+    }\n+}\n+\n impl Drop for OutputType {\n     fn drop(&mut self) {\n         if let OutputType::Pager(ref mut command) = *self {\n",
    "diff_parsed": "{'added': [(80, '        Ok(match pagerflags.split_first() {'), (86, '                let process = if is_less {'), (87, '                    _make_process_from_less_path('), (88, '                        pager_path,'), (89, '                        args,'), (90, '                        replace_arguments_to_less,'), (91, '                        quit_if_one_screen,'), (92, '                        config,'), (93, '                    )'), (95, '                    _make_process_from_pager_path(pager_path, args)'), (97, '                if let Some(mut process) = process {'), (98, '                    process'), (99, '                        .stdin(Stdio::piped())'), (100, '                        .spawn()'), (101, '                        .map(OutputType::Pager)'), (102, '                        .unwrap_or_else(|_| OutputType::stdout())'), (103, '                } else {'), (104, '                    OutputType::stdout()'), (107, '            None => OutputType::stdout(),'), (108, '        })'), (126, 'fn _make_process_from_less_path('), (127, '    less_path: PathBuf,'), (128, '    args: &[String],'), (129, '    replace_arguments_to_less: bool,'), (130, '    quit_if_one_screen: bool,'), (131, '    config: &config::Config,'), (132, ') -> Option<Command> {'), (133, '    if let Ok(less_path) = grep_cli::resolve_binary(less_path) {'), (134, '        let mut p = Command::new(&less_path);'), (135, '        if args.is_empty() || replace_arguments_to_less {'), (136, '            p.args(vec![\"--RAW-CONTROL-CHARS\"]);'), (145, '            match retrieve_less_version() {'), (146, '                None => {'), (147, '                    p.arg(\"--no-init\");'), (148, '                }'), (149, '                Some(version) if (version < 530 || (cfg!(windows) && version < 558)) => {'), (150, '                    p.arg(\"--no-init\");'), (151, '                }'), (152, '                _ => {}'), (153, '            }'), (155, '            if quit_if_one_screen {'), (156, '                p.arg(\"--quit-if-one-screen\");'), (157, '            }'), (158, '        } else {'), (159, '            p.args(args);'), (160, '        }'), (161, '        p.env(\"LESSCHARSET\", \"UTF-8\");'), (162, '        p.env(\"LESSANSIENDCHARS\", \"mK\");'), (163, '        if config.navigate {'), (164, '            if let Ok(hist_file) = navigate::copy_less_hist_file_and_append_navigate_regexp(config)'), (165, '            {'), (166, '                p.env(\"LESSHISTFILE\", hist_file);'), (167, '                if config.show_themes {'), (168, '                    p.arg(\"+n\");'), (169, '                }'), (170, '            }'), (171, '        }'), (172, '        Some(p)'), (173, '    } else {'), (174, '        None'), (175, '    }'), (176, '}'), (178, 'fn _make_process_from_pager_path(pager_path: PathBuf, args: &[String]) -> Option<Command> {'), (179, '    if pager_path.file_stem() == Some(&OsString::from(\"delta\")) {'), (180, '        eprintln!('), (181, '            \"\\\\'), (182, 'It looks like you have set delta as the value of $PAGER. \\\\'), (183, 'This would result in a non-terminating recursion. \\\\'), (184, 'delta is not an appropriate value for $PAGER \\\\'), (185, '(but it is an appropriate value for $GIT_PAGER).\"'), (186, '        );'), (187, '        std::process::exit(1);'), (188, '    }'), (189, '    if let Ok(pager_path) = grep_cli::resolve_binary(pager_path) {'), (190, '        let mut p = Command::new(&pager_path);'), (191, '        p.args(args);'), (192, '        Some(p)'), (193, '    } else {'), (194, '        None'), (195, '    }'), (196, '}')], 'deleted': [(80, '        match pagerflags.split_first() {'), (86, '                let mut process = if is_less {'), (87, '                    let mut p = Command::new(&pager_path);'), (88, '                    if args.is_empty() || replace_arguments_to_less {'), (89, '                        p.args(vec![\"--RAW-CONTROL-CHARS\"]);'), (98, '                        match retrieve_less_version() {'), (99, '                            None => {'), (100, '                                p.arg(\"--no-init\");'), (101, '                            }'), (102, '                            Some(version)'), (103, '                                if (version < 530 || (cfg!(windows) && version < 558)) =>'), (104, '                            {'), (105, '                                p.arg(\"--no-init\");'), (106, '                            }'), (107, '                            _ => {}'), (108, '                        }'), (110, '                        if quit_if_one_screen {'), (111, '                            p.arg(\"--quit-if-one-screen\");'), (112, '                        }'), (113, '                    } else {'), (114, '                        p.args(args);'), (115, '                    }'), (116, '                    p.env(\"LESSCHARSET\", \"UTF-8\");'), (117, '                    p'), (119, '                    if pager_path.file_stem() == Some(&OsString::from(\"delta\")) {'), (120, '                        eprintln!('), (121, '                            \"\\\\'), (122, 'It looks like you have set delta as the value of $PAGER. \\\\'), (123, 'This would result in a non-terminating recursion. \\\\'), (124, 'delta is not an appropriate value for $PAGER \\\\'), (125, '(but it is an appropriate value for $GIT_PAGER).\"'), (126, '                        );'), (127, '                        std::process::exit(1);'), (128, '                    }'), (129, '                    let mut p = Command::new(&pager_path);'), (130, '                    p.args(args);'), (131, '                    p'), (133, '                if is_less && config.navigate {'), (134, '                    if let Ok(hist_file) ='), (135, '                        navigate::copy_less_hist_file_and_append_navigate_regexp(config)'), (136, '                    {'), (137, '                        process.env(\"LESSHISTFILE\", hist_file);'), (138, '                        if config.show_themes {'), (139, '                            process.arg(\"+n\");'), (140, '                        }'), (141, '                    }'), (143, '                Ok(process'), (144, '                    .env(\"LESSANSIENDCHARS\", \"mK\")'), (145, '                    .stdin(Stdio::piped())'), (146, '                    .spawn()'), (147, '                    .map(OutputType::Pager)'), (148, '                    .unwrap_or_else(|_| OutputType::stdout()))'), (150, '            None => Ok(OutputType::stdout()),'), (151, '        }')]}",
    "num_lines_added": "81",
    "num_lines_deleted": "54",
    "nloc": "169"
  },
  {
    "file_change_id": "267127761211221",
    "hash": "f01846bd443aaf92fdd5ac20f461beac3f6ee3fd",
    "old_path": "src/main.rs",
    "new_path": "src/main.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -132,7 +132,11 @@ You can also use delta to diff two files: `delta file_A file_B`.\"\n     let diff_command = \"git\";\n     let minus_file = minus_file.unwrap_or_else(die);\n     let plus_file = plus_file.unwrap_or_else(die);\n-    let mut diff_process = process::Command::new(PathBuf::from(diff_command))\n+    let diff_command_path = match grep_cli::resolve_binary(PathBuf::from(diff_command)) {\n+        Ok(path) => path,\n+        Err(_) => return config.error_exit_code,\n+    };\n+    let mut diff_process = process::Command::new(diff_command_path)\n         .args(&[\"diff\", \"--no-index\"])\n         .args(&[minus_file, plus_file])\n         .stdout(process::Stdio::piped())\n",
    "diff_parsed": "{'added': [(135, '    let diff_command_path = match grep_cli::resolve_binary(PathBuf::from(diff_command)) {'), (136, '        Ok(path) => path,'), (137, '        Err(_) => return config.error_exit_code,'), (138, '    };'), (139, '    let mut diff_process = process::Command::new(diff_command_path)')], 'deleted': [(135, '    let mut diff_process = process::Command::new(PathBuf::from(diff_command))')]}",
    "num_lines_added": "5",
    "num_lines_deleted": "1",
    "nloc": "564"
  },
  {
    "file_change_id": "104052016701227",
    "hash": "8f28ec275e412dd3af4f3cda460605512faf332c",
    "old_path": "src/subframe.rs",
    "new_path": "src/subframe.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -254,12 +254,25 @@ fn decode_residual<R: ReadBytes>(input: &mut Bitstream<R>,\n     // most 2^16 - 1 samples in the block. No values have been marked as\n     // invalid by the specification though.\n     let n_partitions = 1u32 << order;\n-    let n_samples = block_size >> order;\n+    let n_samples_per_partition = block_size >> order;\n+\n+    // The partitions together must fill the block. If the block size is not a\n+    // multiple of 2^order; if we shifted off some bits, then we would not fill\n+    // the entire block. Such a partition order is invalid for this block size.\n+    if block_size & (n_partitions - 1) as u16 != 0 {\n+        return fmt_err(\"invalid partition order\")\n+    }\n+\n+    // NOTE: the check above checks that block_size is a multiple of n_partitions\n+    // (this works because n_partitions is a power of 2). The check below is\n+    // equivalent but more expensive.\n+    debug_assert_eq!(n_partitions * n_samples_per_partition as u32, block_size as u32);\n+\n     let n_warm_up = block_size - buffer.len() as u16;\n \n     // The partition size must be at least as big as the number of warm-up\n     // samples, otherwise the size of the first partition is negative.\n-    if n_warm_up > n_samples {\n+    if n_warm_up > n_samples_per_partition {\n         return fmt_err(\"invalid residual\");\n     }\n \n@@ -267,22 +280,22 @@ fn decode_residual<R: ReadBytes>(input: &mut Bitstream<R>,\n     match partition_type {\n         RicePartitionType::Rice => {\n             let mut start = 0;\n-            let mut len = n_samples - n_warm_up;\n+            let mut len = n_samples_per_partition - n_warm_up;\n             for _ in 0..n_partitions {\n                 let slice = &mut buffer[start..start + len as usize];\n                 try!(decode_rice_partition(input, slice));\n                 start = start + len as usize;\n-                len = n_samples;\n+                len = n_samples_per_partition;\n             }\n         }\n         RicePartitionType::Rice2 => {\n             let mut start = 0;\n-            let mut len = n_samples - n_warm_up;\n+            let mut len = n_samples_per_partition - n_warm_up;\n             for _ in 0..n_partitions {\n                 let slice = &mut buffer[start..start + len as usize];\n                 try!(decode_rice2_partition(input, slice));\n                 start = start + len as usize;\n-                len = n_samples;\n+                len = n_samples_per_partition;\n             }\n         }\n     }\n",
    "diff_parsed": "{'added': [(257, '    let n_samples_per_partition = block_size >> order;'), (262, '    if block_size & (n_partitions - 1) as u16 != 0 {'), (263, '        return fmt_err(\"invalid partition order\")'), (264, '    }'), (269, '    debug_assert_eq!(n_partitions * n_samples_per_partition as u32, block_size as u32);'), (275, '    if n_warm_up > n_samples_per_partition {'), (283, '            let mut len = n_samples_per_partition - n_warm_up;'), (288, '                len = n_samples_per_partition;'), (293, '            let mut len = n_samples_per_partition - n_warm_up;'), (298, '                len = n_samples_per_partition;')], 'deleted': [(257, '    let n_samples = block_size >> order;'), (262, '    if n_warm_up > n_samples {'), (270, '            let mut len = n_samples - n_warm_up;'), (275, '                len = n_samples;'), (280, '            let mut len = n_samples - n_warm_up;'), (285, '                len = n_samples;')]}",
    "num_lines_added": "10",
    "num_lines_deleted": "6",
    "nloc": "373"
  },
  {
    "file_change_id": "264997454159564",
    "hash": "3c6b57fe1b2cc87e7ebecde43dd836ffb1c4ea5c",
    "old_path": "src/vtab/array.rs",
    "new_path": "src/vtab/array.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -33,8 +33,8 @@ use std::rc::Rc;\n use crate::ffi;\n use crate::types::{ToSql, ToSqlOutput, Value};\n use crate::vtab::{\n-    eponymous_only_module, Context, IndexConstraintOp, IndexInfo, Module, VTab, VTabConnection,\n-    VTabCursor, Values,\n+    eponymous_only_module, Context, IndexConstraintOp, IndexInfo, VTab, VTabConnection, VTabCursor,\n+    Values,\n };\n use crate::{Connection, Result};\n \n@@ -57,11 +57,7 @@ impl ToSql for Array {\n /// `feature = \"array\"` Register the \"rarray\" module.\n pub fn load_module(conn: &Connection) -> Result<()> {\n     let aux: Option<()> = None;\n-    conn.create_module(\"rarray\", &ARRAY_MODULE, aux)\n-}\n-\n-lazy_static::lazy_static! {\n-    static ref ARRAY_MODULE: Module<ArrayTab> = eponymous_only_module::<ArrayTab>(1);\n+    conn.create_module(\"rarray\", eponymous_only_module::<ArrayTab>(), aux)\n }\n \n // Column numbers\n",
    "diff_parsed": "{'added': [(36, '    eponymous_only_module, Context, IndexConstraintOp, IndexInfo, VTab, VTabConnection, VTabCursor,'), (37, '    Values,'), (60, '    conn.create_module(\"rarray\", eponymous_only_module::<ArrayTab>(), aux)')], 'deleted': [(36, '    eponymous_only_module, Context, IndexConstraintOp, IndexInfo, Module, VTab, VTabConnection,'), (37, '    VTabCursor, Values,'), (60, '    conn.create_module(\"rarray\", &ARRAY_MODULE, aux)'), (61, '}'), (63, 'lazy_static::lazy_static! {'), (64, '    static ref ARRAY_MODULE: Module<ArrayTab> = eponymous_only_module::<ArrayTab>(1);')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "6",
    "nloc": "177"
  },
  {
    "file_change_id": "155342974360949",
    "hash": "3c6b57fe1b2cc87e7ebecde43dd836ffb1c4ea5c",
    "old_path": "src/vtab/csvtab.rs",
    "new_path": "src/vtab/csvtab.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -30,7 +30,7 @@ use crate::ffi;\n use crate::types::Null;\n use crate::vtab::{\n     dequote, escape_double_quote, parse_boolean, read_only_module, Context, CreateVTab, IndexInfo,\n-    Module, VTab, VTabConnection, VTabCursor, Values,\n+    VTab, VTabConnection, VTabCursor, Values,\n };\n use crate::{Connection, Error, Result};\n \n@@ -47,11 +47,7 @@ use crate::{Connection, Error, Result};\n /// ```\n pub fn load_module(conn: &Connection) -> Result<()> {\n     let aux: Option<()> = None;\n-    conn.create_module(\"csv\", &CSV_MODULE, aux)\n-}\n-\n-lazy_static::lazy_static! {\n-    static ref CSV_MODULE: Module<CSVTab> = read_only_module::<CSVTab>(1);\n+    conn.create_module(\"csv\", read_only_module::<CSVTab>(), aux)\n }\n \n /// An instance of the CSV virtual table\n",
    "diff_parsed": "{'added': [(33, '    VTab, VTabConnection, VTabCursor, Values,'), (50, '    conn.create_module(\"csv\", read_only_module::<CSVTab>(), aux)')], 'deleted': [(33, '    Module, VTab, VTabConnection, VTabCursor, Values,'), (50, '    conn.create_module(\"csv\", &CSV_MODULE, aux)'), (51, '}'), (53, 'lazy_static::lazy_static! {'), (54, '    static ref CSV_MODULE: Module<CSVTab> = read_only_module::<CSVTab>(1);')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "5",
    "nloc": "341"
  },
  {
    "file_change_id": "236568929987917",
    "hash": "3c6b57fe1b2cc87e7ebecde43dd836ffb1c4ea5c",
    "old_path": "src/vtab/mod.rs",
    "new_path": "src/vtab/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -60,7 +60,7 @@ use crate::{str_to_cstring, Connection, Error, InnerConnection, Result};\n /// `feature = \"vtab\"` Virtual table module\n ///\n /// (See [SQLite doc](https://sqlite.org/c3ref/module.html))\n-#[repr(C)]\n+#[repr(transparent)]\n pub struct Module<T: VTab> {\n     base: ffi::sqlite3_module,\n     phantom: PhantomData<T>,\n@@ -69,47 +69,55 @@ pub struct Module<T: VTab> {\n unsafe impl<T: VTab> Send for Module<T> {}\n unsafe impl<T: VTab> Sync for Module<T> {}\n \n-// Used as a trailing initializer for sqlite3_module -- this way we avoid having\n-// the build fail if buildtime_bindgen is on\n-fn zeroed_module() -> ffi::sqlite3_module {\n-    // This is safe, as bindgen-generated structs are allowed to be zeroed.\n-    unsafe { std::mem::MaybeUninit::zeroed().assume_init() }\n+union ModuleZeroHack {\n+    bytes: [u8; std::mem::size_of::<ffi::sqlite3_module>()],\n+    module: ffi::sqlite3_module,\n }\n \n+// Used as a trailing initializer for sqlite3_module -- this way we avoid having\n+// the build fail if buildtime_bindgen is on. This is safe, as bindgen-generated\n+// structs are allowed to be zeroed.\n+const ZERO_MODULE: ffi::sqlite3_module = unsafe {\n+    ModuleZeroHack {\n+        bytes: [0u8; std::mem::size_of::<ffi::sqlite3_module>()],\n+    }\n+    .module\n+};\n+\n /// `feature = \"vtab\"` Create a read-only virtual table implementation.\n ///\n /// Step 2 of [Creating New Virtual Table Implementations](https://sqlite.org/vtab.html#creating_new_virtual_table_implementations).\n-pub fn read_only_module<T: CreateVTab>(version: c_int) -> Module<T> {\n+pub fn read_only_module<T: CreateVTab>() -> &'static Module<T> {\n     // The xConnect and xCreate methods do the same thing, but they must be\n     // different so that the virtual table is not an eponymous virtual table.\n-    let ffi_module = ffi::sqlite3_module {\n-        iVersion: version,\n-        xCreate: Some(rust_create::<T>),\n-        xConnect: Some(rust_connect::<T>),\n-        xBestIndex: Some(rust_best_index::<T>),\n-        xDisconnect: Some(rust_disconnect::<T>),\n-        xDestroy: Some(rust_destroy::<T>),\n-        xOpen: Some(rust_open::<T>),\n-        xClose: Some(rust_close::<T::Cursor>),\n-        xFilter: Some(rust_filter::<T::Cursor>),\n-        xNext: Some(rust_next::<T::Cursor>),\n-        xEof: Some(rust_eof::<T::Cursor>),\n-        xColumn: Some(rust_column::<T::Cursor>),\n-        xRowid: Some(rust_rowid::<T::Cursor>),\n-        xUpdate: None,\n-        xBegin: None,\n-        xSync: None,\n-        xCommit: None,\n-        xRollback: None,\n-        xFindFunction: None,\n-        xRename: None,\n-        xSavepoint: None,\n-        xRelease: None,\n-        xRollbackTo: None,\n-        ..zeroed_module()\n-    };\n-    Module {\n-        base: ffi_module,\n+    &Module {\n+        base: ffi::sqlite3_module {\n+            // We don't use V3\n+            iVersion: 2, // We don't use V2 or V3 features in read_only_module types\n+            xCreate: Some(rust_create::<T>),\n+            xConnect: Some(rust_connect::<T>),\n+            xBestIndex: Some(rust_best_index::<T>),\n+            xDisconnect: Some(rust_disconnect::<T>),\n+            xDestroy: Some(rust_destroy::<T>),\n+            xOpen: Some(rust_open::<T>),\n+            xClose: Some(rust_close::<T::Cursor>),\n+            xFilter: Some(rust_filter::<T::Cursor>),\n+            xNext: Some(rust_next::<T::Cursor>),\n+            xEof: Some(rust_eof::<T::Cursor>),\n+            xColumn: Some(rust_column::<T::Cursor>),\n+            xRowid: Some(rust_rowid::<T::Cursor>),\n+            xUpdate: None,\n+            xBegin: None,\n+            xSync: None,\n+            xCommit: None,\n+            xRollback: None,\n+            xFindFunction: None,\n+            xRename: None,\n+            xSavepoint: None,\n+            xRelease: None,\n+            xRollbackTo: None,\n+            ..ZERO_MODULE\n+        },\n         phantom: PhantomData::<T>,\n     }\n }\n@@ -117,38 +125,38 @@ pub fn read_only_module<T: CreateVTab>(version: c_int) -> Module<T> {\n /// `feature = \"vtab\"` Create an eponymous only virtual table implementation.\n ///\n /// Step 2 of [Creating New Virtual Table Implementations](https://sqlite.org/vtab.html#creating_new_virtual_table_implementations).\n-pub fn eponymous_only_module<T: VTab>(version: c_int) -> Module<T> {\n+pub fn eponymous_only_module<T: VTab>() -> &'static Module<T> {\n     // A virtual table is eponymous if its xCreate method is the exact same function\n     // as the xConnect method For eponymous-only virtual tables, the xCreate\n     // method is NULL\n-    let ffi_module = ffi::sqlite3_module {\n-        iVersion: version,\n-        xCreate: None,\n-        xConnect: Some(rust_connect::<T>),\n-        xBestIndex: Some(rust_best_index::<T>),\n-        xDisconnect: Some(rust_disconnect::<T>),\n-        xDestroy: None,\n-        xOpen: Some(rust_open::<T>),\n-        xClose: Some(rust_close::<T::Cursor>),\n-        xFilter: Some(rust_filter::<T::Cursor>),\n-        xNext: Some(rust_next::<T::Cursor>),\n-        xEof: Some(rust_eof::<T::Cursor>),\n-        xColumn: Some(rust_column::<T::Cursor>),\n-        xRowid: Some(rust_rowid::<T::Cursor>),\n-        xUpdate: None,\n-        xBegin: None,\n-        xSync: None,\n-        xCommit: None,\n-        xRollback: None,\n-        xFindFunction: None,\n-        xRename: None,\n-        xSavepoint: None,\n-        xRelease: None,\n-        xRollbackTo: None,\n-        ..zeroed_module()\n-    };\n-    Module {\n-        base: ffi_module,\n+    &Module {\n+        base: ffi::sqlite3_module {\n+            // We don't use V3\n+            iVersion: 2,\n+            xCreate: None,\n+            xConnect: Some(rust_connect::<T>),\n+            xBestIndex: Some(rust_best_index::<T>),\n+            xDisconnect: Some(rust_disconnect::<T>),\n+            xDestroy: None,\n+            xOpen: Some(rust_open::<T>),\n+            xClose: Some(rust_close::<T::Cursor>),\n+            xFilter: Some(rust_filter::<T::Cursor>),\n+            xNext: Some(rust_next::<T::Cursor>),\n+            xEof: Some(rust_eof::<T::Cursor>),\n+            xColumn: Some(rust_column::<T::Cursor>),\n+            xRowid: Some(rust_rowid::<T::Cursor>),\n+            xUpdate: None,\n+            xBegin: None,\n+            xSync: None,\n+            xCommit: None,\n+            xRollback: None,\n+            xFindFunction: None,\n+            xRename: None,\n+            xSavepoint: None,\n+            xRelease: None,\n+            xRollbackTo: None,\n+            ..ZERO_MODULE\n+        },\n         phantom: PhantomData::<T>,\n     }\n }\n@@ -583,11 +591,12 @@ impl<'a> Iterator for ValueIter<'a> {\n impl Connection {\n     /// `feature = \"vtab\"` Register a virtual table implementation.\n     ///\n-    /// Step 3 of [Creating New Virtual Table Implementations](https://sqlite.org/vtab.html#creating_new_virtual_table_implementations).\n+    /// Step 3 of [Creating New Virtual Table\n+    /// Implementations](https://sqlite.org/vtab.html#creating_new_virtual_table_implementations).\n     pub fn create_module<T: VTab>(\n         &self,\n         module_name: &str,\n-        module: &Module<T>,\n+        module: &'static Module<T>,\n         aux: Option<T::Aux>,\n     ) -> Result<()> {\n         self.db.borrow_mut().create_module(module_name, module, aux)\n@@ -598,7 +607,7 @@ impl InnerConnection {\n     fn create_module<T: VTab>(\n         &mut self,\n         module_name: &str,\n-        module: &Module<T>,\n+        module: &'static Module<T>,\n         aux: Option<T::Aux>,\n     ) -> Result<()> {\n         let c_name = str_to_cstring(module_name)?;\n",
    "diff_parsed": "{'added': [(63, '#[repr(transparent)]'), (72, 'union ModuleZeroHack {'), (73, '    bytes: [u8; std::mem::size_of::<ffi::sqlite3_module>()],'), (74, '    module: ffi::sqlite3_module,'), (80, 'const ZERO_MODULE: ffi::sqlite3_module = unsafe {'), (81, '    ModuleZeroHack {'), (82, '        bytes: [0u8; std::mem::size_of::<ffi::sqlite3_module>()],'), (83, '    }'), (84, '    .module'), (85, '};'), (90, \"pub fn read_only_module<T: CreateVTab>() -> &'static Module<T> {\"), (93, '    &Module {'), (94, '        base: ffi::sqlite3_module {'), (96, \"            iVersion: 2, // We don't use V2 or V3 features in read_only_module types\"), (97, '            xCreate: Some(rust_create::<T>),'), (98, '            xConnect: Some(rust_connect::<T>),'), (99, '            xBestIndex: Some(rust_best_index::<T>),'), (100, '            xDisconnect: Some(rust_disconnect::<T>),'), (101, '            xDestroy: Some(rust_destroy::<T>),'), (102, '            xOpen: Some(rust_open::<T>),'), (103, '            xClose: Some(rust_close::<T::Cursor>),'), (104, '            xFilter: Some(rust_filter::<T::Cursor>),'), (105, '            xNext: Some(rust_next::<T::Cursor>),'), (106, '            xEof: Some(rust_eof::<T::Cursor>),'), (107, '            xColumn: Some(rust_column::<T::Cursor>),'), (108, '            xRowid: Some(rust_rowid::<T::Cursor>),'), (109, '            xUpdate: None,'), (110, '            xBegin: None,'), (111, '            xSync: None,'), (112, '            xCommit: None,'), (113, '            xRollback: None,'), (114, '            xFindFunction: None,'), (115, '            xRename: None,'), (116, '            xSavepoint: None,'), (117, '            xRelease: None,'), (118, '            xRollbackTo: None,'), (119, '            ..ZERO_MODULE'), (120, '        },'), (128, \"pub fn eponymous_only_module<T: VTab>() -> &'static Module<T> {\"), (132, '    &Module {'), (133, '        base: ffi::sqlite3_module {'), (135, '            iVersion: 2,'), (136, '            xCreate: None,'), (137, '            xConnect: Some(rust_connect::<T>),'), (138, '            xBestIndex: Some(rust_best_index::<T>),'), (139, '            xDisconnect: Some(rust_disconnect::<T>),'), (140, '            xDestroy: None,'), (141, '            xOpen: Some(rust_open::<T>),'), (142, '            xClose: Some(rust_close::<T::Cursor>),'), (143, '            xFilter: Some(rust_filter::<T::Cursor>),'), (144, '            xNext: Some(rust_next::<T::Cursor>),'), (145, '            xEof: Some(rust_eof::<T::Cursor>),'), (146, '            xColumn: Some(rust_column::<T::Cursor>),'), (147, '            xRowid: Some(rust_rowid::<T::Cursor>),'), (148, '            xUpdate: None,'), (149, '            xBegin: None,'), (150, '            xSync: None,'), (151, '            xCommit: None,'), (152, '            xRollback: None,'), (153, '            xFindFunction: None,'), (154, '            xRename: None,'), (155, '            xSavepoint: None,'), (156, '            xRelease: None,'), (157, '            xRollbackTo: None,'), (158, '            ..ZERO_MODULE'), (159, '        },'), (599, \"        module: &'static Module<T>,\"), (610, \"        module: &'static Module<T>,\")], 'deleted': [(63, '#[repr(C)]'), (74, 'fn zeroed_module() -> ffi::sqlite3_module {'), (76, '    unsafe { std::mem::MaybeUninit::zeroed().assume_init() }'), (82, 'pub fn read_only_module<T: CreateVTab>(version: c_int) -> Module<T> {'), (85, '    let ffi_module = ffi::sqlite3_module {'), (86, '        iVersion: version,'), (87, '        xCreate: Some(rust_create::<T>),'), (88, '        xConnect: Some(rust_connect::<T>),'), (89, '        xBestIndex: Some(rust_best_index::<T>),'), (90, '        xDisconnect: Some(rust_disconnect::<T>),'), (91, '        xDestroy: Some(rust_destroy::<T>),'), (92, '        xOpen: Some(rust_open::<T>),'), (93, '        xClose: Some(rust_close::<T::Cursor>),'), (94, '        xFilter: Some(rust_filter::<T::Cursor>),'), (95, '        xNext: Some(rust_next::<T::Cursor>),'), (96, '        xEof: Some(rust_eof::<T::Cursor>),'), (97, '        xColumn: Some(rust_column::<T::Cursor>),'), (98, '        xRowid: Some(rust_rowid::<T::Cursor>),'), (99, '        xUpdate: None,'), (100, '        xBegin: None,'), (101, '        xSync: None,'), (102, '        xCommit: None,'), (103, '        xRollback: None,'), (104, '        xFindFunction: None,'), (105, '        xRename: None,'), (106, '        xSavepoint: None,'), (107, '        xRelease: None,'), (108, '        xRollbackTo: None,'), (109, '        ..zeroed_module()'), (110, '    };'), (111, '    Module {'), (112, '        base: ffi_module,'), (120, 'pub fn eponymous_only_module<T: VTab>(version: c_int) -> Module<T> {'), (124, '    let ffi_module = ffi::sqlite3_module {'), (125, '        iVersion: version,'), (126, '        xCreate: None,'), (127, '        xConnect: Some(rust_connect::<T>),'), (128, '        xBestIndex: Some(rust_best_index::<T>),'), (129, '        xDisconnect: Some(rust_disconnect::<T>),'), (130, '        xDestroy: None,'), (131, '        xOpen: Some(rust_open::<T>),'), (132, '        xClose: Some(rust_close::<T::Cursor>),'), (133, '        xFilter: Some(rust_filter::<T::Cursor>),'), (134, '        xNext: Some(rust_next::<T::Cursor>),'), (135, '        xEof: Some(rust_eof::<T::Cursor>),'), (136, '        xColumn: Some(rust_column::<T::Cursor>),'), (137, '        xRowid: Some(rust_rowid::<T::Cursor>),'), (138, '        xUpdate: None,'), (139, '        xBegin: None,'), (140, '        xSync: None,'), (141, '        xCommit: None,'), (142, '        xRollback: None,'), (143, '        xFindFunction: None,'), (144, '        xRename: None,'), (145, '        xSavepoint: None,'), (146, '        xRelease: None,'), (147, '        xRollbackTo: None,'), (148, '        ..zeroed_module()'), (149, '    };'), (150, '    Module {'), (151, '        base: ffi_module,'), (590, '        module: &Module<T>,'), (601, '        module: &Module<T>,')]}",
    "num_lines_added": "68",
    "num_lines_deleted": "63",
    "nloc": "861"
  },
  {
    "file_change_id": "16595518575693",
    "hash": "3c6b57fe1b2cc87e7ebecde43dd836ffb1c4ea5c",
    "old_path": "src/vtab/series.rs",
    "new_path": "src/vtab/series.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -9,19 +9,15 @@ use std::os::raw::c_int;\n use crate::ffi;\n use crate::types::Type;\n use crate::vtab::{\n-    eponymous_only_module, Context, IndexConstraintOp, IndexInfo, Module, VTab, VTabConnection,\n-    VTabCursor, Values,\n+    eponymous_only_module, Context, IndexConstraintOp, IndexInfo, VTab, VTabConnection, VTabCursor,\n+    Values,\n };\n use crate::{Connection, Result};\n \n /// `feature = \"series\"` Register the \"generate_series\" module.\n pub fn load_module(conn: &Connection) -> Result<()> {\n     let aux: Option<()> = None;\n-    conn.create_module(\"generate_series\", &SERIES_MODULE, aux)\n-}\n-\n-lazy_static::lazy_static! {\n-    static ref SERIES_MODULE: Module<SeriesTab> = eponymous_only_module::<SeriesTab>(1);\n+    conn.create_module(\"generate_series\", eponymous_only_module::<SeriesTab>(), aux)\n }\n \n // Column numbers\n",
    "diff_parsed": "{'added': [(12, '    eponymous_only_module, Context, IndexConstraintOp, IndexInfo, VTab, VTabConnection, VTabCursor,'), (13, '    Values,'), (20, '    conn.create_module(\"generate_series\", eponymous_only_module::<SeriesTab>(), aux)')], 'deleted': [(12, '    eponymous_only_module, Context, IndexConstraintOp, IndexInfo, Module, VTab, VTabConnection,'), (13, '    VTabCursor, Values,'), (20, '    conn.create_module(\"generate_series\", &SERIES_MODULE, aux)'), (21, '}'), (23, 'lazy_static::lazy_static! {'), (24, '    static ref SERIES_MODULE: Module<SeriesTab> = eponymous_only_module::<SeriesTab>(1);')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "6",
    "nloc": "237"
  },
  {
    "file_change_id": "46086879083762",
    "hash": "3c6b57fe1b2cc87e7ebecde43dd836ffb1c4ea5c",
    "old_path": "tests/vtab.rs",
    "new_path": "tests/vtab.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -11,7 +11,7 @@ fn test_dummy_module() {\n     use rusqlite::{version_number, Connection, Result};\n     use std::os::raw::c_int;\n \n-    let module = eponymous_only_module::<DummyTab>(1);\n+    let module = eponymous_only_module::<DummyTab>();\n \n     #[repr(C)]\n     struct DummyTab {\n@@ -19,7 +19,7 @@ fn test_dummy_module() {\n         base: sqlite3_vtab,\n     }\n \n-    impl VTab for DummyTab {\n+    unsafe impl VTab for DummyTab {\n         type Aux = ();\n         type Cursor = DummyTabCursor;\n \n@@ -53,7 +53,7 @@ fn test_dummy_module() {\n         row_id: i64,\n     }\n \n-    impl VTabCursor for DummyTabCursor {\n+    unsafe impl VTabCursor for DummyTabCursor {\n         fn filter(\n             &mut self,\n             _idx_num: c_int,\n",
    "diff_parsed": "{'added': [(14, '    let module = eponymous_only_module::<DummyTab>();'), (22, '    unsafe impl VTab for DummyTab {'), (56, '    unsafe impl VTabCursor for DummyTabCursor {')], 'deleted': [(14, '    let module = eponymous_only_module::<DummyTab>(1);'), (22, '    impl VTab for DummyTab {'), (56, '    impl VTabCursor for DummyTabCursor {')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "3",
    "nloc": "79"
  },
  {
    "file_change_id": "223607632924653",
    "hash": "01940637dd8f3bfeeee3faf9639fa9ae52f19f4d",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -79,7 +79,7 @@ macro_rules! array {\n         #[allow(unsafe_code)]\n         fn create_arr<T>(mut callback: impl FnMut(usize) -> T) -> [T; COUNT] {\n             let mut arr = $crate::__core::mem::MaybeUninit::uninit();\n-            let mut vec = $crate::__ArrayVec::<T>::new(arr.as_mut_ptr() as *mut T);\n+            let mut vec = $crate::__ArrayVec::<T>::new((&mut arr).as_mut_ptr() as *mut T);\n             unsafe {\n                 // Loop invariant: vec[..vec.length] is valid\n                 for i in 0..COUNT {\n@@ -90,8 +90,8 @@ macro_rules! array {\n                     //\n                     // The value is set before writing the value to avoid need to perform\n                     // addition by 1.\n-                    *vec.length() = i;\n-                    $crate::__core::ptr::write(vec.start().add(i), callback(i));\n+                    *(&mut vec).length() = i;\n+                    $crate::__core::ptr::write((&vec).start().add(i), callback(i));\n                 }\n                 // Loop escaped without panicking, avoid dropping elements.\n                 $crate::__core::mem::forget(vec);\n",
    "diff_parsed": "{'added': [(82, '            let mut vec = $crate::__ArrayVec::<T>::new((&mut arr).as_mut_ptr() as *mut T);'), (93, '                    *(&mut vec).length() = i;'), (94, '                    $crate::__core::ptr::write((&vec).start().add(i), callback(i));')], 'deleted': [(82, '            let mut vec = $crate::__ArrayVec::<T>::new(arr.as_mut_ptr() as *mut T);'), (93, '                    *vec.length() = i;'), (94, '                    $crate::__core::ptr::write(vec.start().add(i), callback(i));')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "3",
    "nloc": "59"
  },
  {
    "file_change_id": "21429780410938",
    "hash": "01940637dd8f3bfeeee3faf9639fa9ae52f19f4d",
    "old_path": "tests/test.rs",
    "new_path": "tests/test.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -108,3 +108,16 @@ fn array_of_void_panic_safety() {\n     }\n     internal(|| -> ! { panic!() });\n }\n+\n+#[test]\n+fn malicious_length() {\n+    trait Evil {\n+        fn length(&self) -> *mut usize;\n+    }\n+    impl<T> Evil for T {\n+        fn length(&self) -> *mut usize {\n+            42 as *mut usize\n+        }\n+    }\n+    assert_eq!(array![1; 3], [1, 1, 1]);\n+}\n",
    "diff_parsed": "{'added': [(112, '#[test]'), (113, 'fn malicious_length() {'), (114, '    trait Evil {'), (115, '        fn length(&self) -> *mut usize;'), (116, '    }'), (117, '    impl<T> Evil for T {'), (118, '        fn length(&self) -> *mut usize {'), (119, '            42 as *mut usize'), (120, '        }'), (121, '    }'), (122, '    assert_eq!(array![1; 3], [1, 1, 1]);'), (123, '}')], 'deleted': []}",
    "num_lines_added": "12",
    "num_lines_deleted": "0",
    "nloc": "107"
  },
  {
    "file_change_id": "171484328674567",
    "hash": "f7d120a3b724d06a7b623d0a4306acf8f78cb4f0",
    "old_path": "benches/lib.rs",
    "new_path": "benches/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -89,7 +89,8 @@ fn scoped_yield_bench(b: &mut Bencher) {\n             i += 1;\n             match v {\n                 Some(x) => {\n-                    assert_eq!(x, i);\n+                    dbg!(x, i);\n+                    // assert_eq!(x, i);\n                 }\n                 None => {\n                     // for elegant exit\n",
    "diff_parsed": "{'added': [(92, '                    dbg!(x, i);')], 'deleted': [(92, '                    assert_eq!(x, i);')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "147"
  },
  {
    "file_change_id": "214798149740711",
    "hash": "f7d120a3b724d06a7b623d0a4306acf8f78cb4f0",
    "old_path": "examples/pipe.rs",
    "new_path": "examples/pipe.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -2,7 +2,7 @@ use generator::*;\n \n fn main() {\n     // fn square<'a, T: Iterator<Item = u32> + 'a>(input: T) -> impl Iterator<Item = u32> + 'a {\n-    fn square<'a, T: Iterator<Item = u32> + 'a>(input: T) -> Generator<'a, (), u32> {\n+    fn square<'a, T: Iterator<Item = u32> + Send + 'a>(input: T) -> Generator<'a, (), u32> {\n         Gn::new_scoped(|mut s| {\n             for i in input {\n                 s.yield_with(i * i);\n@@ -12,7 +12,7 @@ fn main() {\n     }\n \n     // fn sum<'a, T: Iterator<Item = u32> + 'a>(input: T) -> impl Iterator<Item = u32> + 'a {\n-    fn sum<'a, T: Iterator<Item = u32> + 'a>(input: T) -> Generator<'a, (), u32> {\n+    fn sum<'a, T: Iterator<Item = u32> + Send + 'a>(input: T) -> Generator<'a, (), u32> {\n         Gn::new_scoped(|mut s| {\n             let mut acc = 0;\n             for i in input {\n",
    "diff_parsed": "{'added': [(5, \"    fn square<'a, T: Iterator<Item = u32> + Send + 'a>(input: T) -> Generator<'a, (), u32> {\"), (15, \"    fn sum<'a, T: Iterator<Item = u32> + Send + 'a>(input: T) -> Generator<'a, (), u32> {\")], 'deleted': [(5, \"    fn square<'a, T: Iterator<Item = u32> + 'a>(input: T) -> Generator<'a, (), u32> {\"), (15, \"    fn sum<'a, T: Iterator<Item = u32> + 'a>(input: T) -> Generator<'a, (), u32> {\")]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "26"
  },
  {
    "file_change_id": "156093184235271",
    "hash": "f7d120a3b724d06a7b623d0a4306acf8f78cb4f0",
    "old_path": "src/detail/aarch64_unix.rs",
    "new_path": "src/detail/aarch64_unix.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -42,9 +42,10 @@ pub fn initialize_call_frame(\n     const X19: usize = 19 - 19;\n     const X20: usize = 20 - 19;\n     const X21: usize = 21 - 19;\n-    const FP: usize  = 29 - 19;\n-    const LR: usize  = 30 - 19;\n-    const SP: usize  = 31 - 19;\n+\n+    const FP: usize = 29 - 19;\n+    const LR: usize = 30 - 19;\n+    const SP: usize = 31 - 19;\n     \n     let sp = align_down(stack.end());\n \n@@ -56,7 +57,7 @@ pub fn initialize_call_frame(\n \n     // Aarch64 current stack frame pointer\n     regs.gpr[FP] = sp as usize;\n-    \n+\n     regs.gpr[LR] = bootstrap_green_task as usize;\n \n     // setup the init stack\n",
    "diff_parsed": "{'added': [(46, '    const FP: usize = 29 - 19;'), (47, '    const LR: usize = 30 - 19;'), (48, '    const SP: usize = 31 - 19;')], 'deleted': [(45, '    const FP: usize  = 29 - 19;'), (46, '    const LR: usize  = 30 - 19;'), (47, '    const SP: usize  = 31 - 19;')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "3",
    "nloc": "47"
  },
  {
    "file_change_id": "211900757439486",
    "hash": "f7d120a3b724d06a7b623d0a4306acf8f78cb4f0",
    "old_path": "src/gen_impl.rs",
    "new_path": "src/gen_impl.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -19,14 +19,52 @@ use crate::yield_::yield_now;\n // windows has a minimal size as 0x4a8!!!!\n pub const DEFAULT_STACK_SIZE: usize = 0x1000;\n \n-/// the generator type\n-pub struct Generator<'a, A, T> {\n+/// the generator obj type, the functor passed to it must be Send\n+pub struct GeneratorObj<'a, A, T, const LOCAL: bool> {\n     gen: StackBox<GeneratorImpl<'a, A, T>>,\n }\n \n-unsafe impl<A, T> Send for Generator<'static, A, T> {}\n+/// the generator type, the functor passed to it must be Send\n+pub type Generator<'a, A, T> = GeneratorObj<'a, A, T, false>;\n+\n+// only when A, T and Functor are all sendable, the generator could be send\n+unsafe impl<A: Send, T: Send> Send for Generator<'static, A, T> {}\n \n impl<'a, A, T> Generator<'a, A, T> {\n+    /// init a heap based generator with scoped closure\n+    pub fn scoped_init<F: FnOnce(Scope<'a, A, T>) -> T + Send + 'a>(&mut self, f: F)\n+    where\n+        T: Send + 'a,\n+        A: Send + 'a,\n+    {\n+        self.gen.scoped_init(f);\n+    }\n+\n+    /// init a heap based generator\n+    // it's can be used to re-init a 'done' generator before it's get dropped\n+    pub fn init_code<F: FnOnce() -> T + Send + 'a>(&mut self, f: F)\n+    where\n+        T: Send + 'a,\n+    {\n+        self.gen.init_code(f);\n+    }\n+}\n+\n+/// the local generator type, can't Send\n+pub type LocalGenerator<'a, A, T> = GeneratorObj<'a, A, T, true>;\n+\n+impl<'a, A, T> LocalGenerator<'a, A, T> {\n+    /// init a heap based generator with scoped closure\n+    pub fn scoped_init<F: FnOnce(Scope<'a, A, T>) -> T + 'a>(&mut self, f: F)\n+    where\n+        T: 'a,\n+        A: 'a,\n+    {\n+        self.gen.scoped_init(f);\n+    }\n+}\n+\n+impl<'a, A, T, const LOCAL: bool> GeneratorObj<'a, A, T, LOCAL> {\n     /// Constructs a Generator from a raw pointer.\n     ///\n     /// # Safety\n@@ -36,7 +74,7 @@ impl<'a, A, T> Generator<'a, A, T> {\n     /// function is called twice on the same raw pointer.\n     #[inline]\n     pub unsafe fn from_raw(raw: *mut usize) -> Self {\n-        Generator {\n+        GeneratorObj {\n             gen: StackBox::from_raw(raw as *mut GeneratorImpl<'a, A, T>),\n         }\n     }\n@@ -55,24 +93,6 @@ impl<'a, A, T> Generator<'a, A, T> {\n         self.gen.prefetch();\n     }\n \n-    /// init a heap based generator with scoped closure\n-    pub fn scoped_init<F: FnOnce(Scope<'a, A, T>) -> T + 'a>(&mut self, f: F)\n-    where\n-        T: 'a,\n-        A: 'a,\n-    {\n-        self.gen.scoped_init(f);\n-    }\n-\n-    /// init a heap based generator\n-    // it's can be used to re-init a 'done' generator before it's get dropped\n-    pub fn init_code<F: FnOnce() -> T + 'a>(&mut self, f: F)\n-    where\n-        T: 'a,\n-    {\n-        self.gen.init_code(f);\n-    }\n-\n     /// prepare the para that passed into generator before send\n     #[inline]\n     pub fn set_para(&mut self, para: A) {\n@@ -136,23 +156,24 @@ impl<'a, A, T> Generator<'a, A, T> {\n     }\n }\n \n-impl<'a, T> Iterator for Generator<'a, (), T> {\n+impl<'a, T, const LOCAL: bool> Iterator for GeneratorObj<'a, (), T, LOCAL> {\n     type Item = T;\n     fn next(&mut self) -> Option<T> {\n         self.resume()\n     }\n }\n \n-impl<'a, A, T> fmt::Debug for Generator<'a, A, T> {\n+impl<'a, A, T, const LOCAL: bool> fmt::Debug for GeneratorObj<'a, A, T, LOCAL> {\n     #[cfg(nightly)]\n     #[allow(unused_unsafe)]\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         use std::intrinsics::type_name;\n         write!(\n             f,\n-            \"Generator<{}, Output={}> {{ ... }}\",\n+            \"Generator<{}, Output={}, Local={}> {{ ... }}\",\n             unsafe { type_name::<A>() },\n-            unsafe { type_name::<T>() }\n+            unsafe { type_name::<T>() },\n+            LOCAL\n         )\n     }\n \n@@ -170,16 +191,38 @@ pub struct Gn<A = ()> {\n impl<A> Gn<A> {\n     /// create a scoped generator with default stack size\n     pub fn new_scoped<'a, T, F>(f: F) -> Generator<'a, A, T>\n+    where\n+        F: FnOnce(Scope<A, T>) -> T + Send + 'a,\n+        T: Send+ 'a,\n+        A: Send + 'a,\n+    {\n+        Self::new_scoped_opt(DEFAULT_STACK_SIZE, f)\n+    }\n+\n+    /// create a scoped local generator with default stack size\n+    pub fn new_scoped_local<'a, T, F>(f: F) -> LocalGenerator<'a, A, T>\n     where\n         F: FnOnce(Scope<A, T>) -> T + 'a,\n         T: 'a,\n         A: 'a,\n     {\n-        Self::new_scoped_opt(DEFAULT_STACK_SIZE, f)\n+        Self::new_scoped_opt_local(DEFAULT_STACK_SIZE, f)\n     }\n \n     /// create a scoped generator with specified stack size\n     pub fn new_scoped_opt<'a, T, F>(size: usize, f: F) -> Generator<'a, A, T>\n+    where\n+        F: FnOnce(Scope<A, T>) -> T + Send + 'a,\n+        T: Send + 'a,\n+        A: Send + 'a,\n+    {\n+        let mut gen = GeneratorImpl::<A, T>::new(Stack::new(size));\n+        gen.scoped_init(f);\n+        Generator { gen }\n+    }\n+\n+    /// create a scoped local generator with specified stack size\n+    pub fn new_scoped_opt_local<'a, T, F>(size: usize, f: F) -> LocalGenerator<'a, A, T>\n     where\n         F: FnOnce(Scope<A, T>) -> T + 'a,\n         T: 'a,\n@@ -187,7 +230,7 @@ impl<A> Gn<A> {\n     {\n         let mut gen = GeneratorImpl::<A, T>::new(Stack::new(size));\n         gen.scoped_init(f);\n-        Generator { gen }\n+        LocalGenerator { gen }\n     }\n }\n \n@@ -197,7 +240,7 @@ impl<A: Any> Gn<A> {\n     #[deprecated(since = \"0.6.18\", note = \"please use `scope` version instead\")]\n     pub fn new<'a, T: Any, F>(f: F) -> Generator<'a, A, T>\n     where\n-        F: FnOnce() -> T + 'a,\n+        F: FnOnce() -> T + Send + 'a,\n     {\n         Self::new_opt(DEFAULT_STACK_SIZE, f)\n     }\n@@ -206,7 +249,7 @@ impl<A: Any> Gn<A> {\n     // the `may` library use this API so we can't deprecated it yet.\n     pub fn new_opt<'a, T: Any, F>(size: usize, f: F) -> Generator<'a, A, T>\n     where\n-        F: FnOnce() -> T + 'a,\n+        F: FnOnce() -> T + Send + 'a,\n     {\n         let mut gen = GeneratorImpl::<A, T>::new(Stack::new(size));\n         gen.init_context();\n",
    "diff_parsed": "{'added': [(23, \"pub struct GeneratorObj<'a, A, T, const LOCAL: bool> {\"), (28, \"pub type Generator<'a, A, T> = GeneratorObj<'a, A, T, false>;\"), (31, \"unsafe impl<A: Send, T: Send> Send for Generator<'static, A, T> {}\"), (35, \"    pub fn scoped_init<F: FnOnce(Scope<'a, A, T>) -> T + Send + 'a>(&mut self, f: F)\"), (36, '    where'), (37, \"        T: Send + 'a,\"), (38, \"        A: Send + 'a,\"), (39, '    {'), (40, '        self.gen.scoped_init(f);'), (41, '    }'), (45, \"    pub fn init_code<F: FnOnce() -> T + Send + 'a>(&mut self, f: F)\"), (46, '    where'), (47, \"        T: Send + 'a,\"), (48, '    {'), (49, '        self.gen.init_code(f);'), (50, '    }'), (51, '}'), (54, \"pub type LocalGenerator<'a, A, T> = GeneratorObj<'a, A, T, true>;\"), (56, \"impl<'a, A, T> LocalGenerator<'a, A, T> {\"), (58, \"    pub fn scoped_init<F: FnOnce(Scope<'a, A, T>) -> T + 'a>(&mut self, f: F)\"), (59, '    where'), (60, \"        T: 'a,\"), (61, \"        A: 'a,\"), (62, '    {'), (63, '        self.gen.scoped_init(f);'), (64, '    }'), (65, '}'), (67, \"impl<'a, A, T, const LOCAL: bool> GeneratorObj<'a, A, T, LOCAL> {\"), (77, '        GeneratorObj {'), (159, \"impl<'a, T, const LOCAL: bool> Iterator for GeneratorObj<'a, (), T, LOCAL> {\"), (166, \"impl<'a, A, T, const LOCAL: bool> fmt::Debug for GeneratorObj<'a, A, T, LOCAL> {\"), (173, '            \"Generator<{}, Output={}, Local={}> {{ ... }}\",'), (175, '            unsafe { type_name::<T>() },'), (176, '            LOCAL'), (194, '    where'), (195, \"        F: FnOnce(Scope<A, T>) -> T + Send + 'a,\"), (196, \"        T: Send+ 'a,\"), (197, \"        A: Send + 'a,\"), (198, '    {'), (199, '        Self::new_scoped_opt(DEFAULT_STACK_SIZE, f)'), (200, '    }'), (203, \"    pub fn new_scoped_local<'a, T, F>(f: F) -> LocalGenerator<'a, A, T>\"), (209, '        Self::new_scoped_opt_local(DEFAULT_STACK_SIZE, f)'), (214, '    where'), (215, \"        F: FnOnce(Scope<A, T>) -> T + Send + 'a,\"), (216, \"        T: Send + 'a,\"), (217, \"        A: Send + 'a,\"), (218, '    {'), (219, '        let mut gen = GeneratorImpl::<A, T>::new(Stack::new(size));'), (220, '        gen.scoped_init(f);'), (221, '        Generator { gen }'), (222, '    }'), (225, \"    pub fn new_scoped_opt_local<'a, T, F>(size: usize, f: F) -> LocalGenerator<'a, A, T>\"), (233, '        LocalGenerator { gen }'), (243, \"        F: FnOnce() -> T + Send + 'a,\"), (252, \"        F: FnOnce() -> T + Send + 'a,\")], 'deleted': [(23, \"pub struct Generator<'a, A, T> {\"), (27, \"unsafe impl<A, T> Send for Generator<'static, A, T> {}\"), (39, '        Generator {'), (59, \"    pub fn scoped_init<F: FnOnce(Scope<'a, A, T>) -> T + 'a>(&mut self, f: F)\"), (60, '    where'), (61, \"        T: 'a,\"), (62, \"        A: 'a,\"), (63, '    {'), (64, '        self.gen.scoped_init(f);'), (65, '    }'), (69, \"    pub fn init_code<F: FnOnce() -> T + 'a>(&mut self, f: F)\"), (70, '    where'), (71, \"        T: 'a,\"), (72, '    {'), (73, '        self.gen.init_code(f);'), (74, '    }'), (139, \"impl<'a, T> Iterator for Generator<'a, (), T> {\"), (146, \"impl<'a, A, T> fmt::Debug for Generator<'a, A, T> {\"), (153, '            \"Generator<{}, Output={}> {{ ... }}\",'), (155, '            unsafe { type_name::<T>() }'), (178, '        Self::new_scoped_opt(DEFAULT_STACK_SIZE, f)'), (190, '        Generator { gen }'), (200, \"        F: FnOnce() -> T + 'a,\"), (209, \"        F: FnOnce() -> T + 'a,\")]}",
    "num_lines_added": "56",
    "num_lines_deleted": "24",
    "nloc": "413"
  },
  {
    "file_change_id": "42292843658391",
    "hash": "f7d120a3b724d06a7b623d0a4306acf8f78cb4f0",
    "old_path": "tests/lib.rs",
    "new_path": "tests/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -125,9 +125,9 @@ fn test_scoped() {\n     let x = Rc::new(RefCell::new(10));\n \n     let x1 = x.clone();\n-    let mut g = Gn::<()>::new(move || {\n+    let mut g = Gn::<()>::new_scoped_local(move |mut s| {\n         *x1.borrow_mut() = 20;\n-        yield_with(());\n+        s.yield_with(());\n         *x1.borrow_mut() = 5;\n     });\n \n@@ -221,8 +221,7 @@ fn test_ill_drop() {\n fn test_loop_drop() {\n     let mut x = 10u32;\n     {\n-        // rust 1.17 can't deduce the output type!\n-        let mut g: Generator<_, ()> = Gn::<()>::new(|| {\n+        let mut g = Gn::<()>::new(|| {\n             x = 5;\n             loop {\n                 yield_with(());\n",
    "diff_parsed": "{'added': [(128, '    let mut g = Gn::<()>::new_scoped_local(move |mut s| {'), (130, '        s.yield_with(());'), (224, '        let mut g = Gn::<()>::new(|| {')], 'deleted': [(128, '    let mut g = Gn::<()>::new(move || {'), (130, '        yield_with(());'), (225, '        let mut g: Generator<_, ()> = Gn::<()>::new(|| {')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "3",
    "nloc": "371"
  },
  {
    "file_change_id": "260143976189045",
    "hash": "e965d8298f421e9c89fe98b1300b8361e948c324",
    "old_path": "None",
    "new_path": "actix-http/src/h1/chunked.rs",
    "change_type": "ModificationType.ADD",
    "diff": "@@ -0,0 +1,432 @@\n+use std::{io, task::Poll};\n+\n+use bytes::{Buf as _, Bytes, BytesMut};\n+\n+macro_rules! byte (\n+    ($rdr:ident) => ({\n+        if $rdr.len() > 0 {\n+            let b = $rdr[0];\n+            $rdr.advance(1);\n+            b\n+        } else {\n+            return Poll::Pending\n+        }\n+    })\n+);\n+\n+#[derive(Debug, PartialEq, Clone)]\n+pub(super) enum ChunkedState {\n+    Size,\n+    SizeLws,\n+    Extension,\n+    SizeLf,\n+    Body,\n+    BodyCr,\n+    BodyLf,\n+    EndCr,\n+    EndLf,\n+    End,\n+}\n+\n+impl ChunkedState {\n+    pub(super) fn step(\n+        &self,\n+        body: &mut BytesMut,\n+        size: &mut u64,\n+        buf: &mut Option<Bytes>,\n+    ) -> Poll<Result<ChunkedState, io::Error>> {\n+        use self::ChunkedState::*;\n+        match *self {\n+            Size => ChunkedState::read_size(body, size),\n+            SizeLws => ChunkedState::read_size_lws(body),\n+            Extension => ChunkedState::read_extension(body),\n+            SizeLf => ChunkedState::read_size_lf(body, size),\n+            Body => ChunkedState::read_body(body, size, buf),\n+            BodyCr => ChunkedState::read_body_cr(body),\n+            BodyLf => ChunkedState::read_body_lf(body),\n+            EndCr => ChunkedState::read_end_cr(body),\n+            EndLf => ChunkedState::read_end_lf(body),\n+            End => Poll::Ready(Ok(ChunkedState::End)),\n+        }\n+    }\n+\n+    fn read_size(\n+        rdr: &mut BytesMut,\n+        size: &mut u64,\n+    ) -> Poll<Result<ChunkedState, io::Error>> {\n+        let radix = 16;\n+\n+        let rem = match byte!(rdr) {\n+            b @ b'0'..=b'9' => b - b'0',\n+            b @ b'a'..=b'f' => b + 10 - b'a',\n+            b @ b'A'..=b'F' => b + 10 - b'A',\n+            b'\\t' | b' ' => return Poll::Ready(Ok(ChunkedState::SizeLws)),\n+            b';' => return Poll::Ready(Ok(ChunkedState::Extension)),\n+            b'\\r' => return Poll::Ready(Ok(ChunkedState::SizeLf)),\n+            _ => {\n+                return Poll::Ready(Err(io::Error::new(\n+                    io::ErrorKind::InvalidInput,\n+                    \"Invalid chunk size line: Invalid Size\",\n+                )));\n+            }\n+        };\n+\n+        match size.checked_mul(radix) {\n+            Some(n) => {\n+                *size = n as u64;\n+                *size += rem as u64;\n+\n+                Poll::Ready(Ok(ChunkedState::Size))\n+            }\n+            None => {\n+                log::debug!(\"chunk size would overflow u64\");\n+                Poll::Ready(Err(io::Error::new(\n+                    io::ErrorKind::InvalidInput,\n+                    \"Invalid chunk size line: Size is too big\",\n+                )))\n+            }\n+        }\n+    }\n+\n+    fn read_size_lws(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {\n+        match byte!(rdr) {\n+            // LWS can follow the chunk size, but no more digits can come\n+            b'\\t' | b' ' => Poll::Ready(Ok(ChunkedState::SizeLws)),\n+            b';' => Poll::Ready(Ok(ChunkedState::Extension)),\n+            b'\\r' => Poll::Ready(Ok(ChunkedState::SizeLf)),\n+            _ => Poll::Ready(Err(io::Error::new(\n+                io::ErrorKind::InvalidInput,\n+                \"Invalid chunk size linear white space\",\n+            ))),\n+        }\n+    }\n+    fn read_extension(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {\n+        match byte!(rdr) {\n+            b'\\r' => Poll::Ready(Ok(ChunkedState::SizeLf)),\n+            // strictly 0x20 (space) should be disallowed but we don't parse quoted strings here\n+            0x00..=0x08 | 0x0a..=0x1f | 0x7f => Poll::Ready(Err(io::Error::new(\n+                io::ErrorKind::InvalidInput,\n+                \"Invalid character in chunk extension\",\n+            ))),\n+            _ => Poll::Ready(Ok(ChunkedState::Extension)), // no supported extensions\n+        }\n+    }\n+    fn read_size_lf(\n+        rdr: &mut BytesMut,\n+        size: &mut u64,\n+    ) -> Poll<Result<ChunkedState, io::Error>> {\n+        match byte!(rdr) {\n+            b'\\n' if *size > 0 => Poll::Ready(Ok(ChunkedState::Body)),\n+            b'\\n' if *size == 0 => Poll::Ready(Ok(ChunkedState::EndCr)),\n+            _ => Poll::Ready(Err(io::Error::new(\n+                io::ErrorKind::InvalidInput,\n+                \"Invalid chunk size LF\",\n+            ))),\n+        }\n+    }\n+\n+    fn read_body(\n+        rdr: &mut BytesMut,\n+        rem: &mut u64,\n+        buf: &mut Option<Bytes>,\n+    ) -> Poll<Result<ChunkedState, io::Error>> {\n+        log::trace!(\"Chunked read, remaining={:?}\", rem);\n+\n+        let len = rdr.len() as u64;\n+        if len == 0 {\n+            Poll::Ready(Ok(ChunkedState::Body))\n+        } else {\n+            let slice;\n+            if *rem > len {\n+                slice = rdr.split().freeze();\n+                *rem -= len;\n+            } else {\n+                slice = rdr.split_to(*rem as usize).freeze();\n+                *rem = 0;\n+            }\n+            *buf = Some(slice);\n+            if *rem > 0 {\n+                Poll::Ready(Ok(ChunkedState::Body))\n+            } else {\n+                Poll::Ready(Ok(ChunkedState::BodyCr))\n+            }\n+        }\n+    }\n+\n+    fn read_body_cr(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {\n+        match byte!(rdr) {\n+            b'\\r' => Poll::Ready(Ok(ChunkedState::BodyLf)),\n+            _ => Poll::Ready(Err(io::Error::new(\n+                io::ErrorKind::InvalidInput,\n+                \"Invalid chunk body CR\",\n+            ))),\n+        }\n+    }\n+    fn read_body_lf(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {\n+        match byte!(rdr) {\n+            b'\\n' => Poll::Ready(Ok(ChunkedState::Size)),\n+            _ => Poll::Ready(Err(io::Error::new(\n+                io::ErrorKind::InvalidInput,\n+                \"Invalid chunk body LF\",\n+            ))),\n+        }\n+    }\n+    fn read_end_cr(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {\n+        match byte!(rdr) {\n+            b'\\r' => Poll::Ready(Ok(ChunkedState::EndLf)),\n+            _ => Poll::Ready(Err(io::Error::new(\n+                io::ErrorKind::InvalidInput,\n+                \"Invalid chunk end CR\",\n+            ))),\n+        }\n+    }\n+    fn read_end_lf(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {\n+        match byte!(rdr) {\n+            b'\\n' => Poll::Ready(Ok(ChunkedState::End)),\n+            _ => Poll::Ready(Err(io::Error::new(\n+                io::ErrorKind::InvalidInput,\n+                \"Invalid chunk end LF\",\n+            ))),\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use actix_codec::Decoder as _;\n+    use bytes::{Bytes, BytesMut};\n+    use http::Method;\n+\n+    use crate::{\n+        error::ParseError,\n+        h1::decoder::{MessageDecoder, PayloadItem},\n+        HttpMessage as _, Request,\n+    };\n+\n+    macro_rules! parse_ready {\n+        ($e:expr) => {{\n+            match MessageDecoder::<Request>::default().decode($e) {\n+                Ok(Some((msg, _))) => msg,\n+                Ok(_) => unreachable!(\"Eof during parsing http request\"),\n+                Err(err) => unreachable!(\"Error during parsing http request: {:?}\", err),\n+            }\n+        }};\n+    }\n+\n+    macro_rules! expect_parse_err {\n+        ($e:expr) => {{\n+            match MessageDecoder::<Request>::default().decode($e) {\n+                Err(err) => match err {\n+                    ParseError::Io(_) => unreachable!(\"Parse error expected\"),\n+                    _ => {}\n+                },\n+                _ => unreachable!(\"Error expected\"),\n+            }\n+        }};\n+    }\n+\n+    #[test]\n+    fn test_parse_chunked_payload_chunk_extension() {\n+        let mut buf = BytesMut::from(\n+            \"GET /test HTTP/1.1\\r\\n\\\n+            transfer-encoding: chunked\\r\\n\\\n+            \\r\\n\",\n+        );\n+\n+        let mut reader = MessageDecoder::<Request>::default();\n+        let (msg, pl) = reader.decode(&mut buf).unwrap().unwrap();\n+        let mut pl = pl.unwrap();\n+        assert!(msg.chunked().unwrap());\n+\n+        buf.extend(b\"4;test\\r\\ndata\\r\\n4\\r\\nline\\r\\n0\\r\\n\\r\\n\"); // test: test\\r\\n\\r\\n\")\n+        let chunk = pl.decode(&mut buf).unwrap().unwrap().chunk();\n+        assert_eq!(chunk, Bytes::from_static(b\"data\"));\n+        let chunk = pl.decode(&mut buf).unwrap().unwrap().chunk();\n+        assert_eq!(chunk, Bytes::from_static(b\"line\"));\n+        let msg = pl.decode(&mut buf).unwrap().unwrap();\n+        assert!(msg.eof());\n+    }\n+\n+    #[test]\n+    fn test_request_chunked() {\n+        let mut buf = BytesMut::from(\n+            \"GET /test HTTP/1.1\\r\\n\\\n+             transfer-encoding: chunked\\r\\n\\r\\n\",\n+        );\n+        let req = parse_ready!(&mut buf);\n+\n+        if let Ok(val) = req.chunked() {\n+            assert!(val);\n+        } else {\n+            unreachable!(\"Error\");\n+        }\n+\n+        // intentional typo in \"chunked\"\n+        let mut buf = BytesMut::from(\n+            \"GET /test HTTP/1.1\\r\\n\\\n+             transfer-encoding: chnked\\r\\n\\r\\n\",\n+        );\n+        expect_parse_err!(&mut buf);\n+    }\n+\n+    #[test]\n+    fn test_http_request_chunked_payload() {\n+        let mut buf = BytesMut::from(\n+            \"GET /test HTTP/1.1\\r\\n\\\n+             transfer-encoding: chunked\\r\\n\\r\\n\",\n+        );\n+        let mut reader = MessageDecoder::<Request>::default();\n+        let (req, pl) = reader.decode(&mut buf).unwrap().unwrap();\n+        let mut pl = pl.unwrap();\n+        assert!(req.chunked().unwrap());\n+\n+        buf.extend(b\"4\\r\\ndata\\r\\n4\\r\\nline\\r\\n0\\r\\n\\r\\n\");\n+        assert_eq!(\n+            pl.decode(&mut buf).unwrap().unwrap().chunk().as_ref(),\n+            b\"data\"\n+        );\n+        assert_eq!(\n+            pl.decode(&mut buf).unwrap().unwrap().chunk().as_ref(),\n+            b\"line\"\n+        );\n+        assert!(pl.decode(&mut buf).unwrap().unwrap().eof());\n+    }\n+\n+    #[test]\n+    fn test_http_request_chunked_payload_and_next_message() {\n+        let mut buf = BytesMut::from(\n+            \"GET /test HTTP/1.1\\r\\n\\\n+             transfer-encoding: chunked\\r\\n\\r\\n\",\n+        );\n+        let mut reader = MessageDecoder::<Request>::default();\n+        let (req, pl) = reader.decode(&mut buf).unwrap().unwrap();\n+        let mut pl = pl.unwrap();\n+        assert!(req.chunked().unwrap());\n+\n+        buf.extend(\n+            b\"4\\r\\ndata\\r\\n4\\r\\nline\\r\\n0\\r\\n\\r\\n\\\n+              POST /test2 HTTP/1.1\\r\\n\\\n+              transfer-encoding: chunked\\r\\n\\r\\n\"\n+                .iter(),\n+        );\n+        let msg = pl.decode(&mut buf).unwrap().unwrap();\n+        assert_eq!(msg.chunk().as_ref(), b\"data\");\n+        let msg = pl.decode(&mut buf).unwrap().unwrap();\n+        assert_eq!(msg.chunk().as_ref(), b\"line\");\n+        let msg = pl.decode(&mut buf).unwrap().unwrap();\n+        assert!(msg.eof());\n+\n+        let (req, _) = reader.decode(&mut buf).unwrap().unwrap();\n+        assert!(req.chunked().unwrap());\n+        assert_eq!(*req.method(), Method::POST);\n+        assert!(req.chunked().unwrap());\n+    }\n+\n+    #[test]\n+    fn test_http_request_chunked_payload_chunks() {\n+        let mut buf = BytesMut::from(\n+            \"GET /test HTTP/1.1\\r\\n\\\n+             transfer-encoding: chunked\\r\\n\\r\\n\",\n+        );\n+\n+        let mut reader = MessageDecoder::<Request>::default();\n+        let (req, pl) = reader.decode(&mut buf).unwrap().unwrap();\n+        let mut pl = pl.unwrap();\n+        assert!(req.chunked().unwrap());\n+\n+        buf.extend(b\"4\\r\\n1111\\r\\n\");\n+        let msg = pl.decode(&mut buf).unwrap().unwrap();\n+        assert_eq!(msg.chunk().as_ref(), b\"1111\");\n+\n+        buf.extend(b\"4\\r\\ndata\\r\");\n+        let msg = pl.decode(&mut buf).unwrap().unwrap();\n+        assert_eq!(msg.chunk().as_ref(), b\"data\");\n+\n+        buf.extend(b\"\\n4\");\n+        assert!(pl.decode(&mut buf).unwrap().is_none());\n+\n+        buf.extend(b\"\\r\");\n+        assert!(pl.decode(&mut buf).unwrap().is_none());\n+        buf.extend(b\"\\n\");\n+        assert!(pl.decode(&mut buf).unwrap().is_none());\n+\n+        buf.extend(b\"li\");\n+        let msg = pl.decode(&mut buf).unwrap().unwrap();\n+        assert_eq!(msg.chunk().as_ref(), b\"li\");\n+\n+        //trailers\n+        //buf.feed_data(\"test: test\\r\\n\");\n+        //not_ready!(reader.parse(&mut buf, &mut readbuf));\n+\n+        buf.extend(b\"ne\\r\\n0\\r\\n\");\n+        let msg = pl.decode(&mut buf).unwrap().unwrap();\n+        assert_eq!(msg.chunk().as_ref(), b\"ne\");\n+        assert!(pl.decode(&mut buf).unwrap().is_none());\n+\n+        buf.extend(b\"\\r\\n\");\n+        assert!(pl.decode(&mut buf).unwrap().unwrap().eof());\n+    }\n+\n+    #[test]\n+    fn chunk_extension_quoted() {\n+        let mut buf = BytesMut::from(\n+            \"GET /test HTTP/1.1\\r\\n\\\n+            Host: localhost:8080\\r\\n\\\n+            Transfer-Encoding: chunked\\r\\n\\\n+            \\r\\n\\\n+            2;hello=b;one=\\\"1 2 3\\\"\\r\\n\\\n+            xx\",\n+        );\n+\n+        let mut reader = MessageDecoder::<Request>::default();\n+        let (_msg, pl) = reader.decode(&mut buf).unwrap().unwrap();\n+        let mut pl = pl.unwrap();\n+\n+        let chunk = pl.decode(&mut buf).unwrap().unwrap();\n+        assert_eq!(chunk, PayloadItem::Chunk(Bytes::from_static(b\"xx\")));\n+    }\n+\n+    #[test]\n+    fn hrs_chunk_extension_invalid() {\n+        let mut buf = BytesMut::from(\n+            \"GET / HTTP/1.1\\r\\n\\\n+            Host: localhost:8080\\r\\n\\\n+            Transfer-Encoding: chunked\\r\\n\\\n+            \\r\\n\\\n+            2;x\\nx\\r\\n\\\n+            4c\\r\\n\\\n+            0\\r\\n\",\n+        );\n+\n+        let mut reader = MessageDecoder::<Request>::default();\n+        let (_msg, pl) = reader.decode(&mut buf).unwrap().unwrap();\n+        let mut pl = pl.unwrap();\n+\n+        let err = pl.decode(&mut buf).unwrap_err();\n+        assert!(err\n+            .to_string()\n+            .contains(\"Invalid character in chunk extension\"));\n+    }\n+\n+    #[test]\n+    fn hrs_chunk_size_overflow() {\n+        let mut buf = BytesMut::from(\n+            \"GET / HTTP/1.1\\r\\n\\\n+            Host: example.com\\r\\n\\\n+            Transfer-Encoding: chunked\\r\\n\\\n+            \\r\\n\\\n+            f0000000000000003\\r\\n\\\n+            abc\\r\\n\\\n+            0\\r\\n\",\n+        );\n+\n+        let mut reader = MessageDecoder::<Request>::default();\n+        let (_msg, pl) = reader.decode(&mut buf).unwrap().unwrap();\n+        let mut pl = pl.unwrap();\n+\n+        let err = pl.decode(&mut buf).unwrap_err();\n+        assert!(err\n+            .to_string()\n+            .contains(\"Invalid chunk size line: Size is too big\"));\n+    }\n+}\n",
    "diff_parsed": "{'added': [(1, 'use std::{io, task::Poll};'), (3, 'use bytes::{Buf as _, Bytes, BytesMut};'), (5, 'macro_rules! byte ('), (6, '    ($rdr:ident) => ({'), (7, '        if $rdr.len() > 0 {'), (8, '            let b = $rdr[0];'), (9, '            $rdr.advance(1);'), (10, '            b'), (11, '        } else {'), (12, '            return Poll::Pending'), (13, '        }'), (14, '    })'), (15, ');'), (17, '#[derive(Debug, PartialEq, Clone)]'), (18, 'pub(super) enum ChunkedState {'), (19, '    Size,'), (20, '    SizeLws,'), (21, '    Extension,'), (22, '    SizeLf,'), (23, '    Body,'), (24, '    BodyCr,'), (25, '    BodyLf,'), (26, '    EndCr,'), (27, '    EndLf,'), (28, '    End,'), (29, '}'), (31, 'impl ChunkedState {'), (32, '    pub(super) fn step('), (33, '        &self,'), (34, '        body: &mut BytesMut,'), (35, '        size: &mut u64,'), (36, '        buf: &mut Option<Bytes>,'), (37, '    ) -> Poll<Result<ChunkedState, io::Error>> {'), (38, '        use self::ChunkedState::*;'), (39, '        match *self {'), (40, '            Size => ChunkedState::read_size(body, size),'), (41, '            SizeLws => ChunkedState::read_size_lws(body),'), (42, '            Extension => ChunkedState::read_extension(body),'), (43, '            SizeLf => ChunkedState::read_size_lf(body, size),'), (44, '            Body => ChunkedState::read_body(body, size, buf),'), (45, '            BodyCr => ChunkedState::read_body_cr(body),'), (46, '            BodyLf => ChunkedState::read_body_lf(body),'), (47, '            EndCr => ChunkedState::read_end_cr(body),'), (48, '            EndLf => ChunkedState::read_end_lf(body),'), (49, '            End => Poll::Ready(Ok(ChunkedState::End)),'), (50, '        }'), (51, '    }'), (53, '    fn read_size('), (54, '        rdr: &mut BytesMut,'), (55, '        size: &mut u64,'), (56, '    ) -> Poll<Result<ChunkedState, io::Error>> {'), (57, '        let radix = 16;'), (59, '        let rem = match byte!(rdr) {'), (60, \"            b @ b'0'..=b'9' => b - b'0',\"), (61, \"            b @ b'a'..=b'f' => b + 10 - b'a',\"), (62, \"            b @ b'A'..=b'F' => b + 10 - b'A',\"), (63, \"            b'\\\\t' | b' ' => return Poll::Ready(Ok(ChunkedState::SizeLws)),\"), (64, \"            b';' => return Poll::Ready(Ok(ChunkedState::Extension)),\"), (65, \"            b'\\\\r' => return Poll::Ready(Ok(ChunkedState::SizeLf)),\"), (66, '            _ => {'), (67, '                return Poll::Ready(Err(io::Error::new('), (68, '                    io::ErrorKind::InvalidInput,'), (69, '                    \"Invalid chunk size line: Invalid Size\",'), (70, '                )));'), (71, '            }'), (72, '        };'), (74, '        match size.checked_mul(radix) {'), (75, '            Some(n) => {'), (76, '                *size = n as u64;'), (77, '                *size += rem as u64;'), (79, '                Poll::Ready(Ok(ChunkedState::Size))'), (80, '            }'), (81, '            None => {'), (82, '                log::debug!(\"chunk size would overflow u64\");'), (83, '                Poll::Ready(Err(io::Error::new('), (84, '                    io::ErrorKind::InvalidInput,'), (85, '                    \"Invalid chunk size line: Size is too big\",'), (86, '                )))'), (87, '            }'), (88, '        }'), (89, '    }'), (91, '    fn read_size_lws(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {'), (92, '        match byte!(rdr) {'), (94, \"            b'\\\\t' | b' ' => Poll::Ready(Ok(ChunkedState::SizeLws)),\"), (95, \"            b';' => Poll::Ready(Ok(ChunkedState::Extension)),\"), (96, \"            b'\\\\r' => Poll::Ready(Ok(ChunkedState::SizeLf)),\"), (97, '            _ => Poll::Ready(Err(io::Error::new('), (98, '                io::ErrorKind::InvalidInput,'), (99, '                \"Invalid chunk size linear white space\",'), (100, '            ))),'), (101, '        }'), (102, '    }'), (103, '    fn read_extension(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {'), (104, '        match byte!(rdr) {'), (105, \"            b'\\\\r' => Poll::Ready(Ok(ChunkedState::SizeLf)),\"), (107, '            0x00..=0x08 | 0x0a..=0x1f | 0x7f => Poll::Ready(Err(io::Error::new('), (108, '                io::ErrorKind::InvalidInput,'), (109, '                \"Invalid character in chunk extension\",'), (110, '            ))),'), (111, '            _ => Poll::Ready(Ok(ChunkedState::Extension)), // no supported extensions'), (112, '        }'), (113, '    }'), (114, '    fn read_size_lf('), (115, '        rdr: &mut BytesMut,'), (116, '        size: &mut u64,'), (117, '    ) -> Poll<Result<ChunkedState, io::Error>> {'), (118, '        match byte!(rdr) {'), (119, \"            b'\\\\n' if *size > 0 => Poll::Ready(Ok(ChunkedState::Body)),\"), (120, \"            b'\\\\n' if *size == 0 => Poll::Ready(Ok(ChunkedState::EndCr)),\"), (121, '            _ => Poll::Ready(Err(io::Error::new('), (122, '                io::ErrorKind::InvalidInput,'), (123, '                \"Invalid chunk size LF\",'), (124, '            ))),'), (125, '        }'), (126, '    }'), (128, '    fn read_body('), (129, '        rdr: &mut BytesMut,'), (130, '        rem: &mut u64,'), (131, '        buf: &mut Option<Bytes>,'), (132, '    ) -> Poll<Result<ChunkedState, io::Error>> {'), (133, '        log::trace!(\"Chunked read, remaining={:?}\", rem);'), (135, '        let len = rdr.len() as u64;'), (136, '        if len == 0 {'), (137, '            Poll::Ready(Ok(ChunkedState::Body))'), (138, '        } else {'), (139, '            let slice;'), (140, '            if *rem > len {'), (141, '                slice = rdr.split().freeze();'), (142, '                *rem -= len;'), (143, '            } else {'), (144, '                slice = rdr.split_to(*rem as usize).freeze();'), (145, '                *rem = 0;'), (146, '            }'), (147, '            *buf = Some(slice);'), (148, '            if *rem > 0 {'), (149, '                Poll::Ready(Ok(ChunkedState::Body))'), (150, '            } else {'), (151, '                Poll::Ready(Ok(ChunkedState::BodyCr))'), (152, '            }'), (153, '        }'), (154, '    }'), (156, '    fn read_body_cr(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {'), (157, '        match byte!(rdr) {'), (158, \"            b'\\\\r' => Poll::Ready(Ok(ChunkedState::BodyLf)),\"), (159, '            _ => Poll::Ready(Err(io::Error::new('), (160, '                io::ErrorKind::InvalidInput,'), (161, '                \"Invalid chunk body CR\",'), (162, '            ))),'), (163, '        }'), (164, '    }'), (165, '    fn read_body_lf(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {'), (166, '        match byte!(rdr) {'), (167, \"            b'\\\\n' => Poll::Ready(Ok(ChunkedState::Size)),\"), (168, '            _ => Poll::Ready(Err(io::Error::new('), (169, '                io::ErrorKind::InvalidInput,'), (170, '                \"Invalid chunk body LF\",'), (171, '            ))),'), (172, '        }'), (173, '    }'), (174, '    fn read_end_cr(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {'), (175, '        match byte!(rdr) {'), (176, \"            b'\\\\r' => Poll::Ready(Ok(ChunkedState::EndLf)),\"), (177, '            _ => Poll::Ready(Err(io::Error::new('), (178, '                io::ErrorKind::InvalidInput,'), (179, '                \"Invalid chunk end CR\",'), (180, '            ))),'), (181, '        }'), (182, '    }'), (183, '    fn read_end_lf(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {'), (184, '        match byte!(rdr) {'), (185, \"            b'\\\\n' => Poll::Ready(Ok(ChunkedState::End)),\"), (186, '            _ => Poll::Ready(Err(io::Error::new('), (187, '                io::ErrorKind::InvalidInput,'), (188, '                \"Invalid chunk end LF\",'), (189, '            ))),'), (190, '        }'), (191, '    }'), (192, '}'), (194, '#[cfg(test)]'), (195, 'mod tests {'), (196, '    use actix_codec::Decoder as _;'), (197, '    use bytes::{Bytes, BytesMut};'), (198, '    use http::Method;'), (200, '    use crate::{'), (201, '        error::ParseError,'), (202, '        h1::decoder::{MessageDecoder, PayloadItem},'), (203, '        HttpMessage as _, Request,'), (204, '    };'), (206, '    macro_rules! parse_ready {'), (207, '        ($e:expr) => {{'), (208, '            match MessageDecoder::<Request>::default().decode($e) {'), (209, '                Ok(Some((msg, _))) => msg,'), (210, '                Ok(_) => unreachable!(\"Eof during parsing http request\"),'), (211, '                Err(err) => unreachable!(\"Error during parsing http request: {:?}\", err),'), (212, '            }'), (213, '        }};'), (214, '    }'), (216, '    macro_rules! expect_parse_err {'), (217, '        ($e:expr) => {{'), (218, '            match MessageDecoder::<Request>::default().decode($e) {'), (219, '                Err(err) => match err {'), (220, '                    ParseError::Io(_) => unreachable!(\"Parse error expected\"),'), (221, '                    _ => {}'), (222, '                },'), (223, '                _ => unreachable!(\"Error expected\"),'), (224, '            }'), (225, '        }};'), (226, '    }'), (228, '    #[test]'), (229, '    fn test_parse_chunked_payload_chunk_extension() {'), (230, '        let mut buf = BytesMut::from('), (231, '            \"GET /test HTTP/1.1\\\\r\\\\n\\\\'), (232, '            transfer-encoding: chunked\\\\r\\\\n\\\\'), (233, '            \\\\r\\\\n\",'), (234, '        );'), (236, '        let mut reader = MessageDecoder::<Request>::default();'), (237, '        let (msg, pl) = reader.decode(&mut buf).unwrap().unwrap();'), (238, '        let mut pl = pl.unwrap();'), (239, '        assert!(msg.chunked().unwrap());'), (241, '        buf.extend(b\"4;test\\\\r\\\\ndata\\\\r\\\\n4\\\\r\\\\nline\\\\r\\\\n0\\\\r\\\\n\\\\r\\\\n\"); // test: test\\\\r\\\\n\\\\r\\\\n\")'), (242, '        let chunk = pl.decode(&mut buf).unwrap().unwrap().chunk();'), (243, '        assert_eq!(chunk, Bytes::from_static(b\"data\"));'), (244, '        let chunk = pl.decode(&mut buf).unwrap().unwrap().chunk();'), (245, '        assert_eq!(chunk, Bytes::from_static(b\"line\"));'), (246, '        let msg = pl.decode(&mut buf).unwrap().unwrap();'), (247, '        assert!(msg.eof());'), (248, '    }'), (250, '    #[test]'), (251, '    fn test_request_chunked() {'), (252, '        let mut buf = BytesMut::from('), (253, '            \"GET /test HTTP/1.1\\\\r\\\\n\\\\'), (254, '             transfer-encoding: chunked\\\\r\\\\n\\\\r\\\\n\",'), (255, '        );'), (256, '        let req = parse_ready!(&mut buf);'), (258, '        if let Ok(val) = req.chunked() {'), (259, '            assert!(val);'), (260, '        } else {'), (261, '            unreachable!(\"Error\");'), (262, '        }'), (265, '        let mut buf = BytesMut::from('), (266, '            \"GET /test HTTP/1.1\\\\r\\\\n\\\\'), (267, '             transfer-encoding: chnked\\\\r\\\\n\\\\r\\\\n\",'), (268, '        );'), (269, '        expect_parse_err!(&mut buf);'), (270, '    }'), (272, '    #[test]'), (273, '    fn test_http_request_chunked_payload() {'), (274, '        let mut buf = BytesMut::from('), (275, '            \"GET /test HTTP/1.1\\\\r\\\\n\\\\'), (276, '             transfer-encoding: chunked\\\\r\\\\n\\\\r\\\\n\",'), (277, '        );'), (278, '        let mut reader = MessageDecoder::<Request>::default();'), (279, '        let (req, pl) = reader.decode(&mut buf).unwrap().unwrap();'), (280, '        let mut pl = pl.unwrap();'), (281, '        assert!(req.chunked().unwrap());'), (283, '        buf.extend(b\"4\\\\r\\\\ndata\\\\r\\\\n4\\\\r\\\\nline\\\\r\\\\n0\\\\r\\\\n\\\\r\\\\n\");'), (284, '        assert_eq!('), (285, '            pl.decode(&mut buf).unwrap().unwrap().chunk().as_ref(),'), (286, '            b\"data\"'), (287, '        );'), (288, '        assert_eq!('), (289, '            pl.decode(&mut buf).unwrap().unwrap().chunk().as_ref(),'), (290, '            b\"line\"'), (291, '        );'), (292, '        assert!(pl.decode(&mut buf).unwrap().unwrap().eof());'), (293, '    }'), (295, '    #[test]'), (296, '    fn test_http_request_chunked_payload_and_next_message() {'), (297, '        let mut buf = BytesMut::from('), (298, '            \"GET /test HTTP/1.1\\\\r\\\\n\\\\'), (299, '             transfer-encoding: chunked\\\\r\\\\n\\\\r\\\\n\",'), (300, '        );'), (301, '        let mut reader = MessageDecoder::<Request>::default();'), (302, '        let (req, pl) = reader.decode(&mut buf).unwrap().unwrap();'), (303, '        let mut pl = pl.unwrap();'), (304, '        assert!(req.chunked().unwrap());'), (306, '        buf.extend('), (307, '            b\"4\\\\r\\\\ndata\\\\r\\\\n4\\\\r\\\\nline\\\\r\\\\n0\\\\r\\\\n\\\\r\\\\n\\\\'), (308, '              POST /test2 HTTP/1.1\\\\r\\\\n\\\\'), (309, '              transfer-encoding: chunked\\\\r\\\\n\\\\r\\\\n\"'), (310, '                .iter(),'), (311, '        );'), (312, '        let msg = pl.decode(&mut buf).unwrap().unwrap();'), (313, '        assert_eq!(msg.chunk().as_ref(), b\"data\");'), (314, '        let msg = pl.decode(&mut buf).unwrap().unwrap();'), (315, '        assert_eq!(msg.chunk().as_ref(), b\"line\");'), (316, '        let msg = pl.decode(&mut buf).unwrap().unwrap();'), (317, '        assert!(msg.eof());'), (319, '        let (req, _) = reader.decode(&mut buf).unwrap().unwrap();'), (320, '        assert!(req.chunked().unwrap());'), (321, '        assert_eq!(*req.method(), Method::POST);'), (322, '        assert!(req.chunked().unwrap());'), (323, '    }'), (325, '    #[test]'), (326, '    fn test_http_request_chunked_payload_chunks() {'), (327, '        let mut buf = BytesMut::from('), (328, '            \"GET /test HTTP/1.1\\\\r\\\\n\\\\'), (329, '             transfer-encoding: chunked\\\\r\\\\n\\\\r\\\\n\",'), (330, '        );'), (332, '        let mut reader = MessageDecoder::<Request>::default();'), (333, '        let (req, pl) = reader.decode(&mut buf).unwrap().unwrap();'), (334, '        let mut pl = pl.unwrap();'), (335, '        assert!(req.chunked().unwrap());'), (337, '        buf.extend(b\"4\\\\r\\\\n1111\\\\r\\\\n\");'), (338, '        let msg = pl.decode(&mut buf).unwrap().unwrap();'), (339, '        assert_eq!(msg.chunk().as_ref(), b\"1111\");'), (341, '        buf.extend(b\"4\\\\r\\\\ndata\\\\r\");'), (342, '        let msg = pl.decode(&mut buf).unwrap().unwrap();'), (343, '        assert_eq!(msg.chunk().as_ref(), b\"data\");'), (345, '        buf.extend(b\"\\\\n4\");'), (346, '        assert!(pl.decode(&mut buf).unwrap().is_none());'), (348, '        buf.extend(b\"\\\\r\");'), (349, '        assert!(pl.decode(&mut buf).unwrap().is_none());'), (350, '        buf.extend(b\"\\\\n\");'), (351, '        assert!(pl.decode(&mut buf).unwrap().is_none());'), (353, '        buf.extend(b\"li\");'), (354, '        let msg = pl.decode(&mut buf).unwrap().unwrap();'), (355, '        assert_eq!(msg.chunk().as_ref(), b\"li\");'), (361, '        buf.extend(b\"ne\\\\r\\\\n0\\\\r\\\\n\");'), (362, '        let msg = pl.decode(&mut buf).unwrap().unwrap();'), (363, '        assert_eq!(msg.chunk().as_ref(), b\"ne\");'), (364, '        assert!(pl.decode(&mut buf).unwrap().is_none());'), (366, '        buf.extend(b\"\\\\r\\\\n\");'), (367, '        assert!(pl.decode(&mut buf).unwrap().unwrap().eof());'), (368, '    }'), (370, '    #[test]'), (371, '    fn chunk_extension_quoted() {'), (372, '        let mut buf = BytesMut::from('), (373, '            \"GET /test HTTP/1.1\\\\r\\\\n\\\\'), (374, '            Host: localhost:8080\\\\r\\\\n\\\\'), (375, '            Transfer-Encoding: chunked\\\\r\\\\n\\\\'), (376, '            \\\\r\\\\n\\\\'), (377, '            2;hello=b;one=\\\\\"1 2 3\\\\\"\\\\r\\\\n\\\\'), (378, '            xx\",'), (379, '        );'), (381, '        let mut reader = MessageDecoder::<Request>::default();'), (382, '        let (_msg, pl) = reader.decode(&mut buf).unwrap().unwrap();'), (383, '        let mut pl = pl.unwrap();'), (385, '        let chunk = pl.decode(&mut buf).unwrap().unwrap();'), (386, '        assert_eq!(chunk, PayloadItem::Chunk(Bytes::from_static(b\"xx\")));'), (387, '    }'), (389, '    #[test]'), (390, '    fn hrs_chunk_extension_invalid() {'), (391, '        let mut buf = BytesMut::from('), (392, '            \"GET / HTTP/1.1\\\\r\\\\n\\\\'), (393, '            Host: localhost:8080\\\\r\\\\n\\\\'), (394, '            Transfer-Encoding: chunked\\\\r\\\\n\\\\'), (395, '            \\\\r\\\\n\\\\'), (396, '            2;x\\\\nx\\\\r\\\\n\\\\'), (397, '            4c\\\\r\\\\n\\\\'), (398, '            0\\\\r\\\\n\",'), (399, '        );'), (401, '        let mut reader = MessageDecoder::<Request>::default();'), (402, '        let (_msg, pl) = reader.decode(&mut buf).unwrap().unwrap();'), (403, '        let mut pl = pl.unwrap();'), (405, '        let err = pl.decode(&mut buf).unwrap_err();'), (406, '        assert!(err'), (407, '            .to_string()'), (408, '            .contains(\"Invalid character in chunk extension\"));'), (409, '    }'), (411, '    #[test]'), (412, '    fn hrs_chunk_size_overflow() {'), (413, '        let mut buf = BytesMut::from('), (414, '            \"GET / HTTP/1.1\\\\r\\\\n\\\\'), (415, '            Host: example.com\\\\r\\\\n\\\\'), (416, '            Transfer-Encoding: chunked\\\\r\\\\n\\\\'), (417, '            \\\\r\\\\n\\\\'), (418, '            f0000000000000003\\\\r\\\\n\\\\'), (419, '            abc\\\\r\\\\n\\\\'), (420, '            0\\\\r\\\\n\",'), (421, '        );'), (423, '        let mut reader = MessageDecoder::<Request>::default();'), (424, '        let (_msg, pl) = reader.decode(&mut buf).unwrap().unwrap();'), (425, '        let mut pl = pl.unwrap();'), (427, '        let err = pl.decode(&mut buf).unwrap_err();'), (428, '        assert!(err'), (429, '            .to_string()'), (430, '            .contains(\"Invalid chunk size line: Size is too big\"));'), (431, '    }'), (432, '}')], 'deleted': []}",
    "num_lines_added": "380",
    "num_lines_deleted": "0",
    "nloc": "380"
  },
  {
    "file_change_id": "266347436850916",
    "hash": "e965d8298f421e9c89fe98b1300b8361e948c324",
    "old_path": "actix-http/src/h1/decoder.rs",
    "new_path": "actix-http/src/h1/decoder.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,18 +1,18 @@\n-use std::convert::TryFrom;\n-use std::io;\n-use std::marker::PhantomData;\n-use std::task::Poll;\n+use std::{convert::TryFrom, io, marker::PhantomData, task::Poll};\n \n use actix_codec::Decoder;\n-use bytes::{Buf, Bytes, BytesMut};\n+use bytes::{Bytes, BytesMut};\n use http::header::{HeaderName, HeaderValue};\n use http::{header, Method, StatusCode, Uri, Version};\n use log::{debug, error, trace};\n \n-use crate::error::ParseError;\n-use crate::header::HeaderMap;\n-use crate::message::{ConnectionType, ResponseHead};\n-use crate::request::Request;\n+use super::chunked::ChunkedState;\n+use crate::{\n+    error::ParseError,\n+    header::HeaderMap,\n+    message::{ConnectionType, ResponseHead},\n+    request::Request,\n+};\n \n pub(crate) const MAX_BUFFER_SIZE: usize = 131_072;\n const MAX_HEADERS: usize = 96;\n@@ -67,6 +67,7 @@ pub(crate) trait MessageType: Sized {\n         let mut has_upgrade_websocket = false;\n         let mut expect = false;\n         let mut chunked = false;\n+        let mut seen_te = false;\n         let mut content_length = None;\n \n         {\n@@ -85,8 +86,17 @@ pub(crate) trait MessageType: Sized {\n                 };\n \n                 match name {\n-                    header::CONTENT_LENGTH => {\n-                        if let Ok(s) = value.to_str() {\n+                    header::CONTENT_LENGTH if content_length.is_some() => {\n+                        debug!(\"multiple Content-Length\");\n+                        return Err(ParseError::Header);\n+                    }\n+\n+                    header::CONTENT_LENGTH => match value.to_str() {\n+                        Ok(s) if s.trim().starts_with('+') => {\n+                            debug!(\"illegal Content-Length: {:?}\", s);\n+                            return Err(ParseError::Header);\n+                        }\n+                        Ok(s) => {\n                             if let Ok(len) = s.parse::<u64>() {\n                                 if len != 0 {\n                                     content_length = Some(len);\n@@ -95,15 +105,31 @@ pub(crate) trait MessageType: Sized {\n                                 debug!(\"illegal Content-Length: {:?}\", s);\n                                 return Err(ParseError::Header);\n                             }\n-                        } else {\n+                        }\n+                        Err(_) => {\n                             debug!(\"illegal Content-Length: {:?}\", value);\n                             return Err(ParseError::Header);\n                         }\n-                    }\n+                    },\n+\n                     // transfer-encoding\n+                    header::TRANSFER_ENCODING if seen_te => {\n+                        debug!(\"multiple Transfer-Encoding not allowed\");\n+                        return Err(ParseError::Header);\n+                    }\n+\n                     header::TRANSFER_ENCODING => {\n+                        seen_te = true;\n+\n                         if let Ok(s) = value.to_str().map(str::trim) {\n-                            chunked = s.eq_ignore_ascii_case(\"chunked\");\n+                            if s.eq_ignore_ascii_case(\"chunked\") {\n+                                chunked = true;\n+                            } else if s.eq_ignore_ascii_case(\"identity\") {\n+                                // allow silently since multiple TE headers are already checked\n+                            } else {\n+                                debug!(\"illegal Transfer-Encoding: {:?}\", s);\n+                                return Err(ParseError::Header);\n+                            }\n                         } else {\n                             return Err(ParseError::Header);\n                         }\n@@ -408,20 +434,6 @@ enum Kind {\n     Eof,\n }\n \n-#[derive(Debug, PartialEq, Clone)]\n-enum ChunkedState {\n-    Size,\n-    SizeLws,\n-    Extension,\n-    SizeLf,\n-    Body,\n-    BodyCr,\n-    BodyLf,\n-    EndCr,\n-    EndLf,\n-    End,\n-}\n-\n impl Decoder for PayloadDecoder {\n     type Item = PayloadItem;\n     type Error = io::Error;\n@@ -451,19 +463,23 @@ impl Decoder for PayloadDecoder {\n             Kind::Chunked(ref mut state, ref mut size) => {\n                 loop {\n                     let mut buf = None;\n+\n                     // advances the chunked state\n                     *state = match state.step(src, size, &mut buf) {\n                         Poll::Pending => return Ok(None),\n                         Poll::Ready(Ok(state)) => state,\n                         Poll::Ready(Err(e)) => return Err(e),\n                     };\n+\n                     if *state == ChunkedState::End {\n                         trace!(\"End of chunked stream\");\n                         return Ok(Some(PayloadItem::Eof));\n                     }\n+\n                     if let Some(buf) = buf {\n                         return Ok(Some(PayloadItem::Chunk(buf)));\n                     }\n+\n                     if src.is_empty() {\n                         return Ok(None);\n                     }\n@@ -480,201 +496,40 @@ impl Decoder for PayloadDecoder {\n     }\n }\n \n-macro_rules! byte (\n-    ($rdr:ident) => ({\n-        if $rdr.len() > 0 {\n-            let b = $rdr[0];\n-            $rdr.advance(1);\n-            b\n-        } else {\n-            return Poll::Pending\n-        }\n-    })\n-);\n-\n-impl ChunkedState {\n-    fn step(\n-        &self,\n-        body: &mut BytesMut,\n-        size: &mut u64,\n-        buf: &mut Option<Bytes>,\n-    ) -> Poll<Result<ChunkedState, io::Error>> {\n-        use self::ChunkedState::*;\n-        match *self {\n-            Size => ChunkedState::read_size(body, size),\n-            SizeLws => ChunkedState::read_size_lws(body),\n-            Extension => ChunkedState::read_extension(body),\n-            SizeLf => ChunkedState::read_size_lf(body, size),\n-            Body => ChunkedState::read_body(body, size, buf),\n-            BodyCr => ChunkedState::read_body_cr(body),\n-            BodyLf => ChunkedState::read_body_lf(body),\n-            EndCr => ChunkedState::read_end_cr(body),\n-            EndLf => ChunkedState::read_end_lf(body),\n-            End => Poll::Ready(Ok(ChunkedState::End)),\n-        }\n-    }\n-\n-    fn read_size(\n-        rdr: &mut BytesMut,\n-        size: &mut u64,\n-    ) -> Poll<Result<ChunkedState, io::Error>> {\n-        let radix = 16;\n-        match byte!(rdr) {\n-            b @ b'0'..=b'9' => {\n-                *size *= radix;\n-                *size += u64::from(b - b'0');\n-            }\n-            b @ b'a'..=b'f' => {\n-                *size *= radix;\n-                *size += u64::from(b + 10 - b'a');\n-            }\n-            b @ b'A'..=b'F' => {\n-                *size *= radix;\n-                *size += u64::from(b + 10 - b'A');\n-            }\n-            b'\\t' | b' ' => return Poll::Ready(Ok(ChunkedState::SizeLws)),\n-            b';' => return Poll::Ready(Ok(ChunkedState::Extension)),\n-            b'\\r' => return Poll::Ready(Ok(ChunkedState::SizeLf)),\n-            _ => {\n-                return Poll::Ready(Err(io::Error::new(\n-                    io::ErrorKind::InvalidInput,\n-                    \"Invalid chunk size line: Invalid Size\",\n-                )));\n-            }\n-        }\n-        Poll::Ready(Ok(ChunkedState::Size))\n-    }\n-\n-    fn read_size_lws(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {\n-        trace!(\"read_size_lws\");\n-        match byte!(rdr) {\n-            // LWS can follow the chunk size, but no more digits can come\n-            b'\\t' | b' ' => Poll::Ready(Ok(ChunkedState::SizeLws)),\n-            b';' => Poll::Ready(Ok(ChunkedState::Extension)),\n-            b'\\r' => Poll::Ready(Ok(ChunkedState::SizeLf)),\n-            _ => Poll::Ready(Err(io::Error::new(\n-                io::ErrorKind::InvalidInput,\n-                \"Invalid chunk size linear white space\",\n-            ))),\n-        }\n-    }\n-    fn read_extension(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {\n-        match byte!(rdr) {\n-            b'\\r' => Poll::Ready(Ok(ChunkedState::SizeLf)),\n-            _ => Poll::Ready(Ok(ChunkedState::Extension)), // no supported extensions\n-        }\n-    }\n-    fn read_size_lf(\n-        rdr: &mut BytesMut,\n-        size: &mut u64,\n-    ) -> Poll<Result<ChunkedState, io::Error>> {\n-        match byte!(rdr) {\n-            b'\\n' if *size > 0 => Poll::Ready(Ok(ChunkedState::Body)),\n-            b'\\n' if *size == 0 => Poll::Ready(Ok(ChunkedState::EndCr)),\n-            _ => Poll::Ready(Err(io::Error::new(\n-                io::ErrorKind::InvalidInput,\n-                \"Invalid chunk size LF\",\n-            ))),\n-        }\n-    }\n-\n-    fn read_body(\n-        rdr: &mut BytesMut,\n-        rem: &mut u64,\n-        buf: &mut Option<Bytes>,\n-    ) -> Poll<Result<ChunkedState, io::Error>> {\n-        trace!(\"Chunked read, remaining={:?}\", rem);\n-\n-        let len = rdr.len() as u64;\n-        if len == 0 {\n-            Poll::Ready(Ok(ChunkedState::Body))\n-        } else {\n-            let slice;\n-            if *rem > len {\n-                slice = rdr.split().freeze();\n-                *rem -= len;\n-            } else {\n-                slice = rdr.split_to(*rem as usize).freeze();\n-                *rem = 0;\n-            }\n-            *buf = Some(slice);\n-            if *rem > 0 {\n-                Poll::Ready(Ok(ChunkedState::Body))\n-            } else {\n-                Poll::Ready(Ok(ChunkedState::BodyCr))\n-            }\n-        }\n-    }\n-\n-    fn read_body_cr(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {\n-        match byte!(rdr) {\n-            b'\\r' => Poll::Ready(Ok(ChunkedState::BodyLf)),\n-            _ => Poll::Ready(Err(io::Error::new(\n-                io::ErrorKind::InvalidInput,\n-                \"Invalid chunk body CR\",\n-            ))),\n-        }\n-    }\n-    fn read_body_lf(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {\n-        match byte!(rdr) {\n-            b'\\n' => Poll::Ready(Ok(ChunkedState::Size)),\n-            _ => Poll::Ready(Err(io::Error::new(\n-                io::ErrorKind::InvalidInput,\n-                \"Invalid chunk body LF\",\n-            ))),\n-        }\n-    }\n-    fn read_end_cr(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {\n-        match byte!(rdr) {\n-            b'\\r' => Poll::Ready(Ok(ChunkedState::EndLf)),\n-            _ => Poll::Ready(Err(io::Error::new(\n-                io::ErrorKind::InvalidInput,\n-                \"Invalid chunk end CR\",\n-            ))),\n-        }\n-    }\n-    fn read_end_lf(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {\n-        match byte!(rdr) {\n-            b'\\n' => Poll::Ready(Ok(ChunkedState::End)),\n-            _ => Poll::Ready(Err(io::Error::new(\n-                io::ErrorKind::InvalidInput,\n-                \"Invalid chunk end LF\",\n-            ))),\n-        }\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use bytes::{Bytes, BytesMut};\n     use http::{Method, Version};\n \n     use super::*;\n-    use crate::error::ParseError;\n-    use crate::http::header::{HeaderName, SET_COOKIE};\n-    use crate::HttpMessage;\n+    use crate::{\n+        error::ParseError,\n+        http::header::{HeaderName, SET_COOKIE},\n+        HttpMessage as _,\n+    };\n \n     impl PayloadType {\n-        fn unwrap(self) -> PayloadDecoder {\n+        pub(crate) fn unwrap(self) -> PayloadDecoder {\n             match self {\n                 PayloadType::Payload(pl) => pl,\n                 _ => panic!(),\n             }\n         }\n \n-        fn is_unhandled(&self) -> bool {\n+        pub(crate) fn is_unhandled(&self) -> bool {\n             matches!(self, PayloadType::Stream(_))\n         }\n     }\n \n     impl PayloadItem {\n-        fn chunk(self) -> Bytes {\n+        pub(crate) fn chunk(self) -> Bytes {\n             match self {\n                 PayloadItem::Chunk(chunk) => chunk,\n                 _ => panic!(\"error\"),\n             }\n         }\n-        fn eof(&self) -> bool {\n+\n+        pub(crate) fn eof(&self) -> bool {\n             matches!(*self, PayloadItem::Eof)\n         }\n     }\n@@ -967,34 +822,6 @@ mod tests {\n         assert!(req.upgrade());\n     }\n \n-    #[test]\n-    fn test_request_chunked() {\n-        let mut buf = BytesMut::from(\n-            \"GET /test HTTP/1.1\\r\\n\\\n-             transfer-encoding: chunked\\r\\n\\r\\n\",\n-        );\n-        let req = parse_ready!(&mut buf);\n-\n-        if let Ok(val) = req.chunked() {\n-            assert!(val);\n-        } else {\n-            unreachable!(\"Error\");\n-        }\n-\n-        // intentional typo in \"chunked\"\n-        let mut buf = BytesMut::from(\n-            \"GET /test HTTP/1.1\\r\\n\\\n-             transfer-encoding: chnked\\r\\n\\r\\n\",\n-        );\n-        let req = parse_ready!(&mut buf);\n-\n-        if let Ok(val) = req.chunked() {\n-            assert!(!val);\n-        } else {\n-            unreachable!(\"Error\");\n-        }\n-    }\n-\n     #[test]\n     fn test_headers_content_length_err_1() {\n         let mut buf = BytesMut::from(\n@@ -1113,134 +940,94 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_http_request_chunked_payload() {\n-        let mut buf = BytesMut::from(\n-            \"GET /test HTTP/1.1\\r\\n\\\n-             transfer-encoding: chunked\\r\\n\\r\\n\",\n-        );\n-        let mut reader = MessageDecoder::<Request>::default();\n-        let (req, pl) = reader.decode(&mut buf).unwrap().unwrap();\n+    fn test_response_http10_read_until_eof() {\n+        let mut buf = BytesMut::from(\"HTTP/1.0 200 Ok\\r\\n\\r\\ntest data\");\n+\n+        let mut reader = MessageDecoder::<ResponseHead>::default();\n+        let (_msg, pl) = reader.decode(&mut buf).unwrap().unwrap();\n         let mut pl = pl.unwrap();\n-        assert!(req.chunked().unwrap());\n \n-        buf.extend(b\"4\\r\\ndata\\r\\n4\\r\\nline\\r\\n0\\r\\n\\r\\n\");\n-        assert_eq!(\n-            pl.decode(&mut buf).unwrap().unwrap().chunk().as_ref(),\n-            b\"data\"\n-        );\n-        assert_eq!(\n-            pl.decode(&mut buf).unwrap().unwrap().chunk().as_ref(),\n-            b\"line\"\n-        );\n-        assert!(pl.decode(&mut buf).unwrap().unwrap().eof());\n+        let chunk = pl.decode(&mut buf).unwrap().unwrap();\n+        assert_eq!(chunk, PayloadItem::Chunk(Bytes::from_static(b\"test data\")));\n     }\n \n     #[test]\n-    fn test_http_request_chunked_payload_and_next_message() {\n+    fn hrs_multiple_content_length() {\n         let mut buf = BytesMut::from(\n-            \"GET /test HTTP/1.1\\r\\n\\\n-             transfer-encoding: chunked\\r\\n\\r\\n\",\n+            \"GET / HTTP/1.1\\r\\n\\\n+            Host: example.com\\r\\n\\\n+            Content-Length: 4\\r\\n\\\n+            Content-Length: 2\\r\\n\\\n+            \\r\\n\\\n+            abcd\",\n         );\n-        let mut reader = MessageDecoder::<Request>::default();\n-        let (req, pl) = reader.decode(&mut buf).unwrap().unwrap();\n-        let mut pl = pl.unwrap();\n-        assert!(req.chunked().unwrap());\n \n-        buf.extend(\n-            b\"4\\r\\ndata\\r\\n4\\r\\nline\\r\\n0\\r\\n\\r\\n\\\n-              POST /test2 HTTP/1.1\\r\\n\\\n-              transfer-encoding: chunked\\r\\n\\r\\n\"\n-                .iter(),\n-        );\n-        let msg = pl.decode(&mut buf).unwrap().unwrap();\n-        assert_eq!(msg.chunk().as_ref(), b\"data\");\n-        let msg = pl.decode(&mut buf).unwrap().unwrap();\n-        assert_eq!(msg.chunk().as_ref(), b\"line\");\n-        let msg = pl.decode(&mut buf).unwrap().unwrap();\n-        assert!(msg.eof());\n-\n-        let (req, _) = reader.decode(&mut buf).unwrap().unwrap();\n-        assert!(req.chunked().unwrap());\n-        assert_eq!(*req.method(), Method::POST);\n-        assert!(req.chunked().unwrap());\n+        expect_parse_err!(&mut buf);\n     }\n \n     #[test]\n-    fn test_http_request_chunked_payload_chunks() {\n+    fn hrs_content_length_plus() {\n         let mut buf = BytesMut::from(\n-            \"GET /test HTTP/1.1\\r\\n\\\n-             transfer-encoding: chunked\\r\\n\\r\\n\",\n+            \"GET / HTTP/1.1\\r\\n\\\n+            Host: example.com\\r\\n\\\n+            Content-Length: +3\\r\\n\\\n+            \\r\\n\\\n+            000\",\n         );\n \n-        let mut reader = MessageDecoder::<Request>::default();\n-        let (req, pl) = reader.decode(&mut buf).unwrap().unwrap();\n-        let mut pl = pl.unwrap();\n-        assert!(req.chunked().unwrap());\n-\n-        buf.extend(b\"4\\r\\n1111\\r\\n\");\n-        let msg = pl.decode(&mut buf).unwrap().unwrap();\n-        assert_eq!(msg.chunk().as_ref(), b\"1111\");\n-\n-        buf.extend(b\"4\\r\\ndata\\r\");\n-        let msg = pl.decode(&mut buf).unwrap().unwrap();\n-        assert_eq!(msg.chunk().as_ref(), b\"data\");\n-\n-        buf.extend(b\"\\n4\");\n-        assert!(pl.decode(&mut buf).unwrap().is_none());\n-\n-        buf.extend(b\"\\r\");\n-        assert!(pl.decode(&mut buf).unwrap().is_none());\n-        buf.extend(b\"\\n\");\n-        assert!(pl.decode(&mut buf).unwrap().is_none());\n-\n-        buf.extend(b\"li\");\n-        let msg = pl.decode(&mut buf).unwrap().unwrap();\n-        assert_eq!(msg.chunk().as_ref(), b\"li\");\n-\n-        //trailers\n-        //buf.feed_data(\"test: test\\r\\n\");\n-        //not_ready!(reader.parse(&mut buf, &mut readbuf));\n+        expect_parse_err!(&mut buf);\n+    }\n \n-        buf.extend(b\"ne\\r\\n0\\r\\n\");\n-        let msg = pl.decode(&mut buf).unwrap().unwrap();\n-        assert_eq!(msg.chunk().as_ref(), b\"ne\");\n-        assert!(pl.decode(&mut buf).unwrap().is_none());\n+    #[test]\n+    fn hrs_unknown_transfer_encoding() {\n+        let mut buf = BytesMut::from(\n+            \"GET / HTTP/1.1\\r\\n\\\n+            Host: example.com\\r\\n\\\n+            Transfer-Encoding: JUNK\\r\\n\\\n+            Transfer-Encoding: chunked\\r\\n\\\n+            \\r\\n\\\n+            5\\r\\n\\\n+            hello\\r\\n\\\n+            0\",\n+        );\n \n-        buf.extend(b\"\\r\\n\");\n-        assert!(pl.decode(&mut buf).unwrap().unwrap().eof());\n+        expect_parse_err!(&mut buf);\n     }\n \n     #[test]\n-    fn test_parse_chunked_payload_chunk_extension() {\n+    fn hrs_multiple_transfer_encoding() {\n         let mut buf = BytesMut::from(\n-            \"GET /test HTTP/1.1\\r\\n\\\n-            transfer-encoding: chunked\\r\\n\\\n-            \\r\\n\",\n+            \"GET / HTTP/1.1\\r\\n\\\n+            Host: example.com\\r\\n\\\n+            Content-Length: 51\\r\\n\\\n+            Transfer-Encoding: identity\\r\\n\\\n+            Transfer-Encoding: chunked\\r\\n\\\n+            \\r\\n\\\n+            0\\r\\n\\\n+            \\r\\n\\\n+            GET /forbidden HTTP/1.1\\r\\n\\\n+            Host: example.com\\r\\n\\r\\n\",\n         );\n \n-        let mut reader = MessageDecoder::<Request>::default();\n-        let (msg, pl) = reader.decode(&mut buf).unwrap().unwrap();\n-        let mut pl = pl.unwrap();\n-        assert!(msg.chunked().unwrap());\n-\n-        buf.extend(b\"4;test\\r\\ndata\\r\\n4\\r\\nline\\r\\n0\\r\\n\\r\\n\"); // test: test\\r\\n\\r\\n\")\n-        let chunk = pl.decode(&mut buf).unwrap().unwrap().chunk();\n-        assert_eq!(chunk, Bytes::from_static(b\"data\"));\n-        let chunk = pl.decode(&mut buf).unwrap().unwrap().chunk();\n-        assert_eq!(chunk, Bytes::from_static(b\"line\"));\n-        let msg = pl.decode(&mut buf).unwrap().unwrap();\n-        assert!(msg.eof());\n+        expect_parse_err!(&mut buf);\n     }\n \n     #[test]\n-    fn test_response_http10_read_until_eof() {\n-        let mut buf = BytesMut::from(\"HTTP/1.0 200 Ok\\r\\n\\r\\ntest data\");\n+    fn transfer_encoding_agrees() {\n+        let mut buf = BytesMut::from(\n+            \"GET /test HTTP/1.1\\r\\n\\\n+            Host: example.com\\r\\n\\\n+            Content-Length: 3\\r\\n\\\n+            Transfer-Encoding: identity\\r\\n\\\n+            \\r\\n\\\n+            0\\r\\n\",\n+        );\n \n-        let mut reader = MessageDecoder::<ResponseHead>::default();\n+        let mut reader = MessageDecoder::<Request>::default();\n         let (_msg, pl) = reader.decode(&mut buf).unwrap().unwrap();\n         let mut pl = pl.unwrap();\n \n         let chunk = pl.decode(&mut buf).unwrap().unwrap();\n-        assert_eq!(chunk, PayloadItem::Chunk(Bytes::from_static(b\"test data\")));\n+        assert_eq!(chunk, PayloadItem::Chunk(Bytes::from_static(b\"0\\r\\n\")));\n     }\n }\n",
    "diff_parsed": "{'added': [(1, 'use std::{convert::TryFrom, io, marker::PhantomData, task::Poll};'), (4, 'use bytes::{Bytes, BytesMut};'), (9, 'use super::chunked::ChunkedState;'), (10, 'use crate::{'), (11, '    error::ParseError,'), (12, '    header::HeaderMap,'), (13, '    message::{ConnectionType, ResponseHead},'), (14, '    request::Request,'), (15, '};'), (70, '        let mut seen_te = false;'), (89, '                    header::CONTENT_LENGTH if content_length.is_some() => {'), (90, '                        debug!(\"multiple Content-Length\");'), (91, '                        return Err(ParseError::Header);'), (92, '                    }'), (94, '                    header::CONTENT_LENGTH => match value.to_str() {'), (95, \"                        Ok(s) if s.trim().starts_with('+') => {\"), (96, '                            debug!(\"illegal Content-Length: {:?}\", s);'), (97, '                            return Err(ParseError::Header);'), (98, '                        }'), (99, '                        Ok(s) => {'), (108, '                        }'), (109, '                        Err(_) => {'), (113, '                    },'), (116, '                    header::TRANSFER_ENCODING if seen_te => {'), (117, '                        debug!(\"multiple Transfer-Encoding not allowed\");'), (118, '                        return Err(ParseError::Header);'), (119, '                    }'), (122, '                        seen_te = true;'), (125, '                            if s.eq_ignore_ascii_case(\"chunked\") {'), (126, '                                chunked = true;'), (127, '                            } else if s.eq_ignore_ascii_case(\"identity\") {'), (129, '                            } else {'), (130, '                                debug!(\"illegal Transfer-Encoding: {:?}\", s);'), (131, '                                return Err(ParseError::Header);'), (132, '                            }'), (505, '    use crate::{'), (506, '        error::ParseError,'), (507, '        http::header::{HeaderName, SET_COOKIE},'), (508, '        HttpMessage as _,'), (509, '    };'), (512, '        pub(crate) fn unwrap(self) -> PayloadDecoder {'), (519, '        pub(crate) fn is_unhandled(&self) -> bool {'), (525, '        pub(crate) fn chunk(self) -> Bytes {'), (532, '        pub(crate) fn eof(&self) -> bool {'), (943, '    fn test_response_http10_read_until_eof() {'), (944, '        let mut buf = BytesMut::from(\"HTTP/1.0 200 Ok\\\\r\\\\n\\\\r\\\\ntest data\");'), (946, '        let mut reader = MessageDecoder::<ResponseHead>::default();'), (947, '        let (_msg, pl) = reader.decode(&mut buf).unwrap().unwrap();'), (950, '        let chunk = pl.decode(&mut buf).unwrap().unwrap();'), (951, '        assert_eq!(chunk, PayloadItem::Chunk(Bytes::from_static(b\"test data\")));'), (955, '    fn hrs_multiple_content_length() {'), (957, '            \"GET / HTTP/1.1\\\\r\\\\n\\\\'), (958, '            Host: example.com\\\\r\\\\n\\\\'), (959, '            Content-Length: 4\\\\r\\\\n\\\\'), (960, '            Content-Length: 2\\\\r\\\\n\\\\'), (961, '            \\\\r\\\\n\\\\'), (962, '            abcd\",'), (965, '        expect_parse_err!(&mut buf);'), (969, '    fn hrs_content_length_plus() {'), (971, '            \"GET / HTTP/1.1\\\\r\\\\n\\\\'), (972, '            Host: example.com\\\\r\\\\n\\\\'), (973, '            Content-Length: +3\\\\r\\\\n\\\\'), (974, '            \\\\r\\\\n\\\\'), (975, '            000\",'), (978, '        expect_parse_err!(&mut buf);'), (979, '    }'), (981, '    #[test]'), (982, '    fn hrs_unknown_transfer_encoding() {'), (983, '        let mut buf = BytesMut::from('), (984, '            \"GET / HTTP/1.1\\\\r\\\\n\\\\'), (985, '            Host: example.com\\\\r\\\\n\\\\'), (986, '            Transfer-Encoding: JUNK\\\\r\\\\n\\\\'), (987, '            Transfer-Encoding: chunked\\\\r\\\\n\\\\'), (988, '            \\\\r\\\\n\\\\'), (989, '            5\\\\r\\\\n\\\\'), (990, '            hello\\\\r\\\\n\\\\'), (991, '            0\",'), (992, '        );'), (994, '        expect_parse_err!(&mut buf);'), (998, '    fn hrs_multiple_transfer_encoding() {'), (1000, '            \"GET / HTTP/1.1\\\\r\\\\n\\\\'), (1001, '            Host: example.com\\\\r\\\\n\\\\'), (1002, '            Content-Length: 51\\\\r\\\\n\\\\'), (1003, '            Transfer-Encoding: identity\\\\r\\\\n\\\\'), (1004, '            Transfer-Encoding: chunked\\\\r\\\\n\\\\'), (1005, '            \\\\r\\\\n\\\\'), (1006, '            0\\\\r\\\\n\\\\'), (1007, '            \\\\r\\\\n\\\\'), (1008, '            GET /forbidden HTTP/1.1\\\\r\\\\n\\\\'), (1009, '            Host: example.com\\\\r\\\\n\\\\r\\\\n\",'), (1012, '        expect_parse_err!(&mut buf);'), (1016, '    fn transfer_encoding_agrees() {'), (1017, '        let mut buf = BytesMut::from('), (1018, '            \"GET /test HTTP/1.1\\\\r\\\\n\\\\'), (1019, '            Host: example.com\\\\r\\\\n\\\\'), (1020, '            Content-Length: 3\\\\r\\\\n\\\\'), (1021, '            Transfer-Encoding: identity\\\\r\\\\n\\\\'), (1022, '            \\\\r\\\\n\\\\'), (1023, '            0\\\\r\\\\n\",'), (1024, '        );'), (1026, '        let mut reader = MessageDecoder::<Request>::default();'), (1031, '        assert_eq!(chunk, PayloadItem::Chunk(Bytes::from_static(b\"0\\\\r\\\\n\")));')], 'deleted': [(1, 'use std::convert::TryFrom;'), (2, 'use std::io;'), (3, 'use std::marker::PhantomData;'), (4, 'use std::task::Poll;'), (7, 'use bytes::{Buf, Bytes, BytesMut};'), (12, 'use crate::error::ParseError;'), (13, 'use crate::header::HeaderMap;'), (14, 'use crate::message::{ConnectionType, ResponseHead};'), (15, 'use crate::request::Request;'), (88, '                    header::CONTENT_LENGTH => {'), (89, '                        if let Ok(s) = value.to_str() {'), (98, '                        } else {'), (102, '                    }'), (106, '                            chunked = s.eq_ignore_ascii_case(\"chunked\");'), (411, '#[derive(Debug, PartialEq, Clone)]'), (412, 'enum ChunkedState {'), (413, '    Size,'), (414, '    SizeLws,'), (415, '    Extension,'), (416, '    SizeLf,'), (417, '    Body,'), (418, '    BodyCr,'), (419, '    BodyLf,'), (420, '    EndCr,'), (421, '    EndLf,'), (422, '    End,'), (423, '}'), (483, 'macro_rules! byte ('), (484, '    ($rdr:ident) => ({'), (485, '        if $rdr.len() > 0 {'), (486, '            let b = $rdr[0];'), (487, '            $rdr.advance(1);'), (488, '            b'), (489, '        } else {'), (490, '            return Poll::Pending'), (491, '        }'), (492, '    })'), (493, ');'), (495, 'impl ChunkedState {'), (496, '    fn step('), (497, '        &self,'), (498, '        body: &mut BytesMut,'), (499, '        size: &mut u64,'), (500, '        buf: &mut Option<Bytes>,'), (501, '    ) -> Poll<Result<ChunkedState, io::Error>> {'), (502, '        use self::ChunkedState::*;'), (503, '        match *self {'), (504, '            Size => ChunkedState::read_size(body, size),'), (505, '            SizeLws => ChunkedState::read_size_lws(body),'), (506, '            Extension => ChunkedState::read_extension(body),'), (507, '            SizeLf => ChunkedState::read_size_lf(body, size),'), (508, '            Body => ChunkedState::read_body(body, size, buf),'), (509, '            BodyCr => ChunkedState::read_body_cr(body),'), (510, '            BodyLf => ChunkedState::read_body_lf(body),'), (511, '            EndCr => ChunkedState::read_end_cr(body),'), (512, '            EndLf => ChunkedState::read_end_lf(body),'), (513, '            End => Poll::Ready(Ok(ChunkedState::End)),'), (514, '        }'), (515, '    }'), (517, '    fn read_size('), (518, '        rdr: &mut BytesMut,'), (519, '        size: &mut u64,'), (520, '    ) -> Poll<Result<ChunkedState, io::Error>> {'), (521, '        let radix = 16;'), (522, '        match byte!(rdr) {'), (523, \"            b @ b'0'..=b'9' => {\"), (524, '                *size *= radix;'), (525, \"                *size += u64::from(b - b'0');\"), (526, '            }'), (527, \"            b @ b'a'..=b'f' => {\"), (528, '                *size *= radix;'), (529, \"                *size += u64::from(b + 10 - b'a');\"), (530, '            }'), (531, \"            b @ b'A'..=b'F' => {\"), (532, '                *size *= radix;'), (533, \"                *size += u64::from(b + 10 - b'A');\"), (534, '            }'), (535, \"            b'\\\\t' | b' ' => return Poll::Ready(Ok(ChunkedState::SizeLws)),\"), (536, \"            b';' => return Poll::Ready(Ok(ChunkedState::Extension)),\"), (537, \"            b'\\\\r' => return Poll::Ready(Ok(ChunkedState::SizeLf)),\"), (538, '            _ => {'), (539, '                return Poll::Ready(Err(io::Error::new('), (540, '                    io::ErrorKind::InvalidInput,'), (541, '                    \"Invalid chunk size line: Invalid Size\",'), (542, '                )));'), (543, '            }'), (544, '        }'), (545, '        Poll::Ready(Ok(ChunkedState::Size))'), (546, '    }'), (548, '    fn read_size_lws(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {'), (549, '        trace!(\"read_size_lws\");'), (550, '        match byte!(rdr) {'), (552, \"            b'\\\\t' | b' ' => Poll::Ready(Ok(ChunkedState::SizeLws)),\"), (553, \"            b';' => Poll::Ready(Ok(ChunkedState::Extension)),\"), (554, \"            b'\\\\r' => Poll::Ready(Ok(ChunkedState::SizeLf)),\"), (555, '            _ => Poll::Ready(Err(io::Error::new('), (556, '                io::ErrorKind::InvalidInput,'), (557, '                \"Invalid chunk size linear white space\",'), (558, '            ))),'), (559, '        }'), (560, '    }'), (561, '    fn read_extension(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {'), (562, '        match byte!(rdr) {'), (563, \"            b'\\\\r' => Poll::Ready(Ok(ChunkedState::SizeLf)),\"), (564, '            _ => Poll::Ready(Ok(ChunkedState::Extension)), // no supported extensions'), (565, '        }'), (566, '    }'), (567, '    fn read_size_lf('), (568, '        rdr: &mut BytesMut,'), (569, '        size: &mut u64,'), (570, '    ) -> Poll<Result<ChunkedState, io::Error>> {'), (571, '        match byte!(rdr) {'), (572, \"            b'\\\\n' if *size > 0 => Poll::Ready(Ok(ChunkedState::Body)),\"), (573, \"            b'\\\\n' if *size == 0 => Poll::Ready(Ok(ChunkedState::EndCr)),\"), (574, '            _ => Poll::Ready(Err(io::Error::new('), (575, '                io::ErrorKind::InvalidInput,'), (576, '                \"Invalid chunk size LF\",'), (577, '            ))),'), (578, '        }'), (579, '    }'), (581, '    fn read_body('), (582, '        rdr: &mut BytesMut,'), (583, '        rem: &mut u64,'), (584, '        buf: &mut Option<Bytes>,'), (585, '    ) -> Poll<Result<ChunkedState, io::Error>> {'), (586, '        trace!(\"Chunked read, remaining={:?}\", rem);'), (588, '        let len = rdr.len() as u64;'), (589, '        if len == 0 {'), (590, '            Poll::Ready(Ok(ChunkedState::Body))'), (591, '        } else {'), (592, '            let slice;'), (593, '            if *rem > len {'), (594, '                slice = rdr.split().freeze();'), (595, '                *rem -= len;'), (596, '            } else {'), (597, '                slice = rdr.split_to(*rem as usize).freeze();'), (598, '                *rem = 0;'), (599, '            }'), (600, '            *buf = Some(slice);'), (601, '            if *rem > 0 {'), (602, '                Poll::Ready(Ok(ChunkedState::Body))'), (603, '            } else {'), (604, '                Poll::Ready(Ok(ChunkedState::BodyCr))'), (605, '            }'), (606, '        }'), (607, '    }'), (609, '    fn read_body_cr(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {'), (610, '        match byte!(rdr) {'), (611, \"            b'\\\\r' => Poll::Ready(Ok(ChunkedState::BodyLf)),\"), (612, '            _ => Poll::Ready(Err(io::Error::new('), (613, '                io::ErrorKind::InvalidInput,'), (614, '                \"Invalid chunk body CR\",'), (615, '            ))),'), (616, '        }'), (617, '    }'), (618, '    fn read_body_lf(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {'), (619, '        match byte!(rdr) {'), (620, \"            b'\\\\n' => Poll::Ready(Ok(ChunkedState::Size)),\"), (621, '            _ => Poll::Ready(Err(io::Error::new('), (622, '                io::ErrorKind::InvalidInput,'), (623, '                \"Invalid chunk body LF\",'), (624, '            ))),'), (625, '        }'), (626, '    }'), (627, '    fn read_end_cr(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {'), (628, '        match byte!(rdr) {'), (629, \"            b'\\\\r' => Poll::Ready(Ok(ChunkedState::EndLf)),\"), (630, '            _ => Poll::Ready(Err(io::Error::new('), (631, '                io::ErrorKind::InvalidInput,'), (632, '                \"Invalid chunk end CR\",'), (633, '            ))),'), (634, '        }'), (635, '    }'), (636, '    fn read_end_lf(rdr: &mut BytesMut) -> Poll<Result<ChunkedState, io::Error>> {'), (637, '        match byte!(rdr) {'), (638, \"            b'\\\\n' => Poll::Ready(Ok(ChunkedState::End)),\"), (639, '            _ => Poll::Ready(Err(io::Error::new('), (640, '                io::ErrorKind::InvalidInput,'), (641, '                \"Invalid chunk end LF\",'), (642, '            ))),'), (643, '        }'), (644, '    }'), (645, '}'), (653, '    use crate::error::ParseError;'), (654, '    use crate::http::header::{HeaderName, SET_COOKIE};'), (655, '    use crate::HttpMessage;'), (658, '        fn unwrap(self) -> PayloadDecoder {'), (665, '        fn is_unhandled(&self) -> bool {'), (671, '        fn chunk(self) -> Bytes {'), (677, '        fn eof(&self) -> bool {'), (970, '    #[test]'), (971, '    fn test_request_chunked() {'), (972, '        let mut buf = BytesMut::from('), (973, '            \"GET /test HTTP/1.1\\\\r\\\\n\\\\'), (974, '             transfer-encoding: chunked\\\\r\\\\n\\\\r\\\\n\",'), (975, '        );'), (976, '        let req = parse_ready!(&mut buf);'), (978, '        if let Ok(val) = req.chunked() {'), (979, '            assert!(val);'), (980, '        } else {'), (981, '            unreachable!(\"Error\");'), (982, '        }'), (985, '        let mut buf = BytesMut::from('), (986, '            \"GET /test HTTP/1.1\\\\r\\\\n\\\\'), (987, '             transfer-encoding: chnked\\\\r\\\\n\\\\r\\\\n\",'), (988, '        );'), (989, '        let req = parse_ready!(&mut buf);'), (991, '        if let Ok(val) = req.chunked() {'), (992, '            assert!(!val);'), (993, '        } else {'), (994, '            unreachable!(\"Error\");'), (995, '        }'), (996, '    }'), (1116, '    fn test_http_request_chunked_payload() {'), (1117, '        let mut buf = BytesMut::from('), (1118, '            \"GET /test HTTP/1.1\\\\r\\\\n\\\\'), (1119, '             transfer-encoding: chunked\\\\r\\\\n\\\\r\\\\n\",'), (1120, '        );'), (1121, '        let mut reader = MessageDecoder::<Request>::default();'), (1122, '        let (req, pl) = reader.decode(&mut buf).unwrap().unwrap();'), (1124, '        assert!(req.chunked().unwrap());'), (1126, '        buf.extend(b\"4\\\\r\\\\ndata\\\\r\\\\n4\\\\r\\\\nline\\\\r\\\\n0\\\\r\\\\n\\\\r\\\\n\");'), (1127, '        assert_eq!('), (1128, '            pl.decode(&mut buf).unwrap().unwrap().chunk().as_ref(),'), (1129, '            b\"data\"'), (1130, '        );'), (1131, '        assert_eq!('), (1132, '            pl.decode(&mut buf).unwrap().unwrap().chunk().as_ref(),'), (1133, '            b\"line\"'), (1134, '        );'), (1135, '        assert!(pl.decode(&mut buf).unwrap().unwrap().eof());'), (1139, '    fn test_http_request_chunked_payload_and_next_message() {'), (1141, '            \"GET /test HTTP/1.1\\\\r\\\\n\\\\'), (1142, '             transfer-encoding: chunked\\\\r\\\\n\\\\r\\\\n\",'), (1144, '        let mut reader = MessageDecoder::<Request>::default();'), (1145, '        let (req, pl) = reader.decode(&mut buf).unwrap().unwrap();'), (1146, '        let mut pl = pl.unwrap();'), (1147, '        assert!(req.chunked().unwrap());'), (1149, '        buf.extend('), (1150, '            b\"4\\\\r\\\\ndata\\\\r\\\\n4\\\\r\\\\nline\\\\r\\\\n0\\\\r\\\\n\\\\r\\\\n\\\\'), (1151, '              POST /test2 HTTP/1.1\\\\r\\\\n\\\\'), (1152, '              transfer-encoding: chunked\\\\r\\\\n\\\\r\\\\n\"'), (1153, '                .iter(),'), (1154, '        );'), (1155, '        let msg = pl.decode(&mut buf).unwrap().unwrap();'), (1156, '        assert_eq!(msg.chunk().as_ref(), b\"data\");'), (1157, '        let msg = pl.decode(&mut buf).unwrap().unwrap();'), (1158, '        assert_eq!(msg.chunk().as_ref(), b\"line\");'), (1159, '        let msg = pl.decode(&mut buf).unwrap().unwrap();'), (1160, '        assert!(msg.eof());'), (1162, '        let (req, _) = reader.decode(&mut buf).unwrap().unwrap();'), (1163, '        assert!(req.chunked().unwrap());'), (1164, '        assert_eq!(*req.method(), Method::POST);'), (1165, '        assert!(req.chunked().unwrap());'), (1169, '    fn test_http_request_chunked_payload_chunks() {'), (1171, '            \"GET /test HTTP/1.1\\\\r\\\\n\\\\'), (1172, '             transfer-encoding: chunked\\\\r\\\\n\\\\r\\\\n\",'), (1175, '        let mut reader = MessageDecoder::<Request>::default();'), (1176, '        let (req, pl) = reader.decode(&mut buf).unwrap().unwrap();'), (1177, '        let mut pl = pl.unwrap();'), (1178, '        assert!(req.chunked().unwrap());'), (1180, '        buf.extend(b\"4\\\\r\\\\n1111\\\\r\\\\n\");'), (1181, '        let msg = pl.decode(&mut buf).unwrap().unwrap();'), (1182, '        assert_eq!(msg.chunk().as_ref(), b\"1111\");'), (1184, '        buf.extend(b\"4\\\\r\\\\ndata\\\\r\");'), (1185, '        let msg = pl.decode(&mut buf).unwrap().unwrap();'), (1186, '        assert_eq!(msg.chunk().as_ref(), b\"data\");'), (1188, '        buf.extend(b\"\\\\n4\");'), (1189, '        assert!(pl.decode(&mut buf).unwrap().is_none());'), (1191, '        buf.extend(b\"\\\\r\");'), (1192, '        assert!(pl.decode(&mut buf).unwrap().is_none());'), (1193, '        buf.extend(b\"\\\\n\");'), (1194, '        assert!(pl.decode(&mut buf).unwrap().is_none());'), (1196, '        buf.extend(b\"li\");'), (1197, '        let msg = pl.decode(&mut buf).unwrap().unwrap();'), (1198, '        assert_eq!(msg.chunk().as_ref(), b\"li\");'), (1204, '        buf.extend(b\"ne\\\\r\\\\n0\\\\r\\\\n\");'), (1205, '        let msg = pl.decode(&mut buf).unwrap().unwrap();'), (1206, '        assert_eq!(msg.chunk().as_ref(), b\"ne\");'), (1207, '        assert!(pl.decode(&mut buf).unwrap().is_none());'), (1209, '        buf.extend(b\"\\\\r\\\\n\");'), (1210, '        assert!(pl.decode(&mut buf).unwrap().unwrap().eof());'), (1214, '    fn test_parse_chunked_payload_chunk_extension() {'), (1216, '            \"GET /test HTTP/1.1\\\\r\\\\n\\\\'), (1217, '            transfer-encoding: chunked\\\\r\\\\n\\\\'), (1218, '            \\\\r\\\\n\",'), (1221, '        let mut reader = MessageDecoder::<Request>::default();'), (1222, '        let (msg, pl) = reader.decode(&mut buf).unwrap().unwrap();'), (1223, '        let mut pl = pl.unwrap();'), (1224, '        assert!(msg.chunked().unwrap());'), (1226, '        buf.extend(b\"4;test\\\\r\\\\ndata\\\\r\\\\n4\\\\r\\\\nline\\\\r\\\\n0\\\\r\\\\n\\\\r\\\\n\"); // test: test\\\\r\\\\n\\\\r\\\\n\")'), (1227, '        let chunk = pl.decode(&mut buf).unwrap().unwrap().chunk();'), (1228, '        assert_eq!(chunk, Bytes::from_static(b\"data\"));'), (1229, '        let chunk = pl.decode(&mut buf).unwrap().unwrap().chunk();'), (1230, '        assert_eq!(chunk, Bytes::from_static(b\"line\"));'), (1231, '        let msg = pl.decode(&mut buf).unwrap().unwrap();'), (1232, '        assert!(msg.eof());'), (1236, '    fn test_response_http10_read_until_eof() {'), (1237, '        let mut buf = BytesMut::from(\"HTTP/1.0 200 Ok\\\\r\\\\n\\\\r\\\\ntest data\");'), (1239, '        let mut reader = MessageDecoder::<ResponseHead>::default();'), (1244, '        assert_eq!(chunk, PayloadItem::Chunk(Bytes::from_static(b\"test data\")));')]}",
    "num_lines_added": "102",
    "num_lines_deleted": "301",
    "nloc": "852"
  },
  {
    "file_change_id": "33119195630726",
    "hash": "e965d8298f421e9c89fe98b1300b8361e948c324",
    "old_path": "actix-http/src/h1/encoder.rs",
    "new_path": "actix-http/src/h1/encoder.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -81,6 +81,7 @@ pub(crate) trait MessageType: Sized {\n         match length {\n             BodySize::Stream => {\n                 if chunked {\n+                    skip_len = true;\n                     if camel_case {\n                         dst.put_slice(b\"\\r\\nTransfer-Encoding: chunked\\r\\n\")\n                     } else {\n",
    "diff_parsed": "{'added': [(84, '                    skip_len = true;')], 'deleted': []}",
    "num_lines_added": "1",
    "num_lines_deleted": "0",
    "nloc": "517"
  },
  {
    "file_change_id": "25886079542821",
    "hash": "e965d8298f421e9c89fe98b1300b8361e948c324",
    "old_path": "actix-http/src/h1/mod.rs",
    "new_path": "actix-http/src/h1/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,6 +1,8 @@\n //! HTTP/1 protocol implementation.\n+\n use bytes::{Bytes, BytesMut};\n \n+mod chunked;\n mod client;\n mod codec;\n mod decoder;\n",
    "diff_parsed": "{'added': [(5, 'mod chunked;')], 'deleted': []}",
    "num_lines_added": "1",
    "num_lines_deleted": "0",
    "nloc": "70"
  },
  {
    "file_change_id": "222233424658104",
    "hash": "0b962f218f0cdd796dadfe26c3f09e68f7861b26",
    "old_path": "frame/ethereum/src/lib.rs",
    "new_path": "frame/ethereum/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -190,6 +190,27 @@ pub mod pallet {\n \n \t\tfn validate_unsigned(_source: TransactionSource, call: &Self::Call) -> TransactionValidity {\n \t\t\tif let Call::transact(transaction) = call {\n+\t\t\t\t// We must ensure a transaction can pay the cost of its data bytes.\n+\t\t\t\t// If it can't it should not be included in a block.\n+\t\t\t\tlet mut gasometer = evm::gasometer::Gasometer::new(\n+\t\t\t\t\ttransaction.gas_limit.low_u64(),\n+\t\t\t\t\t<T as pallet_evm::Config>::config(),\n+\t\t\t\t);\n+\t\t\t\tlet transaction_cost = match transaction.action {\n+\t\t\t\t\tTransactionAction::Call(_) => {\n+\t\t\t\t\t\tevm::gasometer::call_transaction_cost(&transaction.input)\n+\t\t\t\t\t}\n+\t\t\t\t\tTransactionAction::Create => {\n+\t\t\t\t\t\tevm::gasometer::create_transaction_cost(&transaction.input)\n+\t\t\t\t\t}\n+\t\t\t\t};\n+\t\t\t\tif gasometer.record_transaction(transaction_cost).is_err() {\n+\t\t\t\t\treturn InvalidTransaction::Custom(\n+\t\t\t\t\t\tTransactionValidationError::InvalidGasLimit as u8,\n+\t\t\t\t\t)\n+\t\t\t\t\t.into();\n+\t\t\t\t}\n+\n \t\t\t\tif let Some(chain_id) = transaction.signature.chain_id() {\n \t\t\t\t\tif chain_id != T::ChainId::get() {\n \t\t\t\t\t\treturn InvalidTransaction::Custom(\n",
    "diff_parsed": "{'added': [(195, '\\t\\t\\t\\tlet mut gasometer = evm::gasometer::Gasometer::new('), (196, '\\t\\t\\t\\t\\ttransaction.gas_limit.low_u64(),'), (197, '\\t\\t\\t\\t\\t<T as pallet_evm::Config>::config(),'), (198, '\\t\\t\\t\\t);'), (199, '\\t\\t\\t\\tlet transaction_cost = match transaction.action {'), (200, '\\t\\t\\t\\t\\tTransactionAction::Call(_) => {'), (201, '\\t\\t\\t\\t\\t\\tevm::gasometer::call_transaction_cost(&transaction.input)'), (202, '\\t\\t\\t\\t\\t}'), (203, '\\t\\t\\t\\t\\tTransactionAction::Create => {'), (204, '\\t\\t\\t\\t\\t\\tevm::gasometer::create_transaction_cost(&transaction.input)'), (205, '\\t\\t\\t\\t\\t}'), (206, '\\t\\t\\t\\t};'), (207, '\\t\\t\\t\\tif gasometer.record_transaction(transaction_cost).is_err() {'), (208, '\\t\\t\\t\\t\\treturn InvalidTransaction::Custom('), (209, '\\t\\t\\t\\t\\t\\tTransactionValidationError::InvalidGasLimit as u8,'), (210, '\\t\\t\\t\\t\\t)'), (211, '\\t\\t\\t\\t\\t.into();'), (212, '\\t\\t\\t\\t}')], 'deleted': []}",
    "num_lines_added": "18",
    "num_lines_deleted": "0",
    "nloc": "436"
  },
  {
    "file_change_id": "24713868298993",
    "hash": "666c2554ea0e1728c35aa41178cf235920db888a",
    "old_path": "cranelift/codegen/src/machinst/vcode.rs",
    "new_path": "cranelift/codegen/src/machinst/vcode.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -17,6 +17,7 @@\n //! See the main module comment in `mod.rs` for more details on the VCode-based\n //! backend pipeline.\n \n+use crate::fx::FxHashMap;\n use crate::ir::{self, types, Constant, ConstantData, SourceLoc};\n use crate::machinst::*;\n use crate::settings;\n@@ -478,6 +479,19 @@ impl<I: VCodeInst> VCode<I> {\n         let mut inst_end_offsets = vec![0; self.insts.len()];\n         let mut label_inst_indices = vec![0; self.num_blocks()];\n \n+        // Map from instruction index to index in\n+        // `safepoint_slots`. We need this because we emit\n+        // instructions out-of-order, while the safepoint_insns /\n+        // safepoint_slots data structures are sorted in instruction\n+        // order.\n+        let mut safepoint_indices: FxHashMap<u32, usize> = FxHashMap::default();\n+        for (safepoint_idx, iix) in self.safepoint_insns.iter().enumerate() {\n+            // Disregard safepoints that ended up having no live refs.\n+            if self.safepoint_slots[safepoint_idx].len() > 0 {\n+                safepoint_indices.insert(*iix, safepoint_idx);\n+            }\n+        }\n+\n         // Construct the final order we emit code in: cold blocks at the end.\n         let mut final_order: SmallVec<[BlockIndex; 16]> = smallvec![];\n         let mut cold_blocks: SmallVec<[BlockIndex; 16]> = smallvec![];\n@@ -493,7 +507,6 @@ impl<I: VCodeInst> VCode<I> {\n         final_order.extend(cold_blocks.clone());\n \n         // Emit blocks.\n-        let mut safepoint_idx = 0;\n         let mut cur_srcloc = None;\n         let mut last_offset = None;\n         let mut start_of_cold_code = None;\n@@ -541,17 +554,11 @@ impl<I: VCodeInst> VCode<I> {\n                 }\n                 state.pre_sourceloc(cur_srcloc.unwrap_or(SourceLoc::default()));\n \n-                if safepoint_idx < self.safepoint_insns.len()\n-                    && self.safepoint_insns[safepoint_idx] == iix\n-                {\n-                    if self.safepoint_slots[safepoint_idx].len() > 0 {\n-                        let stack_map = self.abi.spillslots_to_stack_map(\n-                            &self.safepoint_slots[safepoint_idx][..],\n-                            &state,\n-                        );\n-                        state.pre_safepoint(stack_map);\n-                    }\n-                    safepoint_idx += 1;\n+                if let Some(safepoint_idx) = safepoint_indices.get(&iix) {\n+                    let stack_map = self\n+                        .abi\n+                        .spillslots_to_stack_map(&self.safepoint_slots[*safepoint_idx][..], &state);\n+                    state.pre_safepoint(stack_map);\n                 }\n \n                 self.insts[iix as usize].emit(&mut buffer, &self.emit_info, &mut state);\n",
    "diff_parsed": "{'added': [(20, 'use crate::fx::FxHashMap;'), (487, '        let mut safepoint_indices: FxHashMap<u32, usize> = FxHashMap::default();'), (488, '        for (safepoint_idx, iix) in self.safepoint_insns.iter().enumerate() {'), (490, '            if self.safepoint_slots[safepoint_idx].len() > 0 {'), (491, '                safepoint_indices.insert(*iix, safepoint_idx);'), (492, '            }'), (493, '        }'), (557, '                if let Some(safepoint_idx) = safepoint_indices.get(&iix) {'), (558, '                    let stack_map = self'), (559, '                        .abi'), (560, '                        .spillslots_to_stack_map(&self.safepoint_slots[*safepoint_idx][..], &state);'), (561, '                    state.pre_safepoint(stack_map);')], 'deleted': [(496, '        let mut safepoint_idx = 0;'), (544, '                if safepoint_idx < self.safepoint_insns.len()'), (545, '                    && self.safepoint_insns[safepoint_idx] == iix'), (546, '                {'), (547, '                    if self.safepoint_slots[safepoint_idx].len() > 0 {'), (548, '                        let stack_map = self.abi.spillslots_to_stack_map('), (549, '                            &self.safepoint_slots[safepoint_idx][..],'), (550, '                            &state,'), (551, '                        );'), (552, '                        state.pre_safepoint(stack_map);'), (553, '                    }'), (554, '                    safepoint_idx += 1;')]}",
    "num_lines_added": "12",
    "num_lines_deleted": "12",
    "nloc": "673"
  },
  {
    "file_change_id": "267416725937469",
    "hash": "666c2554ea0e1728c35aa41178cf235920db888a",
    "old_path": "tests/all/funcref.rs",
    "new_path": "tests/all/funcref.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -6,6 +6,7 @@ use wasmtime::*;\n #[test]\n fn pass_funcref_in_and_out_of_wasm() -> anyhow::Result<()> {\n     let (mut store, module) = ref_types_module(\n+        false,\n         r#\"\n             (module\n                 (func (export \"func\") (param funcref) (result funcref)\n@@ -60,7 +61,8 @@ fn pass_funcref_in_and_out_of_wasm() -> anyhow::Result<()> {\n \n     // Passing in a `funcref` from another store fails.\n     {\n-        let (mut other_store, other_module) = ref_types_module(r#\"(module (func (export \"f\")))\"#)?;\n+        let (mut other_store, other_module) =\n+            ref_types_module(false, r#\"(module (func (export \"f\")))\"#)?;\n         let other_store_instance = Instance::new(&mut other_store, &other_module, &[])?;\n         let f = other_store_instance\n             .get_func(&mut other_store, \"f\")\n@@ -77,6 +79,7 @@ fn pass_funcref_in_and_out_of_wasm() -> anyhow::Result<()> {\n #[test]\n fn receive_null_funcref_from_wasm() -> anyhow::Result<()> {\n     let (mut store, module) = ref_types_module(\n+        false,\n         r#\"\n             (module\n                 (func (export \"get-null\") (result funcref)\n",
    "diff_parsed": "{'added': [(9, '        false,'), (64, '        let (mut other_store, other_module) ='), (65, '            ref_types_module(false, r#\"(module (func (export \"f\")))\"#)?;'), (82, '        false,')], 'deleted': [(63, '        let (mut other_store, other_module) = ref_types_module(r#\"(module (func (export \"f\")))\"#)?;')]}",
    "num_lines_added": "4",
    "num_lines_deleted": "1",
    "nloc": "127"
  },
  {
    "file_change_id": "91770779978124",
    "hash": "666c2554ea0e1728c35aa41178cf235920db888a",
    "old_path": "tests/all/gc.rs",
    "new_path": "tests/all/gc.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -14,7 +14,17 @@ impl Drop for SetFlagOnDrop {\n \n #[test]\n fn smoke_test_gc() -> anyhow::Result<()> {\n+    smoke_test_gc_impl(false)\n+}\n+\n+#[test]\n+fn smoke_test_gc_epochs() -> anyhow::Result<()> {\n+    smoke_test_gc_impl(true)\n+}\n+\n+fn smoke_test_gc_impl(use_epochs: bool) -> anyhow::Result<()> {\n     let (mut store, module) = ref_types_module(\n+        use_epochs,\n         r#\"\n             (module\n                 (import \"\" \"\" (func $do_gc))\n@@ -69,6 +79,7 @@ fn smoke_test_gc() -> anyhow::Result<()> {\n #[test]\n fn wasm_dropping_refs() -> anyhow::Result<()> {\n     let (mut store, module) = ref_types_module(\n+        false,\n         r#\"\n             (module\n                 (func (export \"drop_ref\") (param externref)\n@@ -145,7 +156,7 @@ fn many_live_refs() -> anyhow::Result<()> {\n         \",\n     );\n \n-    let (mut store, module) = ref_types_module(&wat)?;\n+    let (mut store, module) = ref_types_module(false, &wat)?;\n \n     let live_refs = Arc::new(AtomicUsize::new(0));\n \n@@ -191,6 +202,7 @@ fn many_live_refs() -> anyhow::Result<()> {\n #[test]\n fn drop_externref_via_table_set() -> anyhow::Result<()> {\n     let (mut store, module) = ref_types_module(\n+        false,\n         r#\"\n             (module\n                 (table $t 1 externref)\n@@ -400,6 +412,7 @@ fn gee_i_sure_hope_refcounting_is_atomic() -> anyhow::Result<()> {\n #[test]\n fn global_init_no_leak() -> anyhow::Result<()> {\n     let (mut store, module) = ref_types_module(\n+        false,\n         r#\"\n             (module\n                 (import \"\" \"\" (global externref))\n@@ -424,6 +437,7 @@ fn global_init_no_leak() -> anyhow::Result<()> {\n #[test]\n fn no_gc_middle_of_args() -> anyhow::Result<()> {\n     let (mut store, module) = ref_types_module(\n+        false,\n         r#\"\n             (module\n                 (import \"\" \"return_some\" (func $return (result externref externref externref)))\n",
    "diff_parsed": "{'added': [(17, '    smoke_test_gc_impl(false)'), (18, '}'), (20, '#[test]'), (21, 'fn smoke_test_gc_epochs() -> anyhow::Result<()> {'), (22, '    smoke_test_gc_impl(true)'), (23, '}'), (25, 'fn smoke_test_gc_impl(use_epochs: bool) -> anyhow::Result<()> {'), (27, '        use_epochs,'), (82, '        false,'), (159, '    let (mut store, module) = ref_types_module(false, &wat)?;'), (205, '        false,'), (415, '        false,'), (440, '        false,')], 'deleted': [(148, '    let (mut store, module) = ref_types_module(&wat)?;')]}",
    "num_lines_added": "13",
    "num_lines_deleted": "1",
    "nloc": "413"
  },
  {
    "file_change_id": "49660639600954",
    "hash": "666c2554ea0e1728c35aa41178cf235920db888a",
    "old_path": "tests/all/main.rs",
    "new_path": "tests/all/main.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -33,6 +33,7 @@ mod wast;\n \n /// A helper to compile a module in a new store with reference types enabled.\n pub(crate) fn ref_types_module(\n+    use_epochs: bool,\n     source: &str,\n ) -> anyhow::Result<(wasmtime::Store<()>, wasmtime::Module)> {\n     use wasmtime::*;\n@@ -41,9 +42,15 @@ pub(crate) fn ref_types_module(\n \n     let mut config = Config::new();\n     config.wasm_reference_types(true);\n+    if use_epochs {\n+        config.epoch_interruption(true);\n+    }\n \n     let engine = Engine::new(&config)?;\n-    let store = Store::new(&engine, ());\n+    let mut store = Store::new(&engine, ());\n+    if use_epochs {\n+        store.set_epoch_deadline(1);\n+    }\n \n     let module = Module::new(&engine, source)?;\n \n",
    "diff_parsed": "{'added': [(36, '    use_epochs: bool,'), (45, '    if use_epochs {'), (46, '        config.epoch_interruption(true);'), (47, '    }'), (50, '    let mut store = Store::new(&engine, ());'), (51, '    if use_epochs {'), (52, '        store.set_epoch_deadline(1);'), (53, '    }')], 'deleted': [(46, '    let store = Store::new(&engine, ());')]}",
    "num_lines_added": "8",
    "num_lines_deleted": "1",
    "nloc": "54"
  },
  {
    "file_change_id": "265060090882625",
    "hash": "2a4d538",
    "old_path": "src/stack.rs",
    "new_path": "src/stack.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -53,7 +53,8 @@ impl<T: ?Sized, D: ::DataBuf> StackA<T, D> {\n         mem::size_of::<&T>() / mem::size_of::<usize>() - 1\n     }\n \n-    fn push_inner(&mut self, fat_ptr: &T) -> Result<&mut [usize], ()> {\n+\t/// Returns the metadata and data slots\n+    fn push_inner(&mut self, fat_ptr: &T) -> Result<(&mut [usize],&mut [usize]), ()> {\n         let bytes = mem::size_of_val(fat_ptr);\n         let words = super::round_to_words(bytes) + Self::meta_words();\n         // Check if there is sufficient space for the new item\n@@ -71,7 +72,7 @@ impl<T: ?Sized, D: ::DataBuf> StackA<T, D> {\n             meta.clone_from_slice(&ptr_words[1..]);\n \n             // Increment offset and return\n-            Ok(rv)\n+            Ok( (meta, rv) )\n         } else {\n             Err(())\n         }\n@@ -94,7 +95,7 @@ impl<T: ?Sized, D: ::DataBuf> StackA<T, D> {\n         );\n \n         match self.push_inner(f(&v)) {\n-            Ok(d) => {\n+            Ok((_,d)) => {\n                 // SAFE: Destination address is valid\n                 unsafe {\n                     ptr::write(d.as_mut_ptr() as *mut U, v);\n@@ -143,7 +144,7 @@ impl<T: ?Sized, D: ::DataBuf> StackA<T, D> {\n impl<D: ::DataBuf> StackA<str, D> {\n     /// Push the contents of a string slice as an item onto the stack\n     pub fn push_str(&mut self, v: &str) -> Result<(), ()> {\n-        self.push_inner(v).map(|d| unsafe {\n+        self.push_inner(v).map(|(_,d)| unsafe {\n             ptr::copy(v.as_bytes().as_ptr(), d.as_mut_ptr() as *mut u8, v.len());\n         })\n     }\n@@ -151,12 +152,24 @@ impl<D: ::DataBuf> StackA<str, D> {\n impl<D: ::DataBuf, T: Clone> StackA<[T], D> {\n     /// Pushes a set of items (cloning out of the input slice)\n     pub fn push_cloned(&mut self, v: &[T]) -> Result<(), ()> {\n-        self.push_inner(&v).map(|d| unsafe {\n-            let mut ptr = d.as_mut_ptr() as *mut T;\n-            for val in v {\n-                ptr::write(ptr, val.clone());\n-                ptr = ptr.offset(1);\n-            }\n-        })\n+        let (meta,d) = self.push_inner(&v)?;\n+\t\t// Prepare the slot with zeros (as if it's an empty slice)\n+\t\t// The length is updated as each item is written\n+\t\t// - This ensures that there's no drop issues during write\n+\t\tmeta[0] = 0;\n+\t\tfor v in d.iter_mut() {\n+\t\t\t*v = 0;\n+\t\t}\n+\n+\t\tunsafe {\n+\t\t\tlet mut ptr = d.as_mut_ptr() as *mut T;\n+\t\t\tfor val in v {\n+\t\t\t\tptr::write(ptr, val.clone());\n+\t\t\t\tmeta[0] += 1;\n+\t\t\t\tptr = ptr.offset(1);\n+\t\t\t}\n+\t\t}\n+\n+\t\tOk( () )\n     }\n }\n",
    "diff_parsed": "{'added': [(57, '    fn push_inner(&mut self, fat_ptr: &T) -> Result<(&mut [usize],&mut [usize]), ()> {'), (75, '            Ok( (meta, rv) )'), (98, '            Ok((_,d)) => {'), (147, '        self.push_inner(v).map(|(_,d)| unsafe {'), (155, '        let (meta,d) = self.push_inner(&v)?;'), (159, '\\t\\tmeta[0] = 0;'), (160, '\\t\\tfor v in d.iter_mut() {'), (161, '\\t\\t\\t*v = 0;'), (162, '\\t\\t}'), (164, '\\t\\tunsafe {'), (165, '\\t\\t\\tlet mut ptr = d.as_mut_ptr() as *mut T;'), (166, '\\t\\t\\tfor val in v {'), (167, '\\t\\t\\t\\tptr::write(ptr, val.clone());'), (168, '\\t\\t\\t\\tmeta[0] += 1;'), (169, '\\t\\t\\t\\tptr = ptr.offset(1);'), (170, '\\t\\t\\t}'), (171, '\\t\\t}'), (173, '\\t\\tOk( () )')], 'deleted': [(56, '    fn push_inner(&mut self, fat_ptr: &T) -> Result<&mut [usize], ()> {'), (74, '            Ok(rv)'), (97, '            Ok(d) => {'), (146, '        self.push_inner(v).map(|d| unsafe {'), (154, '        self.push_inner(&v).map(|d| unsafe {'), (155, '            let mut ptr = d.as_mut_ptr() as *mut T;'), (156, '            for val in v {'), (157, '                ptr::write(ptr, val.clone());'), (158, '                ptr = ptr.offset(1);'), (159, '            }'), (160, '        })')]}",
    "num_lines_added": "18",
    "num_lines_deleted": "11",
    "nloc": "123"
  },
  {
    "file_change_id": "268355118869549",
    "hash": "2a4d538",
    "old_path": "tests/stack.rs",
    "new_path": "tests/stack.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -114,3 +114,34 @@ fn destructors() {\n     drop(stack);\n     assert_eq!(v.get(), 2 + 3);\n }\n+\n+#[test]\n+fn slice_push_panic_safety() {\n+\tuse std::sync::atomic::{AtomicUsize,Ordering};\n+\tstatic COUNT: AtomicUsize = AtomicUsize::new(0);\n+\tstruct Sentinel(bool);\n+\timpl Clone for Sentinel {\n+\t\tfn clone(&self) -> Self {\n+\t\t\tif self.0 {\n+\t\t\t\tpanic!();\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tSentinel(self.0)\n+\t\t\t}\n+\t\t}\n+\t}\n+\timpl Drop for Sentinel {\n+\t\tfn drop(&mut self) {\n+\t\t\tCOUNT.fetch_add(1, Ordering::SeqCst);\n+\t\t}\n+\t}\n+\tlet input = [Sentinel(false), Sentinel(true)];\n+\n+\n+\tlet _ = ::std::panic::catch_unwind(::std::panic::AssertUnwindSafe(|| {\n+\t\tlet mut stack = ::stack_dst::StackA::<[Sentinel], [usize; 8]>::new();\n+\t\tlet _ = stack.push_cloned(&input);\n+\t\t}));\n+\tassert_eq!(COUNT.load(Ordering::SeqCst), 1);\n+}\n+\n",
    "diff_parsed": "{'added': [(118, '#[test]'), (119, 'fn slice_push_panic_safety() {'), (120, '\\tuse std::sync::atomic::{AtomicUsize,Ordering};'), (121, '\\tstatic COUNT: AtomicUsize = AtomicUsize::new(0);'), (122, '\\tstruct Sentinel(bool);'), (123, '\\timpl Clone for Sentinel {'), (124, '\\t\\tfn clone(&self) -> Self {'), (125, '\\t\\t\\tif self.0 {'), (126, '\\t\\t\\t\\tpanic!();'), (127, '\\t\\t\\t}'), (128, '\\t\\t\\telse {'), (129, '\\t\\t\\t\\tSentinel(self.0)'), (130, '\\t\\t\\t}'), (131, '\\t\\t}'), (132, '\\t}'), (133, '\\timpl Drop for Sentinel {'), (134, '\\t\\tfn drop(&mut self) {'), (135, '\\t\\t\\tCOUNT.fetch_add(1, Ordering::SeqCst);'), (136, '\\t\\t}'), (137, '\\t}'), (138, '\\tlet input = [Sentinel(false), Sentinel(true)];'), (141, '\\tlet _ = ::std::panic::catch_unwind(::std::panic::AssertUnwindSafe(|| {'), (142, '\\t\\tlet mut stack = ::stack_dst::StackA::<[Sentinel], [usize; 8]>::new();'), (143, '\\t\\tlet _ = stack.push_cloned(&input);'), (144, '\\t\\t}));'), (145, '\\tassert_eq!(COUNT.load(Ordering::SeqCst), 1);'), (146, '}')], 'deleted': []}",
    "num_lines_added": "27",
    "num_lines_deleted": "0",
    "nloc": "119"
  },
  {
    "file_change_id": "177291040784481",
    "hash": "2327d3b774927fdf48903c0bdc1ca7ec93c7c8d0",
    "old_path": "src/trace.rs",
    "new_path": "src/trace.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -61,7 +61,7 @@ pub unsafe fn config_log(callback: Option<fn(c_int, &str)>) -> Result<()> {\n pub fn log(err_code: c_int, msg: &str) {\n     let msg = CString::new(msg).expect(\"SQLite log messages cannot contain embedded zeroes\");\n     unsafe {\n-        ffi::sqlite3_log(err_code, msg.as_ptr());\n+        ffi::sqlite3_log(err_code, b\"%s\\0\" as *const _ as *const c_char, msg.as_ptr());\n     }\n }\n \n",
    "diff_parsed": "{'added': [(64, '        ffi::sqlite3_log(err_code, b\"%s\\\\0\" as *const _ as *const c_char, msg.as_ptr());')], 'deleted': [(64, '        ffi::sqlite3_log(err_code, msg.as_ptr());')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "135"
  },
  {
    "file_change_id": "7858321098591",
    "hash": "8f93123efef5c1361086688fe4f34c83c89cec02",
    "old_path": "src/proto/h1/role.rs",
    "new_path": "src/proto/h1/role.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -213,6 +213,8 @@ impl Http1Transaction for Server {\n                     if headers::is_chunked_(&value) {\n                         is_te_chunked = true;\n                         decoder = DecodedLength::CHUNKED;\n+                    } else {\n+                        is_te_chunked = false;\n                     }\n                 }\n                 header::CONTENT_LENGTH => {\n@@ -1444,6 +1446,16 @@ mod tests {\n             \"transfer-encoding doesn't end in chunked\",\n         );\n \n+        parse_err(\n+            \"\\\n+             POST / HTTP/1.1\\r\\n\\\n+             transfer-encoding: chunked\\r\\n\\\n+             transfer-encoding: afterlol\\r\\n\\\n+             \\r\\n\\\n+             \",\n+            \"transfer-encoding multiple lines doesn't end in chunked\",\n+        );\n+\n         // http/1.0\n \n         assert_eq!(\n",
    "diff_parsed": "{'added': [(216, '                    } else {'), (217, '                        is_te_chunked = false;'), (1449, '        parse_err('), (1450, '            \"\\\\'), (1451, '             POST / HTTP/1.1\\\\r\\\\n\\\\'), (1452, '             transfer-encoding: chunked\\\\r\\\\n\\\\'), (1453, '             transfer-encoding: afterlol\\\\r\\\\n\\\\'), (1454, '             \\\\r\\\\n\\\\'), (1455, '             \",'), (1456, '            \"transfer-encoding multiple lines doesn\\'t end in chunked\",'), (1457, '        );')], 'deleted': []}",
    "num_lines_added": "11",
    "num_lines_deleted": "0",
    "nloc": "1882"
  },
  {
    "file_change_id": "189886963010974",
    "hash": "d44011a69e0674acfa9c59bd7ad7f0523eb61d42",
    "old_path": "runtime/ops/fs.rs",
    "new_path": "runtime/ops/fs.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1370,7 +1370,8 @@ fn op_symlink_sync(\n   let oldpath = PathBuf::from(&args.oldpath);\n   let newpath = PathBuf::from(&args.newpath);\n \n-  state.borrow_mut::<Permissions>().write.check(&newpath)?;\n+  state.borrow_mut::<Permissions>().write.check_all()?;\n+  state.borrow_mut::<Permissions>().read.check_all()?;\n \n   debug!(\n     \"op_symlink_sync {} {}\",\n@@ -1432,7 +1433,8 @@ async fn op_symlink_async(\n \n   {\n     let mut state = state.borrow_mut();\n-    state.borrow_mut::<Permissions>().write.check(&newpath)?;\n+    state.borrow_mut::<Permissions>().write.check_all()?;\n+    state.borrow_mut::<Permissions>().read.check_all()?;\n   }\n \n   tokio::task::spawn_blocking(move || {\n",
    "diff_parsed": "{'added': [(1373, '  state.borrow_mut::<Permissions>().write.check_all()?;'), (1374, '  state.borrow_mut::<Permissions>().read.check_all()?;'), (1436, '    state.borrow_mut::<Permissions>().write.check_all()?;'), (1437, '    state.borrow_mut::<Permissions>().read.check_all()?;')], 'deleted': [(1373, '  state.borrow_mut::<Permissions>().write.check(&newpath)?;'), (1435, '    state.borrow_mut::<Permissions>().write.check(&newpath)?;')]}",
    "num_lines_added": "4",
    "num_lines_deleted": "2",
    "nloc": "1726"
  },
  {
    "file_change_id": "211667177589065",
    "hash": "1a2efcdbe68e5e7fd0a05836ac32d2cde78a0b2e",
    "old_path": "tests/script.rs",
    "new_path": "tests/script.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -51,6 +51,7 @@ macro_rules! test_cases {\n                 out_json.reverse();\n \n                 let mut results = Vec::new();\n+                let mut state = Value::null();\n                 for (id, mut json) in in_json.into_iter().enumerate() {\n                     let uri = EventOriginUri{\n                         host: \"test\".into(),\n@@ -62,7 +63,6 @@ macro_rules! test_cases {\n                     };\n                     let context = EventContext::new(id as u64, Some(&uri));\n                     let mut meta = Value::from(Object::default());\n-                    let mut state = Value::null();\n                     match script.run(&context, AggrType::Tick, &mut json, &mut state, &mut meta)? {\n                         Return::Drop => (),\n                         Return::EmitEvent{..} => results.push(json),\n@@ -154,6 +154,7 @@ test_cases!(\n     // TODO\n     // const_in_const_lookup,\n     // INSERT\n+    merge_assign_target_state,\n     expr_path,\n     patch_default,\n     patch_default_key,\n@@ -186,7 +187,7 @@ test_cases!(\n     heredoc_quoted_curly,\n     string_interpolation_import,\n     string_interpolation_prefix,\n-    patch_in_place,\n+    patch_assign_target,\n     tuple_pattern,\n     pattern_cmp,\n     pass_args,\n",
    "diff_parsed": "{'added': [(54, '                let mut state = Value::null();'), (157, '    merge_assign_target_state,'), (190, '    patch_assign_target,')], 'deleted': [(65, '                    let mut state = Value::null();'), (189, '    patch_in_place,')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "2",
    "nloc": "179"
  },
  {
    "file_change_id": "216300931728582",
    "hash": "1a2efcdbe68e5e7fd0a05836ac32d2cde78a0b2e",
    "old_path": "tests/script_runtime_error.rs",
    "new_path": "tests/script_runtime_error.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -105,10 +105,10 @@ macro_rules! ignore_cases {\n                 file.read_to_string(&mut err)?;\n                 let _err = err.trim();\n \n+                let mut state = Value::null();\n                 if let Some(mut json) =  in_json.pop() {\n                     let context = EventContext::new(0, None);\n                     let mut meta = Value::object();\n-                    let mut state = Value::null();\n                     let s = script.run(&context, AggrType::Tick, &mut json, &mut state, &mut meta);\n                     if let Err(e) = s {\n                         let mut h = Dumb::new();\n@@ -144,8 +144,8 @@ test_cases!(\n     function_error_n,\n     match_bad_guard_type,\n     match_no_clause_hit,\n-    merge_in_place_new_no_object,\n-    merge_in_place_target_no_object,\n+    merge_assign_target_new_no_object,\n+    merge_assign_target_target_no_object,\n     merge_new_no_object,\n     merge_target_no_object,\n     missing_local,\n",
    "diff_parsed": "{'added': [(108, '                let mut state = Value::null();'), (147, '    merge_assign_target_new_no_object,'), (148, '    merge_assign_target_target_no_object,')], 'deleted': [(111, '                    let mut state = Value::null();'), (147, '    merge_in_place_new_no_object,'), (148, '    merge_in_place_target_no_object,')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "3",
    "nloc": "149"
  },
  {
    "file_change_id": "157582011657995",
    "hash": "1a2efcdbe68e5e7fd0a05836ac32d2cde78a0b2e",
    "old_path": "tremor-script/src/ast.rs",
    "new_path": "tremor-script/src/ast.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -961,10 +961,6 @@ pub enum Expr<'script> {\n     Match(Box<Match<'script, Self>>),\n     /// IfElse style match expression\n     IfElse(Box<IfElse<'script, Self>>),\n-    /// In place patch expression\n-    PatchInPlace(Box<Patch<'script>>),\n-    /// In place merge expression\n-    MergeInPlace(Box<Merge<'script>>),\n     /// Assignment expression\n     Assign {\n         /// Id\n",
    "diff_parsed": "{'added': [], 'deleted': [(965, \"    PatchInPlace(Box<Patch<'script>>),\"), (967, \"    MergeInPlace(Box<Merge<'script>>),\")]}",
    "num_lines_added": "0",
    "num_lines_deleted": "2",
    "nloc": "2420"
  },
  {
    "file_change_id": "234410312511069",
    "hash": "1a2efcdbe68e5e7fd0a05836ac32d2cde78a0b2e",
    "old_path": "tremor-script/src/ast/base_expr.rs",
    "new_path": "tremor-script/src/ast/base_expr.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -248,8 +248,6 @@ impl<'script> BaseExpr for Expr<'script> {\n             Expr::Emit(e) => e.mid(),\n             Expr::Imut(e) => e.mid(),\n             Expr::Match(e) => e.mid(),\n-            Expr::MergeInPlace(e) => e.mid(),\n-            Expr::PatchInPlace(e) => e.mid(),\n             Expr::IfElse(e) => e.mid(),\n         }\n     }\n",
    "diff_parsed": "{'added': [], 'deleted': [(251, '            Expr::MergeInPlace(e) => e.mid(),'), (252, '            Expr::PatchInPlace(e) => e.mid(),')]}",
    "num_lines_added": "0",
    "num_lines_deleted": "2",
    "nloc": "497"
  },
  {
    "file_change_id": "199350867682699",
    "hash": "1a2efcdbe68e5e7fd0a05836ac32d2cde78a0b2e",
    "old_path": "tremor-script/src/ast/raw.rs",
    "new_path": "tremor-script/src/ast/raw.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -18,14 +18,14 @@\n \n use crate::{\n     ast::{\n-        base_expr, eq::AstEq, query, upable::Upable, ArrayPattern, ArrayPredicatePattern,\n-        AssignPattern, BinExpr, BinOpKind, Bytes, BytesPart, ClauseGroup, Comprehension,\n-        ComprehensionCase, Costly, DefaultCase, EmitExpr, EventPath, Expr, ExprPath, Expression,\n-        Field, FnDecl, FnDoc, Helper, Ident, IfElse, ImutExpr, ImutExprInt, Invocable, Invoke,\n-        InvokeAggr, InvokeAggrFn, List, Literal, LocalPath, Match, Merge, MetadataPath, ModDoc,\n-        NodeMetas, Patch, PatchOperation, Path, Pattern, PredicateClause, PredicatePattern, Record,\n-        RecordPattern, Recur, ReservedPath, Script, Segment, StatePath, StrLitElement, StringLit,\n-        TestExpr, TuplePattern, UnaryExpr, UnaryOpKind,\n+        base_expr, query, upable::Upable, ArrayPattern, ArrayPredicatePattern, AssignPattern,\n+        BinExpr, BinOpKind, Bytes, BytesPart, ClauseGroup, Comprehension, ComprehensionCase,\n+        Costly, DefaultCase, EmitExpr, EventPath, Expr, ExprPath, Expression, Field, FnDecl, FnDoc,\n+        Helper, Ident, IfElse, ImutExpr, ImutExprInt, Invocable, Invoke, InvokeAggr, InvokeAggrFn,\n+        List, Literal, LocalPath, Match, Merge, MetadataPath, ModDoc, NodeMetas, Patch,\n+        PatchOperation, Path, Pattern, PredicateClause, PredicatePattern, Record, RecordPattern,\n+        Recur, ReservedPath, Script, Segment, StatePath, StrLitElement, StringLit, TestExpr,\n+        TuplePattern, UnaryExpr, UnaryOpKind,\n     },\n     errors::{\n         err_generic, error_generic, error_missing_effector, error_oops, Error, ErrorKind, Result,\n@@ -646,28 +646,16 @@ impl<'script> Upable<'script> for ExprRaw<'script> {\n                 let path = a.path.up(helper)?;\n                 let mid = helper.add_meta(a.start, a.end);\n                 match a.expr.up(helper)? {\n-                    Expr::Imut(ImutExprInt::Merge(m)) => {\n-                        if path.ast_eq(&m.target) {\n-                            Expr::MergeInPlace(Box::new(*m))\n-                        } else {\n-                            Expr::Assign {\n-                                mid,\n-                                path,\n-                                expr: Box::new(ImutExprInt::Merge(m).into()),\n-                            }\n-                        }\n-                    }\n-                    Expr::Imut(ImutExprInt::Patch(m)) => {\n-                        if path.ast_eq(&m.target) {\n-                            Expr::PatchInPlace(Box::new(*m))\n-                        } else {\n-                            Expr::Assign {\n-                                mid,\n-                                path,\n-                                expr: Box::new(ImutExprInt::Patch(m).into()),\n-                            }\n-                        }\n-                    }\n+                    Expr::Imut(ImutExprInt::Merge(m)) => Expr::Assign {\n+                        mid,\n+                        path,\n+                        expr: Box::new(ImutExprInt::Merge(m).into()),\n+                    },\n+                    Expr::Imut(ImutExprInt::Patch(m)) => Expr::Assign {\n+                        mid,\n+                        path,\n+                        expr: Box::new(ImutExprInt::Patch(m).into()),\n+                    },\n                     expr => Expr::Assign {\n                         mid,\n                         path,\n",
    "diff_parsed": "{'added': [(21, '        base_expr, query, upable::Upable, ArrayPattern, ArrayPredicatePattern, AssignPattern,'), (22, '        BinExpr, BinOpKind, Bytes, BytesPart, ClauseGroup, Comprehension, ComprehensionCase,'), (23, '        Costly, DefaultCase, EmitExpr, EventPath, Expr, ExprPath, Expression, Field, FnDecl, FnDoc,'), (24, '        Helper, Ident, IfElse, ImutExpr, ImutExprInt, Invocable, Invoke, InvokeAggr, InvokeAggrFn,'), (25, '        List, Literal, LocalPath, Match, Merge, MetadataPath, ModDoc, NodeMetas, Patch,'), (26, '        PatchOperation, Path, Pattern, PredicateClause, PredicatePattern, Record, RecordPattern,'), (27, '        Recur, ReservedPath, Script, Segment, StatePath, StrLitElement, StringLit, TestExpr,'), (28, '        TuplePattern, UnaryExpr, UnaryOpKind,'), (649, '                    Expr::Imut(ImutExprInt::Merge(m)) => Expr::Assign {'), (650, '                        mid,'), (651, '                        path,'), (652, '                        expr: Box::new(ImutExprInt::Merge(m).into()),'), (653, '                    },'), (654, '                    Expr::Imut(ImutExprInt::Patch(m)) => Expr::Assign {'), (655, '                        mid,'), (656, '                        path,'), (657, '                        expr: Box::new(ImutExprInt::Patch(m).into()),'), (658, '                    },')], 'deleted': [(21, '        base_expr, eq::AstEq, query, upable::Upable, ArrayPattern, ArrayPredicatePattern,'), (22, '        AssignPattern, BinExpr, BinOpKind, Bytes, BytesPart, ClauseGroup, Comprehension,'), (23, '        ComprehensionCase, Costly, DefaultCase, EmitExpr, EventPath, Expr, ExprPath, Expression,'), (24, '        Field, FnDecl, FnDoc, Helper, Ident, IfElse, ImutExpr, ImutExprInt, Invocable, Invoke,'), (25, '        InvokeAggr, InvokeAggrFn, List, Literal, LocalPath, Match, Merge, MetadataPath, ModDoc,'), (26, '        NodeMetas, Patch, PatchOperation, Path, Pattern, PredicateClause, PredicatePattern, Record,'), (27, '        RecordPattern, Recur, ReservedPath, Script, Segment, StatePath, StrLitElement, StringLit,'), (28, '        TestExpr, TuplePattern, UnaryExpr, UnaryOpKind,'), (649, '                    Expr::Imut(ImutExprInt::Merge(m)) => {'), (650, '                        if path.ast_eq(&m.target) {'), (651, '                            Expr::MergeInPlace(Box::new(*m))'), (652, '                        } else {'), (653, '                            Expr::Assign {'), (654, '                                mid,'), (655, '                                path,'), (656, '                                expr: Box::new(ImutExprInt::Merge(m).into()),'), (657, '                            }'), (658, '                        }'), (659, '                    }'), (660, '                    Expr::Imut(ImutExprInt::Patch(m)) => {'), (661, '                        if path.ast_eq(&m.target) {'), (662, '                            Expr::PatchInPlace(Box::new(*m))'), (663, '                        } else {'), (664, '                            Expr::Assign {'), (665, '                                mid,'), (666, '                                path,'), (667, '                                expr: Box::new(ImutExprInt::Patch(m).into()),'), (668, '                            }'), (669, '                        }'), (670, '                    }')]}",
    "num_lines_added": "18",
    "num_lines_deleted": "30",
    "nloc": "2394"
  },
  {
    "file_change_id": "167785239986642",
    "hash": "1a2efcdbe68e5e7fd0a05836ac32d2cde78a0b2e",
    "old_path": "tremor-script/src/ast/to_static.rs",
    "new_path": "tremor-script/src/ast/to_static.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -159,8 +159,6 @@ impl<'script> Expr<'script> {\n         match self {\n             Expr::Match(e) => Expr::Match(Box::new(e.into_static())),\n             Expr::IfElse(e) => Expr::IfElse(Box::new(e.into_static())),\n-            Expr::PatchInPlace(e) => Expr::PatchInPlace(Box::new(e.into_static())),\n-            Expr::MergeInPlace(e) => Expr::MergeInPlace(Box::new(e.into_static())),\n             Expr::Assign { mid, path, expr } => Expr::Assign {\n                 mid,\n                 path: path.into_static(),\n",
    "diff_parsed": "{'added': [], 'deleted': [(162, '            Expr::PatchInPlace(e) => Expr::PatchInPlace(Box::new(e.into_static())),'), (163, '            Expr::MergeInPlace(e) => Expr::MergeInPlace(Box::new(e.into_static())),')]}",
    "num_lines_added": "0",
    "num_lines_deleted": "2",
    "nloc": "1036"
  },
  {
    "file_change_id": "68994094943068",
    "hash": "1a2efcdbe68e5e7fd0a05836ac32d2cde78a0b2e",
    "old_path": "tremor-script/src/interpreter/expr.rs",
    "new_path": "tremor-script/src/interpreter/expr.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -13,24 +13,23 @@\n // limitations under the License.\n \n use super::{\n-    merge_values, patch_value, resolve, resolve_value, set_local_shadow, test_guard,\n-    test_predicate_expr, Env, ExecOpts, LocalStack, NULL,\n+    resolve, resolve_value, set_local_shadow, test_guard, test_predicate_expr, Env, ExecOpts,\n+    LocalStack, NULL,\n };\n use crate::errors::{\n     error_assign_array, error_assign_to_const, error_bad_key_err, error_invalid_assign_target,\n-    error_need_obj, error_need_obj_err, error_no_clause_hit, Result,\n+    error_need_obj_err, error_no_clause_hit, Result,\n };\n use crate::prelude::*;\n use crate::registry::RECUR_PTR;\n use crate::{\n     ast::{\n         BaseExpr, ClauseGroup, ClausePreCondition, Comprehension, DefaultCase, EmitExpr, EventPath,\n-        Expr, IfElse, ImutExprInt, Match, Merge, Patch, Path, Segment,\n+        Expr, IfElse, ImutExprInt, Match, Path, Segment,\n     },\n     errors::error_oops_err,\n };\n use crate::{stry, Value};\n-use matches::matches;\n use std::mem;\n use std::{\n     borrow::{Borrow, Cow},\n@@ -219,104 +218,6 @@ impl<'script> Expr<'script> {\n         }\n     }\n \n-    fn patch_in_place<'run, 'event>(\n-        opts: ExecOpts,\n-        env: &'run Env<'run, 'event>,\n-        event: &'run Value<'event>,\n-        state: &'run Value<'static>,\n-        meta: &'run Value<'event>,\n-        local: &'run LocalStack<'event>,\n-        expr: &'run Patch<'event>,\n-    ) -> Result<Cow<'run, Value<'event>>> {\n-        // This function is called when we encounter code that consumes a value\n-        // to patch it. So the following code:\n-        // ```tremor\n-        // let event = patch event of insert \"key\" => \"value\" end\n-        // ```\n-        // When executed on it's own would clone the event, add a key and\n-        // overwrite original event.\n-        //\n-        // We optimise this as:\n-        // ```\n-        // patch_in_place event of insert \"key\" => \"value\" end\n-        // ```\n-        //\n-        // This code is generated in impl Upable for ExprRaw where the following\n-        // checks are performed:\n-        //\n-        // 1) the patch is on the RHS of an assignment\n-        // 2) the path of the assigned value and the path of the patched\n-        //    expression are identical.\n-        //\n-        // In turn this guarantees (at compile time):\n-        //\n-        // 1) The target (`expr`) is a path lookup\n-        // 2) The target is not a known constant as otherwise the assignment\n-        //    will complan\n-        // 3) this leave the `expr` to be either a local, the event, the state,\n-        //    metadata or a subkey thereof.\n-        //\n-        // And the following guarantees at run time:\n-        //\n-        // 1) the `expr` is an existing key of the mentioned categories,\n-        //    otherwise `expr.target.run` will error.\n-        // 2) `value` will never be owned (however the resolve function is\n-        //    generic so it needs to return a Cow)\n-\n-        let value: Cow<'run, Value<'event>> =\n-            stry!(expr.target.run(opts, env, event, state, meta, local));\n-        debug_assert!(\n-            !matches!(value, Cow::Owned(_)),\n-            \"We should never see a owned value here as patch_in_place is only ever called on existing data in event, state, meta or local\"\n-        );\n-        let v: &Value<'event> = value.borrow();\n-        // ALLOW: https://github.com/tremor-rs/tremor-runtime/issues/1032\n-        #[allow(mutable_transmutes, clippy::transmute_ptr_to_ptr)]\n-        // ALLOW: https://github.com/tremor-rs/tremor-runtime/issues/1032\n-        let v: &mut Value<'event> = unsafe { mem::transmute(v) };\n-        stry!(patch_value(opts, env, event, state, meta, local, v, expr));\n-        Ok(value)\n-    }\n-\n-    fn merge_in_place<'run, 'event>(\n-        &'run self,\n-        opts: ExecOpts,\n-        env: &'run Env<'run, 'event>,\n-        event: &'run mut Value<'event>,\n-        state: &'run mut Value<'static>,\n-        meta: &'run mut Value<'event>,\n-        local: &'run mut LocalStack<'event>,\n-        expr: &'run Merge<'event>,\n-    ) -> Result<Cow<'run, Value<'event>>> {\n-        // Please see the soundness reasoning in `patch_in_place` for details\n-        // those functions perform the same function just with slighty different\n-        // operations.\n-        let value_cow: Cow<'run, Value<'event>> =\n-            stry!(expr.target.run(opts, env, event, state, meta, local));\n-        debug_assert!(\n-            !matches!(value_cow, Cow::Owned(_)),\n-            \"We should never see a owned value here as merge_in_place is only ever called on existing data in event, state, meta or local\"\n-        );\n-\n-        if value_cow.is_object() {\n-            let value: &Value<'event> = value_cow.borrow();\n-            // ALLOW: https://github.com/tremor-rs/tremor-runtime/issues/1032\n-            #[allow(mutable_transmutes, clippy::transmute_ptr_to_ptr)]\n-            // ALLOW: https://github.com/tremor-rs/tremor-runtime/issues/1032\n-            let value: &mut Value<'event> = unsafe { mem::transmute(value) };\n-            let replacement = stry!(expr.expr.run(opts, env, event, state, meta, local,));\n-\n-            if replacement.is_object() {\n-                stry!(merge_values(self, &expr.expr, value, &replacement));\n-                Ok(value_cow)\n-            } else {\n-                error_need_obj(self, &expr.expr, replacement.value_type(), env.meta)\n-            }\n-        } else {\n-            error_need_obj(self, &expr.target, value_cow.value_type(), env.meta)\n-        }\n-    }\n-\n     // TODO: Quite some overlap with `ImutExprInt::comprehension`\n     fn comprehension<'run, 'event>(\n         &'run self,\n@@ -641,12 +542,6 @@ impl<'script> Expr<'script> {\n             }\n             Expr::Match(ref expr) => self.match_expr(opts, env, event, state, meta, local, expr),\n             Expr::IfElse(ref expr) => self.if_expr(opts, env, event, state, meta, local, expr),\n-            Expr::MergeInPlace(ref expr) => self\n-                .merge_in_place(opts, env, event, state, meta, local, expr)\n-                .map(Cont::Cont),\n-            Expr::PatchInPlace(ref expr) => {\n-                Self::patch_in_place(opts, env, event, state, meta, local, expr).map(Cont::Cont)\n-            }\n             Expr::Comprehension(ref expr) => {\n                 self.comprehension(opts, env, event, state, meta, local, expr)\n             }\n",
    "diff_parsed": "{'added': [(16, '    resolve, resolve_value, set_local_shadow, test_guard, test_predicate_expr, Env, ExecOpts,'), (17, '    LocalStack, NULL,'), (21, '    error_need_obj_err, error_no_clause_hit, Result,'), (28, '        Expr, IfElse, ImutExprInt, Match, Path, Segment,')], 'deleted': [(16, '    merge_values, patch_value, resolve, resolve_value, set_local_shadow, test_guard,'), (17, '    test_predicate_expr, Env, ExecOpts, LocalStack, NULL,'), (21, '    error_need_obj, error_need_obj_err, error_no_clause_hit, Result,'), (28, '        Expr, IfElse, ImutExprInt, Match, Merge, Patch, Path, Segment,'), (33, 'use matches::matches;'), (222, \"    fn patch_in_place<'run, 'event>(\"), (223, '        opts: ExecOpts,'), (224, \"        env: &'run Env<'run, 'event>,\"), (225, \"        event: &'run Value<'event>,\"), (226, \"        state: &'run Value<'static>,\"), (227, \"        meta: &'run Value<'event>,\"), (228, \"        local: &'run LocalStack<'event>,\"), (229, \"        expr: &'run Patch<'event>,\"), (230, \"    ) -> Result<Cow<'run, Value<'event>>> {\"), (266, \"        let value: Cow<'run, Value<'event>> =\"), (267, '            stry!(expr.target.run(opts, env, event, state, meta, local));'), (268, '        debug_assert!('), (269, '            !matches!(value, Cow::Owned(_)),'), (270, '            \"We should never see a owned value here as patch_in_place is only ever called on existing data in event, state, meta or local\"'), (271, '        );'), (272, \"        let v: &Value<'event> = value.borrow();\"), (274, '        #[allow(mutable_transmutes, clippy::transmute_ptr_to_ptr)]'), (276, \"        let v: &mut Value<'event> = unsafe { mem::transmute(v) };\"), (277, '        stry!(patch_value(opts, env, event, state, meta, local, v, expr));'), (278, '        Ok(value)'), (279, '    }'), (281, \"    fn merge_in_place<'run, 'event>(\"), (282, \"        &'run self,\"), (283, '        opts: ExecOpts,'), (284, \"        env: &'run Env<'run, 'event>,\"), (285, \"        event: &'run mut Value<'event>,\"), (286, \"        state: &'run mut Value<'static>,\"), (287, \"        meta: &'run mut Value<'event>,\"), (288, \"        local: &'run mut LocalStack<'event>,\"), (289, \"        expr: &'run Merge<'event>,\"), (290, \"    ) -> Result<Cow<'run, Value<'event>>> {\"), (294, \"        let value_cow: Cow<'run, Value<'event>> =\"), (295, '            stry!(expr.target.run(opts, env, event, state, meta, local));'), (296, '        debug_assert!('), (297, '            !matches!(value_cow, Cow::Owned(_)),'), (298, '            \"We should never see a owned value here as merge_in_place is only ever called on existing data in event, state, meta or local\"'), (299, '        );'), (301, '        if value_cow.is_object() {'), (302, \"            let value: &Value<'event> = value_cow.borrow();\"), (304, '            #[allow(mutable_transmutes, clippy::transmute_ptr_to_ptr)]'), (306, \"            let value: &mut Value<'event> = unsafe { mem::transmute(value) };\"), (307, '            let replacement = stry!(expr.expr.run(opts, env, event, state, meta, local,));'), (309, '            if replacement.is_object() {'), (310, '                stry!(merge_values(self, &expr.expr, value, &replacement));'), (311, '                Ok(value_cow)'), (312, '            } else {'), (313, '                error_need_obj(self, &expr.expr, replacement.value_type(), env.meta)'), (314, '            }'), (315, '        } else {'), (316, '            error_need_obj(self, &expr.target, value_cow.value_type(), env.meta)'), (317, '        }'), (318, '    }'), (644, '            Expr::MergeInPlace(ref expr) => self'), (645, '                .merge_in_place(opts, env, event, state, meta, local, expr)'), (646, '                .map(Cont::Cont),'), (647, '            Expr::PatchInPlace(ref expr) => {'), (648, '                Self::patch_in_place(opts, env, event, state, meta, local, expr).map(Cont::Cont)'), (649, '            }')]}",
    "num_lines_added": "4",
    "num_lines_deleted": "63",
    "nloc": "495"
  },
  {
    "file_change_id": "260927689250275",
    "hash": "ae70b41d4f46641dbc45c7a4f87954aea356283e",
    "old_path": "src/compile.rs",
    "new_path": "src/compile.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -38,6 +38,16 @@ pub struct Compiler {\n     suffix_cache: SuffixCache,\n     utf8_seqs: Option<Utf8Sequences>,\n     byte_classes: ByteClassSet,\n+    // This keeps track of extra bytes allocated while compiling the regex\n+    // program. Currently, this corresponds to two things. First is the heap\n+    // memory allocated by Unicode character classes ('InstRanges'). Second is\n+    // a \"fake\" amount of memory used by empty sub-expressions, so that enough\n+    // empty sub-expressions will ultimately trigger the compiler to bail\n+    // because of a size limit restriction. (That empty sub-expressions don't\n+    // add to heap memory usage is more-or-less an implementation detail.) In\n+    // the second case, if we don't bail, then an excessively large repetition\n+    // on an empty sub-expression can result in the compiler using a very large\n+    // amount of CPU time.\n     extra_inst_bytes: usize,\n }\n \n@@ -260,7 +270,7 @@ impl Compiler {\n \n         self.check_size()?;\n         match *expr.kind() {\n-            Empty => Ok(None),\n+            Empty => self.c_empty(),\n             Literal(hir::Literal::Unicode(c)) => self.c_char(c),\n             Literal(hir::Literal::Byte(b)) => {\n                 assert!(self.compiled.uses_bytes());\n@@ -378,6 +388,19 @@ impl Compiler {\n         }\n     }\n \n+    fn c_empty(&mut self) -> ResultOrEmpty {\n+        // See: https://github.com/rust-lang/regex/security/advisories/GHSA-m5pq-gvj9-9vr8\n+        // See: CVE-2022-24713\n+        //\n+        // Since 'empty' sub-expressions don't increase the size of\n+        // the actual compiled object, we \"fake\" an increase in its\n+        // size so that our 'check_size_limit' routine will eventually\n+        // stop compilation if there are too many empty sub-expressions\n+        // (e.g., via a large repetition).\n+        self.extra_inst_bytes += std::mem::size_of::<Inst>();\n+        Ok(None)\n+    }\n+\n     fn c_capture(&mut self, first_slot: usize, expr: &Hir) -> ResultOrEmpty {\n         if self.num_exprs > 1 || self.compiled.is_dfa {\n             // Don't ever compile Save instructions for regex sets because\n@@ -496,7 +519,7 @@ impl Compiler {\n         let mut exprs = exprs.into_iter();\n         let Patch { mut hole, entry } = loop {\n             match exprs.next() {\n-                None => return Ok(None),\n+                None => return self.c_empty(),\n                 Some(e) => {\n                     if let Some(p) = self.c(e)? {\n                         break p;\n",
    "diff_parsed": "{'added': [(273, '            Empty => self.c_empty(),'), (391, '    fn c_empty(&mut self) -> ResultOrEmpty {'), (400, '        self.extra_inst_bytes += std::mem::size_of::<Inst>();'), (401, '        Ok(None)'), (402, '    }'), (522, '                None => return self.c_empty(),')], 'deleted': [(263, '            Empty => Ok(None),'), (499, '                None => return Ok(None),')]}",
    "num_lines_added": "6",
    "num_lines_deleted": "2",
    "nloc": "990"
  },
  {
    "file_change_id": "170086761793069",
    "hash": "ae70b41d4f46641dbc45c7a4f87954aea356283e",
    "old_path": "tests/test_default.rs",
    "new_path": "tests/test_default.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -150,3 +150,73 @@ fn regex_is_reasonably_small() {\n     assert_eq!(16, size_of::<bytes::Regex>());\n     assert_eq!(16, size_of::<bytes::RegexSet>());\n }\n+\n+// See: https://github.com/rust-lang/regex/security/advisories/GHSA-m5pq-gvj9-9vr8\n+// See: CVE-2022-24713\n+//\n+// We test that our regex compiler will correctly return a \"too big\" error when\n+// we try to use a very large repetition on an *empty* sub-expression.\n+//\n+// At the time this test was written, the regex compiler does not represent\n+// empty sub-expressions with any bytecode instructions. In effect, it's an\n+// \"optimization\" to leave them out, since they would otherwise correspond\n+// to an unconditional JUMP in the regex bytecode (i.e., an unconditional\n+// epsilon transition in the NFA graph). Therefore, an empty sub-expression\n+// represents an interesting case for the compiler's size limits. Since it\n+// doesn't actually contribute any additional memory to the compiled regex\n+// instructions, the size limit machinery never detects it. Instead, it just\n+// dumbly tries to compile the empty sub-expression N times, where N is the\n+// repetition size.\n+//\n+// When N is very large, this will cause the compiler to essentially spin and\n+// do nothing for a decently large amount of time. It causes the regex to take\n+// quite a bit of time to compile, despite the concrete syntax of the regex\n+// being quite small.\n+//\n+// The degree to which this is actually a problem is somewhat of a judgment\n+// call. Some regexes simply take a long time to compile. But in general, you\n+// should be able to reasonably control this by setting lower or higher size\n+// limits on the compiled object size. But this mitigation doesn't work at all\n+// for this case.\n+//\n+// This particular test is somewhat narrow. It merely checks that regex\n+// compilation will, at some point, return a \"too big\" error. Before the\n+// fix landed, this test would eventually fail because the regex would be\n+// successfully compiled (after enough time elapsed). So while this test\n+// doesn't check that we exit in a reasonable amount of time, it does at least\n+// check that we are properly returning an error at some point.\n+#[test]\n+fn big_empty_regex_fails() {\n+    use regex::Regex;\n+\n+    let result = Regex::new(\"(?:){4294967295}\");\n+    assert!(result.is_err());\n+}\n+\n+// Below is a \"billion laughs\" variant of the previous test case.\n+#[test]\n+fn big_empty_reps_chain_regex_fails() {\n+    use regex::Regex;\n+\n+    let result = Regex::new(\"(?:){64}{64}{64}{64}{64}{64}\");\n+    assert!(result.is_err());\n+}\n+\n+// Below is another situation where a zero-length sub-expression can be\n+// introduced.\n+#[test]\n+fn big_zero_reps_regex_fails() {\n+    use regex::Regex;\n+\n+    let result = Regex::new(r\"x{0}{4294967295}\");\n+    assert!(result.is_err());\n+}\n+\n+// Testing another case for completeness.\n+#[test]\n+fn empty_alt_regex_fails() {\n+    use regex::Regex;\n+\n+    let result = Regex::new(r\"(?:|){4294967295}\");\n+    assert!(result.is_err());\n+}\n",
    "diff_parsed": "{'added': [(188, '#[test]'), (189, 'fn big_empty_regex_fails() {'), (190, '    use regex::Regex;'), (192, '    let result = Regex::new(\"(?:){4294967295}\");'), (193, '    assert!(result.is_err());'), (194, '}'), (197, '#[test]'), (198, 'fn big_empty_reps_chain_regex_fails() {'), (199, '    use regex::Regex;'), (201, '    let result = Regex::new(\"(?:){64}{64}{64}{64}{64}{64}\");'), (202, '    assert!(result.is_err());'), (203, '}'), (207, '#[test]'), (208, 'fn big_zero_reps_regex_fails() {'), (209, '    use regex::Regex;'), (211, '    let result = Regex::new(r\"x{0}{4294967295}\");'), (212, '    assert!(result.is_err());'), (213, '}'), (216, '#[test]'), (217, 'fn empty_alt_regex_fails() {'), (218, '    use regex::Regex;'), (220, '    let result = Regex::new(r\"(?:|){4294967295}\");'), (221, '    assert!(result.is_err());'), (222, '}')], 'deleted': []}",
    "num_lines_added": "24",
    "num_lines_deleted": "0",
    "nloc": "145"
  },
  {
    "file_change_id": "124313553561333",
    "hash": "45fd77ee43c38eea4d6f4e2e56c1667a55ec654f",
    "old_path": "src/unlock_notify.rs",
    "new_path": "src/unlock_notify.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -26,12 +26,13 @@ impl UnlockNotification {\n         }\n     }\n \n-    fn fired(&mut self) {\n-        *self.mutex.lock().unwrap() = true;\n+    fn fired(&self) {\n+        let mut flag = self.mutex.lock().unwrap();\n+        *flag = true;\n         self.cond.notify_one();\n     }\n \n-    fn wait(&mut self) {\n+    fn wait(&self) {\n         let mut fired = self.mutex.lock().unwrap();\n         while !*fired {\n             fired = self.cond.wait(fired).unwrap();\n@@ -43,12 +44,9 @@ impl UnlockNotification {\n #[cfg(feature = \"unlock_notify\")]\n unsafe extern \"C\" fn unlock_notify_cb(ap_arg: *mut *mut c_void, n_arg: c_int) {\n     use std::slice::from_raw_parts;\n-    let args = from_raw_parts(ap_arg, n_arg as usize);\n-    for arg in args {\n-        let _ = catch_unwind(|| {\n-            let un: &mut UnlockNotification = &mut *(*arg as *mut UnlockNotification);\n-            un.fired()\n-        });\n+    let args = from_raw_parts(ap_arg as *const &UnlockNotification, n_arg as usize);\n+    for un in args {\n+        let _ = catch_unwind(std::panic::AssertUnwindSafe(|| un.fired()));\n     }\n }\n \n@@ -73,12 +71,12 @@ pub unsafe fn is_locked(db: *mut ffi::sqlite3, rc: c_int) -> bool {\n /// back the current transaction (if any).\n #[cfg(feature = \"unlock_notify\")]\n pub unsafe fn wait_for_unlock_notify(db: *mut ffi::sqlite3) -> c_int {\n-    let mut un = UnlockNotification::new();\n+    let un = UnlockNotification::new();\n     /* Register for an unlock-notify callback. */\n     let rc = ffi::sqlite3_unlock_notify(\n         db,\n         Some(unlock_notify_cb),\n-        &mut un as *mut UnlockNotification as *mut c_void,\n+        &un as *const UnlockNotification as *mut c_void,\n     );\n     debug_assert!(\n         rc == ffi::SQLITE_LOCKED || rc == ffi::SQLITE_LOCKED_SHAREDCACHE || rc == ffi::SQLITE_OK\n",
    "diff_parsed": "{'added': [(29, '    fn fired(&self) {'), (30, '        let mut flag = self.mutex.lock().unwrap();'), (31, '        *flag = true;'), (35, '    fn wait(&self) {'), (47, '    let args = from_raw_parts(ap_arg as *const &UnlockNotification, n_arg as usize);'), (48, '    for un in args {'), (49, '        let _ = catch_unwind(std::panic::AssertUnwindSafe(|| un.fired()));'), (74, '    let un = UnlockNotification::new();'), (79, '        &un as *const UnlockNotification as *mut c_void,')], 'deleted': [(29, '    fn fired(&mut self) {'), (30, '        *self.mutex.lock().unwrap() = true;'), (34, '    fn wait(&mut self) {'), (46, '    let args = from_raw_parts(ap_arg, n_arg as usize);'), (47, '    for arg in args {'), (48, '        let _ = catch_unwind(|| {'), (49, '            let un: &mut UnlockNotification = &mut *(*arg as *mut UnlockNotification);'), (50, '            un.fired()'), (51, '        });'), (76, '    let mut un = UnlockNotification::new();'), (81, '        &mut un as *mut UnlockNotification as *mut c_void,')]}",
    "num_lines_added": "9",
    "num_lines_deleted": "11",
    "nloc": "101"
  },
  {
    "file_change_id": "168914330292846",
    "hash": "e61e045f8c244de978401d186dcfd50838817297",
    "old_path": "src/jit.rs",
    "new_path": "src/jit.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -913,7 +913,7 @@ fn emit_muldivmod<E: UserDefinedError>(jit: &mut JitCompiler, opc: u8, src: u8,\n         X86Instruction::pop(RAX).emit(jit)?;\n     }\n \n-    if size == OperandSize::S32 && opc & ebpf::BPF_ALU_OP_MASK == ebpf::BPF_MUL {\n+    if size == OperandSize::S32 && (mul || sdiv)  {\n         X86Instruction::sign_extend_i32_to_i64(dst, dst).emit(jit)?;\n     }\n     Ok(())\n",
    "diff_parsed": "{'added': [(916, '    if size == OperandSize::S32 && (mul || sdiv)  {')], 'deleted': [(916, '    if size == OperandSize::S32 && opc & ebpf::BPF_ALU_OP_MASK == ebpf::BPF_MUL {')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "1599"
  },
  {
    "file_change_id": "278379213431624",
    "hash": "e61e045f8c244de978401d186dcfd50838817297",
    "old_path": "tests/ubpf_execution.rs",
    "new_path": "tests/ubpf_execution.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -838,6 +838,21 @@ fn test_sdiv32_imm() {\n     );\n }\n \n+#[test]\n+fn test_sdiv32_neg_imm() {\n+    test_interpreter_and_jit_asm!(\n+        \"\n+        lddw r0, 0x10000000c\n+        sdiv32 r0, -4\n+        exit\",\n+        [],\n+        (),\n+        0,\n+        { |_vm, res: Result| { res.unwrap() as i64 == -3 } },\n+        3\n+    );\n+}\n+\n #[test]\n fn test_sdiv32_reg() {\n     test_interpreter_and_jit_asm!(\n@@ -854,6 +869,22 @@ fn test_sdiv32_reg() {\n     );\n }\n \n+#[test]\n+fn test_sdiv32_neg_reg() {\n+    test_interpreter_and_jit_asm!(\n+        \"\n+        lddw r0, 0x10000000c\n+        mov r1, -4\n+        sdiv32 r0, r1\n+        exit\",\n+        [],\n+        (),\n+        0,\n+        { |_vm, res: Result| { res.unwrap() as i64 == -0x3 } },\n+        4\n+    );\n+}\n+\n #[test]\n fn test_div64_imm() {\n     test_interpreter_and_jit_asm!(\n",
    "diff_parsed": "{'added': [(841, '#[test]'), (842, 'fn test_sdiv32_neg_imm() {'), (843, '    test_interpreter_and_jit_asm!('), (844, '        \"'), (845, '        lddw r0, 0x10000000c'), (846, '        sdiv32 r0, -4'), (847, '        exit\",'), (848, '        [],'), (849, '        (),'), (850, '        0,'), (851, '        { |_vm, res: Result| { res.unwrap() as i64 == -3 } },'), (852, '        3'), (853, '    );'), (854, '}'), (872, '#[test]'), (873, 'fn test_sdiv32_neg_reg() {'), (874, '    test_interpreter_and_jit_asm!('), (875, '        \"'), (876, '        lddw r0, 0x10000000c'), (877, '        mov r1, -4'), (878, '        sdiv32 r0, r1'), (879, '        exit\",'), (880, '        [],'), (881, '        (),'), (882, '        0,'), (883, '        { |_vm, res: Result| { res.unwrap() as i64 == -0x3 } },'), (884, '        4'), (885, '    );'), (886, '}')], 'deleted': []}",
    "num_lines_added": "29",
    "num_lines_deleted": "0",
    "nloc": "4211"
  },
  {
    "file_change_id": "9603772360891",
    "hash": "b4e6dc76f4845ab03104187a42ac6d1bbc1e0021",
    "old_path": "src/daemon.rs",
    "new_path": "src/daemon.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -85,6 +85,7 @@ async fn main() -> Result<(), Box<dyn std::error::Error>> {\n     }\n \n     let load_config = || {\n+        seteuid(env::var(\"PKEXEC_UID\").unwrap().parse::<u32>().unwrap()); // Dropping privileges to invoking user.\n         let config_file_path: std::path::PathBuf = if args.is_present(\"config\") {\n             Path::new(args.value_of(\"config\").unwrap()).to_path_buf()\n         } else {\n@@ -114,7 +115,7 @@ async fn main() -> Result<(), Box<dyn std::error::Error>> {\n     };\n \n     let mut hotkeys = load_config();\n-\n+    seteuid(0); // Escalating back to root after reading config file.\n     log::trace!(\"Attempting to find all keyboard file descriptors.\");\n     let keyboard_devices: Vec<Device> =\n         evdev::enumerate().filter(check_device_is_keyboard).collect();\n@@ -399,3 +400,14 @@ pub fn fetch_xdg_config_path() -> std::path::PathBuf {\n     };\n     config_file_path\n }\n+\n+pub fn seteuid(uid: u32) {\n+    let uid = nix::unistd::Uid::from_raw(uid);\n+    match nix::unistd::seteuid(uid) {\n+        Ok(_) => log::debug!(\"Dropping privileges...\"),\n+        Err(e) => {\n+            log::error!(\"Failed to set UID: {:#?}\", e);\n+            exit(1);\n+        }\n+    }\n+}\n",
    "diff_parsed": "{'added': [(88, '        seteuid(env::var(\"PKEXEC_UID\").unwrap().parse::<u32>().unwrap()); // Dropping privileges to invoking user.'), (118, '    seteuid(0); // Escalating back to root after reading config file.'), (404, 'pub fn seteuid(uid: u32) {'), (405, '    let uid = nix::unistd::Uid::from_raw(uid);'), (406, '    match nix::unistd::seteuid(uid) {'), (407, '        Ok(_) => log::debug!(\"Dropping privileges...\"),'), (408, '        Err(e) => {'), (409, '            log::error!(\"Failed to set UID: {:#?}\", e);'), (410, '            exit(1);'), (411, '        }'), (412, '    }'), (413, '}')], 'deleted': []}",
    "num_lines_added": "12",
    "num_lines_deleted": "0",
    "nloc": "356"
  },
  {
    "file_change_id": "115056402623038",
    "hash": "2a36405339c87b16ed6c76e91ad5b76638fbdb0c",
    "old_path": "src/install.rs",
    "new_path": "src/install.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -16,9 +16,11 @@ use anyhow::{bail, Context, Result};\n use lazy_static::lazy_static;\n use nix::mount;\n use regex::Regex;\n-use std::fs::{copy as fscopy, create_dir_all, read_dir, File, OpenOptions};\n+use std::fs::{\n+    copy as fscopy, create_dir_all, read_dir, set_permissions, File, OpenOptions, Permissions,\n+};\n use std::io::{copy, Read, Seek, SeekFrom, Write};\n-use std::os::unix::fs::FileTypeExt;\n+use std::os::unix::fs::{FileTypeExt, PermissionsExt};\n use std::path::{Path, PathBuf};\n \n use crate::blockdev::*;\n@@ -248,7 +250,21 @@ fn write_ignition(\n     // make parent directory\n     let mut config_dest = mountpoint.to_path_buf();\n     config_dest.push(\"ignition\");\n-    create_dir_all(&config_dest).context(\"creating Ignition config directory\")?;\n+    if !config_dest.is_dir() {\n+        create_dir_all(&config_dest).with_context(|| {\n+            format!(\n+                \"creating Ignition config directory {}\",\n+                config_dest.display()\n+            )\n+        })?;\n+        // Ignition data may contain secrets; restrict to root\n+        set_permissions(&config_dest, Permissions::from_mode(0o700)).with_context(|| {\n+            format!(\n+                \"setting file mode for Ignition directory {}\",\n+                config_dest.display()\n+            )\n+        })?;\n+    }\n \n     // do the copy\n     config_dest.push(\"config.ign\");\n@@ -262,6 +278,13 @@ fn write_ignition(\n                 config_dest.display()\n             )\n         })?;\n+    // Ignition config may contain secrets; restrict to root\n+    set_permissions(&config_dest, Permissions::from_mode(0o600)).with_context(|| {\n+        format!(\n+            \"setting file mode for destination Ignition config {}\",\n+            config_dest.display()\n+        )\n+    })?;\n     copy(&mut config_in, &mut config_out).context(\"writing Ignition config\")?;\n \n     Ok(())\n",
    "diff_parsed": "{'added': [(19, 'use std::fs::{'), (20, '    copy as fscopy, create_dir_all, read_dir, set_permissions, File, OpenOptions, Permissions,'), (21, '};'), (23, 'use std::os::unix::fs::{FileTypeExt, PermissionsExt};'), (253, '    if !config_dest.is_dir() {'), (254, '        create_dir_all(&config_dest).with_context(|| {'), (255, '            format!('), (256, '                \"creating Ignition config directory {}\",'), (257, '                config_dest.display()'), (258, '            )'), (259, '        })?;'), (261, '        set_permissions(&config_dest, Permissions::from_mode(0o700)).with_context(|| {'), (262, '            format!('), (263, '                \"setting file mode for Ignition directory {}\",'), (264, '                config_dest.display()'), (265, '            )'), (266, '        })?;'), (267, '    }'), (282, '    set_permissions(&config_dest, Permissions::from_mode(0o600)).with_context(|| {'), (283, '        format!('), (284, '            \"setting file mode for destination Ignition config {}\",'), (285, '            config_dest.display()'), (286, '        )'), (287, '    })?;')], 'deleted': [(19, 'use std::fs::{copy as fscopy, create_dir_all, read_dir, File, OpenOptions};'), (21, 'use std::os::unix::fs::FileTypeExt;'), (251, '    create_dir_all(&config_dest).context(\"creating Ignition config directory\")?;')]}",
    "num_lines_added": "24",
    "num_lines_deleted": "3",
    "nloc": "542"
  },
  {
    "file_change_id": "166016255953525",
    "hash": "e661a4940df78fbb7b52c622ac4ae6a3a7f7d8aa",
    "old_path": "src/daemon.rs",
    "new_path": "src/daemon.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -39,6 +39,7 @@ impl KeyboardState {\n #[tokio::main]\n async fn main() -> Result<(), Box<dyn std::error::Error>> {\n     let args = set_command_line_args().get_matches();\n+    let invoking_uid = env::var(\"PKEXEC_UID\").unwrap().parse::<u32>().unwrap();\n     env::set_var(\"RUST_LOG\", \"swhkd=warn\");\n \n     if args.is_present(\"debug\") {\n@@ -48,7 +49,7 @@ async fn main() -> Result<(), Box<dyn std::error::Error>> {\n     env_logger::init();\n     log::trace!(\"Logger initialized.\");\n \n-    let pidfile: String = String::from(\"/tmp/swhkd.pid\");\n+    let pidfile: String = String::from(format!(\"/etc/swhkd/runtime/swhkd_{}.pid\", invoking_uid));\n     if Path::new(&pidfile).exists() {\n         log::trace!(\"Reading {} file and checking for running instances.\", pidfile);\n         let swhkd_pid = match fs::read_to_string(&pidfile) {\n@@ -85,7 +86,7 @@ async fn main() -> Result<(), Box<dyn std::error::Error>> {\n     }\n \n     let load_config = || {\n-        seteuid(env::var(\"PKEXEC_UID\").unwrap().parse::<u32>().unwrap()); // Dropping privileges to invoking user.\n+        seteuid(invoking_uid); // Dropping privileges to invoking user.\n         let config_file_path: std::path::PathBuf = if args.is_present(\"config\") {\n             Path::new(args.value_of(\"config\").unwrap()).to_path_buf()\n         } else {\n",
    "diff_parsed": "{'added': [(42, '    let invoking_uid = env::var(\"PKEXEC_UID\").unwrap().parse::<u32>().unwrap();'), (52, '    let pidfile: String = String::from(format!(\"/etc/swhkd/runtime/swhkd_{}.pid\", invoking_uid));'), (89, '        seteuid(invoking_uid); // Dropping privileges to invoking user.')], 'deleted': [(51, '    let pidfile: String = String::from(\"/tmp/swhkd.pid\");'), (88, '        seteuid(env::var(\"PKEXEC_UID\").unwrap().parse::<u32>().unwrap()); // Dropping privileges to invoking user.')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "2",
    "nloc": "355"
  },
  {
    "file_change_id": "98598921308321",
    "hash": "c9ef5bd63cad5c0c123344c072b490a1a9bcbe1f",
    "old_path": "src/vtab/array.rs",
    "new_path": "src/vtab/array.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -71,7 +71,7 @@ struct ArrayTab {\n     base: ffi::sqlite3_vtab,\n }\n \n-impl VTab for ArrayTab {\n+unsafe impl VTab for ArrayTab {\n     type Aux = ();\n     type Cursor = ArrayTabCursor;\n \n@@ -149,7 +149,7 @@ impl ArrayTabCursor {\n         }\n     }\n }\n-impl VTabCursor for ArrayTabCursor {\n+unsafe impl VTabCursor for ArrayTabCursor {\n     fn filter(&mut self, idx_num: c_int, _idx_str: Option<&str>, args: &Values<'_>) -> Result<()> {\n         if idx_num > 0 {\n             self.ptr = args.get_array(0)?;\n",
    "diff_parsed": "{'added': [(74, 'unsafe impl VTab for ArrayTab {'), (152, 'unsafe impl VTabCursor for ArrayTabCursor {')], 'deleted': [(74, 'impl VTab for ArrayTab {'), (152, 'impl VTabCursor for ArrayTabCursor {')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "177"
  },
  {
    "file_change_id": "29555819906332",
    "hash": "c9ef5bd63cad5c0c123344c072b490a1a9bcbe1f",
    "old_path": "src/vtab/csvtab.rs",
    "new_path": "src/vtab/csvtab.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -95,7 +95,7 @@ impl CSVTab {\n     }\n }\n \n-impl VTab for CSVTab {\n+unsafe impl VTab for CSVTab {\n     type Aux = ();\n     type Cursor = CSVTabCursor;\n \n@@ -296,7 +296,7 @@ impl CSVTabCursor {\n     }\n }\n \n-impl VTabCursor for CSVTabCursor {\n+unsafe impl VTabCursor for CSVTabCursor {\n     // Only a full table scan is supported.  So `filter` simply rewinds to\n     // the beginning.\n     fn filter(\n",
    "diff_parsed": "{'added': [(98, 'unsafe impl VTab for CSVTab {'), (299, 'unsafe impl VTabCursor for CSVTabCursor {')], 'deleted': [(98, 'impl VTab for CSVTab {'), (299, 'impl VTabCursor for CSVTabCursor {')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "341"
  },
  {
    "file_change_id": "135501686094385",
    "hash": "c9ef5bd63cad5c0c123344c072b490a1a9bcbe1f",
    "old_path": "src/vtab/mod.rs",
    "new_path": "src/vtab/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -189,7 +189,11 @@ impl VTabConnection {\n \n /// `feature = \"vtab\"` Virtual table instance trait.\n ///\n-/// Implementations must be like:\n+/// # Safety\n+///\n+/// The first item in a struct implementing VTab must be\n+/// `rusqlite::sqlite3_vtab`, and the struct must be `#[repr(C)]`.\n+///\n /// ```rust,ignore\n /// #[repr(C)]\n /// struct MyTab {\n@@ -200,7 +204,7 @@ impl VTabConnection {\n /// ```\n ///\n /// (See [SQLite doc](https://sqlite.org/c3ref/vtab.html))\n-pub trait VTab: Sized {\n+pub unsafe trait VTab: Sized {\n     type Aux;\n     type Cursor: VTabCursor;\n \n@@ -465,7 +469,7 @@ impl OrderBy<'_> {\n /// ```\n ///\n /// (See [SQLite doc](https://sqlite.org/c3ref/vtab_cursor.html))\n-pub trait VTabCursor: Sized {\n+pub unsafe trait VTabCursor: Sized {\n     /// Begin a search of a virtual table.\n     /// (See [SQLite doc](https://sqlite.org/vtab.html#the_xfilter_method))\n     fn filter(&mut self, idx_num: c_int, idx_str: Option<&str>, args: &Values<'_>) -> Result<()>;\n",
    "diff_parsed": "{'added': [(207, 'pub unsafe trait VTab: Sized {'), (472, 'pub unsafe trait VTabCursor: Sized {')], 'deleted': [(203, 'pub trait VTab: Sized {'), (468, 'pub trait VTabCursor: Sized {')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "861"
  },
  {
    "file_change_id": "166285934324102",
    "hash": "c9ef5bd63cad5c0c123344c072b490a1a9bcbe1f",
    "old_path": "src/vtab/series.rs",
    "new_path": "src/vtab/series.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -49,7 +49,7 @@ struct SeriesTab {\n     base: ffi::sqlite3_vtab,\n }\n \n-impl VTab for SeriesTab {\n+unsafe impl VTab for SeriesTab {\n     type Aux = ();\n     type Cursor = SeriesTabCursor;\n \n@@ -181,7 +181,7 @@ impl SeriesTabCursor {\n         SeriesTabCursor::default()\n     }\n }\n-impl VTabCursor for SeriesTabCursor {\n+unsafe impl VTabCursor for SeriesTabCursor {\n     fn filter(&mut self, idx_num: c_int, _idx_str: Option<&str>, args: &Values<'_>) -> Result<()> {\n         let idx_num = QueryPlanFlags::from_bits_truncate(idx_num);\n         let mut i = 0;\n",
    "diff_parsed": "{'added': [(52, 'unsafe impl VTab for SeriesTab {'), (184, 'unsafe impl VTabCursor for SeriesTabCursor {')], 'deleted': [(52, 'impl VTab for SeriesTab {'), (184, 'impl VTabCursor for SeriesTabCursor {')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "237"
  },
  {
    "file_change_id": "254020205306113",
    "hash": "da7904c04f82e1cb43cc42eaf6a1dba072b5c921",
    "old_path": "lib/extensions/serve_static.rs",
    "new_path": "lib/extensions/serve_static.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -320,7 +320,7 @@ impl ServeStatic {\n fn process_req(req: Request, cell: &RwLock<ServeStatic>) -> (Response, bool) {\n     let this = cell.read().unwrap();\n \n-    let mut path = format!(\"{}{}\", this.data_dir, req.path.replace(\"/..\", \"\"));\n+    let mut path = safe_path(req.path.to_owned());\n \n     // Add Index.html if path ends with /\n     if path.ends_with('/') {\n@@ -364,6 +364,14 @@ fn get_type(path: &str, types: &[(String, String)]) -> String {\n     \"application/octet-stream\".to_owned()\n }\n \n+#[inline]\n+fn safe_path(mut path: String) -> String {\n+    while path.contains(\"/..\") {\n+        path = path.replace(\"/..\", \"\");\n+    }\n+    path\n+}\n+\n /// Common MIME Types\n ///\n /// Used by Servestatic Extentions\n",
    "diff_parsed": "{'added': [(323, '    let mut path = safe_path(req.path.to_owned());'), (367, '#[inline]'), (368, 'fn safe_path(mut path: String) -> String {'), (369, '    while path.contains(\"/..\") {'), (370, '        path = path.replace(\"/..\", \"\");'), (371, '    }'), (372, '    path'), (373, '}')], 'deleted': [(323, '    let mut path = format!(\"{}{}\", this.data_dir, req.path.replace(\"/..\", \"\"));')]}",
    "num_lines_added": "8",
    "num_lines_deleted": "1",
    "nloc": "202"
  },
  {
    "file_change_id": "3595160241142",
    "hash": "0b620a09605afb815c6d8d8953bbb7a10a8c0575",
    "old_path": "src/server.rs",
    "new_path": "src/server.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -12,7 +12,7 @@ fn main() -> std::io::Result<()> {\n     env::set_var(\"RUST_LOG\", \"swhks=trace\");\n     env_logger::init();\n \n-    let pid_file_path = String::from(\"/tmp/swhks.pid\");\n+    let pid_file_path = String::from(format!(\"/run/user/{}/swhks.pid\", unistd::Uid::current()));\n     let sock_file_path = String::from(format!(\"/run/user/{}/swhkd.sock\", unistd::Uid::current()));\n \n     if Path::new(&pid_file_path).exists() {\n",
    "diff_parsed": "{'added': [(15, '    let pid_file_path = String::from(format!(\"/run/user/{}/swhks.pid\", unistd::Uid::current()));')], 'deleted': [(15, '    let pid_file_path = String::from(\"/tmp/swhks.pid\");')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "82"
  },
  {
    "file_change_id": "134076660697755",
    "hash": "8a93fdc6c9f4eb1d2f2a11b7ff1d12d70bf5a664",
    "old_path": "frame/evm/precompile/modexp/src/lib.rs",
    "new_path": "frame/evm/precompile/modexp/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -47,7 +47,10 @@ fn calculate_gas_cost(\n \t\t\twords += 1;\n \t\t}\n \n-\t\t// TODO: prevent/handle overflow\n+\t\t// Note: can't overflow because we take words to be some u64 value / 8, which is\n+\t\t// necessarily less than sqrt(u64::MAX).\n+\t\t// Additionally, both base_length and mod_length are bounded to 1024, so this has\n+\t\t// an upper bound of roughly (1024 / 8) squared\n \t\twords * words\n \t}\n \n@@ -63,8 +66,17 @@ fn calculate_gas_cost(\n \t\t\tlet bytes: [u8; 32] = [0xFF; 32];\n \t\t\tlet max_256_bit_uint = BigUint::from_bytes_be(&bytes);\n \n+\t\t\t// from the EIP spec:\n+\t\t\t// (8 * (exp_length - 32)) + ((exponent & (2**256 - 1)).bit_length() - 1)\n+\t\t\t//\n+\t\t\t// Notes:\n+\t\t\t// * exp_length is bounded to 1024 and is > 32\n+\t\t\t// * exponent can be zero, so we subtract 1 after adding the other terms (whose sum\n+\t\t\t//   must be > 0)\n+\t\t\t// * the addition can't overflow because the terms are both capped at roughly\n+\t\t\t//   8 * max size of exp_length (1024)\n \t\t\titeration_count =\n-\t\t\t\t(8 * (exp_length - 32)) + ((exponent.bitand(max_256_bit_uint)).bits() - 1);\n+\t\t\t\t(8 * (exp_length - 32)) + exponent.bitand(max_256_bit_uint).bits() - 1;\n \t\t}\n \n \t\tmax(iteration_count, 1)\n@@ -89,7 +101,7 @@ fn calculate_gas_cost(\n // 6) modulus, size as described above\n //\n //\n-// NOTE: input sizes are arbitrarily large (up to 256 bits), with the expectation\n+// NOTE: input sizes are bound to 1024 bytes, with the expectation\n //       that gas limits would be applied before actual computation.\n //\n //       maximum stack size will also prevent abuse.\n@@ -133,7 +145,7 @@ impl Precompile for Modexp {\n \t\tlet mod_len_big = BigUint::from_bytes_be(&buf);\n \t\tif mod_len_big > max_size_big {\n \t\t\treturn Err(PrecompileFailure::Error {\n-\t\t\t\texit_status: ExitError::Other(\"unreasonably large exponent length\".into()),\n+\t\t\t\texit_status: ExitError::Other(\"unreasonably large modulus length\".into()),\n \t\t\t});\n \t\t}\n \n@@ -162,7 +174,6 @@ impl Precompile for Modexp {\n \t\t\tlet exponent = BigUint::from_bytes_be(&input[exp_start..exp_start + exp_len]);\n \n \t\t\t// do our gas accounting\n-\t\t\t// TODO: we could technically avoid reading base first...\n \t\t\tlet gas_cost =\n \t\t\t\tcalculate_gas_cost(base_len as u64, exp_len as u64, mod_len as u64, &exponent);\n \t\t\tif let Some(gas_left) = target_gas {\n@@ -423,4 +434,39 @@ mod tests {\n \t\t\t}\n \t\t}\n \t}\n+\n+\t#[test]\n+\tfn test_zero_exp_with_33_length() {\n+\t\t// This is a regression test which ensures that the 'iteration_count' calculation\n+\t\t// in 'calculate_iteration_count' cannot underflow.\n+\t\t//\n+\t\t// In debug mode, this underflow could cause a panic. Otherwise, it causes N**0 to\n+\t\t// be calculated at more-than-normal expense.\n+\t\t//\n+\t\t// TODO: cite security advisory\n+\n+\t\tlet input = vec![\n+\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t\t0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t\t0, 0, 0, 0, 0, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,\n+\t\t];\n+\n+\t\tlet cost: u64 = 100000;\n+\n+\t\tlet context: Context = Context {\n+\t\t\taddress: Default::default(),\n+\t\t\tcaller: Default::default(),\n+\t\t\tapparent_value: From::from(0),\n+\t\t};\n+\n+\t\tlet precompile_result = Modexp::execute(&input, Some(cost), &context, false)\n+\t\t\t.expect(\"Modexp::execute() returned error\");\n+\n+\t\tassert_eq!(precompile_result.output.len(), 1); // should be same length as mod\n+\t\tlet result = BigUint::from_bytes_be(&precompile_result.output[..]);\n+\t\tlet expected = BigUint::parse_bytes(b\"0\", 10).unwrap();\n+\t\tassert_eq!(result, expected);\n+\t}\n }\n",
    "diff_parsed": "{'added': [(79, '\\t\\t\\t\\t(8 * (exp_length - 32)) + exponent.bitand(max_256_bit_uint).bits() - 1;'), (148, '\\t\\t\\t\\texit_status: ExitError::Other(\"unreasonably large modulus length\".into()),'), (438, '\\t#[test]'), (439, '\\tfn test_zero_exp_with_33_length() {'), (448, '\\t\\tlet input = vec!['), (449, '\\t\\t\\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,'), (450, '\\t\\t\\t0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,'), (451, '\\t\\t\\t0, 0, 0, 0, 0, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,'), (452, '\\t\\t\\t0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,'), (453, '\\t\\t\\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,'), (454, '\\t\\t];'), (456, '\\t\\tlet cost: u64 = 100000;'), (458, '\\t\\tlet context: Context = Context {'), (459, '\\t\\t\\taddress: Default::default(),'), (460, '\\t\\t\\tcaller: Default::default(),'), (461, '\\t\\t\\tapparent_value: From::from(0),'), (462, '\\t\\t};'), (464, '\\t\\tlet precompile_result = Modexp::execute(&input, Some(cost), &context, false)'), (465, '\\t\\t\\t.expect(\"Modexp::execute() returned error\");'), (467, '\\t\\tassert_eq!(precompile_result.output.len(), 1); // should be same length as mod'), (468, '\\t\\tlet result = BigUint::from_bytes_be(&precompile_result.output[..]);'), (469, '\\t\\tlet expected = BigUint::parse_bytes(b\"0\", 10).unwrap();'), (470, '\\t\\tassert_eq!(result, expected);'), (471, '\\t}')], 'deleted': [(67, '\\t\\t\\t\\t(8 * (exp_length - 32)) + ((exponent.bitand(max_256_bit_uint)).bits() - 1);'), (136, '\\t\\t\\t\\texit_status: ExitError::Other(\"unreasonably large exponent length\".into()),')]}",
    "num_lines_added": "24",
    "num_lines_deleted": "2",
    "nloc": "344"
  },
  {
    "file_change_id": "137608538513086",
    "hash": "f70b99dd575fab79d8a942111a6980431f006818",
    "old_path": "src/daemon.rs",
    "new_path": "src/daemon.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -94,11 +94,6 @@ async fn main() -> Result<(), Box<dyn std::error::Error>> {\n \n         log::debug!(\"Using config file path: {:#?}\", config_file_path);\n \n-        if !config_file_path.exists() {\n-            log::error!(\"{:#?} doesn't exist\", config_file_path);\n-            exit(1);\n-        }\n-\n         let hotkeys = match config::load(&config_file_path) {\n             Err(e) => {\n                 log::error!(\"Config Error: {}\", e);\n@@ -319,7 +314,9 @@ async fn main() -> Result<(), Box<dyn std::error::Error>> {\n }\n \n fn sock_send(command: &str) -> std::io::Result<()> {\n-    let mut stream = UnixStream::connect(\"/tmp/swhkd.sock\")?;\n+    let sock_file_path =\n+        String::from(format!(\"/run/user/{}/swhkd.sock\", env::var(\"PKEXEC_UID\").unwrap()));\n+    let mut stream = UnixStream::connect(sock_file_path)?;\n     stream.write_all(command.as_bytes())?;\n     Ok(())\n }\n@@ -402,11 +399,11 @@ pub fn fetch_xdg_config_path() -> std::path::PathBuf {\n }\n \n pub fn seteuid(uid: u32) {\n-    let uid = nix::unistd::Uid::from_raw(uid);\n+    let uid = Uid::from_raw(uid);\n     match nix::unistd::seteuid(uid) {\n         Ok(_) => log::debug!(\"Dropping privileges...\"),\n         Err(e) => {\n-            log::error!(\"Failed to set UID: {:#?}\", e);\n+            log::error!(\"Failed to set EUID: {:#?}\", e);\n             exit(1);\n         }\n     }\n",
    "diff_parsed": "{'added': [(317, '    let sock_file_path ='), (318, '        String::from(format!(\"/run/user/{}/swhkd.sock\", env::var(\"PKEXEC_UID\").unwrap()));'), (319, '    let mut stream = UnixStream::connect(sock_file_path)?;'), (402, '    let uid = Uid::from_raw(uid);'), (406, '            log::error!(\"Failed to set EUID: {:#?}\", e);')], 'deleted': [(97, '        if !config_file_path.exists() {'), (98, '            log::error!(\"{:#?} doesn\\'t exist\", config_file_path);'), (99, '            exit(1);'), (100, '        }'), (322, '    let mut stream = UnixStream::connect(\"/tmp/swhkd.sock\")?;'), (405, '    let uid = nix::unistd::Uid::from_raw(uid);'), (409, '            log::error!(\"Failed to set UID: {:#?}\", e);')]}",
    "num_lines_added": "5",
    "num_lines_deleted": "7",
    "nloc": "354"
  },
  {
    "file_change_id": "261242974323260",
    "hash": "f70b99dd575fab79d8a942111a6980431f006818",
    "old_path": "src/server.rs",
    "new_path": "src/server.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,3 +1,4 @@\n+use nix::unistd;\n use std::io::prelude::*;\n use std::os::unix::net::UnixListener;\n use std::{\n@@ -12,7 +13,7 @@ fn main() -> std::io::Result<()> {\n     env_logger::init();\n \n     let pid_file_path = String::from(\"/tmp/swhks.pid\");\n-    let sock_file_path = String::from(\"/tmp/swhkd.sock\");\n+    let sock_file_path = String::from(format!(\"/run/user/{}/swhkd.sock\", unistd::Uid::current()));\n \n     if Path::new(&pid_file_path).exists() {\n         log::trace!(\"Reading {} file and checking for running instances.\", pid_file_path);\n",
    "diff_parsed": "{'added': [(1, 'use nix::unistd;'), (16, '    let sock_file_path = String::from(format!(\"/run/user/{}/swhkd.sock\", unistd::Uid::current()));')], 'deleted': [(15, '    let sock_file_path = String::from(\"/tmp/swhkd.sock\");')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "1",
    "nloc": "82"
  },
  {
    "file_change_id": "122211172634369",
    "hash": "9e9f1fb44114078c000c78c72e691eeb9e7ac260",
    "old_path": "src/buffer.rs",
    "new_path": "src/buffer.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -192,7 +192,9 @@ impl From<Buffer> for Vec<u8> {\n         let len = buffer.copy_to(&mut slice);\n \n         unsafe {\n-            Vec::from_raw_parts(slice.as_mut_ptr(), len, slice.len())\n+            let vec = Vec::from_raw_parts(slice.as_mut_ptr(), len, slice.len());\n+            mem::forget(slice);\n+            vec\n         }\n     }\n }\n@@ -291,4 +293,17 @@ mod tests {\n         buffer.copy_to(&mut out);\n         assert!(&out == b\"hello world\");\n     }\n+\n+    #[test]\n+    fn vec_from_buffer() {\n+        let mut buffer = Buffer::new();\n+        let bytes = b\"hello world\";\n+        buffer.push(bytes);\n+\n+        assert!(buffer.len() == bytes.len());\n+\n+        let vec = Vec::from(buffer);\n+\n+        assert!(&vec == bytes);\n+    }\n }\n",
    "diff_parsed": "{'added': [(195, '            let vec = Vec::from_raw_parts(slice.as_mut_ptr(), len, slice.len());'), (196, '            mem::forget(slice);'), (197, '            vec'), (297, '    #[test]'), (298, '    fn vec_from_buffer() {'), (299, '        let mut buffer = Buffer::new();'), (300, '        let bytes = b\"hello world\";'), (301, '        buffer.push(bytes);'), (303, '        assert!(buffer.len() == bytes.len());'), (305, '        let vec = Vec::from(buffer);'), (307, '        assert!(&vec == bytes);'), (308, '    }')], 'deleted': [(195, '            Vec::from_raw_parts(slice.as_mut_ptr(), len, slice.len())')]}",
    "num_lines_added": "12",
    "num_lines_deleted": "1",
    "nloc": "212"
  },
  {
    "file_change_id": "68017136111100",
    "hash": "49b43f277afb1caf5104fcbe02bef581f7444686",
    "old_path": "src/socket.rs",
    "new_path": "src/socket.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -32,7 +32,7 @@ impl Socket {\n     pub fn bind(&self, addr: &SocketAddr) -> io::Result<()> {\n         let (addr, len) = addr2raw(addr);\n         unsafe {\n-            ::cvt(c::bind(self.inner.raw(), addr, len as c::socklen_t)).map(|_| ())\n+            ::cvt(c::bind(self.inner.raw(), addr.as_ptr(), len as c::socklen_t)).map(|_| ())\n         }\n     }\n \n@@ -45,7 +45,7 @@ impl Socket {\n     pub fn connect(&self, addr: &SocketAddr) -> io::Result<()> {\n         let (addr, len) = addr2raw(addr);\n         unsafe {\n-            ::cvt(c::connect(self.inner.raw(), addr, len)).map(|_| ())\n+            ::cvt(c::connect(self.inner.raw(), addr.as_ptr(), len)).map(|_| ())\n         }\n     }\n \n@@ -84,17 +84,130 @@ impl ::IntoInner for Socket {\n     fn into_inner(self) -> sys::Socket { self.inner }\n }\n \n-fn addr2raw(addr: &SocketAddr) -> (*const c::sockaddr, c::socklen_t) {\n-    match *addr {\n-        SocketAddr::V4(ref a) => {\n-            (a as *const _ as *const _, mem::size_of_val(a) as c::socklen_t)\n-        }\n-        SocketAddr::V6(ref a) => {\n-            (a as *const _ as *const _, mem::size_of_val(a) as c::socklen_t)\n-        }\n+/// A type with the same memory layout as `c::sockaddr`. Used in converting Rust level\n+/// SocketAddr* types into their system representation. The benefit of this specific\n+/// type over using `c::sockaddr_storage` is that this type is exactly as large as it\n+/// needs to be and not a lot larger.\n+#[repr(C)]\n+pub(crate) union SocketAddrCRepr {\n+    v4: c::sockaddr_in,\n+    v6: c::sockaddr_in6,\n+}\n+\n+impl SocketAddrCRepr {\n+    pub(crate) fn as_ptr(&self) -> *const c::sockaddr {\n+        self as *const _ as *const c::sockaddr\n     }\n }\n \n+fn addr2raw(addr: &SocketAddr) -> (SocketAddrCRepr, c::socklen_t) {\n+    match addr {\n+        &SocketAddr::V4(ref v4) => addr2raw_v4(v4),\n+        &SocketAddr::V6(ref v6) => addr2raw_v6(v6),\n+    }\n+}\n+\n+#[cfg(unix)]\n+fn addr2raw_v4(addr: &SocketAddrV4) -> (SocketAddrCRepr, c::socklen_t) {\n+    let sin_addr = c::in_addr {\n+        s_addr: u32::from(*addr.ip()).to_be(),\n+    };\n+\n+    let sockaddr = SocketAddrCRepr {\n+        v4: c::sockaddr_in {\n+            sin_family: c::AF_INET as c::sa_family_t,\n+            sin_port: addr.port().to_be(),\n+            sin_addr,\n+            sin_zero: [0; 8],\n+            #[cfg(any(\n+                target_os = \"dragonfly\",\n+                target_os = \"freebsd\",\n+                target_os = \"ios\",\n+                target_os = \"macos\",\n+                target_os = \"netbsd\",\n+                target_os = \"openbsd\"\n+            ))]\n+            sin_len: 0,\n+        },\n+    };\n+    (sockaddr, mem::size_of::<c::sockaddr_in>() as c::socklen_t)\n+}\n+\n+#[cfg(windows)]\n+fn addr2raw_v4(addr: &SocketAddrV4) -> (SocketAddrCRepr, c::socklen_t) {\n+    let sin_addr = unsafe {\n+        let mut s_un = mem::zeroed::<c::in_addr_S_un>();\n+        *s_un.S_addr_mut() = u32::from(*addr.ip()).to_be();\n+        c::IN_ADDR { S_un: s_un }\n+    };\n+\n+    let sockaddr = SocketAddrCRepr {\n+        v4: c::sockaddr_in {\n+            sin_family: c::AF_INET as c::sa_family_t,\n+            sin_port: addr.port().to_be(),\n+            sin_addr,\n+            sin_zero: [0; 8],\n+        },\n+    };\n+    (sockaddr, mem::size_of::<c::sockaddr_in>() as c::socklen_t)\n+}\n+\n+#[cfg(unix)]\n+fn addr2raw_v6(addr: &SocketAddrV6) -> (SocketAddrCRepr, c::socklen_t) {\n+    let sin6_addr = {\n+        let mut sin6_addr = unsafe { mem::zeroed::<c::in6_addr>() };\n+        sin6_addr.s6_addr = addr.ip().octets();\n+        sin6_addr\n+    };\n+\n+    let sockaddr = SocketAddrCRepr {\n+        v6: c::sockaddr_in6 {\n+            sin6_family: c::AF_INET6 as c::sa_family_t,\n+            sin6_port: addr.port().to_be(),\n+            sin6_addr,\n+            sin6_flowinfo: addr.flowinfo(),\n+            sin6_scope_id: addr.scope_id(),\n+            #[cfg(any(\n+                target_os = \"dragonfly\",\n+                target_os = \"freebsd\",\n+                target_os = \"ios\",\n+                target_os = \"macos\",\n+                target_os = \"netbsd\",\n+                target_os = \"openbsd\"\n+            ))]\n+            sin6_len: 0,\n+            #[cfg(any(target_os = \"solaris\", target_os = \"illumos\"))]\n+            __sin6_src_id: 0,\n+        },\n+    };\n+    (sockaddr, mem::size_of::<c::sockaddr_in6>() as c::socklen_t)\n+}\n+\n+#[cfg(windows)]\n+fn addr2raw_v6(addr: &SocketAddrV6) -> (SocketAddrCRepr, c::socklen_t) {\n+    let sin6_addr = unsafe {\n+        let mut u = mem::zeroed::<c::in6_addr_u>();\n+        *u.Byte_mut() = addr.ip().octets();\n+        c::IN6_ADDR { u }\n+    };\n+    let scope_id = unsafe {\n+        let mut u = mem::zeroed::<c::SOCKADDR_IN6_LH_u>();\n+        *u.sin6_scope_id_mut() = addr.scope_id();\n+        u\n+    };\n+\n+    let sockaddr = SocketAddrCRepr {\n+        v6: c::sockaddr_in6 {\n+            sin6_family: c::AF_INET6 as c::sa_family_t,\n+            sin6_port: addr.port().to_be(),\n+            sin6_addr,\n+            sin6_flowinfo: addr.flowinfo(),\n+            u: scope_id,\n+        },\n+    };\n+    (sockaddr, mem::size_of::<c::sockaddr_in6>() as c::socklen_t)\n+}\n+\n fn raw2addr(storage: &c::sockaddr_storage, len: c::socklen_t) -> io::Result<SocketAddr> {\n     match storage.ss_family as c_int {\n         c::AF_INET => {\n",
    "diff_parsed": "{'added': [(35, '            ::cvt(c::bind(self.inner.raw(), addr.as_ptr(), len as c::socklen_t)).map(|_| ())'), (48, '            ::cvt(c::connect(self.inner.raw(), addr.as_ptr(), len)).map(|_| ())'), (91, '#[repr(C)]'), (92, 'pub(crate) union SocketAddrCRepr {'), (93, '    v4: c::sockaddr_in,'), (94, '    v6: c::sockaddr_in6,'), (95, '}'), (97, 'impl SocketAddrCRepr {'), (98, '    pub(crate) fn as_ptr(&self) -> *const c::sockaddr {'), (99, '        self as *const _ as *const c::sockaddr'), (103, 'fn addr2raw(addr: &SocketAddr) -> (SocketAddrCRepr, c::socklen_t) {'), (104, '    match addr {'), (105, '        &SocketAddr::V4(ref v4) => addr2raw_v4(v4),'), (106, '        &SocketAddr::V6(ref v6) => addr2raw_v6(v6),'), (107, '    }'), (108, '}'), (110, '#[cfg(unix)]'), (111, 'fn addr2raw_v4(addr: &SocketAddrV4) -> (SocketAddrCRepr, c::socklen_t) {'), (112, '    let sin_addr = c::in_addr {'), (113, '        s_addr: u32::from(*addr.ip()).to_be(),'), (114, '    };'), (116, '    let sockaddr = SocketAddrCRepr {'), (117, '        v4: c::sockaddr_in {'), (118, '            sin_family: c::AF_INET as c::sa_family_t,'), (119, '            sin_port: addr.port().to_be(),'), (120, '            sin_addr,'), (121, '            sin_zero: [0; 8],'), (122, '            #[cfg(any('), (123, '                target_os = \"dragonfly\",'), (124, '                target_os = \"freebsd\",'), (125, '                target_os = \"ios\",'), (126, '                target_os = \"macos\",'), (127, '                target_os = \"netbsd\",'), (128, '                target_os = \"openbsd\"'), (129, '            ))]'), (130, '            sin_len: 0,'), (131, '        },'), (132, '    };'), (133, '    (sockaddr, mem::size_of::<c::sockaddr_in>() as c::socklen_t)'), (134, '}'), (136, '#[cfg(windows)]'), (137, 'fn addr2raw_v4(addr: &SocketAddrV4) -> (SocketAddrCRepr, c::socklen_t) {'), (138, '    let sin_addr = unsafe {'), (139, '        let mut s_un = mem::zeroed::<c::in_addr_S_un>();'), (140, '        *s_un.S_addr_mut() = u32::from(*addr.ip()).to_be();'), (141, '        c::IN_ADDR { S_un: s_un }'), (142, '    };'), (144, '    let sockaddr = SocketAddrCRepr {'), (145, '        v4: c::sockaddr_in {'), (146, '            sin_family: c::AF_INET as c::sa_family_t,'), (147, '            sin_port: addr.port().to_be(),'), (148, '            sin_addr,'), (149, '            sin_zero: [0; 8],'), (150, '        },'), (151, '    };'), (152, '    (sockaddr, mem::size_of::<c::sockaddr_in>() as c::socklen_t)'), (153, '}'), (155, '#[cfg(unix)]'), (156, 'fn addr2raw_v6(addr: &SocketAddrV6) -> (SocketAddrCRepr, c::socklen_t) {'), (157, '    let sin6_addr = {'), (158, '        let mut sin6_addr = unsafe { mem::zeroed::<c::in6_addr>() };'), (159, '        sin6_addr.s6_addr = addr.ip().octets();'), (160, '        sin6_addr'), (161, '    };'), (163, '    let sockaddr = SocketAddrCRepr {'), (164, '        v6: c::sockaddr_in6 {'), (165, '            sin6_family: c::AF_INET6 as c::sa_family_t,'), (166, '            sin6_port: addr.port().to_be(),'), (167, '            sin6_addr,'), (168, '            sin6_flowinfo: addr.flowinfo(),'), (169, '            sin6_scope_id: addr.scope_id(),'), (170, '            #[cfg(any('), (171, '                target_os = \"dragonfly\",'), (172, '                target_os = \"freebsd\",'), (173, '                target_os = \"ios\",'), (174, '                target_os = \"macos\",'), (175, '                target_os = \"netbsd\",'), (176, '                target_os = \"openbsd\"'), (177, '            ))]'), (178, '            sin6_len: 0,'), (179, '            #[cfg(any(target_os = \"solaris\", target_os = \"illumos\"))]'), (180, '            __sin6_src_id: 0,'), (181, '        },'), (182, '    };'), (183, '    (sockaddr, mem::size_of::<c::sockaddr_in6>() as c::socklen_t)'), (184, '}'), (186, '#[cfg(windows)]'), (187, 'fn addr2raw_v6(addr: &SocketAddrV6) -> (SocketAddrCRepr, c::socklen_t) {'), (188, '    let sin6_addr = unsafe {'), (189, '        let mut u = mem::zeroed::<c::in6_addr_u>();'), (190, '        *u.Byte_mut() = addr.ip().octets();'), (191, '        c::IN6_ADDR { u }'), (192, '    };'), (193, '    let scope_id = unsafe {'), (194, '        let mut u = mem::zeroed::<c::SOCKADDR_IN6_LH_u>();'), (195, '        *u.sin6_scope_id_mut() = addr.scope_id();'), (196, '        u'), (197, '    };'), (199, '    let sockaddr = SocketAddrCRepr {'), (200, '        v6: c::sockaddr_in6 {'), (201, '            sin6_family: c::AF_INET6 as c::sa_family_t,'), (202, '            sin6_port: addr.port().to_be(),'), (203, '            sin6_addr,'), (204, '            sin6_flowinfo: addr.flowinfo(),'), (205, '            u: scope_id,'), (206, '        },'), (207, '    };'), (208, '    (sockaddr, mem::size_of::<c::sockaddr_in6>() as c::socklen_t)'), (209, '}')], 'deleted': [(35, '            ::cvt(c::bind(self.inner.raw(), addr, len as c::socklen_t)).map(|_| ())'), (48, '            ::cvt(c::connect(self.inner.raw(), addr, len)).map(|_| ())'), (87, 'fn addr2raw(addr: &SocketAddr) -> (*const c::sockaddr, c::socklen_t) {'), (88, '    match *addr {'), (89, '        SocketAddr::V4(ref a) => {'), (90, '            (a as *const _ as *const _, mem::size_of_val(a) as c::socklen_t)'), (91, '        }'), (92, '        SocketAddr::V6(ref a) => {'), (93, '            (a as *const _ as *const _, mem::size_of_val(a) as c::socklen_t)'), (94, '        }')]}",
    "num_lines_added": "109",
    "num_lines_deleted": "10",
    "nloc": "214"
  },
  {
    "file_change_id": "160106943141725",
    "hash": "49b43f277afb1caf5104fcbe02bef581f7444686",
    "old_path": "src/sys/windows/mod.rs",
    "new_path": "src/sys/windows/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -34,6 +34,7 @@ pub mod c {\n     pub use winapi::shared::ws2def::SOCKADDR as sockaddr;\n     pub use winapi::shared::ws2def::SOCKADDR_STORAGE as sockaddr_storage;\n     pub use winapi::shared::ws2def::SOCKADDR_IN as sockaddr_in;\n+    pub use winapi::shared::ws2def::ADDRESS_FAMILY as sa_family_t;\n     pub use winapi::shared::ws2ipdef::*;\n     pub use winapi::shared::ws2ipdef::SOCKADDR_IN6_LH as sockaddr_in6;\n     pub use winapi::shared::ws2ipdef::IP_MREQ as ip_mreq;\n",
    "diff_parsed": "{'added': [(37, '    pub use winapi::shared::ws2def::ADDRESS_FAMILY as sa_family_t;')], 'deleted': []}",
    "num_lines_added": "1",
    "num_lines_deleted": "0",
    "nloc": "92"
  },
  {
    "file_change_id": "190874785903451",
    "hash": "d90a02f582c03dfa0fd11c78d608d0974625ae5d",
    "old_path": "src/entry.rs",
    "new_path": "src/entry.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -413,11 +413,8 @@ impl<'a> EntryFields<'a> {\n             None => return Ok(false),\n         };\n \n-        if parent.symlink_metadata().is_err() {\n-            fs::create_dir_all(&parent).map_err(|e| {\n-                TarError::new(&format!(\"failed to create `{}`\", parent.display()), e)\n-            })?;\n-        }\n+        self.ensure_dir_created(&dst, parent)\n+            .map_err(|e| TarError::new(&format!(\"failed to create `{}`\", parent.display()), e))?;\n \n         let canon_target = self.validate_inside_dst(&dst, parent)?;\n \n@@ -761,6 +758,26 @@ impl<'a> EntryFields<'a> {\n         }\n     }\n \n+    fn ensure_dir_created(&self, dst: &Path, dir: &Path) -> io::Result<()> {\n+        let mut ancestor = dir;\n+        let mut dirs_to_create = Vec::new();\n+        while ancestor.symlink_metadata().is_err() {\n+            dirs_to_create.push(ancestor);\n+            if let Some(parent) = ancestor.parent() {\n+                ancestor = parent;\n+            } else {\n+                break;\n+            }\n+        }\n+        for ancestor in dirs_to_create.into_iter().rev() {\n+            if let Some(parent) = ancestor.parent() {\n+                self.validate_inside_dst(dst, parent)?;\n+            }\n+            fs::create_dir(ancestor)?;\n+        }\n+        Ok(())\n+    }\n+\n     fn validate_inside_dst(&self, dst: &Path, file_dst: &Path) -> io::Result<PathBuf> {\n         // Abort if target (canonical) parent is outside of `dst`\n         let canon_parent = file_dst.canonicalize().map_err(|err| {\n",
    "diff_parsed": "{'added': [(416, '        self.ensure_dir_created(&dst, parent)'), (417, '            .map_err(|e| TarError::new(&format!(\"failed to create `{}`\", parent.display()), e))?;'), (761, '    fn ensure_dir_created(&self, dst: &Path, dir: &Path) -> io::Result<()> {'), (762, '        let mut ancestor = dir;'), (763, '        let mut dirs_to_create = Vec::new();'), (764, '        while ancestor.symlink_metadata().is_err() {'), (765, '            dirs_to_create.push(ancestor);'), (766, '            if let Some(parent) = ancestor.parent() {'), (767, '                ancestor = parent;'), (768, '            } else {'), (769, '                break;'), (770, '            }'), (771, '        }'), (772, '        for ancestor in dirs_to_create.into_iter().rev() {'), (773, '            if let Some(parent) = ancestor.parent() {'), (774, '                self.validate_inside_dst(dst, parent)?;'), (775, '            }'), (776, '            fs::create_dir(ancestor)?;'), (777, '        }'), (778, '        Ok(())'), (779, '    }')], 'deleted': [(416, '        if parent.symlink_metadata().is_err() {'), (417, '            fs::create_dir_all(&parent).map_err(|e| {'), (418, '                TarError::new(&format!(\"failed to create `{}`\", parent.display()), e)'), (419, '            })?;'), (420, '        }')]}",
    "num_lines_added": "21",
    "num_lines_deleted": "5",
    "nloc": "602"
  },
  {
    "file_change_id": "263518597839406",
    "hash": "d90a02f582c03dfa0fd11c78d608d0974625ae5d",
    "old_path": "tests/entry.rs",
    "new_path": "tests/entry.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,7 +1,7 @@\n extern crate tar;\n extern crate tempfile;\n \n-use std::fs::File;\n+use std::fs::{create_dir, File};\n use std::io::Read;\n \n use tempfile::Builder;\n@@ -219,6 +219,36 @@ fn modify_link_just_created() {\n     t!(File::open(td.path().join(\"foo/bar\")));\n }\n \n+#[test]\n+#[cfg(not(windows))] // dangling symlinks have weird permissions\n+fn modify_outside_with_relative_symlink() {\n+    let mut ar = tar::Builder::new(Vec::new());\n+\n+    let mut header = tar::Header::new_gnu();\n+    header.set_size(0);\n+    header.set_entry_type(tar::EntryType::Symlink);\n+    t!(header.set_path(\"symlink\"));\n+    t!(header.set_link_name(\"..\"));\n+    header.set_cksum();\n+    t!(ar.append(&header, &[][..]));\n+\n+    let mut header = tar::Header::new_gnu();\n+    header.set_size(0);\n+    header.set_entry_type(tar::EntryType::Regular);\n+    t!(header.set_path(\"symlink/foo/bar\"));\n+    header.set_cksum();\n+    t!(ar.append(&header, &[][..]));\n+\n+    let bytes = t!(ar.into_inner());\n+    let mut ar = tar::Archive::new(&bytes[..]);\n+\n+    let td = t!(Builder::new().prefix(\"tar\").tempdir());\n+    let tar_dir = td.path().join(\"tar\");\n+    create_dir(&tar_dir).unwrap();\n+    assert!(ar.unpack(tar_dir).is_err());\n+    assert!(!td.path().join(\"foo\").exists());\n+}\n+\n #[test]\n fn parent_paths_error() {\n     let mut ar = tar::Builder::new(Vec::new());\n",
    "diff_parsed": "{'added': [(4, 'use std::fs::{create_dir, File};'), (222, '#[test]'), (223, '#[cfg(not(windows))] // dangling symlinks have weird permissions'), (224, 'fn modify_outside_with_relative_symlink() {'), (225, '    let mut ar = tar::Builder::new(Vec::new());'), (227, '    let mut header = tar::Header::new_gnu();'), (228, '    header.set_size(0);'), (229, '    header.set_entry_type(tar::EntryType::Symlink);'), (230, '    t!(header.set_path(\"symlink\"));'), (231, '    t!(header.set_link_name(\"..\"));'), (232, '    header.set_cksum();'), (233, '    t!(ar.append(&header, &[][..]));'), (235, '    let mut header = tar::Header::new_gnu();'), (236, '    header.set_size(0);'), (237, '    header.set_entry_type(tar::EntryType::Regular);'), (238, '    t!(header.set_path(\"symlink/foo/bar\"));'), (239, '    header.set_cksum();'), (240, '    t!(ar.append(&header, &[][..]));'), (242, '    let bytes = t!(ar.into_inner());'), (243, '    let mut ar = tar::Archive::new(&bytes[..]);'), (245, '    let td = t!(Builder::new().prefix(\"tar\").tempdir());'), (246, '    let tar_dir = td.path().join(\"tar\");'), (247, '    create_dir(&tar_dir).unwrap();'), (248, '    assert!(ar.unpack(tar_dir).is_err());'), (249, '    assert!(!td.path().join(\"foo\").exists());'), (250, '}')], 'deleted': [(4, 'use std::fs::File;')]}",
    "num_lines_added": "26",
    "num_lines_deleted": "1",
    "nloc": "306"
  },
  {
    "file_change_id": "114675587626525",
    "hash": "d90a02f582c03dfa0fd11c78d608d0974625ae5d",
    "old_path": "tests/header/mod.rs",
    "new_path": "tests/header/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -154,6 +154,10 @@ fn set_path() {\n     assert!(h.set_path(&medium2).is_err());\n     assert!(h.set_path(\"\\0\").is_err());\n \n+    assert!(h.set_path(\"..\").is_err());\n+    assert!(h.set_path(\"foo/..\").is_err());\n+    assert!(h.set_path(\"foo/../bar\").is_err());\n+\n     h = Header::new_ustar();\n     t!(h.set_path(\"foo\"));\n     assert_eq!(t!(h.path()).to_str(), Some(\"foo\"));\n",
    "diff_parsed": "{'added': [(157, '    assert!(h.set_path(\"..\").is_err());'), (158, '    assert!(h.set_path(\"foo/..\").is_err());'), (159, '    assert!(h.set_path(\"foo/../bar\").is_err());')], 'deleted': []}",
    "num_lines_added": "3",
    "num_lines_deleted": "0",
    "nloc": "202"
  },
  {
    "file_change_id": "159284428901916",
    "hash": "369e55736f9bd29c37b1712afc2923f4028148c6",
    "old_path": "src/vector.rs",
    "new_path": "src/vector.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -49,9 +49,10 @@ pub trait Vector {\n     }\n \n     fn insert(&mut self, index: usize, element: Self::Item) {\n+        let len = self.len();\n+        assert!(index <= len);\n         self.reserve(1);\n         unsafe {\n-            let len = self.len();\n             let ptr = self.as_mut_ptr().uoffset(index);\n             copy(ptr, ptr.uoffset(1), len - index);\n             write(ptr, element);\n",
    "diff_parsed": "{'added': [(52, '        let len = self.len();'), (53, '        assert!(index <= len);')], 'deleted': [(54, '            let len = self.len();')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "1",
    "nloc": "165"
  },
  {
    "file_change_id": "4740874669485",
    "hash": "b8f9011c04f104bb4a20f44e5bce31a1e9b46e64",
    "old_path": "core/lib/src/local/request.rs",
    "new_path": "core/lib/src/local/request.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -476,19 +476,35 @@ impl fmt::Debug for LocalResponse<'_> {\n \n impl<'c> Clone for LocalRequest<'c> {\n     fn clone(&self) -> LocalRequest<'c> {\n+        // Don't alias the existing `Request`. See #1312.\n+        let mut request = Rc::new(self.inner().clone());\n+        let ptr = Rc::get_mut(&mut request).unwrap() as *mut Request<'_>;\n+\n         LocalRequest {\n+            ptr, request,\n             client: self.client,\n-            ptr: self.ptr,\n-            request: self.request.clone(),\n             data: self.data.clone(),\n             uri: self.uri.clone()\n         }\n     }\n }\n \n-// #[cfg(test)]\n+#[cfg(test)]\n mod tests {\n-    // Someday...\n+    use crate::Request;\n+    use crate::local::Client;\n+\n+    #[test]\n+    fn clone_unique_ptr() {\n+        let client = Client::new(crate::ignite()).unwrap();\n+        let r1 = client.get(\"/\");\n+        let r2 = r1.clone();\n+\n+        assert_ne!(\n+            r1.inner() as *const Request<'_>,\n+            r2.inner() as *const Request<'_>\n+        );\n+    }\n \n     // #[test]\n     // #[compile_fail]\n",
    "diff_parsed": "{'added': [(480, '        let mut request = Rc::new(self.inner().clone());'), (481, \"        let ptr = Rc::get_mut(&mut request).unwrap() as *mut Request<'_>;\"), (484, '            ptr, request,'), (492, '#[cfg(test)]'), (494, '    use crate::Request;'), (495, '    use crate::local::Client;'), (497, '    #[test]'), (498, '    fn clone_unique_ptr() {'), (499, '        let client = Client::new(crate::ignite()).unwrap();'), (500, '        let r1 = client.get(\"/\");'), (501, '        let r2 = r1.clone();'), (503, '        assert_ne!('), (504, \"            r1.inner() as *const Request<'_>,\"), (505, \"            r2.inner() as *const Request<'_>\"), (506, '        );'), (507, '    }')], 'deleted': [(481, '            ptr: self.ptr,'), (482, '            request: self.request.clone(),')]}",
    "num_lines_added": "16",
    "num_lines_deleted": "2",
    "nloc": "346"
  },
  {
    "file_change_id": "69503567990117",
    "hash": "b8f9011c04f104bb4a20f44e5bce31a1e9b46e64",
    "old_path": "None",
    "new_path": "core/lib/tests/unsound-local-request-1312.rs",
    "change_type": "ModificationType.ADD",
    "diff": "@@ -0,0 +1,33 @@\n+use rocket::http::Header;\n+use rocket::local::Client;\n+\n+#[test]\n+fn test_local_request_clone_soundness() {\n+    let client = Client::new(rocket::ignite()).unwrap();\n+\n+    // creates two LocalRequest instances that shouldn't share the same req\n+    let r1 = client.get(\"/\").header(Header::new(\"key\", \"val1\"));\n+    let mut r2 = r1.clone();\n+\n+    // save the iterator, which internally holds a slice\n+    let mut iter = r1.inner().headers().get(\"key\");\n+\n+    // insert headers to force header map reallocation.\n+    for i in 0..100 {\n+        r2.add_header(Header::new(i.to_string(), i.to_string()));\n+    }\n+\n+    // Replace the original key/val.\n+    r2.add_header(Header::new(\"key\", \"val2\"));\n+\n+    // Heap massage: so we've got crud to print.\n+    let _: Vec<usize> = vec![0, 0xcafebabe, 31337, 0];\n+\n+    // Ensure we're good.\n+    let s = iter.next().unwrap();\n+    println!(\"{}\", s);\n+\n+    // And that we've got the right data.\n+    assert_eq!(r1.inner().headers().get(\"key\").collect::<Vec<_>>(), vec![\"val1\"]);\n+    assert_eq!(r2.inner().headers().get(\"key\").collect::<Vec<_>>(), vec![\"val1\", \"val2\"]);\n+}\n",
    "diff_parsed": "{'added': [(1, 'use rocket::http::Header;'), (2, 'use rocket::local::Client;'), (4, '#[test]'), (5, 'fn test_local_request_clone_soundness() {'), (6, '    let client = Client::new(rocket::ignite()).unwrap();'), (9, '    let r1 = client.get(\"/\").header(Header::new(\"key\", \"val1\"));'), (10, '    let mut r2 = r1.clone();'), (13, '    let mut iter = r1.inner().headers().get(\"key\");'), (16, '    for i in 0..100 {'), (17, '        r2.add_header(Header::new(i.to_string(), i.to_string()));'), (18, '    }'), (21, '    r2.add_header(Header::new(\"key\", \"val2\"));'), (24, '    let _: Vec<usize> = vec![0, 0xcafebabe, 31337, 0];'), (27, '    let s = iter.next().unwrap();'), (28, '    println!(\"{}\", s);'), (31, '    assert_eq!(r1.inner().headers().get(\"key\").collect::<Vec<_>>(), vec![\"val1\"]);'), (32, '    assert_eq!(r2.inner().headers().get(\"key\").collect::<Vec<_>>(), vec![\"val1\", \"val2\"]);'), (33, '}')], 'deleted': []}",
    "num_lines_added": "18",
    "num_lines_deleted": "0",
    "nloc": "18"
  },
  {
    "file_change_id": "260145205025062",
    "hash": "268301a714934dd067ba33f59f22c5f003aa20f3",
    "old_path": "src/cell.rs",
    "new_path": "src/cell.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -62,7 +62,7 @@ pub struct OnceCell<T, B> {\n /********** impl Send + Sync **********************************************************************/\n \n unsafe impl<T, B> Send for OnceCell<T, B> where T: Send {}\n-unsafe impl<T, B> Sync for OnceCell<T, B> where T: Sync {}\n+unsafe impl<T, B> Sync for OnceCell<T, B> where T: Send + Sync {}\n \n /********** impl inherent *************************************************************************/\n \n",
    "diff_parsed": "{'added': [(65, 'unsafe impl<T, B> Sync for OnceCell<T, B> where T: Send + Sync {}')], 'deleted': [(65, 'unsafe impl<T, B> Sync for OnceCell<T, B> where T: Sync {}')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "252"
  },
  {
    "file_change_id": "268824252114314",
    "hash": "e325e2fce4d9f9f392761e9fb58b418a48cef8bb",
    "old_path": "core/http/src/uri/formatter.rs",
    "new_path": "core/http/src/uri/formatter.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -334,26 +334,42 @@ impl Formatter<'_, Query> {\n     fn with_prefix<F>(&mut self, prefix: &str, f: F) -> fmt::Result\n         where F: FnOnce(&mut Self) -> fmt::Result\n     {\n-        // The `prefix` string is pushed in a `StackVec` for use by recursive\n-        // (nested) calls to `write_raw`. The string is pushed here and then\n-        // popped here. `self.prefixes` is modified nowhere else, and no strings\n-        // leak from the the vector. As a result, it is impossible for a\n-        // `prefix` to be accessed incorrectly as:\n-        //\n-        //   * Rust _guarantees_ it exists for the lifetime of this method\n-        //   * it is only reachable while this method's stack is active because\n-        //     it is popped before this method returns\n-        //   * thus, at any point that it's reachable, it's valid\n-        //\n-        // Said succinctly: this `prefixes` stack shadows a subset of the\n-        // `with_prefix` stack precisely, making it reachable to other code.\n-        let prefix: &'static str = unsafe { std::mem::transmute(prefix) };\n-\n-        self.prefixes.push(prefix);\n-        let result = f(self);\n-        self.prefixes.pop();\n \n-        result\n+        struct PrefixGuard<'f, 'i>(&'f mut Formatter<'i, Query>);\n+\n+        impl<'f, 'i> PrefixGuard<'f, 'i> {\n+            fn new(prefix: &str, f: &'f mut Formatter<'i, Query>) -> Self {\n+                // SAFETY: The `prefix` string is pushed in a `StackVec` for use\n+                // by recursive (nested) calls to `write_raw`. The string is\n+                // pushed in `PrefixGuard` here and then popped in `Drop`.\n+                // `prefixes` is modified nowhere else, and no concrete-lifetime\n+                // strings leak from the the vector. As a result, it is\n+                // impossible for a `prefix` to be accessed incorrectly as:\n+                //\n+                //   * Rust _guarantees_ `prefix` is valid for this method\n+                //   * `prefix` is only reachable while this method's stack is\n+                //     active because it is unconditionally popped before this\n+                //     method returns via `PrefixGuard::drop()`.\n+                //   * should a panic occur in `f()`, `PrefixGuard::drop()` is\n+                //     still called (or the program aborts), ensuring `prefix`\n+                //     is no longer in `prefixes` and thus inaccessible.\n+                //   * thus, at any point `prefix` is reachable, it is valid\n+                //\n+                // Said succinctly: `prefixes` shadows a subset of the\n+                // `with_prefix` stack, making it reachable to other code.\n+                let prefix = unsafe { std::mem::transmute(prefix) };\n+                f.prefixes.push(prefix);\n+                PrefixGuard(f)\n+            }\n+        }\n+\n+        impl Drop for PrefixGuard<'_, '_> {\n+            fn drop(&mut self) {\n+                self.0.prefixes.pop();\n+            }\n+        }\n+\n+        f(&mut PrefixGuard::new(prefix, self).0)\n     }\n \n     /// Writes the named value `value` by prefixing `name` followed by `=` to\n@@ -468,3 +484,54 @@ impl UriArguments<'_> {\n         Origin::new(path, query)\n     }\n }\n+\n+// See https://github.com/SergioBenitez/Rocket/issues/1534.\n+#[cfg(test)]\n+mod prefix_soundness_test {\n+    use crate::uri::{Formatter, Query, UriDisplay};\n+\n+    struct MyValue;\n+\n+    impl UriDisplay<Query> for MyValue {\n+        fn fmt(&self, _f: &mut Formatter<'_, Query>) -> std::fmt::Result {\n+            panic!()\n+        }\n+    }\n+\n+    struct MyDisplay;\n+\n+    impl UriDisplay<Query> for MyDisplay {\n+        fn fmt(&self, formatter: &mut Formatter<'_, Query>) -> std::fmt::Result {\n+            struct Wrapper<'a, 'b>(&'a mut Formatter<'b, Query>);\n+\n+            impl<'a, 'b> Drop for Wrapper<'a, 'b> {\n+                fn drop(&mut self) {\n+                    let _overlap = String::from(\"12345\");\n+                    self.0.write_raw(\"world\").ok();\n+                    assert!(self.0.prefixes.is_empty());\n+                }\n+            }\n+\n+            let wrapper = Wrapper(formatter);\n+            let temporary_string = String::from(\"hello\");\n+\n+            // `write_named_value` will push `temp_string` into a buffer and\n+            // call the formatter for `MyValue`, which panics. At the panic\n+            // point, `formatter` contains an (illegal) static reference to\n+            // `temp_string` in its `prefixes` stack. When unwinding occurs,\n+            // `Wrapper` will be dropped. `Wrapper` holds a reference to\n+            // `Formatter`, thus `Formatter` must be consistent at this point.\n+            let _ = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {\n+                wrapper.0.write_named_value(&temporary_string, MyValue)\n+            }));\n+\n+            Ok(())\n+        }\n+    }\n+\n+    #[test]\n+    fn check_consistency() {\n+        let string = format!(\"{}\", &MyDisplay as &dyn UriDisplay<Query>);\n+        assert_eq!(string, \"world\");\n+    }\n+}\n",
    "diff_parsed": "{'added': [(338, \"        struct PrefixGuard<'f, 'i>(&'f mut Formatter<'i, Query>);\"), (340, \"        impl<'f, 'i> PrefixGuard<'f, 'i> {\"), (341, \"            fn new(prefix: &str, f: &'f mut Formatter<'i, Query>) -> Self {\"), (360, '                let prefix = unsafe { std::mem::transmute(prefix) };'), (361, '                f.prefixes.push(prefix);'), (362, '                PrefixGuard(f)'), (363, '            }'), (364, '        }'), (366, \"        impl Drop for PrefixGuard<'_, '_> {\"), (367, '            fn drop(&mut self) {'), (368, '                self.0.prefixes.pop();'), (369, '            }'), (370, '        }'), (372, '        f(&mut PrefixGuard::new(prefix, self).0)'), (489, '#[cfg(test)]'), (490, 'mod prefix_soundness_test {'), (491, '    use crate::uri::{Formatter, Query, UriDisplay};'), (493, '    struct MyValue;'), (495, '    impl UriDisplay<Query> for MyValue {'), (496, \"        fn fmt(&self, _f: &mut Formatter<'_, Query>) -> std::fmt::Result {\"), (497, '            panic!()'), (498, '        }'), (499, '    }'), (501, '    struct MyDisplay;'), (503, '    impl UriDisplay<Query> for MyDisplay {'), (504, \"        fn fmt(&self, formatter: &mut Formatter<'_, Query>) -> std::fmt::Result {\"), (505, \"            struct Wrapper<'a, 'b>(&'a mut Formatter<'b, Query>);\"), (507, \"            impl<'a, 'b> Drop for Wrapper<'a, 'b> {\"), (508, '                fn drop(&mut self) {'), (509, '                    let _overlap = String::from(\"12345\");'), (510, '                    self.0.write_raw(\"world\").ok();'), (511, '                    assert!(self.0.prefixes.is_empty());'), (512, '                }'), (513, '            }'), (515, '            let wrapper = Wrapper(formatter);'), (516, '            let temporary_string = String::from(\"hello\");'), (524, '            let _ = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {'), (525, '                wrapper.0.write_named_value(&temporary_string, MyValue)'), (526, '            }));'), (528, '            Ok(())'), (529, '        }'), (530, '    }'), (532, '    #[test]'), (533, '    fn check_consistency() {'), (534, '        let string = format!(\"{}\", &MyDisplay as &dyn UriDisplay<Query>);'), (535, '        assert_eq!(string, \"world\");'), (536, '    }'), (537, '}')], 'deleted': [(350, \"        let prefix: &'static str = unsafe { std::mem::transmute(prefix) };\"), (352, '        self.prefixes.push(prefix);'), (353, '        let result = f(self);'), (354, '        self.prefixes.pop();'), (356, '        result')]}",
    "num_lines_added": "48",
    "num_lines_deleted": "5",
    "nloc": "201"
  },
  {
    "file_change_id": "78804897149895",
    "hash": "8783a08e71694b7a5eb4fbc7cd95379b6de0d290",
    "old_path": "src/sync/mutex.rs",
    "new_path": "src/sync/mutex.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -310,6 +310,13 @@ impl<MutexType: RawMutex, T> DerefMut for GenericMutexGuard<'_, MutexType, T> {\n     }\n }\n \n+// Safety: GenericMutexGuard may only be used across threads if the underlying\n+// type is Sync.\n+unsafe impl<MutexType: RawMutex, T: Sync> Sync\n+    for GenericMutexGuard<'_, MutexType, T>\n+{\n+}\n+\n /// A future which resolves when the target mutex has been successfully acquired.\n #[must_use = \"futures do nothing unless polled\"]\n pub struct GenericMutexLockFuture<'a, MutexType: RawMutex, T: 'a> {\n",
    "diff_parsed": "{'added': [(315, 'unsafe impl<MutexType: RawMutex, T: Sync> Sync'), (316, \"    for GenericMutexGuard<'_, MutexType, T>\"), (317, '{'), (318, '}')], 'deleted': []}",
    "num_lines_added": "4",
    "num_lines_deleted": "0",
    "nloc": "353"
  },
  {
    "file_change_id": "232577052992178",
    "hash": "59f2a7311dd6540696bfd0145f5281ce495f4385",
    "old_path": "prost-types/src/lib.rs",
    "new_path": "prost-types/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -26,6 +26,7 @@ pub mod compiler {\n // are defined in both directions.\n \n const NANOS_PER_SECOND: i32 = 1_000_000_000;\n+const NANOS_MAX: i32 = NANOS_PER_SECOND - 1;\n \n impl Duration {\n     /// Normalizes the duration to a canonical format.\n@@ -35,17 +36,42 @@ impl Duration {\n     pub fn normalize(&mut self) {\n         // Make sure nanos is in the range.\n         if self.nanos <= -NANOS_PER_SECOND || self.nanos >= NANOS_PER_SECOND {\n-            self.seconds += (self.nanos / NANOS_PER_SECOND) as i64;\n-            self.nanos %= NANOS_PER_SECOND;\n+            if let Some(seconds) = self\n+                .seconds\n+                .checked_add((self.nanos / NANOS_PER_SECOND) as i64)\n+            {\n+                self.seconds = seconds;\n+                self.nanos %= NANOS_PER_SECOND;\n+            } else if self.nanos < 0 {\n+                // Negative overflow! Set to the least normal value.\n+                self.seconds = i64::MIN;\n+                self.nanos = -NANOS_MAX;\n+            } else {\n+                // Positive overflow! Set to the greatest normal value.\n+                self.seconds = i64::MAX;\n+                self.nanos = NANOS_MAX;\n+            }\n         }\n \n         // nanos should have the same sign as seconds.\n         if self.seconds < 0 && self.nanos > 0 {\n-            self.seconds += 1;\n-            self.nanos -= NANOS_PER_SECOND;\n+            if let Some(seconds) = self.seconds.checked_add(1) {\n+                self.seconds = seconds;\n+                self.nanos -= NANOS_PER_SECOND;\n+            } else {\n+                // Positive overflow! Set to the greatest normal value.\n+                debug_assert_eq!(self.seconds, i64::MAX);\n+                self.nanos = NANOS_MAX;\n+            }\n         } else if self.seconds > 0 && self.nanos < 0 {\n-            self.seconds -= 1;\n-            self.nanos += NANOS_PER_SECOND;\n+            if let Some(seconds) = self.seconds.checked_sub(1) {\n+                self.seconds = seconds;\n+                self.nanos += NANOS_PER_SECOND;\n+            } else {\n+                // Negative overflow! Set to the least normal value.\n+                debug_assert_eq!(self.seconds, i64::MIN);\n+                self.nanos = -NANOS_MAX;\n+            }\n         }\n         // TODO: should this be checked?\n         // debug_assert!(self.seconds >= -315_576_000_000 && self.seconds <= 315_576_000_000,\n@@ -104,14 +130,33 @@ impl Timestamp {\n     pub fn normalize(&mut self) {\n         // Make sure nanos is in the range.\n         if self.nanos <= -NANOS_PER_SECOND || self.nanos >= NANOS_PER_SECOND {\n-            self.seconds += (self.nanos / NANOS_PER_SECOND) as i64;\n-            self.nanos %= NANOS_PER_SECOND;\n+            if let Some(seconds) = self\n+                .seconds\n+                .checked_add((self.nanos / NANOS_PER_SECOND) as i64)\n+            {\n+                self.seconds = seconds;\n+                self.nanos %= NANOS_PER_SECOND;\n+            } else if self.nanos < 0 {\n+                // Negative overflow! Set to the earliest normal value.\n+                self.seconds = i64::MIN;\n+                self.nanos = 0;\n+            } else {\n+                // Positive overflow! Set to the latest normal value.\n+                self.seconds = i64::MAX;\n+                self.nanos = 999_999_999;\n+            }\n         }\n \n         // For Timestamp nanos should be in the range [0, 999999999].\n         if self.nanos < 0 {\n-            self.seconds -= 1;\n-            self.nanos += NANOS_PER_SECOND;\n+            if let Some(seconds) = self.seconds.checked_sub(1) {\n+                self.seconds = seconds;\n+                self.nanos += NANOS_PER_SECOND;\n+            } else {\n+                // Negative overflow! Set to the earliest normal value.\n+                debug_assert_eq!(self.seconds, i64::MIN);\n+                self.nanos = 0;\n+            }\n         }\n \n         // TODO: should this be checked?\n@@ -143,17 +188,56 @@ impl From<std::time::SystemTime> for Timestamp {\n     }\n }\n \n+/// Indicates that a [`Timestamp`] could not be converted to\n+/// [`SystemTime`][std::time::SystemTime] because it is out of range.\n+///\n+/// The range of times that can be represented by `SystemTime` depends on the platform.\n+/// All `Timestamp`s are likely representable on 64-bit Unix-like platforms, but\n+/// other platforms, such as Windows and 32-bit Linux, may not be able to represent\n+/// the full range of `Timestamp`s.\n+#[cfg(feature = \"std\")]\n+#[derive(Debug)]\n+#[non_exhaustive]\n+pub struct TimestampOutOfSystemRangeError {\n+    pub timestamp: Timestamp,\n+}\n+\n+#[cfg(feature = \"std\")]\n+impl core::fmt::Display for TimestampOutOfSystemRangeError {\n+    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n+        write!(\n+            f,\n+            \"{:?} is not representable as a `SystemTime` because it is out of range\",\n+            self\n+        )\n+    }\n+}\n+\n+#[cfg(feature = \"std\")]\n+impl std::error::Error for TimestampOutOfSystemRangeError {}\n+\n #[cfg(feature = \"std\")]\n-impl From<Timestamp> for std::time::SystemTime {\n-    fn from(mut timestamp: Timestamp) -> std::time::SystemTime {\n+impl TryFrom<Timestamp> for std::time::SystemTime {\n+    type Error = TimestampOutOfSystemRangeError;\n+\n+    fn try_from(mut timestamp: Timestamp) -> Result<std::time::SystemTime, Self::Error> {\n+        let orig_timestamp = timestamp.clone();\n         timestamp.normalize();\n+\n         let system_time = if timestamp.seconds >= 0 {\n-            std::time::UNIX_EPOCH + time::Duration::from_secs(timestamp.seconds as u64)\n+            std::time::UNIX_EPOCH.checked_add(time::Duration::from_secs(timestamp.seconds as u64))\n         } else {\n-            std::time::UNIX_EPOCH - time::Duration::from_secs((-timestamp.seconds) as u64)\n+            std::time::UNIX_EPOCH\n+                .checked_sub(time::Duration::from_secs((-timestamp.seconds) as u64))\n         };\n \n-        system_time + time::Duration::from_nanos(timestamp.nanos as u64)\n+        let system_time = system_time.and_then(|system_time| {\n+            system_time.checked_add(time::Duration::from_nanos(timestamp.nanos as u64))\n+        });\n+\n+        system_time.ok_or(TimestampOutOfSystemRangeError {\n+            timestamp: orig_timestamp,\n+        })\n     }\n }\n \n@@ -171,7 +255,19 @@ mod tests {\n         fn check_system_time_roundtrip(\n             system_time in SystemTime::arbitrary(),\n         ) {\n-            prop_assert_eq!(SystemTime::from(Timestamp::from(system_time)), system_time);\n+            prop_assert_eq!(SystemTime::try_from(Timestamp::from(system_time)).unwrap(), system_time);\n+        }\n+\n+        #[test]\n+        fn check_timestamp_roundtrip_via_system_time(\n+            seconds in i64::arbitrary(),\n+            nanos in i32::arbitrary(),\n+        ) {\n+            let mut timestamp = Timestamp { seconds, nanos };\n+            timestamp.normalize();\n+            if let Ok(system_time) = SystemTime::try_from(timestamp.clone()) {\n+                prop_assert_eq!(Timestamp::from(system_time), timestamp);\n+            }\n         }\n     }\n \n@@ -243,4 +339,156 @@ mod tests {\n             }\n         );\n     }\n+\n+    #[test]\n+    fn check_duration_normalize() {\n+        #[rustfmt::skip] // Don't mangle the table formatting.\n+        let cases = [\n+            // --- Table of test cases ---\n+            //        test seconds      test nanos  expected seconds  expected nanos\n+            (line!(),            0,              0,                0,              0),\n+            (line!(),            1,              1,                1,              1),\n+            (line!(),           -1,             -1,               -1,             -1),\n+            (line!(),            0,    999_999_999,                0,    999_999_999),\n+            (line!(),            0,   -999_999_999,                0,   -999_999_999),\n+            (line!(),            0,  1_000_000_000,                1,              0),\n+            (line!(),            0, -1_000_000_000,               -1,              0),\n+            (line!(),            0,  1_000_000_001,                1,              1),\n+            (line!(),            0, -1_000_000_001,               -1,             -1),\n+            (line!(),           -1,              1,                0,   -999_999_999),\n+            (line!(),            1,             -1,                0,    999_999_999),\n+            (line!(),           -1,  1_000_000_000,                0,              0),\n+            (line!(),            1, -1_000_000_000,                0,              0),\n+            (line!(), i64::MIN    ,              0,     i64::MIN    ,              0),\n+            (line!(), i64::MIN + 1,              0,     i64::MIN + 1,              0),\n+            (line!(), i64::MIN    ,              1,     i64::MIN + 1,   -999_999_999),\n+            (line!(), i64::MIN    ,  1_000_000_000,     i64::MIN + 1,              0),\n+            (line!(), i64::MIN    , -1_000_000_000,     i64::MIN    ,   -999_999_999),\n+            (line!(), i64::MIN + 1, -1_000_000_000,     i64::MIN    ,              0),\n+            (line!(), i64::MIN + 2, -1_000_000_000,     i64::MIN + 1,              0),\n+            (line!(), i64::MIN    , -1_999_999_998,     i64::MIN    ,   -999_999_999),\n+            (line!(), i64::MIN + 1, -1_999_999_998,     i64::MIN    ,   -999_999_998),\n+            (line!(), i64::MIN + 2, -1_999_999_998,     i64::MIN + 1,   -999_999_998),\n+            (line!(), i64::MIN    , -1_999_999_999,     i64::MIN    ,   -999_999_999),\n+            (line!(), i64::MIN + 1, -1_999_999_999,     i64::MIN    ,   -999_999_999),\n+            (line!(), i64::MIN + 2, -1_999_999_999,     i64::MIN + 1,   -999_999_999),\n+            (line!(), i64::MIN    , -2_000_000_000,     i64::MIN    ,   -999_999_999),\n+            (line!(), i64::MIN + 1, -2_000_000_000,     i64::MIN    ,   -999_999_999),\n+            (line!(), i64::MIN + 2, -2_000_000_000,     i64::MIN    ,              0),\n+            (line!(), i64::MIN    ,   -999_999_998,     i64::MIN    ,   -999_999_998),\n+            (line!(), i64::MIN + 1,   -999_999_998,     i64::MIN + 1,   -999_999_998),\n+            (line!(), i64::MAX    ,              0,     i64::MAX    ,              0),\n+            (line!(), i64::MAX - 1,              0,     i64::MAX - 1,              0),\n+            (line!(), i64::MAX    ,             -1,     i64::MAX - 1,    999_999_999),\n+            (line!(), i64::MAX    ,  1_000_000_000,     i64::MAX    ,    999_999_999),\n+            (line!(), i64::MAX - 1,  1_000_000_000,     i64::MAX    ,              0),\n+            (line!(), i64::MAX - 2,  1_000_000_000,     i64::MAX - 1,              0),\n+            (line!(), i64::MAX    ,  1_999_999_998,     i64::MAX    ,    999_999_999),\n+            (line!(), i64::MAX - 1,  1_999_999_998,     i64::MAX    ,    999_999_998),\n+            (line!(), i64::MAX - 2,  1_999_999_998,     i64::MAX - 1,    999_999_998),\n+            (line!(), i64::MAX    ,  1_999_999_999,     i64::MAX    ,    999_999_999),\n+            (line!(), i64::MAX - 1,  1_999_999_999,     i64::MAX    ,    999_999_999),\n+            (line!(), i64::MAX - 2,  1_999_999_999,     i64::MAX - 1,    999_999_999),\n+            (line!(), i64::MAX    ,  2_000_000_000,     i64::MAX    ,    999_999_999),\n+            (line!(), i64::MAX - 1,  2_000_000_000,     i64::MAX    ,    999_999_999),\n+            (line!(), i64::MAX - 2,  2_000_000_000,     i64::MAX    ,              0),\n+            (line!(), i64::MAX    ,    999_999_998,     i64::MAX    ,    999_999_998),\n+            (line!(), i64::MAX - 1,    999_999_998,     i64::MAX - 1,    999_999_998),\n+        ];\n+\n+        for case in cases.iter() {\n+            let mut test_duration = crate::Duration {\n+                seconds: case.1,\n+                nanos: case.2,\n+            };\n+            test_duration.normalize();\n+\n+            assert_eq!(\n+                test_duration,\n+                crate::Duration {\n+                    seconds: case.3,\n+                    nanos: case.4,\n+                },\n+                \"test case on line {} doesn't match\",\n+                case.0,\n+            );\n+        }\n+    }\n+\n+    #[cfg(feature = \"std\")]\n+    #[test]\n+    fn check_timestamp_normalize() {\n+        // Make sure that `Timestamp::normalize` behaves correctly on and near overflow.\n+        #[rustfmt::skip] // Don't mangle the table formatting.\n+        let cases = [\n+            // --- Table of test cases ---\n+            //        test seconds      test nanos  expected seconds  expected nanos\n+            (line!(),            0,              0,                0,              0),\n+            (line!(),            1,              1,                1,              1),\n+            (line!(),           -1,             -1,               -2,    999_999_999),\n+            (line!(),            0,    999_999_999,                0,    999_999_999),\n+            (line!(),            0,   -999_999_999,               -1,              1),\n+            (line!(),            0,  1_000_000_000,                1,              0),\n+            (line!(),            0, -1_000_000_000,               -1,              0),\n+            (line!(),            0,  1_000_000_001,                1,              1),\n+            (line!(),            0, -1_000_000_001,               -2,    999_999_999),\n+            (line!(),           -1,              1,               -1,              1),\n+            (line!(),            1,             -1,                0,    999_999_999),\n+            (line!(),           -1,  1_000_000_000,                0,              0),\n+            (line!(),            1, -1_000_000_000,                0,              0),\n+            (line!(), i64::MIN    ,              0,     i64::MIN    ,              0),\n+            (line!(), i64::MIN + 1,              0,     i64::MIN + 1,              0),\n+            (line!(), i64::MIN    ,              1,     i64::MIN    ,              1),\n+            (line!(), i64::MIN    ,  1_000_000_000,     i64::MIN + 1,              0),\n+            (line!(), i64::MIN    , -1_000_000_000,     i64::MIN    ,              0),\n+            (line!(), i64::MIN + 1, -1_000_000_000,     i64::MIN    ,              0),\n+            (line!(), i64::MIN + 2, -1_000_000_000,     i64::MIN + 1,              0),\n+            (line!(), i64::MIN    , -1_999_999_998,     i64::MIN    ,              0),\n+            (line!(), i64::MIN + 1, -1_999_999_998,     i64::MIN    ,              0),\n+            (line!(), i64::MIN + 2, -1_999_999_998,     i64::MIN    ,              2),\n+            (line!(), i64::MIN    , -1_999_999_999,     i64::MIN    ,              0),\n+            (line!(), i64::MIN + 1, -1_999_999_999,     i64::MIN    ,              0),\n+            (line!(), i64::MIN + 2, -1_999_999_999,     i64::MIN    ,              1),\n+            (line!(), i64::MIN    , -2_000_000_000,     i64::MIN    ,              0),\n+            (line!(), i64::MIN + 1, -2_000_000_000,     i64::MIN    ,              0),\n+            (line!(), i64::MIN + 2, -2_000_000_000,     i64::MIN    ,              0),\n+            (line!(), i64::MIN    ,   -999_999_998,     i64::MIN    ,              0),\n+            (line!(), i64::MIN + 1,   -999_999_998,     i64::MIN    ,              2),\n+            (line!(), i64::MAX    ,              0,     i64::MAX    ,              0),\n+            (line!(), i64::MAX - 1,              0,     i64::MAX - 1,              0),\n+            (line!(), i64::MAX    ,             -1,     i64::MAX - 1,    999_999_999),\n+            (line!(), i64::MAX    ,  1_000_000_000,     i64::MAX    ,    999_999_999),\n+            (line!(), i64::MAX - 1,  1_000_000_000,     i64::MAX    ,              0),\n+            (line!(), i64::MAX - 2,  1_000_000_000,     i64::MAX - 1,              0),\n+            (line!(), i64::MAX    ,  1_999_999_998,     i64::MAX    ,    999_999_999),\n+            (line!(), i64::MAX - 1,  1_999_999_998,     i64::MAX    ,    999_999_998),\n+            (line!(), i64::MAX - 2,  1_999_999_998,     i64::MAX - 1,    999_999_998),\n+            (line!(), i64::MAX    ,  1_999_999_999,     i64::MAX    ,    999_999_999),\n+            (line!(), i64::MAX - 1,  1_999_999_999,     i64::MAX    ,    999_999_999),\n+            (line!(), i64::MAX - 2,  1_999_999_999,     i64::MAX - 1,    999_999_999),\n+            (line!(), i64::MAX    ,  2_000_000_000,     i64::MAX    ,    999_999_999),\n+            (line!(), i64::MAX - 1,  2_000_000_000,     i64::MAX    ,    999_999_999),\n+            (line!(), i64::MAX - 2,  2_000_000_000,     i64::MAX    ,              0),\n+            (line!(), i64::MAX    ,    999_999_998,     i64::MAX    ,    999_999_998),\n+            (line!(), i64::MAX - 1,    999_999_998,     i64::MAX - 1,    999_999_998),\n+        ];\n+\n+        for case in cases.iter() {\n+            let mut test_timestamp = crate::Timestamp {\n+                seconds: case.1,\n+                nanos: case.2,\n+            };\n+            test_timestamp.normalize();\n+\n+            assert_eq!(\n+                test_timestamp,\n+                crate::Timestamp {\n+                    seconds: case.3,\n+                    nanos: case.4,\n+                },\n+                \"test case on line {} doesn't match\",\n+                case.0,\n+            );\n+        }\n+    }\n }\n",
    "diff_parsed": "{'added': [(29, 'const NANOS_MAX: i32 = NANOS_PER_SECOND - 1;'), (39, '            if let Some(seconds) = self'), (40, '                .seconds'), (41, '                .checked_add((self.nanos / NANOS_PER_SECOND) as i64)'), (42, '            {'), (43, '                self.seconds = seconds;'), (44, '                self.nanos %= NANOS_PER_SECOND;'), (45, '            } else if self.nanos < 0 {'), (47, '                self.seconds = i64::MIN;'), (48, '                self.nanos = -NANOS_MAX;'), (49, '            } else {'), (51, '                self.seconds = i64::MAX;'), (52, '                self.nanos = NANOS_MAX;'), (53, '            }'), (58, '            if let Some(seconds) = self.seconds.checked_add(1) {'), (59, '                self.seconds = seconds;'), (60, '                self.nanos -= NANOS_PER_SECOND;'), (61, '            } else {'), (63, '                debug_assert_eq!(self.seconds, i64::MAX);'), (64, '                self.nanos = NANOS_MAX;'), (65, '            }'), (67, '            if let Some(seconds) = self.seconds.checked_sub(1) {'), (68, '                self.seconds = seconds;'), (69, '                self.nanos += NANOS_PER_SECOND;'), (70, '            } else {'), (72, '                debug_assert_eq!(self.seconds, i64::MIN);'), (73, '                self.nanos = -NANOS_MAX;'), (74, '            }'), (133, '            if let Some(seconds) = self'), (134, '                .seconds'), (135, '                .checked_add((self.nanos / NANOS_PER_SECOND) as i64)'), (136, '            {'), (137, '                self.seconds = seconds;'), (138, '                self.nanos %= NANOS_PER_SECOND;'), (139, '            } else if self.nanos < 0 {'), (141, '                self.seconds = i64::MIN;'), (142, '                self.nanos = 0;'), (143, '            } else {'), (145, '                self.seconds = i64::MAX;'), (146, '                self.nanos = 999_999_999;'), (147, '            }'), (152, '            if let Some(seconds) = self.seconds.checked_sub(1) {'), (153, '                self.seconds = seconds;'), (154, '                self.nanos += NANOS_PER_SECOND;'), (155, '            } else {'), (157, '                debug_assert_eq!(self.seconds, i64::MIN);'), (158, '                self.nanos = 0;'), (159, '            }'), (198, '#[cfg(feature = \"std\")]'), (199, '#[derive(Debug)]'), (200, '#[non_exhaustive]'), (201, 'pub struct TimestampOutOfSystemRangeError {'), (202, '    pub timestamp: Timestamp,'), (203, '}'), (205, '#[cfg(feature = \"std\")]'), (206, 'impl core::fmt::Display for TimestampOutOfSystemRangeError {'), (207, \"    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\"), (208, '        write!('), (209, '            f,'), (210, '            \"{:?} is not representable as a `SystemTime` because it is out of range\",'), (211, '            self'), (212, '        )'), (213, '    }'), (214, '}'), (216, '#[cfg(feature = \"std\")]'), (217, 'impl std::error::Error for TimestampOutOfSystemRangeError {}'), (220, 'impl TryFrom<Timestamp> for std::time::SystemTime {'), (221, '    type Error = TimestampOutOfSystemRangeError;'), (223, '    fn try_from(mut timestamp: Timestamp) -> Result<std::time::SystemTime, Self::Error> {'), (224, '        let orig_timestamp = timestamp.clone();'), (228, '            std::time::UNIX_EPOCH.checked_add(time::Duration::from_secs(timestamp.seconds as u64))'), (230, '            std::time::UNIX_EPOCH'), (231, '                .checked_sub(time::Duration::from_secs((-timestamp.seconds) as u64))'), (234, '        let system_time = system_time.and_then(|system_time| {'), (235, '            system_time.checked_add(time::Duration::from_nanos(timestamp.nanos as u64))'), (236, '        });'), (238, '        system_time.ok_or(TimestampOutOfSystemRangeError {'), (239, '            timestamp: orig_timestamp,'), (240, '        })'), (258, '            prop_assert_eq!(SystemTime::try_from(Timestamp::from(system_time)).unwrap(), system_time);'), (259, '        }'), (261, '        #[test]'), (262, '        fn check_timestamp_roundtrip_via_system_time('), (263, '            seconds in i64::arbitrary(),'), (264, '            nanos in i32::arbitrary(),'), (265, '        ) {'), (266, '            let mut timestamp = Timestamp { seconds, nanos };'), (267, '            timestamp.normalize();'), (268, '            if let Ok(system_time) = SystemTime::try_from(timestamp.clone()) {'), (269, '                prop_assert_eq!(Timestamp::from(system_time), timestamp);'), (270, '            }'), (343, '    #[test]'), (344, '    fn check_duration_normalize() {'), (345, \"        #[rustfmt::skip] // Don't mangle the table formatting.\"), (346, '        let cases = ['), (349, '            (line!(),            0,              0,                0,              0),'), (350, '            (line!(),            1,              1,                1,              1),'), (351, '            (line!(),           -1,             -1,               -1,             -1),'), (352, '            (line!(),            0,    999_999_999,                0,    999_999_999),'), (353, '            (line!(),            0,   -999_999_999,                0,   -999_999_999),'), (354, '            (line!(),            0,  1_000_000_000,                1,              0),'), (355, '            (line!(),            0, -1_000_000_000,               -1,              0),'), (356, '            (line!(),            0,  1_000_000_001,                1,              1),'), (357, '            (line!(),            0, -1_000_000_001,               -1,             -1),'), (358, '            (line!(),           -1,              1,                0,   -999_999_999),'), (359, '            (line!(),            1,             -1,                0,    999_999_999),'), (360, '            (line!(),           -1,  1_000_000_000,                0,              0),'), (361, '            (line!(),            1, -1_000_000_000,                0,              0),'), (362, '            (line!(), i64::MIN    ,              0,     i64::MIN    ,              0),'), (363, '            (line!(), i64::MIN + 1,              0,     i64::MIN + 1,              0),'), (364, '            (line!(), i64::MIN    ,              1,     i64::MIN + 1,   -999_999_999),'), (365, '            (line!(), i64::MIN    ,  1_000_000_000,     i64::MIN + 1,              0),'), (366, '            (line!(), i64::MIN    , -1_000_000_000,     i64::MIN    ,   -999_999_999),'), (367, '            (line!(), i64::MIN + 1, -1_000_000_000,     i64::MIN    ,              0),'), (368, '            (line!(), i64::MIN + 2, -1_000_000_000,     i64::MIN + 1,              0),'), (369, '            (line!(), i64::MIN    , -1_999_999_998,     i64::MIN    ,   -999_999_999),'), (370, '            (line!(), i64::MIN + 1, -1_999_999_998,     i64::MIN    ,   -999_999_998),'), (371, '            (line!(), i64::MIN + 2, -1_999_999_998,     i64::MIN + 1,   -999_999_998),'), (372, '            (line!(), i64::MIN    , -1_999_999_999,     i64::MIN    ,   -999_999_999),'), (373, '            (line!(), i64::MIN + 1, -1_999_999_999,     i64::MIN    ,   -999_999_999),'), (374, '            (line!(), i64::MIN + 2, -1_999_999_999,     i64::MIN + 1,   -999_999_999),'), (375, '            (line!(), i64::MIN    , -2_000_000_000,     i64::MIN    ,   -999_999_999),'), (376, '            (line!(), i64::MIN + 1, -2_000_000_000,     i64::MIN    ,   -999_999_999),'), (377, '            (line!(), i64::MIN + 2, -2_000_000_000,     i64::MIN    ,              0),'), (378, '            (line!(), i64::MIN    ,   -999_999_998,     i64::MIN    ,   -999_999_998),'), (379, '            (line!(), i64::MIN + 1,   -999_999_998,     i64::MIN + 1,   -999_999_998),'), (380, '            (line!(), i64::MAX    ,              0,     i64::MAX    ,              0),'), (381, '            (line!(), i64::MAX - 1,              0,     i64::MAX - 1,              0),'), (382, '            (line!(), i64::MAX    ,             -1,     i64::MAX - 1,    999_999_999),'), (383, '            (line!(), i64::MAX    ,  1_000_000_000,     i64::MAX    ,    999_999_999),'), (384, '            (line!(), i64::MAX - 1,  1_000_000_000,     i64::MAX    ,              0),'), (385, '            (line!(), i64::MAX - 2,  1_000_000_000,     i64::MAX - 1,              0),'), (386, '            (line!(), i64::MAX    ,  1_999_999_998,     i64::MAX    ,    999_999_999),'), (387, '            (line!(), i64::MAX - 1,  1_999_999_998,     i64::MAX    ,    999_999_998),'), (388, '            (line!(), i64::MAX - 2,  1_999_999_998,     i64::MAX - 1,    999_999_998),'), (389, '            (line!(), i64::MAX    ,  1_999_999_999,     i64::MAX    ,    999_999_999),'), (390, '            (line!(), i64::MAX - 1,  1_999_999_999,     i64::MAX    ,    999_999_999),'), (391, '            (line!(), i64::MAX - 2,  1_999_999_999,     i64::MAX - 1,    999_999_999),'), (392, '            (line!(), i64::MAX    ,  2_000_000_000,     i64::MAX    ,    999_999_999),'), (393, '            (line!(), i64::MAX - 1,  2_000_000_000,     i64::MAX    ,    999_999_999),'), (394, '            (line!(), i64::MAX - 2,  2_000_000_000,     i64::MAX    ,              0),'), (395, '            (line!(), i64::MAX    ,    999_999_998,     i64::MAX    ,    999_999_998),'), (396, '            (line!(), i64::MAX - 1,    999_999_998,     i64::MAX - 1,    999_999_998),'), (397, '        ];'), (399, '        for case in cases.iter() {'), (400, '            let mut test_duration = crate::Duration {'), (401, '                seconds: case.1,'), (402, '                nanos: case.2,'), (403, '            };'), (404, '            test_duration.normalize();'), (406, '            assert_eq!('), (407, '                test_duration,'), (408, '                crate::Duration {'), (409, '                    seconds: case.3,'), (410, '                    nanos: case.4,'), (411, '                },'), (412, '                \"test case on line {} doesn\\'t match\",'), (413, '                case.0,'), (414, '            );'), (415, '        }'), (416, '    }'), (418, '    #[cfg(feature = \"std\")]'), (419, '    #[test]'), (420, '    fn check_timestamp_normalize() {'), (422, \"        #[rustfmt::skip] // Don't mangle the table formatting.\"), (423, '        let cases = ['), (426, '            (line!(),            0,              0,                0,              0),'), (427, '            (line!(),            1,              1,                1,              1),'), (428, '            (line!(),           -1,             -1,               -2,    999_999_999),'), (429, '            (line!(),            0,    999_999_999,                0,    999_999_999),'), (430, '            (line!(),            0,   -999_999_999,               -1,              1),'), (431, '            (line!(),            0,  1_000_000_000,                1,              0),'), (432, '            (line!(),            0, -1_000_000_000,               -1,              0),'), (433, '            (line!(),            0,  1_000_000_001,                1,              1),'), (434, '            (line!(),            0, -1_000_000_001,               -2,    999_999_999),'), (435, '            (line!(),           -1,              1,               -1,              1),'), (436, '            (line!(),            1,             -1,                0,    999_999_999),'), (437, '            (line!(),           -1,  1_000_000_000,                0,              0),'), (438, '            (line!(),            1, -1_000_000_000,                0,              0),'), (439, '            (line!(), i64::MIN    ,              0,     i64::MIN    ,              0),'), (440, '            (line!(), i64::MIN + 1,              0,     i64::MIN + 1,              0),'), (441, '            (line!(), i64::MIN    ,              1,     i64::MIN    ,              1),'), (442, '            (line!(), i64::MIN    ,  1_000_000_000,     i64::MIN + 1,              0),'), (443, '            (line!(), i64::MIN    , -1_000_000_000,     i64::MIN    ,              0),'), (444, '            (line!(), i64::MIN + 1, -1_000_000_000,     i64::MIN    ,              0),'), (445, '            (line!(), i64::MIN + 2, -1_000_000_000,     i64::MIN + 1,              0),'), (446, '            (line!(), i64::MIN    , -1_999_999_998,     i64::MIN    ,              0),'), (447, '            (line!(), i64::MIN + 1, -1_999_999_998,     i64::MIN    ,              0),'), (448, '            (line!(), i64::MIN + 2, -1_999_999_998,     i64::MIN    ,              2),'), (449, '            (line!(), i64::MIN    , -1_999_999_999,     i64::MIN    ,              0),'), (450, '            (line!(), i64::MIN + 1, -1_999_999_999,     i64::MIN    ,              0),'), (451, '            (line!(), i64::MIN + 2, -1_999_999_999,     i64::MIN    ,              1),'), (452, '            (line!(), i64::MIN    , -2_000_000_000,     i64::MIN    ,              0),'), (453, '            (line!(), i64::MIN + 1, -2_000_000_000,     i64::MIN    ,              0),'), (454, '            (line!(), i64::MIN + 2, -2_000_000_000,     i64::MIN    ,              0),'), (455, '            (line!(), i64::MIN    ,   -999_999_998,     i64::MIN    ,              0),'), (456, '            (line!(), i64::MIN + 1,   -999_999_998,     i64::MIN    ,              2),'), (457, '            (line!(), i64::MAX    ,              0,     i64::MAX    ,              0),'), (458, '            (line!(), i64::MAX - 1,              0,     i64::MAX - 1,              0),'), (459, '            (line!(), i64::MAX    ,             -1,     i64::MAX - 1,    999_999_999),'), (460, '            (line!(), i64::MAX    ,  1_000_000_000,     i64::MAX    ,    999_999_999),'), (461, '            (line!(), i64::MAX - 1,  1_000_000_000,     i64::MAX    ,              0),'), (462, '            (line!(), i64::MAX - 2,  1_000_000_000,     i64::MAX - 1,              0),'), (463, '            (line!(), i64::MAX    ,  1_999_999_998,     i64::MAX    ,    999_999_999),'), (464, '            (line!(), i64::MAX - 1,  1_999_999_998,     i64::MAX    ,    999_999_998),'), (465, '            (line!(), i64::MAX - 2,  1_999_999_998,     i64::MAX - 1,    999_999_998),'), (466, '            (line!(), i64::MAX    ,  1_999_999_999,     i64::MAX    ,    999_999_999),'), (467, '            (line!(), i64::MAX - 1,  1_999_999_999,     i64::MAX    ,    999_999_999),'), (468, '            (line!(), i64::MAX - 2,  1_999_999_999,     i64::MAX - 1,    999_999_999),'), (469, '            (line!(), i64::MAX    ,  2_000_000_000,     i64::MAX    ,    999_999_999),'), (470, '            (line!(), i64::MAX - 1,  2_000_000_000,     i64::MAX    ,    999_999_999),'), (471, '            (line!(), i64::MAX - 2,  2_000_000_000,     i64::MAX    ,              0),'), (472, '            (line!(), i64::MAX    ,    999_999_998,     i64::MAX    ,    999_999_998),'), (473, '            (line!(), i64::MAX - 1,    999_999_998,     i64::MAX - 1,    999_999_998),'), (474, '        ];'), (476, '        for case in cases.iter() {'), (477, '            let mut test_timestamp = crate::Timestamp {'), (478, '                seconds: case.1,'), (479, '                nanos: case.2,'), (480, '            };'), (481, '            test_timestamp.normalize();'), (483, '            assert_eq!('), (484, '                test_timestamp,'), (485, '                crate::Timestamp {'), (486, '                    seconds: case.3,'), (487, '                    nanos: case.4,'), (488, '                },'), (489, '                \"test case on line {} doesn\\'t match\",'), (490, '                case.0,'), (491, '            );'), (492, '        }'), (493, '    }')], 'deleted': [(38, '            self.seconds += (self.nanos / NANOS_PER_SECOND) as i64;'), (39, '            self.nanos %= NANOS_PER_SECOND;'), (44, '            self.seconds += 1;'), (45, '            self.nanos -= NANOS_PER_SECOND;'), (47, '            self.seconds -= 1;'), (48, '            self.nanos += NANOS_PER_SECOND;'), (107, '            self.seconds += (self.nanos / NANOS_PER_SECOND) as i64;'), (108, '            self.nanos %= NANOS_PER_SECOND;'), (113, '            self.seconds -= 1;'), (114, '            self.nanos += NANOS_PER_SECOND;'), (147, 'impl From<Timestamp> for std::time::SystemTime {'), (148, '    fn from(mut timestamp: Timestamp) -> std::time::SystemTime {'), (151, '            std::time::UNIX_EPOCH + time::Duration::from_secs(timestamp.seconds as u64)'), (153, '            std::time::UNIX_EPOCH - time::Duration::from_secs((-timestamp.seconds) as u64)'), (156, '        system_time + time::Duration::from_nanos(timestamp.nanos as u64)'), (174, '            prop_assert_eq!(SystemTime::from(Timestamp::from(system_time)), system_time);')]}",
    "num_lines_added": "232",
    "num_lines_deleted": "16",
    "nloc": "421"
  },
  {
    "file_change_id": "122605131004035",
    "hash": "85593a484173c574027d7897b980f729bb1f454f",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1041,14 +1041,24 @@ impl<A: Array> SmallVec<A> {\n                 let mut cur = ptr.add(num_added);\n                 if num_added >= lower_size_bound {\n                     // Iterator provided more elements than the hint.  Move trailing items again.\n+\n+                    // `reserve` needs `len` to be accurate.\n+                    self.set_len(old_len + num_added);\n+                    let guard_len = guard.len;\n+                    guard.len = 0; // in case `reserve` panics, don't double-free in guard.drop().\n+\n+                    // Grow the vector by 1.\n                     self.reserve(1);\n+\n                     let start = self.as_mut_ptr();\n                     ptr = start.add(index);\n                     cur = ptr.add(num_added);\n                     ptr::copy(cur, cur.add(1), old_len - index);\n \n+                    // Restore the guard.\n+                    self.set_len(0);\n                     guard.start = start;\n-                    guard.len += 1;\n+                    guard.len = guard_len + 1;\n                     guard.skip.end += 1;\n                 }\n                 ptr::write(cur, element);\n",
    "diff_parsed": "{'added': [(1046, '                    self.set_len(old_len + num_added);'), (1047, '                    let guard_len = guard.len;'), (1048, \"                    guard.len = 0; // in case `reserve` panics, don't double-free in guard.drop().\"), (1059, '                    self.set_len(0);'), (1061, '                    guard.len = guard_len + 1;')], 'deleted': [(1051, '                    guard.len += 1;')]}",
    "num_lines_added": "5",
    "num_lines_deleted": "1",
    "nloc": "1495"
  },
  {
    "file_change_id": "51497255624628",
    "hash": "85593a484173c574027d7897b980f729bb1f454f",
    "old_path": "src/tests.rs",
    "new_path": "src/tests.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -905,3 +905,18 @@ fn empty_macro() {\n fn zero_size_items() {\n     SmallVec::<[(); 0]>::new().push(());\n }\n+\n+#[test]\n+fn test_insert_many_overflow() {\n+    let mut v: SmallVec<[u8; 0]> = SmallVec::new();\n+\n+    // Spill on heap\n+    v.push(123);\n+\n+    // Prepare an iterator with small lower bound\n+    let iter = (0u8..=255).filter(|n| n % 2 == 0);\n+    assert_eq!(iter.size_hint().0, 0);\n+\n+    // Triggering the bug\n+    v.insert_many(0, iter);\n+}\n",
    "diff_parsed": "{'added': [(909, '#[test]'), (910, 'fn test_insert_many_overflow() {'), (911, '    let mut v: SmallVec<[u8; 0]> = SmallVec::new();'), (914, '    v.push(123);'), (917, '    let iter = (0u8..=255).filter(|n| n % 2 == 0);'), (918, '    assert_eq!(iter.size_hint().0, 0);'), (921, '    v.insert_many(0, iter);'), (922, '}')], 'deleted': []}",
    "num_lines_added": "8",
    "num_lines_deleted": "0",
    "nloc": "770"
  },
  {
    "file_change_id": "250378483580548",
    "hash": "18abedadaa77646cce6f2ca2149c0119a2e4f428",
    "old_path": "None",
    "new_path": "src/array_iter.rs",
    "change_type": "ModificationType.ADD",
    "diff": "@@ -0,0 +1,75 @@\n+// Copyright 2018-2021 Theodore Cipicchio\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Consuming iterator for static arrays.\n+\n+use super::Array;\n+use core::{mem::ManuallyDrop, ptr, slice};\n+\n+/// Consuming iterator for static arrays.\n+pub struct ArrayIter<T>\n+where\n+    T: Array,\n+{\n+    /// Source array being consumed.\n+    source: ManuallyDrop<T>,\n+    /// Index of the next element to yield.\n+    index: usize,\n+}\n+\n+impl<T> ArrayIter<T>\n+where\n+    T: Array,\n+{\n+    /// Creates a new iterator consuming all elements in the given array.\n+    pub fn new(source: T) -> Self {\n+        Self {\n+            source: ManuallyDrop::new(source),\n+            index: 0,\n+        }\n+    }\n+}\n+\n+impl<T> Iterator for ArrayIter<T>\n+where\n+    T: Array,\n+{\n+    type Item = T::Item;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let source = self.source.as_slice();\n+        let index = self.index;\n+        if index < source.len() {\n+            self.index = index + 1;\n+\n+            Some(unsafe { ptr::read(&source[index]) })\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl<T> Drop for ArrayIter<T>\n+where\n+    T: Array,\n+{\n+    fn drop(&mut self) {\n+        // Drop all unconsumed elements.\n+        let source = self.source.as_mut_slice();\n+        let remaining_len = source.len() - self.index;\n+        unsafe {\n+            // The Rust compiler and standard library try to prevent cases\n+            // where the length of an allocation is larger than `isize::MAX`\n+            // (see the `pointer::offset` safety documentation), so casting\n+            // the source array length to an `isize` should be okay.\n+            let start = source.as_mut_ptr().offset(self.index as isize);\n+            let remaining = slice::from_raw_parts_mut(start, remaining_len);\n+            ptr::drop_in_place(remaining);\n+        }\n+    }\n+}\n",
    "diff_parsed": "{'added': [(11, 'use super::Array;'), (12, 'use core::{mem::ManuallyDrop, ptr, slice};'), (15, 'pub struct ArrayIter<T>'), (16, 'where'), (17, '    T: Array,'), (18, '{'), (20, '    source: ManuallyDrop<T>,'), (22, '    index: usize,'), (23, '}'), (25, 'impl<T> ArrayIter<T>'), (26, 'where'), (27, '    T: Array,'), (28, '{'), (30, '    pub fn new(source: T) -> Self {'), (31, '        Self {'), (32, '            source: ManuallyDrop::new(source),'), (33, '            index: 0,'), (34, '        }'), (35, '    }'), (36, '}'), (38, 'impl<T> Iterator for ArrayIter<T>'), (39, 'where'), (40, '    T: Array,'), (41, '{'), (42, '    type Item = T::Item;'), (44, '    fn next(&mut self) -> Option<Self::Item> {'), (45, '        let source = self.source.as_slice();'), (46, '        let index = self.index;'), (47, '        if index < source.len() {'), (48, '            self.index = index + 1;'), (50, '            Some(unsafe { ptr::read(&source[index]) })'), (51, '        } else {'), (52, '            None'), (53, '        }'), (54, '    }'), (55, '}'), (57, 'impl<T> Drop for ArrayIter<T>'), (58, 'where'), (59, '    T: Array,'), (60, '{'), (61, '    fn drop(&mut self) {'), (63, '        let source = self.source.as_mut_slice();'), (64, '        let remaining_len = source.len() - self.index;'), (65, '        unsafe {'), (70, '            let start = source.as_mut_ptr().offset(self.index as isize);'), (71, '            let remaining = slice::from_raw_parts_mut(start, remaining_len);'), (72, '            ptr::drop_in_place(remaining);'), (73, '        }'), (74, '    }'), (75, '}')], 'deleted': []}",
    "num_lines_added": "50",
    "num_lines_deleted": "0",
    "nloc": "50"
  },
  {
    "file_change_id": "255234817296480",
    "hash": "18abedadaa77646cce6f2ca2149c0119a2e4f428",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -820,5 +820,8 @@ pub use scratchpad::*;\n pub use traits::*;\n pub use utility::*;\n \n+mod array_iter;\n+pub(crate) use array_iter::*;\n+\n #[cfg(test)]\n mod tests;\n",
    "diff_parsed": "{'added': [(823, 'mod array_iter;'), (824, 'pub(crate) use array_iter::*;')], 'deleted': []}",
    "num_lines_added": "2",
    "num_lines_deleted": "0",
    "nloc": "53"
  },
  {
    "file_change_id": "162490835580626",
    "hash": "18abedadaa77646cce6f2ca2149c0119a2e4f428",
    "old_path": "src/tests.rs",
    "new_path": "src/tests.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -18,6 +18,9 @@ use core::mem::MaybeUninit;\n #[cfg(any(feature = \"std\", feature = \"alloc\", feature = \"unstable\"))]\n use super::{Box, Vec};\n \n+#[cfg(feature = \"std\")]\n+use std::panic::{self, AssertUnwindSafe};\n+\n // Struct that increments a counter each time it is dropped (used for testing\n // for accidental drops due to incorrect moving of values in unsafe code).\n #[derive(Clone, Debug)]\n@@ -1152,6 +1155,209 @@ fn slice_move_source_collection_boxed_slice_test() {\n     assert_eq!(drop_count.get(), 3);\n }\n \n+/// Verifies array implementations of `SliceMoveSource` do not drop elements\n+/// that have already been moved out of the source during panic unwinds.\n+#[test]\n+#[cfg(feature = \"std\")]\n+fn slice_move_source_array_panic_unwind_test() {\n+    let drop_count = Cell::new(0);\n+    let data = [\n+        DropCounter::new(&drop_count),\n+        DropCounter::new(&drop_count),\n+        DropCounter::new(&drop_count),\n+    ];\n+\n+    let mut move_count = 0;\n+    panic::catch_unwind(AssertUnwindSafe(|| {\n+        data.move_elements(|x| {\n+            move_count += 1;\n+            if move_count == 2 {\n+                panic!();\n+            }\n+\n+            drop(x);\n+        });\n+    }))\n+    .unwrap_or(());\n+\n+    assert_eq!(drop_count.get(), 3);\n+}\n+\n+/// Verifies boxed slice implementations of `SliceMoveSource` do not drop\n+/// elements that have already been moved out of the source during panic\n+/// unwinds.\n+#[test]\n+#[cfg(feature = \"std\")]\n+fn slice_move_source_boxed_slice_panic_unwind_test() {\n+    let drop_count = Cell::new(0);\n+    let data = vec![\n+        DropCounter::new(&drop_count),\n+        DropCounter::new(&drop_count),\n+        DropCounter::new(&drop_count),\n+    ]\n+    .into_boxed_slice();\n+\n+    let mut move_count = 0;\n+    panic::catch_unwind(AssertUnwindSafe(|| {\n+        data.move_elements(|x| {\n+            move_count += 1;\n+            if move_count == 2 {\n+                panic!();\n+            }\n+\n+            drop(x);\n+        });\n+    }))\n+    .unwrap_or(());\n+\n+    assert_eq!(drop_count.get(), 3);\n+}\n+\n+/// Verifies vector implementations of `SliceMoveSource` do not drop elements\n+/// that have already been moved out of the source during panic unwinds.\n+#[test]\n+#[cfg(feature = \"std\")]\n+fn slice_move_source_vec_panic_unwind_test() {\n+    let drop_count = Cell::new(0);\n+    let data = vec![\n+        DropCounter::new(&drop_count),\n+        DropCounter::new(&drop_count),\n+        DropCounter::new(&drop_count),\n+    ];\n+\n+    let mut move_count = 0;\n+    panic::catch_unwind(AssertUnwindSafe(|| {\n+        data.move_elements(|x| {\n+            move_count += 1;\n+            if move_count == 2 {\n+                panic!();\n+            }\n+\n+            drop(x);\n+        });\n+    }))\n+    .unwrap_or(());\n+\n+    assert_eq!(drop_count.get(), 3);\n+}\n+\n+/// Verifies array implementations of `SliceMoveSourceCollection` do not drop\n+/// elements that have already been moved out of the collection during panic\n+/// unwinds.\n+#[test]\n+#[cfg(feature = \"std\")]\n+fn slice_move_source_collection_array_panic_unwind_test() {\n+    let drop_count = Cell::new(0);\n+    let data = [\n+        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],\n+        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],\n+        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],\n+    ];\n+\n+    let mut move_count = 0;\n+    panic::catch_unwind(AssertUnwindSafe(|| {\n+        data.move_all_elements(|x| {\n+            move_count += 1;\n+            if move_count == 3 {\n+                panic!();\n+            }\n+\n+            drop(x);\n+        });\n+    }))\n+    .unwrap_or(());\n+\n+    assert_eq!(drop_count.get(), 6);\n+}\n+\n+/// Verifies boxed slice implementations of `SliceMoveSourceCollection` do not\n+/// drop elements that have already been moved out of the collection during\n+/// panic unwinds.\n+#[test]\n+#[cfg(feature = \"std\")]\n+fn slice_move_source_collection_boxed_slice_panic_unwind_test() {\n+    let drop_count = Cell::new(0);\n+    let data = vec![\n+        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],\n+        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],\n+        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],\n+    ]\n+    .into_boxed_slice();\n+\n+    let mut move_count = 0;\n+    panic::catch_unwind(AssertUnwindSafe(|| {\n+        data.move_all_elements(|x| {\n+            move_count += 1;\n+            if move_count == 3 {\n+                panic!();\n+            }\n+\n+            drop(x);\n+        });\n+    }))\n+    .unwrap_or(());\n+\n+    assert_eq!(drop_count.get(), 6);\n+}\n+\n+/// Verifies vector implementations of `SliceMoveSourceCollection` do not drop\n+/// elements that have already been moved out of the collection during panic\n+/// unwinds.\n+#[test]\n+#[cfg(feature = \"std\")]\n+fn slice_move_source_collection_vec_panic_unwind_test() {\n+    let drop_count = Cell::new(0);\n+    let data = vec![\n+        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],\n+        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],\n+        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],\n+    ];\n+\n+    let mut move_count = 0;\n+    panic::catch_unwind(AssertUnwindSafe(|| {\n+        data.move_all_elements(|x| {\n+            move_count += 1;\n+            if move_count == 3 {\n+                panic!();\n+            }\n+\n+            drop(x);\n+        });\n+    }))\n+    .unwrap_or(());\n+\n+    assert_eq!(drop_count.get(), 6);\n+}\n+\n+/// Verifies tuple implementations of `SliceMoveSourceCollection` do not drop\n+/// elements that have already been moved out of the collection during panic\n+/// unwinds.\n+#[test]\n+#[cfg(feature = \"std\")]\n+fn slice_move_source_collection_tuple_panic_unwind_test() {\n+    let drop_count = Cell::new(0);\n+    let data = (\n+        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],\n+        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],\n+        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],\n+    );\n+\n+    let mut move_count = 0;\n+    panic::catch_unwind(AssertUnwindSafe(|| {\n+        data.move_all_elements(|x| {\n+            move_count += 1;\n+            if move_count == 3 {\n+                panic!();\n+            }\n+\n+            drop(x);\n+        });\n+    }))\n+    .unwrap_or(());\n+\n+    assert_eq!(drop_count.get(), 6);\n+}\n+\n /// Verifies ZST allocations work properly.\n #[test]\n fn zst_test() {\n",
    "diff_parsed": "{'added': [(21, '#[cfg(feature = \"std\")]'), (22, 'use std::panic::{self, AssertUnwindSafe};'), (1160, '#[test]'), (1161, '#[cfg(feature = \"std\")]'), (1162, 'fn slice_move_source_array_panic_unwind_test() {'), (1163, '    let drop_count = Cell::new(0);'), (1164, '    let data = ['), (1165, '        DropCounter::new(&drop_count),'), (1166, '        DropCounter::new(&drop_count),'), (1167, '        DropCounter::new(&drop_count),'), (1168, '    ];'), (1170, '    let mut move_count = 0;'), (1171, '    panic::catch_unwind(AssertUnwindSafe(|| {'), (1172, '        data.move_elements(|x| {'), (1173, '            move_count += 1;'), (1174, '            if move_count == 2 {'), (1175, '                panic!();'), (1176, '            }'), (1178, '            drop(x);'), (1179, '        });'), (1180, '    }))'), (1181, '    .unwrap_or(());'), (1183, '    assert_eq!(drop_count.get(), 3);'), (1184, '}'), (1189, '#[test]'), (1190, '#[cfg(feature = \"std\")]'), (1191, 'fn slice_move_source_boxed_slice_panic_unwind_test() {'), (1192, '    let drop_count = Cell::new(0);'), (1193, '    let data = vec!['), (1194, '        DropCounter::new(&drop_count),'), (1195, '        DropCounter::new(&drop_count),'), (1196, '        DropCounter::new(&drop_count),'), (1197, '    ]'), (1198, '    .into_boxed_slice();'), (1200, '    let mut move_count = 0;'), (1201, '    panic::catch_unwind(AssertUnwindSafe(|| {'), (1202, '        data.move_elements(|x| {'), (1203, '            move_count += 1;'), (1204, '            if move_count == 2 {'), (1205, '                panic!();'), (1206, '            }'), (1208, '            drop(x);'), (1209, '        });'), (1210, '    }))'), (1211, '    .unwrap_or(());'), (1213, '    assert_eq!(drop_count.get(), 3);'), (1214, '}'), (1218, '#[test]'), (1219, '#[cfg(feature = \"std\")]'), (1220, 'fn slice_move_source_vec_panic_unwind_test() {'), (1221, '    let drop_count = Cell::new(0);'), (1222, '    let data = vec!['), (1223, '        DropCounter::new(&drop_count),'), (1224, '        DropCounter::new(&drop_count),'), (1225, '        DropCounter::new(&drop_count),'), (1226, '    ];'), (1228, '    let mut move_count = 0;'), (1229, '    panic::catch_unwind(AssertUnwindSafe(|| {'), (1230, '        data.move_elements(|x| {'), (1231, '            move_count += 1;'), (1232, '            if move_count == 2 {'), (1233, '                panic!();'), (1234, '            }'), (1236, '            drop(x);'), (1237, '        });'), (1238, '    }))'), (1239, '    .unwrap_or(());'), (1241, '    assert_eq!(drop_count.get(), 3);'), (1242, '}'), (1247, '#[test]'), (1248, '#[cfg(feature = \"std\")]'), (1249, 'fn slice_move_source_collection_array_panic_unwind_test() {'), (1250, '    let drop_count = Cell::new(0);'), (1251, '    let data = ['), (1252, '        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],'), (1253, '        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],'), (1254, '        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],'), (1255, '    ];'), (1257, '    let mut move_count = 0;'), (1258, '    panic::catch_unwind(AssertUnwindSafe(|| {'), (1259, '        data.move_all_elements(|x| {'), (1260, '            move_count += 1;'), (1261, '            if move_count == 3 {'), (1262, '                panic!();'), (1263, '            }'), (1265, '            drop(x);'), (1266, '        });'), (1267, '    }))'), (1268, '    .unwrap_or(());'), (1270, '    assert_eq!(drop_count.get(), 6);'), (1271, '}'), (1276, '#[test]'), (1277, '#[cfg(feature = \"std\")]'), (1278, 'fn slice_move_source_collection_boxed_slice_panic_unwind_test() {'), (1279, '    let drop_count = Cell::new(0);'), (1280, '    let data = vec!['), (1281, '        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],'), (1282, '        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],'), (1283, '        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],'), (1284, '    ]'), (1285, '    .into_boxed_slice();'), (1287, '    let mut move_count = 0;'), (1288, '    panic::catch_unwind(AssertUnwindSafe(|| {'), (1289, '        data.move_all_elements(|x| {'), (1290, '            move_count += 1;'), (1291, '            if move_count == 3 {'), (1292, '                panic!();'), (1293, '            }'), (1295, '            drop(x);'), (1296, '        });'), (1297, '    }))'), (1298, '    .unwrap_or(());'), (1300, '    assert_eq!(drop_count.get(), 6);'), (1301, '}'), (1306, '#[test]'), (1307, '#[cfg(feature = \"std\")]'), (1308, 'fn slice_move_source_collection_vec_panic_unwind_test() {'), (1309, '    let drop_count = Cell::new(0);'), (1310, '    let data = vec!['), (1311, '        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],'), (1312, '        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],'), (1313, '        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],'), (1314, '    ];'), (1316, '    let mut move_count = 0;'), (1317, '    panic::catch_unwind(AssertUnwindSafe(|| {'), (1318, '        data.move_all_elements(|x| {'), (1319, '            move_count += 1;'), (1320, '            if move_count == 3 {'), (1321, '                panic!();'), (1322, '            }'), (1324, '            drop(x);'), (1325, '        });'), (1326, '    }))'), (1327, '    .unwrap_or(());'), (1329, '    assert_eq!(drop_count.get(), 6);'), (1330, '}'), (1335, '#[test]'), (1336, '#[cfg(feature = \"std\")]'), (1337, 'fn slice_move_source_collection_tuple_panic_unwind_test() {'), (1338, '    let drop_count = Cell::new(0);'), (1339, '    let data = ('), (1340, '        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],'), (1341, '        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],'), (1342, '        [DropCounter::new(&drop_count), DropCounter::new(&drop_count)],'), (1343, '    );'), (1345, '    let mut move_count = 0;'), (1346, '    panic::catch_unwind(AssertUnwindSafe(|| {'), (1347, '        data.move_all_elements(|x| {'), (1348, '            move_count += 1;'), (1349, '            if move_count == 3 {'), (1350, '                panic!();'), (1351, '            }'), (1353, '            drop(x);'), (1354, '        });'), (1355, '    }))'), (1356, '    .unwrap_or(());'), (1358, '    assert_eq!(drop_count.get(), 6);'), (1359, '}')], 'deleted': []}",
    "num_lines_added": "158",
    "num_lines_deleted": "0",
    "nloc": "1074"
  },
  {
    "file_change_id": "41486917337418",
    "hash": "18abedadaa77646cce6f2ca2149c0119a2e4f428",
    "old_path": "src/traits.rs",
    "new_path": "src/traits.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -12,18 +12,16 @@ use core::ptr;\n use core::slice;\n use core::str;\n \n-use super::CacheAligned;\n+use super::{ArrayIter, CacheAligned};\n+use core::mem::size_of;\n #[cfg(any(stable_maybe_uninit, feature = \"unstable\"))]\n use core::mem::MaybeUninit;\n-use core::mem::{forget, size_of};\n \n #[cfg(feature = \"std\")]\n use std::ffi::CStr;\n \n #[cfg(any(feature = \"std\", feature = \"alloc\", feature = \"unstable\"))]\n use super::{Box, Vec};\n-#[cfg(any(feature = \"std\", feature = \"alloc\", feature = \"unstable\"))]\n-use core::mem::ManuallyDrop;\n \n /// Trait for types that can be safely used as the backing data type for\n /// storage of arbitrary data.\n@@ -868,12 +866,8 @@ where\n     where\n         F: FnMut(<T as Array>::Item),\n     {\n-        unsafe {\n-            for item in self.as_slice() {\n-                f(ptr::read(item))\n-            }\n-\n-            forget(self);\n+        for item in ArrayIter::new(self) {\n+            f(item);\n         }\n     }\n }\n@@ -888,7 +882,7 @@ where\n         F: FnMut(<T as SliceLike>::Element),\n     {\n         for item in self.as_element_slice() {\n-            f(*item)\n+            f(*item);\n         }\n     }\n }\n@@ -902,14 +896,13 @@ where\n     where\n         F: FnMut(<T as SliceLike>::Element),\n     {\n-        unsafe {\n-            for item in self.as_element_slice() {\n-                f(ptr::read(item));\n-            }\n-\n+        let boxed_slice = unsafe {\n             Box::from_raw((*Box::into_raw(self)).as_element_slice_mut()\n-                as *mut [<T as SliceLike>::Element]\n-                as *mut [ManuallyDrop<<T as SliceLike>::Element>]);\n+                as *mut [T::Element])\n+        };\n+\n+        for item in boxed_slice.into_vec() {\n+            f(item);\n         }\n     }\n }\n@@ -1138,12 +1131,8 @@ where\n     where\n         F: FnMut(<T as SliceLike>::Element),\n     {\n-        unsafe {\n-            for source in self.as_slice() {\n-                ptr::read(source).move_elements(&mut f);\n-            }\n-\n-            forget(self);\n+        for source in ArrayIter::new(self) {\n+            source.move_elements(&mut f);\n         }\n     }\n }\n@@ -1176,12 +1165,8 @@ where\n     where\n         F: FnMut(<T as SliceLike>::Element),\n     {\n-        unsafe {\n-            for source in &*self {\n-                ptr::read(source).move_elements(&mut f);\n-            }\n-\n-            Box::from_raw(Box::into_raw(self) as *mut [ManuallyDrop<U>]);\n+        for source in self.into_vec() {\n+            source.move_elements(&mut f);\n         }\n     }\n }\n",
    "diff_parsed": "{'added': [(15, 'use super::{ArrayIter, CacheAligned};'), (16, 'use core::mem::size_of;'), (869, '        for item in ArrayIter::new(self) {'), (870, '            f(item);'), (885, '            f(*item);'), (899, '        let boxed_slice = unsafe {'), (901, '                as *mut [T::Element])'), (902, '        };'), (904, '        for item in boxed_slice.into_vec() {'), (905, '            f(item);'), (1134, '        for source in ArrayIter::new(self) {'), (1135, '            source.move_elements(&mut f);'), (1168, '        for source in self.into_vec() {'), (1169, '            source.move_elements(&mut f);')], 'deleted': [(15, 'use super::CacheAligned;'), (18, 'use core::mem::{forget, size_of};'), (25, '#[cfg(any(feature = \"std\", feature = \"alloc\", feature = \"unstable\"))]'), (26, 'use core::mem::ManuallyDrop;'), (871, '        unsafe {'), (872, '            for item in self.as_slice() {'), (873, '                f(ptr::read(item))'), (874, '            }'), (876, '            forget(self);'), (891, '            f(*item)'), (905, '        unsafe {'), (906, '            for item in self.as_element_slice() {'), (907, '                f(ptr::read(item));'), (908, '            }'), (911, '                as *mut [<T as SliceLike>::Element]'), (912, '                as *mut [ManuallyDrop<<T as SliceLike>::Element>]);'), (1141, '        unsafe {'), (1142, '            for source in self.as_slice() {'), (1143, '                ptr::read(source).move_elements(&mut f);'), (1144, '            }'), (1146, '            forget(self);'), (1179, '        unsafe {'), (1180, '            for source in &*self {'), (1181, '                ptr::read(source).move_elements(&mut f);'), (1182, '            }'), (1184, '            Box::from_raw(Box::into_raw(self) as *mut [ManuallyDrop<U>]);')]}",
    "num_lines_added": "14",
    "num_lines_deleted": "26",
    "nloc": "769"
  },
  {
    "file_change_id": "166381872520541",
    "hash": "6b83f9d0708337a9f8b709c1624a8587021ceba2",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -224,11 +224,13 @@ impl<T> Arena<T> {\n         &'a mut self,\n         selected: I,\n     ) -> Option<(&mut T, ArenaSplit<'a, T>)> {\n-        if let Some(value) = self.get_mut(selected.borrow()) {\n+        let selected = selected.borrow();\n+\n+        if let Some(value) = self.get_mut(selected) {\n             Some((\n                 unsafe { (value as *mut T).as_mut().unwrap() },\n                 ArenaSplit {\n-                    selected: selected.borrow().clone(),\n+                    selected: selected.clone(),\n                     arena: self,\n                     __type: Default::default(),\n                 },\n@@ -421,6 +423,7 @@ impl<T> Into<Vec<T>> for Arena<T> {\n #[cfg(test)]\n mod tests {\n     use super::*;\n+    use std::cell::Cell;\n \n     fn setup_arena() -> (Arena<String>, Idx, Idx, Idx, Idx) {\n         let mut arena = Arena::new();\n@@ -707,4 +710,54 @@ mod tests {\n \n         assert_eq!(format!(\"{:?}\", john), \"Removed Idx ( 0 )\");\n     }\n+\n+    #[test]\n+    fn compare_should_work_for_idx() {\n+        let mut arena = Arena::new();\n+        let left = arena.alloc(1);\n+        let right = left.clone();\n+\n+        assert!(left.borrow() == right.borrow());\n+    }\n+\n+    #[test]\n+    fn splitting_should_be_safe() {\n+        // A bug described here (https://github.com/bennetthardwick/nano-arena/issues/1) meant that\n+        // multiple mutable references could be handed out.\n+\n+        struct ToggleIdx {\n+            first: Idx,\n+            second: Idx,\n+            state: Cell<bool>,\n+        }\n+\n+        impl Borrow<Idx> for ToggleIdx {\n+            fn borrow(&self) -> &Idx {\n+                self.state.set(!self.state.get());\n+\n+                if self.state.get() {\n+                    &self.first\n+                } else {\n+                    &self.second\n+                }\n+            }\n+        }\n+\n+        let mut arena = Arena::new();\n+\n+        let first = arena.alloc(1);\n+        let second = arena.alloc(2);\n+\n+        let toggle_idx = ToggleIdx {\n+            first: first.clone(),\n+            second: second.clone(),\n+            state: Cell::new(false),\n+        };\n+\n+        let (first_mut_ref, mut split_arena) = arena.split_at(toggle_idx).unwrap();\n+        let second_mut_ref = split_arena.get_mut(&first);\n+\n+        drop(first_mut_ref);\n+        assert!(second_mut_ref.is_none());\n+    }\n }\n",
    "diff_parsed": "{'added': [(227, '        let selected = selected.borrow();'), (229, '        if let Some(value) = self.get_mut(selected) {'), (233, '                    selected: selected.clone(),'), (426, '    use std::cell::Cell;'), (714, '    #[test]'), (715, '    fn compare_should_work_for_idx() {'), (716, '        let mut arena = Arena::new();'), (717, '        let left = arena.alloc(1);'), (718, '        let right = left.clone();'), (720, '        assert!(left.borrow() == right.borrow());'), (721, '    }'), (723, '    #[test]'), (724, '    fn splitting_should_be_safe() {'), (728, '        struct ToggleIdx {'), (729, '            first: Idx,'), (730, '            second: Idx,'), (731, '            state: Cell<bool>,'), (732, '        }'), (734, '        impl Borrow<Idx> for ToggleIdx {'), (735, '            fn borrow(&self) -> &Idx {'), (736, '                self.state.set(!self.state.get());'), (738, '                if self.state.get() {'), (739, '                    &self.first'), (740, '                } else {'), (741, '                    &self.second'), (742, '                }'), (743, '            }'), (744, '        }'), (746, '        let mut arena = Arena::new();'), (748, '        let first = arena.alloc(1);'), (749, '        let second = arena.alloc(2);'), (751, '        let toggle_idx = ToggleIdx {'), (752, '            first: first.clone(),'), (753, '            second: second.clone(),'), (754, '            state: Cell::new(false),'), (755, '        };'), (757, '        let (first_mut_ref, mut split_arena) = arena.split_at(toggle_idx).unwrap();'), (758, '        let second_mut_ref = split_arena.get_mut(&first);'), (760, '        drop(first_mut_ref);'), (761, '        assert!(second_mut_ref.is_none());'), (762, '    }')], 'deleted': [(227, '        if let Some(value) = self.get_mut(selected.borrow()) {'), (231, '                    selected: selected.borrow().clone(),')]}",
    "num_lines_added": "41",
    "num_lines_deleted": "2",
    "nloc": "633"
  },
  {
    "file_change_id": "218707757336165",
    "hash": "dfeb84bfce2be11327749c152b3c8f4ea4304e12",
    "old_path": "src/access.rs",
    "new_path": "src/access.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,3 +1,5 @@\n+#![deny(unsafe_code)]\n+\n //! Abstracting over accessing parts of stored value.\n //!\n //! Sometimes, there's a big globalish data structure (like a configuration for the whole program).\n@@ -205,39 +207,20 @@ where\n \n #[doc(hidden)]\n #[derive(Copy, Clone, Debug)]\n-pub struct MapGuard<G, T> {\n-    _guard: G,\n-    value: *const T,\n-}\n-\n-// Why these are safe:\n-// * The *const T is actually used just as a &const T with 'self lifetime (which can't be done in\n-//   Rust). So if the reference is Send/Sync, so is the raw pointer.\n-unsafe impl<G, T> Send for MapGuard<G, T>\n-where\n-    G: Send,\n-    for<'a> &'a T: Send,\n-{\n+pub struct MapGuard<G, F, T, R> {\n+    guard: G,\n+    projection: F,\n+    _t: PhantomData<fn(&T) -> &R>,\n }\n \n-unsafe impl<G, T> Sync for MapGuard<G, T>\n+impl<G, F, T, R> Deref for MapGuard<G, F, T, R>\n where\n-    G: Sync,\n-    for<'a> &'a T: Sync,\n+    G: Deref<Target = T>,\n+    F: Fn(&T) -> &R,\n {\n-}\n-\n-impl<G, T> Deref for MapGuard<G, T> {\n-    type Target = T;\n-    fn deref(&self) -> &T {\n-        // Why this is safe:\n-        // * The pointer is originally converted from a reference. It's not null, it's aligned,\n-        //   it's the right type, etc.\n-        // * The pointee couldn't have gone away \u2012 the guard keeps the original reference alive, so\n-        //   must the new one still be alive too. Moving the guard is fine, we assume the RefCnt is\n-        //   Pin (because it's Arc or Rc or something like that \u2012 when that one moves, the data it\n-        //   points to stay at the same place).\n-        unsafe { &*self.value }\n+    type Target = R;\n+    fn deref(&self) -> &R {\n+        (self.projection)(&self.guard)\n     }\n }\n \n@@ -266,7 +249,7 @@ impl<A, T, F> Map<A, T, F> {\n     ///   *cheap* (like only taking reference).\n     pub fn new<R>(access: A, projection: F) -> Self\n     where\n-        F: Fn(&T) -> &R,\n+        F: Fn(&T) -> &R + Clone,\n     {\n         Map {\n             access,\n@@ -276,18 +259,18 @@ impl<A, T, F> Map<A, T, F> {\n     }\n }\n \n-impl<A, T, F, R> Access<R> for Map<A, T, F>\n+impl<A, F, T, R> Access<R> for Map<A, T, F>\n where\n     A: Access<T>,\n-    F: Fn(&T) -> &R,\n+    F: Fn(&T) -> &R + Clone,\n {\n-    type Guard = MapGuard<A::Guard, R>;\n+    type Guard = MapGuard<A::Guard, F, T, R>;\n     fn load(&self) -> Self::Guard {\n         let guard = self.access.load();\n-        let value: *const _ = (self.projection)(&guard);\n         MapGuard {\n-            _guard: guard,\n-            value,\n+            guard,\n+            projection: self.projection.clone(),\n+            _t: PhantomData,\n         }\n     }\n }\n",
    "diff_parsed": "{'added': [(1, '#![deny(unsafe_code)]'), (210, 'pub struct MapGuard<G, F, T, R> {'), (211, '    guard: G,'), (212, '    projection: F,'), (213, '    _t: PhantomData<fn(&T) -> &R>,'), (216, 'impl<G, F, T, R> Deref for MapGuard<G, F, T, R>'), (218, '    G: Deref<Target = T>,'), (219, '    F: Fn(&T) -> &R,'), (221, '    type Target = R;'), (222, '    fn deref(&self) -> &R {'), (223, '        (self.projection)(&self.guard)'), (252, '        F: Fn(&T) -> &R + Clone,'), (262, 'impl<A, F, T, R> Access<R> for Map<A, T, F>'), (265, '    F: Fn(&T) -> &R + Clone,'), (267, '    type Guard = MapGuard<A::Guard, F, T, R>;'), (271, '            guard,'), (272, '            projection: self.projection.clone(),'), (273, '            _t: PhantomData,')], 'deleted': [(208, 'pub struct MapGuard<G, T> {'), (209, '    _guard: G,'), (210, '    value: *const T,'), (211, '}'), (216, 'unsafe impl<G, T> Send for MapGuard<G, T>'), (217, 'where'), (218, '    G: Send,'), (219, \"    for<'a> &'a T: Send,\"), (220, '{'), (223, 'unsafe impl<G, T> Sync for MapGuard<G, T>'), (225, '    G: Sync,'), (226, \"    for<'a> &'a T: Sync,\"), (228, '}'), (230, 'impl<G, T> Deref for MapGuard<G, T> {'), (231, '    type Target = T;'), (232, '    fn deref(&self) -> &T {'), (240, '        unsafe { &*self.value }'), (269, '        F: Fn(&T) -> &R,'), (279, 'impl<A, T, F, R> Access<R> for Map<A, T, F>'), (282, '    F: Fn(&T) -> &R,'), (284, '    type Guard = MapGuard<A::Guard, R>;'), (287, '        let value: *const _ = (self.projection)(&guard);'), (289, '            _guard: guard,'), (290, '            value,')]}",
    "num_lines_added": "18",
    "num_lines_deleted": "24",
    "nloc": "253"
  },
  {
    "file_change_id": "222902428260748",
    "hash": "dfeb84bfce2be11327749c152b3c8f4ea4304e12",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -660,7 +660,7 @@ impl<T: RefCnt, S: Strategy<T>> ArcSwapAny<T, S> {\n     /// ```\n     pub fn map<I, R, F>(&self, f: F) -> Map<&Self, I, F>\n     where\n-        F: Fn(&I) -> &R,\n+        F: Fn(&I) -> &R + Clone,\n         Self: Access<I>,\n     {\n         Map::new(self, f)\n",
    "diff_parsed": "{'added': [(663, '        F: Fn(&I) -> &R + Clone,')], 'deleted': [(663, '        F: Fn(&I) -> &R,')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "598"
  },
  {
    "file_change_id": "254514581471684",
    "hash": "340f893dbc9db3e43c6315b05eff4b0b150220d2",
    "old_path": "nanorand/src/tls.rs",
    "new_path": "nanorand/src/tls.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,32 +1,27 @@\n-use crate::WyRand;\n-use std::{\n-\tcell::UnsafeCell,\n-\tops::{Deref, DerefMut},\n-\trc::Rc,\n-};\n+use crate::{Rng, WyRand};\n+use std::{cell::RefCell, rc::Rc};\n \n thread_local! {\n-\tstatic WYRAND: Rc<UnsafeCell<WyRand>> = Rc::new(UnsafeCell::new(WyRand::new()));\n+\tstatic WYRAND: Rc<RefCell<WyRand>> = Rc::new(RefCell::new(WyRand::new()));\n }\n \n+#[derive(Clone)]\n #[doc(hidden)]\n-pub struct TlsWyRand(Rc<UnsafeCell<WyRand>>);\n+pub struct TlsWyRand(Rc<RefCell<WyRand>>);\n \n-impl Deref for TlsWyRand {\n-\ttype Target = WyRand;\n+impl Rng for TlsWyRand {\n+\ttype Output = [u8; 8];\n \n-\t/// Safety: [`TlsWyRand`] is neither [Send] nor [Sync], and thus,\n-\t/// there will always be a thread-local [`WyRand`] when there is a [`TlsWyRand`]\n-\tfn deref(&self) -> &Self::Target {\n-\t\tunsafe { &*self.0.get() }\n+\tfn rand(&mut self) -> Self::Output {\n+\t\tself.0.borrow_mut().rand()\n+\t}\n+\n+\tfn rand_with_seed(seed: &[u8]) -> Self::Output {\n+\t\tWyRand::rand_with_seed(seed)\n \t}\n-}\n \n-impl DerefMut for TlsWyRand {\n-\t/// Safety: [`TlsWyRand`] is neither [Send] nor [Sync], and thus,\n-\t/// there will always be a thread-local [`WyRand`] when there is a [`TlsWyRand`]\n-\tfn deref_mut(&mut self) -> &mut Self::Target {\n-\t\tunsafe { &mut *(*self.0).get() }\n+\tfn reseed(&mut self, new_seed: &[u8]) {\n+\t\tself.0.borrow_mut().reseed(new_seed)\n \t}\n }\n \n",
    "diff_parsed": "{'added': [(1, 'use crate::{Rng, WyRand};'), (2, 'use std::{cell::RefCell, rc::Rc};'), (5, '\\tstatic WYRAND: Rc<RefCell<WyRand>> = Rc::new(RefCell::new(WyRand::new()));'), (8, '#[derive(Clone)]'), (10, 'pub struct TlsWyRand(Rc<RefCell<WyRand>>);'), (12, 'impl Rng for TlsWyRand {'), (13, '\\ttype Output = [u8; 8];'), (15, '\\tfn rand(&mut self) -> Self::Output {'), (16, '\\t\\tself.0.borrow_mut().rand()'), (17, '\\t}'), (19, '\\tfn rand_with_seed(seed: &[u8]) -> Self::Output {'), (20, '\\t\\tWyRand::rand_with_seed(seed)'), (23, '\\tfn reseed(&mut self, new_seed: &[u8]) {'), (24, '\\t\\tself.0.borrow_mut().reseed(new_seed)')], 'deleted': [(1, 'use crate::WyRand;'), (2, 'use std::{'), (3, '\\tcell::UnsafeCell,'), (4, '\\tops::{Deref, DerefMut},'), (5, '\\trc::Rc,'), (6, '};'), (9, '\\tstatic WYRAND: Rc<UnsafeCell<WyRand>> = Rc::new(UnsafeCell::new(WyRand::new()));'), (13, 'pub struct TlsWyRand(Rc<UnsafeCell<WyRand>>);'), (15, 'impl Deref for TlsWyRand {'), (16, '\\ttype Target = WyRand;'), (20, '\\tfn deref(&self) -> &Self::Target {'), (21, '\\t\\tunsafe { &*self.0.get() }'), (23, '}'), (25, 'impl DerefMut for TlsWyRand {'), (28, '\\tfn deref_mut(&mut self) -> &mut Self::Target {'), (29, '\\t\\tunsafe { &mut *(*self.0).get() }')]}",
    "num_lines_added": "14",
    "num_lines_deleted": "16",
    "nloc": "23"
  },
  {
    "file_change_id": "195857744847363",
    "hash": "1660818b60832fdf58b982a37d81f5ef10abe0be",
    "old_path": "build/cg/struct.rs",
    "new_path": "build/cg/struct.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1459,27 +1459,71 @@ impl CodeGen {\n                     if let Some(doc) = doc {\n                         doc.emit(out, 1)?;\n                     }\n-                    writeln!(out, \"    pub fn {}(&self{}) -> &str {{\", name, params)?;\n+                    // String returned from X may not be valid utf-8.\n+                    // To overcome this, we provide two methods:\n+                    //   - one that returns Result<&str, Utf8Error>\n+                    //   - one that returns &[u8]\n+                    // see rust-xcb#96\n+                    writeln!(\n+                        out,\n+                        \"{}pub fn {}(&self{}) -> Result<&str, std::str::Utf8Error> {{\",\n+                        cg::ind(1),\n+                        name,\n+                        params\n+                    )?;\n \n-                    writeln!(out, \"        unsafe {{\")?;\n+                    writeln!(out, \"{}unsafe {{\", cg::ind(2))?;\n                     writeln!(\n                         out,\n-                        \"            let offset = {};\",\n+                        \"{}let offset = {};\",\n+                        cg::ind(3),\n                         self.build_rs_expr(wire_off, \"self.\", \"()\", fields)\n                     )?;\n                     writeln!(\n                         out,\n-                        \"            let len = {} as _;\",\n+                        \"{}let len = {} as _;\",\n+                        cg::ind(3),\n                         self.build_rs_expr(len_expr, \"self.\", \"()\", fields)\n                     )?;\n-                    writeln!(out, \"            let ptr = self.wire_ptr().add(offset);\",)?;\n+                    writeln!(out, \"{}let ptr = self.wire_ptr().add(offset);\", cg::ind(3))?;\n                     writeln!(\n                         out,\n-                        \"            let utf8 = std::slice::from_raw_parts(ptr, len);\",\n+                        \"{}let raw = std::slice::from_raw_parts(ptr, len);\",\n+                        cg::ind(3)\n                     )?;\n-                    writeln!(out, \"            std::str::from_utf8(utf8).unwrap()\")?;\n-                    writeln!(out, \"        }}\")?;\n-                    writeln!(out, \"    }}\")?;\n+                    writeln!(out, \"{}std::str::from_utf8(raw)\", cg::ind(3))?;\n+                    writeln!(out, \"{}}}\", cg::ind(2))?;\n+                    writeln!(out, \"{}}}\", cg::ind(1))?;\n+\n+                    writeln!(out)?;\n+                    if let Some(doc) = doc {\n+                        doc.emit(out, 1)?;\n+                    }\n+                    writeln!(\n+                        out,\n+                        \"{}pub fn {}_raw(&self{}) -> &[u8] {{\",\n+                        cg::ind(1),\n+                        name,\n+                        params\n+                    )?;\n+\n+                    writeln!(out, \"{}unsafe {{\", cg::ind(2))?;\n+                    writeln!(\n+                        out,\n+                        \"{}let offset = {};\",\n+                        cg::ind(3),\n+                        self.build_rs_expr(wire_off, \"self.\", \"()\", fields)\n+                    )?;\n+                    writeln!(\n+                        out,\n+                        \"{}let len = {} as _;\",\n+                        cg::ind(3),\n+                        self.build_rs_expr(len_expr, \"self.\", \"()\", fields)\n+                    )?;\n+                    writeln!(out, \"{}let ptr = self.wire_ptr().add(offset);\", cg::ind(3))?;\n+                    writeln!(out, \"{}std::slice::from_raw_parts(ptr, len)\", cg::ind(3))?;\n+                    writeln!(out, \"{}}}\", cg::ind(2))?;\n+                    writeln!(out, \"{}}}\", cg::ind(1))?;\n                 }\n                 Field::List {\n                     name,\n",
    "diff_parsed": "{'added': [(1467, '                    writeln!('), (1468, '                        out,'), (1469, '                        \"{}pub fn {}(&self{}) -> Result<&str, std::str::Utf8Error> {{\",'), (1470, '                        cg::ind(1),'), (1471, '                        name,'), (1472, '                        params'), (1473, '                    )?;'), (1475, '                    writeln!(out, \"{}unsafe {{\", cg::ind(2))?;'), (1478, '                        \"{}let offset = {};\",'), (1479, '                        cg::ind(3),'), (1484, '                        \"{}let len = {} as _;\",'), (1485, '                        cg::ind(3),'), (1488, '                    writeln!(out, \"{}let ptr = self.wire_ptr().add(offset);\", cg::ind(3))?;'), (1491, '                        \"{}let raw = std::slice::from_raw_parts(ptr, len);\",'), (1492, '                        cg::ind(3)'), (1494, '                    writeln!(out, \"{}std::str::from_utf8(raw)\", cg::ind(3))?;'), (1495, '                    writeln!(out, \"{}}}\", cg::ind(2))?;'), (1496, '                    writeln!(out, \"{}}}\", cg::ind(1))?;'), (1498, '                    writeln!(out)?;'), (1499, '                    if let Some(doc) = doc {'), (1500, '                        doc.emit(out, 1)?;'), (1501, '                    }'), (1502, '                    writeln!('), (1503, '                        out,'), (1504, '                        \"{}pub fn {}_raw(&self{}) -> &[u8] {{\",'), (1505, '                        cg::ind(1),'), (1506, '                        name,'), (1507, '                        params'), (1508, '                    )?;'), (1510, '                    writeln!(out, \"{}unsafe {{\", cg::ind(2))?;'), (1511, '                    writeln!('), (1512, '                        out,'), (1513, '                        \"{}let offset = {};\",'), (1514, '                        cg::ind(3),'), (1515, '                        self.build_rs_expr(wire_off, \"self.\", \"()\", fields)'), (1516, '                    )?;'), (1517, '                    writeln!('), (1518, '                        out,'), (1519, '                        \"{}let len = {} as _;\",'), (1520, '                        cg::ind(3),'), (1521, '                        self.build_rs_expr(len_expr, \"self.\", \"()\", fields)'), (1522, '                    )?;'), (1523, '                    writeln!(out, \"{}let ptr = self.wire_ptr().add(offset);\", cg::ind(3))?;'), (1524, '                    writeln!(out, \"{}std::slice::from_raw_parts(ptr, len)\", cg::ind(3))?;'), (1525, '                    writeln!(out, \"{}}}\", cg::ind(2))?;'), (1526, '                    writeln!(out, \"{}}}\", cg::ind(1))?;')], 'deleted': [(1462, '                    writeln!(out, \"    pub fn {}(&self{}) -> &str {{\", name, params)?;'), (1464, '                    writeln!(out, \"        unsafe {{\")?;'), (1467, '                        \"            let offset = {};\",'), (1472, '                        \"            let len = {} as _;\",'), (1475, '                    writeln!(out, \"            let ptr = self.wire_ptr().add(offset);\",)?;'), (1478, '                        \"            let utf8 = std::slice::from_raw_parts(ptr, len);\",'), (1480, '                    writeln!(out, \"            std::str::from_utf8(utf8).unwrap()\")?;'), (1481, '                    writeln!(out, \"        }}\")?;'), (1482, '                    writeln!(out, \"    }}\")?;')]}",
    "num_lines_added": "46",
    "num_lines_deleted": "9",
    "nloc": "1818"
  },
  {
    "file_change_id": "276950250263273",
    "hash": "6299af0ab17f070a78b75367e14b9101c29ce475",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -134,8 +134,7 @@ impl<'a> Record<'a> {\n             return Err(Error::RecordTooShort(len));\n         }\n \n-        data.reserve(len - 5);\n-        unsafe { data.set_len(len) };\n+        data.resize(len, 0);\n         input.read_exact(&mut data[5..len])?;\n \n         let data_offset = misc::read_dec_5(&data[12..17])?;\n",
    "diff_parsed": "{'added': [(137, '        data.resize(len, 0);')], 'deleted': [(137, '        data.reserve(len - 5);'), (138, '        unsafe { data.set_len(len) };')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "2",
    "nloc": "1048"
  },
  {
    "file_change_id": "105743626409556",
    "hash": "0867ad5c15fa52b7af3fc840ee7a1e256c469942",
    "old_path": "src/proto/h1/role.rs",
    "new_path": "src/proto/h1/role.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -780,31 +780,44 @@ impl Client {\n \n impl Client {\n     fn set_length(head: &mut RequestHead, body: Option<BodyLength>) -> Encoder {\n-        if let Some(body) = body {\n-            let can_chunked = head.version == Version::HTTP_11\n-                && (head.subject.0 != Method::HEAD)\n-                && (head.subject.0 != Method::GET)\n-                && (head.subject.0 != Method::CONNECT);\n-            set_length(&mut head.headers, body, can_chunked)\n+        let body = if let Some(body) = body {\n+            body\n         } else {\n             head.headers.remove(header::TRANSFER_ENCODING);\n-            Encoder::length(0)\n-        }\n-    }\n-}\n+            return Encoder::length(0)\n+        };\n+\n+        // HTTP/1.0 doesn't know about chunked\n+        let can_chunked = head.version == Version::HTTP_11;\n+        let headers = &mut head.headers;\n+\n+        // If the user already set specific headers, we should respect them, regardless\n+        // of what the Payload knows about itself. They set them for a reason.\n \n-fn set_length(headers: &mut HeaderMap, body: BodyLength, can_chunked: bool) -> Encoder {\n-    // If the user already set specific headers, we should respect them, regardless\n-    // of what the Payload knows about itself. They set them for a reason.\n+        // Because of the borrow checker, we can't check the for an existing\n+        // Content-Length header while holding an `Entry` for the Transfer-Encoding\n+        // header, so unfortunately, we must do the check here, first.\n \n-    // Because of the borrow checker, we can't check the for an existing\n-    // Content-Length header while holding an `Entry` for the Transfer-Encoding\n-    // header, so unfortunately, we must do the check here, first.\n+        let existing_con_len = headers::content_length_parse_all(headers);\n+        let mut should_remove_con_len = false;\n \n-    let existing_con_len = headers::content_length_parse_all(headers);\n-    let mut should_remove_con_len = false;\n+        if !can_chunked {\n+            // Chunked isn't legal, so if it is set, we need to remove it.\n+            if headers.remove(header::TRANSFER_ENCODING).is_some() {\n+                trace!(\"removing illegal transfer-encoding header\");\n+            }\n+\n+            return if let Some(len) = existing_con_len {\n+                Encoder::length(len)\n+            } else if let BodyLength::Known(len) = body {\n+                set_content_length(headers, len)\n+            } else {\n+                // HTTP/1.0 client requests without a content-length\n+                // cannot have any body at all.\n+                Encoder::length(0)\n+            };\n+        }\n \n-    if can_chunked {\n         // If the user set a transfer-encoding, respect that. Let's just\n         // make sure `chunked` is the final encoding.\n         let encoder = match headers.entry(header::TRANSFER_ENCODING)\n@@ -840,9 +853,22 @@ fn set_length(headers: &mut HeaderMap, body: BodyLength, can_chunked: bool) -> E\n                 if let Some(len) = existing_con_len {\n                     Some(Encoder::length(len))\n                 } else if let BodyLength::Unknown = body {\n-                    should_remove_con_len = true;\n-                    te.insert(HeaderValue::from_static(\"chunked\"));\n-                    Some(Encoder::chunked())\n+                    // GET, HEAD, and CONNECT almost never have bodies.\n+                    //\n+                    // So instead of sending a \"chunked\" body with a 0-chunk,\n+                    // assume no body here. If you *must* send a body,\n+                    // set the headers explicitly.\n+                    match head.subject.0 {\n+                        Method::GET |\n+                        Method::HEAD |\n+                        Method::CONNECT => {\n+                            Some(Encoder::length(0))\n+                        },\n+                        _ => {\n+                            te.insert(HeaderValue::from_static(\"chunked\"));\n+                            Some(Encoder::chunked())\n+                        },\n+                    }\n                 } else {\n                     None\n                 }\n@@ -868,27 +894,6 @@ fn set_length(headers: &mut HeaderMap, body: BodyLength, can_chunked: bool) -> E\n         };\n \n         set_content_length(headers, len)\n-    } else {\n-        // Chunked isn't legal, so if it is set, we need to remove it.\n-        // Also, if it *is* set, then we shouldn't replace with a length,\n-        // since the user tried to imply there isn't a length.\n-        let encoder = if headers.remove(header::TRANSFER_ENCODING).is_some() {\n-            trace!(\"removing illegal transfer-encoding header\");\n-            should_remove_con_len = true;\n-            Encoder::close_delimited()\n-        } else if let Some(len) = existing_con_len {\n-            Encoder::length(len)\n-        } else if let BodyLength::Known(len) = body {\n-            set_content_length(headers, len)\n-        } else {\n-            Encoder::close_delimited()\n-        };\n-\n-        if should_remove_con_len && existing_con_len.is_some() {\n-            headers.remove(header::CONTENT_LENGTH);\n-        }\n-\n-        encoder\n     }\n }\n \n",
    "diff_parsed": "{'added': [(783, '        let body = if let Some(body) = body {'), (784, '            body'), (787, '            return Encoder::length(0)'), (788, '        };'), (791, '        let can_chunked = head.version == Version::HTTP_11;'), (792, '        let headers = &mut head.headers;'), (801, '        let existing_con_len = headers::content_length_parse_all(headers);'), (802, '        let mut should_remove_con_len = false;'), (804, '        if !can_chunked {'), (806, '            if headers.remove(header::TRANSFER_ENCODING).is_some() {'), (807, '                trace!(\"removing illegal transfer-encoding header\");'), (808, '            }'), (810, '            return if let Some(len) = existing_con_len {'), (811, '                Encoder::length(len)'), (812, '            } else if let BodyLength::Known(len) = body {'), (813, '                set_content_length(headers, len)'), (814, '            } else {'), (817, '                Encoder::length(0)'), (818, '            };'), (819, '        }'), (861, '                    match head.subject.0 {'), (862, '                        Method::GET |'), (863, '                        Method::HEAD |'), (864, '                        Method::CONNECT => {'), (865, '                            Some(Encoder::length(0))'), (866, '                        },'), (867, '                        _ => {'), (868, '                            te.insert(HeaderValue::from_static(\"chunked\"));'), (869, '                            Some(Encoder::chunked())'), (870, '                        },'), (871, '                    }')], 'deleted': [(783, '        if let Some(body) = body {'), (784, '            let can_chunked = head.version == Version::HTTP_11'), (785, '                && (head.subject.0 != Method::HEAD)'), (786, '                && (head.subject.0 != Method::GET)'), (787, '                && (head.subject.0 != Method::CONNECT);'), (788, '            set_length(&mut head.headers, body, can_chunked)'), (791, '            Encoder::length(0)'), (792, '        }'), (793, '    }'), (794, '}'), (796, 'fn set_length(headers: &mut HeaderMap, body: BodyLength, can_chunked: bool) -> Encoder {'), (804, '    let existing_con_len = headers::content_length_parse_all(headers);'), (805, '    let mut should_remove_con_len = false;'), (807, '    if can_chunked {'), (843, '                    should_remove_con_len = true;'), (844, '                    te.insert(HeaderValue::from_static(\"chunked\"));'), (845, '                    Some(Encoder::chunked())'), (871, '    } else {'), (875, '        let encoder = if headers.remove(header::TRANSFER_ENCODING).is_some() {'), (876, '            trace!(\"removing illegal transfer-encoding header\");'), (877, '            should_remove_con_len = true;'), (878, '            Encoder::close_delimited()'), (879, '        } else if let Some(len) = existing_con_len {'), (880, '            Encoder::length(len)'), (881, '        } else if let BodyLength::Known(len) = body {'), (882, '            set_content_length(headers, len)'), (883, '        } else {'), (884, '            Encoder::close_delimited()'), (885, '        };'), (887, '        if should_remove_con_len && existing_con_len.is_some() {'), (888, '            headers.remove(header::CONTENT_LENGTH);'), (889, '        }'), (891, '        encoder')]}",
    "num_lines_added": "31",
    "num_lines_deleted": "33",
    "nloc": "1341"
  },
  {
    "file_change_id": "241713514247428",
    "hash": "0867ad5c15fa52b7af3fc840ee7a1e256c469942",
    "old_path": "tests/client.rs",
    "new_path": "tests/client.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -353,7 +353,7 @@ test! {\n }\n \n test! {\n-    name: client_get_implicitly_empty,\n+    name: client_get_req_body_implicitly_empty,\n \n     server:\n         expected: \"GET / HTTP/1.1\\r\\nhost: {addr}\\r\\n\\r\\n\",\n@@ -367,9 +367,153 @@ test! {\n         },\n         response:\n             status: OK,\n+            headers: {},\n+            body: None,\n+}\n+\n+test! {\n+    name: client_get_req_body_chunked,\n+\n+    server:\n+        expected: \"\\\n+            GET / HTTP/1.1\\r\\n\\\n+            transfer-encoding: chunked\\r\\n\\\n+            host: {addr}\\r\\n\\\n+            \\r\\n\\\n+            5\\r\\n\\\n+            hello\\r\\n\\\n+            0\\r\\n\\r\\n\\\n+            \",\n+        reply: REPLY_OK,\n+\n+    client:\n+        request: {\n+            method: GET,\n+            url: \"http://{addr}/\",\n             headers: {\n-                \"Content-Length\" => \"0\",\n+                \"transfer-encoding\" => \"chunked\",\n+            },\n+            body: \"hello\", // not Body::empty\n+        },\n+        response:\n+            status: OK,\n+            headers: {},\n+            body: None,\n+}\n+\n+test! {\n+    name: client_get_req_body_chunked_http10,\n+\n+    server:\n+        expected: \"\\\n+            GET / HTTP/1.0\\r\\n\\\n+            host: {addr}\\r\\n\\\n+            content-length: 5\\r\\n\\\n+            \\r\\n\\\n+            hello\\\n+            \",\n+        reply: \"HTTP/1.0 200 OK\\r\\ncontent-length: 0\\r\\n\\r\\n\",\n+\n+    client:\n+        request: {\n+            method: GET,\n+            url: \"http://{addr}/\",\n+            headers: {\n+                \"transfer-encoding\" => \"chunked\",\n+            },\n+            version: HTTP_10,\n+            body: \"hello\",\n+        },\n+        response:\n+            status: OK,\n+            headers: {},\n+            body: None,\n+}\n+\n+test! {\n+    name: client_get_req_body_sized,\n+\n+    server:\n+        expected: \"\\\n+            GET / HTTP/1.1\\r\\n\\\n+            content-length: 5\\r\\n\\\n+            host: {addr}\\r\\n\\\n+            \\r\\n\\\n+            hello\\\n+            \",\n+        reply: REPLY_OK,\n+\n+    client:\n+        request: {\n+            method: GET,\n+            url: \"http://{addr}/\",\n+            headers: {\n+                \"Content-Length\" => \"5\",\n+            },\n+            body: (Body::wrap_stream(Body::from(\"hello\"))),\n+        },\n+        response:\n+            status: OK,\n+            headers: {},\n+            body: None,\n+}\n+\n+test! {\n+    name: client_get_req_body_unknown,\n+\n+    server:\n+        expected: \"\\\n+            GET / HTTP/1.1\\r\\n\\\n+            host: {addr}\\r\\n\\\n+            \\r\\n\\\n+            \",\n+        reply: REPLY_OK,\n+\n+    client:\n+        request: {\n+            method: GET,\n+            url: \"http://{addr}/\",\n+            // wrap_steam means we don't know the content-length,\n+            // but we're wrapping a non-empty stream.\n+            //\n+            // But since the headers cannot tell us, and the method typically\n+            // doesn't have a body, the body must be ignored.\n+            body: (Body::wrap_stream(Body::from(\"hello\"))),\n+        },\n+        response:\n+            status: OK,\n+            headers: {},\n+            body: None,\n+}\n+\n+test! {\n+    name: client_get_req_body_unknown_http10,\n+\n+    server:\n+        expected: \"\\\n+            GET / HTTP/1.0\\r\\n\\\n+            host: {addr}\\r\\n\\\n+            \\r\\n\\\n+            \",\n+        reply: \"HTTP/1.0 200 OK\\r\\ncontent-length: 0\\r\\n\\r\\n\",\n+\n+    client:\n+        request: {\n+            method: GET,\n+            url: \"http://{addr}/\",\n+            headers: {\n+                \"transfer-encoding\" => \"chunked\",\n             },\n+            version: HTTP_10,\n+            // wrap_steam means we don't know the content-length,\n+            // but we're wrapping a non-empty stream.\n+            //\n+            // But since the headers cannot tell us, the body must be ignored.\n+            body: (Body::wrap_stream(Body::from(\"hello\"))),\n+        },\n+        response:\n+            status: OK,\n+            headers: {},\n             body: None,\n }\n \n@@ -431,6 +575,33 @@ test! {\n             body: None,\n }\n \n+test! {\n+    name: client_post_unknown,\n+\n+    server:\n+        expected: \"\\\n+            POST /chunks HTTP/1.1\\r\\n\\\n+            host: {addr}\\r\\n\\\n+            transfer-encoding: chunked\\r\\n\\\n+            \\r\\n\\\n+            B\\r\\n\\\n+            foo bar baz\\r\\n\\\n+            0\\r\\n\\r\\n\\\n+            \",\n+        reply: REPLY_OK,\n+\n+    client:\n+        request: {\n+            method: POST,\n+            url: \"http://{addr}/chunks\",\n+            body: (Body::wrap_stream(Body::from(\"foo bar baz\"))),\n+        },\n+        response:\n+            status: OK,\n+            headers: {},\n+            body: None,\n+}\n+\n test! {\n     name: client_post_empty,\n \n",
    "diff_parsed": "{'added': [(356, '    name: client_get_req_body_implicitly_empty,'), (370, '            headers: {},'), (371, '            body: None,'), (372, '}'), (374, 'test! {'), (375, '    name: client_get_req_body_chunked,'), (377, '    server:'), (378, '        expected: \"\\\\'), (379, '            GET / HTTP/1.1\\\\r\\\\n\\\\'), (380, '            transfer-encoding: chunked\\\\r\\\\n\\\\'), (381, '            host: {addr}\\\\r\\\\n\\\\'), (382, '            \\\\r\\\\n\\\\'), (383, '            5\\\\r\\\\n\\\\'), (384, '            hello\\\\r\\\\n\\\\'), (385, '            0\\\\r\\\\n\\\\r\\\\n\\\\'), (386, '            \",'), (387, '        reply: REPLY_OK,'), (389, '    client:'), (390, '        request: {'), (391, '            method: GET,'), (392, '            url: \"http://{addr}/\",'), (394, '                \"transfer-encoding\" => \"chunked\",'), (395, '            },'), (396, '            body: \"hello\", // not Body::empty'), (397, '        },'), (398, '        response:'), (399, '            status: OK,'), (400, '            headers: {},'), (401, '            body: None,'), (402, '}'), (404, 'test! {'), (405, '    name: client_get_req_body_chunked_http10,'), (407, '    server:'), (408, '        expected: \"\\\\'), (409, '            GET / HTTP/1.0\\\\r\\\\n\\\\'), (410, '            host: {addr}\\\\r\\\\n\\\\'), (411, '            content-length: 5\\\\r\\\\n\\\\'), (412, '            \\\\r\\\\n\\\\'), (413, '            hello\\\\'), (414, '            \",'), (415, '        reply: \"HTTP/1.0 200 OK\\\\r\\\\ncontent-length: 0\\\\r\\\\n\\\\r\\\\n\",'), (417, '    client:'), (418, '        request: {'), (419, '            method: GET,'), (420, '            url: \"http://{addr}/\",'), (421, '            headers: {'), (422, '                \"transfer-encoding\" => \"chunked\",'), (423, '            },'), (424, '            version: HTTP_10,'), (425, '            body: \"hello\",'), (426, '        },'), (427, '        response:'), (428, '            status: OK,'), (429, '            headers: {},'), (430, '            body: None,'), (431, '}'), (433, 'test! {'), (434, '    name: client_get_req_body_sized,'), (436, '    server:'), (437, '        expected: \"\\\\'), (438, '            GET / HTTP/1.1\\\\r\\\\n\\\\'), (439, '            content-length: 5\\\\r\\\\n\\\\'), (440, '            host: {addr}\\\\r\\\\n\\\\'), (441, '            \\\\r\\\\n\\\\'), (442, '            hello\\\\'), (443, '            \",'), (444, '        reply: REPLY_OK,'), (446, '    client:'), (447, '        request: {'), (448, '            method: GET,'), (449, '            url: \"http://{addr}/\",'), (450, '            headers: {'), (451, '                \"Content-Length\" => \"5\",'), (452, '            },'), (453, '            body: (Body::wrap_stream(Body::from(\"hello\"))),'), (454, '        },'), (455, '        response:'), (456, '            status: OK,'), (457, '            headers: {},'), (458, '            body: None,'), (459, '}'), (461, 'test! {'), (462, '    name: client_get_req_body_unknown,'), (464, '    server:'), (465, '        expected: \"\\\\'), (466, '            GET / HTTP/1.1\\\\r\\\\n\\\\'), (467, '            host: {addr}\\\\r\\\\n\\\\'), (468, '            \\\\r\\\\n\\\\'), (469, '            \",'), (470, '        reply: REPLY_OK,'), (472, '    client:'), (473, '        request: {'), (474, '            method: GET,'), (475, '            url: \"http://{addr}/\",'), (481, '            body: (Body::wrap_stream(Body::from(\"hello\"))),'), (482, '        },'), (483, '        response:'), (484, '            status: OK,'), (485, '            headers: {},'), (486, '            body: None,'), (487, '}'), (489, 'test! {'), (490, '    name: client_get_req_body_unknown_http10,'), (492, '    server:'), (493, '        expected: \"\\\\'), (494, '            GET / HTTP/1.0\\\\r\\\\n\\\\'), (495, '            host: {addr}\\\\r\\\\n\\\\'), (496, '            \\\\r\\\\n\\\\'), (497, '            \",'), (498, '        reply: \"HTTP/1.0 200 OK\\\\r\\\\ncontent-length: 0\\\\r\\\\n\\\\r\\\\n\",'), (500, '    client:'), (501, '        request: {'), (502, '            method: GET,'), (503, '            url: \"http://{addr}/\",'), (504, '            headers: {'), (505, '                \"transfer-encoding\" => \"chunked\",'), (507, '            version: HTTP_10,'), (512, '            body: (Body::wrap_stream(Body::from(\"hello\"))),'), (513, '        },'), (514, '        response:'), (515, '            status: OK,'), (516, '            headers: {},'), (578, 'test! {'), (579, '    name: client_post_unknown,'), (581, '    server:'), (582, '        expected: \"\\\\'), (583, '            POST /chunks HTTP/1.1\\\\r\\\\n\\\\'), (584, '            host: {addr}\\\\r\\\\n\\\\'), (585, '            transfer-encoding: chunked\\\\r\\\\n\\\\'), (586, '            \\\\r\\\\n\\\\'), (587, '            B\\\\r\\\\n\\\\'), (588, '            foo bar baz\\\\r\\\\n\\\\'), (589, '            0\\\\r\\\\n\\\\r\\\\n\\\\'), (590, '            \",'), (591, '        reply: REPLY_OK,'), (593, '    client:'), (594, '        request: {'), (595, '            method: POST,'), (596, '            url: \"http://{addr}/chunks\",'), (597, '            body: (Body::wrap_stream(Body::from(\"foo bar baz\"))),'), (598, '        },'), (599, '        response:'), (600, '            status: OK,'), (601, '            headers: {},'), (602, '            body: None,'), (603, '}')], 'deleted': [(356, '    name: client_get_implicitly_empty,'), (371, '                \"Content-Length\" => \"0\",')]}",
    "num_lines_added": "146",
    "num_lines_deleted": "2",
    "nloc": "1942"
  },
  {
    "file_change_id": "237434606590748",
    "hash": "6dd7ca0d50f2464df708975cdafcfaeeb6d41c66",
    "old_path": "src/aref.rs",
    "new_path": "src/aref.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -516,7 +516,7 @@ impl<'a, U: ?Sized> ARefs<'a, U> {\n     /// assert_eq!(*aref.map(|s| &s[1]), 5);\n     /// ```\n     #[inline]\n-    pub fn map<V: ?Sized, F: FnOnce(&U) -> &V>(self, f: F) -> ARefs<'a, V> { ARefs(self.0.map(f)) }\n+    pub fn map<V: ?Sized + Send, F: FnOnce(&U) -> &V>(self, f: F) -> ARefs<'a, V> { ARefs(self.0.map(f)) }\n \n     /// Like map, but with Result passthrough.\n     ///\n@@ -528,11 +528,11 @@ impl<'a, U: ?Sized> ARefs<'a, U> {\n     /// assert_eq!(aref.try_map(|s| s.get(9).ok_or(())), Err(()));\n     /// ```\n     #[inline]\n-    pub fn try_map<E, V: ?Sized, F: FnOnce(&U) -> Result<&V, E>>(self, f: F) -> Result<ARefs<'a, V>, E> {\n+    pub fn try_map<E, V: ?Sized + Send, F: FnOnce(&U) -> Result<&V, E>>(self, f: F) -> Result<ARefs<'a, V>, E> {\n         self.0.try_map(f).map(|z| ARefs(z))\n     }\n \n-    /// Removes the type information that this struct is Send + Sync.\n+    /// Removes the type information that this struct is Send.\n     #[inline]\n     pub fn into_aref(self) -> ARef<'a, U> { self.0 }\n }\n@@ -564,7 +564,7 @@ impl<'a, U: ?Sized> ARefss<'a, U> {\n     /// assert_eq!(*aref.map(|s| &s[1]), 5);\n     /// ```\n     #[inline]\n-    pub fn map<V: ?Sized, F: FnOnce(&U) -> &V>(self, f: F) -> ARefss<'a, V> { ARefss(self.0.map(f)) }\n+    pub fn map<V: ?Sized + Send + Sync, F: FnOnce(&U) -> &V>(self, f: F) -> ARefss<'a, V> { ARefss(self.0.map(f)) }\n \n     /// Like map, but with Result passthrough.\n     ///\n@@ -576,7 +576,7 @@ impl<'a, U: ?Sized> ARefss<'a, U> {\n     /// assert_eq!(aref.try_map(|s| s.get(9).ok_or(())), Err(()));\n     /// ```\n     #[inline]\n-    pub fn try_map<E, V: ?Sized, F: FnOnce(&U) -> Result<&V, E>>(self, f: F) -> Result<ARefss<'a, V>, E> {\n+    pub fn try_map<E, V: ?Sized + Send + Sync, F: FnOnce(&U) -> Result<&V, E>>(self, f: F) -> Result<ARefss<'a, V>, E> {\n         self.0.try_map(f).map(|z| ARefss(z))\n     }\n \n",
    "diff_parsed": "{'added': [(519, \"    pub fn map<V: ?Sized + Send, F: FnOnce(&U) -> &V>(self, f: F) -> ARefs<'a, V> { ARefs(self.0.map(f)) }\"), (531, \"    pub fn try_map<E, V: ?Sized + Send, F: FnOnce(&U) -> Result<&V, E>>(self, f: F) -> Result<ARefs<'a, V>, E> {\"), (567, \"    pub fn map<V: ?Sized + Send + Sync, F: FnOnce(&U) -> &V>(self, f: F) -> ARefss<'a, V> { ARefss(self.0.map(f)) }\"), (579, \"    pub fn try_map<E, V: ?Sized + Send + Sync, F: FnOnce(&U) -> Result<&V, E>>(self, f: F) -> Result<ARefss<'a, V>, E> {\")], 'deleted': [(519, \"    pub fn map<V: ?Sized, F: FnOnce(&U) -> &V>(self, f: F) -> ARefs<'a, V> { ARefs(self.0.map(f)) }\"), (531, \"    pub fn try_map<E, V: ?Sized, F: FnOnce(&U) -> Result<&V, E>>(self, f: F) -> Result<ARefs<'a, V>, E> {\"), (567, \"    pub fn map<V: ?Sized, F: FnOnce(&U) -> &V>(self, f: F) -> ARefss<'a, V> { ARefss(self.0.map(f)) }\"), (579, \"    pub fn try_map<E, V: ?Sized, F: FnOnce(&U) -> Result<&V, E>>(self, f: F) -> Result<ARefss<'a, V>, E> {\")]}",
    "num_lines_added": "4",
    "num_lines_deleted": "4",
    "nloc": "532"
  },
  {
    "file_change_id": "273036382940312",
    "hash": "dbc7ab1c739667eb26aace1b9a6795192ed4a805",
    "old_path": "src/der/value.rs",
    "new_path": "src/der/value.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -12,13 +12,10 @@ impl DerValue {\n \tpub fn deserialize<'a>(mut source: impl Iterator<Item = &'a u8>, len: impl Into<usize>)\n \t\t-> Result<Self, Asn1DerError>\n \t{\n-\t\t// Create buffer\n-\t\tlet len = len.into();\n-\t\tlet mut data_buf = vec![0u8; len];\n-\t\t\n-\t\t// Copy data into buffer\n-\t\tfor b in data_buf.iter_mut() {\n-\t\t\t*b = *source.next().ok_or(Asn1DerError::LengthMismatch)?;\n+\t\t// Create buffer and fill it with `len` bytes\n+\t\tlet mut data_buf = Vec::new();\n+\t\tfor _ in 0..len.into() {\n+\t\t\tdata_buf.push(*source.next().ok_or(Asn1DerError::LengthMismatch)?);\n \t\t}\n \t\tOk(data_buf.into())\n \t}\n",
    "diff_parsed": "{'added': [(16, '\\t\\tlet mut data_buf = Vec::new();'), (17, '\\t\\tfor _ in 0..len.into() {'), (18, '\\t\\t\\tdata_buf.push(*source.next().ok_or(Asn1DerError::LengthMismatch)?);')], 'deleted': [(16, '\\t\\tlet len = len.into();'), (17, '\\t\\tlet mut data_buf = vec![0u8; len];'), (20, '\\t\\tfor b in data_buf.iter_mut() {'), (21, '\\t\\t\\t*b = *source.next().ok_or(Asn1DerError::LengthMismatch)?;')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "4",
    "nloc": "40"
  },
  {
    "file_change_id": "40071568367011",
    "hash": "dbc7ab1c739667eb26aace1b9a6795192ed4a805",
    "old_path": "tests/der.rs",
    "new_path": "tests/der.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -63,6 +63,8 @@ fn test_err() {\n \t\t// Incomplete value\n \t\t(b\"\\x0c\\x09\\x54\\x65\\x73\\x74\\x6F\\x6C\\x6F\\x70\".as_ref(), Asn1DerError::LengthMismatch),\n \t\t// Complex length > 2^64 - 1\n-\t\t(b\"\\x77\\x89\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\".as_ref(), Asn1DerError::Unsupported)\n+\t\t(b\"\\x77\\x89\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\".as_ref(), Asn1DerError::Unsupported),\n+\t\t// Excessive length announcement\n+\t\t(b\"\\x9d\\xf7\\x9d\\x9d\\x9d\\x9d\\x9d\\x9d\\x9d\\x9d\\x9d\\x9d\\x9d\\x9d\\x9d\\x43\\x9d\\x01\\x00\\x00\\x00\\x9d\\x9d\\x9d\\x9d\\x9d\\x9d\\x9d\\x9d\".as_ref(), Asn1DerError::LengthMismatch)\n \t].iter().for_each(test);\n }\n\\ No newline at end of file\n",
    "diff_parsed": "{'added': [(66, '\\t\\t(b\"\\\\x77\\\\x89\\\\x01\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\".as_ref(), Asn1DerError::Unsupported),'), (68, '\\t\\t(b\"\\\\x9d\\\\xf7\\\\x9d\\\\x9d\\\\x9d\\\\x9d\\\\x9d\\\\x9d\\\\x9d\\\\x9d\\\\x9d\\\\x9d\\\\x9d\\\\x9d\\\\x9d\\\\x43\\\\x9d\\\\x01\\\\x00\\\\x00\\\\x00\\\\x9d\\\\x9d\\\\x9d\\\\x9d\\\\x9d\\\\x9d\\\\x9d\\\\x9d\".as_ref(), Asn1DerError::LengthMismatch)')], 'deleted': [(66, '\\t\\t(b\"\\\\x77\\\\x89\\\\x01\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\".as_ref(), Asn1DerError::Unsupported)')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "1",
    "nloc": "46"
  },
  {
    "file_change_id": "253071999671139",
    "hash": "3199bd8623d05341b4047f53e143ae67d7d9f064",
    "old_path": "buttplug/src/util/future.rs",
    "new_path": "buttplug/src/util/future.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -85,9 +85,9 @@ pub struct ButtplugFutureStateShared<T> {\n   state: Arc<Mutex<ButtplugFutureState<T>>>,\n }\n \n-unsafe impl<T> Sync for ButtplugFutureStateShared<T> {\n+unsafe impl<T: Sync> Sync for ButtplugFutureStateShared<T> {\n }\n-unsafe impl<T> Send for ButtplugFutureStateShared<T> {\n+unsafe impl<T: Send> Send for ButtplugFutureStateShared<T> {\n }\n \n impl<T> ButtplugFutureStateShared<T> {\n",
    "diff_parsed": "{'added': [(88, 'unsafe impl<T: Sync> Sync for ButtplugFutureStateShared<T> {'), (90, 'unsafe impl<T: Send> Send for ButtplugFutureStateShared<T> {')], 'deleted': [(88, 'unsafe impl<T> Sync for ButtplugFutureStateShared<T> {'), (90, 'unsafe impl<T> Send for ButtplugFutureStateShared<T> {')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "95"
  },
  {
    "file_change_id": "240963572866228",
    "hash": "2928a87a0c9f86c46ba70f8c8058d9b7b10a241d",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -146,8 +146,8 @@ impl<T> Clone for Intern<T> {\n /// because we never free the data pointed to by an `Intern`.\n impl<T> Copy for Intern<T> {}\n \n-unsafe impl<T> Send for Intern<T> {}\n-unsafe impl<T> Sync for Intern<T> {}\n+unsafe impl<T: Send> Send for Intern<T> {}\n+unsafe impl<T: Sync> Sync for Intern<T> {}\n \n impl<T: Eq + Hash + Send + 'static> Intern<T> {\n     fn get_mutex() -> &'static Mutex<HashSet<Box<T>>> {\n",
    "diff_parsed": "{'added': [(149, 'unsafe impl<T: Send> Send for Intern<T> {}'), (150, 'unsafe impl<T: Sync> Sync for Intern<T> {}')], 'deleted': [(149, 'unsafe impl<T> Send for Intern<T> {}'), (150, 'unsafe impl<T> Sync for Intern<T> {}')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "724"
  },
  {
    "file_change_id": "56955928846367",
    "hash": "8e970aaa60471a845a309c0fe82ebe59779341ca",
    "old_path": "src/generic.rs",
    "new_path": "src/generic.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -527,5 +527,6 @@ where\n     }\n }\n \n+// Safety: Same bounds as `std::borrow::Cow`.\n unsafe impl<T: Beef + Sync + ?Sized, U: Capacity> Sync for Cow<'_, T, U> {}\n-unsafe impl<T: Beef + Send + ?Sized, U: Capacity> Send for Cow<'_, T, U> {}\n+unsafe impl<T: Beef + Send + Sync + ?Sized, U: Capacity> Send for Cow<'_, T, U> {}\n",
    "diff_parsed": "{'added': [(532, \"unsafe impl<T: Beef + Send + Sync + ?Sized, U: Capacity> Send for Cow<'_, T, U> {}\")], 'deleted': [(531, \"unsafe impl<T: Beef + Send + ?Sized, U: Capacity> Send for Cow<'_, T, U> {}\")]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "419"
  },
  {
    "file_change_id": "78298857363034",
    "hash": "cdff034e6d93cdfdafd13d8c6956e22fa5a57b79",
    "old_path": "crates/xdv/src/lib.rs",
    "new_path": "crates/xdv/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -221,10 +221,9 @@ impl<T: XdvEvents> XdvParser<T> {\n     {\n         const BUF_SIZE: usize = 4096;\n         let mut parser = Self::new(events);\n-        let mut buf = Vec::with_capacity(BUF_SIZE);\n-        unsafe {\n-            buf.set_len(BUF_SIZE);\n-        }\n+        // Note that it is unsound to pass uninitialized data to a read() call,\n+        // even though it *should* never cause problems ...\n+        let mut buf = vec![0; BUF_SIZE];\n         let mut n_saved_bytes = 0;\n \n         loop {\n",
    "diff_parsed": "{'added': [(226, '        let mut buf = vec![0; BUF_SIZE];')], 'deleted': [(224, '        let mut buf = Vec::with_capacity(BUF_SIZE);'), (225, '        unsafe {'), (226, '            buf.set_len(BUF_SIZE);'), (227, '        }')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "4",
    "nloc": "869"
  },
  {
    "file_change_id": "236817257362352",
    "hash": "599313b39c249ee89144c69eb09da0f56d579922",
    "old_path": "src/read.rs",
    "new_path": "src/read.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -17,12 +17,9 @@ impl<R: io::Read> IoReader<R> {\n \n impl<R: io::Read> BufReadExact for IoReader<R> {\n     fn buf_read_exact(&mut self, len: usize) -> io::Result<&[u8]> {\n-        unsafe {\n-            self.buf.reserve(len);\n-            let slice = self.buf.get_unchecked_mut(..len);\n-            self.rdr.read_exact(slice)?;\n-            Ok(slice)\n-        }\n+        self.buf.resize(len, 0);\n+        self.rdr.read_exact(self.buf.as_mut_slice())?;\n+        Ok(self.buf.as_slice())\n     }\n }\n \n",
    "diff_parsed": "{'added': [(20, '        self.buf.resize(len, 0);'), (21, '        self.rdr.read_exact(self.buf.as_mut_slice())?;'), (22, '        Ok(self.buf.as_slice())')], 'deleted': [(20, '        unsafe {'), (21, '            self.buf.reserve(len);'), (22, '            let slice = self.buf.get_unchecked_mut(..len);'), (23, '            self.rdr.read_exact(slice)?;'), (24, '            Ok(slice)'), (25, '        }')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "6",
    "nloc": "39"
  },
  {
    "file_change_id": "58951199972655",
    "hash": "291fca7dbfb2e3fe235180b41ce9e845ef0b2895",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -319,14 +319,9 @@ impl<A> State<A> {\n         let start_ptr = self.tip.as_mut_ptr()\n                                 .offset(self.tip.len_items() as isize);\n \n-        let padding = start_ptr as usize % alignment;\n-\n-        debug_assert!(padding < alignment);\n-        debug_assert_eq!(padding, 0);\n-\n+        let padding = (alignment - (start_ptr as usize % alignment)) % alignment;\n         let start_ptr = start_ptr.offset(AlignedVec::<A>::bytes_to_items(padding) as isize);\n-\n-        let new_used = self.tip.len_items() + padding + AlignedVec::<A>::bytes_to_items(size);\n+        let new_used = self.tip.len_items() + AlignedVec::<A>::bytes_to_items(padding + size);\n \n         if new_used <= self.tip.capacity_items() {\n             self.tip.set_len_items(new_used);\n",
    "diff_parsed": "{'added': [(322, '        let padding = (alignment - (start_ptr as usize % alignment)) % alignment;'), (324, '        let new_used = self.tip.len_items() + AlignedVec::<A>::bytes_to_items(padding + size);')], 'deleted': [(322, '        let padding = start_ptr as usize % alignment;'), (324, '        debug_assert!(padding < alignment);'), (325, '        debug_assert_eq!(padding, 0);'), (329, '        let new_used = self.tip.len_items() + padding + AlignedVec::<A>::bytes_to_items(size);')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "4",
    "nloc": "448"
  },
  {
    "file_change_id": "202478937133579",
    "hash": "936ab41a87d2b4876e09efc43864faf591dc0c2c",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -712,16 +712,13 @@ impl VendorInfo {\n     /// Return vendor identification as human readable string.\n     pub fn as_string<'a>(&'a self) -> &'a str {\n         let brand_string_start = self as *const VendorInfo as *const u8;\n-        unsafe {\n+        let slice = unsafe {\n             // Safety: VendorInfo is laid out with repr(C) and exactly\n             // 12 byte long without any padding.\n-            let slice: &'a [u8] =\n-                slice::from_raw_parts(brand_string_start, size_of::<VendorInfo>());\n-            // Safety: The field is specified to be ASCII, and the only safe\n-            // way to construct VendorInfo is from real CPUID data or the\n-            // Default implementation.\n-            str::from_utf8_unchecked(slice)\n-        }\n+            slice::from_raw_parts(brand_string_start, size_of::<VendorInfo>())\n+        };\n+\n+        str::from_utf8(slice).unwrap_or(\"InvalidVendorString\")\n     }\n }\n \n@@ -4193,15 +4190,11 @@ pub struct SoCVendorBrand {\n impl SoCVendorBrand {\n     pub fn as_string<'a>(&'a self) -> &'a str {\n         let brand_string_start = self as *const SoCVendorBrand as *const u8;\n-        unsafe {\n+        let slice = unsafe {\n             // Safety: SoCVendorBrand is laid out with repr(C).\n-            let slice: &'a [u8] =\n-                slice::from_raw_parts(brand_string_start, size_of::<SoCVendorBrand>());\n-            // Safety: The field is specified to be ASCII, and the only safe\n-            // way to construct SoCVendorBrand is from real CPUID data or the\n-            // Default implementation.\n-            str::from_utf8_unchecked(slice)\n-        }\n+            slice::from_raw_parts(brand_string_start, size_of::<SoCVendorBrand>())\n+        };\n+        str::from_utf8(slice).unwrap_or(\"InvalidSoCVendorString\")\n     }\n }\n \n@@ -4329,10 +4322,7 @@ impl ExtendedFunctionInfo {\n             // Brand terminated at nul byte or end, whichever comes first.\n             let slice = slice.split(|&x| x == 0).next().unwrap();\n \n-            // Safety: Field is specified to be ASCII, and the only safe way\n-            // to construct ExtendedFunctionInfo is from real CPUID data\n-            // or the Default implementation.\n-            Some(unsafe { str::from_utf8_unchecked(slice) })\n+            str::from_utf8(slice).ok()\n         } else {\n             None\n         }\n",
    "diff_parsed": "{'added': [(715, '        let slice = unsafe {'), (718, '            slice::from_raw_parts(brand_string_start, size_of::<VendorInfo>())'), (719, '        };'), (721, '        str::from_utf8(slice).unwrap_or(\"InvalidVendorString\")'), (4193, '        let slice = unsafe {'), (4195, '            slice::from_raw_parts(brand_string_start, size_of::<SoCVendorBrand>())'), (4196, '        };'), (4197, '        str::from_utf8(slice).unwrap_or(\"InvalidSoCVendorString\")'), (4325, '            str::from_utf8(slice).ok()')], 'deleted': [(715, '        unsafe {'), (718, \"            let slice: &'a [u8] =\"), (719, '                slice::from_raw_parts(brand_string_start, size_of::<VendorInfo>());'), (723, '            str::from_utf8_unchecked(slice)'), (724, '        }'), (4196, '        unsafe {'), (4198, \"            let slice: &'a [u8] =\"), (4199, '                slice::from_raw_parts(brand_string_start, size_of::<SoCVendorBrand>());'), (4203, '            str::from_utf8_unchecked(slice)'), (4204, '        }'), (4335, '            Some(unsafe { str::from_utf8_unchecked(slice) })')]}",
    "num_lines_added": "9",
    "num_lines_deleted": "11",
    "nloc": "3679"
  },
  {
    "file_change_id": "62614979905666",
    "hash": "229d1a8d41b0023420e7815578fa0b39c0d5c2e4",
    "old_path": "crates/cli/src/decompress.rs",
    "new_path": "crates/cli/src/decompress.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,7 +1,7 @@\n use std::ffi::{OsStr, OsString};\n use std::fs::File;\n use std::io;\n-use std::path::Path;\n+use std::path::{Path, PathBuf};\n use std::process::Command;\n \n use globset::{Glob, GlobSet, GlobSetBuilder};\n@@ -24,7 +24,7 @@ struct DecompressionCommand {\n     /// The glob that matches this command.\n     glob: String,\n     /// The command or binary name.\n-    bin: OsString,\n+    bin: PathBuf,\n     /// The arguments to invoke with the command.\n     args: Vec<OsString>,\n }\n@@ -83,23 +83,60 @@ impl DecompressionMatcherBuilder {\n     ///\n     /// The syntax for the glob is documented in the\n     /// [`globset` crate](https://docs.rs/globset/#syntax).\n+    ///\n+    /// The `program` given is resolved with respect to `PATH` and turned\n+    /// into an absolute path internally before being executed by the current\n+    /// platform. Notably, on Windows, this avoids a security problem where\n+    /// passing a relative path to `CreateProcess` will automatically search\n+    /// the current directory for a matching program. If the program could\n+    /// not be resolved, then it is silently ignored and the association is\n+    /// dropped. For this reason, callers should prefer `try_associate`.\n     pub fn associate<P, I, A>(\n         &mut self,\n         glob: &str,\n         program: P,\n         args: I,\n     ) -> &mut DecompressionMatcherBuilder\n+    where\n+        P: AsRef<OsStr>,\n+        I: IntoIterator<Item = A>,\n+        A: AsRef<OsStr>,\n+    {\n+        let _ = self.try_associate(glob, program, args);\n+        self\n+    }\n+\n+    /// Associates a glob with a command to decompress files matching the glob.\n+    ///\n+    /// If multiple globs match the same file, then the most recently added\n+    /// glob takes precedence.\n+    ///\n+    /// The syntax for the glob is documented in the\n+    /// [`globset` crate](https://docs.rs/globset/#syntax).\n+    ///\n+    /// The `program` given is resolved with respect to `PATH` and turned\n+    /// into an absolute path internally before being executed by the current\n+    /// platform. Notably, on Windows, this avoids a security problem where\n+    /// passing a relative path to `CreateProcess` will automatically search\n+    /// the current directory for a matching program. If the program could not\n+    /// be resolved, then an error is returned.\n+    pub fn try_associate<P, I, A>(\n+        &mut self,\n+        glob: &str,\n+        program: P,\n+        args: I,\n+    ) -> Result<&mut DecompressionMatcherBuilder, CommandError>\n     where\n         P: AsRef<OsStr>,\n         I: IntoIterator<Item = A>,\n         A: AsRef<OsStr>,\n     {\n         let glob = glob.to_string();\n-        let bin = program.as_ref().to_os_string();\n+        let bin = resolve_binary(Path::new(program.as_ref()))?;\n         let args =\n             args.into_iter().map(|a| a.as_ref().to_os_string()).collect();\n         self.commands.push(DecompressionCommand { glob, bin, args });\n-        self\n+        Ok(self)\n     }\n }\n \n@@ -340,6 +377,70 @@ impl io::Read for DecompressionReader {\n     }\n }\n \n+/// Resolves a path to a program to a path by searching for the program in\n+/// `PATH`.\n+///\n+/// If the program could not be resolved, then an error is returned.\n+///\n+/// The purpose of doing this instead of passing the path to the program\n+/// directly to Command::new is that Command::new will hand relative paths\n+/// to CreateProcess on Windows, which will implicitly search the current\n+/// working directory for the executable. This could be undesirable for\n+/// security reasons. e.g., running ripgrep with the -z/--search-zip flag on an\n+/// untrusted directory tree could result in arbitrary programs executing on\n+/// Windows.\n+///\n+/// Note that this could still return a relative path if PATH contains a\n+/// relative path. We permit this since it is assumed that the user has set\n+/// this explicitly, and thus, desires this behavior.\n+///\n+/// On non-Windows, this is a no-op.\n+pub fn resolve_binary<P: AsRef<Path>>(\n+    prog: P,\n+) -> Result<PathBuf, CommandError> {\n+    use std::env;\n+\n+    fn is_exe(path: &Path) -> bool {\n+        let md = match path.metadata() {\n+            Err(_) => return false,\n+            Ok(md) => md,\n+        };\n+        !md.is_dir()\n+    }\n+\n+    let prog = prog.as_ref();\n+    if !cfg!(windows) || prog.is_absolute() {\n+        return Ok(prog.to_path_buf());\n+    }\n+    let syspaths = match env::var_os(\"PATH\") {\n+        Some(syspaths) => syspaths,\n+        None => {\n+            let msg = \"system PATH environment variable not found\";\n+            return Err(CommandError::io(io::Error::new(\n+                io::ErrorKind::Other,\n+                msg,\n+            )));\n+        }\n+    };\n+    for syspath in env::split_paths(&syspaths) {\n+        if syspath.as_os_str().is_empty() {\n+            continue;\n+        }\n+        let abs_prog = syspath.join(prog);\n+        if is_exe(&abs_prog) {\n+            return Ok(abs_prog.to_path_buf());\n+        }\n+        if abs_prog.extension().is_none() {\n+            let abs_prog = abs_prog.with_extension(\"exe\");\n+            if is_exe(&abs_prog) {\n+                return Ok(abs_prog.to_path_buf());\n+            }\n+        }\n+    }\n+    let msg = format!(\"{}: could not find executable in PATH\", prog.display());\n+    return Err(CommandError::io(io::Error::new(io::ErrorKind::Other, msg)));\n+}\n+\n fn default_decompression_commands() -> Vec<DecompressionCommand> {\n     const ARGS_GZIP: &[&str] = &[\"gzip\", \"-d\", \"-c\"];\n     const ARGS_BZIP: &[&str] = &[\"bzip2\", \"-d\", \"-c\"];\n@@ -350,29 +451,36 @@ fn default_decompression_commands() -> Vec<DecompressionCommand> {\n     const ARGS_ZSTD: &[&str] = &[\"zstd\", \"-q\", \"-d\", \"-c\"];\n     const ARGS_UNCOMPRESS: &[&str] = &[\"uncompress\", \"-c\"];\n \n-    fn cmd(glob: &str, args: &[&str]) -> DecompressionCommand {\n-        DecompressionCommand {\n+    fn add(glob: &str, args: &[&str], cmds: &mut Vec<DecompressionCommand>) {\n+        let bin = match resolve_binary(Path::new(args[0])) {\n+            Ok(bin) => bin,\n+            Err(err) => {\n+                debug!(\"{}\", err);\n+                return;\n+            }\n+        };\n+        cmds.push(DecompressionCommand {\n             glob: glob.to_string(),\n-            bin: OsStr::new(&args[0]).to_os_string(),\n+            bin,\n             args: args\n                 .iter()\n                 .skip(1)\n                 .map(|s| OsStr::new(s).to_os_string())\n                 .collect(),\n-        }\n+        });\n     }\n-    vec![\n-        cmd(\"*.gz\", ARGS_GZIP),\n-        cmd(\"*.tgz\", ARGS_GZIP),\n-        cmd(\"*.bz2\", ARGS_BZIP),\n-        cmd(\"*.tbz2\", ARGS_BZIP),\n-        cmd(\"*.xz\", ARGS_XZ),\n-        cmd(\"*.txz\", ARGS_XZ),\n-        cmd(\"*.lz4\", ARGS_LZ4),\n-        cmd(\"*.lzma\", ARGS_LZMA),\n-        cmd(\"*.br\", ARGS_BROTLI),\n-        cmd(\"*.zst\", ARGS_ZSTD),\n-        cmd(\"*.zstd\", ARGS_ZSTD),\n-        cmd(\"*.Z\", ARGS_UNCOMPRESS),\n-    ]\n+    let mut cmds = vec![];\n+    add(\"*.gz\", ARGS_GZIP, &mut cmds);\n+    add(\"*.tgz\", ARGS_GZIP, &mut cmds);\n+    add(\"*.bz2\", ARGS_BZIP, &mut cmds);\n+    add(\"*.tbz2\", ARGS_BZIP, &mut cmds);\n+    add(\"*.xz\", ARGS_XZ, &mut cmds);\n+    add(\"*.txz\", ARGS_XZ, &mut cmds);\n+    add(\"*.lz4\", ARGS_LZ4, &mut cmds);\n+    add(\"*.lzma\", ARGS_LZMA, &mut cmds);\n+    add(\"*.br\", ARGS_BROTLI, &mut cmds);\n+    add(\"*.zst\", ARGS_ZSTD, &mut cmds);\n+    add(\"*.zstd\", ARGS_ZSTD, &mut cmds);\n+    add(\"*.Z\", ARGS_UNCOMPRESS, &mut cmds);\n+    cmds\n }\n",
    "diff_parsed": "{'added': [(4, 'use std::path::{Path, PathBuf};'), (27, '    bin: PathBuf,'), (100, '    where'), (101, '        P: AsRef<OsStr>,'), (102, '        I: IntoIterator<Item = A>,'), (103, '        A: AsRef<OsStr>,'), (104, '    {'), (105, '        let _ = self.try_associate(glob, program, args);'), (106, '        self'), (107, '    }'), (123, '    pub fn try_associate<P, I, A>('), (124, '        &mut self,'), (125, '        glob: &str,'), (126, '        program: P,'), (127, '        args: I,'), (128, '    ) -> Result<&mut DecompressionMatcherBuilder, CommandError>'), (135, '        let bin = resolve_binary(Path::new(program.as_ref()))?;'), (139, '        Ok(self)'), (398, 'pub fn resolve_binary<P: AsRef<Path>>('), (399, '    prog: P,'), (400, ') -> Result<PathBuf, CommandError> {'), (401, '    use std::env;'), (403, '    fn is_exe(path: &Path) -> bool {'), (404, '        let md = match path.metadata() {'), (405, '            Err(_) => return false,'), (406, '            Ok(md) => md,'), (407, '        };'), (408, '        !md.is_dir()'), (409, '    }'), (411, '    let prog = prog.as_ref();'), (412, '    if !cfg!(windows) || prog.is_absolute() {'), (413, '        return Ok(prog.to_path_buf());'), (414, '    }'), (415, '    let syspaths = match env::var_os(\"PATH\") {'), (416, '        Some(syspaths) => syspaths,'), (417, '        None => {'), (418, '            let msg = \"system PATH environment variable not found\";'), (419, '            return Err(CommandError::io(io::Error::new('), (420, '                io::ErrorKind::Other,'), (421, '                msg,'), (422, '            )));'), (423, '        }'), (424, '    };'), (425, '    for syspath in env::split_paths(&syspaths) {'), (426, '        if syspath.as_os_str().is_empty() {'), (427, '            continue;'), (428, '        }'), (429, '        let abs_prog = syspath.join(prog);'), (430, '        if is_exe(&abs_prog) {'), (431, '            return Ok(abs_prog.to_path_buf());'), (432, '        }'), (433, '        if abs_prog.extension().is_none() {'), (434, '            let abs_prog = abs_prog.with_extension(\"exe\");'), (435, '            if is_exe(&abs_prog) {'), (436, '                return Ok(abs_prog.to_path_buf());'), (437, '            }'), (438, '        }'), (439, '    }'), (440, '    let msg = format!(\"{}: could not find executable in PATH\", prog.display());'), (441, '    return Err(CommandError::io(io::Error::new(io::ErrorKind::Other, msg)));'), (442, '}'), (454, '    fn add(glob: &str, args: &[&str], cmds: &mut Vec<DecompressionCommand>) {'), (455, '        let bin = match resolve_binary(Path::new(args[0])) {'), (456, '            Ok(bin) => bin,'), (457, '            Err(err) => {'), (458, '                debug!(\"{}\", err);'), (459, '                return;'), (460, '            }'), (461, '        };'), (462, '        cmds.push(DecompressionCommand {'), (464, '            bin,'), (470, '        });'), (472, '    let mut cmds = vec![];'), (473, '    add(\"*.gz\", ARGS_GZIP, &mut cmds);'), (474, '    add(\"*.tgz\", ARGS_GZIP, &mut cmds);'), (475, '    add(\"*.bz2\", ARGS_BZIP, &mut cmds);'), (476, '    add(\"*.tbz2\", ARGS_BZIP, &mut cmds);'), (477, '    add(\"*.xz\", ARGS_XZ, &mut cmds);'), (478, '    add(\"*.txz\", ARGS_XZ, &mut cmds);'), (479, '    add(\"*.lz4\", ARGS_LZ4, &mut cmds);'), (480, '    add(\"*.lzma\", ARGS_LZMA, &mut cmds);'), (481, '    add(\"*.br\", ARGS_BROTLI, &mut cmds);'), (482, '    add(\"*.zst\", ARGS_ZSTD, &mut cmds);'), (483, '    add(\"*.zstd\", ARGS_ZSTD, &mut cmds);'), (484, '    add(\"*.Z\", ARGS_UNCOMPRESS, &mut cmds);'), (485, '    cmds')], 'deleted': [(4, 'use std::path::Path;'), (27, '    bin: OsString,'), (98, '        let bin = program.as_ref().to_os_string();'), (102, '        self'), (353, '    fn cmd(glob: &str, args: &[&str]) -> DecompressionCommand {'), (354, '        DecompressionCommand {'), (356, '            bin: OsStr::new(&args[0]).to_os_string(),'), (362, '        }'), (364, '    vec!['), (365, '        cmd(\"*.gz\", ARGS_GZIP),'), (366, '        cmd(\"*.tgz\", ARGS_GZIP),'), (367, '        cmd(\"*.bz2\", ARGS_BZIP),'), (368, '        cmd(\"*.tbz2\", ARGS_BZIP),'), (369, '        cmd(\"*.xz\", ARGS_XZ),'), (370, '        cmd(\"*.txz\", ARGS_XZ),'), (371, '        cmd(\"*.lz4\", ARGS_LZ4),'), (372, '        cmd(\"*.lzma\", ARGS_LZMA),'), (373, '        cmd(\"*.br\", ARGS_BROTLI),'), (374, '        cmd(\"*.zst\", ARGS_ZSTD),'), (375, '        cmd(\"*.zstd\", ARGS_ZSTD),'), (376, '        cmd(\"*.Z\", ARGS_UNCOMPRESS),'), (377, '    ]')]}",
    "num_lines_added": "86",
    "num_lines_deleted": "22",
    "nloc": "272"
  },
  {
    "file_change_id": "50928347057761",
    "hash": "229d1a8d41b0023420e7815578fa0b39c0d5c2e4",
    "old_path": "crates/cli/src/lib.rs",
    "new_path": "crates/cli/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -179,8 +179,8 @@ mod process;\n mod wtr;\n \n pub use decompress::{\n-    DecompressionMatcher, DecompressionMatcherBuilder, DecompressionReader,\n-    DecompressionReaderBuilder,\n+    resolve_binary, DecompressionMatcher, DecompressionMatcherBuilder,\n+    DecompressionReader, DecompressionReaderBuilder,\n };\n pub use escape::{escape, escape_os, unescape, unescape_os};\n pub use human::{parse_human_readable_size, ParseSizeError};\n",
    "diff_parsed": "{'added': [(182, '    resolve_binary, DecompressionMatcher, DecompressionMatcherBuilder,'), (183, '    DecompressionReader, DecompressionReaderBuilder,')], 'deleted': [(182, '    DecompressionMatcher, DecompressionMatcherBuilder, DecompressionReader,'), (183, '    DecompressionReaderBuilder,')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "62"
  },
  {
    "file_change_id": "126895128492806",
    "hash": "229d1a8d41b0023420e7815578fa0b39c0d5c2e4",
    "old_path": "crates/core/args.rs",
    "new_path": "crates/core/args.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -290,7 +290,7 @@ impl Args {\n         let mut builder = SearchWorkerBuilder::new();\n         builder\n             .json_stats(matches.is_present(\"json\"))\n-            .preprocessor(matches.preprocessor())\n+            .preprocessor(matches.preprocessor())?\n             .preprocessor_globs(matches.preprocessor_globs()?)\n             .search_zip(matches.is_present(\"search-zip\"))\n             .binary_detection_implicit(matches.binary_detection_implicit())\n",
    "diff_parsed": "{'added': [(293, '            .preprocessor(matches.preprocessor())?')], 'deleted': [(293, '            .preprocessor(matches.preprocessor())')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "1324"
  },
  {
    "file_change_id": "225983220333744",
    "hash": "229d1a8d41b0023420e7815578fa0b39c0d5c2e4",
    "old_path": "crates/core/search.rs",
    "new_path": "crates/core/search.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -115,9 +115,14 @@ impl SearchWorkerBuilder {\n     pub fn preprocessor(\n         &mut self,\n         cmd: Option<PathBuf>,\n-    ) -> &mut SearchWorkerBuilder {\n-        self.config.preprocessor = cmd;\n-        self\n+    ) -> crate::Result<&mut SearchWorkerBuilder> {\n+        if let Some(ref prog) = cmd {\n+            let bin = cli::resolve_binary(prog)?;\n+            self.config.preprocessor = Some(bin);\n+        } else {\n+            self.config.preprocessor = None;\n+        }\n+        Ok(self)\n     }\n \n     /// Set the globs for determining which files should be run through the\n",
    "diff_parsed": "{'added': [(118, '    ) -> crate::Result<&mut SearchWorkerBuilder> {'), (119, '        if let Some(ref prog) = cmd {'), (120, '            let bin = cli::resolve_binary(prog)?;'), (121, '            self.config.preprocessor = Some(bin);'), (122, '        } else {'), (123, '            self.config.preprocessor = None;'), (124, '        }'), (125, '        Ok(self)')], 'deleted': [(118, '    ) -> &mut SearchWorkerBuilder {'), (119, '        self.config.preprocessor = cmd;'), (120, '        self')]}",
    "num_lines_added": "8",
    "num_lines_deleted": "3",
    "nloc": "394"
  },
  {
    "file_change_id": "162866267775818",
    "hash": "26a296b871976d7d46325ce004207b8a6e27c94",
    "old_path": "src/digests.rs",
    "new_path": "src/digests.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -321,7 +321,9 @@ impl<'a, T: TryFrom<u64>> MultihashRefGeneric<'a, T> {\n             return Err(DecodeError::BadInputLength);\n         }\n \n-        let (_code, bytes) = varint_decode::u64(&input).map_err(|_| DecodeError::BadInputLength)?;\n+        let (code, bytes) = varint_decode::u64(&input).map_err(|_| DecodeError::BadInputLength)?;\n+        // Make sure it's a code that is part of the codec table\n+        T::try_from(code).map_err(|_| DecodeError::UnknownCode)?;\n \n         let (hash_len, bytes) =\n             varint_decode::u64(&bytes).map_err(|_| DecodeError::BadInputLength)?;\n",
    "diff_parsed": "{'added': [(324, '        let (code, bytes) = varint_decode::u64(&input).map_err(|_| DecodeError::BadInputLength)?;'), (326, '        T::try_from(code).map_err(|_| DecodeError::UnknownCode)?;')], 'deleted': [(324, '        let (_code, bytes) = varint_decode::u64(&input).map_err(|_| DecodeError::BadInputLength)?;')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "1",
    "nloc": "246"
  },
  {
    "file_change_id": "177792489153415",
    "hash": "26a296b871976d7d46325ce004207b8a6e27c94",
    "old_path": "tests/lib.rs",
    "new_path": "tests/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -286,6 +286,14 @@ fn multihash_ref_errors() {\n         MultihashRef::from_slice(&[identity_code, identity_length, 1, 2, 3, 4]).is_err(),\n         \"Should error on wrong hash length\"\n     );\n+\n+    let unsupported_code = 0x04;\n+    let hash_length = 3;\n+    assert_eq!(\n+        MultihashRef::from_slice(&[unsupported_code, hash_length, 1, 2, 3]),\n+        Err(DecodeError::UnknownCode),\n+        \"Should error on codes that are not part of the code table\"\n+    );\n }\n \n #[test]\n",
    "diff_parsed": "{'added': [(290, '    let unsupported_code = 0x04;'), (291, '    let hash_length = 3;'), (292, '    assert_eq!('), (293, '        MultihashRef::from_slice(&[unsupported_code, hash_length, 1, 2, 3]),'), (294, '        Err(DecodeError::UnknownCode),'), (295, '        \"Should error on codes that are not part of the code table\"'), (296, '    );')], 'deleted': []}",
    "num_lines_added": "7",
    "num_lines_deleted": "0",
    "nloc": "291"
  },
  {
    "file_change_id": "95488019235485",
    "hash": "e7e291709240bd83ca35a12b85d87f074002be7",
    "old_path": "src/algorithm/mod.rs",
    "new_path": "src/algorithm/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -3,7 +3,7 @@ extern crate libc;\n use array::Array;\n use defines::{AfError, BinaryOp};\n use error::HANDLE_ERROR;\n-use self::libc::{c_int, uint8_t, c_uint, c_double};\n+use self::libc::{c_int, c_uint, c_double};\n use util::{AfArray, MutAfArray, MutDouble, MutUint};\n use util::{HasAfEnum, Scanable, RealNumber};\n \n@@ -44,9 +44,9 @@ extern {\n     fn af_sort_by_key(out_keys: MutAfArray, out_vals: MutAfArray,\n                       in_keys: AfArray, in_vals: AfArray, dim: c_uint, ascend: c_int) -> c_int;\n \n-    fn af_scan(out: MutAfArray, inp: AfArray, dim: c_int, op: uint8_t, inclusive: c_int) -> c_int;\n+    fn af_scan(out: MutAfArray, inp: AfArray, dim: c_int, op: c_uint, inclusive: c_int) -> c_int;\n     fn af_scan_by_key(out: MutAfArray, key: AfArray, inp: AfArray,\n-                      dim: c_int, op: uint8_t, inclusive: c_int) -> c_int;\n+                      dim: c_int, op: c_uint, inclusive: c_int) -> c_int;\n }\n \n macro_rules! dim_reduce_func_def {\n@@ -922,7 +922,7 @@ pub fn scan<T>(input: &Array<T>, dim: i32,\n     let mut temp : i64 = 0;\n     unsafe {\n         let err_val = af_scan(&mut temp as MutAfArray, input.get() as AfArray,\n-                              dim as c_int, op as uint8_t, inclusive as c_int);\n+                              dim as c_int, op as c_uint, inclusive as c_int);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n@@ -953,7 +953,7 @@ pub fn scan_by_key<K, V>(key: &Array<K>, input: &Array<V>,\n     unsafe {\n         let err_val = af_scan_by_key(&mut temp as MutAfArray, key.get() as AfArray,\n                                      input.get() as AfArray, dim as c_int,\n-                                     op as uint8_t, inclusive as c_int);\n+                                     op as c_uint, inclusive as c_int);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n",
    "diff_parsed": "{'added': [(6, 'use self::libc::{c_int, c_uint, c_double};'), (47, '    fn af_scan(out: MutAfArray, inp: AfArray, dim: c_int, op: c_uint, inclusive: c_int) -> c_int;'), (49, '                      dim: c_int, op: c_uint, inclusive: c_int) -> c_int;'), (925, '                              dim as c_int, op as c_uint, inclusive as c_int);'), (956, '                                     op as c_uint, inclusive as c_int);')], 'deleted': [(6, 'use self::libc::{c_int, uint8_t, c_uint, c_double};'), (47, '    fn af_scan(out: MutAfArray, inp: AfArray, dim: c_int, op: uint8_t, inclusive: c_int) -> c_int;'), (49, '                      dim: c_int, op: uint8_t, inclusive: c_int) -> c_int;'), (925, '                              dim as c_int, op as uint8_t, inclusive as c_int);'), (956, '                                     op as uint8_t, inclusive as c_int);')]}",
    "num_lines_added": "5",
    "num_lines_deleted": "5",
    "nloc": "743"
  },
  {
    "file_change_id": "90505433207172",
    "hash": "e7e291709240bd83ca35a12b85d87f074002be7",
    "old_path": "src/array.rs",
    "new_path": "src/array.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -4,7 +4,7 @@ use dim4::Dim4;\n use defines::{AfError, DType, Backend};\n use error::HANDLE_ERROR;\n use util::{AfArray, DimT, HasAfEnum, MutAfArray, MutVoidPtr};\n-use self::libc::{uint8_t, c_void, c_int, c_uint, c_longlong, c_char};\n+use self::libc::{c_void, c_int, c_uint, c_longlong, c_char};\n use std::marker::PhantomData;\n use std::ffi::CString;\n \n@@ -16,13 +16,13 @@ use std::ffi::CString;\n #[allow(dead_code)]\n extern {\n     fn af_create_array(out: MutAfArray, data: *const c_void,\n-                       ndims: c_uint, dims: *const DimT, aftype: uint8_t) -> c_int;\n+                       ndims: c_uint, dims: *const DimT, aftype: c_uint) -> c_int;\n \n-    fn af_create_handle(out: MutAfArray, ndims: c_uint, dims: *const DimT, aftype: uint8_t) -> c_int;\n+    fn af_create_handle(out: MutAfArray, ndims: c_uint, dims: *const DimT, aftype: c_uint) -> c_int;\n \n     fn af_get_elements(out: MutAfArray, arr: AfArray) -> c_int;\n \n-    fn af_get_type(out: *mut c_int, arr: AfArray) -> c_int;\n+    fn af_get_type(out: *mut c_uint, arr: AfArray) -> c_int;\n \n     fn af_get_dims(dim0: *mut c_longlong, dim1: *mut c_longlong, dim2: *mut c_longlong,\n                    dim3: *mut c_longlong, arr: AfArray) -> c_int;\n@@ -75,15 +75,15 @@ extern {\n \n     fn af_print_array_gen(exp: *const c_char, arr: AfArray, precision: c_int) -> c_int;\n \n-    fn af_cast(out: MutAfArray, arr: AfArray, aftype: uint8_t) -> c_int;\n+    fn af_cast(out: MutAfArray, arr: AfArray, aftype: c_uint) -> c_int;\n \n-    fn af_get_backend_id(backend: *mut c_int, input: AfArray) -> c_int;\n+    fn af_get_backend_id(backend: *mut c_uint, input: AfArray) -> c_int;\n \n     fn af_get_device_id(device: *mut c_int, input: AfArray) -> c_int;\n \n     fn af_create_strided_array(arr: MutAfArray, data: *const c_void, offset: DimT,\n                                ndims: c_uint, dims: *const DimT, strides: *const DimT,\n-                               aftype: uint8_t, stype: uint8_t) -> c_int;\n+                               aftype: c_uint, stype: c_uint) -> c_int;\n \n     fn af_get_strides(s0: *mut DimT, s1: *mut DimT, s2: *mut DimT, s3: *mut DimT,\n                       arr: AfArray) -> c_int;\n@@ -155,7 +155,7 @@ impl<T> Array<T> where T: HasAfEnum {\n                                           slice.as_ptr() as *const c_void,\n                                           dims.ndims() as c_uint,\n                                           dims.get().as_ptr() as * const c_longlong,\n-                                          aftype as uint8_t);\n+                                          aftype as c_uint);\n             HANDLE_ERROR(AfError::from(err_val));\n         }\n         temp.into()\n@@ -176,7 +176,7 @@ impl<T> Array<T> where T: HasAfEnum {\n                                                   dims.ndims() as c_uint,\n                                                   dims.get().as_ptr() as * const c_longlong,\n                                                   strides.get().as_ptr() as * const c_longlong,\n-                                                  aftype as uint8_t, 1);\n+                                                  aftype as c_uint, 1 as c_uint);\n             HANDLE_ERROR(AfError::from(err_val));\n         }\n         temp.into()\n@@ -198,7 +198,7 @@ impl<T> Array<T> where T: HasAfEnum {\n             let err_val = af_create_handle(&mut temp as MutAfArray,\n                                            dims.ndims() as c_uint,\n                                            dims.get().as_ptr() as * const c_longlong,\n-                                           aftype as uint8_t);\n+                                           aftype as c_uint);\n             HANDLE_ERROR(AfError::from(err_val));\n             temp.into()\n         }\n@@ -212,8 +212,8 @@ impl<T> Array<T> where T: HasAfEnum {\n     /// was active when Array was created.\n     pub fn get_backend(&self) -> Backend {\n         unsafe {\n-            let mut ret_val: i32 = 0;\n-            let err_val = af_get_backend_id(&mut ret_val as *mut c_int, self.handle as AfArray);\n+            let mut ret_val: u32 = 0;\n+            let err_val = af_get_backend_id(&mut ret_val as *mut c_uint, self.handle as AfArray);\n             HANDLE_ERROR(AfError::from(err_val));\n             match (err_val, ret_val) {\n                 (0, 1) => Backend::CPU,\n@@ -251,8 +251,8 @@ impl<T> Array<T> where T: HasAfEnum {\n     /// Returns the Array data type\n     pub fn get_type(&self) -> DType {\n         unsafe {\n-            let mut ret_val: i32 = 0;\n-            let err_val = af_get_type(&mut ret_val as *mut c_int, self.handle as AfArray);\n+            let mut ret_val: u32 = 0;\n+            let err_val = af_get_type(&mut ret_val as *mut c_uint, self.handle as AfArray);\n             HANDLE_ERROR(AfError::from(err_val));\n             DType::from(ret_val)\n         }\n@@ -364,7 +364,7 @@ impl<T> Array<T> where T: HasAfEnum {\n         let trgt_type = O::get_af_dtype();\n         let mut temp: i64 = 0;\n         unsafe {\n-            let err_val = af_cast(&mut temp as MutAfArray, self.handle as AfArray, trgt_type as uint8_t);\n+            let err_val = af_cast(&mut temp as MutAfArray, self.handle as AfArray, trgt_type as c_uint);\n             HANDLE_ERROR(AfError::from(err_val));\n         }\n         temp.into()\n",
    "diff_parsed": "{'added': [(7, 'use self::libc::{c_void, c_int, c_uint, c_longlong, c_char};'), (19, '                       ndims: c_uint, dims: *const DimT, aftype: c_uint) -> c_int;'), (21, '    fn af_create_handle(out: MutAfArray, ndims: c_uint, dims: *const DimT, aftype: c_uint) -> c_int;'), (25, '    fn af_get_type(out: *mut c_uint, arr: AfArray) -> c_int;'), (78, '    fn af_cast(out: MutAfArray, arr: AfArray, aftype: c_uint) -> c_int;'), (80, '    fn af_get_backend_id(backend: *mut c_uint, input: AfArray) -> c_int;'), (86, '                               aftype: c_uint, stype: c_uint) -> c_int;'), (158, '                                          aftype as c_uint);'), (179, '                                                  aftype as c_uint, 1 as c_uint);'), (201, '                                           aftype as c_uint);'), (215, '            let mut ret_val: u32 = 0;'), (216, '            let err_val = af_get_backend_id(&mut ret_val as *mut c_uint, self.handle as AfArray);'), (254, '            let mut ret_val: u32 = 0;'), (255, '            let err_val = af_get_type(&mut ret_val as *mut c_uint, self.handle as AfArray);'), (367, '            let err_val = af_cast(&mut temp as MutAfArray, self.handle as AfArray, trgt_type as c_uint);')], 'deleted': [(7, 'use self::libc::{uint8_t, c_void, c_int, c_uint, c_longlong, c_char};'), (19, '                       ndims: c_uint, dims: *const DimT, aftype: uint8_t) -> c_int;'), (21, '    fn af_create_handle(out: MutAfArray, ndims: c_uint, dims: *const DimT, aftype: uint8_t) -> c_int;'), (25, '    fn af_get_type(out: *mut c_int, arr: AfArray) -> c_int;'), (78, '    fn af_cast(out: MutAfArray, arr: AfArray, aftype: uint8_t) -> c_int;'), (80, '    fn af_get_backend_id(backend: *mut c_int, input: AfArray) -> c_int;'), (86, '                               aftype: uint8_t, stype: uint8_t) -> c_int;'), (158, '                                          aftype as uint8_t);'), (179, '                                                  aftype as uint8_t, 1);'), (201, '                                           aftype as uint8_t);'), (215, '            let mut ret_val: i32 = 0;'), (216, '            let err_val = af_get_backend_id(&mut ret_val as *mut c_int, self.handle as AfArray);'), (254, '            let mut ret_val: i32 = 0;'), (255, '            let err_val = af_get_type(&mut ret_val as *mut c_int, self.handle as AfArray);'), (367, '            let err_val = af_cast(&mut temp as MutAfArray, self.handle as AfArray, trgt_type as uint8_t);')]}",
    "num_lines_added": "15",
    "num_lines_deleted": "15",
    "nloc": "354"
  },
  {
    "file_change_id": "205051350145531",
    "hash": "e7e291709240bd83ca35a12b85d87f074002be7",
    "old_path": "src/data/mod.rs",
    "new_path": "src/data/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -5,7 +5,7 @@ use array::Array;\n use dim4::Dim4;\n use defines::{AfError};\n use error::HANDLE_ERROR;\n-use self::libc::{uint8_t, c_int, c_uint, c_double};\n+use self::libc::{c_int, c_uint, c_double};\n use self::num::Complex;\n use util::{AfArray, DimT, HasAfEnum, Intl, MutAfArray, Uintl};\n use std::vec::Vec;\n@@ -25,12 +25,12 @@ extern {\n                          ndims: c_uint, dims: *const DimT) -> c_int;\n \n     fn af_range(out: MutAfArray, ndims: c_uint, dims: *const DimT,\n-                seq_dims: c_int, afdtype: uint8_t) -> c_int;\n+                seq_dims: c_int, afdtype: c_uint) -> c_int;\n \n     fn af_iota(out: MutAfArray, ndims: c_uint, dims: *const DimT,\n-               t_ndims: c_uint, tdims: *const DimT, afdtype: uint8_t) -> c_int;\n+               t_ndims: c_uint, tdims: *const DimT, afdtype: c_uint) -> c_int;\n \n-    fn af_identity(out: MutAfArray, ndims: c_uint, dims: *const DimT, afdtype: uint8_t) -> c_int;\n+    fn af_identity(out: MutAfArray, ndims: c_uint, dims: *const DimT, afdtype: c_uint) -> c_int;\n     fn af_diag_create(out: MutAfArray, arr: AfArray, num: c_int) -> c_int;\n     fn af_diag_extract(out: MutAfArray, arr: AfArray, num: c_int) -> c_int;\n     fn af_join(out: MutAfArray, dim: c_int, first: AfArray, second: AfArray) -> c_int;\n@@ -243,7 +243,7 @@ pub fn range<T: HasAfEnum>(dims: Dim4, seq_dim: i32) -> Array<T> {\n     unsafe {\n         let err_val = af_range(&mut temp as MutAfArray,\n                               dims.ndims() as c_uint, dims.get().as_ptr() as *const DimT,\n-                              seq_dim as c_int, aftype as uint8_t);\n+                              seq_dim as c_int, aftype as c_uint);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n@@ -269,7 +269,7 @@ pub fn iota<T: HasAfEnum>(dims: Dim4, tdims: Dim4) -> Array<T> {\n         let err_val =af_iota(&mut temp as MutAfArray,\n                              dims.ndims() as c_uint, dims.get().as_ptr() as *const DimT,\n                              tdims.ndims() as c_uint, tdims.get().as_ptr() as *const DimT,\n-                             aftype as uint8_t);\n+                             aftype as c_uint);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n@@ -291,7 +291,7 @@ pub fn identity<T: HasAfEnum>(dims: Dim4) -> Array<T> {\n     unsafe {\n         let err_val = af_identity(&mut temp as MutAfArray,\n                                   dims.ndims() as c_uint, dims.get().as_ptr() as *const DimT,\n-                                  aftype as uint8_t);\n+                                  aftype as c_uint);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n",
    "diff_parsed": "{'added': [(8, 'use self::libc::{c_int, c_uint, c_double};'), (28, '                seq_dims: c_int, afdtype: c_uint) -> c_int;'), (31, '               t_ndims: c_uint, tdims: *const DimT, afdtype: c_uint) -> c_int;'), (33, '    fn af_identity(out: MutAfArray, ndims: c_uint, dims: *const DimT, afdtype: c_uint) -> c_int;'), (246, '                              seq_dim as c_int, aftype as c_uint);'), (272, '                             aftype as c_uint);'), (294, '                                  aftype as c_uint);')], 'deleted': [(8, 'use self::libc::{uint8_t, c_int, c_uint, c_double};'), (28, '                seq_dims: c_int, afdtype: uint8_t) -> c_int;'), (31, '               t_ndims: c_uint, tdims: *const DimT, afdtype: uint8_t) -> c_int;'), (33, '    fn af_identity(out: MutAfArray, ndims: c_uint, dims: *const DimT, afdtype: uint8_t) -> c_int;'), (246, '                              seq_dim as c_int, aftype as uint8_t);'), (272, '                             aftype as uint8_t);'), (294, '                                  aftype as uint8_t);')]}",
    "num_lines_added": "7",
    "num_lines_deleted": "7",
    "nloc": "368"
  },
  {
    "file_change_id": "75210323456050",
    "hash": "e7e291709240bd83ca35a12b85d87f074002be7",
    "old_path": "src/defines.rs",
    "new_path": "src/defines.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -6,7 +6,7 @@ use std::fmt::Error as FmtError;\n use self::num::Complex;\n \n /// Error codes\n-#[repr(C)]\n+#[repr(i32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum AfError {\n     /// The function returned successfully\n@@ -53,7 +53,7 @@ pub enum AfError {\n }\n \n /// Compute/Acceleration Backend\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum Backend {\n     /// Default backend order: OpenCL -> CUDA -> CPU\n@@ -109,7 +109,7 @@ impl Error for AfError {\n }\n \n /// Types of Array data type\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum DType {\n     /// 32 bit float\n@@ -139,7 +139,7 @@ pub enum DType {\n }\n \n /// Dictates the interpolation method to be used by a function\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum InterpType {\n     /// Nearest Neighbor interpolation method\n@@ -165,7 +165,7 @@ pub enum InterpType {\n }\n \n /// Helps determine how to pad kernels along borders\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum BorderType {\n     /// Pad using zeros\n@@ -175,7 +175,7 @@ pub enum BorderType {\n }\n \n /// Used by `regions` function to identify type of connectivity\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum Connectivity {\n     /// North-East-South-West (N-E-S-W) connectivity from given pixel/point\n@@ -185,7 +185,7 @@ pub enum Connectivity {\n }\n \n /// Helps determine the size of output of convolution\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum ConvMode {\n     /// Default convolution mode where output size is same as input size\n@@ -195,7 +195,7 @@ pub enum ConvMode {\n }\n \n /// Helps determine if convolution is in Spatial or Frequency domain\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum ConvDomain {\n     /// ArrayFire chooses whether the convolution will be in spatial domain or frequency domain\n@@ -207,7 +207,7 @@ pub enum ConvDomain {\n }\n \n /// Error metric used by `matchTemplate` function\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum MatchType {\n     /// Sum of Absolute Differences\n@@ -231,7 +231,7 @@ pub enum MatchType {\n }\n \n /// Identify the color space of given image(Array)\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum ColorSpace {\n     /// Grayscale color space\n@@ -243,7 +243,7 @@ pub enum ColorSpace {\n }\n \n /// Helps determine the type of a Matrix\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum MatProp {\n     /// Default (no-op)\n@@ -272,7 +272,7 @@ pub enum MatProp {\n \n /// Norm type\n #[allow(non_camel_case_types)]\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum NormType {\n     /// Treats input as a vector and return sum of absolute values\n@@ -294,7 +294,7 @@ pub enum NormType {\n }\n \n /// Dictates what color map is used for Image rendering\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum ColorMap {\n     /// Default color map is grayscale range [0-1]\n@@ -314,7 +314,7 @@ pub enum ColorMap {\n }\n \n /// YCbCr Standards\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum YCCStd {\n     /// ITU-R BT.601 (formerly CCIR 601) standard\n@@ -326,7 +326,7 @@ pub enum YCCStd {\n }\n \n /// Homography type\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum HomographyType {\n     /// RANdom SAmple Consensus algorithm\n@@ -336,7 +336,7 @@ pub enum HomographyType {\n }\n \n /// Plotting markers\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum MarkerType {\n     /// No marker\n@@ -358,7 +358,7 @@ pub enum MarkerType {\n }\n \n /// Image moment types\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum MomentType {\n     /// Central moment of order (0 + 0)\n@@ -374,7 +374,7 @@ pub enum MomentType {\n }\n \n /// Sparse storage format type\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum SparseFormat {\n     /// Dense format\n@@ -388,7 +388,7 @@ pub enum SparseFormat {\n }\n \n /// Binary operation types for generalized scan functions\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum BinaryOp {\n     /// Addition operation\n@@ -402,7 +402,7 @@ pub enum BinaryOp {\n }\n \n /// Random engine types\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum RandomEngineType {\n     ///Philox variant with N=4, W=32 and Rounds=10\n@@ -452,7 +452,7 @@ pub enum Scalar {\n }\n \n /// Canny edge detector threshold operations types\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum CannyThresholdType {\n     /// User has to define canny thresholds manually\n@@ -462,7 +462,7 @@ pub enum CannyThresholdType {\n }\n \n /// Anisotropic diffusion flux equation types\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum DiffusionEq {\n     /// Quadratic flux function\n@@ -474,7 +474,7 @@ pub enum DiffusionEq {\n }\n \n /// Diffusion equation types\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum FluxFn {\n     /// Quadratic flux function\n@@ -486,7 +486,7 @@ pub enum FluxFn {\n }\n \n /// topk function ordering\n-#[repr(C)]\n+#[repr(u32)]\n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum TopkFn {\n     /// Top k min values\n",
    "diff_parsed": "{'added': [(9, '#[repr(i32)]'), (56, '#[repr(u32)]'), (112, '#[repr(u32)]'), (142, '#[repr(u32)]'), (168, '#[repr(u32)]'), (178, '#[repr(u32)]'), (188, '#[repr(u32)]'), (198, '#[repr(u32)]'), (210, '#[repr(u32)]'), (234, '#[repr(u32)]'), (246, '#[repr(u32)]'), (275, '#[repr(u32)]'), (297, '#[repr(u32)]'), (317, '#[repr(u32)]'), (329, '#[repr(u32)]'), (339, '#[repr(u32)]'), (361, '#[repr(u32)]'), (377, '#[repr(u32)]'), (391, '#[repr(u32)]'), (405, '#[repr(u32)]'), (455, '#[repr(u32)]'), (465, '#[repr(u32)]'), (477, '#[repr(u32)]'), (489, '#[repr(u32)]')], 'deleted': [(9, '#[repr(C)]'), (56, '#[repr(C)]'), (112, '#[repr(C)]'), (142, '#[repr(C)]'), (168, '#[repr(C)]'), (178, '#[repr(C)]'), (188, '#[repr(C)]'), (198, '#[repr(C)]'), (210, '#[repr(C)]'), (234, '#[repr(C)]'), (246, '#[repr(C)]'), (275, '#[repr(C)]'), (297, '#[repr(C)]'), (317, '#[repr(C)]'), (329, '#[repr(C)]'), (339, '#[repr(C)]'), (361, '#[repr(C)]'), (377, '#[repr(C)]'), (391, '#[repr(C)]'), (405, '#[repr(C)]'), (455, '#[repr(C)]'), (465, '#[repr(C)]'), (477, '#[repr(C)]'), (489, '#[repr(C)]')]}",
    "num_lines_added": "24",
    "num_lines_deleted": "24",
    "nloc": "290"
  },
  {
    "file_change_id": "225885087031268",
    "hash": "e7e291709240bd83ca35a12b85d87f074002be7",
    "old_path": "src/image/mod.rs",
    "new_path": "src/image/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -7,7 +7,7 @@ use error::HANDLE_ERROR;\n use util::{AfArray, DimT, MutAfArray};\n use util::{FloatingPoint, HasAfEnum, RealNumber, ImageNativeType, ImageFilterType};\n use util::{RealFloating, EdgeComputable, MomentsComputable, GrayRGBConvertible};\n-use self::libc::{uint8_t, c_uint, c_int, c_float, c_double, c_char};\n+use self::libc::{c_uint, c_int, c_float, c_double, c_char};\n use std::ffi::CString;\n \n // unused functions from image.h header\n@@ -17,7 +17,7 @@ use std::ffi::CString;\n \n #[allow(dead_code)]\n extern {\n-    fn af_cast(out: MutAfArray, arr: AfArray, aftype: uint8_t) -> c_int;\n+    fn af_cast(out: MutAfArray, arr: AfArray, aftype: c_uint) -> c_int;\n     fn af_gradient(dx: MutAfArray, dy: MutAfArray, arr: AfArray) -> c_int;\n     fn af_load_image(out: MutAfArray, filename: *const c_char, iscolor: c_int) -> c_int;\n     fn af_save_image(filename: *const c_char, input: AfArray) -> c_int;\n@@ -25,22 +25,22 @@ extern {\n     fn af_save_image_native(filename: *const c_char, input: AfArray) -> c_int;\n \n     fn af_resize(out: MutAfArray, input: AfArray,\n-                 odim0: DimT, odim1: DimT, method: uint8_t) -> c_int;\n+                 odim0: DimT, odim1: DimT, method: c_uint) -> c_int;\n \n     fn af_transform(out: MutAfArray, input: AfArray, trans: AfArray,\n-                    odim0: DimT, odim1: DimT, method: uint8_t, is_inverse: c_int) -> c_int;\n+                    odim0: DimT, odim1: DimT, method: c_uint, is_inverse: c_int) -> c_int;\n \n     fn af_rotate(out: MutAfArray, input: AfArray, theta: c_float, crop: c_int,\n-                 method: uint8_t) -> c_int;\n+                 method: c_uint) -> c_int;\n \n     fn af_translate(out: MutAfArray, input: AfArray, trans0: c_float, trans1: c_float,\n-                    odim0: DimT, odim1: DimT, method: uint8_t) -> c_int;\n+                    odim0: DimT, odim1: DimT, method: c_uint) -> c_int;\n \n     fn af_scale(out: MutAfArray, input: AfArray, scale0: c_float, scale1: c_float,\n-                odim0: DimT, odim1: DimT, method: uint8_t) -> c_int;\n+                odim0: DimT, odim1: DimT, method: c_uint) -> c_int;\n \n     fn af_skew(out: MutAfArray, input: AfArray, skew0: c_float, skew1: c_float,\n-               odim0: DimT, odim1: DimT, method: uint8_t, is_inverse: c_int) -> c_int;\n+               odim0: DimT, odim1: DimT, method: c_uint, is_inverse: c_int) -> c_int;\n \n     fn af_histogram(out: MutAfArray, input: AfArray, nbins: c_uint,\n                     minval: c_double, maxval: c_double) -> c_int;\n@@ -49,7 +49,7 @@ extern {\n     fn af_dilate3(out: MutAfArray, input: AfArray, mask: AfArray) -> c_int;\n     fn af_erode(out: MutAfArray, input: AfArray, mask: AfArray) -> c_int;\n     fn af_erode3(out: MutAfArray, input: AfArray, mask: AfArray) -> c_int;\n-    fn af_regions(out: MutAfArray, input: AfArray, conn: uint8_t, aftype: uint8_t) -> c_int;\n+    fn af_regions(out: MutAfArray, input: AfArray, conn: c_uint, aftype: c_uint) -> c_int;\n     fn af_sobel_operator(dx: MutAfArray, dy: MutAfArray, i: AfArray, ksize: c_uint) -> c_int;\n     fn af_rgb2gray(out: MutAfArray, input: AfArray, r: c_float, g: c_float, b: c_float) -> c_int;\n     fn af_gray2rgb(out: MutAfArray, input: AfArray, r: c_float, g: c_float, b: c_float) -> c_int;\n@@ -64,21 +64,21 @@ extern {\n                      ch_sig: c_float, iter: c_uint, iscolor: c_int) -> c_int;\n \n     fn af_medfilt(out: MutAfArray, input: AfArray,\n-                  wlen: DimT, wwid: DimT, etype: uint8_t) -> c_int;\n+                  wlen: DimT, wwid: DimT, etype: c_uint) -> c_int;\n \n-    fn af_medfilt1(out: MutAfArray, input: AfArray, wlen: DimT, etype: uint8_t) -> c_int;\n+    fn af_medfilt1(out: MutAfArray, input: AfArray, wlen: DimT, etype: c_uint) -> c_int;\n \n     fn af_minfilt(out: MutAfArray, input: AfArray,\n-                  wlen: DimT, wwid: DimT, etype: uint8_t) -> c_int;\n+                  wlen: DimT, wwid: DimT, etype: c_uint) -> c_int;\n \n     fn af_maxfilt(out: MutAfArray, input: AfArray,\n-                  wlen: DimT, wwid: DimT, etype: uint8_t) -> c_int;\n+                  wlen: DimT, wwid: DimT, etype: c_uint) -> c_int;\n \n     fn af_gaussian_kernel(out: MutAfArray, rows: c_int, cols: c_int,\n                           sigma_r: c_double, sigma_c: c_double) -> c_int;\n \n     fn af_color_space(out: MutAfArray, input: AfArray,\n-                      tospace: uint8_t, fromspace: uint8_t) -> c_int;\n+                      tospace: c_uint, fromspace: c_uint) -> c_int;\n \n     fn af_unwrap(out: MutAfArray, input: AfArray, wx: DimT, wy: DimT, sx: DimT, sy: DimT,\n                  px: DimT, py: DimT, is_column: c_int) -> c_int;\n@@ -162,7 +162,7 @@ pub fn load_image<T>(filename: String, is_color: bool) -> Array<T>\n         let mut temp: i64 = 0;\n         let err1 = af_load_image(&mut temp as MutAfArray, cstr_param.as_ptr(), is_color as c_int);\n         HANDLE_ERROR(AfError::from(err1));\n-        let err2 = af_cast(&mut img as MutAfArray, temp as AfArray, trgt_type as uint8_t);\n+        let err2 = af_cast(&mut img as MutAfArray, temp as AfArray, trgt_type as c_uint);\n         HANDLE_ERROR(AfError::from(err2));\n     }\n     img.into()\n@@ -200,7 +200,7 @@ pub fn load_image_native<T>(filename: String) -> Array<T>\n         let mut temp: i64 = 0;\n         let err1 = af_load_image_native(&mut temp as MutAfArray, cstr_param.as_ptr());\n         HANDLE_ERROR(AfError::from(err1));\n-        let err2 = af_cast(&mut img as MutAfArray, temp as AfArray, trgt_type as uint8_t);\n+        let err2 = af_cast(&mut img as MutAfArray, temp as AfArray, trgt_type as c_uint);\n         HANDLE_ERROR(AfError::from(err2));\n     }\n     img.into()\n@@ -283,7 +283,7 @@ pub fn resize<T:HasAfEnum>(input: &Array<T>,\n     let mut temp: i64 = 0;\n     unsafe {\n         let err_val = af_resize(&mut temp as MutAfArray, input.get() as AfArray,\n-                                odim0 as DimT, odim1 as DimT, method as uint8_t);\n+                                odim0 as DimT, odim1 as DimT, method as c_uint);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n@@ -327,7 +327,7 @@ pub fn transform<T:HasAfEnum>(input: &Array<T>, trans: &Array<f32>,\n         let err_val = af_transform(&mut temp as MutAfArray,\n                                    input.get() as AfArray, trans.get() as AfArray,\n                                    odim0 as DimT, odim1 as DimT,\n-                                   method as uint8_t, is_inverse as c_int);\n+                                   method as c_uint, is_inverse as c_int);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n@@ -368,7 +368,7 @@ pub fn rotate<T:HasAfEnum>(input: &Array<T>, theta: f64, crop: bool,\n     let mut temp: i64 = 0;\n     unsafe {\n         let err_val = af_rotate(&mut temp as MutAfArray, input.get() as AfArray,\n-                                theta as c_float, crop as c_int, method as uint8_t);\n+                                theta as c_float, crop as c_int, method as c_uint);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n@@ -410,7 +410,7 @@ pub fn translate<T:HasAfEnum>(input: &Array<T>, trans0: f32, trans1: f32,\n                                    input.get() as AfArray,\n                                    trans0 as c_float, trans1 as c_float,\n                                    odim0 as DimT, odim1 as DimT,\n-                                   method as uint8_t);\n+                                   method as c_uint);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n@@ -443,7 +443,7 @@ pub fn scale<T:HasAfEnum>(input: &Array<T>, scale0: f32, scale1: f32,\n                                input.get() as AfArray,\n                                scale0 as c_float, scale1 as c_float,\n                                odim0 as DimT, odim1 as DimT,\n-                               method as uint8_t);\n+                               method as c_uint);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n@@ -484,7 +484,7 @@ pub fn skew<T:HasAfEnum>(input: &Array<T>,\n         let err_val = af_skew(&mut temp as MutAfArray, input.get() as AfArray,\n                               skew0 as c_float, skew1 as c_float,\n                               odim0 as DimT, odim1 as DimT,\n-                              method as uint8_t, is_inverse as c_int);\n+                              method as c_uint, is_inverse as c_int);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n@@ -737,7 +737,7 @@ macro_rules! filt_func_def {\n             let mut temp: i64 = 0;\n             unsafe {\n                 let err_val = $ffi_name(&mut temp as MutAfArray, input.get() as AfArray,\n-                                        wlen as DimT, wwid as DimT, etype as uint8_t);\n+                                        wlen as DimT, wwid as DimT, etype as c_uint);\n                 HANDLE_ERROR(AfError::from(err_val));\n             }\n             temp.into()\n@@ -825,7 +825,7 @@ pub fn color_space<T>(input: &Array<T>,\n     let mut temp: i64 = 0;\n     unsafe {\n         let err_val = af_color_space(&mut temp as MutAfArray, input.get() as AfArray,\n-                                     tospace as uint8_t, fromspace as uint8_t);\n+                                     tospace as c_uint, fromspace as c_uint);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n@@ -856,7 +856,7 @@ pub fn regions<OutType>(input: &Array<bool>, conn: Connectivity) -> Array<OutTyp\n     let mut temp: i64 = 0;\n     unsafe {\n         let err_val = af_regions(&mut temp as MutAfArray, input.get() as AfArray,\n-                                 conn as uint8_t, otype as uint8_t);\n+                                 conn as c_uint, otype as c_uint);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n@@ -1291,7 +1291,7 @@ pub fn medfilt1<T>(input: &Array<T>, wlen: u64, etype: BorderType) -> Array<T>\n     let mut temp: i64 = 0;\n     unsafe {\n         let err_val = af_medfilt1(&mut temp as MutAfArray, input.get() as AfArray,\n-                                  wlen as DimT, etype as uint8_t);\n+                                  wlen as DimT, etype as c_uint);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n",
    "diff_parsed": "{'added': [(10, 'use self::libc::{c_uint, c_int, c_float, c_double, c_char};'), (20, '    fn af_cast(out: MutAfArray, arr: AfArray, aftype: c_uint) -> c_int;'), (28, '                 odim0: DimT, odim1: DimT, method: c_uint) -> c_int;'), (31, '                    odim0: DimT, odim1: DimT, method: c_uint, is_inverse: c_int) -> c_int;'), (34, '                 method: c_uint) -> c_int;'), (37, '                    odim0: DimT, odim1: DimT, method: c_uint) -> c_int;'), (40, '                odim0: DimT, odim1: DimT, method: c_uint) -> c_int;'), (43, '               odim0: DimT, odim1: DimT, method: c_uint, is_inverse: c_int) -> c_int;'), (52, '    fn af_regions(out: MutAfArray, input: AfArray, conn: c_uint, aftype: c_uint) -> c_int;'), (67, '                  wlen: DimT, wwid: DimT, etype: c_uint) -> c_int;'), (69, '    fn af_medfilt1(out: MutAfArray, input: AfArray, wlen: DimT, etype: c_uint) -> c_int;'), (72, '                  wlen: DimT, wwid: DimT, etype: c_uint) -> c_int;'), (75, '                  wlen: DimT, wwid: DimT, etype: c_uint) -> c_int;'), (81, '                      tospace: c_uint, fromspace: c_uint) -> c_int;'), (165, '        let err2 = af_cast(&mut img as MutAfArray, temp as AfArray, trgt_type as c_uint);'), (203, '        let err2 = af_cast(&mut img as MutAfArray, temp as AfArray, trgt_type as c_uint);'), (286, '                                odim0 as DimT, odim1 as DimT, method as c_uint);'), (330, '                                   method as c_uint, is_inverse as c_int);'), (371, '                                theta as c_float, crop as c_int, method as c_uint);'), (413, '                                   method as c_uint);'), (446, '                               method as c_uint);'), (487, '                              method as c_uint, is_inverse as c_int);'), (740, '                                        wlen as DimT, wwid as DimT, etype as c_uint);'), (828, '                                     tospace as c_uint, fromspace as c_uint);'), (859, '                                 conn as c_uint, otype as c_uint);'), (1294, '                                  wlen as DimT, etype as c_uint);')], 'deleted': [(10, 'use self::libc::{uint8_t, c_uint, c_int, c_float, c_double, c_char};'), (20, '    fn af_cast(out: MutAfArray, arr: AfArray, aftype: uint8_t) -> c_int;'), (28, '                 odim0: DimT, odim1: DimT, method: uint8_t) -> c_int;'), (31, '                    odim0: DimT, odim1: DimT, method: uint8_t, is_inverse: c_int) -> c_int;'), (34, '                 method: uint8_t) -> c_int;'), (37, '                    odim0: DimT, odim1: DimT, method: uint8_t) -> c_int;'), (40, '                odim0: DimT, odim1: DimT, method: uint8_t) -> c_int;'), (43, '               odim0: DimT, odim1: DimT, method: uint8_t, is_inverse: c_int) -> c_int;'), (52, '    fn af_regions(out: MutAfArray, input: AfArray, conn: uint8_t, aftype: uint8_t) -> c_int;'), (67, '                  wlen: DimT, wwid: DimT, etype: uint8_t) -> c_int;'), (69, '    fn af_medfilt1(out: MutAfArray, input: AfArray, wlen: DimT, etype: uint8_t) -> c_int;'), (72, '                  wlen: DimT, wwid: DimT, etype: uint8_t) -> c_int;'), (75, '                  wlen: DimT, wwid: DimT, etype: uint8_t) -> c_int;'), (81, '                      tospace: uint8_t, fromspace: uint8_t) -> c_int;'), (165, '        let err2 = af_cast(&mut img as MutAfArray, temp as AfArray, trgt_type as uint8_t);'), (203, '        let err2 = af_cast(&mut img as MutAfArray, temp as AfArray, trgt_type as uint8_t);'), (286, '                                odim0 as DimT, odim1 as DimT, method as uint8_t);'), (330, '                                   method as uint8_t, is_inverse as c_int);'), (371, '                                theta as c_float, crop as c_int, method as uint8_t);'), (413, '                                   method as uint8_t);'), (446, '                               method as uint8_t);'), (487, '                              method as uint8_t, is_inverse as c_int);'), (740, '                                        wlen as DimT, wwid as DimT, etype as uint8_t);'), (828, '                                     tospace as uint8_t, fromspace as uint8_t);'), (859, '                                 conn as uint8_t, otype as uint8_t);'), (1294, '                                  wlen as DimT, etype as uint8_t);')]}",
    "num_lines_added": "26",
    "num_lines_deleted": "26",
    "nloc": "596"
  },
  {
    "file_change_id": "62562464474507",
    "hash": "e7e291709240bd83ca35a12b85d87f074002be7",
    "old_path": "src/lapack/mod.rs",
    "new_path": "src/lapack/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -5,7 +5,7 @@ use defines::{AfError, MatProp, NormType};\n use error::HANDLE_ERROR;\n use util::{AfArray, MutAfArray, MutDouble, to_u32};\n use util::{FloatingPoint, HasAfEnum};\n-use self::libc::{uint8_t, c_int, c_uint, c_double};\n+use self::libc::{c_int, c_uint, c_double};\n \n #[allow(dead_code)]\n extern {\n@@ -22,7 +22,7 @@ extern {\n     fn af_inverse(out: MutAfArray, input: AfArray, options: c_uint) -> c_int;\n     fn af_rank(rank: *mut c_uint, input: AfArray, tol: c_double) -> c_int;\n     fn af_det(det_real: MutDouble, det_imag: MutDouble, input: AfArray) -> c_int;\n-    fn af_norm(out: MutDouble, input: AfArray, ntype: uint8_t, p: c_double, q: c_double) -> c_int;\n+    fn af_norm(out: MutDouble, input: AfArray, ntype: c_uint, p: c_double, q: c_double) -> c_int;\n     fn af_is_lapack_available(out: *mut c_int) -> c_int;\n }\n \n@@ -416,7 +416,7 @@ pub fn norm<T>(input: &Array<T>, ntype: NormType, p: f64, q: f64) -> f64\n     let mut out: f64 = 0.0;\n     unsafe {\n         let err_val = af_norm(&mut out as MutDouble, input.get() as AfArray,\n-                              ntype as uint8_t,\n+                              ntype as c_uint,\n                               p as c_double, q as c_double);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n",
    "diff_parsed": "{'added': [(8, 'use self::libc::{c_int, c_uint, c_double};'), (25, '    fn af_norm(out: MutDouble, input: AfArray, ntype: c_uint, p: c_double, q: c_double) -> c_int;'), (419, '                              ntype as c_uint,')], 'deleted': [(8, 'use self::libc::{uint8_t, c_int, c_uint, c_double};'), (25, '    fn af_norm(out: MutDouble, input: AfArray, ntype: uint8_t, p: c_double, q: c_double) -> c_int;'), (419, '                              ntype as uint8_t,')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "3",
    "nloc": "217"
  },
  {
    "file_change_id": "210411795862068",
    "hash": "e7e291709240bd83ca35a12b85d87f074002be7",
    "old_path": "src/random/mod.rs",
    "new_path": "src/random/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -4,7 +4,7 @@ use array::Array;\n use dim4::Dim4;\n use defines::{AfError, RandomEngineType};\n use error::HANDLE_ERROR;\n-use self::libc::{uint8_t, c_int, c_uint};\n+use self::libc::{c_int, c_uint};\n use util::{FloatingPoint, HasAfEnum};\n use util::{DimT, MutAfArray, MutRandEngine, RandEngine, Uintl};\n \n@@ -13,24 +13,24 @@ extern {\n     fn af_set_seed(seed: Uintl) -> c_int;\n     fn af_get_seed(seed: *mut Uintl) -> c_int;\n \n-    fn af_randu(out: MutAfArray, ndims: c_uint, dims: *const DimT, afdtype: uint8_t) -> c_int;\n-    fn af_randn(out: MutAfArray, ndims: c_uint, dims: *const DimT, afdtype: uint8_t) -> c_int;\n+    fn af_randu(out: MutAfArray, ndims: c_uint, dims: *const DimT, afdtype: c_uint) -> c_int;\n+    fn af_randn(out: MutAfArray, ndims: c_uint, dims: *const DimT, afdtype: c_uint) -> c_int;\n \n-    fn af_create_random_engine(engine: MutRandEngine, rtype: uint8_t, seed: Uintl) -> c_int;\n+    fn af_create_random_engine(engine: MutRandEngine, rtype: c_uint, seed: Uintl) -> c_int;\n     fn af_retain_random_engine(engine: MutRandEngine, inputEngine: RandEngine) -> c_int;\n-    fn af_random_engine_set_type(engine: MutRandEngine, rtpye: uint8_t) -> c_int;\n-    fn af_random_engine_get_type(rtype: *mut uint8_t, engine: RandEngine) -> c_int;\n+    fn af_random_engine_set_type(engine: MutRandEngine, rtpye: c_uint) -> c_int;\n+    fn af_random_engine_get_type(rtype: *mut c_uint, engine: RandEngine) -> c_int;\n     fn af_random_engine_set_seed(engine: MutRandEngine, seed: Uintl) -> c_int;\n     fn af_random_engine_get_seed(seed: *mut Uintl, engine: RandEngine) -> c_int;\n     fn af_release_random_engine(engine: RandEngine) -> c_int;\n \n     fn af_get_default_random_engine(engine: MutRandEngine) -> c_int;\n-    fn af_set_default_random_engine_type(rtype: uint8_t) -> c_int;\n+    fn af_set_default_random_engine_type(rtype: c_uint) -> c_int;\n \n     fn af_random_uniform(out: MutAfArray, ndims: c_uint, dims: *const DimT,\n-                         aftype: uint8_t, engine: RandEngine) -> c_int;\n+                         aftype: c_uint, engine: RandEngine) -> c_int;\n     fn af_random_normal(out: MutAfArray, ndims: c_uint, dims: *const DimT,\n-                        aftype: uint8_t, engine: RandEngine) -> c_int;\n+                        aftype: c_uint, engine: RandEngine) -> c_int;\n }\n \n /// Set seed for random number generation\n@@ -71,7 +71,7 @@ macro_rules! data_gen_def {\n             unsafe {\n                 let err_val = $ffi_name(&mut temp as MutAfArray,\n                                         dims.ndims() as c_uint, dims.get().as_ptr() as *const DimT,\n-                                        aftype as uint8_t);\n+                                        aftype as c_uint);\n                 HANDLE_ERROR(AfError::from(err_val));\n             }\n             temp.into()\n@@ -112,7 +112,7 @@ impl RandomEngine {\n     pub fn new(rengine: RandomEngineType, seed: Option<u64>) -> RandomEngine {\n         let mut temp: i64 = 0;\n         unsafe {\n-            let err_val = af_create_random_engine(&mut temp as MutRandEngine, rengine as uint8_t,\n+            let err_val = af_create_random_engine(&mut temp as MutRandEngine, rengine as c_uint,\n                                                   match seed {Some(s) => s, None => 0} as Uintl);\n             HANDLE_ERROR(AfError::from(err_val));\n         }\n@@ -121,20 +121,20 @@ impl RandomEngine {\n \n     /// Get random engine type\n     pub fn get_type(&self) -> RandomEngineType {\n-        let mut temp: u8 = 0;\n+        let mut temp: u32 = 0;\n         unsafe {\n-            let err_val = af_random_engine_get_type(&mut temp as *mut uint8_t,\n+            let err_val = af_random_engine_get_type(&mut temp as *mut c_uint,\n                                                     self.handle as RandEngine);\n             HANDLE_ERROR(AfError::from(err_val));\n         }\n-        RandomEngineType::from(temp as i32)\n+        RandomEngineType::from(temp)\n     }\n \n     /// Get random engine type\n     pub fn set_type(&mut self, engine_type: RandomEngineType) {\n         unsafe {\n             let err_val = af_random_engine_set_type(&mut self.handle as MutRandEngine,\n-                                                    engine_type as uint8_t);\n+                                                    engine_type as c_uint);\n             HANDLE_ERROR(AfError::from(err_val));\n         }\n     }\n@@ -206,7 +206,7 @@ pub fn get_default_random_engine() -> RandomEngine {\n /// - `rtype` can take one of the values of enum [RandomEngineType](./enum.RandomEngineType.html)\n pub fn set_default_random_engine_type(rtype: RandomEngineType) {\n     unsafe {\n-        let err_val = af_set_default_random_engine_type(rtype as uint8_t);\n+        let err_val = af_set_default_random_engine_type(rtype as c_uint);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n }\n@@ -228,7 +228,7 @@ where T: HasAfEnum {\n     unsafe {\n         let err_val = af_random_uniform(&mut temp as MutAfArray,\n                                         dims.ndims() as c_uint, dims.get().as_ptr() as *const DimT,\n-                                        aftype as uint8_t, engine.get() as RandEngine);\n+                                        aftype as c_uint, engine.get() as RandEngine);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n@@ -252,7 +252,7 @@ pub fn random_normal<T>(dims: Dim4, engine: &RandomEngine) -> Array<T>\n     unsafe {\n         let err_val = af_random_normal(&mut temp as MutAfArray,\n                                        dims.ndims() as c_uint, dims.get().as_ptr() as *const DimT,\n-                                       aftype as uint8_t, engine.get() as RandEngine);\n+                                       aftype as c_uint, engine.get() as RandEngine);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n",
    "diff_parsed": "{'added': [(7, 'use self::libc::{c_int, c_uint};'), (16, '    fn af_randu(out: MutAfArray, ndims: c_uint, dims: *const DimT, afdtype: c_uint) -> c_int;'), (17, '    fn af_randn(out: MutAfArray, ndims: c_uint, dims: *const DimT, afdtype: c_uint) -> c_int;'), (19, '    fn af_create_random_engine(engine: MutRandEngine, rtype: c_uint, seed: Uintl) -> c_int;'), (21, '    fn af_random_engine_set_type(engine: MutRandEngine, rtpye: c_uint) -> c_int;'), (22, '    fn af_random_engine_get_type(rtype: *mut c_uint, engine: RandEngine) -> c_int;'), (28, '    fn af_set_default_random_engine_type(rtype: c_uint) -> c_int;'), (31, '                         aftype: c_uint, engine: RandEngine) -> c_int;'), (33, '                        aftype: c_uint, engine: RandEngine) -> c_int;'), (74, '                                        aftype as c_uint);'), (115, '            let err_val = af_create_random_engine(&mut temp as MutRandEngine, rengine as c_uint,'), (124, '        let mut temp: u32 = 0;'), (126, '            let err_val = af_random_engine_get_type(&mut temp as *mut c_uint,'), (130, '        RandomEngineType::from(temp)'), (137, '                                                    engine_type as c_uint);'), (209, '        let err_val = af_set_default_random_engine_type(rtype as c_uint);'), (231, '                                        aftype as c_uint, engine.get() as RandEngine);'), (255, '                                       aftype as c_uint, engine.get() as RandEngine);')], 'deleted': [(7, 'use self::libc::{uint8_t, c_int, c_uint};'), (16, '    fn af_randu(out: MutAfArray, ndims: c_uint, dims: *const DimT, afdtype: uint8_t) -> c_int;'), (17, '    fn af_randn(out: MutAfArray, ndims: c_uint, dims: *const DimT, afdtype: uint8_t) -> c_int;'), (19, '    fn af_create_random_engine(engine: MutRandEngine, rtype: uint8_t, seed: Uintl) -> c_int;'), (21, '    fn af_random_engine_set_type(engine: MutRandEngine, rtpye: uint8_t) -> c_int;'), (22, '    fn af_random_engine_get_type(rtype: *mut uint8_t, engine: RandEngine) -> c_int;'), (28, '    fn af_set_default_random_engine_type(rtype: uint8_t) -> c_int;'), (31, '                         aftype: uint8_t, engine: RandEngine) -> c_int;'), (33, '                        aftype: uint8_t, engine: RandEngine) -> c_int;'), (74, '                                        aftype as uint8_t);'), (115, '            let err_val = af_create_random_engine(&mut temp as MutRandEngine, rengine as uint8_t,'), (124, '        let mut temp: u8 = 0;'), (126, '            let err_val = af_random_engine_get_type(&mut temp as *mut uint8_t,'), (130, '        RandomEngineType::from(temp as i32)'), (137, '                                                    engine_type as uint8_t);'), (209, '        let err_val = af_set_default_random_engine_type(rtype as uint8_t);'), (231, '                                        aftype as uint8_t, engine.get() as RandEngine);'), (255, '                                       aftype as uint8_t, engine.get() as RandEngine);')]}",
    "num_lines_added": "18",
    "num_lines_deleted": "18",
    "nloc": "178"
  },
  {
    "file_change_id": "251383002188367",
    "hash": "e7e291709240bd83ca35a12b85d87f074002be7",
    "old_path": "src/signal/mod.rs",
    "new_path": "src/signal/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -5,7 +5,7 @@ use array::Array;\n use defines::{AfError, ConvDomain, ConvMode, InterpType};\n use error::HANDLE_ERROR;\n use self::num::Complex;\n-use self::libc::{uint8_t, c_int, c_float, c_double, c_longlong, size_t};\n+use self::libc::{c_uint, c_int, c_float, c_double, c_longlong, size_t};\n use util::{ComplexFloating, FloatingPoint, HasAfEnum, RealFloating};\n use util::{AfArray, MutAfArray};\n \n@@ -55,13 +55,13 @@ extern {\n     fn af_fft2_c2r(out: MutAfArray, input: AfArray, nfac: c_double, is_odd: c_int) -> c_int;\n     fn af_fft3_c2r(out: MutAfArray, input: AfArray, nfac: c_double, is_odd: c_int) -> c_int;\n \n-    fn af_convolve1(out: MutAfArray, s: AfArray, f: AfArray, m: uint8_t, d: uint8_t) -> c_int;\n-    fn af_convolve2(out: MutAfArray, s: AfArray, f: AfArray, m: uint8_t, d: uint8_t) -> c_int;\n-    fn af_convolve3(out: MutAfArray, s: AfArray, f: AfArray, m: uint8_t, d: uint8_t) -> c_int;\n-    fn af_convolve2_sep(o: MutAfArray, c: AfArray, r: AfArray, s: AfArray, m: uint8_t) -> c_int;\n-    fn af_fft_convolve1(out: MutAfArray, s: AfArray, f: AfArray, m: uint8_t) -> c_int;\n-    fn af_fft_convolve2(out: MutAfArray, s: AfArray, f: AfArray, m: uint8_t) -> c_int;\n-    fn af_fft_convolve3(out: MutAfArray, s: AfArray, f: AfArray, m: uint8_t) -> c_int;\n+    fn af_convolve1(out: MutAfArray, s: AfArray, f: AfArray, m: c_uint, d: c_uint) -> c_int;\n+    fn af_convolve2(out: MutAfArray, s: AfArray, f: AfArray, m: c_uint, d: c_uint) -> c_int;\n+    fn af_convolve3(out: MutAfArray, s: AfArray, f: AfArray, m: c_uint, d: c_uint) -> c_int;\n+    fn af_convolve2_sep(o: MutAfArray, c: AfArray, r: AfArray, s: AfArray, m: c_uint) -> c_int;\n+    fn af_fft_convolve1(out: MutAfArray, s: AfArray, f: AfArray, m: c_uint) -> c_int;\n+    fn af_fft_convolve2(out: MutAfArray, s: AfArray, f: AfArray, m: c_uint) -> c_int;\n+    fn af_fft_convolve3(out: MutAfArray, s: AfArray, f: AfArray, m: c_uint) -> c_int;\n     fn af_fir(out: MutAfArray, b: AfArray, x: AfArray) -> c_int;\n     fn af_iir(out: MutAfArray, b: AfArray, a: AfArray, x: AfArray) -> c_int;\n }\n@@ -337,7 +337,7 @@ macro_rules! conv_func_def {\n             unsafe {\n                 let err_val = $ffi_name(&mut temp as MutAfArray,\n                                         signal.get() as AfArray, filter.get() as AfArray,\n-                                        mode as uint8_t, domain as uint8_t);\n+                                        mode as c_uint, domain as c_uint);\n                 HANDLE_ERROR(AfError::from(err_val));\n             }\n             temp.into()\n@@ -371,7 +371,7 @@ pub fn convolve2_sep<T, F>(cfilt: &Array<F>, rfilt: &Array<F>, signal: &Array<T>\n     unsafe {\n         let err_val = af_convolve2_sep(&mut temp as MutAfArray,\n                                        cfilt.get() as AfArray, rfilt.get() as AfArray,\n-                                       signal.get() as AfArray, mode as uint8_t);\n+                                       signal.get() as AfArray, mode as c_uint);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n@@ -400,7 +400,7 @@ macro_rules! fft_conv_func_def {\n             let mut temp: i64 = 0;\n             unsafe {\n                 let err_val = $ffi_name(&mut temp as MutAfArray, signal.get() as AfArray,\n-                                        filter.get() as AfArray, mode as uint8_t);\n+                                        filter.get() as AfArray, mode as c_uint);\n                 HANDLE_ERROR(AfError::from(err_val));\n             }\n             temp.into()\n",
    "diff_parsed": "{'added': [(8, 'use self::libc::{c_uint, c_int, c_float, c_double, c_longlong, size_t};'), (58, '    fn af_convolve1(out: MutAfArray, s: AfArray, f: AfArray, m: c_uint, d: c_uint) -> c_int;'), (59, '    fn af_convolve2(out: MutAfArray, s: AfArray, f: AfArray, m: c_uint, d: c_uint) -> c_int;'), (60, '    fn af_convolve3(out: MutAfArray, s: AfArray, f: AfArray, m: c_uint, d: c_uint) -> c_int;'), (61, '    fn af_convolve2_sep(o: MutAfArray, c: AfArray, r: AfArray, s: AfArray, m: c_uint) -> c_int;'), (62, '    fn af_fft_convolve1(out: MutAfArray, s: AfArray, f: AfArray, m: c_uint) -> c_int;'), (63, '    fn af_fft_convolve2(out: MutAfArray, s: AfArray, f: AfArray, m: c_uint) -> c_int;'), (64, '    fn af_fft_convolve3(out: MutAfArray, s: AfArray, f: AfArray, m: c_uint) -> c_int;'), (340, '                                        mode as c_uint, domain as c_uint);'), (374, '                                       signal.get() as AfArray, mode as c_uint);'), (403, '                                        filter.get() as AfArray, mode as c_uint);')], 'deleted': [(8, 'use self::libc::{uint8_t, c_int, c_float, c_double, c_longlong, size_t};'), (58, '    fn af_convolve1(out: MutAfArray, s: AfArray, f: AfArray, m: uint8_t, d: uint8_t) -> c_int;'), (59, '    fn af_convolve2(out: MutAfArray, s: AfArray, f: AfArray, m: uint8_t, d: uint8_t) -> c_int;'), (60, '    fn af_convolve3(out: MutAfArray, s: AfArray, f: AfArray, m: uint8_t, d: uint8_t) -> c_int;'), (61, '    fn af_convolve2_sep(o: MutAfArray, c: AfArray, r: AfArray, s: AfArray, m: uint8_t) -> c_int;'), (62, '    fn af_fft_convolve1(out: MutAfArray, s: AfArray, f: AfArray, m: uint8_t) -> c_int;'), (63, '    fn af_fft_convolve2(out: MutAfArray, s: AfArray, f: AfArray, m: uint8_t) -> c_int;'), (64, '    fn af_fft_convolve3(out: MutAfArray, s: AfArray, f: AfArray, m: uint8_t) -> c_int;'), (340, '                                        mode as uint8_t, domain as uint8_t);'), (374, '                                       signal.get() as AfArray, mode as uint8_t);'), (403, '                                        filter.get() as AfArray, mode as uint8_t);')]}",
    "num_lines_added": "11",
    "num_lines_deleted": "11",
    "nloc": "385"
  },
  {
    "file_change_id": "172629832525724",
    "hash": "e7e291709240bd83ca35a12b85d87f074002be7",
    "old_path": "src/sparse/mod.rs",
    "new_path": "src/sparse/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -3,26 +3,26 @@ extern crate libc;\n use array::Array;\n use defines::{AfError, SparseFormat};\n use error::HANDLE_ERROR;\n-use self::libc::{uint8_t, c_void, c_int};\n+use self::libc::{c_uint, c_void, c_int};\n use util::{AfArray, DimT, MutAfArray, MutDimT};\n use util::{FloatingPoint, HasAfEnum};\n \n #[allow(dead_code)]\n extern {\n     fn af_create_sparse_array(out: MutAfArray, nRows: DimT, nCols: DimT, vals: AfArray,\n-                              rowIdx: AfArray, colIdx: AfArray, stype: uint8_t) -> c_int;\n+                              rowIdx: AfArray, colIdx: AfArray, stype: c_uint) -> c_int;\n \n     fn af_create_sparse_array_from_ptr(out: MutAfArray, nRows: DimT, nCols: DimT, nNZ: DimT,\n                                        values: *const c_void, rowIdx: *const c_int, colIdx: *const c_int,\n-                                       aftype: uint8_t, stype: uint8_t, src: uint8_t) -> c_int;\n+                                       aftype: c_uint, stype: c_uint, src: c_uint) -> c_int;\n \n-    fn af_create_sparse_array_from_dense(out: MutAfArray, dense: AfArray, stype: uint8_t) -> c_int;\n+    fn af_create_sparse_array_from_dense(out: MutAfArray, dense: AfArray, stype: c_uint) -> c_int;\n \n-    fn af_sparse_convert_to(out: MutAfArray, input: AfArray, dstStrge: uint8_t) -> c_int;\n+    fn af_sparse_convert_to(out: MutAfArray, input: AfArray, dstStrge: c_uint) -> c_int;\n \n     fn af_sparse_to_dense(out: MutAfArray, sparse: AfArray) -> c_int;\n \n-    fn af_sparse_get_info(vals: MutAfArray, rIdx: MutAfArray, cIdx: MutAfArray, stype: *mut uint8_t,\n+    fn af_sparse_get_info(vals: MutAfArray, rIdx: MutAfArray, cIdx: MutAfArray, stype: *mut c_uint,\n                           input: AfArray) -> c_int;\n \n     fn af_sparse_get_values(out: MutAfArray, input: AfArray) -> c_int;\n@@ -33,7 +33,7 @@ extern {\n \n     fn af_sparse_get_nnz(out: MutDimT, input: AfArray) -> c_int;\n \n-    fn af_sparse_get_storage(out: *mut uint8_t, input: AfArray) -> c_int;\n+    fn af_sparse_get_storage(out: *mut c_uint, input: AfArray) -> c_int;\n }\n \n /// Create sprase matrix from arrays\n@@ -69,7 +69,7 @@ pub fn sparse<T>(rows: u64, cols: u64,\n     unsafe {\n         let err_val = af_create_sparse_array(&mut temp as MutAfArray, rows as DimT, cols as DimT,\n                                              values.get() as AfArray, row_indices.get() as AfArray,\n-                                             col_indices.get() as AfArray, format as uint8_t);\n+                                             col_indices.get() as AfArray, format as c_uint);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n@@ -112,7 +112,7 @@ pub fn sparse_from_host<T>(rows: u64, cols: u64, nzz: u64,\n                                                       values.as_ptr() as *const c_void,\n                                                       row_indices.as_ptr() as *const c_int,\n                                                       col_indices.as_ptr() as *const c_int,\n-                                                      aftype as uint8_t, format as uint8_t, 1);\n+                                                      aftype as c_uint, format as c_uint, 1);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n@@ -134,7 +134,7 @@ pub fn sparse_from_dense<T>(dense: &Array<T>, format: SparseFormat) -> Array<T>\n     let mut temp : i64 = 0;\n     unsafe {\n         let err_val = af_create_sparse_array_from_dense(&mut temp as MutAfArray, dense.get() as AfArray,\n-                                                        format as uint8_t);\n+                                                        format as c_uint);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n@@ -157,7 +157,7 @@ pub fn sparse_convert_to<T>(input: &Array<T>, format: SparseFormat) -> Array<T>\n     unsafe {\n         let err_val = af_sparse_convert_to(&mut temp as MutAfArray,\n                                            input.get() as AfArray,\n-                                           format as uint8_t);\n+                                           format as c_uint);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n@@ -196,17 +196,17 @@ pub fn sparse_to_dense<T>(input: &Array<T>) -> Array<T>\n pub fn sparse_get_info<T>(input: &Array<T>) -> (Array<T>, Array<i32>, Array<i32>, SparseFormat)\n     where T: HasAfEnum + FloatingPoint\n {\n-    let mut val : i64 = 0;\n-    let mut row : i64 = 0;\n-    let mut col : i64 = 0;\n-    let mut stype : u8 = 0;\n+    let mut val  : i64 = 0;\n+    let mut row  : i64 = 0;\n+    let mut col  : i64 = 0;\n+    let mut stype: u32 = 0;\n     unsafe {\n         let err_val = af_sparse_get_info(&mut val as MutAfArray, &mut row as MutAfArray,\n-                                         &mut col as MutAfArray, &mut stype as *mut uint8_t,\n+                                         &mut col as MutAfArray, &mut stype as *mut c_uint,\n                                          input.get() as AfArray);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n-    (val.into(), row.into(), col.into(), SparseFormat::from(stype as i32))\n+    (val.into(), row.into(), col.into(), SparseFormat::from(stype))\n }\n \n /// Get values of sparse Array\n@@ -297,10 +297,10 @@ pub fn sparse_get_nnz<T:HasAfEnum>(input: &Array<T>) -> i64 {\n ///\n /// Sparse array format\n pub fn sparse_get_format<T:HasAfEnum>(input: &Array<T>) -> SparseFormat {\n-    let mut stype : u8 = 0;\n+    let mut stype : u32 = 0;\n     unsafe {\n-        let err_val = af_sparse_get_storage(&mut stype as *mut uint8_t, input.get() as AfArray);\n+        let err_val = af_sparse_get_storage(&mut stype as *mut c_uint, input.get() as AfArray);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n-    SparseFormat::from(stype as i32)\n+    SparseFormat::from(stype)\n }\n",
    "diff_parsed": "{'added': [(6, 'use self::libc::{c_uint, c_void, c_int};'), (13, '                              rowIdx: AfArray, colIdx: AfArray, stype: c_uint) -> c_int;'), (17, '                                       aftype: c_uint, stype: c_uint, src: c_uint) -> c_int;'), (19, '    fn af_create_sparse_array_from_dense(out: MutAfArray, dense: AfArray, stype: c_uint) -> c_int;'), (21, '    fn af_sparse_convert_to(out: MutAfArray, input: AfArray, dstStrge: c_uint) -> c_int;'), (25, '    fn af_sparse_get_info(vals: MutAfArray, rIdx: MutAfArray, cIdx: MutAfArray, stype: *mut c_uint,'), (36, '    fn af_sparse_get_storage(out: *mut c_uint, input: AfArray) -> c_int;'), (72, '                                             col_indices.get() as AfArray, format as c_uint);'), (115, '                                                      aftype as c_uint, format as c_uint, 1);'), (137, '                                                        format as c_uint);'), (160, '                                           format as c_uint);'), (199, '    let mut val  : i64 = 0;'), (200, '    let mut row  : i64 = 0;'), (201, '    let mut col  : i64 = 0;'), (202, '    let mut stype: u32 = 0;'), (205, '                                         &mut col as MutAfArray, &mut stype as *mut c_uint,'), (209, '    (val.into(), row.into(), col.into(), SparseFormat::from(stype))'), (300, '    let mut stype : u32 = 0;'), (302, '        let err_val = af_sparse_get_storage(&mut stype as *mut c_uint, input.get() as AfArray);'), (305, '    SparseFormat::from(stype)')], 'deleted': [(6, 'use self::libc::{uint8_t, c_void, c_int};'), (13, '                              rowIdx: AfArray, colIdx: AfArray, stype: uint8_t) -> c_int;'), (17, '                                       aftype: uint8_t, stype: uint8_t, src: uint8_t) -> c_int;'), (19, '    fn af_create_sparse_array_from_dense(out: MutAfArray, dense: AfArray, stype: uint8_t) -> c_int;'), (21, '    fn af_sparse_convert_to(out: MutAfArray, input: AfArray, dstStrge: uint8_t) -> c_int;'), (25, '    fn af_sparse_get_info(vals: MutAfArray, rIdx: MutAfArray, cIdx: MutAfArray, stype: *mut uint8_t,'), (36, '    fn af_sparse_get_storage(out: *mut uint8_t, input: AfArray) -> c_int;'), (72, '                                             col_indices.get() as AfArray, format as uint8_t);'), (115, '                                                      aftype as uint8_t, format as uint8_t, 1);'), (137, '                                                        format as uint8_t);'), (160, '                                           format as uint8_t);'), (199, '    let mut val : i64 = 0;'), (200, '    let mut row : i64 = 0;'), (201, '    let mut col : i64 = 0;'), (202, '    let mut stype : u8 = 0;'), (205, '                                         &mut col as MutAfArray, &mut stype as *mut uint8_t,'), (209, '    (val.into(), row.into(), col.into(), SparseFormat::from(stype as i32))'), (300, '    let mut stype : u8 = 0;'), (302, '        let err_val = af_sparse_get_storage(&mut stype as *mut uint8_t, input.get() as AfArray);'), (305, '    SparseFormat::from(stype as i32)')]}",
    "num_lines_added": "20",
    "num_lines_deleted": "20",
    "nloc": "153"
  },
  {
    "file_change_id": "30411602913056",
    "hash": "e7e291709240bd83ca35a12b85d87f074002be7",
    "old_path": "src/statistics/mod.rs",
    "new_path": "src/statistics/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -3,7 +3,7 @@ extern crate libc;\n use array::Array;\n use defines::{AfError, TopkFn};\n use error::HANDLE_ERROR;\n-use self::libc::{c_int};\n+use self::libc::{c_int, c_uint};\n use util::{AfArray, DimT, MutAfArray, MutDouble};\n use util::{RealNumber, CovarianceComputable};\n use util::{HasAfEnum, MedianComputable, RealFloating};\n@@ -30,7 +30,7 @@ extern {\n \n     fn af_corrcoef(real: MutDouble, imag: MutDouble, X: AfArray, Y: AfArray) -> c_int;\n     fn af_topk(vals: MutAfArray, idxs: MutAfArray, arr: AfArray, k: c_int,\n-               dim: c_int, order: c_int) -> c_int;\n+               dim: c_int, order: c_uint) -> c_int;\n }\n \n /// Find the median along a given dimension\n@@ -336,7 +336,7 @@ pub fn topk<T>(input: &Array<T>, k: u32, dim: i32, order: TopkFn) -> (Array<T>,\n     unsafe {\n         let err_val = af_topk(&mut t0 as MutAfArray, &mut t1 as MutAfArray,\n                               input.get() as AfArray, k as c_int, dim as c_int,\n-                              order as c_int);\n+                              order as c_uint);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     (t0.into(), t1.into())\n",
    "diff_parsed": "{'added': [(6, 'use self::libc::{c_int, c_uint};'), (33, '               dim: c_int, order: c_uint) -> c_int;'), (339, '                              order as c_uint);')], 'deleted': [(6, 'use self::libc::{c_int};'), (33, '               dim: c_int, order: c_int) -> c_int;'), (339, '                              order as c_int);')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "3",
    "nloc": "199"
  },
  {
    "file_change_id": "276187436782046",
    "hash": "e7e291709240bd83ca35a12b85d87f074002be7",
    "old_path": "src/util.rs",
    "new_path": "src/util.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -7,7 +7,7 @@ use error::HANDLE_ERROR;\n use std::mem;\n use self::num::Complex;\n use num::Zero;\n-use self::libc::{uint8_t, c_int, size_t, c_void};\n+use self::libc::{c_uint, c_int, size_t, c_void};\n \n pub type AfArray       = self::libc::c_longlong;\n pub type AfIndex       = self::libc::c_longlong;\n@@ -32,7 +32,7 @@ pub type WndHandle     = self::libc::c_ulonglong;\n \n #[allow(dead_code)]\n extern {\n-    fn af_get_size_of(size: *mut size_t, aftype: uint8_t) -> c_int;\n+    fn af_get_size_of(size: *mut size_t, aftype: c_uint) -> c_int;\n \n     fn af_alloc_host(ptr: *mut *const c_void, bytes: DimT) -> c_int;\n     fn af_free_host(ptr: *mut c_void) -> c_int;\n@@ -42,7 +42,7 @@ extern {\n pub fn get_size(value: DType) -> usize {\n     unsafe {\n         let mut ret_val: usize = 0;\n-        let err_val = af_get_size_of(&mut ret_val as *mut size_t, value as uint8_t);\n+        let err_val = af_get_size_of(&mut ret_val as *mut size_t, value as c_uint);\n         HANDLE_ERROR(AfError::from(err_val));\n         ret_val\n     }\n@@ -75,37 +75,37 @@ impl From<i32> for AfError {\n     }\n }\n \n-impl From<i32> for DType {\n-    fn from(t: i32) -> DType {\n-        assert!(DType::F32 as i32 <= t && t <= DType::U64 as i32);\n+impl From<u32> for DType {\n+    fn from(t: u32) -> DType {\n+        assert!(DType::F32 as u32 <= t && t <= DType::U64 as u32);\n         unsafe { mem::transmute(t) }\n     }\n }\n \n-impl From<i32> for InterpType {\n-    fn from(t: i32) -> InterpType {\n-        assert!(InterpType::NEAREST as i32 <= t && t <= InterpType::BICUBIC_SPLINE as i32);\n+impl From<u32> for InterpType {\n+    fn from(t: u32) -> InterpType {\n+        assert!(InterpType::NEAREST as u32 <= t && t <= InterpType::BICUBIC_SPLINE as u32);\n         unsafe { mem::transmute(t) }\n     }\n }\n \n-impl From<i32> for ConvMode {\n-    fn from(t: i32) -> ConvMode {\n-        assert!(ConvMode::DEFAULT as i32 <= t && t <= ConvMode::EXPAND as i32);\n+impl From<u32> for ConvMode {\n+    fn from(t: u32) -> ConvMode {\n+        assert!(ConvMode::DEFAULT as u32 <= t && t <= ConvMode::EXPAND as u32);\n         unsafe { mem::transmute(t) }\n     }\n }\n \n-impl From<i32> for ConvDomain {\n-    fn from(t: i32) -> ConvDomain {\n-        assert!(ConvDomain::AUTO as i32 <= t && t <= ConvDomain::FREQUENCY as i32);\n+impl From<u32> for ConvDomain {\n+    fn from(t: u32) -> ConvDomain {\n+        assert!(ConvDomain::AUTO as u32 <= t && t <= ConvDomain::FREQUENCY as u32);\n         unsafe { mem::transmute(t) }\n     }\n }\n \n-impl From<i32> for MatchType {\n-    fn from(t: i32) -> MatchType {\n-        assert!(MatchType::SAD as i32 <= t && t <= MatchType::SHD as i32);\n+impl From<u32> for MatchType {\n+    fn from(t: u32) -> MatchType {\n+        assert!(MatchType::SAD as u32 <= t && t <= MatchType::SHD as u32);\n         unsafe { mem::transmute(t) }\n     }\n }\n@@ -126,9 +126,9 @@ pub fn to_u32(t: MatProp) -> u32 {\n     }\n }\n \n-impl From<i32> for ColorMap {\n-    fn from(t: i32) -> ColorMap {\n-        assert!(ColorMap::DEFAULT as i32 <= t && t <= ColorMap::BLUE as i32);\n+impl From<u32> for ColorMap {\n+    fn from(t: u32) -> ColorMap {\n+        assert!(ColorMap::DEFAULT as u32 <= t && t <= ColorMap::BLUE as u32);\n         unsafe { mem::transmute(t) }\n     }\n }\n@@ -357,23 +357,23 @@ impl HasAfEnum for u64  {\n     fn get_af_dtype() -> DType { DType::U64 }\n }\n \n-impl From<i32> for SparseFormat {\n-    fn from(t: i32) -> SparseFormat {\n-        assert!(SparseFormat::DENSE as i32 <= t && t <= SparseFormat::COO as i32);\n+impl From<u32> for SparseFormat {\n+    fn from(t: u32) -> SparseFormat {\n+        assert!(SparseFormat::DENSE as u32 <= t && t <= SparseFormat::COO as u32);\n         unsafe { mem::transmute(t) }\n     }\n }\n \n-impl From<i32> for BinaryOp {\n-    fn from(t: i32) -> BinaryOp {\n-        assert!(BinaryOp::ADD as i32 <= t && t <= BinaryOp::MAX as i32);\n+impl From<u32> for BinaryOp {\n+    fn from(t: u32) -> BinaryOp {\n+        assert!(BinaryOp::ADD as u32 <= t && t <= BinaryOp::MAX as u32);\n         unsafe { mem::transmute(t) }\n     }\n }\n \n-impl From<i32> for RandomEngineType {\n-    fn from(t: i32) -> RandomEngineType {\n-        assert!(RandomEngineType::PHILOX_4X32_10 as i32 <= t && t <= RandomEngineType::MERSENNE_GP11213 as i32);\n+impl From<u32> for RandomEngineType {\n+    fn from(t: u32) -> RandomEngineType {\n+        assert!(RandomEngineType::PHILOX_4X32_10 as u32 <= t && t <= RandomEngineType::MERSENNE_GP11213 as u32);\n         unsafe { mem::transmute(t) }\n     }\n }\n",
    "diff_parsed": "{'added': [(10, 'use self::libc::{c_uint, c_int, size_t, c_void};'), (35, '    fn af_get_size_of(size: *mut size_t, aftype: c_uint) -> c_int;'), (45, '        let err_val = af_get_size_of(&mut ret_val as *mut size_t, value as c_uint);'), (78, 'impl From<u32> for DType {'), (79, '    fn from(t: u32) -> DType {'), (80, '        assert!(DType::F32 as u32 <= t && t <= DType::U64 as u32);'), (85, 'impl From<u32> for InterpType {'), (86, '    fn from(t: u32) -> InterpType {'), (87, '        assert!(InterpType::NEAREST as u32 <= t && t <= InterpType::BICUBIC_SPLINE as u32);'), (92, 'impl From<u32> for ConvMode {'), (93, '    fn from(t: u32) -> ConvMode {'), (94, '        assert!(ConvMode::DEFAULT as u32 <= t && t <= ConvMode::EXPAND as u32);'), (99, 'impl From<u32> for ConvDomain {'), (100, '    fn from(t: u32) -> ConvDomain {'), (101, '        assert!(ConvDomain::AUTO as u32 <= t && t <= ConvDomain::FREQUENCY as u32);'), (106, 'impl From<u32> for MatchType {'), (107, '    fn from(t: u32) -> MatchType {'), (108, '        assert!(MatchType::SAD as u32 <= t && t <= MatchType::SHD as u32);'), (129, 'impl From<u32> for ColorMap {'), (130, '    fn from(t: u32) -> ColorMap {'), (131, '        assert!(ColorMap::DEFAULT as u32 <= t && t <= ColorMap::BLUE as u32);'), (360, 'impl From<u32> for SparseFormat {'), (361, '    fn from(t: u32) -> SparseFormat {'), (362, '        assert!(SparseFormat::DENSE as u32 <= t && t <= SparseFormat::COO as u32);'), (367, 'impl From<u32> for BinaryOp {'), (368, '    fn from(t: u32) -> BinaryOp {'), (369, '        assert!(BinaryOp::ADD as u32 <= t && t <= BinaryOp::MAX as u32);'), (374, 'impl From<u32> for RandomEngineType {'), (375, '    fn from(t: u32) -> RandomEngineType {'), (376, '        assert!(RandomEngineType::PHILOX_4X32_10 as u32 <= t && t <= RandomEngineType::MERSENNE_GP11213 as u32);')], 'deleted': [(10, 'use self::libc::{uint8_t, c_int, size_t, c_void};'), (35, '    fn af_get_size_of(size: *mut size_t, aftype: uint8_t) -> c_int;'), (45, '        let err_val = af_get_size_of(&mut ret_val as *mut size_t, value as uint8_t);'), (78, 'impl From<i32> for DType {'), (79, '    fn from(t: i32) -> DType {'), (80, '        assert!(DType::F32 as i32 <= t && t <= DType::U64 as i32);'), (85, 'impl From<i32> for InterpType {'), (86, '    fn from(t: i32) -> InterpType {'), (87, '        assert!(InterpType::NEAREST as i32 <= t && t <= InterpType::BICUBIC_SPLINE as i32);'), (92, 'impl From<i32> for ConvMode {'), (93, '    fn from(t: i32) -> ConvMode {'), (94, '        assert!(ConvMode::DEFAULT as i32 <= t && t <= ConvMode::EXPAND as i32);'), (99, 'impl From<i32> for ConvDomain {'), (100, '    fn from(t: i32) -> ConvDomain {'), (101, '        assert!(ConvDomain::AUTO as i32 <= t && t <= ConvDomain::FREQUENCY as i32);'), (106, 'impl From<i32> for MatchType {'), (107, '    fn from(t: i32) -> MatchType {'), (108, '        assert!(MatchType::SAD as i32 <= t && t <= MatchType::SHD as i32);'), (129, 'impl From<i32> for ColorMap {'), (130, '    fn from(t: i32) -> ColorMap {'), (131, '        assert!(ColorMap::DEFAULT as i32 <= t && t <= ColorMap::BLUE as i32);'), (360, 'impl From<i32> for SparseFormat {'), (361, '    fn from(t: i32) -> SparseFormat {'), (362, '        assert!(SparseFormat::DENSE as i32 <= t && t <= SparseFormat::COO as i32);'), (367, 'impl From<i32> for BinaryOp {'), (368, '    fn from(t: i32) -> BinaryOp {'), (369, '        assert!(BinaryOp::ADD as i32 <= t && t <= BinaryOp::MAX as i32);'), (374, 'impl From<i32> for RandomEngineType {'), (375, '    fn from(t: i32) -> RandomEngineType {'), (376, '        assert!(RandomEngineType::PHILOX_4X32_10 as i32 <= t && t <= RandomEngineType::MERSENNE_GP11213 as i32);')]}",
    "num_lines_added": "30",
    "num_lines_deleted": "30",
    "nloc": "539"
  },
  {
    "file_change_id": "210309650194329",
    "hash": "e7e291709240bd83ca35a12b85d87f074002be7",
    "old_path": "src/vision/mod.rs",
    "new_path": "src/vision/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -6,7 +6,7 @@ use defines::{AfError, HomographyType, MatchType};\n use error::HANDLE_ERROR;\n use util::{AfArray, DimT, Feat, MutAfArray, MutFeat};\n use util::{HasAfEnum, RealFloating, ImageFilterType};\n-use self::libc::{c_void, uint8_t, c_uint, c_int, c_float, c_double, c_longlong};\n+use self::libc::{c_void, c_uint, c_int, c_float, c_double, c_longlong};\n \n // af_sift and af_gloh uses patented algorithms, so didn't add them\n // they are built using installer builds\n@@ -39,7 +39,7 @@ extern {\n                             dist_dim: DimT, n_dist: c_uint, dist_type: c_int) -> c_int;\n \n     fn af_match_template(out: MutAfArray, search_img: AfArray, template_img: AfArray,\n-                         mtype: uint8_t) -> c_int;\n+                         mtype: c_uint) -> c_int;\n \n     fn af_susan(feat: MutFeat, i: AfArray, r: c_uint, d: c_float, g: c_float, f: c_float, e: c_uint) -> c_int;\n \n@@ -405,7 +405,7 @@ pub fn match_template<T>(search_img: &Array<T>,\n     unsafe {\n         let err_val = af_match_template(&mut temp as MutAfArray,\n                           search_img.get() as AfArray, template_img.get() as AfArray,\n-                          mtype as uint8_t);\n+                          mtype as c_uint);\n         HANDLE_ERROR(AfError::from(err_val));\n     }\n     temp.into()\n",
    "diff_parsed": "{'added': [(9, 'use self::libc::{c_void, c_uint, c_int, c_float, c_double, c_longlong};'), (42, '                         mtype: c_uint) -> c_int;'), (408, '                          mtype as c_uint);')], 'deleted': [(9, 'use self::libc::{c_void, uint8_t, c_uint, c_int, c_float, c_double, c_longlong};'), (42, '                         mtype: uint8_t) -> c_int;'), (408, '                          mtype as uint8_t);')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "3",
    "nloc": "265"
  },
  {
    "file_change_id": "86830233547815",
    "hash": "1b643df85ca4a56f7d96105a9eb35e1b917ee48",
    "old_path": "src/go_offset_log.rs",
    "new_path": "src/go_offset_log.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -215,8 +215,7 @@ where\n {\n     // Entry is [payload size: u64, payload ]\n \n-    let mut buf = Vec::with_capacity(frame.data_size);\n-    unsafe { buf.set_len(frame.data_size) };\n+    let mut buf = vec![0; frame.data_size];\n \n     let n = read_at(&mut buf, frame.data_start())?;\n     if n < frame.data_size {\n",
    "diff_parsed": "{'added': [(218, '    let mut buf = vec![0; frame.data_size];')], 'deleted': [(218, '    let mut buf = Vec::with_capacity(frame.data_size);'), (219, '    unsafe { buf.set_len(frame.data_size) };')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "2",
    "nloc": "268"
  },
  {
    "file_change_id": "280587929945738",
    "hash": "1b643df85ca4a56f7d96105a9eb35e1b917ee48",
    "old_path": "src/offset_log.rs",
    "new_path": "src/offset_log.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -335,8 +335,7 @@ where\n     let tail_size = size_of_frame_tail::<ByteType>();\n     let to_read = frame.data_size + tail_size;\n \n-    let mut buf = Vec::with_capacity(to_read);\n-    unsafe { buf.set_len(to_read) };\n+    let mut buf = vec![0; to_read];\n \n     let n = read_at(&mut buf, frame.data_start())?;\n     if n < to_read {\n@@ -353,7 +352,7 @@ where\n             offset: frame.offset,\n             data: buf,\n         },\n-        next: next,\n+        next,\n     })\n }\n \n",
    "diff_parsed": "{'added': [(338, '    let mut buf = vec![0; to_read];'), (355, '        next,')], 'deleted': [(338, '    let mut buf = Vec::with_capacity(to_read);'), (339, '    unsafe { buf.set_len(to_read) };'), (356, '        next: next,')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "3",
    "nloc": "585"
  },
  {
    "file_change_id": "269694635871807",
    "hash": "dd0639bf2876773b66382f47285f7db701f628d",
    "old_path": "src/main.rs",
    "new_path": "src/main.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -106,6 +106,14 @@ struct Server {\n     port_ranges: Vec<(u16, u16)>,\n }\n \n+impl Server {\n+    fn validate_hostname(&self) -> bool {\n+        self.hostname\n+            .chars()\n+            .all(|c| c.is_ascii_alphanumeric() || c == '-')\n+    }\n+}\n+\n // latitude and longitude omitted\n #[derive(serde::Deserialize)]\n struct City {\n@@ -130,13 +138,26 @@ struct ServerList {\n \n impl ServerList {\n     fn new(client: reqwest::blocking::Client, token: &str) -> Self {\n-        client\n+        let server_list = client\n             .get(&format!(\"{}/vpn/servers\", BASE_URL))\n             .bearer_auth(token)\n             .send()\n             .unwrap()\n             .json::<ServerList>()\n-            .unwrap()\n+            .unwrap();\n+        if let Some(server) = server_list\n+            .countries\n+            .iter()\n+            .flat_map(|country| country.cities.iter().flat_map(|city| city.servers.iter()))\n+            .find(|server| !server.validate_hostname())\n+        {\n+            eprintln!(\n+                \"A server contains invalid characters in its hostname: {}\",\n+                server.hostname\n+            );\n+            std::process::exit(3);\n+        }\n+        server_list\n     }\n }\n \n",
    "diff_parsed": "{'added': [(109, 'impl Server {'), (110, '    fn validate_hostname(&self) -> bool {'), (111, '        self.hostname'), (112, '            .chars()'), (113, \"            .all(|c| c.is_ascii_alphanumeric() || c == '-')\"), (114, '    }'), (115, '}'), (141, '        let server_list = client'), (147, '            .unwrap();'), (148, '        if let Some(server) = server_list'), (149, '            .countries'), (150, '            .iter()'), (151, '            .flat_map(|country| country.cities.iter().flat_map(|city| city.servers.iter()))'), (152, '            .find(|server| !server.validate_hostname())'), (153, '        {'), (154, '            eprintln!('), (155, '                \"A server contains invalid characters in its hostname: {}\",'), (156, '                server.hostname'), (157, '            );'), (158, '            std::process::exit(3);'), (159, '        }'), (160, '        server_list')], 'deleted': [(133, '        client'), (139, '            .unwrap()')]}",
    "num_lines_added": "22",
    "num_lines_deleted": "2",
    "nloc": "523"
  },
  {
    "file_change_id": "78666058867366",
    "hash": "f9e8a1c13cca73e356b48f8a16a6bd308f20988",
    "old_path": "src/sync/ms_queue.rs",
    "new_path": "src/sync/ms_queue.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -174,7 +174,7 @@ impl<T> MsQueue<T> {\n                         unsafe {\n                             // signal the thread\n                             (*signal).data = Some(cache.into_data());\n-                            (*signal).ready.store(true, Relaxed);\n+                            (*signal).ready.store(true, Release);\n                             (*signal).thread.unpark();\n                             guard.unlinked(head);\n                             return;\n@@ -295,7 +295,7 @@ impl<T> MsQueue<T> {\n             // case, blocked.\n             match self.push_internal(&guard, tail, node) {\n                 Ok(()) => {\n-                    while !signal.ready.load(Relaxed) {\n+                    while !signal.ready.load(Acquire) {\n                         thread::park();\n                     }\n                     return signal.data.unwrap();\n",
    "diff_parsed": "{'added': [(177, '                            (*signal).ready.store(true, Release);'), (298, '                    while !signal.ready.load(Acquire) {')], 'deleted': [(177, '                            (*signal).ready.store(true, Relaxed);'), (298, '                    while !signal.ready.load(Relaxed) {')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "392"
  },
  {
    "file_change_id": "272391392344056",
    "hash": "f86e6d392326f0e4dc25eeec8b26af36f2b0fbc",
    "old_path": "src/instance.rs",
    "new_path": "src/instance.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -494,9 +494,9 @@ impl<T> std::convert::From<Py<T>> for PyObject\n where\n     T: AsRef<PyAny>,\n {\n+    #[inline]\n     fn from(other: Py<T>) -> Self {\n-        let Py(ptr, _) = other;\n-        Py(ptr, PhantomData)\n+        unsafe { Self::from_non_null(other.into_non_null()) }\n     }\n }\n \n@@ -647,4 +647,14 @@ mod test {\n         };\n         assert_eq!(unsafe { ffi::Py_REFCNT(dict.as_ptr()) }, 1);\n     }\n+\n+    #[test]\n+    fn pyobject_from_py() {\n+        Python::with_gil(|py| {\n+            let dict: Py<PyDict> = PyDict::new(py).into();\n+            let cnt = dict.get_refcnt(py);\n+            let p: PyObject = dict.into();\n+            assert_eq!(p.get_refcnt(py), cnt);\n+        });\n+    }\n }\n",
    "diff_parsed": "{'added': [(497, '    #[inline]'), (499, '        unsafe { Self::from_non_null(other.into_non_null()) }'), (651, '    #[test]'), (652, '    fn pyobject_from_py() {'), (653, '        Python::with_gil(|py| {'), (654, '            let dict: Py<PyDict> = PyDict::new(py).into();'), (655, '            let cnt = dict.get_refcnt(py);'), (656, '            let p: PyObject = dict.into();'), (657, '            assert_eq!(p.get_refcnt(py), cnt);'), (658, '        });'), (659, '    }')], 'deleted': [(498, '        let Py(ptr, _) = other;'), (499, '        Py(ptr, PhantomData)')]}",
    "num_lines_added": "11",
    "num_lines_deleted": "2",
    "nloc": "404"
  },
  {
    "file_change_id": "179308645222324",
    "hash": "45f172cf8407e05cb9ed431f68663ad4f46b232",
    "old_path": "streebog/src/streebog.rs",
    "new_path": "streebog/src/streebog.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -61,12 +61,10 @@ impl StreebogState {\n     }\n \n     fn update_sigma(&mut self, m: &Block) {\n-        let mut over = false;\n+        let mut carry = 0;\n         for (a, b) in self.sigma.iter_mut().zip(m.iter()) {\n-            let (res, loc_over) = (*a).overflowing_add(*b);\n-            *a = res;\n-            if over { *a += 1; }\n-            over = loc_over;\n+            carry = (*a as u16) + (*b as u16) + (carry >> 8);\n+            *a = (carry & 0xFF) as u8;\n         }\n     }\n \n",
    "diff_parsed": "{'added': [(64, '        let mut carry = 0;'), (66, '            carry = (*a as u16) + (*b as u16) + (carry >> 8);'), (67, '            *a = (carry & 0xFF) as u8;')], 'deleted': [(64, '        let mut over = false;'), (66, '            let (res, loc_over) = (*a).overflowing_add(*b);'), (67, '            *a = res;'), (68, '            if over { *a += 1; }'), (69, '            over = loc_over;')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "5",
    "nloc": "137"
  },
  {
    "file_change_id": "152495208799297",
    "hash": "bbe7cc5381c5380b54fb8bbb4f77a3725917ff0",
    "old_path": "src/transport/sendmail/mod.rs",
    "new_path": "src/transport/sendmail/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -120,6 +120,7 @@ impl SendmailTransport {\n         c.arg(\"-i\")\n             .arg(\"-f\")\n             .arg(envelope.from().map(|f| f.as_ref()).unwrap_or(\"\\\"\\\"\"))\n+            .arg(\"--\")\n             .args(envelope.to())\n             .stdin(Stdio::piped())\n             .stdout(Stdio::piped());\n@@ -135,6 +136,7 @@ impl SendmailTransport {\n         c.arg(\"-i\")\n             .arg(\"-f\")\n             .arg(envelope.from().map(|f| f.as_ref()).unwrap_or(\"\\\"\\\"\"))\n+            .arg(\"--\")\n             .args(envelope.to())\n             .stdin(Stdio::piped())\n             .stdout(Stdio::piped());\n@@ -150,6 +152,7 @@ impl SendmailTransport {\n         c.arg(\"-i\")\n             .arg(\"-f\")\n             .arg(envelope.from().map(|f| f.as_ref()).unwrap_or(\"\\\"\\\"\"))\n+            .arg(\"--\")\n             .args(envelope.to())\n             .stdin(Stdio::piped())\n             .stdout(Stdio::piped());\n",
    "diff_parsed": "{'added': [(123, '            .arg(\"--\")'), (139, '            .arg(\"--\")'), (155, '            .arg(\"--\")')], 'deleted': []}",
    "num_lines_added": "3",
    "num_lines_deleted": "0",
    "nloc": "150"
  },
  {
    "file_change_id": "229553211023905",
    "hash": "414bc9e7abac7500312e0324378ec320c079a98",
    "old_path": "src/transport/sendmail/mod.rs",
    "new_path": "src/transport/sendmail/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -117,10 +117,11 @@ impl SendmailTransport {\n \n     fn command(&self, envelope: &Envelope) -> Command {\n         let mut c = Command::new(&self.command);\n-        c.arg(\"-i\")\n-            .arg(\"-f\")\n-            .arg(envelope.from().map(|f| f.as_ref()).unwrap_or(\"\\\"\\\"\"))\n-            .arg(\"--\")\n+        c.arg(\"-i\");\n+        if let Some(from) = envelope.from() {\n+            c.arg(\"-f\").arg(from);\n+        }\n+        c.arg(\"--\")\n             .args(envelope.to())\n             .stdin(Stdio::piped())\n             .stdout(Stdio::piped());\n@@ -133,10 +134,11 @@ impl SendmailTransport {\n \n         let mut c = Command::new(&self.command);\n         c.kill_on_drop(true);\n-        c.arg(\"-i\")\n-            .arg(\"-f\")\n-            .arg(envelope.from().map(|f| f.as_ref()).unwrap_or(\"\\\"\\\"\"))\n-            .arg(\"--\")\n+        c.arg(\"-i\");\n+        if let Some(from) = envelope.from() {\n+            c.arg(\"-f\").arg(from);\n+        }\n+        c.arg(\"--\")\n             .args(envelope.to())\n             .stdin(Stdio::piped())\n             .stdout(Stdio::piped());\n@@ -149,10 +151,11 @@ impl SendmailTransport {\n \n         let mut c = Command::new(&self.command);\n         c.kill_on_drop(true);\n-        c.arg(\"-i\")\n-            .arg(\"-f\")\n-            .arg(envelope.from().map(|f| f.as_ref()).unwrap_or(\"\\\"\\\"\"))\n-            .arg(\"--\")\n+        c.arg(\"-i\");\n+        if let Some(from) = envelope.from() {\n+            c.arg(\"-f\").arg(from);\n+        }\n+        c.arg(\"--\")\n             .args(envelope.to())\n             .stdin(Stdio::piped())\n             .stdout(Stdio::piped());\n",
    "diff_parsed": "{'added': [(120, '        c.arg(\"-i\");'), (121, '        if let Some(from) = envelope.from() {'), (122, '            c.arg(\"-f\").arg(from);'), (123, '        }'), (124, '        c.arg(\"--\")'), (137, '        c.arg(\"-i\");'), (138, '        if let Some(from) = envelope.from() {'), (139, '            c.arg(\"-f\").arg(from);'), (140, '        }'), (141, '        c.arg(\"--\")'), (154, '        c.arg(\"-i\");'), (155, '        if let Some(from) = envelope.from() {'), (156, '            c.arg(\"-f\").arg(from);'), (157, '        }'), (158, '        c.arg(\"--\")')], 'deleted': [(120, '        c.arg(\"-i\")'), (121, '            .arg(\"-f\")'), (122, '            .arg(envelope.from().map(|f| f.as_ref()).unwrap_or(\"\\\\\"\\\\\"\"))'), (123, '            .arg(\"--\")'), (136, '        c.arg(\"-i\")'), (137, '            .arg(\"-f\")'), (138, '            .arg(envelope.from().map(|f| f.as_ref()).unwrap_or(\"\\\\\"\\\\\"\"))'), (139, '            .arg(\"--\")'), (152, '        c.arg(\"-i\")'), (153, '            .arg(\"-f\")'), (154, '            .arg(envelope.from().map(|f| f.as_ref()).unwrap_or(\"\\\\\"\\\\\"\"))'), (155, '            .arg(\"--\")')]}",
    "num_lines_added": "15",
    "num_lines_deleted": "12",
    "nloc": "153"
  },
  {
    "file_change_id": "121753516987745",
    "hash": "76bc9b5fbae73262307c41e72dbcfa0796073f3",
    "old_path": "src/array.rs",
    "new_path": "src/array.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -174,26 +174,24 @@ macro_rules! impl_array {\n         where\n             F: FnMut(T) -> U,\n         {\n-            fn map_array(mut values: [T; $size], mut f: F) -> Self {\n+            fn map_array(values: [T; $size], mut f: F) -> Self {\n                 use std::{\n-                    mem::forget,\n+                    mem::{ManuallyDrop, MaybeUninit},\n                     ptr::{read, write},\n                 };\n \n+                // Use `ManuallyDrop<_>` to guard against panic safety issue.\n+                // Upon panic in `f`, `values` isn't dropped\n+                // and thus item copied by `read()` is dropped only once.\n+                let mut values = ManuallyDrop::new(values);\n                 unsafe {\n-                    // All elements of `result` is written.\n-                    // Each element of `values` read once and then forgotten.\n-                    // Hence safe in case `f` never panics.\n-                    // TODO: Make it panic-safe.\n-                    let mut result: ::std::mem::MaybeUninit<[U; $size]> =\n-                        ::std::mem::MaybeUninit::zeroed();\n+                    let mut result: MaybeUninit<[U; $size]> = MaybeUninit::zeroed();\n                     for i in 0..$size {\n                         write(\n                             result.as_mut_ptr().cast::<U>().add(i),\n                             f(read(&mut values[i])),\n                         );\n                     }\n-                    forget(values);\n                     result.assume_init()\n                 }\n             }\n",
    "diff_parsed": "{'added': [(177, '            fn map_array(values: [T; $size], mut f: F) -> Self {'), (179, '                    mem::{ManuallyDrop, MaybeUninit},'), (186, '                let mut values = ManuallyDrop::new(values);'), (188, '                    let mut result: MaybeUninit<[U; $size]> = MaybeUninit::zeroed();')], 'deleted': [(177, '            fn map_array(mut values: [T; $size], mut f: F) -> Self {'), (179, '                    mem::forget,'), (188, '                    let mut result: ::std::mem::MaybeUninit<[U; $size]> ='), (189, '                        ::std::mem::MaybeUninit::zeroed();'), (196, '                    forget(values);')]}",
    "num_lines_added": "4",
    "num_lines_deleted": "5",
    "nloc": "265"
  },
  {
    "file_change_id": "257848254834607",
    "hash": "ee5d1cf3b2df709ae1521d11521f38e335c45be",
    "old_path": "tokio-rustls/src/common/mod.rs",
    "new_path": "tokio-rustls/src/common/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -218,7 +218,10 @@ impl<'a, IO: AsyncRead + AsyncWrite + Unpin, S: Session> Stream<'a, IO, S> {\n             while !self.eof && self.session.wants_read() {\n                 match self.read_io(cx) {\n                     Poll::Ready(Ok(0)) => self.eof = true,\n-                    Poll::Ready(Ok(n)) => rdlen += n,\n+                    Poll::Ready(Ok(n)) => {\n+                        rdlen += n;\n+                        self.process_new_packets(cx)?;\n+                    }\n                     Poll::Pending => {\n                         read_would_block = true;\n                         break;\n@@ -227,8 +230,6 @@ impl<'a, IO: AsyncRead + AsyncWrite + Unpin, S: Session> Stream<'a, IO, S> {\n                 }\n             }\n \n-            self.process_new_packets(cx)?;\n-\n             return match (self.eof, self.session.is_handshaking()) {\n                 (true, true) => {\n                     let err = io::Error::new(io::ErrorKind::UnexpectedEof, \"tls handshake eof\");\n@@ -266,7 +267,7 @@ impl<'a, IO: AsyncRead + AsyncWrite + Unpin, S: Session> AsyncRead for Stream<'a\n                         self.eof = true;\n                         break;\n                     }\n-                    Poll::Ready(Ok(_)) => (),\n+                    Poll::Ready(Ok(_)) => self.process_new_packets(cx)?,\n                     Poll::Pending => {\n                         would_block = true;\n                         break;\n@@ -275,8 +276,6 @@ impl<'a, IO: AsyncRead + AsyncWrite + Unpin, S: Session> AsyncRead for Stream<'a\n                 }\n             }\n \n-            self.process_new_packets(cx)?;\n-\n             return match self.session.read(&mut buf[pos..]) {\n                 Ok(0) if pos == 0 && would_block => Poll::Pending,\n                 Ok(n) if self.eof || would_block => Poll::Ready(Ok(pos + n)),\n",
    "diff_parsed": "{'added': [(221, '                    Poll::Ready(Ok(n)) => {'), (222, '                        rdlen += n;'), (223, '                        self.process_new_packets(cx)?;'), (224, '                    }'), (270, '                    Poll::Ready(Ok(_)) => self.process_new_packets(cx)?,')], 'deleted': [(221, '                    Poll::Ready(Ok(n)) => rdlen += n,'), (230, '            self.process_new_packets(cx)?;'), (269, '                    Poll::Ready(Ok(_)) => (),'), (278, '            self.process_new_packets(cx)?;')]}",
    "num_lines_added": "5",
    "num_lines_deleted": "4",
    "nloc": "333"
  },
  {
    "file_change_id": "55369979690336",
    "hash": "a986a9335d591fa5c826157d1674d47aa525357",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -50,7 +50,7 @@ pub struct ReadTicket<T> {\n     data: Arc<UnsafeCell<T>>,\n }\n \n-unsafe impl<T> Send for ReadTicket<T> {}\n+unsafe impl<T: Send> Send for ReadTicket<T> {}\n \n #[cfg(not(feature = \"futures\"))]\n impl<T> ReadTicket<T> {\n@@ -112,7 +112,7 @@ pub struct WriteTicket<T> {\n     data: Arc<UnsafeCell<T>>,\n }\n \n-unsafe impl<T> Send for WriteTicket<T> {}\n+unsafe impl<T: Send> Send for WriteTicket<T> {}\n \n #[cfg(not(feature = \"futures\"))]\n impl<T> WriteTicket<T> {\n",
    "diff_parsed": "{'added': [(53, 'unsafe impl<T: Send> Send for ReadTicket<T> {}'), (115, 'unsafe impl<T: Send> Send for WriteTicket<T> {}')], 'deleted': [(53, 'unsafe impl<T> Send for ReadTicket<T> {}'), (115, 'unsafe impl<T> Send for WriteTicket<T> {}')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "139"
  },
  {
    "file_change_id": "100181359880475",
    "hash": "1a2efcdbe68e5e7fd0a05836ac32d2cde78a0b2",
    "old_path": "tests/script.rs",
    "new_path": "tests/script.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -51,6 +51,7 @@ macro_rules! test_cases {\n                 out_json.reverse();\n \n                 let mut results = Vec::new();\n+                let mut state = Value::null();\n                 for (id, mut json) in in_json.into_iter().enumerate() {\n                     let uri = EventOriginUri{\n                         host: \"test\".into(),\n@@ -62,7 +63,6 @@ macro_rules! test_cases {\n                     };\n                     let context = EventContext::new(id as u64, Some(&uri));\n                     let mut meta = Value::from(Object::default());\n-                    let mut state = Value::null();\n                     match script.run(&context, AggrType::Tick, &mut json, &mut state, &mut meta)? {\n                         Return::Drop => (),\n                         Return::EmitEvent{..} => results.push(json),\n@@ -154,6 +154,7 @@ test_cases!(\n     // TODO\n     // const_in_const_lookup,\n     // INSERT\n+    merge_assign_target_state,\n     expr_path,\n     patch_default,\n     patch_default_key,\n@@ -186,7 +187,7 @@ test_cases!(\n     heredoc_quoted_curly,\n     string_interpolation_import,\n     string_interpolation_prefix,\n-    patch_in_place,\n+    patch_assign_target,\n     tuple_pattern,\n     pattern_cmp,\n     pass_args,\n",
    "diff_parsed": "{'added': [(54, '                let mut state = Value::null();'), (157, '    merge_assign_target_state,'), (190, '    patch_assign_target,')], 'deleted': [(65, '                    let mut state = Value::null();'), (189, '    patch_in_place,')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "2",
    "nloc": "179"
  },
  {
    "file_change_id": "71346060664198",
    "hash": "1a2efcdbe68e5e7fd0a05836ac32d2cde78a0b2",
    "old_path": "tests/script_runtime_error.rs",
    "new_path": "tests/script_runtime_error.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -105,10 +105,10 @@ macro_rules! ignore_cases {\n                 file.read_to_string(&mut err)?;\n                 let _err = err.trim();\n \n+                let mut state = Value::null();\n                 if let Some(mut json) =  in_json.pop() {\n                     let context = EventContext::new(0, None);\n                     let mut meta = Value::object();\n-                    let mut state = Value::null();\n                     let s = script.run(&context, AggrType::Tick, &mut json, &mut state, &mut meta);\n                     if let Err(e) = s {\n                         let mut h = Dumb::new();\n@@ -144,8 +144,8 @@ test_cases!(\n     function_error_n,\n     match_bad_guard_type,\n     match_no_clause_hit,\n-    merge_in_place_new_no_object,\n-    merge_in_place_target_no_object,\n+    merge_assign_target_new_no_object,\n+    merge_assign_target_target_no_object,\n     merge_new_no_object,\n     merge_target_no_object,\n     missing_local,\n",
    "diff_parsed": "{'added': [(108, '                let mut state = Value::null();'), (147, '    merge_assign_target_new_no_object,'), (148, '    merge_assign_target_target_no_object,')], 'deleted': [(111, '                    let mut state = Value::null();'), (147, '    merge_in_place_new_no_object,'), (148, '    merge_in_place_target_no_object,')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "3",
    "nloc": "149"
  },
  {
    "file_change_id": "70895921779043",
    "hash": "1a2efcdbe68e5e7fd0a05836ac32d2cde78a0b2",
    "old_path": "tremor-script/src/ast.rs",
    "new_path": "tremor-script/src/ast.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -961,10 +961,6 @@ pub enum Expr<'script> {\n     Match(Box<Match<'script, Self>>),\n     /// IfElse style match expression\n     IfElse(Box<IfElse<'script, Self>>),\n-    /// In place patch expression\n-    PatchInPlace(Box<Patch<'script>>),\n-    /// In place merge expression\n-    MergeInPlace(Box<Merge<'script>>),\n     /// Assignment expression\n     Assign {\n         /// Id\n",
    "diff_parsed": "{'added': [], 'deleted': [(965, \"    PatchInPlace(Box<Patch<'script>>),\"), (967, \"    MergeInPlace(Box<Merge<'script>>),\")]}",
    "num_lines_added": "0",
    "num_lines_deleted": "2",
    "nloc": "2420"
  },
  {
    "file_change_id": "77864718264704",
    "hash": "1a2efcdbe68e5e7fd0a05836ac32d2cde78a0b2",
    "old_path": "tremor-script/src/ast/base_expr.rs",
    "new_path": "tremor-script/src/ast/base_expr.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -248,8 +248,6 @@ impl<'script> BaseExpr for Expr<'script> {\n             Expr::Emit(e) => e.mid(),\n             Expr::Imut(e) => e.mid(),\n             Expr::Match(e) => e.mid(),\n-            Expr::MergeInPlace(e) => e.mid(),\n-            Expr::PatchInPlace(e) => e.mid(),\n             Expr::IfElse(e) => e.mid(),\n         }\n     }\n",
    "diff_parsed": "{'added': [], 'deleted': [(251, '            Expr::MergeInPlace(e) => e.mid(),'), (252, '            Expr::PatchInPlace(e) => e.mid(),')]}",
    "num_lines_added": "0",
    "num_lines_deleted": "2",
    "nloc": "497"
  },
  {
    "file_change_id": "232211839169880",
    "hash": "1a2efcdbe68e5e7fd0a05836ac32d2cde78a0b2",
    "old_path": "tremor-script/src/ast/raw.rs",
    "new_path": "tremor-script/src/ast/raw.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -18,14 +18,14 @@\n \n use crate::{\n     ast::{\n-        base_expr, eq::AstEq, query, upable::Upable, ArrayPattern, ArrayPredicatePattern,\n-        AssignPattern, BinExpr, BinOpKind, Bytes, BytesPart, ClauseGroup, Comprehension,\n-        ComprehensionCase, Costly, DefaultCase, EmitExpr, EventPath, Expr, ExprPath, Expression,\n-        Field, FnDecl, FnDoc, Helper, Ident, IfElse, ImutExpr, ImutExprInt, Invocable, Invoke,\n-        InvokeAggr, InvokeAggrFn, List, Literal, LocalPath, Match, Merge, MetadataPath, ModDoc,\n-        NodeMetas, Patch, PatchOperation, Path, Pattern, PredicateClause, PredicatePattern, Record,\n-        RecordPattern, Recur, ReservedPath, Script, Segment, StatePath, StrLitElement, StringLit,\n-        TestExpr, TuplePattern, UnaryExpr, UnaryOpKind,\n+        base_expr, query, upable::Upable, ArrayPattern, ArrayPredicatePattern, AssignPattern,\n+        BinExpr, BinOpKind, Bytes, BytesPart, ClauseGroup, Comprehension, ComprehensionCase,\n+        Costly, DefaultCase, EmitExpr, EventPath, Expr, ExprPath, Expression, Field, FnDecl, FnDoc,\n+        Helper, Ident, IfElse, ImutExpr, ImutExprInt, Invocable, Invoke, InvokeAggr, InvokeAggrFn,\n+        List, Literal, LocalPath, Match, Merge, MetadataPath, ModDoc, NodeMetas, Patch,\n+        PatchOperation, Path, Pattern, PredicateClause, PredicatePattern, Record, RecordPattern,\n+        Recur, ReservedPath, Script, Segment, StatePath, StrLitElement, StringLit, TestExpr,\n+        TuplePattern, UnaryExpr, UnaryOpKind,\n     },\n     errors::{\n         err_generic, error_generic, error_missing_effector, error_oops, Error, ErrorKind, Result,\n@@ -646,28 +646,16 @@ impl<'script> Upable<'script> for ExprRaw<'script> {\n                 let path = a.path.up(helper)?;\n                 let mid = helper.add_meta(a.start, a.end);\n                 match a.expr.up(helper)? {\n-                    Expr::Imut(ImutExprInt::Merge(m)) => {\n-                        if path.ast_eq(&m.target) {\n-                            Expr::MergeInPlace(Box::new(*m))\n-                        } else {\n-                            Expr::Assign {\n-                                mid,\n-                                path,\n-                                expr: Box::new(ImutExprInt::Merge(m).into()),\n-                            }\n-                        }\n-                    }\n-                    Expr::Imut(ImutExprInt::Patch(m)) => {\n-                        if path.ast_eq(&m.target) {\n-                            Expr::PatchInPlace(Box::new(*m))\n-                        } else {\n-                            Expr::Assign {\n-                                mid,\n-                                path,\n-                                expr: Box::new(ImutExprInt::Patch(m).into()),\n-                            }\n-                        }\n-                    }\n+                    Expr::Imut(ImutExprInt::Merge(m)) => Expr::Assign {\n+                        mid,\n+                        path,\n+                        expr: Box::new(ImutExprInt::Merge(m).into()),\n+                    },\n+                    Expr::Imut(ImutExprInt::Patch(m)) => Expr::Assign {\n+                        mid,\n+                        path,\n+                        expr: Box::new(ImutExprInt::Patch(m).into()),\n+                    },\n                     expr => Expr::Assign {\n                         mid,\n                         path,\n",
    "diff_parsed": "{'added': [(21, '        base_expr, query, upable::Upable, ArrayPattern, ArrayPredicatePattern, AssignPattern,'), (22, '        BinExpr, BinOpKind, Bytes, BytesPart, ClauseGroup, Comprehension, ComprehensionCase,'), (23, '        Costly, DefaultCase, EmitExpr, EventPath, Expr, ExprPath, Expression, Field, FnDecl, FnDoc,'), (24, '        Helper, Ident, IfElse, ImutExpr, ImutExprInt, Invocable, Invoke, InvokeAggr, InvokeAggrFn,'), (25, '        List, Literal, LocalPath, Match, Merge, MetadataPath, ModDoc, NodeMetas, Patch,'), (26, '        PatchOperation, Path, Pattern, PredicateClause, PredicatePattern, Record, RecordPattern,'), (27, '        Recur, ReservedPath, Script, Segment, StatePath, StrLitElement, StringLit, TestExpr,'), (28, '        TuplePattern, UnaryExpr, UnaryOpKind,'), (649, '                    Expr::Imut(ImutExprInt::Merge(m)) => Expr::Assign {'), (650, '                        mid,'), (651, '                        path,'), (652, '                        expr: Box::new(ImutExprInt::Merge(m).into()),'), (653, '                    },'), (654, '                    Expr::Imut(ImutExprInt::Patch(m)) => Expr::Assign {'), (655, '                        mid,'), (656, '                        path,'), (657, '                        expr: Box::new(ImutExprInt::Patch(m).into()),'), (658, '                    },')], 'deleted': [(21, '        base_expr, eq::AstEq, query, upable::Upable, ArrayPattern, ArrayPredicatePattern,'), (22, '        AssignPattern, BinExpr, BinOpKind, Bytes, BytesPart, ClauseGroup, Comprehension,'), (23, '        ComprehensionCase, Costly, DefaultCase, EmitExpr, EventPath, Expr, ExprPath, Expression,'), (24, '        Field, FnDecl, FnDoc, Helper, Ident, IfElse, ImutExpr, ImutExprInt, Invocable, Invoke,'), (25, '        InvokeAggr, InvokeAggrFn, List, Literal, LocalPath, Match, Merge, MetadataPath, ModDoc,'), (26, '        NodeMetas, Patch, PatchOperation, Path, Pattern, PredicateClause, PredicatePattern, Record,'), (27, '        RecordPattern, Recur, ReservedPath, Script, Segment, StatePath, StrLitElement, StringLit,'), (28, '        TestExpr, TuplePattern, UnaryExpr, UnaryOpKind,'), (649, '                    Expr::Imut(ImutExprInt::Merge(m)) => {'), (650, '                        if path.ast_eq(&m.target) {'), (651, '                            Expr::MergeInPlace(Box::new(*m))'), (652, '                        } else {'), (653, '                            Expr::Assign {'), (654, '                                mid,'), (655, '                                path,'), (656, '                                expr: Box::new(ImutExprInt::Merge(m).into()),'), (657, '                            }'), (658, '                        }'), (659, '                    }'), (660, '                    Expr::Imut(ImutExprInt::Patch(m)) => {'), (661, '                        if path.ast_eq(&m.target) {'), (662, '                            Expr::PatchInPlace(Box::new(*m))'), (663, '                        } else {'), (664, '                            Expr::Assign {'), (665, '                                mid,'), (666, '                                path,'), (667, '                                expr: Box::new(ImutExprInt::Patch(m).into()),'), (668, '                            }'), (669, '                        }'), (670, '                    }')]}",
    "num_lines_added": "18",
    "num_lines_deleted": "30",
    "nloc": "2394"
  },
  {
    "file_change_id": "257522639437419",
    "hash": "1a2efcdbe68e5e7fd0a05836ac32d2cde78a0b2",
    "old_path": "tremor-script/src/ast/to_static.rs",
    "new_path": "tremor-script/src/ast/to_static.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -159,8 +159,6 @@ impl<'script> Expr<'script> {\n         match self {\n             Expr::Match(e) => Expr::Match(Box::new(e.into_static())),\n             Expr::IfElse(e) => Expr::IfElse(Box::new(e.into_static())),\n-            Expr::PatchInPlace(e) => Expr::PatchInPlace(Box::new(e.into_static())),\n-            Expr::MergeInPlace(e) => Expr::MergeInPlace(Box::new(e.into_static())),\n             Expr::Assign { mid, path, expr } => Expr::Assign {\n                 mid,\n                 path: path.into_static(),\n",
    "diff_parsed": "{'added': [], 'deleted': [(162, '            Expr::PatchInPlace(e) => Expr::PatchInPlace(Box::new(e.into_static())),'), (163, '            Expr::MergeInPlace(e) => Expr::MergeInPlace(Box::new(e.into_static())),')]}",
    "num_lines_added": "0",
    "num_lines_deleted": "2",
    "nloc": "1036"
  },
  {
    "file_change_id": "121095756654566",
    "hash": "1a2efcdbe68e5e7fd0a05836ac32d2cde78a0b2",
    "old_path": "tremor-script/src/interpreter/expr.rs",
    "new_path": "tremor-script/src/interpreter/expr.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -13,24 +13,23 @@\n // limitations under the License.\n \n use super::{\n-    merge_values, patch_value, resolve, resolve_value, set_local_shadow, test_guard,\n-    test_predicate_expr, Env, ExecOpts, LocalStack, NULL,\n+    resolve, resolve_value, set_local_shadow, test_guard, test_predicate_expr, Env, ExecOpts,\n+    LocalStack, NULL,\n };\n use crate::errors::{\n     error_assign_array, error_assign_to_const, error_bad_key_err, error_invalid_assign_target,\n-    error_need_obj, error_need_obj_err, error_no_clause_hit, Result,\n+    error_need_obj_err, error_no_clause_hit, Result,\n };\n use crate::prelude::*;\n use crate::registry::RECUR_PTR;\n use crate::{\n     ast::{\n         BaseExpr, ClauseGroup, ClausePreCondition, Comprehension, DefaultCase, EmitExpr, EventPath,\n-        Expr, IfElse, ImutExprInt, Match, Merge, Patch, Path, Segment,\n+        Expr, IfElse, ImutExprInt, Match, Path, Segment,\n     },\n     errors::error_oops_err,\n };\n use crate::{stry, Value};\n-use matches::matches;\n use std::mem;\n use std::{\n     borrow::{Borrow, Cow},\n@@ -219,104 +218,6 @@ impl<'script> Expr<'script> {\n         }\n     }\n \n-    fn patch_in_place<'run, 'event>(\n-        opts: ExecOpts,\n-        env: &'run Env<'run, 'event>,\n-        event: &'run Value<'event>,\n-        state: &'run Value<'static>,\n-        meta: &'run Value<'event>,\n-        local: &'run LocalStack<'event>,\n-        expr: &'run Patch<'event>,\n-    ) -> Result<Cow<'run, Value<'event>>> {\n-        // This function is called when we encounter code that consumes a value\n-        // to patch it. So the following code:\n-        // ```tremor\n-        // let event = patch event of insert \"key\" => \"value\" end\n-        // ```\n-        // When executed on it's own would clone the event, add a key and\n-        // overwrite original event.\n-        //\n-        // We optimise this as:\n-        // ```\n-        // patch_in_place event of insert \"key\" => \"value\" end\n-        // ```\n-        //\n-        // This code is generated in impl Upable for ExprRaw where the following\n-        // checks are performed:\n-        //\n-        // 1) the patch is on the RHS of an assignment\n-        // 2) the path of the assigned value and the path of the patched\n-        //    expression are identical.\n-        //\n-        // In turn this guarantees (at compile time):\n-        //\n-        // 1) The target (`expr`) is a path lookup\n-        // 2) The target is not a known constant as otherwise the assignment\n-        //    will complan\n-        // 3) this leave the `expr` to be either a local, the event, the state,\n-        //    metadata or a subkey thereof.\n-        //\n-        // And the following guarantees at run time:\n-        //\n-        // 1) the `expr` is an existing key of the mentioned categories,\n-        //    otherwise `expr.target.run` will error.\n-        // 2) `value` will never be owned (however the resolve function is\n-        //    generic so it needs to return a Cow)\n-\n-        let value: Cow<'run, Value<'event>> =\n-            stry!(expr.target.run(opts, env, event, state, meta, local));\n-        debug_assert!(\n-            !matches!(value, Cow::Owned(_)),\n-            \"We should never see a owned value here as patch_in_place is only ever called on existing data in event, state, meta or local\"\n-        );\n-        let v: &Value<'event> = value.borrow();\n-        // ALLOW: https://github.com/tremor-rs/tremor-runtime/issues/1032\n-        #[allow(mutable_transmutes, clippy::transmute_ptr_to_ptr)]\n-        // ALLOW: https://github.com/tremor-rs/tremor-runtime/issues/1032\n-        let v: &mut Value<'event> = unsafe { mem::transmute(v) };\n-        stry!(patch_value(opts, env, event, state, meta, local, v, expr));\n-        Ok(value)\n-    }\n-\n-    fn merge_in_place<'run, 'event>(\n-        &'run self,\n-        opts: ExecOpts,\n-        env: &'run Env<'run, 'event>,\n-        event: &'run mut Value<'event>,\n-        state: &'run mut Value<'static>,\n-        meta: &'run mut Value<'event>,\n-        local: &'run mut LocalStack<'event>,\n-        expr: &'run Merge<'event>,\n-    ) -> Result<Cow<'run, Value<'event>>> {\n-        // Please see the soundness reasoning in `patch_in_place` for details\n-        // those functions perform the same function just with slighty different\n-        // operations.\n-        let value_cow: Cow<'run, Value<'event>> =\n-            stry!(expr.target.run(opts, env, event, state, meta, local));\n-        debug_assert!(\n-            !matches!(value_cow, Cow::Owned(_)),\n-            \"We should never see a owned value here as merge_in_place is only ever called on existing data in event, state, meta or local\"\n-        );\n-\n-        if value_cow.is_object() {\n-            let value: &Value<'event> = value_cow.borrow();\n-            // ALLOW: https://github.com/tremor-rs/tremor-runtime/issues/1032\n-            #[allow(mutable_transmutes, clippy::transmute_ptr_to_ptr)]\n-            // ALLOW: https://github.com/tremor-rs/tremor-runtime/issues/1032\n-            let value: &mut Value<'event> = unsafe { mem::transmute(value) };\n-            let replacement = stry!(expr.expr.run(opts, env, event, state, meta, local,));\n-\n-            if replacement.is_object() {\n-                stry!(merge_values(self, &expr.expr, value, &replacement));\n-                Ok(value_cow)\n-            } else {\n-                error_need_obj(self, &expr.expr, replacement.value_type(), env.meta)\n-            }\n-        } else {\n-            error_need_obj(self, &expr.target, value_cow.value_type(), env.meta)\n-        }\n-    }\n-\n     // TODO: Quite some overlap with `ImutExprInt::comprehension`\n     fn comprehension<'run, 'event>(\n         &'run self,\n@@ -641,12 +542,6 @@ impl<'script> Expr<'script> {\n             }\n             Expr::Match(ref expr) => self.match_expr(opts, env, event, state, meta, local, expr),\n             Expr::IfElse(ref expr) => self.if_expr(opts, env, event, state, meta, local, expr),\n-            Expr::MergeInPlace(ref expr) => self\n-                .merge_in_place(opts, env, event, state, meta, local, expr)\n-                .map(Cont::Cont),\n-            Expr::PatchInPlace(ref expr) => {\n-                Self::patch_in_place(opts, env, event, state, meta, local, expr).map(Cont::Cont)\n-            }\n             Expr::Comprehension(ref expr) => {\n                 self.comprehension(opts, env, event, state, meta, local, expr)\n             }\n",
    "diff_parsed": "{'added': [(16, '    resolve, resolve_value, set_local_shadow, test_guard, test_predicate_expr, Env, ExecOpts,'), (17, '    LocalStack, NULL,'), (21, '    error_need_obj_err, error_no_clause_hit, Result,'), (28, '        Expr, IfElse, ImutExprInt, Match, Path, Segment,')], 'deleted': [(16, '    merge_values, patch_value, resolve, resolve_value, set_local_shadow, test_guard,'), (17, '    test_predicate_expr, Env, ExecOpts, LocalStack, NULL,'), (21, '    error_need_obj, error_need_obj_err, error_no_clause_hit, Result,'), (28, '        Expr, IfElse, ImutExprInt, Match, Merge, Patch, Path, Segment,'), (33, 'use matches::matches;'), (222, \"    fn patch_in_place<'run, 'event>(\"), (223, '        opts: ExecOpts,'), (224, \"        env: &'run Env<'run, 'event>,\"), (225, \"        event: &'run Value<'event>,\"), (226, \"        state: &'run Value<'static>,\"), (227, \"        meta: &'run Value<'event>,\"), (228, \"        local: &'run LocalStack<'event>,\"), (229, \"        expr: &'run Patch<'event>,\"), (230, \"    ) -> Result<Cow<'run, Value<'event>>> {\"), (266, \"        let value: Cow<'run, Value<'event>> =\"), (267, '            stry!(expr.target.run(opts, env, event, state, meta, local));'), (268, '        debug_assert!('), (269, '            !matches!(value, Cow::Owned(_)),'), (270, '            \"We should never see a owned value here as patch_in_place is only ever called on existing data in event, state, meta or local\"'), (271, '        );'), (272, \"        let v: &Value<'event> = value.borrow();\"), (274, '        #[allow(mutable_transmutes, clippy::transmute_ptr_to_ptr)]'), (276, \"        let v: &mut Value<'event> = unsafe { mem::transmute(v) };\"), (277, '        stry!(patch_value(opts, env, event, state, meta, local, v, expr));'), (278, '        Ok(value)'), (279, '    }'), (281, \"    fn merge_in_place<'run, 'event>(\"), (282, \"        &'run self,\"), (283, '        opts: ExecOpts,'), (284, \"        env: &'run Env<'run, 'event>,\"), (285, \"        event: &'run mut Value<'event>,\"), (286, \"        state: &'run mut Value<'static>,\"), (287, \"        meta: &'run mut Value<'event>,\"), (288, \"        local: &'run mut LocalStack<'event>,\"), (289, \"        expr: &'run Merge<'event>,\"), (290, \"    ) -> Result<Cow<'run, Value<'event>>> {\"), (294, \"        let value_cow: Cow<'run, Value<'event>> =\"), (295, '            stry!(expr.target.run(opts, env, event, state, meta, local));'), (296, '        debug_assert!('), (297, '            !matches!(value_cow, Cow::Owned(_)),'), (298, '            \"We should never see a owned value here as merge_in_place is only ever called on existing data in event, state, meta or local\"'), (299, '        );'), (301, '        if value_cow.is_object() {'), (302, \"            let value: &Value<'event> = value_cow.borrow();\"), (304, '            #[allow(mutable_transmutes, clippy::transmute_ptr_to_ptr)]'), (306, \"            let value: &mut Value<'event> = unsafe { mem::transmute(value) };\"), (307, '            let replacement = stry!(expr.expr.run(opts, env, event, state, meta, local,));'), (309, '            if replacement.is_object() {'), (310, '                stry!(merge_values(self, &expr.expr, value, &replacement));'), (311, '                Ok(value_cow)'), (312, '            } else {'), (313, '                error_need_obj(self, &expr.expr, replacement.value_type(), env.meta)'), (314, '            }'), (315, '        } else {'), (316, '            error_need_obj(self, &expr.target, value_cow.value_type(), env.meta)'), (317, '        }'), (318, '    }'), (644, '            Expr::MergeInPlace(ref expr) => self'), (645, '                .merge_in_place(opts, env, event, state, meta, local, expr)'), (646, '                .map(Cont::Cont),'), (647, '            Expr::PatchInPlace(ref expr) => {'), (648, '                Self::patch_in_place(opts, env, event, state, meta, local, expr).map(Cont::Cont)'), (649, '            }')]}",
    "num_lines_added": "4",
    "num_lines_deleted": "63",
    "nloc": "495"
  },
  {
    "file_change_id": "193174160667121",
    "hash": "3bbb69d25b9ca995a4c25838781f89c62f2ca92",
    "old_path": "tremor-cli/src/run.rs",
    "new_path": "tremor-cli/src/run.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -40,7 +40,8 @@ struct Ingress {\n     codec: Box<dyn Codec>,\n }\n \n-type IngressHandler<T> = dyn Fn(&mut T, &mut u64, &mut Egress, u64, Value) -> Result<()>;\n+type IngressHandler<T> =\n+    dyn Fn(&mut T, &mut u64, &mut Egress, &mut Value<'static>, u64, Value) -> Result<()>;\n \n impl Ingress {\n     fn from_args(matches: &ArgMatches) -> Result<Self> {\n@@ -86,6 +87,7 @@ impl Ingress {\n         mut egress: &mut Egress,\n         handler: &IngressHandler<T>,\n     ) -> Result<()> {\n+        let mut state: Value<'static> = Value::null();\n         loop {\n             match self.buffer.read(&mut self.buf) {\n                 Ok(0) => {\n@@ -104,7 +106,6 @@ impl Ingress {\n                             Ok(None) => continue,\n                             Err(e) => return Err(e.into()),\n                         };\n-                        let event = event.clone();\n \n                         if self.is_interactive {\n                             eprintln!(\n@@ -114,7 +115,7 @@ impl Ingress {\n                             );\n                             highlight(self.is_pretty, &event)?;\n                         }\n-                        handler(runnable, &mut id, &mut egress, at, event)?;\n+                        handler(runnable, &mut id, &mut egress, &mut state, at, event)?;\n                     }\n                 }\n                 Err(e) => {\n@@ -245,15 +246,14 @@ fn run_tremor_source(matches: &ArgMatches, src: String) -> Result<()> {\n                 &mut script,\n                 id,\n                 &mut egress,\n-                &move |runnable, _id, egress, at, event| {\n+                &move |runnable, _id, egress, state, at, event| {\n                     let mut global_map = Value::object();\n-                    let mut state = Value::null();\n                     let mut event = event.clone_static();\n                     match runnable.run(\n                         &EventContext::new(at, None),\n                         AggrType::Tick,\n                         &mut event,\n-                        &mut state,\n+                        state,\n                         &mut global_map,\n                     ) {\n                         Ok(r) => egress.process(&src, &event, r),\n@@ -340,7 +340,7 @@ fn run_trickle_source(matches: &ArgMatches, src: String) -> Result<()> {\n         &mut pipeline,\n         id,\n         &mut egress,\n-        &move |runnable, id, egress, at, event| {\n+        &move |runnable, id, egress, _state, at, event| {\n             let value = EventPayload::new(vec![], |_| ValueAndMeta::from(event.clone_static()));\n \n             let mut continuation = vec![];\n",
    "diff_parsed": "{'added': [(43, 'type IngressHandler<T> ='), (44, \"    dyn Fn(&mut T, &mut u64, &mut Egress, &mut Value<'static>, u64, Value) -> Result<()>;\"), (90, \"        let mut state: Value<'static> = Value::null();\"), (118, '                        handler(runnable, &mut id, &mut egress, &mut state, at, event)?;'), (249, '                &move |runnable, _id, egress, state, at, event| {'), (256, '                        state,'), (343, '        &move |runnable, id, egress, _state, at, event| {')], 'deleted': [(43, 'type IngressHandler<T> = dyn Fn(&mut T, &mut u64, &mut Egress, u64, Value) -> Result<()>;'), (107, '                        let event = event.clone();'), (117, '                        handler(runnable, &mut id, &mut egress, at, event)?;'), (248, '                &move |runnable, _id, egress, at, event| {'), (250, '                    let mut state = Value::null();'), (256, '                        &mut state,'), (343, '        &move |runnable, id, egress, at, event| {')]}",
    "num_lines_added": "7",
    "num_lines_deleted": "7",
    "nloc": "367"
  },
  {
    "file_change_id": "220134103720549",
    "hash": "96ccccd55ddbff7f03a9d484f52d1080f40eae8",
    "old_path": "sha2/src/sha512/x86.rs",
    "new_path": "sha2/src/sha512/x86.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -106,8 +106,8 @@ unsafe fn load_data_avx2(\n \n     macro_rules! unrolled_iterations {\n         ($($i:literal),*) => {$(\n-            x[$i] = _mm256_insertf128_si256(x[$i], _mm_loadu_si128(data.add($i) as *const _), 1);\n-            x[$i] = _mm256_insertf128_si256(x[$i], _mm_loadu_si128(data.add($i + 1) as *const _), 0);\n+            x[$i] = _mm256_insertf128_si256(x[$i], _mm_loadu_si128(data.add(8 + $i) as *const _), 1);\n+            x[$i] = _mm256_insertf128_si256(x[$i], _mm_loadu_si128(data.add($i) as *const _), 0);\n \n             x[$i] = _mm256_shuffle_epi8(x[$i], MASK);\n \n",
    "diff_parsed": "{'added': [(109, '            x[$i] = _mm256_insertf128_si256(x[$i], _mm_loadu_si128(data.add(8 + $i) as *const _), 1);'), (110, '            x[$i] = _mm256_insertf128_si256(x[$i], _mm_loadu_si128(data.add($i) as *const _), 0);')], 'deleted': [(109, '            x[$i] = _mm256_insertf128_si256(x[$i], _mm_loadu_si128(data.add($i) as *const _), 1);'), (110, '            x[$i] = _mm256_insertf128_si256(x[$i], _mm_loadu_si128(data.add($i + 1) as *const _), 0);')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "268"
  },
  {
    "file_change_id": "216637159270172",
    "hash": "543687d6c85f39338a283d72614ea96a7fc8188",
    "old_path": "futures-task/src/waker.rs",
    "new_path": "futures-task/src/waker.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -18,7 +18,7 @@ pub(super) fn waker_vtable<W: ArcWake>() -> &'static RawWakerVTable {\n /// [`ArcWake.wake()`](ArcWake::wake) if awoken.\n pub fn waker<W>(wake: Arc<W>) -> Waker\n where\n-    W: ArcWake,\n+    W: ArcWake + 'static,\n {\n     let ptr = Arc::into_raw(wake) as *const ();\n \n",
    "diff_parsed": "{'added': [(21, \"    W: ArcWake + 'static,\")], 'deleted': [(21, '    W: ArcWake,')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "46"
  },
  {
    "file_change_id": "188060605545368",
    "hash": "d3d14ad5c32922444f857382976c22f056e3cef",
    "old_path": "src/entry.rs",
    "new_path": "src/entry.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -482,7 +482,16 @@ impl<'a> EntryFields<'a> {\n         // As a result if we don't recognize the kind we just write out the file\n         // as we would normally.\n \n-        fs::File::create(dst).and_then(|mut f| {\n+        // Remove an existing file, if any, to avoid writing through\n+        // symlinks/hardlinks to weird locations. The tar archive says this is a\n+        // regular file, so let's make it a regular file.\n+        (|| -> io::Result<()> {\n+            match fs::remove_file(dst) {\n+                Ok(()) => {}\n+                Err(ref e) if e.kind() == io::ErrorKind::NotFound => {}\n+                Err(e) => return Err(e)\n+            }\n+            let mut f = fs::File::create(dst)?;\n             for io in self.data.drain(..) {\n                 match io {\n                     EntryIo::Data(mut d) => {\n@@ -500,7 +509,7 @@ impl<'a> EntryFields<'a> {\n                 }\n             }\n             Ok(())\n-        }).map_err(|e| {\n+        })().map_err(|e| {\n             let header = self.header.path_bytes();\n             TarError::new(&format!(\"failed to unpack `{}` into `{}`\",\n                                    String::from_utf8_lossy(&header),\n",
    "diff_parsed": "{'added': [(488, '        (|| -> io::Result<()> {'), (489, '            match fs::remove_file(dst) {'), (490, '                Ok(()) => {}'), (491, '                Err(ref e) if e.kind() == io::ErrorKind::NotFound => {}'), (492, '                Err(e) => return Err(e)'), (493, '            }'), (494, '            let mut f = fs::File::create(dst)?;'), (512, '        })().map_err(|e| {')], 'deleted': [(485, '        fs::File::create(dst).and_then(|mut f| {'), (503, '        }).map_err(|e| {')]}",
    "num_lines_added": "8",
    "num_lines_deleted": "2",
    "nloc": "447"
  },
  {
    "file_change_id": "133499688520197",
    "hash": "d3d14ad5c32922444f857382976c22f056e3cef",
    "old_path": "tests/entry.rs",
    "new_path": "tests/entry.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -283,3 +283,38 @@ fn modify_hard_link_just_created() {\n     t!(t!(File::open(&test)).read_to_end(&mut contents));\n     assert_eq!(contents.len(), 0);\n }\n+\n+#[test]\n+fn modify_symlink_just_created() {\n+    let mut ar = tar::Builder::new(Vec::new());\n+\n+    let mut header = tar::Header::new_gnu();\n+    header.set_size(0);\n+    header.set_entry_type(tar::EntryType::Symlink);\n+    t!(header.set_path(\"foo\"));\n+    t!(header.set_link_name(\"../test\"));\n+    header.set_cksum();\n+    t!(ar.append(&header, &[][..]));\n+\n+    let mut header = tar::Header::new_gnu();\n+    header.set_size(1);\n+    header.set_entry_type(tar::EntryType::Regular);\n+    t!(header.set_path(\"foo\"));\n+    header.set_cksum();\n+    t!(ar.append(&header, &b\"x\"[..]));\n+\n+    let bytes = t!(ar.into_inner());\n+    let mut ar = tar::Archive::new(&bytes[..]);\n+\n+    let td = t!(TempDir::new(\"tar\"));\n+\n+    let test = td.path().join(\"test\");\n+    t!(File::create(&test));\n+\n+    let dir = td.path().join(\"dir\");\n+    t!(ar.unpack(&dir));\n+\n+    let mut contents = Vec::new();\n+    t!(t!(File::open(&test)).read_to_end(&mut contents));\n+    assert_eq!(contents.len(), 0);\n+}\n",
    "diff_parsed": "{'added': [(287, '#[test]'), (288, 'fn modify_symlink_just_created() {'), (289, '    let mut ar = tar::Builder::new(Vec::new());'), (291, '    let mut header = tar::Header::new_gnu();'), (292, '    header.set_size(0);'), (293, '    header.set_entry_type(tar::EntryType::Symlink);'), (294, '    t!(header.set_path(\"foo\"));'), (295, '    t!(header.set_link_name(\"../test\"));'), (296, '    header.set_cksum();'), (297, '    t!(ar.append(&header, &[][..]));'), (299, '    let mut header = tar::Header::new_gnu();'), (300, '    header.set_size(1);'), (301, '    header.set_entry_type(tar::EntryType::Regular);'), (302, '    t!(header.set_path(\"foo\"));'), (303, '    header.set_cksum();'), (304, '    t!(ar.append(&header, &b\"x\"[..]));'), (306, '    let bytes = t!(ar.into_inner());'), (307, '    let mut ar = tar::Archive::new(&bytes[..]);'), (309, '    let td = t!(TempDir::new(\"tar\"));'), (311, '    let test = td.path().join(\"test\");'), (312, '    t!(File::create(&test));'), (314, '    let dir = td.path().join(\"dir\");'), (315, '    t!(ar.unpack(&dir));'), (317, '    let mut contents = Vec::new();'), (318, '    t!(t!(File::open(&test)).read_to_end(&mut contents));'), (319, '    assert_eq!(contents.len(), 0);'), (320, '}')], 'deleted': []}",
    "num_lines_added": "27",
    "num_lines_deleted": "0",
    "nloc": "257"
  },
  {
    "file_change_id": "188989665958799",
    "hash": "cdc4276a7e3ec67185c2b66fcb7585ec8716de1",
    "old_path": "src/api.rs",
    "new_path": "src/api.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -291,7 +291,7 @@ pub trait RenderDocV110: RenderDocV100 {\n     ///\n     /// Data is saved to a capture log file at the location specified via\n     /// `set_log_file_path_template()`.\n-    fn trigger_multi_frame_capture(&self, num_frames: u32) {\n+    fn trigger_multi_frame_capture(&mut self, num_frames: u32) {\n         unsafe {\n             (self.entry_v110().TriggerMultiFrameCapture.unwrap())(num_frames);\n         }\n@@ -353,7 +353,7 @@ pub trait RenderDocV120: RenderDocV112 {\n     unsafe fn entry_v120(&self) -> &EntryV120;\n \n     #[allow(missing_docs)]\n-    fn set_capture_file_comments<'a, P, C>(&self, path: P, comments: C)\n+    fn set_capture_file_comments<'a, P, C>(&mut self, path: P, comments: C)\n     where\n         P: Into<Option<&'a str>>,\n         C: AsRef<str>,\n",
    "diff_parsed": "{'added': [(294, '    fn trigger_multi_frame_capture(&mut self, num_frames: u32) {'), (356, \"    fn set_capture_file_comments<'a, P, C>(&mut self, path: P, comments: C)\")], 'deleted': [(294, '    fn trigger_multi_frame_capture(&self, num_frames: u32) {'), (356, \"    fn set_capture_file_comments<'a, P, C>(&self, path: P, comments: C)\")]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "267"
  },
  {
    "file_change_id": "247126396346061",
    "hash": "85e98d1c9d5ba8af623120e8fee6c97a2c2aee0",
    "old_path": "src/untrusted.rs",
    "new_path": "src/untrusted.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -316,11 +316,11 @@ impl<'a> Reader<'a> {\n     pub fn skip_and_get_input(&mut self, num_bytes: usize)\n                               -> Result<Input<'a>, EndOfInput> {\n         let new_i = try!(self.i.checked_add(num_bytes).ok_or(EndOfInput));\n-        let ret = self.input.get_slice(self.i..new_i)\n-                            .map(|subslice| Input { value: subslice })\n-                            .ok_or(EndOfInput);\n+        let ret = try!(self.input.get_slice(self.i..new_i)\n+                                 .map(|subslice| Input { value: subslice })\n+                                 .ok_or(EndOfInput));\n         self.i = new_i;\n-        ret\n+        Ok(ret)\n     }\n \n     /// Skips the reader to the end of the input, returning the skipped input\n",
    "diff_parsed": "{'added': [(319, '        let ret = try!(self.input.get_slice(self.i..new_i)'), (320, '                                 .map(|subslice| Input { value: subslice })'), (321, '                                 .ok_or(EndOfInput));'), (323, '        Ok(ret)')], 'deleted': [(319, '        let ret = self.input.get_slice(self.i..new_i)'), (320, '                            .map(|subslice| Input { value: subslice })'), (321, '                            .ok_or(EndOfInput);'), (323, '        ret')]}",
    "num_lines_added": "4",
    "num_lines_deleted": "4",
    "nloc": "289"
  },
  {
    "file_change_id": "217588941083802",
    "hash": "fb1021a1c3c8a34d0eef7335811c52535e5c179",
    "old_path": "src/fields/fp/mod.rs",
    "new_path": "src/fields/fp/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -733,6 +733,28 @@ impl<F: PrimeField> FieldVar<F, F> for FpVar<F> {\n         *self = self.frobenius_map(power)?;\n         Ok(self)\n     }\n+\n+    #[tracing::instrument(target = \"r1cs\")]\n+    fn mul_by_inverse(&self, d: &Self) -> Result<Self, SynthesisError> {\n+        match (self, d) {\n+            (FpVar::Constant(_), _) | (_, FpVar::Constant(_)) => {\n+                let d_inv = d.inverse()?;\n+                Ok(d_inv * self)\n+            }\n+            (FpVar::Var(self_var), FpVar::Var(d_var)) => {\n+                let cs = self.cs().or(d.cs());\n+                let res_var = AllocatedFp::<F>::new_witness(self.cs(), || {\n+                    Ok(self_var.value()? * d_var.value()?.inverse().unwrap_or(F::zero()))\n+                })?;\n+                cs.enforce_constraint(\n+                    lc!() + res_var.variable,\n+                    lc!() + d_var.variable,\n+                    lc!() + self_var.variable,\n+                )?;\n+                Ok(FpVar::Var(res_var))\n+            }\n+        }\n+    }\n }\n \n impl_ops!(\n",
    "diff_parsed": "{'added': [(737, '    #[tracing::instrument(target = \"r1cs\")]'), (738, '    fn mul_by_inverse(&self, d: &Self) -> Result<Self, SynthesisError> {'), (739, '        match (self, d) {'), (740, '            (FpVar::Constant(_), _) | (_, FpVar::Constant(_)) => {'), (741, '                let d_inv = d.inverse()?;'), (742, '                Ok(d_inv * self)'), (743, '            }'), (744, '            (FpVar::Var(self_var), FpVar::Var(d_var)) => {'), (745, '                let cs = self.cs().or(d.cs());'), (746, '                let res_var = AllocatedFp::<F>::new_witness(self.cs(), || {'), (747, '                    Ok(self_var.value()? * d_var.value()?.inverse().unwrap_or(F::zero()))'), (748, '                })?;'), (749, '                cs.enforce_constraint('), (750, '                    lc!() + res_var.variable,'), (751, '                    lc!() + d_var.variable,'), (752, '                    lc!() + self_var.variable,'), (753, '                )?;'), (754, '                Ok(FpVar::Var(res_var))'), (755, '            }'), (756, '        }'), (757, '    }')], 'deleted': []}",
    "num_lines_added": "21",
    "num_lines_deleted": "0",
    "nloc": "976"
  },
  {
    "file_change_id": "74039385637042",
    "hash": "fb1021a1c3c8a34d0eef7335811c52535e5c179",
    "old_path": "src/fields/mod.rs",
    "new_path": "src/fields/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -155,16 +155,20 @@ pub trait FieldVar<F: Field, ConstraintF: Field>:\n     /// Computes `result` such that `self * result == Self::one()`.\n     fn inverse(&self) -> Result<Self, SynthesisError>;\n \n-    /// Returns `(self / d)`. but requires fewer constraints than `self * d.inverse()`.\n+    /// Returns `(self / d)`.\n     /// It is up to the caller to ensure that `d` is non-zero,\n-    /// since in that case the result is unconstrained.\n+    /// since in that case the constraint is unsatisfied.\n     fn mul_by_inverse(&self, d: &Self) -> Result<Self, SynthesisError> {\n-        let d_inv = if self.is_constant() || d.is_constant() {\n-            d.inverse()?\n+        if self.is_constant() || d.is_constant() {\n+            let d_inv = d.inverse()?;\n+            Ok(d_inv * self)\n         } else {\n-            Self::new_witness(self.cs(), || Ok(d.value()?.inverse().unwrap_or(F::zero())))?\n-        };\n-        Ok(d_inv * self)\n+            let res = Self::new_witness(self.cs(), || {\n+                Ok(self.value()? * d.value()?.inverse().unwrap_or(F::zero()))\n+            })?;\n+            res.mul_equals(d, self)?;\n+            Ok(res)\n+        }\n     }\n \n     /// Computes the frobenius map over `self`.\n",
    "diff_parsed": "{'added': [(162, '        if self.is_constant() || d.is_constant() {'), (163, '            let d_inv = d.inverse()?;'), (164, '            Ok(d_inv * self)'), (166, '            let res = Self::new_witness(self.cs(), || {'), (167, '                Ok(self.value()? * d.value()?.inverse().unwrap_or(F::zero()))'), (168, '            })?;'), (169, '            res.mul_equals(d, self)?;'), (170, '            Ok(res)'), (171, '        }')], 'deleted': [(162, '        let d_inv = if self.is_constant() || d.is_constant() {'), (163, '            d.inverse()?'), (165, '            Self::new_witness(self.cs(), || Ok(d.value()?.inverse().unwrap_or(F::zero())))?'), (166, '        };'), (167, '        Ok(d_inv * self)')]}",
    "num_lines_added": "9",
    "num_lines_deleted": "5",
    "nloc": "129"
  },
  {
    "file_change_id": "36337796840265",
    "hash": "b93aff6e904cffbbfd1f421b82f6dcc5ca19a4f",
    "old_path": "src/de.rs",
    "new_path": "src/de.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -79,6 +79,7 @@ struct Deserializer<'a> {\n     aliases: &'a BTreeMap<usize, usize>,\n     pos: &'a mut usize,\n     path: Path<'a>,\n+    remaining_depth: u8,\n }\n \n impl<'a> Deserializer<'a> {\n@@ -109,6 +110,7 @@ impl<'a> Deserializer<'a> {\n                     aliases: self.aliases,\n                     pos: pos,\n                     path: Path::Alias { parent: &self.path },\n+                    remaining_depth: self.remaining_depth,\n                 })\n             }\n             None => panic!(\"unresolved alias: {}\", *pos),\n@@ -161,11 +163,11 @@ impl<'a> Deserializer<'a> {\n     where\n         V: Visitor<'de>,\n     {\n-        let (value, len) = {\n-            let mut seq = SeqAccess { de: self, len: 0 };\n+        let (value, len) = self.recursion_check(|de| {\n+            let mut seq = SeqAccess { de: de, len: 0 };\n             let value = visitor.visit_seq(&mut seq)?;\n-            (value, seq.len)\n-        };\n+            Ok((value, seq.len))\n+        })?;\n         self.end_sequence(len)?;\n         Ok(value)\n     }\n@@ -174,15 +176,15 @@ impl<'a> Deserializer<'a> {\n     where\n         V: Visitor<'de>,\n     {\n-        let (value, len) = {\n+        let (value, len) = self.recursion_check(|de| {\n             let mut map = MapAccess {\n-                de: &mut *self,\n+                de: de,\n                 len: 0,\n                 key: None,\n             };\n             let value = visitor.visit_map(&mut map)?;\n-            (value, map.len)\n-        };\n+            Ok((value, map.len))\n+        })?;\n         self.end_mapping(len)?;\n         Ok(value)\n     }\n@@ -238,6 +240,16 @@ impl<'a> Deserializer<'a> {\n             Err(de::Error::invalid_length(total, &ExpectedMap(len)))\n         }\n     }\n+\n+    fn recursion_check<F: FnOnce(&mut Self) -> Result<T>, T>(&mut self, f: F) -> Result<T> {\n+        let previous_depth = self.remaining_depth;\n+        self.remaining_depth = previous_depth\n+            .checked_sub(1)\n+            .ok_or_else(Error::recursion_limit_exceeded)?;\n+        let result = f(self);\n+        self.remaining_depth = previous_depth;\n+        result\n+    }\n }\n \n fn visit_scalar<'de, V>(\n@@ -303,6 +315,7 @@ impl<'de, 'a, 'r> de::SeqAccess<'de> for SeqAccess<'a, 'r> {\n                         parent: &self.de.path,\n                         index: self.len,\n                     },\n+                    remaining_depth: self.de.remaining_depth,\n                 };\n                 self.len += 1;\n                 seed.deserialize(&mut element_de).map(Some)\n@@ -357,6 +370,7 @@ impl<'de, 'a, 'r> de::MapAccess<'de> for MapAccess<'a, 'r> {\n                     parent: &self.de.path,\n                 }\n             },\n+            remaining_depth: self.de.remaining_depth,\n         };\n         seed.deserialize(&mut value_de)\n     }\n@@ -409,6 +423,7 @@ impl<'de, 'a, 'r> de::EnumAccess<'de> for EnumAccess<'a, 'r> {\n                 parent: &self.de.path,\n                 key: variant,\n             },\n+            remaining_depth: self.de.remaining_depth,\n         };\n         Ok((ret, variant_visitor))\n     }\n@@ -949,6 +964,7 @@ where\n             aliases: &loader.aliases,\n             pos: &mut pos,\n             path: Path::Root,\n+            remaining_depth: 128,\n         })?;\n         if pos == loader.events.len() {\n             Ok(t)\n",
    "diff_parsed": "{'added': [(82, '    remaining_depth: u8,'), (113, '                    remaining_depth: self.remaining_depth,'), (166, '        let (value, len) = self.recursion_check(|de| {'), (167, '            let mut seq = SeqAccess { de: de, len: 0 };'), (169, '            Ok((value, seq.len))'), (170, '        })?;'), (179, '        let (value, len) = self.recursion_check(|de| {'), (181, '                de: de,'), (186, '            Ok((value, map.len))'), (187, '        })?;'), (244, '    fn recursion_check<F: FnOnce(&mut Self) -> Result<T>, T>(&mut self, f: F) -> Result<T> {'), (245, '        let previous_depth = self.remaining_depth;'), (246, '        self.remaining_depth = previous_depth'), (247, '            .checked_sub(1)'), (248, '            .ok_or_else(Error::recursion_limit_exceeded)?;'), (249, '        let result = f(self);'), (250, '        self.remaining_depth = previous_depth;'), (251, '        result'), (252, '    }'), (318, '                    remaining_depth: self.de.remaining_depth,'), (373, '            remaining_depth: self.de.remaining_depth,'), (426, '            remaining_depth: self.de.remaining_depth,'), (967, '            remaining_depth: 128,')], 'deleted': [(164, '        let (value, len) = {'), (165, '            let mut seq = SeqAccess { de: self, len: 0 };'), (167, '            (value, seq.len)'), (168, '        };'), (177, '        let (value, len) = {'), (179, '                de: &mut *self,'), (184, '            (value, map.len)'), (185, '        };')]}",
    "num_lines_added": "23",
    "num_lines_deleted": "8",
    "nloc": "916"
  },
  {
    "file_change_id": "84722164541792",
    "hash": "b93aff6e904cffbbfd1f421b82f6dcc5ca19a4f",
    "old_path": "src/error.rs",
    "new_path": "src/error.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -41,6 +41,7 @@ pub enum ErrorImpl {\n \n     EndOfStream,\n     MoreThanOneDocument,\n+    RecursionLimitExceeded,\n }\n \n #[derive(Debug)]\n@@ -157,6 +158,12 @@ impl Error {\n         Error(Box::new(ErrorImpl::FromUtf8(err)))\n     }\n \n+    // Not public API. Should be pub(crate).\n+    #[doc(hidden)]\n+    pub fn recursion_limit_exceeded() -> Error {\n+        Error(Box::new(ErrorImpl::RecursionLimitExceeded))\n+    }\n+\n     // Not public API. Should be pub(crate).\n     #[doc(hidden)]\n     pub fn fix_marker(mut self, marker: Marker, path: Path) -> Self {\n@@ -183,6 +190,7 @@ impl error::Error for Error {\n             ErrorImpl::MoreThanOneDocument => {\n                 \"deserializing from YAML containing more than one document is not supported\"\n             }\n+            ErrorImpl::RecursionLimitExceeded => \"recursion limit exceeded\",\n         }\n     }\n \n@@ -218,6 +226,7 @@ impl Display for Error {\n             ErrorImpl::MoreThanOneDocument => f.write_str(\n                 \"deserializing from YAML containing more than one document is not supported\",\n             ),\n+            ErrorImpl::RecursionLimitExceeded => f.write_str(\"recursion limit exceeded\"),\n         }\n     }\n }\n@@ -241,6 +250,9 @@ impl Debug for Error {\n             }\n             ErrorImpl::EndOfStream => formatter.debug_tuple(\"EndOfStream\").finish(),\n             ErrorImpl::MoreThanOneDocument => formatter.debug_tuple(\"MoreThanOneDocument\").finish(),\n+            ErrorImpl::RecursionLimitExceeded => {\n+                formatter.debug_tuple(\"RecursionLimitExceeded\").finish()\n+            }\n         }\n     }\n }\n",
    "diff_parsed": "{'added': [(44, '    RecursionLimitExceeded,'), (162, '    #[doc(hidden)]'), (163, '    pub fn recursion_limit_exceeded() -> Error {'), (164, '        Error(Box::new(ErrorImpl::RecursionLimitExceeded))'), (165, '    }'), (193, '            ErrorImpl::RecursionLimitExceeded => \"recursion limit exceeded\",'), (229, '            ErrorImpl::RecursionLimitExceeded => f.write_str(\"recursion limit exceeded\"),'), (253, '            ErrorImpl::RecursionLimitExceeded => {'), (254, '                formatter.debug_tuple(\"RecursionLimitExceeded\").finish()'), (255, '            }')], 'deleted': []}",
    "num_lines_added": "10",
    "num_lines_deleted": "0",
    "nloc": "189"
  },
  {
    "file_change_id": "76090431365893",
    "hash": "b93aff6e904cffbbfd1f421b82f6dcc5ca19a4f",
    "old_path": "tests/test_error.rs",
    "new_path": "tests/test_error.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -257,3 +257,51 @@ fn test_invalid_scalar_type() {\n     let expected = \"x: invalid type: unit value, expected an array of length 1 at line 2 column 1\";\n     test_error::<S>(yaml, expected);\n }\n+\n+#[test]\n+fn test_infinite_recursion_objects() {\n+    #[derive(Deserialize, Debug)]\n+    struct S {\n+        x: Option<Box<S>>,\n+    }\n+\n+    let yaml = \"&a {x: *a}\";\n+    let expected = \"recursion limit exceeded\";\n+    test_error::<S>(yaml, expected);\n+}\n+\n+#[test]\n+fn test_infinite_recursion_arrays() {\n+    #[derive(Deserialize, Debug)]\n+    struct S {\n+        x: Option<Box<S>>,\n+    }\n+\n+    let yaml = \"&a [*a]\";\n+    let expected = \"recursion limit exceeded\";\n+    test_error::<S>(yaml, expected);\n+}\n+\n+#[test]\n+fn test_finite_recursion_objects() {\n+    #[derive(Deserialize, Debug)]\n+    struct S {\n+        x: Option<Box<S>>,\n+    }\n+\n+    let yaml = \"{x:\".repeat(1_000) + &\"}\".repeat(1_000);\n+    let expected = \"recursion limit exceeded\";\n+    test_error::<i32>(&yaml, expected);\n+}\n+\n+#[test]\n+fn test_finite_recursion_arrays() {\n+    #[derive(Deserialize, Debug)]\n+    struct S {\n+        x: Option<Box<S>>,\n+    }\n+\n+    let yaml = \"[\".repeat(1_000) + &\"]\".repeat(1_000);\n+    let expected = \"recursion limit exceeded\";\n+    test_error::<S>(&yaml, expected);\n+}\n",
    "diff_parsed": "{'added': [(261, '#[test]'), (262, 'fn test_infinite_recursion_objects() {'), (263, '    #[derive(Deserialize, Debug)]'), (264, '    struct S {'), (265, '        x: Option<Box<S>>,'), (266, '    }'), (268, '    let yaml = \"&a {x: *a}\";'), (269, '    let expected = \"recursion limit exceeded\";'), (270, '    test_error::<S>(yaml, expected);'), (271, '}'), (273, '#[test]'), (274, 'fn test_infinite_recursion_arrays() {'), (275, '    #[derive(Deserialize, Debug)]'), (276, '    struct S {'), (277, '        x: Option<Box<S>>,'), (278, '    }'), (280, '    let yaml = \"&a [*a]\";'), (281, '    let expected = \"recursion limit exceeded\";'), (282, '    test_error::<S>(yaml, expected);'), (283, '}'), (285, '#[test]'), (286, 'fn test_finite_recursion_objects() {'), (287, '    #[derive(Deserialize, Debug)]'), (288, '    struct S {'), (289, '        x: Option<Box<S>>,'), (290, '    }'), (292, '    let yaml = \"{x:\".repeat(1_000) + &\"}\".repeat(1_000);'), (293, '    let expected = \"recursion limit exceeded\";'), (294, '    test_error::<i32>(&yaml, expected);'), (295, '}'), (297, '#[test]'), (298, 'fn test_finite_recursion_arrays() {'), (299, '    #[derive(Deserialize, Debug)]'), (300, '    struct S {'), (301, '        x: Option<Box<S>>,'), (302, '    }'), (304, '    let yaml = \"[\".repeat(1_000) + &\"]\".repeat(1_000);'), (305, '    let expected = \"recursion limit exceeded\";'), (306, '    test_error::<S>(&yaml, expected);'), (307, '}')], 'deleted': []}",
    "num_lines_added": "40",
    "num_lines_deleted": "0",
    "nloc": "266"
  },
  {
    "file_change_id": "177935809732787",
    "hash": "93458d01fed0ec81c0e7b4e98e6f35961356fae",
    "old_path": "src/transport/smtp/client/mod.rs",
    "new_path": "src/transport/smtp/client/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -78,7 +78,15 @@ impl ClientCodec {\n                     match self.escape_count {\n                         0 => self.escape_count = if *byte == b'\\r' { 1 } else { 0 },\n                         1 => self.escape_count = if *byte == b'\\n' { 2 } else { 0 },\n-                        2 => self.escape_count = if *byte == b'.' { 3 } else { 0 },\n+                        2 => {\n+                            self.escape_count = if *byte == b'.' {\n+                                3\n+                            } else if *byte == b'\\r' {\n+                                1\n+                            } else {\n+                                0\n+                            }\n+                        }\n                         _ => unreachable!(),\n                     }\n                     if self.escape_count == 3 {\n@@ -111,6 +119,7 @@ mod test {\n         let mut buf: Vec<u8> = vec![];\n \n         codec.encode(b\"test\\r\\n\", &mut buf);\n+        codec.encode(b\"test\\r\\n\\r\\n\", &mut buf);\n         codec.encode(b\".\\r\\n\", &mut buf);\n         codec.encode(b\"\\r\\ntest\", &mut buf);\n         codec.encode(b\"te\\r\\n.\\r\\nst\", &mut buf);\n@@ -121,7 +130,7 @@ mod test {\n         codec.encode(b\"test\", &mut buf);\n         assert_eq!(\n             String::from_utf8(buf).unwrap(),\n-            \"test\\r\\n..\\r\\n\\r\\ntestte\\r\\n..\\r\\nsttesttest.test\\n.test\\ntest\"\n+            \"test\\r\\ntest\\r\\n\\r\\n..\\r\\n\\r\\ntestte\\r\\n..\\r\\nsttesttest.test\\n.test\\ntest\"\n         );\n     }\n \n",
    "diff_parsed": "{'added': [(81, '                        2 => {'), (82, \"                            self.escape_count = if *byte == b'.' {\"), (83, '                                3'), (84, \"                            } else if *byte == b'\\\\r' {\"), (85, '                                1'), (86, '                            } else {'), (87, '                                0'), (88, '                            }'), (89, '                        }'), (122, '        codec.encode(b\"test\\\\r\\\\n\\\\r\\\\n\", &mut buf);'), (133, '            \"test\\\\r\\\\ntest\\\\r\\\\n\\\\r\\\\n..\\\\r\\\\n\\\\r\\\\ntestte\\\\r\\\\n..\\\\r\\\\nsttesttest.test\\\\n.test\\\\ntest\"')], 'deleted': [(81, \"                        2 => self.escape_count = if *byte == b'.' { 3 } else { 0 },\"), (124, '            \"test\\\\r\\\\n..\\\\r\\\\n\\\\r\\\\ntestte\\\\r\\\\n..\\\\r\\\\nsttesttest.test\\\\n.test\\\\ntest\"')]}",
    "num_lines_added": "11",
    "num_lines_deleted": "2",
    "nloc": "106"
  },
  {
    "file_change_id": "216779121317296",
    "hash": "38d308785f84f7037e63c04c0de1cb20d1c8284",
    "old_path": "crossbeam-channel/src/flavors/list.rs",
    "new_path": "crossbeam-channel/src/flavors/list.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -2,7 +2,7 @@\n \n use std::cell::UnsafeCell;\n use std::marker::PhantomData;\n-use std::mem::{self, ManuallyDrop};\n+use std::mem::MaybeUninit;\n use std::ptr;\n use std::sync::atomic::{self, AtomicPtr, AtomicUsize, Ordering};\n use std::time::Instant;\n@@ -42,7 +42,7 @@ const MARK_BIT: usize = 1;\n /// A slot in a block.\n struct Slot<T> {\n     /// The message.\n-    msg: UnsafeCell<ManuallyDrop<T>>,\n+    msg: UnsafeCell<MaybeUninit<T>>,\n \n     /// The state of the slot.\n     state: AtomicUsize,\n@@ -72,7 +72,13 @@ struct Block<T> {\n impl<T> Block<T> {\n     /// Creates an empty block.\n     fn new() -> Block<T> {\n-        unsafe { mem::zeroed() }\n+        // SAFETY: This is safe because:\n+        //  [1] `Block::next` (AtomicPtr) may be safely zero initialized.\n+        //  [2] `Block::slots` (Array) may be safely zero initialized because of [3, 4].\n+        //  [3] `Slot::msg` (UnsafeCell) may be safely zero initialized because it\n+        //       holds a MaybeUninit.\n+        //  [4] `Slot::state` (AtomicUsize) may be safely zero initialized.\n+        unsafe { MaybeUninit::zeroed().assume_init() }\n     }\n \n     /// Waits until the next pointer is set.\n@@ -280,7 +286,7 @@ impl<T> Channel<T> {\n         let block = token.list.block as *mut Block<T>;\n         let offset = token.list.offset;\n         let slot = (*block).slots.get_unchecked(offset);\n-        slot.msg.get().write(ManuallyDrop::new(msg));\n+        slot.msg.get().write(MaybeUninit::new(msg));\n         slot.state.fetch_or(WRITE, Ordering::Release);\n \n         // Wake a sleeping receiver.\n@@ -385,8 +391,7 @@ impl<T> Channel<T> {\n         let offset = token.list.offset;\n         let slot = (*block).slots.get_unchecked(offset);\n         slot.wait_write();\n-        let m = slot.msg.get().read();\n-        let msg = ManuallyDrop::into_inner(m);\n+        let msg = slot.msg.get().read().assume_init();\n \n         // Destroy the block if we've reached the end, or if another thread wanted to destroy but\n         // couldn't because we were busy reading from the slot.\n@@ -572,7 +577,8 @@ impl<T> Drop for Channel<T> {\n                 if offset < BLOCK_CAP {\n                     // Drop the message in the slot.\n                     let slot = (*block).slots.get_unchecked(offset);\n-                    ManuallyDrop::drop(&mut *(*slot).msg.get());\n+                    let p = &mut *slot.msg.get();\n+                    ptr::drop_in_place(p.as_mut_ptr());\n                 } else {\n                     // Deallocate the block and move to the next one.\n                     let next = (*block).next.load(Ordering::Relaxed);\n",
    "diff_parsed": "{'added': [(5, 'use std::mem::MaybeUninit;'), (45, '    msg: UnsafeCell<MaybeUninit<T>>,'), (81, '        unsafe { MaybeUninit::zeroed().assume_init() }'), (289, '        slot.msg.get().write(MaybeUninit::new(msg));'), (394, '        let msg = slot.msg.get().read().assume_init();'), (580, '                    let p = &mut *slot.msg.get();'), (581, '                    ptr::drop_in_place(p.as_mut_ptr());')], 'deleted': [(5, 'use std::mem::{self, ManuallyDrop};'), (45, '    msg: UnsafeCell<ManuallyDrop<T>>,'), (75, '        unsafe { mem::zeroed() }'), (283, '        slot.msg.get().write(ManuallyDrop::new(msg));'), (388, '        let m = slot.msg.get().read();'), (389, '        let msg = ManuallyDrop::into_inner(m);'), (575, '                    ManuallyDrop::drop(&mut *(*slot).msg.get());')]}",
    "num_lines_added": "7",
    "num_lines_deleted": "7",
    "nloc": "447"
  },
  {
    "file_change_id": "19318749384123",
    "hash": "7b35a3d17f5c5ec53f70576d4ca0e18be8ed289",
    "old_path": "crossbeam-queue/src/seg_queue.rs",
    "new_path": "crossbeam-queue/src/seg_queue.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -2,7 +2,7 @@ use alloc::boxed::Box;\n use core::cell::UnsafeCell;\n use core::fmt;\n use core::marker::PhantomData;\n-use core::mem::{self, ManuallyDrop};\n+use core::mem::MaybeUninit;\n use core::ptr;\n use core::sync::atomic::{self, AtomicPtr, AtomicUsize, Ordering};\n \n@@ -30,7 +30,7 @@ const HAS_NEXT: usize = 1;\n /// A slot in a block.\n struct Slot<T> {\n     /// The value.\n-    value: UnsafeCell<ManuallyDrop<T>>,\n+    value: UnsafeCell<MaybeUninit<T>>,\n \n     /// The state of the slot.\n     state: AtomicUsize,\n@@ -60,7 +60,13 @@ struct Block<T> {\n impl<T> Block<T> {\n     /// Creates an empty block that starts at `start_index`.\n     fn new() -> Block<T> {\n-        unsafe { mem::zeroed() }\n+        // SAFETY: This is safe because:\n+        //  [1] `Block::next` (AtomicPtr) may be safely zero initialized.\n+        //  [2] `Block::slots` (Array) may be safely zero initialized because of [3, 4].\n+        //  [3] `Slot::value` (UnsafeCell) may be safely zero initialized because it\n+        //       holds a MaybeUninit.\n+        //  [4] `Slot::state` (AtomicUsize) may be safely zero initialized.\n+        unsafe { MaybeUninit::zeroed().assume_init() }\n     }\n \n     /// Waits until the next pointer is set.\n@@ -244,7 +250,7 @@ impl<T> SegQueue<T> {\n \n                     // Write the value into the slot.\n                     let slot = (*block).slots.get_unchecked(offset);\n-                    slot.value.get().write(ManuallyDrop::new(value));\n+                    slot.value.get().write(MaybeUninit::new(value));\n                     slot.state.fetch_or(WRITE, Ordering::Release);\n \n                     return;\n@@ -339,8 +345,7 @@ impl<T> SegQueue<T> {\n                     // Read the value.\n                     let slot = (*block).slots.get_unchecked(offset);\n                     slot.wait_write();\n-                    let m = slot.value.get().read();\n-                    let value = ManuallyDrop::into_inner(m);\n+                    let value = slot.value.get().read().assume_init();\n \n                     // Destroy the block if we've reached the end, or if another thread wanted to\n                     // destroy but couldn't because we were busy reading from the slot.\n@@ -451,7 +456,8 @@ impl<T> Drop for SegQueue<T> {\n                 if offset < BLOCK_CAP {\n                     // Drop the value in the slot.\n                     let slot = (*block).slots.get_unchecked(offset);\n-                    ManuallyDrop::drop(&mut *(*slot).value.get());\n+                    let p = &mut *slot.value.get();\n+                    ptr::drop_in_place(p.as_mut_ptr());\n                 } else {\n                     // Deallocate the block and move to the next one.\n                     let next = (*block).next.load(Ordering::Relaxed);\n",
    "diff_parsed": "{'added': [(5, 'use core::mem::MaybeUninit;'), (33, '    value: UnsafeCell<MaybeUninit<T>>,'), (69, '        unsafe { MaybeUninit::zeroed().assume_init() }'), (253, '                    slot.value.get().write(MaybeUninit::new(value));'), (348, '                    let value = slot.value.get().read().assume_init();'), (459, '                    let p = &mut *slot.value.get();'), (460, '                    ptr::drop_in_place(p.as_mut_ptr());')], 'deleted': [(5, 'use core::mem::{self, ManuallyDrop};'), (33, '    value: UnsafeCell<ManuallyDrop<T>>,'), (63, '        unsafe { mem::zeroed() }'), (247, '                    slot.value.get().write(ManuallyDrop::new(value));'), (342, '                    let m = slot.value.get().read();'), (343, '                    let value = ManuallyDrop::into_inner(m);'), (454, '                    ManuallyDrop::drop(&mut *(*slot).value.get());')]}",
    "num_lines_added": "7",
    "num_lines_deleted": "7",
    "nloc": "273"
  },
  {
    "file_change_id": "108494154486193",
    "hash": "68e8708c2dda24e4b3b1807f5f301ca2b8ffa35",
    "old_path": "crossbeam-deque/src/lib.rs",
    "new_path": "crossbeam-deque/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -97,7 +97,7 @@ use std::cmp;\n use std::fmt;\n use std::iter::FromIterator;\n use std::marker::PhantomData;\n-use std::mem::{self, ManuallyDrop};\n+use std::mem::{self, MaybeUninit};\n use std::ptr;\n use std::sync::atomic::{self, AtomicIsize, AtomicPtr, AtomicUsize, Ordering};\n use std::sync::Arc;\n@@ -1140,7 +1140,7 @@ const HAS_NEXT: usize = 1;\n /// A slot in a block.\n struct Slot<T> {\n     /// The task.\n-    task: UnsafeCell<ManuallyDrop<T>>,\n+    task: UnsafeCell<MaybeUninit<T>>,\n \n     /// The state of the slot.\n     state: AtomicUsize,\n@@ -1170,7 +1170,13 @@ struct Block<T> {\n impl<T> Block<T> {\n     /// Creates an empty block that starts at `start_index`.\n     fn new() -> Block<T> {\n-        unsafe { mem::zeroed() }\n+        // SAFETY: This is safe because:\n+        //  [1] `Block::next` (AtomicPtr) may be safely zero initialized.\n+        //  [2] `Block::slots` (Array) may be safely zero initialized because of [3, 4].\n+        //  [3] `Slot::task` (UnsafeCell) may be safely zero initialized because it\n+        //       holds a MaybeUninit.\n+        //  [4] `Slot::state` (AtomicUsize) may be safely zero initialized.\n+        unsafe { MaybeUninit::zeroed().assume_init() }\n     }\n \n     /// Waits until the next pointer is set.\n@@ -1329,7 +1335,7 @@ impl<T> Injector<T> {\n \n                     // Write the task into the slot.\n                     let slot = (*block).slots.get_unchecked(offset);\n-                    slot.task.get().write(ManuallyDrop::new(task));\n+                    slot.task.get().write(MaybeUninit::new(task));\n                     slot.state.fetch_or(WRITE, Ordering::Release);\n \n                     return;\n@@ -1422,8 +1428,7 @@ impl<T> Injector<T> {\n             // Read the task.\n             let slot = (*block).slots.get_unchecked(offset);\n             slot.wait_write();\n-            let m = slot.task.get().read();\n-            let task = ManuallyDrop::into_inner(m);\n+            let task = slot.task.get().read().assume_init();\n \n             // Destroy the block if we've reached the end, or if another thread wanted to destroy\n             // but couldn't because we were busy reading from the slot.\n@@ -1548,8 +1553,7 @@ impl<T> Injector<T> {\n                         // Read the task.\n                         let slot = (*block).slots.get_unchecked(offset + i);\n                         slot.wait_write();\n-                        let m = slot.task.get().read();\n-                        let task = ManuallyDrop::into_inner(m);\n+                        let task = slot.task.get().read().assume_init();\n \n                         // Write it into the destination queue.\n                         dest_buffer.write(dest_b.wrapping_add(i as isize), task);\n@@ -1561,8 +1565,7 @@ impl<T> Injector<T> {\n                         // Read the task.\n                         let slot = (*block).slots.get_unchecked(offset + i);\n                         slot.wait_write();\n-                        let m = slot.task.get().read();\n-                        let task = ManuallyDrop::into_inner(m);\n+                        let task = slot.task.get().read().assume_init();\n \n                         // Write it into the destination queue.\n                         dest_buffer.write(dest_b.wrapping_add((batch_size - 1 - i) as isize), task);\n@@ -1704,8 +1707,7 @@ impl<T> Injector<T> {\n             // Read the task.\n             let slot = (*block).slots.get_unchecked(offset);\n             slot.wait_write();\n-            let m = slot.task.get().read();\n-            let task = ManuallyDrop::into_inner(m);\n+            let task = slot.task.get().read().assume_init();\n \n             match dest.flavor {\n                 Flavor::Fifo => {\n@@ -1714,8 +1716,7 @@ impl<T> Injector<T> {\n                         // Read the task.\n                         let slot = (*block).slots.get_unchecked(offset + i + 1);\n                         slot.wait_write();\n-                        let m = slot.task.get().read();\n-                        let task = ManuallyDrop::into_inner(m);\n+                        let task = slot.task.get().read().assume_init();\n \n                         // Write it into the destination queue.\n                         dest_buffer.write(dest_b.wrapping_add(i as isize), task);\n@@ -1728,8 +1729,7 @@ impl<T> Injector<T> {\n                         // Read the task.\n                         let slot = (*block).slots.get_unchecked(offset + i + 1);\n                         slot.wait_write();\n-                        let m = slot.task.get().read();\n-                        let task = ManuallyDrop::into_inner(m);\n+                        let task = slot.task.get().read().assume_init();\n \n                         // Write it into the destination queue.\n                         dest_buffer.write(dest_b.wrapping_add((batch_size - 1 - i) as isize), task);\n@@ -1804,7 +1804,8 @@ impl<T> Drop for Injector<T> {\n                 if offset < BLOCK_CAP {\n                     // Drop the task in the slot.\n                     let slot = (*block).slots.get_unchecked(offset);\n-                    ManuallyDrop::drop(&mut *(*slot).task.get());\n+                    let p = &mut *slot.task.get();\n+                    ptr::drop_in_place(p.as_mut_ptr());\n                 } else {\n                     // Deallocate the block and move to the next one.\n                     let next = (*block).next.load(Ordering::Relaxed);\n",
    "diff_parsed": "{'added': [(100, 'use std::mem::{self, MaybeUninit};'), (1143, '    task: UnsafeCell<MaybeUninit<T>>,'), (1179, '        unsafe { MaybeUninit::zeroed().assume_init() }'), (1338, '                    slot.task.get().write(MaybeUninit::new(task));'), (1431, '            let task = slot.task.get().read().assume_init();'), (1556, '                        let task = slot.task.get().read().assume_init();'), (1568, '                        let task = slot.task.get().read().assume_init();'), (1710, '            let task = slot.task.get().read().assume_init();'), (1719, '                        let task = slot.task.get().read().assume_init();'), (1732, '                        let task = slot.task.get().read().assume_init();'), (1807, '                    let p = &mut *slot.task.get();'), (1808, '                    ptr::drop_in_place(p.as_mut_ptr());')], 'deleted': [(100, 'use std::mem::{self, ManuallyDrop};'), (1143, '    task: UnsafeCell<ManuallyDrop<T>>,'), (1173, '        unsafe { mem::zeroed() }'), (1332, '                    slot.task.get().write(ManuallyDrop::new(task));'), (1425, '            let m = slot.task.get().read();'), (1426, '            let task = ManuallyDrop::into_inner(m);'), (1551, '                        let m = slot.task.get().read();'), (1552, '                        let task = ManuallyDrop::into_inner(m);'), (1564, '                        let m = slot.task.get().read();'), (1565, '                        let task = ManuallyDrop::into_inner(m);'), (1707, '            let m = slot.task.get().read();'), (1708, '            let task = ManuallyDrop::into_inner(m);'), (1717, '                        let m = slot.task.get().read();'), (1718, '                        let task = ManuallyDrop::into_inner(m);'), (1731, '                        let m = slot.task.get().read();'), (1732, '                        let task = ManuallyDrop::into_inner(m);'), (1807, '                    ManuallyDrop::drop(&mut *(*slot).task.get());')]}",
    "num_lines_added": "12",
    "num_lines_deleted": "17",
    "nloc": "997"
  },
  {
    "file_change_id": "2909928333804",
    "hash": "e0fd465b9b7de8b60b0b588e264aca1fa92fbd1",
    "old_path": "crossbeam-epoch/src/deferred.rs",
    "new_path": "crossbeam-epoch/src/deferred.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,7 +1,7 @@\n use alloc::boxed::Box;\n use core::fmt;\n use core::marker::PhantomData;\n-use core::mem;\n+use core::mem::{self, MaybeUninit};\n use core::ptr;\n \n /// Number of words a piece of `Data` can hold.\n@@ -36,11 +36,8 @@ impl Deferred {\n \n         unsafe {\n             if size <= mem::size_of::<Data>() && align <= mem::align_of::<Data>() {\n-                // TODO(taiki-e): when the minimum supported Rust version is bumped to 1.36+,\n-                // replace this with `mem::MaybeUninit`.\n-                #[allow(deprecated)]\n-                let mut data: Data = mem::uninitialized();\n-                ptr::write(&mut data as *mut Data as *mut F, f);\n+                let mut data = MaybeUninit::<Data>::uninit();\n+                ptr::write(data.as_mut_ptr() as *mut F, f);\n \n                 unsafe fn call<F: FnOnce()>(raw: *mut u8) {\n                     let f: F = ptr::read(raw as *mut F);\n@@ -49,16 +46,13 @@ impl Deferred {\n \n                 Deferred {\n                     call: call::<F>,\n-                    data,\n+                    data: data.assume_init(),\n                     _marker: PhantomData,\n                 }\n             } else {\n                 let b: Box<F> = Box::new(f);\n-                // TODO(taiki-e): when the minimum supported Rust version is bumped to 1.36+,\n-                // replace this with `mem::MaybeUninit`.\n-                #[allow(deprecated)]\n-                let mut data: Data = mem::uninitialized();\n-                ptr::write(&mut data as *mut Data as *mut Box<F>, b);\n+                let mut data = MaybeUninit::<Data>::uninit();\n+                ptr::write(data.as_mut_ptr() as *mut Box<F>, b);\n \n                 unsafe fn call<F: FnOnce()>(raw: *mut u8) {\n                     let b: Box<F> = ptr::read(raw as *mut Box<F>);\n@@ -67,7 +61,7 @@ impl Deferred {\n \n                 Deferred {\n                     call: call::<F>,\n-                    data,\n+                    data: data.assume_init(),\n                     _marker: PhantomData,\n                 }\n             }\n",
    "diff_parsed": "{'added': [(4, 'use core::mem::{self, MaybeUninit};'), (39, '                let mut data = MaybeUninit::<Data>::uninit();'), (40, '                ptr::write(data.as_mut_ptr() as *mut F, f);'), (49, '                    data: data.assume_init(),'), (54, '                let mut data = MaybeUninit::<Data>::uninit();'), (55, '                ptr::write(data.as_mut_ptr() as *mut Box<F>, b);'), (64, '                    data: data.assume_init(),')], 'deleted': [(4, 'use core::mem;'), (41, '                #[allow(deprecated)]'), (42, '                let mut data: Data = mem::uninitialized();'), (43, '                ptr::write(&mut data as *mut Data as *mut F, f);'), (52, '                    data,'), (59, '                #[allow(deprecated)]'), (60, '                let mut data: Data = mem::uninitialized();'), (61, '                ptr::write(&mut data as *mut Data as *mut Box<F>, b);'), (70, '                    data,')]}",
    "num_lines_added": "7",
    "num_lines_deleted": "9",
    "nloc": "103"
  },
  {
    "file_change_id": "146466946079828",
    "hash": "f48c1c763a73467e2fde6158c0abc2faa162ae8",
    "old_path": "crossbeam-epoch/src/sync/queue.rs",
    "new_path": "crossbeam-epoch/src/sync/queue.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -8,8 +8,7 @@\n //! Simon Doherty, Lindsay Groves, Victor Luchangco, and Mark Moir. 2004b. Formal Verification of a\n //! Practical Lock-Free Queue Algorithm. https://doi.org/10.1007/978-3-540-30232-2_7\n \n-use core::mem::{self, ManuallyDrop};\n-use core::ptr;\n+use core::mem::MaybeUninit;\n use core::sync::atomic::Ordering::{Acquire, Relaxed, Release};\n \n use crossbeam_utils::CachePadded;\n@@ -29,11 +28,11 @@ pub struct Queue<T> {\n struct Node<T> {\n     /// The slot in which a value of type `T` can be stored.\n     ///\n-    /// The type of `data` is `ManuallyDrop<T>` because a `Node<T>` doesn't always contain a `T`.\n+    /// The type of `data` is `MaybeUninit<T>` because a `Node<T>` doesn't always contain a `T`.\n     /// For example, the sentinel node in a queue never contains a value: its slot is always empty.\n     /// Other nodes start their life with a push operation and contain a value until it gets popped\n     /// out. After that such empty nodes get added to the collector for destruction.\n-    data: ManuallyDrop<T>,\n+    data: MaybeUninit<T>,\n \n     next: Atomic<Node<T>>,\n }\n@@ -49,11 +48,8 @@ impl<T> Queue<T> {\n             head: CachePadded::new(Atomic::null()),\n             tail: CachePadded::new(Atomic::null()),\n         };\n-        // TODO(taiki-e): when the minimum supported Rust version is bumped to 1.36+,\n-        // replace this with `mem::MaybeUninit`.\n-        #[allow(deprecated)]\n         let sentinel = Owned::new(Node {\n-            data: unsafe { mem::uninitialized() },\n+            data: MaybeUninit::uninit(),\n             next: Atomic::null(),\n         });\n         unsafe {\n@@ -93,7 +89,7 @@ impl<T> Queue<T> {\n     /// Adds `t` to the back of the queue, possibly waking up threads blocked on `pop`.\n     pub fn push(&self, t: T, guard: &Guard) {\n         let new = Owned::new(Node {\n-            data: ManuallyDrop::new(t),\n+            data: MaybeUninit::new(t),\n             next: Atomic::null(),\n         });\n         let new = Owned::into_shared(new, guard);\n@@ -126,7 +122,8 @@ impl<T> Queue<T> {\n                             let _ = self.tail.compare_and_set(tail, next, Release, guard);\n                         }\n                         guard.defer_destroy(head);\n-                        Some(ManuallyDrop::into_inner(ptr::read(&n.data)))\n+                        // TODO: Replace with MaybeUninit::read when api is stable\n+                        Some(n.data.as_ptr().read())\n                     })\n                     .map_err(|_| ())\n             },\n@@ -145,22 +142,25 @@ impl<T> Queue<T> {\n         let head = self.head.load(Acquire, guard);\n         let h = unsafe { head.deref() };\n         let next = h.next.load(Acquire, guard);\n-        match unsafe { next.as_ref() } {\n-            Some(n) if condition(&n.data) => unsafe {\n-                self.head\n-                    .compare_and_set(head, next, Release, guard)\n-                    .map(|_| {\n-                        let tail = self.tail.load(Relaxed, guard);\n-                        // Advance the tail so that we don't retire a pointer to a reachable node.\n-                        if head == tail {\n-                            let _ = self.tail.compare_and_set(tail, next, Release, guard);\n-                        }\n-                        guard.defer_destroy(head);\n-                        Some(ManuallyDrop::into_inner(ptr::read(&n.data)))\n-                    })\n-                    .map_err(|_| ())\n-            },\n-            None | Some(_) => Ok(None),\n+        unsafe {\n+            match next.as_ref() {\n+                Some(n) if condition(&*n.data.as_ptr()) => {\n+                    self.head\n+                        .compare_and_set(head, next, Release, guard)\n+                        .map(|_| {\n+                            let tail = self.tail.load(Relaxed, guard);\n+                            // Advance the tail so that we don't retire a pointer to a reachable node.\n+                            if head == tail {\n+                                let _ = self.tail.compare_and_set(tail, next, Release, guard);\n+                            }\n+                            guard.defer_destroy(head);\n+                            // TODO: Replace with MaybeUninit::read when api is stable\n+                            Some(n.data.as_ptr().read())\n+                        })\n+                        .map_err(|_| ())\n+                }\n+                None | Some(_) => Ok(None),\n+            }\n         }\n     }\n \n",
    "diff_parsed": "{'added': [(11, 'use core::mem::MaybeUninit;'), (35, '    data: MaybeUninit<T>,'), (52, '            data: MaybeUninit::uninit(),'), (92, '            data: MaybeUninit::new(t),'), (126, '                        Some(n.data.as_ptr().read())'), (145, '        unsafe {'), (146, '            match next.as_ref() {'), (147, '                Some(n) if condition(&*n.data.as_ptr()) => {'), (148, '                    self.head'), (149, '                        .compare_and_set(head, next, Release, guard)'), (150, '                        .map(|_| {'), (151, '                            let tail = self.tail.load(Relaxed, guard);'), (153, '                            if head == tail {'), (154, '                                let _ = self.tail.compare_and_set(tail, next, Release, guard);'), (155, '                            }'), (156, '                            guard.defer_destroy(head);'), (158, '                            Some(n.data.as_ptr().read())'), (159, '                        })'), (160, '                        .map_err(|_| ())'), (161, '                }'), (162, '                None | Some(_) => Ok(None),'), (163, '            }')], 'deleted': [(11, 'use core::mem::{self, ManuallyDrop};'), (12, 'use core::ptr;'), (36, '    data: ManuallyDrop<T>,'), (54, '        #[allow(deprecated)]'), (56, '            data: unsafe { mem::uninitialized() },'), (96, '            data: ManuallyDrop::new(t),'), (129, '                        Some(ManuallyDrop::into_inner(ptr::read(&n.data)))'), (148, '        match unsafe { next.as_ref() } {'), (149, '            Some(n) if condition(&n.data) => unsafe {'), (150, '                self.head'), (151, '                    .compare_and_set(head, next, Release, guard)'), (152, '                    .map(|_| {'), (153, '                        let tail = self.tail.load(Relaxed, guard);'), (155, '                        if head == tail {'), (156, '                            let _ = self.tail.compare_and_set(tail, next, Release, guard);'), (157, '                        }'), (158, '                        guard.defer_destroy(head);'), (159, '                        Some(ManuallyDrop::into_inner(ptr::read(&n.data)))'), (160, '                    })'), (161, '                    .map_err(|_| ())'), (162, '            },'), (163, '            None | Some(_) => Ok(None),')]}",
    "num_lines_added": "22",
    "num_lines_deleted": "22",
    "nloc": "363"
  },
  {
    "file_change_id": "153851942560707",
    "hash": "6f3a3c17ea89fe16f55246cdfb64d684a52a529",
    "old_path": "crossbeam-queue/src/array_queue.rs",
    "new_path": "crossbeam-queue/src/array_queue.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -12,7 +12,7 @@ use alloc::vec::Vec;\n use core::cell::UnsafeCell;\n use core::fmt;\n use core::marker::PhantomData;\n-use core::mem;\n+use core::mem::{self, MaybeUninit};\n use core::ptr;\n use core::sync::atomic::{self, AtomicUsize, Ordering};\n \n@@ -29,7 +29,7 @@ struct Slot<T> {\n     stamp: AtomicUsize,\n \n     /// The value in this slot.\n-    value: UnsafeCell<T>,\n+    value: UnsafeCell<MaybeUninit<T>>,\n }\n \n /// A bounded multi-producer multi-consumer queue.\n@@ -186,9 +186,7 @@ impl<T> ArrayQueue<T> {\n                 ) {\n                     Ok(_) => {\n                         // Write the value into the slot and update the stamp.\n-                        unsafe {\n-                            slot.value.get().write(value);\n-                        }\n+                        unsafe { slot.value.get().write(MaybeUninit::new(value)) }\n                         slot.stamp.store(tail + 1, Ordering::Release);\n                         return Ok(());\n                     }\n@@ -266,7 +264,7 @@ impl<T> ArrayQueue<T> {\n                 ) {\n                     Ok(_) => {\n                         // Read the value from the slot and update the stamp.\n-                        let msg = unsafe { slot.value.get().read() };\n+                        let msg = unsafe { slot.value.get().read().assume_init() };\n                         slot.stamp\n                             .store(head.wrapping_add(self.one_lap), Ordering::Release);\n                         return Ok(msg);\n",
    "diff_parsed": "{'added': [(15, 'use core::mem::{self, MaybeUninit};'), (32, '    value: UnsafeCell<MaybeUninit<T>>,'), (189, '                        unsafe { slot.value.get().write(MaybeUninit::new(value)) }'), (267, '                        let msg = unsafe { slot.value.get().read().assume_init() };')], 'deleted': [(15, 'use core::mem;'), (32, '    value: UnsafeCell<T>,'), (189, '                        unsafe {'), (190, '                            slot.value.get().write(value);'), (191, '                        }'), (269, '                        let msg = unsafe { slot.value.get().read() };')]}",
    "num_lines_added": "4",
    "num_lines_deleted": "6",
    "nloc": "195"
  },
  {
    "file_change_id": "211350450025580",
    "hash": "71d2799afe690ef9d07bb77614c6bb164cb8e67",
    "old_path": "crossbeam-channel/src/flavors/array.rs",
    "new_path": "crossbeam-channel/src/flavors/array.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -15,7 +15,7 @@\n \n use std::cell::UnsafeCell;\n use std::marker::PhantomData;\n-use std::mem;\n+use std::mem::{self, MaybeUninit};\n use std::ptr;\n use std::sync::atomic::{self, AtomicUsize, Ordering};\n use std::time::Instant;\n@@ -33,7 +33,7 @@ struct Slot<T> {\n     stamp: AtomicUsize,\n \n     /// The message in this slot.\n-    msg: UnsafeCell<T>,\n+    msg: UnsafeCell<MaybeUninit<T>>,\n }\n \n /// The token type for the array flavor.\n@@ -233,7 +233,7 @@ impl<T> Channel<T> {\n         let slot: &Slot<T> = &*(token.array.slot as *const Slot<T>);\n \n         // Write the message into the slot and update the stamp.\n-        slot.msg.get().write(msg);\n+        slot.msg.get().write(MaybeUninit::new(msg));\n         slot.stamp.store(token.array.stamp, Ordering::Release);\n \n         // Wake a sleeping receiver.\n@@ -323,7 +323,7 @@ impl<T> Channel<T> {\n         let slot: &Slot<T> = &*(token.array.slot as *const Slot<T>);\n \n         // Read the message from the slot and update the stamp.\n-        let msg = slot.msg.get().read();\n+        let msg = slot.msg.get().read().assume_init();\n         slot.stamp.store(token.array.stamp, Ordering::Release);\n \n         // Wake a sleeping sender.\n",
    "diff_parsed": "{'added': [(18, 'use std::mem::{self, MaybeUninit};'), (36, '    msg: UnsafeCell<MaybeUninit<T>>,'), (236, '        slot.msg.get().write(MaybeUninit::new(msg));'), (326, '        let msg = slot.msg.get().read().assume_init();')], 'deleted': [(18, 'use std::mem;'), (36, '    msg: UnsafeCell<T>,'), (236, '        slot.msg.get().write(msg);'), (326, '        let msg = slot.msg.get().read();')]}",
    "num_lines_added": "4",
    "num_lines_deleted": "4",
    "nloc": "410"
  },
  {
    "file_change_id": "14469663272192",
    "hash": "b5525b73a5955c5f39157f088b78b93e8943649",
    "old_path": "crossbeam-channel/src/flavors/array.rs",
    "new_path": "crossbeam-channel/src/flavors/array.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -15,13 +15,15 @@\n \n use std::cell::UnsafeCell;\n use std::marker::PhantomData;\n-use std::mem::{self, MaybeUninit};\n+use std::mem;\n use std::ptr;\n use std::sync::atomic::{self, AtomicUsize, Ordering};\n use std::time::Instant;\n \n use crossbeam_utils::{Backoff, CachePadded};\n \n+use maybe_uninit::MaybeUninit;\n+\n use context::Context;\n use err::{RecvTimeoutError, SendTimeoutError, TryRecvError, TrySendError};\n use select::{Operation, SelectHandle, Selected, Token};\n",
    "diff_parsed": "{'added': [(18, 'use std::mem;'), (25, 'use maybe_uninit::MaybeUninit;')], 'deleted': [(18, 'use std::mem::{self, MaybeUninit};')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "1",
    "nloc": "416"
  },
  {
    "file_change_id": "18505042591233",
    "hash": "b5525b73a5955c5f39157f088b78b93e8943649",
    "old_path": "crossbeam-channel/src/flavors/list.rs",
    "new_path": "crossbeam-channel/src/flavors/list.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -2,13 +2,14 @@\n \n use std::cell::UnsafeCell;\n use std::marker::PhantomData;\n-use std::mem::MaybeUninit;\n use std::ptr;\n use std::sync::atomic::{self, AtomicPtr, AtomicUsize, Ordering};\n use std::time::Instant;\n \n use crossbeam_utils::{Backoff, CachePadded};\n \n+use maybe_uninit::MaybeUninit;\n+\n use context::Context;\n use err::{RecvTimeoutError, SendTimeoutError, TryRecvError, TrySendError};\n use select::{Operation, SelectHandle, Selected, Token};\n",
    "diff_parsed": "{'added': [(11, 'use maybe_uninit::MaybeUninit;')], 'deleted': [(5, 'use std::mem::MaybeUninit;')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "447"
  },
  {
    "file_change_id": "46936274014871",
    "hash": "b5525b73a5955c5f39157f088b78b93e8943649",
    "old_path": "crossbeam-channel/src/lib.rs",
    "new_path": "crossbeam-channel/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -348,6 +348,7 @@\n #![warn(missing_debug_implementations)]\n \n extern crate crossbeam_utils;\n+extern crate maybe_uninit;\n \n mod channel;\n mod context;\n",
    "diff_parsed": "{'added': [(351, 'extern crate maybe_uninit;')], 'deleted': []}",
    "num_lines_added": "1",
    "num_lines_deleted": "0",
    "nloc": "26"
  },
  {
    "file_change_id": "20785531641737",
    "hash": "b5525b73a5955c5f39157f088b78b93e8943649",
    "old_path": "crossbeam-deque/src/lib.rs",
    "new_path": "crossbeam-deque/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -92,12 +92,14 @@\n extern crate crossbeam_epoch as epoch;\n extern crate crossbeam_utils as utils;\n \n+extern crate maybe_uninit;\n+\n use std::cell::{Cell, UnsafeCell};\n use std::cmp;\n use std::fmt;\n use std::iter::FromIterator;\n use std::marker::PhantomData;\n-use std::mem::{self, MaybeUninit};\n+use std::mem;\n use std::ptr;\n use std::sync::atomic::{self, AtomicIsize, AtomicPtr, AtomicUsize, Ordering};\n use std::sync::Arc;\n@@ -105,6 +107,8 @@ use std::sync::Arc;\n use epoch::{Atomic, Owned};\n use utils::{Backoff, CachePadded};\n \n+use maybe_uninit::MaybeUninit;\n+\n // Minimum buffer capacity.\n const MIN_CAP: usize = 64;\n // Maximum number of tasks that can be stolen in `steal_batch()` and `steal_batch_and_pop()`.\n",
    "diff_parsed": "{'added': [(95, 'extern crate maybe_uninit;'), (102, 'use std::mem;'), (110, 'use maybe_uninit::MaybeUninit;')], 'deleted': [(100, 'use std::mem::{self, MaybeUninit};')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "1",
    "nloc": "999"
  },
  {
    "file_change_id": "24392842973456",
    "hash": "b5525b73a5955c5f39157f088b78b93e8943649",
    "old_path": "crossbeam-epoch/src/deferred.rs",
    "new_path": "crossbeam-epoch/src/deferred.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,9 +1,11 @@\n use alloc::boxed::Box;\n use core::fmt;\n use core::marker::PhantomData;\n-use core::mem::{self, MaybeUninit};\n+use core::mem;\n use core::ptr;\n \n+use maybe_uninit::MaybeUninit;\n+\n /// Number of words a piece of `Data` can hold.\n ///\n /// Three words should be enough for the majority of cases. For example, you can fit inside it the\n",
    "diff_parsed": "{'added': [(4, 'use core::mem;'), (7, 'use maybe_uninit::MaybeUninit;')], 'deleted': [(4, 'use core::mem::{self, MaybeUninit};')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "1",
    "nloc": "104"
  },
  {
    "file_change_id": "26793214310048",
    "hash": "b5525b73a5955c5f39157f088b78b93e8943649",
    "old_path": "crossbeam-epoch/src/lib.rs",
    "new_path": "crossbeam-epoch/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -64,6 +64,8 @@ extern crate cfg_if;\n #[cfg(feature = \"std\")]\n extern crate core;\n \n+extern crate maybe_uninit;\n+\n cfg_if! {\n     if #[cfg(feature = \"alloc\")] {\n         extern crate alloc;\n",
    "diff_parsed": "{'added': [(67, 'extern crate maybe_uninit;')], 'deleted': []}",
    "num_lines_added": "1",
    "num_lines_deleted": "0",
    "nloc": "44"
  },
  {
    "file_change_id": "4707936947010",
    "hash": "b5525b73a5955c5f39157f088b78b93e8943649",
    "old_path": "crossbeam-epoch/src/sync/queue.rs",
    "new_path": "crossbeam-epoch/src/sync/queue.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -8,11 +8,12 @@\n //! Simon Doherty, Lindsay Groves, Victor Luchangco, and Mark Moir. 2004b. Formal Verification of a\n //! Practical Lock-Free Queue Algorithm. https://doi.org/10.1007/978-3-540-30232-2_7\n \n-use core::mem::MaybeUninit;\n use core::sync::atomic::Ordering::{Acquire, Relaxed, Release};\n \n use crossbeam_utils::CachePadded;\n \n+use maybe_uninit::MaybeUninit;\n+\n use {unprotected, Atomic, Guard, Owned, Shared};\n \n // The representation here is a singly-linked list, with a sentinel node at the front. In general\n",
    "diff_parsed": "{'added': [(15, 'use maybe_uninit::MaybeUninit;')], 'deleted': [(11, 'use core::mem::MaybeUninit;')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "362"
  },
  {
    "file_change_id": "253329005486691",
    "hash": "b5525b73a5955c5f39157f088b78b93e8943649",
    "old_path": "crossbeam-queue/src/array_queue.rs",
    "new_path": "crossbeam-queue/src/array_queue.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -12,12 +12,14 @@ use alloc::vec::Vec;\n use core::cell::UnsafeCell;\n use core::fmt;\n use core::marker::PhantomData;\n-use core::mem::{self, MaybeUninit};\n+use core::mem;\n use core::ptr;\n use core::sync::atomic::{self, AtomicUsize, Ordering};\n \n use crossbeam_utils::{Backoff, CachePadded};\n \n+use maybe_uninit::MaybeUninit;\n+\n use err::{PopError, PushError};\n \n /// A slot in a queue.\n",
    "diff_parsed": "{'added': [(15, 'use core::mem;'), (21, 'use maybe_uninit::MaybeUninit;')], 'deleted': [(15, 'use core::mem::{self, MaybeUninit};')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "1",
    "nloc": "201"
  },
  {
    "file_change_id": "181473267328411",
    "hash": "b5525b73a5955c5f39157f088b78b93e8943649",
    "old_path": "crossbeam-queue/src/lib.rs",
    "new_path": "crossbeam-queue/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -17,6 +17,8 @@ extern crate cfg_if;\n #[cfg(feature = \"std\")]\n extern crate core;\n \n+extern crate maybe_uninit;\n+\n cfg_if! {\n     if #[cfg(feature = \"alloc\")] {\n         extern crate alloc;\n",
    "diff_parsed": "{'added': [(20, 'extern crate maybe_uninit;')], 'deleted': []}",
    "num_lines_added": "1",
    "num_lines_deleted": "0",
    "nloc": "26"
  },
  {
    "file_change_id": "14420703283913",
    "hash": "b5525b73a5955c5f39157f088b78b93e8943649",
    "old_path": "crossbeam-queue/src/seg_queue.rs",
    "new_path": "crossbeam-queue/src/seg_queue.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -2,12 +2,13 @@ use alloc::boxed::Box;\n use core::cell::UnsafeCell;\n use core::fmt;\n use core::marker::PhantomData;\n-use core::mem::MaybeUninit;\n use core::ptr;\n use core::sync::atomic::{self, AtomicPtr, AtomicUsize, Ordering};\n \n use crossbeam_utils::{Backoff, CachePadded};\n \n+use maybe_uninit::MaybeUninit;\n+\n use err::PopError;\n \n // Bits indicating the state of a slot:\n",
    "diff_parsed": "{'added': [(10, 'use maybe_uninit::MaybeUninit;')], 'deleted': [(5, 'use core::mem::MaybeUninit;')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "273"
  },
  {
    "file_change_id": "25508199821795",
    "hash": "d78de60ea78c3aa0eeca66f42dda0154a7cc89fc",
    "old_path": "crossbeam-queue/src/array_queue.rs",
    "new_path": "crossbeam-queue/src/array_queue.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -413,7 +413,17 @@ impl<T> Drop for ArrayQueue<T> {\n             };\n \n             unsafe {\n-                self.buffer.add(index).drop_in_place();\n+                let ptr = self.buffer.add(index);\n+                {\n+                    // This requires an extra scope because when we drop the Slot,\n+                    // reference to it should not exist.\n+                    let slot = &mut *ptr;\n+                    let value = &mut *slot.value.get();\n+                    // Drop the message (MaybeUninit<T>).\n+                    value.as_mut_ptr().drop_in_place();\n+                }\n+                // Drop slot (This should be a no-op).\n+                ptr.drop_in_place();\n             }\n         }\n \n",
    "diff_parsed": "{'added': [(416, '                let ptr = self.buffer.add(index);'), (417, '                {'), (420, '                    let slot = &mut *ptr;'), (421, '                    let value = &mut *slot.value.get();'), (423, '                    value.as_mut_ptr().drop_in_place();'), (424, '                }'), (426, '                ptr.drop_in_place();')], 'deleted': [(416, '                self.buffer.add(index).drop_in_place();')]}",
    "num_lines_added": "7",
    "num_lines_deleted": "1",
    "nloc": "201"
  },
  {
    "file_change_id": "63089506536056",
    "hash": "dce3e118f2778423113e6d6019dd05d88cf7e0e6",
    "old_path": "crossbeam-channel/src/flavors/array.rs",
    "new_path": "crossbeam-channel/src/flavors/array.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -542,7 +542,17 @@ impl<T> Drop for Channel<T> {\n             };\n \n             unsafe {\n-                self.buffer.add(index).drop_in_place();\n+                let ptr = self.buffer.add(index);\n+                {\n+                    // This requires an extra scope because when we drop the Slot,\n+                    // reference to it should not exist.\n+                    let slot = &mut *ptr;\n+                    let msg = &mut *slot.msg.get();\n+                    // Drop the message (MaybeUninit<T>).\n+                    msg.as_mut_ptr().drop_in_place();\n+                }\n+                // Drop slot (This should be a no-op).\n+                ptr.drop_in_place();\n             }\n         }\n \n",
    "diff_parsed": "{'added': [(545, '                let ptr = self.buffer.add(index);'), (546, '                {'), (549, '                    let slot = &mut *ptr;'), (550, '                    let msg = &mut *slot.msg.get();'), (552, '                    msg.as_mut_ptr().drop_in_place();'), (553, '                }'), (555, '                ptr.drop_in_place();')], 'deleted': [(545, '                self.buffer.add(index).drop_in_place();')]}",
    "num_lines_added": "7",
    "num_lines_deleted": "1",
    "nloc": "416"
  },
  {
    "file_change_id": "234064328716667",
    "hash": "65d17446c4242da0f9e1ae84b9dbce5108a822f",
    "old_path": "src/hdr/decoder.rs",
    "new_path": "src/hdr/decoder.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -330,57 +330,48 @@ impl<R: BufRead> HDRDecoder<R> {\n     pub fn read_image_transform<T: Send, F: Send + Sync + Fn(RGBE8Pixel) -> T>(\n         mut self,\n         f: F,\n-    ) -> ImageResult<Vec<T>> {\n+        output_slice: &mut [T],\n+    ) -> ImageResult<()> {\n+        assert_eq!(output_slice.len(), self.width as usize * self.height as usize);\n+\n         // Don't read anything if image is empty\n         if self.width == 0 || self.height == 0 {\n-            return Ok(vec![]);\n+            return Ok(());\n         }\n-        // expression self.width > 0 && self.height > 0 is true from now to the end of this method\n-        // scanline buffer\n-        let uszwidth = self.width as usize;\n \n-        let pixel_count = self.width as usize * self.height as usize;\n-        let mut ret = Vec::with_capacity(pixel_count);\n-        unsafe {\n-            // RGBE8Pixel doesn't implement Drop, so it's Ok to drop half-initialized ret\n-            ret.set_len(pixel_count);\n-        } // ret contains uninitialized data, so now it's my responsibility to return fully initialized ret\n-\n-        {\n-            let chunks_iter = ret.chunks_mut(uszwidth);\n-            let mut pool = Pool::new(8); //\n-\n-            try!(pool.scoped(|scope| {\n-                for chunk in chunks_iter {\n-                    let mut buf = Vec::<RGBE8Pixel>::with_capacity(uszwidth);\n-                    unsafe {\n-                        buf.set_len(uszwidth);\n+        let chunks_iter = output_slice.chunks_mut(self.width as usize);\n+        let mut pool = Pool::new(8); //\n+\n+        try!(pool.scoped(|scope| {\n+            for chunk in chunks_iter {\n+                let mut buf = vec![Default::default(); self.width as usize];\n+                try!(read_scanline(&mut self.r, &mut buf[..]));\n+                let f = &f;\n+                scope.execute(move || {\n+                    for (dst, &pix) in chunk.iter_mut().zip(buf.iter()) {\n+                        *dst = f(pix);\n                     }\n-                    try!(read_scanline(&mut self.r, &mut buf[..]));\n-                    let f = &f;\n-                    scope.execute(move || {\n-                        for (dst, &pix) in chunk.iter_mut().zip(buf.iter()) {\n-                            *dst = f(pix);\n-                        }\n-                    });\n-                }\n-                Ok(())\n-            }) as Result<(), ImageError>);\n-        }\n-\n-        Ok(ret)\n+                });\n+            }\n+            Ok(())\n+        }) as Result<(), ImageError>);\n+        Ok(())\n     }\n \n     /// Consumes decoder and returns a vector of Rgb<u8> pixels.\n     /// scale = 1, gamma = 2.2\n     pub fn read_image_ldr(self) -> ImageResult<Vec<Rgb<u8>>> {\n-        self.read_image_transform(|pix| pix.to_ldr())\n+        let mut ret = vec![Rgb([0,0,0]); self.width as usize * self.height as usize];\n+        self.read_image_transform(|pix| pix.to_ldr(), &mut ret[..])?;\n+        Ok(ret)\n     }\n \n     /// Consumes decoder and returns a vector of Rgb<f32> pixels.\n     ///\n     pub fn read_image_hdr(self) -> ImageResult<Vec<Rgb<f32>>> {\n-        self.read_image_transform(|pix| pix.to_hdr())\n+        let mut ret = vec![Rgb([0.0, 0.0, 0.0]); self.width as usize * self.height as usize];\n+        self.read_image_transform(|pix| pix.to_hdr(), &mut ret[..])?;\n+        Ok(ret)\n     }\n }\n \n",
    "diff_parsed": "{'added': [(333, '        output_slice: &mut [T],'), (334, '    ) -> ImageResult<()> {'), (335, '        assert_eq!(output_slice.len(), self.width as usize * self.height as usize);'), (339, '            return Ok(());'), (342, '        let chunks_iter = output_slice.chunks_mut(self.width as usize);'), (343, '        let mut pool = Pool::new(8); //'), (345, '        try!(pool.scoped(|scope| {'), (346, '            for chunk in chunks_iter {'), (347, '                let mut buf = vec![Default::default(); self.width as usize];'), (348, '                try!(read_scanline(&mut self.r, &mut buf[..]));'), (349, '                let f = &f;'), (350, '                scope.execute(move || {'), (351, '                    for (dst, &pix) in chunk.iter_mut().zip(buf.iter()) {'), (352, '                        *dst = f(pix);'), (354, '                });'), (355, '            }'), (356, '            Ok(())'), (357, '        }) as Result<(), ImageError>);'), (358, '        Ok(())'), (364, '        let mut ret = vec![Rgb([0,0,0]); self.width as usize * self.height as usize];'), (365, '        self.read_image_transform(|pix| pix.to_ldr(), &mut ret[..])?;'), (366, '        Ok(ret)'), (372, '        let mut ret = vec![Rgb([0.0, 0.0, 0.0]); self.width as usize * self.height as usize];'), (373, '        self.read_image_transform(|pix| pix.to_hdr(), &mut ret[..])?;'), (374, '        Ok(ret)')], 'deleted': [(333, '    ) -> ImageResult<Vec<T>> {'), (336, '            return Ok(vec![]);'), (340, '        let uszwidth = self.width as usize;'), (342, '        let pixel_count = self.width as usize * self.height as usize;'), (343, '        let mut ret = Vec::with_capacity(pixel_count);'), (344, '        unsafe {'), (346, '            ret.set_len(pixel_count);'), (347, \"        } // ret contains uninitialized data, so now it's my responsibility to return fully initialized ret\"), (349, '        {'), (350, '            let chunks_iter = ret.chunks_mut(uszwidth);'), (351, '            let mut pool = Pool::new(8); //'), (353, '            try!(pool.scoped(|scope| {'), (354, '                for chunk in chunks_iter {'), (355, '                    let mut buf = Vec::<RGBE8Pixel>::with_capacity(uszwidth);'), (356, '                    unsafe {'), (357, '                        buf.set_len(uszwidth);'), (359, '                    try!(read_scanline(&mut self.r, &mut buf[..]));'), (360, '                    let f = &f;'), (361, '                    scope.execute(move || {'), (362, '                        for (dst, &pix) in chunk.iter_mut().zip(buf.iter()) {'), (363, '                            *dst = f(pix);'), (364, '                        }'), (365, '                    });'), (366, '                }'), (367, '                Ok(())'), (368, '            }) as Result<(), ImageError>);'), (369, '        }'), (371, '        Ok(ret)'), (377, '        self.read_image_transform(|pix| pix.to_ldr())'), (383, '        self.read_image_transform(|pix| pix.to_hdr())')]}",
    "num_lines_added": "25",
    "num_lines_deleted": "30",
    "nloc": "737"
  },
  {
    "file_change_id": "32407099163010",
    "hash": "6c7bf22907a75d1bbaed52e4f7dd9716f5e6f73",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -143,7 +143,8 @@ pub fn clean_text(src: &str) -> String {\n             ' ' => \"&#32;\",\n             '\\t' => \"&#9;\",\n             '\\n' => \"&#10;\",\n-            '\\r' => \"&#12;\",\n+            '\\x0c' => \"&#12;\",\n+            '\\r' => \"&#13;\",\n             // a spec-compliant browser will perform this replacement anyway, but the middleware might not\n             '\\0' => \"&#65533;\",\n             // ALL OTHER CHARACTERS ARE PASSED THROUGH VERBATIM\n@@ -3436,6 +3437,14 @@ mod test {\n         );\n     }\n \n+    #[test]\n+    fn clean_text_spaces_test() {\n+        assert_eq!(\n+            clean_text(\"\\x09\\x0a\\x0c\\x20\"),\n+            \"&#9;&#10;&#12;&#32;\"\n+        );\n+    }\n+\n     #[test]\n     fn ns_svg() {\n         // https://github.com/cure53/DOMPurify/pull/495\n",
    "diff_parsed": "{'added': [(146, '            \\'\\\\x0c\\' => \"&#12;\",'), (147, '            \\'\\\\r\\' => \"&#13;\",'), (3440, '    #[test]'), (3441, '    fn clean_text_spaces_test() {'), (3442, '        assert_eq!('), (3443, '            clean_text(\"\\\\x09\\\\x0a\\\\x0c\\\\x20\"),'), (3444, '            \"&#9;&#10;&#12;&#32;\"'), (3445, '        );'), (3446, '    }')], 'deleted': [(146, '            \\'\\\\r\\' => \"&#12;\",')]}",
    "num_lines_added": "9",
    "num_lines_deleted": "1",
    "nloc": "2648"
  },
  {
    "file_change_id": "68744735622009",
    "hash": "4c00d6212aa5fa56d16cc8a1774ad908d10522b",
    "old_path": "lock_api/src/lib.rs",
    "new_path": "lock_api/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -99,6 +99,8 @@ pub struct GuardSend(());\n /// Marker type which indicates that the Guard type for a lock is not `Send`.\n pub struct GuardNoSend(*mut ());\n \n+unsafe impl Sync for GuardNoSend {}\n+\n mod mutex;\n pub use crate::mutex::*;\n \n",
    "diff_parsed": "{'added': [(102, 'unsafe impl Sync for GuardNoSend {}')], 'deleted': []}",
    "num_lines_added": "1",
    "num_lines_deleted": "0",
    "nloc": "15"
  },
  {
    "file_change_id": "148810825877407",
    "hash": "4c00d6212aa5fa56d16cc8a1774ad908d10522b",
    "old_path": "lock_api/src/mutex.rs",
    "new_path": "lock_api/src/mutex.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -601,7 +601,7 @@ unsafe impl<'a, R: RawMutex + Sync + 'a, T: ?Sized + Sync + 'a> Sync\n     for MappedMutexGuard<'a, R, T>\n {\n }\n-unsafe impl<'a, R: RawMutex + 'a, T: ?Sized + 'a> Send for MappedMutexGuard<'a, R, T> where\n+unsafe impl<'a, R: RawMutex + 'a, T: ?Sized + Send + 'a> Send for MappedMutexGuard<'a, R, T> where\n     R::GuardMarker: Send\n {\n }\n",
    "diff_parsed": "{'added': [(604, \"unsafe impl<'a, R: RawMutex + 'a, T: ?Sized + Send + 'a> Send for MappedMutexGuard<'a, R, T> where\")], 'deleted': [(604, \"unsafe impl<'a, R: RawMutex + 'a, T: ?Sized + 'a> Send for MappedMutexGuard<'a, R, T> where\")]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "572"
  },
  {
    "file_change_id": "73604754228996",
    "hash": "4c00d6212aa5fa56d16cc8a1774ad908d10522b",
    "old_path": "lock_api/src/rwlock.rs",
    "new_path": "lock_api/src/rwlock.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -875,8 +875,6 @@ pub struct RwLockReadGuard<'a, R: RawRwLock, T: ?Sized> {\n     marker: PhantomData<(&'a T, R::GuardMarker)>,\n }\n \n-unsafe impl<'a, R: RawRwLock + 'a, T: ?Sized + Sync + 'a> Sync for RwLockReadGuard<'a, R, T> {}\n-\n impl<'a, R: RawRwLock + 'a, T: ?Sized + 'a> RwLockReadGuard<'a, R, T> {\n     /// Returns a reference to the original reader-writer lock object.\n     pub fn rwlock(s: &Self) -> &'a RwLock<R, T> {\n@@ -1051,8 +1049,6 @@ pub struct RwLockWriteGuard<'a, R: RawRwLock, T: ?Sized> {\n     marker: PhantomData<(&'a mut T, R::GuardMarker)>,\n }\n \n-unsafe impl<'a, R: RawRwLock + 'a, T: ?Sized + Sync + 'a> Sync for RwLockWriteGuard<'a, R, T> {}\n-\n impl<'a, R: RawRwLock + 'a, T: ?Sized + 'a> RwLockWriteGuard<'a, R, T> {\n     /// Returns a reference to the original reader-writer lock object.\n     pub fn rwlock(s: &Self) -> &'a RwLock<R, T> {\n@@ -1514,7 +1510,7 @@ pub struct MappedRwLockReadGuard<'a, R: RawRwLock, T: ?Sized> {\n }\n \n unsafe impl<'a, R: RawRwLock + 'a, T: ?Sized + Sync + 'a> Sync for MappedRwLockReadGuard<'a, R, T> {}\n-unsafe impl<'a, R: RawRwLock + 'a, T: ?Sized + 'a> Send for MappedRwLockReadGuard<'a, R, T> where\n+unsafe impl<'a, R: RawRwLock + 'a, T: ?Sized + Sync + 'a> Send for MappedRwLockReadGuard<'a, R, T> where\n     R::GuardMarker: Send\n {\n }\n@@ -1652,7 +1648,7 @@ unsafe impl<'a, R: RawRwLock + 'a, T: ?Sized + Sync + 'a> Sync\n     for MappedRwLockWriteGuard<'a, R, T>\n {\n }\n-unsafe impl<'a, R: RawRwLock + 'a, T: ?Sized + 'a> Send for MappedRwLockWriteGuard<'a, R, T> where\n+unsafe impl<'a, R: RawRwLock + 'a, T: ?Sized + Send + 'a> Send for MappedRwLockWriteGuard<'a, R, T> where\n     R::GuardMarker: Send\n {\n }\n",
    "diff_parsed": "{'added': [(1513, \"unsafe impl<'a, R: RawRwLock + 'a, T: ?Sized + Sync + 'a> Send for MappedRwLockReadGuard<'a, R, T> where\"), (1651, \"unsafe impl<'a, R: RawRwLock + 'a, T: ?Sized + Send + 'a> Send for MappedRwLockWriteGuard<'a, R, T> where\")], 'deleted': [(878, \"unsafe impl<'a, R: RawRwLock + 'a, T: ?Sized + Sync + 'a> Sync for RwLockReadGuard<'a, R, T> {}\"), (1054, \"unsafe impl<'a, R: RawRwLock + 'a, T: ?Sized + Sync + 'a> Sync for RwLockWriteGuard<'a, R, T> {}\"), (1517, \"unsafe impl<'a, R: RawRwLock + 'a, T: ?Sized + 'a> Send for MappedRwLockReadGuard<'a, R, T> where\"), (1655, \"unsafe impl<'a, R: RawRwLock + 'a, T: ?Sized + 'a> Send for MappedRwLockWriteGuard<'a, R, T> where\")]}",
    "num_lines_added": "2",
    "num_lines_deleted": "4",
    "nloc": "1166"
  },
  {
    "file_change_id": "148101869318815",
    "hash": "a134e06d740f9d7c287f74c0af2cd0620677436",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -314,7 +314,7 @@ pub unsafe fn guarded_transmute_vec_permissive<T>(mut bytes: Vec<u8>) -> Vec<T>\n     let capacity = bytes.capacity() / size_of::<T>();\n     let len = bytes.len() / size_of::<T>();\n     forget(bytes);\n-    Vec::from_raw_parts(ptr as *mut T, capacity, len)\n+    Vec::from_raw_parts(ptr as *mut T, len, capacity)\n }\n \n /// Trasform a byte vector into a vector of an arbitrary type.\n",
    "diff_parsed": "{'added': [(317, '    Vec::from_raw_parts(ptr as *mut T, len, capacity)')], 'deleted': [(317, '    Vec::from_raw_parts(ptr as *mut T, capacity, len)')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "64"
  },
  {
    "file_change_id": "220023623159860",
    "hash": "a134e06d740f9d7c287f74c0af2cd0620677436",
    "old_path": "src/to_bytes.rs",
    "new_path": "src/to_bytes.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -231,7 +231,7 @@ pub unsafe fn guarded_transmute_to_bytes_vec<T>(mut from: Vec<T>) -> Vec<u8> {\n     let len = from.len() * size_of::<T>();\n     let ptr = from.as_mut_ptr();\n     forget(from);\n-    Vec::from_raw_parts(ptr as *mut u8, capacity, len)\n+    Vec::from_raw_parts(ptr as *mut u8, len, capacity)\n }\n \n /// Transmute a vector of POD types into a vector of their bytes,\n",
    "diff_parsed": "{'added': [(234, '    Vec::from_raw_parts(ptr as *mut u8, len, capacity)')], 'deleted': [(234, '    Vec::from_raw_parts(ptr as *mut u8, capacity, len)')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "29"
  },
  {
    "file_change_id": "228577463001331",
    "hash": "4218155363f893032362d083a0e7fe5c5b0865c",
    "old_path": "tower-http/src/services/fs/serve_dir.rs",
    "new_path": "tower-http/src/services/fs/serve_dir.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -137,7 +137,7 @@ fn build_and_validate_path(base_path: &Path, requested_path: &str) -> Option<Pat\n \n     let mut full_path = base_path.to_path_buf();\n     for seg in path_decoded.split('/') {\n-        if seg.starts_with(\"..\") || seg.contains('\\\\') {\n+        if seg.starts_with(\"..\") || seg.contains('\\\\') || seg.contains(':') {\n             return None;\n         }\n         full_path.push(seg);\n",
    "diff_parsed": "{'added': [(140, '        if seg.starts_with(\"..\") || seg.contains(\\'\\\\\\\\\\') || seg.contains(\\':\\') {')], 'deleted': [(140, '        if seg.starts_with(\"..\") || seg.contains(\\'\\\\\\\\\\') {')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "874"
  },
  {
    "file_change_id": "160437827734860",
    "hash": "4ee8515f969d55768d875ea0b32491037a52fa1",
    "old_path": "tower-http/src/services/fs/serve_dir.rs",
    "new_path": "tower-http/src/services/fs/serve_dir.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -130,19 +130,26 @@ impl ServeVariant {\n }\n \n fn build_and_validate_path(base_path: &Path, requested_path: &str) -> Option<PathBuf> {\n-    // build and validate the path\n     let path = requested_path.trim_start_matches('/');\n \n     let path_decoded = percent_decode(path.as_ref()).decode_utf8().ok()?;\n+    let path_decoded = Path::new(&*path_decoded);\n \n     let mut full_path = base_path.to_path_buf();\n-    for seg in path_decoded.split('/') {\n-        if seg.starts_with(\"..\") || seg.contains('\\\\') || seg.contains(':') {\n-            return None;\n+    for component in path_decoded.components() {\n+        match component {\n+            std::path::Component::Normal(comp) => full_path.push(comp),\n+            std::path::Component::CurDir => {}\n+            std::path::Component::Prefix(_)\n+            | std::path::Component::RootDir\n+            | std::path::Component::ParentDir => return None,\n         }\n-        full_path.push(seg);\n     }\n-    Some(full_path)\n+    if full_path.is_relative() {\n+        Some(full_path)\n+    } else {\n+        None\n+    }\n }\n \n impl ServeDir {\n@@ -984,15 +991,10 @@ mod tests {\n \n     #[tokio::test]\n     async fn access_cjk_percent_encoded_uri_path() {\n-        let cjk_filename = \"\u4f60\u597d\u4e16\u754c.txt\";\n         // percent encoding present of \u4f60\u597d\u4e16\u754c.txt\n         let cjk_filename_encoded = \"%E4%BD%A0%E5%A5%BD%E4%B8%96%E7%95%8C.txt\";\n \n-        let tmp_dir = std::env::temp_dir();\n-        let tmp_filename = std::path::Path::new(tmp_dir.as_path()).join(cjk_filename);\n-        let _ = tokio::fs::File::create(&tmp_filename).await.unwrap();\n-\n-        let svc = ServeDir::new(&tmp_dir);\n+        let svc = ServeDir::new(\"../test-files\");\n \n         let req = Request::builder()\n             .uri(format!(\"/{}\", cjk_filename_encoded))\n@@ -1002,20 +1004,13 @@ mod tests {\n \n         assert_eq!(res.status(), StatusCode::OK);\n         assert_eq!(res.headers()[\"content-type\"], \"text/plain\");\n-        let _ = tokio::fs::remove_file(&tmp_filename).await.unwrap();\n     }\n \n     #[tokio::test]\n     async fn access_space_percent_encoded_uri_path() {\n-        let raw_filename = \"filename with space.txt\";\n-        // percent encoding present of \"filename with space.txt\"\n         let encoded_filename = \"filename%20with%20space.txt\";\n \n-        let tmp_dir = std::env::temp_dir();\n-        let tmp_filename = std::path::Path::new(tmp_dir.as_path()).join(raw_filename);\n-        let _ = tokio::fs::File::create(&tmp_filename).await.unwrap();\n-\n-        let svc = ServeDir::new(&tmp_dir);\n+        let svc = ServeDir::new(\"../test-files\");\n \n         let req = Request::builder()\n             .uri(format!(\"/{}\", encoded_filename))\n@@ -1025,7 +1020,6 @@ mod tests {\n \n         assert_eq!(res.status(), StatusCode::OK);\n         assert_eq!(res.headers()[\"content-type\"], \"text/plain\");\n-        let _ = tokio::fs::remove_file(&tmp_filename).await.unwrap();\n     }\n \n     #[tokio::test]\n",
    "diff_parsed": "{'added': [(136, '    let path_decoded = Path::new(&*path_decoded);'), (139, '    for component in path_decoded.components() {'), (140, '        match component {'), (141, '            std::path::Component::Normal(comp) => full_path.push(comp),'), (142, '            std::path::Component::CurDir => {}'), (143, '            std::path::Component::Prefix(_)'), (144, '            | std::path::Component::RootDir'), (145, '            | std::path::Component::ParentDir => return None,'), (148, '    if full_path.is_relative() {'), (149, '        Some(full_path)'), (150, '    } else {'), (151, '        None'), (152, '    }'), (997, '        let svc = ServeDir::new(\"../test-files\");'), (1013, '        let svc = ServeDir::new(\"../test-files\");')], 'deleted': [(139, \"    for seg in path_decoded.split('/') {\"), (140, '        if seg.starts_with(\"..\") || seg.contains(\\'\\\\\\\\\\') || seg.contains(\\':\\') {'), (141, '            return None;'), (143, '        full_path.push(seg);'), (145, '    Some(full_path)'), (987, '        let cjk_filename = \"\u4f60\u597d\u4e16\u754c.txt\";'), (991, '        let tmp_dir = std::env::temp_dir();'), (992, '        let tmp_filename = std::path::Path::new(tmp_dir.as_path()).join(cjk_filename);'), (993, '        let _ = tokio::fs::File::create(&tmp_filename).await.unwrap();'), (995, '        let svc = ServeDir::new(&tmp_dir);'), (1005, '        let _ = tokio::fs::remove_file(&tmp_filename).await.unwrap();'), (1010, '        let raw_filename = \"filename with space.txt\";'), (1014, '        let tmp_dir = std::env::temp_dir();'), (1015, '        let tmp_filename = std::path::Path::new(tmp_dir.as_path()).join(raw_filename);'), (1016, '        let _ = tokio::fs::File::create(&tmp_filename).await.unwrap();'), (1018, '        let svc = ServeDir::new(&tmp_dir);'), (1028, '        let _ = tokio::fs::remove_file(&tmp_filename).await.unwrap();')]}",
    "num_lines_added": "15",
    "num_lines_deleted": "17",
    "nloc": "872"
  },
  {
    "file_change_id": "255693940503973",
    "hash": "877dc0a52adedd1daaabcfcb56d90d1da1da862",
    "old_path": "src/proto/h1/role.rs",
    "new_path": "src/proto/h1/role.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,16 +1,14 @@\n-// `mem::uninitialized` replaced with `mem::MaybeUninit`,\n-// can't upgrade yet\n #![allow(deprecated)]\n \n use std::fmt::{self, Write};\n-use std::mem;\n+use std::mem::{self, MaybeUninit};\n \n #[cfg(any(test, feature = \"server\", feature = \"ffi\"))]\n use bytes::Bytes;\n use bytes::BytesMut;\n-use http::header::{self, Entry, HeaderName, HeaderValue};\n #[cfg(feature = \"server\")]\n use http::header::ValueIter;\n+use http::header::{self, Entry, HeaderName, HeaderValue};\n use http::{HeaderMap, Method, StatusCode, Version};\n \n use crate::body::DecodedLength;\n@@ -126,7 +124,10 @@ impl Http1Transaction for Server {\n         // but we *never* read any of it until after httparse has assigned\n         // values into it. By not zeroing out the stack memory, this saves\n         // a good ~5% on pipeline benchmarks.\n-        let mut headers_indices: [HeaderIndices; MAX_HEADERS] = unsafe { mem::uninitialized() };\n+        let mut headers_indices: [MaybeUninit<HeaderIndices>; MAX_HEADERS] = unsafe {\n+            // SAFETY: We can go safely from MaybeUninit array to array of MaybeUninit\n+            MaybeUninit::uninit().assume_init()\n+        };\n         {\n             let mut headers: [httparse::Header<'_>; MAX_HEADERS] = unsafe { mem::uninitialized() };\n             trace!(\n@@ -205,6 +206,8 @@ impl Http1Transaction for Server {\n         headers.reserve(headers_len);\n \n         for header in &headers_indices[..headers_len] {\n+            // SAFETY: array is valid up to `headers_len`\n+            let header = unsafe { &*header.as_ptr() };\n             let name = header_name!(&slice[header.name.0..header.name.1]);\n             let value = header_value!(slice.slice(header.value.0..header.value.1));\n \n@@ -880,7 +883,10 @@ impl Http1Transaction for Client {\n         // Loop to skip information status code headers (100 Continue, etc).\n         loop {\n             // Unsafe: see comment in Server Http1Transaction, above.\n-            let mut headers_indices: [HeaderIndices; MAX_HEADERS] = unsafe { mem::uninitialized() };\n+            let mut headers_indices: [MaybeUninit<HeaderIndices>; MAX_HEADERS] = unsafe {\n+                // SAFETY: We can go safely from MaybeUninit array to array of MaybeUninit\n+                MaybeUninit::uninit().assume_init()\n+            };\n             let (len, status, reason, version, headers_len) = {\n                 let mut headers: [httparse::Header<'_>; MAX_HEADERS] =\n                     unsafe { mem::uninitialized() };\n@@ -891,8 +897,7 @@ impl Http1Transaction for Client {\n                 );\n                 let mut res = httparse::Response::new(&mut headers);\n                 let bytes = buf.as_ref();\n-                match ctx.h1_parser_config.parse_response(&mut res, bytes)\n-                {\n+                match ctx.h1_parser_config.parse_response(&mut res, bytes) {\n                     Ok(httparse::Status::Complete(len)) => {\n                         trace!(\"Response.parse Complete({})\", len);\n                         let status = StatusCode::from_u16(res.code.unwrap())?;\n@@ -948,6 +953,8 @@ impl Http1Transaction for Client {\n \n             headers.reserve(headers_len);\n             for header in &headers_indices[..headers_len] {\n+                // SAFETY: array is valid up to `headers_len`\n+                let header = unsafe { &*header.as_ptr() };\n                 let name = header_name!(&slice[header.name.0..header.name.1]);\n                 let value = header_value!(slice.slice(header.value.0..header.value.1));\n \n@@ -1290,7 +1297,7 @@ struct HeaderIndices {\n fn record_header_indices(\n     bytes: &[u8],\n     headers: &[httparse::Header<'_>],\n-    indices: &mut [HeaderIndices],\n+    indices: &mut [MaybeUninit<HeaderIndices>],\n ) -> Result<(), crate::error::Parse> {\n     let bytes_ptr = bytes.as_ptr() as usize;\n \n@@ -1301,10 +1308,19 @@ fn record_header_indices(\n         }\n         let name_start = header.name.as_ptr() as usize - bytes_ptr;\n         let name_end = name_start + header.name.len();\n-        indices.name = (name_start, name_end);\n         let value_start = header.value.as_ptr() as usize - bytes_ptr;\n         let value_end = value_start + header.value.len();\n-        indices.value = (value_start, value_end);\n+\n+        // FIXME(maybe_uninit_extra)\n+        // FIXME(addr_of)\n+        // Currently we don't have `ptr::addr_of_mut` in stable rust or\n+        // MaybeUninit::write, so this is some way of assigning into a MaybeUninit\n+        // safely\n+        let new_header_indices = HeaderIndices {\n+            name: (name_start, name_end),\n+            value: (value_start, value_end),\n+        };\n+        *indices = MaybeUninit::new(new_header_indices);\n     }\n \n     Ok(())\n",
    "diff_parsed": "{'added': [(4, 'use std::mem::{self, MaybeUninit};'), (11, 'use http::header::{self, Entry, HeaderName, HeaderValue};'), (127, '        let mut headers_indices: [MaybeUninit<HeaderIndices>; MAX_HEADERS] = unsafe {'), (129, '            MaybeUninit::uninit().assume_init()'), (130, '        };'), (210, '            let header = unsafe { &*header.as_ptr() };'), (886, '            let mut headers_indices: [MaybeUninit<HeaderIndices>; MAX_HEADERS] = unsafe {'), (888, '                MaybeUninit::uninit().assume_init()'), (889, '            };'), (900, '                match ctx.h1_parser_config.parse_response(&mut res, bytes) {'), (957, '                let header = unsafe { &*header.as_ptr() };'), (1300, '    indices: &mut [MaybeUninit<HeaderIndices>],'), (1319, '        let new_header_indices = HeaderIndices {'), (1320, '            name: (name_start, name_end),'), (1321, '            value: (value_start, value_end),'), (1322, '        };'), (1323, '        *indices = MaybeUninit::new(new_header_indices);')], 'deleted': [(6, 'use std::mem;'), (11, 'use http::header::{self, Entry, HeaderName, HeaderValue};'), (129, '        let mut headers_indices: [HeaderIndices; MAX_HEADERS] = unsafe { mem::uninitialized() };'), (883, '            let mut headers_indices: [HeaderIndices; MAX_HEADERS] = unsafe { mem::uninitialized() };'), (894, '                match ctx.h1_parser_config.parse_response(&mut res, bytes)'), (895, '                {'), (1293, '    indices: &mut [HeaderIndices],'), (1304, '        indices.name = (name_start, name_end);'), (1307, '        indices.value = (value_start, value_end);')]}",
    "num_lines_added": "17",
    "num_lines_deleted": "9",
    "nloc": "2478"
  },
  {
    "file_change_id": "163773582660792",
    "hash": "7500d7ddfd1c39a5fbfefd54b9014842d9862af",
    "old_path": "src/proto/h1/role.rs",
    "new_path": "src/proto/h1/role.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -129,15 +129,18 @@ impl Http1Transaction for Server {\n             MaybeUninit::uninit().assume_init()\n         };\n         {\n-            let mut headers: [httparse::Header<'_>; MAX_HEADERS] = unsafe { mem::uninitialized() };\n+            /* SAFETY: it is safe to go from MaybeUninit array to array of MaybeUninit */\n+            let mut headers: [MaybeUninit<httparse::Header<'_>>; MAX_HEADERS] = unsafe {\n+                MaybeUninit::uninit().assume_init()\n+            };\n             trace!(\n                 \"Request.parse([Header; {}], [u8; {}])\",\n                 headers.len(),\n                 buf.len()\n             );\n-            let mut req = httparse::Request::new(&mut headers);\n             let bytes = buf.as_ref();\n-            match req.parse(bytes) {\n+            let (req, status) = httparse::Request::with_uninit_headers(&mut headers, bytes);\n+            match status {\n                 Ok(httparse::Status::Complete(parsed_len)) => {\n                     trace!(\"Request.parse Complete({})\", parsed_len);\n                     len = parsed_len;\n",
    "diff_parsed": "{'added': [(132, '            /* SAFETY: it is safe to go from MaybeUninit array to array of MaybeUninit */'), (133, \"            let mut headers: [MaybeUninit<httparse::Header<'_>>; MAX_HEADERS] = unsafe {\"), (134, '                MaybeUninit::uninit().assume_init()'), (135, '            };'), (142, '            let (req, status) = httparse::Request::with_uninit_headers(&mut headers, bytes);'), (143, '            match status {')], 'deleted': [(132, \"            let mut headers: [httparse::Header<'_>; MAX_HEADERS] = unsafe { mem::uninitialized() };\"), (138, '            let mut req = httparse::Request::new(&mut headers);'), (140, '            match req.parse(bytes) {')]}",
    "num_lines_added": "6",
    "num_lines_deleted": "3",
    "nloc": "2480"
  },
  {
    "file_change_id": "188405538409333",
    "hash": "e57b06f701462547dc5eceb032b0651501ee974",
    "old_path": "src/proto/h1/role.rs",
    "new_path": "src/proto/h1/role.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -891,16 +891,17 @@ impl Http1Transaction for Client {\n                 MaybeUninit::uninit().assume_init()\n             };\n             let (len, status, reason, version, headers_len) = {\n-                let mut headers: [httparse::Header<'_>; MAX_HEADERS] =\n-                    unsafe { mem::uninitialized() };\n+                // SAFETY: We can go safely from MaybeUninit array to array of MaybeUninit\n+                let mut headers: [MaybeUninit<httparse::Header<'_>>; MAX_HEADERS] =\n+                    unsafe { MaybeUninit::uninit().assume_init() };\n                 trace!(\n                     \"Response.parse([Header; {}], [u8; {}])\",\n                     headers.len(),\n                     buf.len()\n                 );\n-                let mut res = httparse::Response::new(&mut headers);\n                 let bytes = buf.as_ref();\n-                match ctx.h1_parser_config.parse_response(&mut res, bytes) {\n+                let (res, status) = ctx.h1_parser_config.parse_response_with_uninit_headers(&mut headers, bytes);\n+                match status {\n                     Ok(httparse::Status::Complete(len)) => {\n                         trace!(\"Response.parse Complete({})\", len);\n                         let status = StatusCode::from_u16(res.code.unwrap())?;\n",
    "diff_parsed": "{'added': [(895, \"                let mut headers: [MaybeUninit<httparse::Header<'_>>; MAX_HEADERS] =\"), (896, '                    unsafe { MaybeUninit::uninit().assume_init() };'), (903, '                let (res, status) = ctx.h1_parser_config.parse_response_with_uninit_headers(&mut headers, bytes);'), (904, '                match status {')], 'deleted': [(894, \"                let mut headers: [httparse::Header<'_>; MAX_HEADERS] =\"), (895, '                    unsafe { mem::uninitialized() };'), (901, '                let mut res = httparse::Response::new(&mut headers);'), (903, '                match ctx.h1_parser_config.parse_response(&mut res, bytes) {')]}",
    "num_lines_added": "4",
    "num_lines_deleted": "4",
    "nloc": "2481"
  },
  {
    "file_change_id": "174009489931725",
    "hash": "5cf0b14921d2d21b0317307441cd6e7c36fa0da",
    "old_path": "src/proto/h1/role.rs",
    "new_path": "src/proto/h1/role.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -138,9 +138,9 @@ impl Http1Transaction for Server {\n                 headers.len(),\n                 buf.len()\n             );\n+            let mut req = httparse::Request::new(&mut []);\n             let bytes = buf.as_ref();\n-            let (req, status) = httparse::Request::with_uninit_headers(&mut headers, bytes);\n-            match status {\n+            match req.parse_with_uninit_headers(bytes, &mut headers) {\n                 Ok(httparse::Status::Complete(parsed_len)) => {\n                     trace!(\"Request.parse Complete({})\", parsed_len);\n                     len = parsed_len;\n@@ -899,9 +899,11 @@ impl Http1Transaction for Client {\n                     headers.len(),\n                     buf.len()\n                 );\n+                let mut res = httparse::Response::new(&mut []);\n                 let bytes = buf.as_ref();\n-                let (res, status) = ctx.h1_parser_config.parse_response_with_uninit_headers(&mut headers, bytes);\n-                match status {\n+                match ctx.h1_parser_config\n+                    .parse_response_with_uninit_headers(&mut res, bytes, &mut headers)\n+                {\n                     Ok(httparse::Status::Complete(len)) => {\n                         trace!(\"Response.parse Complete({})\", len);\n                         let status = StatusCode::from_u16(res.code.unwrap())?;\n",
    "diff_parsed": "{'added': [(141, '            let mut req = httparse::Request::new(&mut []);'), (143, '            match req.parse_with_uninit_headers(bytes, &mut headers) {'), (902, '                let mut res = httparse::Response::new(&mut []);'), (904, '                match ctx.h1_parser_config'), (905, '                    .parse_response_with_uninit_headers(&mut res, bytes, &mut headers)'), (906, '                {')], 'deleted': [(142, '            let (req, status) = httparse::Request::with_uninit_headers(&mut headers, bytes);'), (143, '            match status {'), (903, '                let (res, status) = ctx.h1_parser_config.parse_response_with_uninit_headers(&mut headers, bytes);'), (904, '                match status {')]}",
    "num_lines_added": "6",
    "num_lines_deleted": "4",
    "nloc": "2483"
  },
  {
    "file_change_id": "193666774132277",
    "hash": "684f2fa76d44fa2b1b063ad0443a1b0d16dfad0e",
    "old_path": "src/proto/h1/role.rs",
    "new_path": "src/proto/h1/role.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1308,36 +1308,18 @@ fn record_header_indices(\n     Ok(())\n }\n \n-// Write header names as title case. The header name is assumed to be ASCII,\n-// therefore it is trivial to convert an ASCII character from lowercase to\n-// uppercase. It is as simple as XORing the lowercase character byte with\n-// space.\n+// Write header names as title case. The header name is assumed to be ASCII.\n fn title_case(dst: &mut Vec<u8>, name: &[u8]) {\n     dst.reserve(name.len());\n \n-    let mut iter = name.iter();\n-\n-    // Uppercase the first character\n-    if let Some(c) = iter.next() {\n-        if *c >= b'a' && *c <= b'z' {\n-            dst.push(*c ^ b' ');\n-        } else {\n-            dst.push(*c);\n-        }\n-    }\n-\n-    while let Some(c) = iter.next() {\n-        dst.push(*c);\n-\n-        if *c == b'-' {\n-            if let Some(c) = iter.next() {\n-                if *c >= b'a' && *c <= b'z' {\n-                    dst.push(*c ^ b' ');\n-                } else {\n-                    dst.push(*c);\n-                }\n-            }\n+    // Ensure first character is uppercased\n+    let mut prev = b'-';\n+    for &(mut c) in name {\n+        if prev == b'-' {\n+            c.make_ascii_uppercase();\n         }\n+        dst.push(c);\n+        prev = c;\n     }\n }\n \n@@ -2316,6 +2298,8 @@ mod tests {\n             .insert(\"content-length\", HeaderValue::from_static(\"10\"));\n         head.headers\n             .insert(\"content-type\", HeaderValue::from_static(\"application/json\"));\n+        head.headers\n+            .insert(\"weird--header\", HeaderValue::from_static(\"\"));\n \n         let mut vec = Vec::new();\n         Server::encode(\n@@ -2331,7 +2315,7 @@ mod tests {\n         .unwrap();\n \n         let expected_response =\n-            b\"HTTP/1.1 200 OK\\r\\nContent-Length: 10\\r\\nContent-Type: application/json\\r\\n\";\n+            b\"HTTP/1.1 200 OK\\r\\nContent-Length: 10\\r\\nContent-Type: application/json\\r\\nWeird--Header: \\r\\n\";\n \n         assert_eq!(&vec[..expected_response.len()], &expected_response[..]);\n     }\n",
    "diff_parsed": "{'added': [(1316, \"    let mut prev = b'-';\"), (1317, '    for &(mut c) in name {'), (1318, \"        if prev == b'-' {\"), (1319, '            c.make_ascii_uppercase();'), (1321, '        dst.push(c);'), (1322, '        prev = c;'), (2301, '        head.headers'), (2302, '            .insert(\"weird--header\", HeaderValue::from_static(\"\"));'), (2318, '            b\"HTTP/1.1 200 OK\\\\r\\\\nContent-Length: 10\\\\r\\\\nContent-Type: application/json\\\\r\\\\nWeird--Header: \\\\r\\\\n\";')], 'deleted': [(1318, '    let mut iter = name.iter();'), (1321, '    if let Some(c) = iter.next() {'), (1322, \"        if *c >= b'a' && *c <= b'z' {\"), (1323, \"            dst.push(*c ^ b' ');\"), (1324, '        } else {'), (1325, '            dst.push(*c);'), (1326, '        }'), (1327, '    }'), (1329, '    while let Some(c) = iter.next() {'), (1330, '        dst.push(*c);'), (1332, \"        if *c == b'-' {\"), (1333, '            if let Some(c) = iter.next() {'), (1334, \"                if *c >= b'a' && *c <= b'z' {\"), (1335, \"                    dst.push(*c ^ b' ');\"), (1336, '                } else {'), (1337, '                    dst.push(*c);'), (1338, '                }'), (1339, '            }'), (2334, '            b\"HTTP/1.1 200 OK\\\\r\\\\nContent-Length: 10\\\\r\\\\nContent-Type: application/json\\\\r\\\\n\";')]}",
    "num_lines_added": "9",
    "num_lines_deleted": "19",
    "nloc": "2527"
  },
  {
    "file_change_id": "234889500632543",
    "hash": "df65b33f8a9dbd06b95b0a6af7521f0d4723354",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1135,7 +1135,7 @@ impl<K: Hash + Eq, V, S: BuildHasher> IntoIterator for LinkedHashMap<K, V, S> {\n         }\n         self.clear_free_list();\n         // drop the HashMap but not the LinkedHashMap\n-        self.map = unsafe { mem::uninitialized() };\n+        unsafe { ptr::drop_in_place(&mut self.map); }\n         mem::forget(self);\n \n         IntoIter {\n",
    "diff_parsed": "{'added': [(1138, '        unsafe { ptr::drop_in_place(&mut self.map); }')], 'deleted': [(1138, '        self.map = unsafe { mem::uninitialized() };')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "927"
  },
  {
    "file_change_id": "255898757122671",
    "hash": "a83ccecf515b5273e4dd0306c1b9f6dcb7daf96",
    "old_path": "lib.rs",
    "new_path": "lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -63,7 +63,7 @@ use std::iter::{repeat, FromIterator, IntoIterator};\n #[cfg(feature = \"serde\")]\n use std::marker::PhantomData;\n use std::mem;\n-use std::mem::ManuallyDrop;\n+use std::mem::MaybeUninit;\n use std::ops;\n use std::ptr;\n use std::slice;\n@@ -280,29 +280,27 @@ impl<'a, T: 'a> Drop for Drain<'a, T> {\n \n #[cfg(feature = \"union\")]\n union SmallVecData<A: Array> {\n-    inline: ManuallyDrop<A>,\n+    inline: MaybeUninit<A>,\n     heap: (*mut A::Item, usize),\n }\n \n #[cfg(feature = \"union\")]\n impl<A: Array> SmallVecData<A> {\n     #[inline]\n-    unsafe fn inline(&self) -> &A {\n-        &self.inline\n+    unsafe fn inline(&self) -> *const A::Item {\n+        self.inline.as_ptr() as *const A::Item\n     }\n     #[inline]\n-    unsafe fn inline_mut(&mut self) -> &mut A {\n-        &mut self.inline\n+    unsafe fn inline_mut(&mut self) -> *mut A::Item {\n+        self.inline.as_mut_ptr() as *mut A::Item\n     }\n     #[inline]\n-    fn from_inline(inline: A) -> SmallVecData<A> {\n-        SmallVecData {\n-            inline: ManuallyDrop::new(inline),\n-        }\n+    fn from_inline(inline: MaybeUninit<A>) -> SmallVecData<A> {\n+        SmallVecData { inline }\n     }\n     #[inline]\n-    unsafe fn into_inline(self) -> A {\n-        ManuallyDrop::into_inner(self.inline)\n+    unsafe fn into_inline(self) -> MaybeUninit<A> {\n+        self.inline\n     }\n     #[inline]\n     unsafe fn heap(&self) -> (*mut A::Item, usize) {\n@@ -320,34 +318,34 @@ impl<A: Array> SmallVecData<A> {\n \n #[cfg(not(feature = \"union\"))]\n enum SmallVecData<A: Array> {\n-    Inline(ManuallyDrop<A>),\n+    Inline(MaybeUninit<A>),\n     Heap((*mut A::Item, usize)),\n }\n \n #[cfg(not(feature = \"union\"))]\n impl<A: Array> SmallVecData<A> {\n     #[inline]\n-    unsafe fn inline(&self) -> &A {\n+    unsafe fn inline(&self) -> *const A::Item {\n         match *self {\n-            SmallVecData::Inline(ref a) => a,\n+            SmallVecData::Inline(ref a) => a.as_ptr() as *const A::Item,\n             _ => debug_unreachable!(),\n         }\n     }\n     #[inline]\n-    unsafe fn inline_mut(&mut self) -> &mut A {\n+    unsafe fn inline_mut(&mut self) -> *mut A::Item {\n         match *self {\n-            SmallVecData::Inline(ref mut a) => a,\n+            SmallVecData::Inline(ref mut a) => a.as_mut_ptr() as *mut A::Item,\n             _ => debug_unreachable!(),\n         }\n     }\n     #[inline]\n-    fn from_inline(inline: A) -> SmallVecData<A> {\n-        SmallVecData::Inline(ManuallyDrop::new(inline))\n+    fn from_inline(inline: MaybeUninit<A>) -> SmallVecData<A> {\n+        SmallVecData::Inline(inline)\n     }\n     #[inline]\n-    unsafe fn into_inline(self) -> A {\n+    unsafe fn into_inline(self) -> MaybeUninit<A> {\n         match self {\n-            SmallVecData::Inline(a) => ManuallyDrop::into_inner(a),\n+            SmallVecData::Inline(a) => a,\n             _ => debug_unreachable!(),\n         }\n     }\n@@ -412,11 +410,15 @@ impl<A: Array> SmallVec<A> {\n     /// Construct an empty vector\n     #[inline]\n     pub fn new() -> SmallVec<A> {\n-        unsafe {\n-            SmallVec {\n-                capacity: 0,\n-                data: SmallVecData::from_inline(mem::uninitialized()),\n-            }\n+        // Try to detect invalid custom implementations of `Array`. Hopefuly,\n+        // this check should be optimized away entirely for valid ones.\n+        assert!(\n+            mem::size_of::<A>() == A::size() * mem::size_of::<A::Item>()\n+                && mem::align_of::<A>() >= mem::align_of::<A::Item>()\n+        );\n+        SmallVec {\n+            capacity: 0,\n+            data: SmallVecData::from_inline(MaybeUninit::uninit()),\n         }\n     }\n \n@@ -456,10 +458,10 @@ impl<A: Array> SmallVec<A> {\n     pub fn from_vec(mut vec: Vec<A::Item>) -> SmallVec<A> {\n         if vec.capacity() <= A::size() {\n             unsafe {\n-                let mut data = SmallVecData::<A>::from_inline(mem::uninitialized());\n+                let mut data = SmallVecData::<A>::from_inline(MaybeUninit::uninit());\n                 let len = vec.len();\n                 vec.set_len(0);\n-                ptr::copy_nonoverlapping(vec.as_ptr(), data.inline_mut().ptr_mut(), len);\n+                ptr::copy_nonoverlapping(vec.as_ptr(), data.inline_mut(), len);\n \n                 SmallVec {\n                     capacity: len,\n@@ -492,7 +494,7 @@ impl<A: Array> SmallVec<A> {\n     pub fn from_buf(buf: A) -> SmallVec<A> {\n         SmallVec {\n             capacity: A::size(),\n-            data: SmallVecData::from_inline(buf),\n+            data: SmallVecData::from_inline(MaybeUninit::new(buf)),\n         }\n     }\n \n@@ -511,7 +513,7 @@ impl<A: Array> SmallVec<A> {\n     #[inline]\n     pub fn from_buf_and_len(buf: A, len: usize) -> SmallVec<A> {\n         assert!(len <= A::size());\n-        unsafe { SmallVec::from_buf_and_len_unchecked(buf, len) }\n+        unsafe { SmallVec::from_buf_and_len_unchecked(MaybeUninit::new(buf), len) }\n     }\n \n     /// Constructs a new `SmallVec` on the stack from an `A` without\n@@ -520,16 +522,17 @@ impl<A: Array> SmallVec<A> {\n     ///\n     /// ```rust\n     /// use smallvec::SmallVec;\n+    /// use std::mem::MaybeUninit;\n     ///\n     /// let buf = [1, 2, 3, 4, 5, 0, 0, 0];\n     /// let small_vec: SmallVec<_> = unsafe {\n-    ///     SmallVec::from_buf_and_len_unchecked(buf, 5)\n+    ///     SmallVec::from_buf_and_len_unchecked(MaybeUninit::new(buf), 5)\n     /// };\n     ///\n     /// assert_eq!(&*small_vec, &[1, 2, 3, 4, 5]);\n     /// ```\n     #[inline]\n-    pub unsafe fn from_buf_and_len_unchecked(buf: A, len: usize) -> SmallVec<A> {\n+    pub unsafe fn from_buf_and_len_unchecked(buf: MaybeUninit<A>, len: usize) -> SmallVec<A> {\n         SmallVec {\n             capacity: len,\n             data: SmallVecData::from_inline(buf),\n@@ -579,7 +582,7 @@ impl<A: Array> SmallVec<A> {\n                 let (ptr, len) = self.data.heap();\n                 (ptr, len, self.capacity)\n             } else {\n-                (self.data.inline().ptr(), self.capacity, A::size())\n+                (self.data.inline(), self.capacity, A::size())\n             }\n         }\n     }\n@@ -592,11 +595,7 @@ impl<A: Array> SmallVec<A> {\n                 let &mut (ptr, ref mut len_ptr) = self.data.heap_mut();\n                 (ptr, len_ptr, self.capacity)\n             } else {\n-                (\n-                    self.data.inline_mut().ptr_mut(),\n-                    &mut self.capacity,\n-                    A::size(),\n-                )\n+                (self.data.inline_mut(), &mut self.capacity, A::size())\n             }\n         }\n     }\n@@ -663,8 +662,8 @@ impl<A: Array> SmallVec<A> {\n                 if unspilled {\n                     return;\n                 }\n-                self.data = SmallVecData::from_inline(mem::uninitialized());\n-                ptr::copy_nonoverlapping(ptr, self.data.inline_mut().ptr_mut(), len);\n+                self.data = SmallVecData::from_inline(MaybeUninit::uninit());\n+                ptr::copy_nonoverlapping(ptr, self.data.inline_mut(), len);\n                 self.capacity = len;\n             } else if new_cap != cap {\n                 let mut vec = Vec::with_capacity(new_cap);\n@@ -730,8 +729,8 @@ impl<A: Array> SmallVec<A> {\n         if self.inline_size() >= len {\n             unsafe {\n                 let (ptr, len) = self.data.heap();\n-                self.data = SmallVecData::from_inline(mem::uninitialized());\n-                ptr::copy_nonoverlapping(ptr, self.data.inline_mut().ptr_mut(), len);\n+                self.data = SmallVecData::from_inline(MaybeUninit::uninit());\n+                ptr::copy_nonoverlapping(ptr, self.data.inline_mut(), len);\n                 deallocate(ptr, self.capacity);\n                 self.capacity = len;\n             }\n@@ -900,7 +899,7 @@ impl<A: Array> SmallVec<A> {\n             unsafe {\n                 let data = ptr::read(&self.data);\n                 mem::forget(self);\n-                Ok(data.into_inline())\n+                Ok(data.into_inline().assume_init())\n             }\n         }\n     }\n@@ -1062,8 +1061,12 @@ where\n             SmallVec {\n                 capacity: len,\n                 data: SmallVecData::from_inline(unsafe {\n-                    let mut data: A = mem::uninitialized();\n-                    ptr::copy_nonoverlapping(slice.as_ptr(), data.ptr_mut(), len);\n+                    let mut data: MaybeUninit<A> = MaybeUninit::uninit();\n+                    ptr::copy_nonoverlapping(\n+                        slice.as_ptr(),\n+                        data.as_mut_ptr() as *mut A::Item,\n+                        len,\n+                    );\n                     data\n                 }),\n             }\n@@ -1603,10 +1606,6 @@ pub unsafe trait Array {\n     type Item;\n     /// Returns the number of items the array can hold.\n     fn size() -> usize;\n-    /// Returns a pointer to the first element of the array.\n-    fn ptr(&self) -> *const Self::Item;\n-    /// Returns a mutable pointer to the first element of the array.\n-    fn ptr_mut(&mut self) -> *mut Self::Item;\n }\n \n /// Set the length of the vec when the `SetLenOnDrop` value goes out of scope.\n@@ -1650,8 +1649,6 @@ macro_rules! impl_array(\n             unsafe impl<T> Array for [T; $size] {\n                 type Item = T;\n                 fn size() -> usize { $size }\n-                fn ptr(&self) -> *const T { self.as_ptr() }\n-                fn ptr_mut(&mut self) -> *mut T { self.as_mut_ptr() }\n             }\n         )+\n     }\n@@ -1985,7 +1982,7 @@ mod tests {\n         );\n     }\n \n-    #[cfg(feature = \"std\")]\n+    #[cfg(all(feature = \"std\", not(miri)))] // Miri currently does not support unwinding\n     #[test]\n     // https://github.com/servo/rust-smallvec/issues/96\n     fn test_insert_many_panic() {\n",
    "diff_parsed": "{'added': [(66, 'use std::mem::MaybeUninit;'), (283, '    inline: MaybeUninit<A>,'), (290, '    unsafe fn inline(&self) -> *const A::Item {'), (291, '        self.inline.as_ptr() as *const A::Item'), (294, '    unsafe fn inline_mut(&mut self) -> *mut A::Item {'), (295, '        self.inline.as_mut_ptr() as *mut A::Item'), (298, '    fn from_inline(inline: MaybeUninit<A>) -> SmallVecData<A> {'), (299, '        SmallVecData { inline }'), (302, '    unsafe fn into_inline(self) -> MaybeUninit<A> {'), (303, '        self.inline'), (321, '    Inline(MaybeUninit<A>),'), (328, '    unsafe fn inline(&self) -> *const A::Item {'), (330, '            SmallVecData::Inline(ref a) => a.as_ptr() as *const A::Item,'), (335, '    unsafe fn inline_mut(&mut self) -> *mut A::Item {'), (337, '            SmallVecData::Inline(ref mut a) => a.as_mut_ptr() as *mut A::Item,'), (342, '    fn from_inline(inline: MaybeUninit<A>) -> SmallVecData<A> {'), (343, '        SmallVecData::Inline(inline)'), (346, '    unsafe fn into_inline(self) -> MaybeUninit<A> {'), (348, '            SmallVecData::Inline(a) => a,'), (415, '        assert!('), (416, '            mem::size_of::<A>() == A::size() * mem::size_of::<A::Item>()'), (417, '                && mem::align_of::<A>() >= mem::align_of::<A::Item>()'), (418, '        );'), (419, '        SmallVec {'), (420, '            capacity: 0,'), (421, '            data: SmallVecData::from_inline(MaybeUninit::uninit()),'), (461, '                let mut data = SmallVecData::<A>::from_inline(MaybeUninit::uninit());'), (464, '                ptr::copy_nonoverlapping(vec.as_ptr(), data.inline_mut(), len);'), (497, '            data: SmallVecData::from_inline(MaybeUninit::new(buf)),'), (516, '        unsafe { SmallVec::from_buf_and_len_unchecked(MaybeUninit::new(buf), len) }'), (535, '    pub unsafe fn from_buf_and_len_unchecked(buf: MaybeUninit<A>, len: usize) -> SmallVec<A> {'), (585, '                (self.data.inline(), self.capacity, A::size())'), (598, '                (self.data.inline_mut(), &mut self.capacity, A::size())'), (665, '                self.data = SmallVecData::from_inline(MaybeUninit::uninit());'), (666, '                ptr::copy_nonoverlapping(ptr, self.data.inline_mut(), len);'), (732, '                self.data = SmallVecData::from_inline(MaybeUninit::uninit());'), (733, '                ptr::copy_nonoverlapping(ptr, self.data.inline_mut(), len);'), (902, '                Ok(data.into_inline().assume_init())'), (1064, '                    let mut data: MaybeUninit<A> = MaybeUninit::uninit();'), (1065, '                    ptr::copy_nonoverlapping('), (1066, '                        slice.as_ptr(),'), (1067, '                        data.as_mut_ptr() as *mut A::Item,'), (1068, '                        len,'), (1069, '                    );'), (1985, '    #[cfg(all(feature = \"std\", not(miri)))] // Miri currently does not support unwinding')], 'deleted': [(66, 'use std::mem::ManuallyDrop;'), (283, '    inline: ManuallyDrop<A>,'), (290, '    unsafe fn inline(&self) -> &A {'), (291, '        &self.inline'), (294, '    unsafe fn inline_mut(&mut self) -> &mut A {'), (295, '        &mut self.inline'), (298, '    fn from_inline(inline: A) -> SmallVecData<A> {'), (299, '        SmallVecData {'), (300, '            inline: ManuallyDrop::new(inline),'), (301, '        }'), (304, '    unsafe fn into_inline(self) -> A {'), (305, '        ManuallyDrop::into_inner(self.inline)'), (323, '    Inline(ManuallyDrop<A>),'), (330, '    unsafe fn inline(&self) -> &A {'), (332, '            SmallVecData::Inline(ref a) => a,'), (337, '    unsafe fn inline_mut(&mut self) -> &mut A {'), (339, '            SmallVecData::Inline(ref mut a) => a,'), (344, '    fn from_inline(inline: A) -> SmallVecData<A> {'), (345, '        SmallVecData::Inline(ManuallyDrop::new(inline))'), (348, '    unsafe fn into_inline(self) -> A {'), (350, '            SmallVecData::Inline(a) => ManuallyDrop::into_inner(a),'), (415, '        unsafe {'), (416, '            SmallVec {'), (417, '                capacity: 0,'), (418, '                data: SmallVecData::from_inline(mem::uninitialized()),'), (419, '            }'), (459, '                let mut data = SmallVecData::<A>::from_inline(mem::uninitialized());'), (462, '                ptr::copy_nonoverlapping(vec.as_ptr(), data.inline_mut().ptr_mut(), len);'), (495, '            data: SmallVecData::from_inline(buf),'), (514, '        unsafe { SmallVec::from_buf_and_len_unchecked(buf, len) }'), (532, '    pub unsafe fn from_buf_and_len_unchecked(buf: A, len: usize) -> SmallVec<A> {'), (582, '                (self.data.inline().ptr(), self.capacity, A::size())'), (595, '                ('), (596, '                    self.data.inline_mut().ptr_mut(),'), (597, '                    &mut self.capacity,'), (598, '                    A::size(),'), (599, '                )'), (666, '                self.data = SmallVecData::from_inline(mem::uninitialized());'), (667, '                ptr::copy_nonoverlapping(ptr, self.data.inline_mut().ptr_mut(), len);'), (733, '                self.data = SmallVecData::from_inline(mem::uninitialized());'), (734, '                ptr::copy_nonoverlapping(ptr, self.data.inline_mut().ptr_mut(), len);'), (903, '                Ok(data.into_inline())'), (1065, '                    let mut data: A = mem::uninitialized();'), (1066, '                    ptr::copy_nonoverlapping(slice.as_ptr(), data.ptr_mut(), len);'), (1607, '    fn ptr(&self) -> *const Self::Item;'), (1609, '    fn ptr_mut(&mut self) -> *mut Self::Item;'), (1653, '                fn ptr(&self) -> *const T { self.as_ptr() }'), (1654, '                fn ptr_mut(&mut self) -> *mut T { self.as_mut_ptr() }'), (1988, '    #[cfg(feature = \"std\")]')]}",
    "num_lines_added": "45",
    "num_lines_deleted": "49",
    "nloc": "1961"
  },
  {
    "file_change_id": "141228828803994",
    "hash": "390a7b1049fa5ba1d627feaef2a1629e0e7826b",
    "old_path": "rand_core/src/le.rs",
    "new_path": "rand_core/src/le.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -16,7 +16,7 @@ use core::convert::TryInto;\n /// Reads unsigned 32 bit integers from `src` into `dst`.\n #[inline]\n pub fn read_u32_into(src: &[u8], dst: &mut [u32]) {\n-    assert!(4 * src.len() >= dst.len());\n+    assert!(src.len() >= 4 * dst.len());\n     for (out, chunk) in dst.iter_mut().zip(src.chunks_exact(4)) {\n         *out = u32::from_le_bytes(chunk.try_into().unwrap());\n     }\n@@ -25,7 +25,7 @@ pub fn read_u32_into(src: &[u8], dst: &mut [u32]) {\n /// Reads unsigned 64 bit integers from `src` into `dst`.\n #[inline]\n pub fn read_u64_into(src: &[u8], dst: &mut [u64]) {\n-    assert!(8 * src.len() >= dst.len());\n+    assert!(src.len() >= 8 * dst.len());\n     for (out, chunk) in dst.iter_mut().zip(src.chunks_exact(8)) {\n         *out = u64::from_le_bytes(chunk.try_into().unwrap());\n     }\n",
    "diff_parsed": "{'added': [(19, '    assert!(src.len() >= 4 * dst.len());'), (28, '    assert!(src.len() >= 8 * dst.len());')], 'deleted': [(19, '    assert!(4 * src.len() >= dst.len());'), (28, '    assert!(8 * src.len() >= dst.len());')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "34"
  },
  {
    "file_change_id": "58001547178672",
    "hash": "a6d7cdd2221ae5087fa354a100733b2cc4fd008",
    "old_path": "src/snip.rs",
    "new_path": "src/snip.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -13,7 +13,7 @@ pub(crate) fn preamble_skipcount<R: Read>(reader: &mut R, n_preamble_rows: usize\n     let mut skipcount = 0;\n     loop {\n         let cap = 1 << 12;\n-        let mut buffer = Vec::with_capacity(cap);\n+        let mut buffer = vec![0; cap];\n         unsafe { buffer.set_len(cap); }\n         let n_read = reader.read(&mut buffer)?;\n         let mut crlf_pos = 0;\n",
    "diff_parsed": "{'added': [(16, '        let mut buffer = vec![0; cap];')], 'deleted': [(16, '        let mut buffer = Vec::with_capacity(cap);')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "42"
  },
  {
    "file_change_id": "148898044987512",
    "hash": "4b8426b89b861d9bea20e126576b0febb9d1351",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1781,7 +1781,8 @@ impl<'a> Builder<'a> {\n                 removed.push(node);\n                 continue;\n             }\n-            let pass = self.clean_child(&mut node, url_base);\n+            let pass_clean = self.clean_child(&mut node, url_base);\n+            let pass = pass_clean && self.check_expected_namespace(&parent, &node);\n             if pass {\n                 self.adjust_node_attributes(&mut node, &link_rel, url_base, self.id_prefix);\n                 dom.append(&parent.clone(), NodeOrText::AppendNode(node.clone()));\n@@ -1892,6 +1893,125 @@ impl<'a> Builder<'a> {\n         }\n     }\n \n+    // Check for unexpected namespace changes.\n+    //\n+    // The issue happens if developers added to the list of allowed tags any\n+    // tag which is parsed in RCDATA state, PLAINTEXT state or RCDATA state,\n+    // that is:\n+    //\n+    // * title\n+    // * textarea\n+    // * style\n+    // * xmp\n+    // * iframe\n+    // * noembed\n+    // * noframes\n+    // * plaintext\n+    //\n+    // An example in the wild is Plume, that allows iframe [1].  So in next\n+    // examples I'll assume the following policy:\n+    //\n+    //     Builder::new()\n+    //        .add_tags(&[\"iframe\"])\n+    //\n+    // In HTML namespace `<iframe>` is parsed specially; that is, its content is\n+    // treated as text. For instance, the following html:\n+    //\n+    //     <iframe><a>test\n+    //\n+    // Is parsed into the following DOM tree:\n+    //\n+    //     iframe\n+    //     \u2514\u2500 #text: <a>test\n+    //\n+    // So iframe cannot have any children other than a text node.\n+    //\n+    // The same is not true, though, in \"foreign content\"; that is, within\n+    // <svg> or <math> tags. The following html:\n+    //\n+    //     <svg><iframe><a>test\n+    //\n+    // is parsed differently:\n+    //\n+    //    svg\n+    //    \u2514\u2500 iframe\n+    //       \u2514\u2500 a\n+    //          \u2514\u2500 #text: test\n+    //\n+    // So in SVG namespace iframe can have children.\n+    //\n+    // Ammonia disallows <svg> but it keeps its content after deleting it. And\n+    // the parser internally keeps track of the namespace of the element. So\n+    // assume we have the following snippet:\n+    //\n+    //     <svg><iframe><a title=\"</iframe><img src onerror=alert(1)>\">test\n+    //\n+    // It is parsed into:\n+    //\n+    //     svg\n+    //     \u2514\u2500 iframe\n+    //        \u2514\u2500 a title=\"</iframe><img src onerror=alert(1)>\"\n+    //           \u2514\u2500 #text: test\n+    //\n+    // This DOM tree is harmless from ammonia point of view because the piece\n+    // of code that looks like XSS is in a title attribute. Hence, the\n+    // resulting \"safe\" HTML from ammonia would be:\n+    //\n+    //     <iframe><a title=\"</iframe><img src onerror=alert(1)>\" rel=\"noopener\n+    // noreferrer\">test</a></iframe>\n+    //\n+    // However, at this point, the information about namespace is lost, which\n+    // means that the browser will parse this snippet into:\n+    //\n+    //     \u251c\u2500 iframe\n+    //     \u2502  \u2514\u2500 #text: <a title=\"\n+    //     \u251c\u2500 img src=\"\" onerror=\"alert(1)\"\n+    //     \u2514\u2500 #text: \" rel=\"noopener noreferrer\">test\n+    //\n+    // Leading to XSS.\n+    //\n+    // To solve this issue, check for unexpected namespace switches after cleanup.\n+    // Elements which change namespace at an unexpected point are removed.\n+    // This function returns `true` if `child` should be kept, and `false` if it\n+    // should be removed.\n+    fn check_expected_namespace(&self, parent: &Handle, child: &Handle) -> bool {\n+        let (parent, child) = match (&parent.data, &child.data) {\n+            (NodeData::Element { name: pn, .. }, NodeData::Element { name: cn, .. }) => (pn, cn),\n+            _ => return true,\n+        };\n+        // The only way to switch from html to svg is with the <svg> tag\n+        if parent.ns == ns!(html) && child.ns == ns!(svg) {\n+            child.local == local_name!(\"svg\")\n+        // The only way to switch from html to mathml is with the <math> tag\n+        } else if parent.ns == ns!(html) && child.ns == ns!(mathml) {\n+            child.local == local_name!(\"math\")\n+        // The only way to switch from mathml to svg/html is with a text integration point\n+        } else if parent.ns == ns!(mathml) && child.ns != ns!(mathml) {\n+            // https://html.spec.whatwg.org/#mathml\n+            matches!(\n+                &*parent.local,\n+                \"mi\" | \"mo\" | \"mn\" | \"ms\" | \"mtext\" | \"annotation-xml\"\n+            )\n+        // The only way to switch from svg to mathml/html is with an html integration point\n+        } else if parent.ns == ns!(svg) && child.ns != ns!(svg) {\n+            // https://html.spec.whatwg.org/#svg-0\n+            matches!(&*parent.local, \"foreignObject\")\n+        } else if child.ns == ns!(svg) {\n+            is_svg_tag(&*child.local)\n+        } else if child.ns == ns!(mathml) {\n+            is_mathml_tag(&*child.local)\n+        } else if child.ns == ns!(html) {\n+            (!is_svg_tag(&*child.local) && !is_mathml_tag(&*child.local))\n+                || matches!(\n+                    &*child.local,\n+                    \"title\" | \"style\" | \"font\" | \"a\" | \"script\" | \"span\"\n+                )\n+        } else {\n+            // There are no other supported ways to switch namespace\n+            parent.ns == child.ns\n+        }\n+    }\n+\n     /// Add and transform special-cased attributes and elements.\n     ///\n     /// This function handles:\n@@ -2050,6 +2170,280 @@ fn is_url_attr(element: &str, attr: &str) -> bool {\n         || (element == \"video\" && attr == \"poster\")\n }\n \n+/// Given an element name, check if it's SVG\n+fn is_svg_tag(element: &str) -> bool {\n+    // https://svgwg.org/svg2-draft/eltindex.html\n+    match element {\n+        \"a\"\n+        | \"animate\"\n+        | \"animateMotion\"\n+        | \"animateTransform\"\n+        | \"circle\"\n+        | \"clipPath\"\n+        | \"defs\"\n+        | \"desc\"\n+        | \"discard\"\n+        | \"ellipse\"\n+        | \"feBlend\"\n+        | \"feColorMatrix\"\n+        | \"feComponentTransfer\"\n+        | \"feComposite\"\n+        | \"feConvolveMatrix\"\n+        | \"feDiffuseLighting\"\n+        | \"feDisplacementMap\"\n+        | \"feDistantLight\"\n+        | \"feDropShadow\"\n+        | \"feFlood\"\n+        | \"feFuncA\"\n+        | \"feFuncB\"\n+        | \"feFuncG\"\n+        | \"feFuncR\"\n+        | \"feGaussianBlur\"\n+        | \"feImage\"\n+        | \"feMerge\"\n+        | \"feMergeNode\"\n+        | \"feMorphology\"\n+        | \"feOffset\"\n+        | \"fePointLight\"\n+        | \"feSpecularLighting\"\n+        | \"feSpotLight\"\n+        | \"feTile\"\n+        | \"feTurbulence\"\n+        | \"filter\"\n+        | \"foreignObject\"\n+        | \"g\"\n+        | \"image\"\n+        | \"line\"\n+        | \"linearGradient\"\n+        | \"marker\"\n+        | \"mask\"\n+        | \"metadata\"\n+        | \"mpath\"\n+        | \"path\"\n+        | \"pattern\"\n+        | \"polygon\"\n+        | \"polyline\"\n+        | \"radialGradient\"\n+        | \"rect\"\n+        | \"script\"\n+        | \"set\"\n+        | \"stop\"\n+        | \"style\"\n+        | \"svg\"\n+        | \"switch\"\n+        | \"symbol\"\n+        | \"text\"\n+        | \"textPath\"\n+        | \"title\"\n+        | \"tspan\"\n+        | \"use\"\n+        | \"view\" => true,\n+        _ => false,\n+    }\n+}\n+\n+/// Given an element name, check if it's Math\n+fn is_mathml_tag(element: &str) -> bool {\n+    // https://svgwg.org/svg2-draft/eltindex.html\n+    match element {\n+        \"abs\"\n+        | \"and\"\n+        | \"annotation\"\n+        | \"annotation-xml\"\n+        | \"apply\"\n+        | \"approx\"\n+        | \"arccos\"\n+        | \"arccosh\"\n+        | \"arccot\"\n+        | \"arccoth\"\n+        | \"arccsc\"\n+        | \"arccsch\"\n+        | \"arcsec\"\n+        | \"arcsech\"\n+        | \"arcsin\"\n+        | \"arcsinh\"\n+        | \"arctan\"\n+        | \"arctanh\"\n+        | \"arg\"\n+        | \"bind\"\n+        | \"bvar\"\n+        | \"card\"\n+        | \"cartesianproduct\"\n+        | \"cbytes\"\n+        | \"ceiling\"\n+        | \"cerror\"\n+        | \"ci\"\n+        | \"cn\"\n+        | \"codomain\"\n+        | \"complexes\"\n+        | \"compose\"\n+        | \"condition\"\n+        | \"conjugate\"\n+        | \"cos\"\n+        | \"cosh\"\n+        | \"cot\"\n+        | \"coth\"\n+        | \"cs\"\n+        | \"csc\"\n+        | \"csch\"\n+        | \"csymbol\"\n+        | \"curl\"\n+        | \"declare\"\n+        | \"degree\"\n+        | \"determinant\"\n+        | \"diff\"\n+        | \"divergence\"\n+        | \"divide\"\n+        | \"domain\"\n+        | \"domainofapplication\"\n+        | \"emptyset\"\n+        | \"eq\"\n+        | \"equivalent\"\n+        | \"eulergamma\"\n+        | \"exists\"\n+        | \"exp\"\n+        | \"exponentiale\"\n+        | \"factorial\"\n+        | \"factorof\"\n+        | \"false\"\n+        | \"floor\"\n+        | \"fn\"\n+        | \"forall\"\n+        | \"gcd\"\n+        | \"geq\"\n+        | \"grad\"\n+        | \"gt\"\n+        | \"ident\"\n+        | \"image\"\n+        | \"imaginary\"\n+        | \"imaginaryi\"\n+        | \"implies\"\n+        | \"in\"\n+        | \"infinity\"\n+        | \"int\"\n+        | \"integers\"\n+        | \"intersect\"\n+        | \"interval\"\n+        | \"inverse\"\n+        | \"lambda\"\n+        | \"laplacian\"\n+        | \"lcm\"\n+        | \"leq\"\n+        | \"limit\"\n+        | \"list\"\n+        | \"ln\"\n+        | \"log\"\n+        | \"logbase\"\n+        | \"lowlimit\"\n+        | \"lt\"\n+        | \"maction\"\n+        | \"maligngroup\"\n+        | \"malignmark\"\n+        | \"math\"\n+        | \"matrix\"\n+        | \"matrixrow\"\n+        | \"max\"\n+        | \"mean\"\n+        | \"median\"\n+        | \"menclose\"\n+        | \"merror\"\n+        | \"mfenced\"\n+        | \"mfrac\"\n+        | \"mglyph\"\n+        | \"mi\"\n+        | \"min\"\n+        | \"minus\"\n+        | \"mlabeledtr\"\n+        | \"mlongdiv\"\n+        | \"mmultiscripts\"\n+        | \"mn\"\n+        | \"mo\"\n+        | \"mode\"\n+        | \"moment\"\n+        | \"momentabout\"\n+        | \"mover\"\n+        | \"mpadded\"\n+        | \"mphantom\"\n+        | \"mprescripts\"\n+        | \"mroot\"\n+        | \"mrow\"\n+        | \"ms\"\n+        | \"mscarries\"\n+        | \"mscarry\"\n+        | \"msgroup\"\n+        | \"msline\"\n+        | \"mspace\"\n+        | \"msqrt\"\n+        | \"msrow\"\n+        | \"mstack\"\n+        | \"mstyle\"\n+        | \"msub\"\n+        | \"msubsup\"\n+        | \"msup\"\n+        | \"mtable\"\n+        | \"mtd\"\n+        | \"mtext\"\n+        | \"mtr\"\n+        | \"munder\"\n+        | \"munderover\"\n+        | \"naturalnumbers\"\n+        | \"neq\"\n+        | \"none\"\n+        | \"not\"\n+        | \"notanumber\"\n+        | \"notin\"\n+        | \"notprsubset\"\n+        | \"notsubset\"\n+        | \"or\"\n+        | \"otherwise\"\n+        | \"outerproduct\"\n+        | \"partialdiff\"\n+        | \"pi\"\n+        | \"piece\"\n+        | \"piecewise\"\n+        | \"plus\"\n+        | \"power\"\n+        | \"primes\"\n+        | \"product\"\n+        | \"prsubset\"\n+        | \"quotient\"\n+        | \"rationals\"\n+        | \"real\"\n+        | \"reals\"\n+        | \"reln\"\n+        | \"rem\"\n+        | \"root\"\n+        | \"scalarproduct\"\n+        | \"sdev\"\n+        | \"sec\"\n+        | \"sech\"\n+        | \"selector\"\n+        | \"semantics\"\n+        | \"sep\"\n+        | \"set\"\n+        | \"setdiff\"\n+        | \"share\"\n+        | \"sin\"\n+        | \"sinh\"\n+        | \"span\"\n+        | \"subset\"\n+        | \"sum\"\n+        | \"tan\"\n+        | \"tanh\"\n+        | \"tendsto\"\n+        | \"times\"\n+        | \"transpose\"\n+        | \"true\"\n+        | \"union\"\n+        | \"uplimit\"\n+        | \"variance\"\n+        | \"vector\"\n+        | \"vectorproduct\"\n+        | \"xor\" => true,\n+        _ => false,\n+    }\n+}\n+\n fn is_url_relative(url: &str) -> bool {\n     matches!(\n         Url::parse(url),\n@@ -2479,7 +2873,8 @@ mod test {\n                         (\"rel\", \"noopener noreferrer\") => true,\n                         _ => false,\n                     },\n-                    \"{}\", value.to_string()\n+                    \"{}\",\n+                    value.to_string()\n                 );\n                 Some(value.into())\n             })\n@@ -3037,6 +3432,64 @@ mod test {\n         );\n     }\n \n+    #[test]\n+    fn ns_svg() {\n+        // https://github.com/cure53/DOMPurify/pull/495\n+        let fragment = r##\"<svg><iframe><a title=\"</iframe><img src onerror=alert(1)>\">test\"##;\n+        let result = String::from(Builder::new().add_tags(&[\"iframe\"]).clean(fragment));\n+        assert_eq!(\n+            result.to_string(),\n+            \"test\"\n+        );\n+\n+        let fragment = \"<svg><iframe>remove me</iframe></svg><iframe>keep me</iframe>\";\n+        let result = String::from(Builder::new().add_tags(&[\"iframe\"]).clean(fragment));\n+        assert_eq!(result.to_string(), \"remove me<iframe>keep me</iframe>\");\n+\n+        let fragment = \"<svg><a>remove me</a></svg><iframe>keep me</iframe>\";\n+        let result = String::from(Builder::new().add_tags(&[\"iframe\"]).clean(fragment));\n+        assert_eq!(result.to_string(), \"remove me<iframe>keep me</iframe>\");\n+\n+        let fragment = \"<svg><a>keep me</a></svg><iframe>keep me</iframe>\";\n+        let result = String::from(Builder::new().add_tags(&[\"iframe\", \"svg\"]).clean(fragment));\n+        assert_eq!(\n+            result.to_string(),\n+            \"<svg><a rel=\\\"noopener noreferrer\\\">keep me</a></svg><iframe>keep me</iframe>\"\n+        );\n+    }\n+\n+    #[test]\n+    fn ns_mathml() {\n+        // https://github.com/cure53/DOMPurify/pull/495\n+        let fragment = \"<mglyph></mglyph>\";\n+        let result = String::from(\n+            Builder::new()\n+                .add_tags(&[\"math\", \"mtext\", \"mglyph\"])\n+                .clean(fragment),\n+        );\n+        assert_eq!(result.to_string(), \"\");\n+        let fragment = \"<math><mtext><div><mglyph>\";\n+        let result = String::from(\n+            Builder::new()\n+                .add_tags(&[\"math\", \"mtext\", \"mglyph\"])\n+                .clean(fragment),\n+        );\n+        assert_eq!(\n+            result.to_string(),\n+            \"<math><mtext><div></div></mtext></math>\"\n+        );\n+        let fragment = \"<math><mtext><mglyph>\";\n+        let result = String::from(\n+            Builder::new()\n+                .add_tags(&[\"math\", \"mtext\", \"mglyph\"])\n+                .clean(fragment),\n+        );\n+        assert_eq!(\n+            result.to_string(),\n+            \"<math><mtext><mglyph></mglyph></mtext></math>\"\n+        );\n+    }\n+\n     #[test]\n     fn generic_attribute_prefixes() {\n         let prefix_data = [\"data-\"];\n",
    "diff_parsed": "{'added': [(1784, '            let pass_clean = self.clean_child(&mut node, url_base);'), (1785, '            let pass = pass_clean && self.check_expected_namespace(&parent, &node);'), (1977, '    fn check_expected_namespace(&self, parent: &Handle, child: &Handle) -> bool {'), (1978, '        let (parent, child) = match (&parent.data, &child.data) {'), (1979, '            (NodeData::Element { name: pn, .. }, NodeData::Element { name: cn, .. }) => (pn, cn),'), (1980, '            _ => return true,'), (1981, '        };'), (1983, '        if parent.ns == ns!(html) && child.ns == ns!(svg) {'), (1984, '            child.local == local_name!(\"svg\")'), (1986, '        } else if parent.ns == ns!(html) && child.ns == ns!(mathml) {'), (1987, '            child.local == local_name!(\"math\")'), (1989, '        } else if parent.ns == ns!(mathml) && child.ns != ns!(mathml) {'), (1991, '            matches!('), (1992, '                &*parent.local,'), (1993, '                \"mi\" | \"mo\" | \"mn\" | \"ms\" | \"mtext\" | \"annotation-xml\"'), (1994, '            )'), (1996, '        } else if parent.ns == ns!(svg) && child.ns != ns!(svg) {'), (1998, '            matches!(&*parent.local, \"foreignObject\")'), (1999, '        } else if child.ns == ns!(svg) {'), (2000, '            is_svg_tag(&*child.local)'), (2001, '        } else if child.ns == ns!(mathml) {'), (2002, '            is_mathml_tag(&*child.local)'), (2003, '        } else if child.ns == ns!(html) {'), (2004, '            (!is_svg_tag(&*child.local) && !is_mathml_tag(&*child.local))'), (2005, '                || matches!('), (2006, '                    &*child.local,'), (2007, '                    \"title\" | \"style\" | \"font\" | \"a\" | \"script\" | \"span\"'), (2008, '                )'), (2009, '        } else {'), (2011, '            parent.ns == child.ns'), (2012, '        }'), (2013, '    }'), (2174, 'fn is_svg_tag(element: &str) -> bool {'), (2176, '    match element {'), (2177, '        \"a\"'), (2178, '        | \"animate\"'), (2179, '        | \"animateMotion\"'), (2180, '        | \"animateTransform\"'), (2181, '        | \"circle\"'), (2182, '        | \"clipPath\"'), (2183, '        | \"defs\"'), (2184, '        | \"desc\"'), (2185, '        | \"discard\"'), (2186, '        | \"ellipse\"'), (2187, '        | \"feBlend\"'), (2188, '        | \"feColorMatrix\"'), (2189, '        | \"feComponentTransfer\"'), (2190, '        | \"feComposite\"'), (2191, '        | \"feConvolveMatrix\"'), (2192, '        | \"feDiffuseLighting\"'), (2193, '        | \"feDisplacementMap\"'), (2194, '        | \"feDistantLight\"'), (2195, '        | \"feDropShadow\"'), (2196, '        | \"feFlood\"'), (2197, '        | \"feFuncA\"'), (2198, '        | \"feFuncB\"'), (2199, '        | \"feFuncG\"'), (2200, '        | \"feFuncR\"'), (2201, '        | \"feGaussianBlur\"'), (2202, '        | \"feImage\"'), (2203, '        | \"feMerge\"'), (2204, '        | \"feMergeNode\"'), (2205, '        | \"feMorphology\"'), (2206, '        | \"feOffset\"'), (2207, '        | \"fePointLight\"'), (2208, '        | \"feSpecularLighting\"'), (2209, '        | \"feSpotLight\"'), (2210, '        | \"feTile\"'), (2211, '        | \"feTurbulence\"'), (2212, '        | \"filter\"'), (2213, '        | \"foreignObject\"'), (2214, '        | \"g\"'), (2215, '        | \"image\"'), (2216, '        | \"line\"'), (2217, '        | \"linearGradient\"'), (2218, '        | \"marker\"'), (2219, '        | \"mask\"'), (2220, '        | \"metadata\"'), (2221, '        | \"mpath\"'), (2222, '        | \"path\"'), (2223, '        | \"pattern\"'), (2224, '        | \"polygon\"'), (2225, '        | \"polyline\"'), (2226, '        | \"radialGradient\"'), (2227, '        | \"rect\"'), (2228, '        | \"script\"'), (2229, '        | \"set\"'), (2230, '        | \"stop\"'), (2231, '        | \"style\"'), (2232, '        | \"svg\"'), (2233, '        | \"switch\"'), (2234, '        | \"symbol\"'), (2235, '        | \"text\"'), (2236, '        | \"textPath\"'), (2237, '        | \"title\"'), (2238, '        | \"tspan\"'), (2239, '        | \"use\"'), (2240, '        | \"view\" => true,'), (2241, '        _ => false,'), (2242, '    }'), (2243, '}'), (2246, 'fn is_mathml_tag(element: &str) -> bool {'), (2248, '    match element {'), (2249, '        \"abs\"'), (2250, '        | \"and\"'), (2251, '        | \"annotation\"'), (2252, '        | \"annotation-xml\"'), (2253, '        | \"apply\"'), (2254, '        | \"approx\"'), (2255, '        | \"arccos\"'), (2256, '        | \"arccosh\"'), (2257, '        | \"arccot\"'), (2258, '        | \"arccoth\"'), (2259, '        | \"arccsc\"'), (2260, '        | \"arccsch\"'), (2261, '        | \"arcsec\"'), (2262, '        | \"arcsech\"'), (2263, '        | \"arcsin\"'), (2264, '        | \"arcsinh\"'), (2265, '        | \"arctan\"'), (2266, '        | \"arctanh\"'), (2267, '        | \"arg\"'), (2268, '        | \"bind\"'), (2269, '        | \"bvar\"'), (2270, '        | \"card\"'), (2271, '        | \"cartesianproduct\"'), (2272, '        | \"cbytes\"'), (2273, '        | \"ceiling\"'), (2274, '        | \"cerror\"'), (2275, '        | \"ci\"'), (2276, '        | \"cn\"'), (2277, '        | \"codomain\"'), (2278, '        | \"complexes\"'), (2279, '        | \"compose\"'), (2280, '        | \"condition\"'), (2281, '        | \"conjugate\"'), (2282, '        | \"cos\"'), (2283, '        | \"cosh\"'), (2284, '        | \"cot\"'), (2285, '        | \"coth\"'), (2286, '        | \"cs\"'), (2287, '        | \"csc\"'), (2288, '        | \"csch\"'), (2289, '        | \"csymbol\"'), (2290, '        | \"curl\"'), (2291, '        | \"declare\"'), (2292, '        | \"degree\"'), (2293, '        | \"determinant\"'), (2294, '        | \"diff\"'), (2295, '        | \"divergence\"'), (2296, '        | \"divide\"'), (2297, '        | \"domain\"'), (2298, '        | \"domainofapplication\"'), (2299, '        | \"emptyset\"'), (2300, '        | \"eq\"'), (2301, '        | \"equivalent\"'), (2302, '        | \"eulergamma\"'), (2303, '        | \"exists\"'), (2304, '        | \"exp\"'), (2305, '        | \"exponentiale\"'), (2306, '        | \"factorial\"'), (2307, '        | \"factorof\"'), (2308, '        | \"false\"'), (2309, '        | \"floor\"'), (2310, '        | \"fn\"'), (2311, '        | \"forall\"'), (2312, '        | \"gcd\"'), (2313, '        | \"geq\"'), (2314, '        | \"grad\"'), (2315, '        | \"gt\"'), (2316, '        | \"ident\"'), (2317, '        | \"image\"'), (2318, '        | \"imaginary\"'), (2319, '        | \"imaginaryi\"'), (2320, '        | \"implies\"'), (2321, '        | \"in\"'), (2322, '        | \"infinity\"'), (2323, '        | \"int\"'), (2324, '        | \"integers\"'), (2325, '        | \"intersect\"'), (2326, '        | \"interval\"'), (2327, '        | \"inverse\"'), (2328, '        | \"lambda\"'), (2329, '        | \"laplacian\"'), (2330, '        | \"lcm\"'), (2331, '        | \"leq\"'), (2332, '        | \"limit\"'), (2333, '        | \"list\"'), (2334, '        | \"ln\"'), (2335, '        | \"log\"'), (2336, '        | \"logbase\"'), (2337, '        | \"lowlimit\"'), (2338, '        | \"lt\"'), (2339, '        | \"maction\"'), (2340, '        | \"maligngroup\"'), (2341, '        | \"malignmark\"'), (2342, '        | \"math\"'), (2343, '        | \"matrix\"'), (2344, '        | \"matrixrow\"'), (2345, '        | \"max\"'), (2346, '        | \"mean\"'), (2347, '        | \"median\"'), (2348, '        | \"menclose\"'), (2349, '        | \"merror\"'), (2350, '        | \"mfenced\"'), (2351, '        | \"mfrac\"'), (2352, '        | \"mglyph\"'), (2353, '        | \"mi\"'), (2354, '        | \"min\"'), (2355, '        | \"minus\"'), (2356, '        | \"mlabeledtr\"'), (2357, '        | \"mlongdiv\"'), (2358, '        | \"mmultiscripts\"'), (2359, '        | \"mn\"'), (2360, '        | \"mo\"'), (2361, '        | \"mode\"'), (2362, '        | \"moment\"'), (2363, '        | \"momentabout\"'), (2364, '        | \"mover\"'), (2365, '        | \"mpadded\"'), (2366, '        | \"mphantom\"'), (2367, '        | \"mprescripts\"'), (2368, '        | \"mroot\"'), (2369, '        | \"mrow\"'), (2370, '        | \"ms\"'), (2371, '        | \"mscarries\"'), (2372, '        | \"mscarry\"'), (2373, '        | \"msgroup\"'), (2374, '        | \"msline\"'), (2375, '        | \"mspace\"'), (2376, '        | \"msqrt\"'), (2377, '        | \"msrow\"'), (2378, '        | \"mstack\"'), (2379, '        | \"mstyle\"'), (2380, '        | \"msub\"'), (2381, '        | \"msubsup\"'), (2382, '        | \"msup\"'), (2383, '        | \"mtable\"'), (2384, '        | \"mtd\"'), (2385, '        | \"mtext\"'), (2386, '        | \"mtr\"'), (2387, '        | \"munder\"'), (2388, '        | \"munderover\"'), (2389, '        | \"naturalnumbers\"'), (2390, '        | \"neq\"'), (2391, '        | \"none\"'), (2392, '        | \"not\"'), (2393, '        | \"notanumber\"'), (2394, '        | \"notin\"'), (2395, '        | \"notprsubset\"'), (2396, '        | \"notsubset\"'), (2397, '        | \"or\"'), (2398, '        | \"otherwise\"'), (2399, '        | \"outerproduct\"'), (2400, '        | \"partialdiff\"'), (2401, '        | \"pi\"'), (2402, '        | \"piece\"'), (2403, '        | \"piecewise\"'), (2404, '        | \"plus\"'), (2405, '        | \"power\"'), (2406, '        | \"primes\"'), (2407, '        | \"product\"'), (2408, '        | \"prsubset\"'), (2409, '        | \"quotient\"'), (2410, '        | \"rationals\"'), (2411, '        | \"real\"'), (2412, '        | \"reals\"'), (2413, '        | \"reln\"'), (2414, '        | \"rem\"'), (2415, '        | \"root\"'), (2416, '        | \"scalarproduct\"'), (2417, '        | \"sdev\"'), (2418, '        | \"sec\"'), (2419, '        | \"sech\"'), (2420, '        | \"selector\"'), (2421, '        | \"semantics\"'), (2422, '        | \"sep\"'), (2423, '        | \"set\"'), (2424, '        | \"setdiff\"'), (2425, '        | \"share\"'), (2426, '        | \"sin\"'), (2427, '        | \"sinh\"'), (2428, '        | \"span\"'), (2429, '        | \"subset\"'), (2430, '        | \"sum\"'), (2431, '        | \"tan\"'), (2432, '        | \"tanh\"'), (2433, '        | \"tendsto\"'), (2434, '        | \"times\"'), (2435, '        | \"transpose\"'), (2436, '        | \"true\"'), (2437, '        | \"union\"'), (2438, '        | \"uplimit\"'), (2439, '        | \"variance\"'), (2440, '        | \"vector\"'), (2441, '        | \"vectorproduct\"'), (2442, '        | \"xor\" => true,'), (2443, '        _ => false,'), (2444, '    }'), (2445, '}'), (2876, '                    \"{}\",'), (2877, '                    value.to_string()'), (3435, '    #[test]'), (3436, '    fn ns_svg() {'), (3438, '        let fragment = r##\"<svg><iframe><a title=\"</iframe><img src onerror=alert(1)>\">test\"##;'), (3439, '        let result = String::from(Builder::new().add_tags(&[\"iframe\"]).clean(fragment));'), (3440, '        assert_eq!('), (3441, '            result.to_string(),'), (3442, '            \"test\"'), (3443, '        );'), (3445, '        let fragment = \"<svg><iframe>remove me</iframe></svg><iframe>keep me</iframe>\";'), (3446, '        let result = String::from(Builder::new().add_tags(&[\"iframe\"]).clean(fragment));'), (3447, '        assert_eq!(result.to_string(), \"remove me<iframe>keep me</iframe>\");'), (3449, '        let fragment = \"<svg><a>remove me</a></svg><iframe>keep me</iframe>\";'), (3450, '        let result = String::from(Builder::new().add_tags(&[\"iframe\"]).clean(fragment));'), (3451, '        assert_eq!(result.to_string(), \"remove me<iframe>keep me</iframe>\");'), (3453, '        let fragment = \"<svg><a>keep me</a></svg><iframe>keep me</iframe>\";'), (3454, '        let result = String::from(Builder::new().add_tags(&[\"iframe\", \"svg\"]).clean(fragment));'), (3455, '        assert_eq!('), (3456, '            result.to_string(),'), (3457, '            \"<svg><a rel=\\\\\"noopener noreferrer\\\\\">keep me</a></svg><iframe>keep me</iframe>\"'), (3458, '        );'), (3459, '    }'), (3461, '    #[test]'), (3462, '    fn ns_mathml() {'), (3464, '        let fragment = \"<mglyph></mglyph>\";'), (3465, '        let result = String::from('), (3466, '            Builder::new()'), (3467, '                .add_tags(&[\"math\", \"mtext\", \"mglyph\"])'), (3468, '                .clean(fragment),'), (3469, '        );'), (3470, '        assert_eq!(result.to_string(), \"\");'), (3471, '        let fragment = \"<math><mtext><div><mglyph>\";'), (3472, '        let result = String::from('), (3473, '            Builder::new()'), (3474, '                .add_tags(&[\"math\", \"mtext\", \"mglyph\"])'), (3475, '                .clean(fragment),'), (3476, '        );'), (3477, '        assert_eq!('), (3478, '            result.to_string(),'), (3479, '            \"<math><mtext><div></div></mtext></math>\"'), (3480, '        );'), (3481, '        let fragment = \"<math><mtext><mglyph>\";'), (3482, '        let result = String::from('), (3483, '            Builder::new()'), (3484, '                .add_tags(&[\"math\", \"mtext\", \"mglyph\"])'), (3485, '                .clean(fragment),'), (3486, '        );'), (3487, '        assert_eq!('), (3488, '            result.to_string(),'), (3489, '            \"<math><mtext><mglyph></mglyph></mtext></math>\"'), (3490, '        );'), (3491, '    }')], 'deleted': [(1784, '            let pass = self.clean_child(&mut node, url_base);'), (2482, '                    \"{}\", value.to_string()')]}",
    "num_lines_added": "353",
    "num_lines_deleted": "2",
    "nloc": "2639"
  },
  {
    "file_change_id": "105786231831187",
    "hash": "582b6221887e92aeab1ac9008c75133974ed939",
    "old_path": "parc/src/lib.rs",
    "new_path": "parc/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -380,7 +380,7 @@ impl<T> LockWeak<T> {\n     }\n }\n \n-unsafe impl<T> Send for LockWeak<T> {}\n+unsafe impl<T: Sync> Send for LockWeak<T> {}\n \n /// Unclonable owned reference to a [`ParentArc`](struct.ParentArc.html).\n ///\n",
    "diff_parsed": "{'added': [(383, 'unsafe impl<T: Sync> Send for LockWeak<T> {}')], 'deleted': [(383, 'unsafe impl<T> Send for LockWeak<T> {}')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "309"
  },
  {
    "file_change_id": "112226852805997",
    "hash": "be327d581e8434a2ba41b74affc915f42d8abfc",
    "old_path": "crossbeam-channel/src/flavors/array.rs",
    "new_path": "crossbeam-channel/src/flavors/array.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -115,7 +115,7 @@ impl<T> Channel<T> {\n         // Allocate a buffer of `cap` slots initialized\n         // with stamps.\n         let buffer = {\n-            let mut v: Vec<Slot<T>> = (0..cap)\n+            let mut boxed: Box<[Slot<T>]> = (0..cap)\n                 .map(|i| {\n                     // Set the stamp to `{ lap: 0, mark: 0, index: i }`.\n                     Slot {\n@@ -124,8 +124,8 @@ impl<T> Channel<T> {\n                     }\n                 })\n                 .collect();\n-            let ptr = v.as_mut_ptr();\n-            mem::forget(v);\n+            let ptr = boxed.as_mut_ptr();\n+            mem::forget(boxed);\n             ptr\n         };\n \n@@ -553,7 +553,11 @@ impl<T> Drop for Channel<T> {\n \n         // Finally, deallocate the buffer, but don't run any destructors.\n         unsafe {\n-            Vec::from_raw_parts(self.buffer, 0, self.cap);\n+            // Create a slice from the buffer to make\n+            // a fat pointer. Then, use Box::from_raw\n+            // to deallocate it.\n+            let ptr = std::slice::from_raw_parts_mut(self.buffer, self.cap) as *mut [Slot<T>];\n+            Box::from_raw(ptr);\n         }\n     }\n }\n",
    "diff_parsed": "{'added': [(118, '            let mut boxed: Box<[Slot<T>]> = (0..cap)'), (127, '            let ptr = boxed.as_mut_ptr();'), (128, '            mem::forget(boxed);'), (559, '            let ptr = std::slice::from_raw_parts_mut(self.buffer, self.cap) as *mut [Slot<T>];'), (560, '            Box::from_raw(ptr);')], 'deleted': [(118, '            let mut v: Vec<Slot<T>> = (0..cap)'), (127, '            let ptr = v.as_mut_ptr();'), (128, '            mem::forget(v);'), (556, '            Vec::from_raw_parts(self.buffer, 0, self.cap);')]}",
    "num_lines_added": "5",
    "num_lines_deleted": "4",
    "nloc": "425"
  },
  {
    "file_change_id": "128583722713435",
    "hash": "be327d581e8434a2ba41b74affc915f42d8abfc",
    "old_path": "crossbeam-queue/src/array_queue.rs",
    "new_path": "crossbeam-queue/src/array_queue.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -8,7 +8,7 @@\n //!   - Simplified BSD License and Apache License, Version 2.0\n //!   - http://www.1024cores.net/home/code-license\n \n-use alloc::vec::Vec;\n+use alloc::boxed::Box;\n use core::cell::UnsafeCell;\n use core::fmt;\n use core::marker::PhantomData;\n@@ -110,7 +110,7 @@ impl<T> ArrayQueue<T> {\n         // Allocate a buffer of `cap` slots initialized\n         // with stamps.\n         let buffer = {\n-            let mut v: Vec<Slot<T>> = (0..cap)\n+            let mut boxed: Box<[Slot<T>]> = (0..cap)\n                 .map(|i| {\n                     // Set the stamp to `{ lap: 0, index: i }`.\n                     Slot {\n@@ -119,8 +119,8 @@ impl<T> ArrayQueue<T> {\n                     }\n                 })\n                 .collect();\n-            let ptr = v.as_mut_ptr();\n-            mem::forget(v);\n+            let ptr = boxed.as_mut_ptr();\n+            mem::forget(boxed);\n             ptr\n         };\n \n@@ -425,7 +425,11 @@ impl<T> Drop for ArrayQueue<T> {\n \n         // Finally, deallocate the buffer, but don't run any destructors.\n         unsafe {\n-            Vec::from_raw_parts(self.buffer, 0, self.cap);\n+            // Create a slice from the buffer to make\n+            // a fat pointer. Then, use Box::from_raw\n+            // to deallocate it.\n+            let ptr = core::slice::from_raw_parts_mut(self.buffer, self.cap) as *mut [Slot<T>];\n+            Box::from_raw(ptr);\n         }\n     }\n }\n",
    "diff_parsed": "{'added': [(11, 'use alloc::boxed::Box;'), (113, '            let mut boxed: Box<[Slot<T>]> = (0..cap)'), (122, '            let ptr = boxed.as_mut_ptr();'), (123, '            mem::forget(boxed);'), (431, '            let ptr = core::slice::from_raw_parts_mut(self.buffer, self.cap) as *mut [Slot<T>];'), (432, '            Box::from_raw(ptr);')], 'deleted': [(11, 'use alloc::vec::Vec;'), (113, '            let mut v: Vec<Slot<T>> = (0..cap)'), (122, '            let ptr = v.as_mut_ptr();'), (123, '            mem::forget(v);'), (428, '            Vec::from_raw_parts(self.buffer, 0, self.cap);')]}",
    "num_lines_added": "6",
    "num_lines_deleted": "5",
    "nloc": "203"
  },
  {
    "file_change_id": "123447421076014",
    "hash": "e1068fdd32f1b12edad05b579f6cd2bd638316e",
    "old_path": "lucet-runtime/lucet-runtime-internals/src/alloc/mod.rs",
    "new_path": "lucet-runtime/lucet-runtime-internals/src/alloc/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,7 +1,7 @@\n use crate::error::Error;\n use crate::module::Module;\n use crate::region::RegionInternal;\n-use libc::{c_void, SIGSTKSZ};\n+use libc::c_void;\n use lucet_module::GlobalValue;\n use nix::unistd::{sysconf, SysconfVar};\n use std::sync::{Arc, Once, Weak};\n@@ -318,7 +318,10 @@ impl Alloc {\n \n     /// Return the sigstack as a mutable byte slice.\n     pub unsafe fn sigstack_mut(&mut self) -> &mut [u8] {\n-        std::slice::from_raw_parts_mut(self.slot().sigstack as *mut u8, libc::SIGSTKSZ)\n+        std::slice::from_raw_parts_mut(\n+            self.slot().sigstack as *mut u8,\n+            self.slot().limits.signal_stack_size,\n+        )\n     }\n \n     pub fn mem_in_heap<T>(&self, ptr: *const T, len: usize) -> bool {\n@@ -351,15 +354,30 @@ pub struct Limits {\n     pub stack_size: usize,\n     /// Size of the globals region in bytes; each global uses 8 bytes. (default 4K)\n     pub globals_size: usize,\n+    /// Size of the signal stack in bytes. (default SIGSTKSZ for release builds, 12K for debug builds)\n+    ///\n+    /// This difference is to account for the greatly increased stack size usage in the signal\n+    /// handler when running without optimizations.\n+    ///\n+    /// Note that debug vs. release mode is determined by `cfg(debug_assertions)`, so if you are\n+    /// specifically enabling debug assertions in your release builds, the default signal stack will\n+    /// be larger.\n+    pub signal_stack_size: usize,\n }\n \n-impl Default for Limits {\n-    fn default() -> Limits {\n+#[cfg(debug_assertions)]\n+pub const DEFAULT_SIGNAL_STACK_SIZE: usize = 12 * 1024;\n+#[cfg(not(debug_assertions))]\n+pub const DEFAULT_SIGNAL_STACK_SIZE: usize = libc::SIGSTKSZ;\n+\n+impl Limits {\n+    pub const fn default() -> Limits {\n         Limits {\n             heap_memory_size: 16 * 64 * 1024,\n             heap_address_space_size: 0x200000000,\n             stack_size: 128 * 1024,\n             globals_size: 4096,\n+            signal_stack_size: DEFAULT_SIGNAL_STACK_SIZE,\n         }\n     }\n }\n@@ -370,19 +388,18 @@ impl Limits {\n         // * the instance (up to instance_heap_offset)\n         // * the heap, followed by guard pages\n         // * the stack (grows towards heap guard pages)\n-        // * one guard page (for good luck?)\n         // * globals\n         // * one guard page (to catch signal stack overflow)\n-        // * the signal stack (size given by signal.h SIGSTKSZ macro)\n+        // * the signal stack\n \n         [\n             instance_heap_offset(),\n             self.heap_address_space_size,\n-            self.stack_size,\n             host_page_size(),\n+            self.stack_size,\n             self.globals_size,\n             host_page_size(),\n-            SIGSTKSZ,\n+            self.signal_stack_size,\n         ]\n         .iter()\n         .try_fold(0usize, |acc, &x| acc.checked_add(x))\n@@ -419,6 +436,11 @@ impl Limits {\n         if self.stack_size <= 0 {\n             return Err(Error::InvalidArgument(\"stack size must be greater than 0\"));\n         }\n+        if self.signal_stack_size % host_page_size() != 0 {\n+            return Err(Error::InvalidArgument(\n+                \"signal stack size must be a multiple of host page size\",\n+            ));\n+        }\n         Ok(())\n     }\n }\n",
    "diff_parsed": "{'added': [(4, 'use libc::c_void;'), (321, '        std::slice::from_raw_parts_mut('), (322, '            self.slot().sigstack as *mut u8,'), (323, '            self.slot().limits.signal_stack_size,'), (324, '        )'), (365, '    pub signal_stack_size: usize,'), (368, '#[cfg(debug_assertions)]'), (369, 'pub const DEFAULT_SIGNAL_STACK_SIZE: usize = 12 * 1024;'), (370, '#[cfg(not(debug_assertions))]'), (371, 'pub const DEFAULT_SIGNAL_STACK_SIZE: usize = libc::SIGSTKSZ;'), (373, 'impl Limits {'), (374, '    pub const fn default() -> Limits {'), (380, '            signal_stack_size: DEFAULT_SIGNAL_STACK_SIZE,'), (399, '            self.stack_size,'), (402, '            self.signal_stack_size,'), (439, '        if self.signal_stack_size % host_page_size() != 0 {'), (440, '            return Err(Error::InvalidArgument('), (441, '                \"signal stack size must be a multiple of host page size\",'), (442, '            ));'), (443, '        }')], 'deleted': [(4, 'use libc::{c_void, SIGSTKSZ};'), (321, '        std::slice::from_raw_parts_mut(self.slot().sigstack as *mut u8, libc::SIGSTKSZ)'), (356, 'impl Default for Limits {'), (357, '    fn default() -> Limits {'), (381, '            self.stack_size,'), (385, '            SIGSTKSZ,')]}",
    "num_lines_added": "20",
    "num_lines_deleted": "6",
    "nloc": "291"
  },
  {
    "file_change_id": "28858525359072",
    "hash": "e1068fdd32f1b12edad05b579f6cd2bd638316e",
    "old_path": "lucet-runtime/lucet-runtime-internals/src/alloc/tests.rs",
    "new_path": "lucet-runtime/lucet-runtime-internals/src/alloc/tests.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -21,6 +21,7 @@ macro_rules! alloc_tests {\n             heap_address_space_size: LIMITS_HEAP_ADDRSPACE_SIZE,\n             stack_size: LIMITS_STACK_SIZE,\n             globals_size: LIMITS_GLOBALS_SIZE,\n+            ..Limits::default()\n         };\n \n         const SPEC_HEAP_RESERVED_SIZE: u64 = LIMITS_HEAP_ADDRSPACE_SIZE as u64 / 2;\n@@ -264,6 +265,7 @@ macro_rules! alloc_tests {\n                 heap_address_space_size: LIMITS_HEAP_ADDRSPACE_SIZE,\n                 stack_size: LIMITS_STACK_SIZE,\n                 globals_size: LIMITS_GLOBALS_SIZE,\n+                ..Limits::default()\n             };\n             let res = TestRegion::create(10, &LIMITS);\n             assert!(res.is_err(), \"region creation fails\");\n@@ -366,7 +368,7 @@ macro_rules! alloc_tests {\n                 }\n \n                 let sigstack = unsafe { inst.alloc_mut().sigstack_mut() };\n-                assert_eq!(sigstack.len(), libc::SIGSTKSZ);\n+                assert_eq!(sigstack.len(), LIMITS.signal_stack_size);\n \n                 assert_eq!(sigstack[0], 0);\n                 sigstack[0] = 0xFF;\n@@ -569,6 +571,7 @@ macro_rules! alloc_tests {\n             heap_address_space_size: 2 * 4096,\n             stack_size: 4096,\n             globals_size: 4096,\n+            ..Limits::default()\n         };\n         const CONTEXT_TEST_INITIAL_SIZE: u64 = 4096;\n         const CONTEXT_TEST_HEAP: HeapSpec = HeapSpec {\n",
    "diff_parsed": "{'added': [(24, '            ..Limits::default()'), (268, '                ..Limits::default()'), (371, '                assert_eq!(sigstack.len(), LIMITS.signal_stack_size);'), (574, '            ..Limits::default()')], 'deleted': [(369, '                assert_eq!(sigstack.len(), libc::SIGSTKSZ);')]}",
    "num_lines_added": "4",
    "num_lines_deleted": "1",
    "nloc": "534"
  },
  {
    "file_change_id": "220064474443075",
    "hash": "e1068fdd32f1b12edad05b579f6cd2bd638316e",
    "old_path": "lucet-runtime/lucet-runtime-internals/src/c_api.rs",
    "new_path": "lucet-runtime/lucet-runtime-internals/src/c_api.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -140,6 +140,16 @@ pub struct lucet_alloc_limits {\n     pub stack_size: u64,\n     /// Size of the globals region in bytes; each global uses 8 bytes. (default 4K)\n     pub globals_size: u64,\n+    /// Size of the signal stack in bytes. (default SIGSTKSZ for Rust release builds, 12K for Rust\n+    /// debug builds)\n+    ///\n+    /// This difference is to account for the greatly increased stack size usage in the signal\n+    /// handler when running without optimizations.\n+    ///\n+    /// Note that debug vs. release mode is determined by `cfg(debug_assertions)`, so if you are\n+    /// specifically enabling Rust debug assertions in your Cargo release builds, the default signal\n+    /// stack will be larger.\n+    pub signal_stack_size: u64,\n }\n \n impl From<Limits> for lucet_alloc_limits {\n@@ -155,6 +165,7 @@ impl From<&Limits> for lucet_alloc_limits {\n             heap_address_space_size: limits.heap_address_space_size as u64,\n             stack_size: limits.stack_size as u64,\n             globals_size: limits.globals_size as u64,\n+            signal_stack_size: limits.signal_stack_size as u64,\n         }\n     }\n }\n@@ -172,6 +183,7 @@ impl From<&lucet_alloc_limits> for Limits {\n             heap_address_space_size: limits.heap_address_space_size as usize,\n             stack_size: limits.stack_size as usize,\n             globals_size: limits.globals_size as usize,\n+            signal_stack_size: limits.signal_stack_size as usize,\n         }\n     }\n }\n",
    "diff_parsed": "{'added': [(152, '    pub signal_stack_size: u64,'), (168, '            signal_stack_size: limits.signal_stack_size as u64,'), (186, '            signal_stack_size: limits.signal_stack_size as usize,')], 'deleted': []}",
    "num_lines_added": "3",
    "num_lines_deleted": "0",
    "nloc": "581"
  },
  {
    "file_change_id": "125009842647650",
    "hash": "e1068fdd32f1b12edad05b579f6cd2bd638316e",
    "old_path": "lucet-runtime/lucet-runtime-internals/src/instance/signals.rs",
    "new_path": "lucet-runtime/lucet-runtime-internals/src/instance/signals.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -61,7 +61,7 @@ impl Instance {\n         let guest_sigstack = SigStack::new(\n             self.alloc.slot().sigstack,\n             SigStackFlags::empty(),\n-            libc::SIGSTKSZ,\n+            self.alloc.slot().limits.signal_stack_size,\n         );\n         let previous_sigstack = unsafe { sigaltstack(Some(guest_sigstack)) }\n             .expect(\"enabling or changing the signal stack succeeds\");\n",
    "diff_parsed": "{'added': [(64, '            self.alloc.slot().limits.signal_stack_size,')], 'deleted': [(64, '            libc::SIGSTKSZ,')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "363"
  },
  {
    "file_change_id": "251097816553002",
    "hash": "e1068fdd32f1b12edad05b579f6cd2bd638316e",
    "old_path": "lucet-runtime/lucet-runtime-internals/src/region/mmap.rs",
    "new_path": "lucet-runtime/lucet-runtime-internals/src/region/mmap.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -4,9 +4,9 @@ use crate::error::Error;\n use crate::instance::{new_instance_handle, Instance, InstanceHandle};\n use crate::module::Module;\n use crate::region::{Region, RegionCreate, RegionInternal};\n+use libc::c_void;\n #[cfg(not(target_os = \"linux\"))]\n use libc::memset;\n-use libc::{c_void, SIGSTKSZ};\n use nix::sys::mman::{madvise, mmap, munmap, MapFlags, MmapAdvise, ProtFlags};\n use std::ptr;\n use std::sync::{Arc, Mutex, Weak};\n@@ -49,7 +49,7 @@ use std::sync::{Arc, Mutex, Weak};\n /// 0xXXXX: |                       |\n /// 0xXXXX  --- global guard page ---\n /// 0xS000: +-----------------------| <-- Sigstack (at globals_start + globals_size + PAGE_SIZE)\n-/// 0xSXXX: |  ......sigstack....   | // sigstack is SIGSTKSZ bytes\n+/// 0xSXXX: |  ......sigstack....   | // sigstack is governed by limits.signal_stack_size\n /// 0xSXXX: +-----------------------|\n /// ```\n pub struct MmapRegion {\n@@ -87,7 +87,7 @@ impl RegionInternal for MmapRegion {\n             // make the globals read/writable\n             (slot.globals, limits.globals_size),\n             // make the sigstack read/writable\n-            (slot.sigstack, SIGSTKSZ),\n+            (slot.sigstack, limits.signal_stack_size),\n         ]\n         .iter()\n         {\n@@ -136,7 +136,7 @@ impl RegionInternal for MmapRegion {\n             (slot.heap, alloc.heap_accessible_size),\n             (slot.stack, slot.limits.stack_size),\n             (slot.globals, slot.limits.globals_size),\n-            (slot.sigstack, SIGSTKSZ),\n+            (slot.sigstack, slot.limits.signal_stack_size),\n         ]\n         .iter()\n         {\n@@ -272,10 +272,6 @@ impl MmapRegion {\n     /// The region is returned in an `Arc`, because any instances created from it carry a reference\n     /// back to the region.\n     pub fn create(instance_capacity: usize, limits: &Limits) -> Result<Arc<Self>, Error> {\n-        assert!(\n-            SIGSTKSZ % host_page_size() == 0,\n-            \"signal stack size is a multiple of host page size\"\n-        );\n         limits.validate()?;\n \n         let region = Arc::new(MmapRegion {\n@@ -305,10 +301,6 @@ impl MmapRegion {\n         limits: &Limits,\n         heap_alignment: usize,\n     ) -> Result<Arc<Self>, Error> {\n-        assert!(\n-            SIGSTKSZ % host_page_size() == 0,\n-            \"signal stack size is a multiple of host page size\"\n-        );\n         limits.validate()?;\n \n         let is_power_of_2 = (heap_alignment & (heap_alignment - 1)) == 0;\n@@ -374,7 +366,7 @@ impl MmapRegion {\n         let heap = mem as usize + instance_heap_offset();\n         let stack = heap + region.limits.heap_address_space_size + host_page_size();\n         let globals = stack + region.limits.stack_size;\n-        let sigstack = globals + host_page_size();\n+        let sigstack = globals + region.limits.globals_size + host_page_size();\n \n         Ok(Slot {\n             start: mem,\n",
    "diff_parsed": "{'added': [(7, 'use libc::c_void;'), (90, '            (slot.sigstack, limits.signal_stack_size),'), (139, '            (slot.sigstack, slot.limits.signal_stack_size),'), (369, '        let sigstack = globals + region.limits.globals_size + host_page_size();')], 'deleted': [(9, 'use libc::{c_void, SIGSTKSZ};'), (90, '            (slot.sigstack, SIGSTKSZ),'), (139, '            (slot.sigstack, SIGSTKSZ),'), (275, '        assert!('), (276, '            SIGSTKSZ % host_page_size() == 0,'), (277, '            \"signal stack size is a multiple of host page size\"'), (278, '        );'), (308, '        assert!('), (309, '            SIGSTKSZ % host_page_size() == 0,'), (310, '            \"signal stack size is a multiple of host page size\"'), (311, '        );'), (377, '        let sigstack = globals + host_page_size();')]}",
    "num_lines_added": "4",
    "num_lines_deleted": "12",
    "nloc": "370"
  },
  {
    "file_change_id": "81913273772416",
    "hash": "e1068fdd32f1b12edad05b579f6cd2bd638316e",
    "old_path": "lucet-runtime/lucet-runtime-tests/src/guest_fault.rs",
    "new_path": "lucet-runtime/lucet-runtime-tests/src/guest_fault.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -127,8 +127,9 @@ macro_rules! guest_fault_tests {\n         use libc::{c_void, pthread_kill, pthread_self, siginfo_t, SIGALRM, SIGSEGV};\n         use lucet_runtime::vmctx::{lucet_vmctx, Vmctx};\n         use lucet_runtime::{\n-            lucet_hostcall, lucet_hostcall_terminate, DlModule, Error, FaultDetails, Instance,\n-            Limits, Region, SignalBehavior, TerminationDetails, TrapCode,\n+            lucet_hostcall, lucet_hostcall_terminate, lucet_internal_ensure_linked, DlModule,\n+            Error, FaultDetails, Instance, Limits, Region, SignalBehavior, TerminationDetails,\n+            TrapCode,\n         };\n         use nix::sys::mman::{mmap, MapFlags, ProtFlags};\n         use nix::sys::signal::{sigaction, SaFlags, SigAction, SigHandler, SigSet, Signal};\n@@ -577,6 +578,7 @@ macro_rules! guest_fault_tests {\n \n         #[test]\n         fn fatal_abort() {\n+            lucet_internal_ensure_linked();\n             fn handler(_inst: &Instance) -> ! {\n                 std::process::abort()\n             }\n",
    "diff_parsed": "{'added': [(130, '            lucet_hostcall, lucet_hostcall_terminate, lucet_internal_ensure_linked, DlModule,'), (131, '            Error, FaultDetails, Instance, Limits, Region, SignalBehavior, TerminationDetails,'), (132, '            TrapCode,'), (581, '            lucet_internal_ensure_linked();')], 'deleted': [(130, '            lucet_hostcall, lucet_hostcall_terminate, DlModule, Error, FaultDetails, Instance,'), (131, '            Limits, Region, SignalBehavior, TerminationDetails, TrapCode,')]}",
    "num_lines_added": "4",
    "num_lines_deleted": "2",
    "nloc": "544"
  },
  {
    "file_change_id": "103887826125255",
    "hash": "e1068fdd32f1b12edad05b579f6cd2bd638316e",
    "old_path": "lucet-runtime/lucet-runtime-tests/src/timeout.rs",
    "new_path": "lucet-runtime/lucet-runtime-tests/src/timeout.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,66 +1,11 @@\n-use crate::helpers::{MockExportBuilder, MockModuleBuilder};\n-use lucet_module::FunctionPointer;\n-use lucet_runtime_internals::module::Module;\n-use lucet_runtime_internals::vmctx::lucet_vmctx;\n-use std::sync::Arc;\n-\n-pub fn mock_timeout_module() -> Arc<dyn Module> {\n-    extern \"C\" fn onetwothree(_vmctx: *mut lucet_vmctx) -> std::os::raw::c_int {\n-        123\n-    }\n-\n-    extern \"C\" fn infinite_loop(_vmctx: *mut lucet_vmctx) -> () {\n-        loop {}\n-    }\n-\n-    extern \"C\" fn do_nothing(_vmctx: *mut lucet_vmctx) -> () {}\n-\n-    extern \"C\" fn run_slow_hostcall(vmctx: *mut lucet_vmctx) -> bool {\n-        extern \"C\" {\n-            fn slow_hostcall(vmctx: *mut lucet_vmctx) -> bool;\n-        }\n-        unsafe { slow_hostcall(vmctx) }\n-    }\n-\n-    extern \"C\" fn run_yielding_hostcall(vmctx: *mut lucet_vmctx) -> () {\n-        extern \"C\" {\n-            fn yielding_hostcall(vmctx: *mut lucet_vmctx) -> ();\n-        }\n-        unsafe { yielding_hostcall(vmctx) }\n-    }\n-\n-    MockModuleBuilder::new()\n-        .with_export_func(MockExportBuilder::new(\n-            \"infinite_loop\",\n-            FunctionPointer::from_usize(infinite_loop as usize),\n-        ))\n-        .with_export_func(MockExportBuilder::new(\n-            \"do_nothing\",\n-            FunctionPointer::from_usize(do_nothing as usize),\n-        ))\n-        .with_export_func(MockExportBuilder::new(\n-            \"onetwothree\",\n-            FunctionPointer::from_usize(onetwothree as usize),\n-        ))\n-        .with_export_func(MockExportBuilder::new(\n-            \"run_slow_hostcall\",\n-            FunctionPointer::from_usize(run_slow_hostcall as usize),\n-        ))\n-        .with_export_func(MockExportBuilder::new(\n-            \"run_yielding_hostcall\",\n-            FunctionPointer::from_usize(run_yielding_hostcall as usize),\n-        ))\n-        .build()\n-}\n-\n #[macro_export]\n macro_rules! timeout_tests {\n     ( $TestRegion:path ) => {\n         use lucet_runtime::vmctx::{lucet_vmctx, Vmctx};\n         use lucet_runtime::{\n             lucet_hostcall, lucet_hostcall_terminate, DlModule, Error, FaultDetails, Instance,\n-            KillError, KillSuccess, Limits, Region, RunResult, SignalBehavior, TerminationDetails,\n-            TrapCode, YieldedVal,\n+            KillError, KillSuccess, Limits, Module, Region, RunResult, SignalBehavior,\n+            TerminationDetails, TrapCode, YieldedVal,\n         };\n         use nix::sys::mman::{mmap, MapFlags, ProtFlags};\n         use nix::sys::signal::{sigaction, SaFlags, SigAction, SigHandler, SigSet, Signal};\n@@ -73,7 +18,55 @@ macro_rules! timeout_tests {\n         use $TestRegion as TestRegion;\n         use $crate::build::test_module_c;\n         use $crate::helpers::{FunctionPointer, MockExportBuilder, MockModuleBuilder};\n-        use $crate::timeout::mock_timeout_module;\n+\n+        pub fn mock_timeout_module() -> Arc<dyn Module> {\n+            extern \"C\" fn onetwothree(_vmctx: *mut lucet_vmctx) -> std::os::raw::c_int {\n+                123\n+            }\n+\n+            extern \"C\" fn infinite_loop(_vmctx: *mut lucet_vmctx) -> () {\n+                loop {}\n+            }\n+\n+            extern \"C\" fn do_nothing(_vmctx: *mut lucet_vmctx) -> () {}\n+\n+            extern \"C\" fn run_slow_hostcall(vmctx: *mut lucet_vmctx) -> bool {\n+                extern \"C\" {\n+                    fn slow_hostcall(vmctx: *mut lucet_vmctx) -> bool;\n+                }\n+                unsafe { slow_hostcall(vmctx) }\n+            }\n+\n+            extern \"C\" fn run_yielding_hostcall(vmctx: *mut lucet_vmctx) -> () {\n+                extern \"C\" {\n+                    fn yielding_hostcall(vmctx: *mut lucet_vmctx) -> ();\n+                }\n+                unsafe { yielding_hostcall(vmctx) }\n+            }\n+\n+            MockModuleBuilder::new()\n+                .with_export_func(MockExportBuilder::new(\n+                    \"infinite_loop\",\n+                    FunctionPointer::from_usize(infinite_loop as usize),\n+                ))\n+                .with_export_func(MockExportBuilder::new(\n+                    \"do_nothing\",\n+                    FunctionPointer::from_usize(do_nothing as usize),\n+                ))\n+                .with_export_func(MockExportBuilder::new(\n+                    \"onetwothree\",\n+                    FunctionPointer::from_usize(onetwothree as usize),\n+                ))\n+                .with_export_func(MockExportBuilder::new(\n+                    \"run_slow_hostcall\",\n+                    FunctionPointer::from_usize(run_slow_hostcall as usize),\n+                ))\n+                .with_export_func(MockExportBuilder::new(\n+                    \"run_yielding_hostcall\",\n+                    FunctionPointer::from_usize(run_yielding_hostcall as usize),\n+                ))\n+                .build()\n+        }\n \n         #[lucet_hostcall]\n         #[no_mangle]\n",
    "diff_parsed": "{'added': [(7, '            KillError, KillSuccess, Limits, Module, Region, RunResult, SignalBehavior,'), (8, '            TerminationDetails, TrapCode, YieldedVal,'), (22, '        pub fn mock_timeout_module() -> Arc<dyn Module> {'), (23, '            extern \"C\" fn onetwothree(_vmctx: *mut lucet_vmctx) -> std::os::raw::c_int {'), (24, '                123'), (25, '            }'), (27, '            extern \"C\" fn infinite_loop(_vmctx: *mut lucet_vmctx) -> () {'), (28, '                loop {}'), (29, '            }'), (31, '            extern \"C\" fn do_nothing(_vmctx: *mut lucet_vmctx) -> () {}'), (33, '            extern \"C\" fn run_slow_hostcall(vmctx: *mut lucet_vmctx) -> bool {'), (34, '                extern \"C\" {'), (35, '                    fn slow_hostcall(vmctx: *mut lucet_vmctx) -> bool;'), (36, '                }'), (37, '                unsafe { slow_hostcall(vmctx) }'), (38, '            }'), (40, '            extern \"C\" fn run_yielding_hostcall(vmctx: *mut lucet_vmctx) -> () {'), (41, '                extern \"C\" {'), (42, '                    fn yielding_hostcall(vmctx: *mut lucet_vmctx) -> ();'), (43, '                }'), (44, '                unsafe { yielding_hostcall(vmctx) }'), (45, '            }'), (47, '            MockModuleBuilder::new()'), (48, '                .with_export_func(MockExportBuilder::new('), (49, '                    \"infinite_loop\",'), (50, '                    FunctionPointer::from_usize(infinite_loop as usize),'), (51, '                ))'), (52, '                .with_export_func(MockExportBuilder::new('), (53, '                    \"do_nothing\",'), (54, '                    FunctionPointer::from_usize(do_nothing as usize),'), (55, '                ))'), (56, '                .with_export_func(MockExportBuilder::new('), (57, '                    \"onetwothree\",'), (58, '                    FunctionPointer::from_usize(onetwothree as usize),'), (59, '                ))'), (60, '                .with_export_func(MockExportBuilder::new('), (61, '                    \"run_slow_hostcall\",'), (62, '                    FunctionPointer::from_usize(run_slow_hostcall as usize),'), (63, '                ))'), (64, '                .with_export_func(MockExportBuilder::new('), (65, '                    \"run_yielding_hostcall\",'), (66, '                    FunctionPointer::from_usize(run_yielding_hostcall as usize),'), (67, '                ))'), (68, '                .build()'), (69, '        }')], 'deleted': [(1, 'use crate::helpers::{MockExportBuilder, MockModuleBuilder};'), (2, 'use lucet_module::FunctionPointer;'), (3, 'use lucet_runtime_internals::module::Module;'), (4, 'use lucet_runtime_internals::vmctx::lucet_vmctx;'), (5, 'use std::sync::Arc;'), (7, 'pub fn mock_timeout_module() -> Arc<dyn Module> {'), (8, '    extern \"C\" fn onetwothree(_vmctx: *mut lucet_vmctx) -> std::os::raw::c_int {'), (9, '        123'), (10, '    }'), (12, '    extern \"C\" fn infinite_loop(_vmctx: *mut lucet_vmctx) -> () {'), (13, '        loop {}'), (14, '    }'), (16, '    extern \"C\" fn do_nothing(_vmctx: *mut lucet_vmctx) -> () {}'), (18, '    extern \"C\" fn run_slow_hostcall(vmctx: *mut lucet_vmctx) -> bool {'), (19, '        extern \"C\" {'), (20, '            fn slow_hostcall(vmctx: *mut lucet_vmctx) -> bool;'), (21, '        }'), (22, '        unsafe { slow_hostcall(vmctx) }'), (23, '    }'), (25, '    extern \"C\" fn run_yielding_hostcall(vmctx: *mut lucet_vmctx) -> () {'), (26, '        extern \"C\" {'), (27, '            fn yielding_hostcall(vmctx: *mut lucet_vmctx) -> ();'), (28, '        }'), (29, '        unsafe { yielding_hostcall(vmctx) }'), (30, '    }'), (32, '    MockModuleBuilder::new()'), (33, '        .with_export_func(MockExportBuilder::new('), (34, '            \"infinite_loop\",'), (35, '            FunctionPointer::from_usize(infinite_loop as usize),'), (36, '        ))'), (37, '        .with_export_func(MockExportBuilder::new('), (38, '            \"do_nothing\",'), (39, '            FunctionPointer::from_usize(do_nothing as usize),'), (40, '        ))'), (41, '        .with_export_func(MockExportBuilder::new('), (42, '            \"onetwothree\",'), (43, '            FunctionPointer::from_usize(onetwothree as usize),'), (44, '        ))'), (45, '        .with_export_func(MockExportBuilder::new('), (46, '            \"run_slow_hostcall\",'), (47, '            FunctionPointer::from_usize(run_slow_hostcall as usize),'), (48, '        ))'), (49, '        .with_export_func(MockExportBuilder::new('), (50, '            \"run_yielding_hostcall\",'), (51, '            FunctionPointer::from_usize(run_yielding_hostcall as usize),'), (52, '        ))'), (53, '        .build()'), (54, '}'), (62, '            KillError, KillSuccess, Limits, Region, RunResult, SignalBehavior, TerminationDetails,'), (63, '            TrapCode, YieldedVal,'), (76, '        use $crate::timeout::mock_timeout_module;')]}",
    "num_lines_added": "45",
    "num_lines_deleted": "51",
    "nloc": "244"
  },
  {
    "file_change_id": "201042760384135",
    "hash": "e1068fdd32f1b12edad05b579f6cd2bd638316e",
    "old_path": "lucet-wasi/src/main.rs",
    "new_path": "lucet-wasi/src/main.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -178,6 +178,7 @@ fn main() {\n         heap_address_space_size,\n         stack_size,\n         globals_size: 0, // calculated from module\n+        ..Limits::default()\n     };\n \n     let guest_args = matches\n",
    "diff_parsed": "{'added': [(181, '        ..Limits::default()')], 'deleted': []}",
    "num_lines_added": "1",
    "num_lines_deleted": "0",
    "nloc": "259"
  },
  {
    "file_change_id": "241438885611970",
    "hash": "813a329f11b4901f962d89fe340004bb32129ac",
    "old_path": "src/net.rs",
    "new_path": "src/net.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -13,6 +13,8 @@ use std::sync::atomic::{AtomicUsize, Ordering};\n \n use winapi::ctypes::*;\n use winapi::shared::guiddef::*;\n+use winapi::shared::in6addr::{in6_addr_u, IN6_ADDR};\n+use winapi::shared::inaddr::{in_addr_S_un, IN_ADDR};\n use winapi::shared::minwindef::*;\n use winapi::shared::minwindef::{FALSE, TRUE};\n use winapi::shared::ntdef::*;\n@@ -456,16 +458,64 @@ fn cvt(i: c_int, size: DWORD) -> io::Result<Option<usize>> {\n     }\n }\n \n-fn socket_addr_to_ptrs(addr: &SocketAddr) -> (*const SOCKADDR, c_int) {\n+/// A type with the same memory layout as `SOCKADDR`. Used in converting Rust level\n+/// SocketAddr* types into their system representation. The benefit of this specific\n+/// type over using `SOCKADDR_STORAGE` is that this type is exactly as large as it\n+/// needs to be and not a lot larger. And it can be initialized cleaner from Rust.\n+#[repr(C)]\n+pub(crate) union SocketAddrCRepr {\n+    v4: SOCKADDR_IN,\n+    v6: SOCKADDR_IN6_LH,\n+}\n+\n+impl SocketAddrCRepr {\n+    pub(crate) fn as_ptr(&self) -> *const SOCKADDR {\n+        self as *const _ as *const SOCKADDR\n+    }\n+}\n+\n+fn socket_addr_to_ptrs(addr: &SocketAddr) -> (SocketAddrCRepr, c_int) {\n     match *addr {\n-        SocketAddr::V4(ref a) => (\n-            a as *const _ as *const _,\n-            mem::size_of::<SOCKADDR_IN>() as c_int,\n-        ),\n-        SocketAddr::V6(ref a) => (\n-            a as *const _ as *const _,\n-            mem::size_of::<SOCKADDR_IN6_LH>() as c_int,\n-        ),\n+        SocketAddr::V4(ref a) => {\n+            let sin_addr = unsafe {\n+                let mut s_un = mem::zeroed::<in_addr_S_un>();\n+                *s_un.S_addr_mut() = u32::from_ne_bytes(a.ip().octets());\n+                IN_ADDR { S_un: s_un }\n+            };\n+\n+            let sockaddr_in = SOCKADDR_IN {\n+                sin_family: AF_INET as ADDRESS_FAMILY,\n+                sin_port: a.port().to_be(),\n+                sin_addr,\n+                sin_zero: [0; 8],\n+            };\n+\n+            let sockaddr = SocketAddrCRepr { v4: sockaddr_in };\n+            (sockaddr, mem::size_of::<SOCKADDR_IN>() as c_int)\n+        }\n+        SocketAddr::V6(ref a) => {\n+            let sin6_addr = unsafe {\n+                let mut u = mem::zeroed::<in6_addr_u>();\n+                *u.Byte_mut() = a.ip().octets();\n+                IN6_ADDR { u }\n+            };\n+            let u = unsafe {\n+                let mut u = mem::zeroed::<SOCKADDR_IN6_LH_u>();\n+                *u.sin6_scope_id_mut() = a.scope_id();\n+                u\n+            };\n+\n+            let sockaddr_in6 = SOCKADDR_IN6_LH {\n+                sin6_family: AF_INET6 as ADDRESS_FAMILY,\n+                sin6_port: a.port().to_be(),\n+                sin6_addr,\n+                sin6_flowinfo: a.flowinfo(),\n+                u,\n+            };\n+\n+            let sockaddr = SocketAddrCRepr { v6: sockaddr_in6 };\n+            (sockaddr, mem::size_of::<SOCKADDR_IN6_LH>() as c_int)\n+        }\n     }\n }\n \n@@ -650,7 +700,7 @@ unsafe fn connect_overlapped(\n     let mut bytes_sent: DWORD = 0;\n     let r = connect_ex(\n         socket,\n-        addr_buf,\n+        addr_buf.as_ptr(),\n         addr_len,\n         buf.as_ptr() as *mut _,\n         buf.len() as u32,\n@@ -723,7 +773,7 @@ impl UdpSocketExt for UdpSocket {\n             1,\n             &mut sent_bytes,\n             0,\n-            addr_buf as *const _,\n+            addr_buf.as_ptr() as *const _,\n             addr_len,\n             overlapped,\n             None,\n",
    "diff_parsed": "{'added': [(16, 'use winapi::shared::in6addr::{in6_addr_u, IN6_ADDR};'), (17, 'use winapi::shared::inaddr::{in_addr_S_un, IN_ADDR};'), (465, '#[repr(C)]'), (466, 'pub(crate) union SocketAddrCRepr {'), (467, '    v4: SOCKADDR_IN,'), (468, '    v6: SOCKADDR_IN6_LH,'), (469, '}'), (471, 'impl SocketAddrCRepr {'), (472, '    pub(crate) fn as_ptr(&self) -> *const SOCKADDR {'), (473, '        self as *const _ as *const SOCKADDR'), (474, '    }'), (475, '}'), (477, 'fn socket_addr_to_ptrs(addr: &SocketAddr) -> (SocketAddrCRepr, c_int) {'), (479, '        SocketAddr::V4(ref a) => {'), (480, '            let sin_addr = unsafe {'), (481, '                let mut s_un = mem::zeroed::<in_addr_S_un>();'), (482, '                *s_un.S_addr_mut() = u32::from_ne_bytes(a.ip().octets());'), (483, '                IN_ADDR { S_un: s_un }'), (484, '            };'), (486, '            let sockaddr_in = SOCKADDR_IN {'), (487, '                sin_family: AF_INET as ADDRESS_FAMILY,'), (488, '                sin_port: a.port().to_be(),'), (489, '                sin_addr,'), (490, '                sin_zero: [0; 8],'), (491, '            };'), (493, '            let sockaddr = SocketAddrCRepr { v4: sockaddr_in };'), (494, '            (sockaddr, mem::size_of::<SOCKADDR_IN>() as c_int)'), (495, '        }'), (496, '        SocketAddr::V6(ref a) => {'), (497, '            let sin6_addr = unsafe {'), (498, '                let mut u = mem::zeroed::<in6_addr_u>();'), (499, '                *u.Byte_mut() = a.ip().octets();'), (500, '                IN6_ADDR { u }'), (501, '            };'), (502, '            let u = unsafe {'), (503, '                let mut u = mem::zeroed::<SOCKADDR_IN6_LH_u>();'), (504, '                *u.sin6_scope_id_mut() = a.scope_id();'), (505, '                u'), (506, '            };'), (508, '            let sockaddr_in6 = SOCKADDR_IN6_LH {'), (509, '                sin6_family: AF_INET6 as ADDRESS_FAMILY,'), (510, '                sin6_port: a.port().to_be(),'), (511, '                sin6_addr,'), (512, '                sin6_flowinfo: a.flowinfo(),'), (513, '                u,'), (514, '            };'), (516, '            let sockaddr = SocketAddrCRepr { v6: sockaddr_in6 };'), (517, '            (sockaddr, mem::size_of::<SOCKADDR_IN6_LH>() as c_int)'), (518, '        }'), (703, '        addr_buf.as_ptr(),'), (776, '            addr_buf.as_ptr() as *const _,')], 'deleted': [(459, 'fn socket_addr_to_ptrs(addr: &SocketAddr) -> (*const SOCKADDR, c_int) {'), (461, '        SocketAddr::V4(ref a) => ('), (462, '            a as *const _ as *const _,'), (463, '            mem::size_of::<SOCKADDR_IN>() as c_int,'), (464, '        ),'), (465, '        SocketAddr::V6(ref a) => ('), (466, '            a as *const _ as *const _,'), (467, '            mem::size_of::<SOCKADDR_IN6_LH>() as c_int,'), (468, '        ),'), (653, '        addr_buf,'), (726, '            addr_buf as *const _,')]}",
    "num_lines_added": "51",
    "num_lines_deleted": "11",
    "nloc": "876"
  },
  {
    "file_change_id": "37361020136996",
    "hash": "2783715269d56a0020160179c0f2ba883d12d87",
    "old_path": "src/net.rs",
    "new_path": "src/net.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -13,6 +13,8 @@ use std::os::windows::prelude::*;\n \n use net2::TcpBuilder;\n use winapi::*;\n+use winapi::shared::inaddr::{in_addr_S_un, IN_ADDR};\n+use winapi::shared::in6addr::{in6_addr_u, IN6_ADDR};\n use ws2_32::*;\n \n /// A type to represent a buffer in which a socket address will be stored.\n@@ -478,13 +480,63 @@ fn cvt(i: c_int, size: DWORD) -> io::Result<Option<usize>> {\n     }\n }\n \n-fn socket_addr_to_ptrs(addr: &SocketAddr) -> (*const SOCKADDR, c_int) {\n+/// A type with the same memory layout as `SOCKADDR`. Used in converting Rust level\n+/// SocketAddr* types into their system representation. The benefit of this specific\n+/// type over using `SOCKADDR_STORAGE` is that this type is exactly as large as it\n+/// needs to be and not a lot larger. And it can be initialized cleaner from Rust.\n+#[repr(C)]\n+pub(crate) union SocketAddrCRepr {\n+    v4: SOCKADDR_IN,\n+    v6: SOCKADDR_IN6_LH,\n+}\n+\n+impl SocketAddrCRepr {\n+    pub(crate) fn as_ptr(&self) -> *const SOCKADDR {\n+        self as *const _ as *const SOCKADDR\n+    }\n+}\n+\n+fn socket_addr_to_ptrs(addr: &SocketAddr) -> (SocketAddrCRepr, c_int) {\n     match *addr {\n         SocketAddr::V4(ref a) => {\n-            (a as *const _ as *const _, mem::size_of::<SOCKADDR_IN>() as c_int)\n+            let sin_addr = unsafe {\n+                let mut s_un = mem::zeroed::<in_addr_S_un>();\n+                *s_un.S_addr_mut() = u32::from_ne_bytes(a.ip().octets());\n+                IN_ADDR { S_un: s_un }\n+            };\n+\n+            let sockaddr_in = SOCKADDR_IN {\n+                sin_family: AF_INET as ADDRESS_FAMILY,\n+                sin_port: a.port().to_be(),\n+                sin_addr,\n+                sin_zero: [0; 8],\n+            };\n+\n+            let sockaddr = SocketAddrCRepr { v4: sockaddr_in };\n+            (sockaddr, mem::size_of::<SOCKADDR_IN>() as c_int)\n         }\n         SocketAddr::V6(ref a) => {\n-            (a as *const _ as *const _, mem::size_of::<sockaddr_in6>() as c_int)\n+            let sin6_addr = unsafe {\n+                let mut u = mem::zeroed::<in6_addr_u>();\n+                *u.Byte_mut() = a.ip().octets();\n+                IN6_ADDR { u }\n+            };\n+            let u = unsafe {\n+                let mut u = mem::zeroed::<SOCKADDR_IN6_LH_u>();\n+                *u.sin6_scope_id_mut() = a.scope_id();\n+                u\n+            };\n+\n+            let sockaddr_in6 = SOCKADDR_IN6_LH {\n+                sin6_family: AF_INET6 as ADDRESS_FAMILY,\n+                sin6_port: a.port().to_be(),\n+                sin6_addr,\n+                sin6_flowinfo: a.flowinfo(),\n+                u,\n+            };\n+\n+            let sockaddr = SocketAddrCRepr { v6: sockaddr_in6 };\n+            (sockaddr, mem::size_of::<SOCKADDR_IN6_LH>() as c_int)\n         }\n     }\n }\n@@ -643,7 +695,7 @@ unsafe fn connect_overlapped(socket: SOCKET,\n \n     let (addr_buf, addr_len) = socket_addr_to_ptrs(addr);\n     let mut bytes_sent: DWORD = 0;\n-    let r = connect_ex(socket, addr_buf, addr_len,\n+    let r = connect_ex(socket, addr_buf.as_ptr(), addr_len,\n                        buf.as_ptr() as *mut _,\n                        buf.len() as u32,\n                        &mut bytes_sent, overlapped);\n@@ -694,7 +746,7 @@ impl UdpSocketExt for UdpSocket {\n         let mut sent_bytes = 0;\n         let r = WSASendTo(self.as_raw_socket(), &mut buf, 1,\n                           &mut sent_bytes, 0,\n-                          addr_buf as *const _, addr_len,\n+                          addr_buf.as_ptr() as *const _, addr_len,\n                           overlapped, None);\n         cvt(r, sent_bytes)\n     }\n",
    "diff_parsed": "{'added': [(16, 'use winapi::shared::inaddr::{in_addr_S_un, IN_ADDR};'), (17, 'use winapi::shared::in6addr::{in6_addr_u, IN6_ADDR};'), (487, '#[repr(C)]'), (488, 'pub(crate) union SocketAddrCRepr {'), (489, '    v4: SOCKADDR_IN,'), (490, '    v6: SOCKADDR_IN6_LH,'), (491, '}'), (493, 'impl SocketAddrCRepr {'), (494, '    pub(crate) fn as_ptr(&self) -> *const SOCKADDR {'), (495, '        self as *const _ as *const SOCKADDR'), (496, '    }'), (497, '}'), (499, 'fn socket_addr_to_ptrs(addr: &SocketAddr) -> (SocketAddrCRepr, c_int) {'), (502, '            let sin_addr = unsafe {'), (503, '                let mut s_un = mem::zeroed::<in_addr_S_un>();'), (504, '                *s_un.S_addr_mut() = u32::from_ne_bytes(a.ip().octets());'), (505, '                IN_ADDR { S_un: s_un }'), (506, '            };'), (508, '            let sockaddr_in = SOCKADDR_IN {'), (509, '                sin_family: AF_INET as ADDRESS_FAMILY,'), (510, '                sin_port: a.port().to_be(),'), (511, '                sin_addr,'), (512, '                sin_zero: [0; 8],'), (513, '            };'), (515, '            let sockaddr = SocketAddrCRepr { v4: sockaddr_in };'), (516, '            (sockaddr, mem::size_of::<SOCKADDR_IN>() as c_int)'), (519, '            let sin6_addr = unsafe {'), (520, '                let mut u = mem::zeroed::<in6_addr_u>();'), (521, '                *u.Byte_mut() = a.ip().octets();'), (522, '                IN6_ADDR { u }'), (523, '            };'), (524, '            let u = unsafe {'), (525, '                let mut u = mem::zeroed::<SOCKADDR_IN6_LH_u>();'), (526, '                *u.sin6_scope_id_mut() = a.scope_id();'), (527, '                u'), (528, '            };'), (530, '            let sockaddr_in6 = SOCKADDR_IN6_LH {'), (531, '                sin6_family: AF_INET6 as ADDRESS_FAMILY,'), (532, '                sin6_port: a.port().to_be(),'), (533, '                sin6_addr,'), (534, '                sin6_flowinfo: a.flowinfo(),'), (535, '                u,'), (536, '            };'), (538, '            let sockaddr = SocketAddrCRepr { v6: sockaddr_in6 };'), (539, '            (sockaddr, mem::size_of::<SOCKADDR_IN6_LH>() as c_int)'), (698, '    let r = connect_ex(socket, addr_buf.as_ptr(), addr_len,'), (749, '                          addr_buf.as_ptr() as *const _, addr_len,')], 'deleted': [(481, 'fn socket_addr_to_ptrs(addr: &SocketAddr) -> (*const SOCKADDR, c_int) {'), (484, '            (a as *const _ as *const _, mem::size_of::<SOCKADDR_IN>() as c_int)'), (487, '            (a as *const _ as *const _, mem::size_of::<sockaddr_in6>() as c_int)'), (646, '    let r = connect_ex(socket, addr_buf, addr_len,'), (697, '                          addr_buf as *const _, addr_len,')]}",
    "num_lines_added": "47",
    "num_lines_deleted": "5",
    "nloc": "758"
  },
  {
    "file_change_id": "223760793440148",
    "hash": "27b77cc870b922d305015841978b581ceb18e3b",
    "old_path": "src/net.rs",
    "new_path": "src/net.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -13,8 +13,9 @@ use std::os::windows::prelude::*;\n \n use net2::TcpBuilder;\n use winapi::*;\n-use winapi::shared::inaddr::{in_addr_S_un, IN_ADDR};\n-use winapi::shared::in6addr::{in6_addr_u, IN6_ADDR};\n+use winapi::inaddr::IN_ADDR;\n+use winapi::ws2def::SOCKADDR_IN;\n+use winapi::ws2ipdef::{in6_addr, sockaddr_in6};\n use ws2_32::*;\n \n /// A type to represent a buffer in which a socket address will be stored.\n@@ -487,7 +488,7 @@ fn cvt(i: c_int, size: DWORD) -> io::Result<Option<usize>> {\n #[repr(C)]\n pub(crate) union SocketAddrCRepr {\n     v4: SOCKADDR_IN,\n-    v6: SOCKADDR_IN6_LH,\n+    v6: sockaddr_in6,\n }\n \n impl SocketAddrCRepr {\n@@ -499,16 +500,10 @@ impl SocketAddrCRepr {\n fn socket_addr_to_ptrs(addr: &SocketAddr) -> (SocketAddrCRepr, c_int) {\n     match *addr {\n         SocketAddr::V4(ref a) => {\n-            let sin_addr = unsafe {\n-                let mut s_un = mem::zeroed::<in_addr_S_un>();\n-                *s_un.S_addr_mut() = u32::from_ne_bytes(a.ip().octets());\n-                IN_ADDR { S_un: s_un }\n-            };\n-\n             let sockaddr_in = SOCKADDR_IN {\n                 sin_family: AF_INET as ADDRESS_FAMILY,\n                 sin_port: a.port().to_be(),\n-                sin_addr,\n+                sin_addr: IN_ADDR { S_un: u32::from_ne_bytes(a.ip().octets()) },\n                 sin_zero: [0; 8],\n             };\n \n@@ -516,27 +511,16 @@ fn socket_addr_to_ptrs(addr: &SocketAddr) -> (SocketAddrCRepr, c_int) {\n             (sockaddr, mem::size_of::<SOCKADDR_IN>() as c_int)\n         }\n         SocketAddr::V6(ref a) => {\n-            let sin6_addr = unsafe {\n-                let mut u = mem::zeroed::<in6_addr_u>();\n-                *u.Byte_mut() = a.ip().octets();\n-                IN6_ADDR { u }\n-            };\n-            let u = unsafe {\n-                let mut u = mem::zeroed::<SOCKADDR_IN6_LH_u>();\n-                *u.sin6_scope_id_mut() = a.scope_id();\n-                u\n-            };\n-\n-            let sockaddr_in6 = SOCKADDR_IN6_LH {\n-                sin6_family: AF_INET6 as ADDRESS_FAMILY,\n+            let sockaddr_in6 = sockaddr_in6 {\n+                sin6_family: AF_INET6 as i16,\n                 sin6_port: a.port().to_be(),\n-                sin6_addr,\n+                sin6_addr: in6_addr { s6_addr: a.ip().octets() },\n                 sin6_flowinfo: a.flowinfo(),\n-                u,\n+                sin6_scope_id: a.scope_id(),\n             };\n \n             let sockaddr = SocketAddrCRepr { v6: sockaddr_in6 };\n-            (sockaddr, mem::size_of::<SOCKADDR_IN6_LH>() as c_int)\n+            (sockaddr, mem::size_of::<sockaddr_in6>() as c_int)\n         }\n     }\n }\n",
    "diff_parsed": "{'added': [(16, 'use winapi::inaddr::IN_ADDR;'), (17, 'use winapi::ws2def::SOCKADDR_IN;'), (18, 'use winapi::ws2ipdef::{in6_addr, sockaddr_in6};'), (491, '    v6: sockaddr_in6,'), (506, '                sin_addr: IN_ADDR { S_un: u32::from_ne_bytes(a.ip().octets()) },'), (514, '            let sockaddr_in6 = sockaddr_in6 {'), (515, '                sin6_family: AF_INET6 as i16,'), (517, '                sin6_addr: in6_addr { s6_addr: a.ip().octets() },'), (519, '                sin6_scope_id: a.scope_id(),'), (523, '            (sockaddr, mem::size_of::<sockaddr_in6>() as c_int)')], 'deleted': [(16, 'use winapi::shared::inaddr::{in_addr_S_un, IN_ADDR};'), (17, 'use winapi::shared::in6addr::{in6_addr_u, IN6_ADDR};'), (490, '    v6: SOCKADDR_IN6_LH,'), (502, '            let sin_addr = unsafe {'), (503, '                let mut s_un = mem::zeroed::<in_addr_S_un>();'), (504, '                *s_un.S_addr_mut() = u32::from_ne_bytes(a.ip().octets());'), (505, '                IN_ADDR { S_un: s_un }'), (506, '            };'), (511, '                sin_addr,'), (519, '            let sin6_addr = unsafe {'), (520, '                let mut u = mem::zeroed::<in6_addr_u>();'), (521, '                *u.Byte_mut() = a.ip().octets();'), (522, '                IN6_ADDR { u }'), (523, '            };'), (524, '            let u = unsafe {'), (525, '                let mut u = mem::zeroed::<SOCKADDR_IN6_LH_u>();'), (526, '                *u.sin6_scope_id_mut() = a.scope_id();'), (527, '                u'), (528, '            };'), (530, '            let sockaddr_in6 = SOCKADDR_IN6_LH {'), (531, '                sin6_family: AF_INET6 as ADDRESS_FAMILY,'), (533, '                sin6_addr,'), (535, '                u,'), (539, '            (sockaddr, mem::size_of::<SOCKADDR_IN6_LH>() as c_int)')]}",
    "num_lines_added": "10",
    "num_lines_deleted": "24",
    "nloc": "744"
  },
  {
    "file_change_id": "18424682303891",
    "hash": "043d5f0e4200b9bafc083997cc7bbf2c1bef91d",
    "old_path": "src/windows/mod.rs",
    "new_path": "src/windows/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -6,7 +6,6 @@ use std::borrow::Cow;\n use std::char;\n use std::ffi::OsStr;\n use std::ffi::OsString;\n-use std::mem;\n use std::os::windows::ffi::OsStrExt;\n use std::os::windows::ffi::OsStringExt;\n \n@@ -17,6 +16,73 @@ use crate::OsStringBytes;\n #[allow(clippy::module_inception)]\n mod imp;\n \n+// UTF-8 ranges and tags for encoding characters\n+// From Rust's libcore/char/mod.rs\n+const TAG_CONT: u8 = 0b1000_0000;\n+const TAG_TWO_B: u8 = 0b1100_0000;\n+const TAG_THREE_B: u8 = 0b1110_0000;\n+const TAG_FOUR_B: u8 = 0b1111_0000;\n+const MAX_ONE_B: u32 = 0x80;\n+const MAX_TWO_B: u32 = 0x800;\n+const MAX_THREE_B: u32 = 0x10000;\n+\n+// From Rust's libcore/char/methods.rs (char::len_utf8)\n+fn len_wtf8(code: u32) -> usize {\n+    if code < MAX_ONE_B {\n+        1\n+    } else if code < MAX_TWO_B {\n+        2\n+    } else if code < MAX_THREE_B {\n+        3\n+    } else {\n+        4\n+    }\n+}\n+\n+// From Rust's libcore/char/methods.rs (char::encode_utf8)\n+fn encode_wtf8(code: u32, dst: &mut [u8]) -> &mut [u8] {\n+    let len = len_wtf8(code);\n+    match (len, &mut dst[..]) {\n+        (1, [a, ..]) => {\n+            *a = code as u8;\n+        }\n+        (2, [a, b, ..]) => {\n+            *a = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;\n+            *b = (code & 0x3F) as u8 | TAG_CONT;\n+        }\n+        (3, [a, b, c, ..]) => {\n+            *a = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;\n+            *b = (code >> 6 & 0x3F) as u8 | TAG_CONT;\n+            *c = (code & 0x3F) as u8 | TAG_CONT;\n+        }\n+        (4, [a, b, c, d, ..]) => {\n+            *a = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;\n+            *b = (code >> 12 & 0x3F) as u8 | TAG_CONT;\n+            *c = (code >> 6 & 0x3F) as u8 | TAG_CONT;\n+            *d = (code & 0x3F) as u8 | TAG_CONT;\n+        }\n+        _ => unreachable!(),\n+    };\n+    &mut dst[..len]\n+}\n+\n+// From Rust's libcore/char/methods.rs (char::encode_utf16)\n+fn encode_wide(mut code: u32, dst: &mut [u16]) -> &mut [u16] {\n+    if (code & 0xFFFF) == code && !dst.is_empty() {\n+        // The BMP falls through (assuming non-surrogate, as it should)\n+        dst[0] = code as u16;\n+        &mut dst[..1]\n+    } else if dst.len() >= 2 {\n+        // Supplementary planes break into surrogates.\n+        code -= 0x1_0000;\n+        dst[0] = 0xD800 | ((code >> 10) as u16);\n+        dst[1] = 0xDC00 | ((code as u16) & 0x3FF);\n+        dst\n+    } else {\n+        unreachable!()\n+    }\n+}\n+\n fn wide_to_wtf8<TString>(encoded_string: TString, length: usize) -> Vec<u8>\n where\n     TString: IntoIterator<Item = u16>,\n@@ -24,17 +90,12 @@ where\n     // https://github.com/rust-lang/rust/blob/49c68bd53f90e375bfb3cbba8c1c67a9e0adb9c0/src/libstd/sys_common/wtf8.rs#L183-L199\n \n     let mut string = Vec::with_capacity(length);\n-    let mut buffer = [0; mem::size_of::<char>()];\n+    let mut buffer = [0; 4];\n     for ch in char::decode_utf16(encoded_string) {\n-        let unchecked_char = ch.unwrap_or_else(|surrogate| {\n-            let surrogate = surrogate.unpaired_surrogate().into();\n-            debug_assert!(surrogate <= u32::from(char::MAX));\n-            // SAFETY: https://docs.rs/os_str_bytes/#safety\n-            unsafe { char::from_u32_unchecked(surrogate) }\n-        });\n-        string.extend_from_slice(\n-            unchecked_char.encode_utf8(&mut buffer).as_bytes(),\n-        );\n+        let ch = ch\n+            .map(u32::from)\n+            .unwrap_or_else(|surrogate| surrogate.unpaired_surrogate().into());\n+        string.extend_from_slice(encode_wtf8(ch, &mut buffer));\n     }\n     debug_assert_eq!(string.len(), length);\n     string\n@@ -47,11 +108,7 @@ fn wtf8_to_wide(string: &[u8]) -> Vec<u16> {\n     let mut encoded_string = Vec::new();\n     let mut buffer = [0; 2];\n     while let Some(code_point) = imp::next_code_point(&mut string) {\n-        debug_assert!(code_point <= u32::from(char::MAX));\n-        // SAFETY: https://docs.rs/os_str_bytes/#safety\n-        let unchecked_char = unsafe { char::from_u32_unchecked(code_point) };\n-        encoded_string\n-            .extend_from_slice(unchecked_char.encode_utf16(&mut buffer));\n+        encoded_string.extend_from_slice(encode_wide(code_point, &mut buffer));\n     }\n     encoded_string\n }\n",
    "diff_parsed": "{'added': [(21, 'const TAG_CONT: u8 = 0b1000_0000;'), (22, 'const TAG_TWO_B: u8 = 0b1100_0000;'), (23, 'const TAG_THREE_B: u8 = 0b1110_0000;'), (24, 'const TAG_FOUR_B: u8 = 0b1111_0000;'), (25, 'const MAX_ONE_B: u32 = 0x80;'), (26, 'const MAX_TWO_B: u32 = 0x800;'), (27, 'const MAX_THREE_B: u32 = 0x10000;'), (30, 'fn len_wtf8(code: u32) -> usize {'), (31, '    if code < MAX_ONE_B {'), (32, '        1'), (33, '    } else if code < MAX_TWO_B {'), (34, '        2'), (35, '    } else if code < MAX_THREE_B {'), (36, '        3'), (37, '    } else {'), (38, '        4'), (39, '    }'), (40, '}'), (43, 'fn encode_wtf8(code: u32, dst: &mut [u8]) -> &mut [u8] {'), (44, '    let len = len_wtf8(code);'), (45, '    match (len, &mut dst[..]) {'), (46, '        (1, [a, ..]) => {'), (47, '            *a = code as u8;'), (48, '        }'), (49, '        (2, [a, b, ..]) => {'), (50, '            *a = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;'), (51, '            *b = (code & 0x3F) as u8 | TAG_CONT;'), (52, '        }'), (53, '        (3, [a, b, c, ..]) => {'), (54, '            *a = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;'), (55, '            *b = (code >> 6 & 0x3F) as u8 | TAG_CONT;'), (56, '            *c = (code & 0x3F) as u8 | TAG_CONT;'), (57, '        }'), (58, '        (4, [a, b, c, d, ..]) => {'), (59, '            *a = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;'), (60, '            *b = (code >> 12 & 0x3F) as u8 | TAG_CONT;'), (61, '            *c = (code >> 6 & 0x3F) as u8 | TAG_CONT;'), (62, '            *d = (code & 0x3F) as u8 | TAG_CONT;'), (63, '        }'), (64, '        _ => unreachable!(),'), (65, '    };'), (66, '    &mut dst[..len]'), (67, '}'), (70, 'fn encode_wide(mut code: u32, dst: &mut [u16]) -> &mut [u16] {'), (71, '    if (code & 0xFFFF) == code && !dst.is_empty() {'), (73, '        dst[0] = code as u16;'), (74, '        &mut dst[..1]'), (75, '    } else if dst.len() >= 2 {'), (77, '        code -= 0x1_0000;'), (78, '        dst[0] = 0xD800 | ((code >> 10) as u16);'), (79, '        dst[1] = 0xDC00 | ((code as u16) & 0x3FF);'), (80, '        dst'), (81, '    } else {'), (82, '        unreachable!()'), (83, '    }'), (84, '}'), (93, '    let mut buffer = [0; 4];'), (95, '        let ch = ch'), (96, '            .map(u32::from)'), (97, '            .unwrap_or_else(|surrogate| surrogate.unpaired_surrogate().into());'), (98, '        string.extend_from_slice(encode_wtf8(ch, &mut buffer));'), (111, '        encoded_string.extend_from_slice(encode_wide(code_point, &mut buffer));')], 'deleted': [(9, 'use std::mem;'), (27, '    let mut buffer = [0; mem::size_of::<char>()];'), (29, '        let unchecked_char = ch.unwrap_or_else(|surrogate| {'), (30, '            let surrogate = surrogate.unpaired_surrogate().into();'), (31, '            debug_assert!(surrogate <= u32::from(char::MAX));'), (33, '            unsafe { char::from_u32_unchecked(surrogate) }'), (34, '        });'), (35, '        string.extend_from_slice('), (36, '            unchecked_char.encode_utf8(&mut buffer).as_bytes(),'), (37, '        );'), (50, '        debug_assert!(code_point <= u32::from(char::MAX));'), (52, '        let unchecked_char = unsafe { char::from_u32_unchecked(code_point) };'), (53, '        encoded_string'), (54, '            .extend_from_slice(unchecked_char.encode_utf16(&mut buffer));')]}",
    "num_lines_added": "62",
    "num_lines_deleted": "14",
    "nloc": "167"
  },
  {
    "file_change_id": "16686109075669",
    "hash": "fd4bd03686c476efcc9d758e234f0bdf1732e7d",
    "old_path": "src/windows/mod.rs",
    "new_path": "src/windows/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -42,24 +42,24 @@ fn len_wtf8(code: u32) -> usize {\n // From Rust's libcore/char/methods.rs (char::encode_utf8)\n fn encode_wtf8(code: u32, dst: &mut [u8]) -> &mut [u8] {\n     let len = len_wtf8(code);\n-    match (len, &mut dst[..]) {\n-        (1, [a, ..]) => {\n-            *a = code as u8;\n+    match len {\n+        1 => {\n+            dst[0] = code as u8;\n         }\n-        (2, [a, b, ..]) => {\n-            *a = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;\n-            *b = (code & 0x3F) as u8 | TAG_CONT;\n+        2 => {\n+            dst[0] = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;\n+            dst[1] = (code & 0x3F) as u8 | TAG_CONT;\n         }\n-        (3, [a, b, c, ..]) => {\n-            *a = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;\n-            *b = (code >> 6 & 0x3F) as u8 | TAG_CONT;\n-            *c = (code & 0x3F) as u8 | TAG_CONT;\n+        3 => {\n+            dst[0] = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;\n+            dst[1] = (code >> 6 & 0x3F) as u8 | TAG_CONT;\n+            dst[2] = (code & 0x3F) as u8 | TAG_CONT;\n         }\n-        (4, [a, b, c, d, ..]) => {\n-            *a = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;\n-            *b = (code >> 12 & 0x3F) as u8 | TAG_CONT;\n-            *c = (code >> 6 & 0x3F) as u8 | TAG_CONT;\n-            *d = (code & 0x3F) as u8 | TAG_CONT;\n+        4 => {\n+            dst[0] = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;\n+            dst[1] = (code >> 12 & 0x3F) as u8 | TAG_CONT;\n+            dst[2] = (code >> 6 & 0x3F) as u8 | TAG_CONT;\n+            dst[3] = (code & 0x3F) as u8 | TAG_CONT;\n         }\n         _ => unreachable!(),\n     };\n",
    "diff_parsed": "{'added': [(45, '    match len {'), (46, '        1 => {'), (47, '            dst[0] = code as u8;'), (49, '        2 => {'), (50, '            dst[0] = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;'), (51, '            dst[1] = (code & 0x3F) as u8 | TAG_CONT;'), (53, '        3 => {'), (54, '            dst[0] = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;'), (55, '            dst[1] = (code >> 6 & 0x3F) as u8 | TAG_CONT;'), (56, '            dst[2] = (code & 0x3F) as u8 | TAG_CONT;'), (58, '        4 => {'), (59, '            dst[0] = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;'), (60, '            dst[1] = (code >> 12 & 0x3F) as u8 | TAG_CONT;'), (61, '            dst[2] = (code >> 6 & 0x3F) as u8 | TAG_CONT;'), (62, '            dst[3] = (code & 0x3F) as u8 | TAG_CONT;')], 'deleted': [(45, '    match (len, &mut dst[..]) {'), (46, '        (1, [a, ..]) => {'), (47, '            *a = code as u8;'), (49, '        (2, [a, b, ..]) => {'), (50, '            *a = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;'), (51, '            *b = (code & 0x3F) as u8 | TAG_CONT;'), (53, '        (3, [a, b, c, ..]) => {'), (54, '            *a = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;'), (55, '            *b = (code >> 6 & 0x3F) as u8 | TAG_CONT;'), (56, '            *c = (code & 0x3F) as u8 | TAG_CONT;'), (58, '        (4, [a, b, c, d, ..]) => {'), (59, '            *a = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;'), (60, '            *b = (code >> 12 & 0x3F) as u8 | TAG_CONT;'), (61, '            *c = (code >> 6 & 0x3F) as u8 | TAG_CONT;'), (62, '            *d = (code & 0x3F) as u8 | TAG_CONT;')]}",
    "num_lines_added": "15",
    "num_lines_deleted": "15",
    "nloc": "167"
  },
  {
    "file_change_id": "90711501340222",
    "hash": "4dd2832d0e4bd0253ea77dd15bcd95ea171bfee",
    "old_path": "cli/tests/integration/run_tests.rs",
    "new_path": "cli/tests/integration/run_tests.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -2523,3 +2523,93 @@ itest!(fetch_async_error_stack {\n   output: \"fetch_async_error_stack.ts.out\",\n   exit_code: 1,\n });\n+\n+itest!(unstable_ffi_1 {\n+  args: \"run unstable_ffi_1.js\",\n+  output: \"unstable_ffi_1.js.out\",\n+  exit_code: 70,\n+});\n+\n+itest!(unstable_ffi_2 {\n+  args: \"run unstable_ffi_2.js\",\n+  output: \"unstable_ffi_2.js.out\",\n+  exit_code: 70,\n+});\n+\n+itest!(unstable_ffi_3 {\n+  args: \"run unstable_ffi_3.js\",\n+  output: \"unstable_ffi_3.js.out\",\n+  exit_code: 70,\n+});\n+\n+itest!(unstable_ffi_4 {\n+  args: \"run unstable_ffi_4.js\",\n+  output: \"unstable_ffi_4.js.out\",\n+  exit_code: 70,\n+});\n+\n+itest!(unstable_ffi_5 {\n+  args: \"run unstable_ffi_5.js\",\n+  output: \"unstable_ffi_5.js.out\",\n+  exit_code: 70,\n+});\n+\n+itest!(unstable_ffi_6 {\n+  args: \"run unstable_ffi_6.js\",\n+  output: \"unstable_ffi_6.js.out\",\n+  exit_code: 70,\n+});\n+\n+itest!(unstable_ffi_7 {\n+  args: \"run unstable_ffi_7.js\",\n+  output: \"unstable_ffi_7.js.out\",\n+  exit_code: 70,\n+});\n+\n+itest!(unstable_ffi_8 {\n+  args: \"run unstable_ffi_8.js\",\n+  output: \"unstable_ffi_8.js.out\",\n+  exit_code: 70,\n+});\n+\n+itest!(unstable_ffi_9 {\n+  args: \"run unstable_ffi_9.js\",\n+  output: \"unstable_ffi_9.js.out\",\n+  exit_code: 70,\n+});\n+\n+itest!(unstable_ffi_10 {\n+  args: \"run unstable_ffi_10.js\",\n+  output: \"unstable_ffi_10.js.out\",\n+  exit_code: 70,\n+});\n+\n+itest!(unstable_ffi_11 {\n+  args: \"run unstable_ffi_11.js\",\n+  output: \"unstable_ffi_11.js.out\",\n+  exit_code: 70,\n+});\n+\n+itest!(unstable_ffi_12 {\n+  args: \"run unstable_ffi_12.js\",\n+  output: \"unstable_ffi_12.js.out\",\n+  exit_code: 70,\n+});\n+\n+itest!(unstable_ffi_13 {\n+  args: \"run unstable_ffi_13.js\",\n+  output: \"unstable_ffi_13.js.out\",\n+  exit_code: 70,\n+});\n+\n+itest!(unstable_ffi_14 {\n+  args: \"run unstable_ffi_14.js\",\n+  output: \"unstable_ffi_14.js.out\",\n+  exit_code: 70,\n+});\n+\n+itest!(unstable_ffi_15 {\n+  args: \"run unstable_ffi_15.js\",\n+  output: \"unstable_ffi_15.js.out\",\n+  exit_code: 70,\n+});\n",
    "diff_parsed": "{'added': [(2527, 'itest!(unstable_ffi_1 {'), (2528, '  args: \"run unstable_ffi_1.js\",'), (2529, '  output: \"unstable_ffi_1.js.out\",'), (2530, '  exit_code: 70,'), (2531, '});'), (2533, 'itest!(unstable_ffi_2 {'), (2534, '  args: \"run unstable_ffi_2.js\",'), (2535, '  output: \"unstable_ffi_2.js.out\",'), (2536, '  exit_code: 70,'), (2537, '});'), (2539, 'itest!(unstable_ffi_3 {'), (2540, '  args: \"run unstable_ffi_3.js\",'), (2541, '  output: \"unstable_ffi_3.js.out\",'), (2542, '  exit_code: 70,'), (2543, '});'), (2545, 'itest!(unstable_ffi_4 {'), (2546, '  args: \"run unstable_ffi_4.js\",'), (2547, '  output: \"unstable_ffi_4.js.out\",'), (2548, '  exit_code: 70,'), (2549, '});'), (2551, 'itest!(unstable_ffi_5 {'), (2552, '  args: \"run unstable_ffi_5.js\",'), (2553, '  output: \"unstable_ffi_5.js.out\",'), (2554, '  exit_code: 70,'), (2555, '});'), (2557, 'itest!(unstable_ffi_6 {'), (2558, '  args: \"run unstable_ffi_6.js\",'), (2559, '  output: \"unstable_ffi_6.js.out\",'), (2560, '  exit_code: 70,'), (2561, '});'), (2563, 'itest!(unstable_ffi_7 {'), (2564, '  args: \"run unstable_ffi_7.js\",'), (2565, '  output: \"unstable_ffi_7.js.out\",'), (2566, '  exit_code: 70,'), (2567, '});'), (2569, 'itest!(unstable_ffi_8 {'), (2570, '  args: \"run unstable_ffi_8.js\",'), (2571, '  output: \"unstable_ffi_8.js.out\",'), (2572, '  exit_code: 70,'), (2573, '});'), (2575, 'itest!(unstable_ffi_9 {'), (2576, '  args: \"run unstable_ffi_9.js\",'), (2577, '  output: \"unstable_ffi_9.js.out\",'), (2578, '  exit_code: 70,'), (2579, '});'), (2581, 'itest!(unstable_ffi_10 {'), (2582, '  args: \"run unstable_ffi_10.js\",'), (2583, '  output: \"unstable_ffi_10.js.out\",'), (2584, '  exit_code: 70,'), (2585, '});'), (2587, 'itest!(unstable_ffi_11 {'), (2588, '  args: \"run unstable_ffi_11.js\",'), (2589, '  output: \"unstable_ffi_11.js.out\",'), (2590, '  exit_code: 70,'), (2591, '});'), (2593, 'itest!(unstable_ffi_12 {'), (2594, '  args: \"run unstable_ffi_12.js\",'), (2595, '  output: \"unstable_ffi_12.js.out\",'), (2596, '  exit_code: 70,'), (2597, '});'), (2599, 'itest!(unstable_ffi_13 {'), (2600, '  args: \"run unstable_ffi_13.js\",'), (2601, '  output: \"unstable_ffi_13.js.out\",'), (2602, '  exit_code: 70,'), (2603, '});'), (2605, 'itest!(unstable_ffi_14 {'), (2606, '  args: \"run unstable_ffi_14.js\",'), (2607, '  output: \"unstable_ffi_14.js.out\",'), (2608, '  exit_code: 70,'), (2609, '});'), (2611, 'itest!(unstable_ffi_15 {'), (2612, '  args: \"run unstable_ffi_15.js\",'), (2613, '  output: \"unstable_ffi_15.js.out\",'), (2614, '  exit_code: 70,'), (2615, '});')], 'deleted': []}",
    "num_lines_added": "75",
    "num_lines_deleted": "0",
    "nloc": "2180"
  },
  {
    "file_change_id": "97802331297173",
    "hash": "4dd2832d0e4bd0253ea77dd15bcd95ea171bfee",
    "old_path": "ext/ffi/lib.rs",
    "new_path": "ext/ffi/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -45,6 +45,11 @@ fn check_unstable(state: &OpState, api_name: &str) {\n   }\n }\n \n+pub fn check_unstable2(state: &Rc<RefCell<OpState>>, api_name: &str) {\n+  let state = state.borrow();\n+  check_unstable(&state, api_name)\n+}\n+\n pub trait FfiPermissions {\n   fn check(&mut self, path: Option<&Path>) -> Result<(), AnyError>;\n }\n@@ -144,8 +149,8 @@ pub fn init<P: FfiPermissions + 'static>(unstable: bool) -> Extension {\n       op_ffi_get_static::decl(),\n       op_ffi_call::decl(),\n       op_ffi_call_nonblocking::decl(),\n-      op_ffi_call_ptr::decl(),\n-      op_ffi_call_ptr_nonblocking::decl(),\n+      op_ffi_call_ptr::decl::<P>(),\n+      op_ffi_call_ptr_nonblocking::decl::<P>(),\n       op_ffi_ptr_of::decl::<P>(),\n       op_ffi_buf_copy_into::decl::<P>(),\n       op_ffi_cstr_read::decl::<P>(),\n@@ -648,15 +653,38 @@ fn ffi_call(args: FfiCallArgs, symbol: &Symbol) -> Result<Value, AnyError> {\n }\n \n #[op]\n-fn op_ffi_call_ptr(args: FfiCallPtrArgs) -> Result<Value, AnyError> {\n+fn op_ffi_call_ptr<FP>(\n+  state: &mut deno_core::OpState,\n+  args: FfiCallPtrArgs,\n+) -> Result<Value, AnyError>\n+where\n+  FP: FfiPermissions + 'static,\n+{\n+  check_unstable(state, \"Deno.UnsafeFnPointer#call\");\n+\n+  let permissions = state.borrow_mut::<FP>();\n+  permissions.check(None)?;\n+\n   let symbol = args.get_symbol();\n   ffi_call(args.into(), &symbol)\n }\n \n #[op]\n-async fn op_ffi_call_ptr_nonblocking(\n+async fn op_ffi_call_ptr_nonblocking<FP>(\n+  state: Rc<RefCell<deno_core::OpState>>,\n   args: FfiCallPtrArgs,\n-) -> Result<Value, AnyError> {\n+) -> Result<Value, AnyError>\n+where\n+  FP: FfiPermissions + 'static,\n+{\n+  check_unstable2(&state, \"Deno.UnsafeFnPointer#call\");\n+\n+  {\n+    let mut state = state.borrow_mut();\n+    let permissions = state.borrow_mut::<FP>();\n+    permissions.check(None)?;\n+  }\n+\n   let symbol = args.get_symbol();\n   tokio::task::spawn_blocking(move || ffi_call(args.into(), &symbol))\n     .await\n@@ -774,6 +802,8 @@ fn op_ffi_ptr_of<FP>(\n where\n   FP: FfiPermissions + 'static,\n {\n+  check_unstable(state, \"Deno.UnsafePointer#of\");\n+\n   let permissions = state.borrow_mut::<FP>();\n   permissions.check(None)?;\n \n@@ -788,6 +818,8 @@ fn op_ffi_buf_copy_into<FP>(\n where\n   FP: FfiPermissions + 'static,\n {\n+  check_unstable(state, \"Deno.UnsafePointerView#copyInto\");\n+\n   let permissions = state.borrow_mut::<FP>();\n   permissions.check(None)?;\n \n@@ -810,6 +842,8 @@ fn op_ffi_cstr_read<FP>(\n where\n   FP: FfiPermissions + 'static,\n {\n+  check_unstable(state, \"Deno.UnsafePointerView#getCString\");\n+\n   let permissions = state.borrow_mut::<FP>();\n   permissions.check(None)?;\n \n@@ -825,6 +859,8 @@ fn op_ffi_read_u8<FP>(\n where\n   FP: FfiPermissions + 'static,\n {\n+  check_unstable(state, \"Deno.UnsafePointerView#getUint8\");\n+\n   let permissions = state.borrow_mut::<FP>();\n   permissions.check(None)?;\n \n@@ -839,6 +875,8 @@ fn op_ffi_read_i8<FP>(\n where\n   FP: FfiPermissions + 'static,\n {\n+  check_unstable(state, \"Deno.UnsafePointerView#getInt8\");\n+\n   let permissions = state.borrow_mut::<FP>();\n   permissions.check(None)?;\n \n@@ -853,6 +891,8 @@ fn op_ffi_read_u16<FP>(\n where\n   FP: FfiPermissions + 'static,\n {\n+  check_unstable(state, \"Deno.UnsafePointerView#getUint16\");\n+\n   let permissions = state.borrow_mut::<FP>();\n   permissions.check(None)?;\n \n@@ -867,6 +907,8 @@ fn op_ffi_read_i16<FP>(\n where\n   FP: FfiPermissions + 'static,\n {\n+  check_unstable(state, \"Deno.UnsafePointerView#getInt16\");\n+\n   let permissions = state.borrow_mut::<FP>();\n   permissions.check(None)?;\n \n@@ -881,6 +923,8 @@ fn op_ffi_read_u32<FP>(\n where\n   FP: FfiPermissions + 'static,\n {\n+  check_unstable(state, \"Deno.UnsafePointerView#getUint32\");\n+\n   let permissions = state.borrow_mut::<FP>();\n   permissions.check(None)?;\n \n@@ -895,6 +939,8 @@ fn op_ffi_read_i32<FP>(\n where\n   FP: FfiPermissions + 'static,\n {\n+  check_unstable(state, \"Deno.UnsafePointerView#getInt32\");\n+\n   let permissions = state.borrow_mut::<FP>();\n   permissions.check(None)?;\n \n@@ -909,6 +955,8 @@ fn op_ffi_read_u64<FP>(\n where\n   FP: FfiPermissions + 'static,\n {\n+  check_unstable(state, \"Deno.UnsafePointerView#getBigUint64\");\n+\n   let permissions = state.borrow_mut::<FP>();\n   permissions.check(None)?;\n \n@@ -925,6 +973,8 @@ fn op_ffi_read_f32<FP>(\n where\n   FP: FfiPermissions + 'static,\n {\n+  check_unstable(state, \"Deno.UnsafePointerView#getFloat32\");\n+\n   let permissions = state.borrow_mut::<FP>();\n   permissions.check(None)?;\n \n@@ -939,6 +989,8 @@ fn op_ffi_read_f64<FP>(\n where\n   FP: FfiPermissions + 'static,\n {\n+  check_unstable(state, \"Deno.UnsafePointerView#getFloat64\");\n+\n   let permissions = state.borrow_mut::<FP>();\n   permissions.check(None)?;\n \n",
    "diff_parsed": "{'added': [(48, 'pub fn check_unstable2(state: &Rc<RefCell<OpState>>, api_name: &str) {'), (49, '  let state = state.borrow();'), (50, '  check_unstable(&state, api_name)'), (51, '}'), (152, '      op_ffi_call_ptr::decl::<P>(),'), (153, '      op_ffi_call_ptr_nonblocking::decl::<P>(),'), (656, 'fn op_ffi_call_ptr<FP>('), (657, '  state: &mut deno_core::OpState,'), (658, '  args: FfiCallPtrArgs,'), (659, ') -> Result<Value, AnyError>'), (660, 'where'), (661, \"  FP: FfiPermissions + 'static,\"), (662, '{'), (663, '  check_unstable(state, \"Deno.UnsafeFnPointer#call\");'), (665, '  let permissions = state.borrow_mut::<FP>();'), (666, '  permissions.check(None)?;'), (673, 'async fn op_ffi_call_ptr_nonblocking<FP>('), (674, '  state: Rc<RefCell<deno_core::OpState>>,'), (676, ') -> Result<Value, AnyError>'), (677, 'where'), (678, \"  FP: FfiPermissions + 'static,\"), (679, '{'), (680, '  check_unstable2(&state, \"Deno.UnsafeFnPointer#call\");'), (682, '  {'), (683, '    let mut state = state.borrow_mut();'), (684, '    let permissions = state.borrow_mut::<FP>();'), (685, '    permissions.check(None)?;'), (686, '  }'), (805, '  check_unstable(state, \"Deno.UnsafePointer#of\");'), (821, '  check_unstable(state, \"Deno.UnsafePointerView#copyInto\");'), (845, '  check_unstable(state, \"Deno.UnsafePointerView#getCString\");'), (862, '  check_unstable(state, \"Deno.UnsafePointerView#getUint8\");'), (878, '  check_unstable(state, \"Deno.UnsafePointerView#getInt8\");'), (894, '  check_unstable(state, \"Deno.UnsafePointerView#getUint16\");'), (910, '  check_unstable(state, \"Deno.UnsafePointerView#getInt16\");'), (926, '  check_unstable(state, \"Deno.UnsafePointerView#getUint32\");'), (942, '  check_unstable(state, \"Deno.UnsafePointerView#getInt32\");'), (958, '  check_unstable(state, \"Deno.UnsafePointerView#getBigUint64\");'), (976, '  check_unstable(state, \"Deno.UnsafePointerView#getFloat32\");'), (992, '  check_unstable(state, \"Deno.UnsafePointerView#getFloat64\");')], 'deleted': [(147, '      op_ffi_call_ptr::decl(),'), (148, '      op_ffi_call_ptr_nonblocking::decl(),'), (651, 'fn op_ffi_call_ptr(args: FfiCallPtrArgs) -> Result<Value, AnyError> {'), (657, 'async fn op_ffi_call_ptr_nonblocking('), (659, ') -> Result<Value, AnyError> {')]}",
    "num_lines_added": "40",
    "num_lines_deleted": "5",
    "nloc": "941"
  },
  {
    "file_change_id": "47276049897552",
    "hash": "9340c55139dc0baaa19df3c3a75c4e46836eda33",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -458,7 +458,7 @@ impl core::fmt::LowerHex for SecretKey {\n }\n \n impl Signature {\n-    pub fn parse(p: &[u8; util::SIGNATURE_SIZE]) -> Signature {\n+    pub fn parse_overflowing(p: &[u8; util::SIGNATURE_SIZE]) -> Signature {\n         let mut r = Scalar::default();\n         let mut s = Scalar::default();\n \n@@ -469,14 +469,39 @@ impl Signature {\n         Signature { r, s }\n     }\n \n-    pub fn parse_slice(p: &[u8]) -> Result<Signature, Error> {\n+    pub fn parse_standard(p: &[u8; util::SIGNATURE_SIZE]) -> Result<Signature, Error> {\n+        let mut r = Scalar::default();\n+        let mut s = Scalar::default();\n+\n+        // Okay for signature to overflow\n+        let overflowed_r = r.set_b32(array_ref!(p, 0, 32));\n+        let overflowed_s = s.set_b32(array_ref!(p, 32, 32));\n+\n+        if bool::from(overflowed_r | overflowed_s) {\n+            return Err(Error::InvalidSignature)\n+        }\n+\n+        Ok(Signature { r, s })\n+    }\n+\n+    pub fn parse_overflowing_slice(p: &[u8]) -> Result<Signature, Error> {\n         if p.len() != util::SIGNATURE_SIZE {\n             return Err(Error::InvalidInputLength);\n         }\n \n         let mut a = [0; util::SIGNATURE_SIZE];\n         a.copy_from_slice(p);\n-        Ok(Self::parse(&a))\n+        Ok(Self::parse_overflowing(&a))\n+    }\n+\n+    pub fn parse_standard_slice(p: &[u8]) -> Result<Signature, Error> {\n+        if p.len() != util::SIGNATURE_SIZE {\n+            return Err(Error::InvalidInputLength);\n+        }\n+\n+        let mut a = [0; util::SIGNATURE_SIZE];\n+        a.copy_from_slice(p);\n+        Ok(Self::parse_standard(&a)?)\n     }\n \n     pub fn parse_der(p: &[u8]) -> Result<Signature, Error> {\n",
    "diff_parsed": "{'added': [(461, '    pub fn parse_overflowing(p: &[u8; util::SIGNATURE_SIZE]) -> Signature {'), (472, '    pub fn parse_standard(p: &[u8; util::SIGNATURE_SIZE]) -> Result<Signature, Error> {'), (473, '        let mut r = Scalar::default();'), (474, '        let mut s = Scalar::default();'), (477, '        let overflowed_r = r.set_b32(array_ref!(p, 0, 32));'), (478, '        let overflowed_s = s.set_b32(array_ref!(p, 32, 32));'), (480, '        if bool::from(overflowed_r | overflowed_s) {'), (481, '            return Err(Error::InvalidSignature)'), (482, '        }'), (484, '        Ok(Signature { r, s })'), (485, '    }'), (487, '    pub fn parse_overflowing_slice(p: &[u8]) -> Result<Signature, Error> {'), (494, '        Ok(Self::parse_overflowing(&a))'), (495, '    }'), (497, '    pub fn parse_standard_slice(p: &[u8]) -> Result<Signature, Error> {'), (498, '        if p.len() != util::SIGNATURE_SIZE {'), (499, '            return Err(Error::InvalidInputLength);'), (500, '        }'), (502, '        let mut a = [0; util::SIGNATURE_SIZE];'), (503, '        a.copy_from_slice(p);'), (504, '        Ok(Self::parse_standard(&a)?)')], 'deleted': [(461, '    pub fn parse(p: &[u8; util::SIGNATURE_SIZE]) -> Signature {'), (472, '    pub fn parse_slice(p: &[u8]) -> Result<Signature, Error> {'), (479, '        Ok(Self::parse(&a))')]}",
    "num_lines_added": "21",
    "num_lines_deleted": "3",
    "nloc": "642"
  },
  {
    "file_change_id": "199646279025064",
    "hash": "5d3207830790420468b1e4f88d6a607df9e3379",
    "old_path": "actix-service/src/and_then.rs",
    "new_path": "actix-service/src/and_then.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,16 +1,17 @@\n use std::future::Future;\n use std::pin::Pin;\n use std::rc::Rc;\n+use std::cell::RefCell;\n use std::task::{Context, Poll};\n \n use super::{Service, ServiceFactory};\n-use crate::cell::Cell;\n+\n \n /// Service for the `and_then` combinator, chaining a computation onto the end\n /// of another service which completes successfully.\n ///\n /// This is created by the `ServiceExt::and_then` method.\n-pub(crate) struct AndThenService<A, B>(Cell<(A, B)>);\n+pub(crate) struct AndThenService<A, B>(Rc<RefCell<(A, B)>>);\n \n impl<A, B> AndThenService<A, B> {\n     /// Create new `AndThen` combinator\n@@ -19,7 +20,7 @@ impl<A, B> AndThenService<A, B> {\n         A: Service,\n         B: Service<Request = A::Response, Error = A::Error>,\n     {\n-        Self(Cell::new((a, b)))\n+        Self(Rc::new(RefCell::new((a, b))))\n     }\n }\n \n@@ -40,7 +41,7 @@ where\n     type Future = AndThenServiceResponse<A, B>;\n \n     fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {\n-        let srv = self.0.get_mut();\n+        let mut srv = self.0.borrow_mut();\n         let not_ready = !srv.0.poll_ready(cx)?.is_ready();\n         if !srv.1.poll_ready(cx)?.is_ready() || not_ready {\n             Poll::Pending\n@@ -51,7 +52,7 @@ where\n \n     fn call(&mut self, req: A::Request) -> Self::Future {\n         AndThenServiceResponse {\n-            state: State::A(self.0.get_mut().0.call(req), Some(self.0.clone())),\n+            state: State::A(self.0.borrow_mut().0.call(req), Some(self.0.clone())),\n         }\n     }\n }\n@@ -72,7 +73,7 @@ where\n     A: Service,\n     B: Service<Request = A::Response, Error = A::Error>,\n {\n-    A(#[pin] A::Future, Option<Cell<(A, B)>>),\n+    A(#[pin] A::Future, Option<Rc<RefCell<(A, B)>>>),\n     B(#[pin] B::Future),\n     Empty,\n }\n@@ -90,9 +91,9 @@ where\n         match this.state.as_mut().project() {\n             StateProj::A(fut, b) => match fut.poll(cx)? {\n                 Poll::Ready(res) => {\n-                    let mut b = b.take().unwrap();\n+                    let b = b.take().unwrap();\n                     this.state.set(State::Empty); // drop fut A\n-                    let fut = b.get_mut().1.call(res);\n+                    let fut = b.borrow_mut().1.call(res);\n                     this.state.set(State::B(fut));\n                     self.poll(cx)\n                 }\n",
    "diff_parsed": "{'added': [(4, 'use std::cell::RefCell;'), (14, 'pub(crate) struct AndThenService<A, B>(Rc<RefCell<(A, B)>>);'), (23, '        Self(Rc::new(RefCell::new((a, b))))'), (44, '        let mut srv = self.0.borrow_mut();'), (55, '            state: State::A(self.0.borrow_mut().0.call(req), Some(self.0.clone())),'), (76, '    A(#[pin] A::Future, Option<Rc<RefCell<(A, B)>>>),'), (94, '                    let b = b.take().unwrap();'), (96, '                    let fut = b.borrow_mut().1.call(res);')], 'deleted': [(7, 'use crate::cell::Cell;'), (13, 'pub(crate) struct AndThenService<A, B>(Cell<(A, B)>);'), (22, '        Self(Cell::new((a, b)))'), (43, '        let srv = self.0.get_mut();'), (54, '            state: State::A(self.0.get_mut().0.call(req), Some(self.0.clone())),'), (75, '    A(#[pin] A::Future, Option<Cell<(A, B)>>),'), (93, '                    let mut b = b.take().unwrap();'), (95, '                    let fut = b.get_mut().1.call(res);')]}",
    "num_lines_added": "8",
    "num_lines_deleted": "8",
    "nloc": "299.0"
  },
  {
    "file_change_id": "262723178701549",
    "hash": "5d3207830790420468b1e4f88d6a607df9e3379",
    "old_path": "actix-service/src/and_then_apply_fn.rs",
    "new_path": "actix-service/src/and_then_apply_fn.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -2,9 +2,9 @@ use std::future::Future;\n use std::marker::PhantomData;\n use std::pin::Pin;\n use std::rc::Rc;\n+use std::cell::RefCell;\n use std::task::{Context, Poll};\n \n-use crate::cell::Cell;\n use crate::{Service, ServiceFactory};\n \n /// `Apply` service combinator\n@@ -16,7 +16,7 @@ where\n     Fut: Future<Output = Result<Res, Err>>,\n     Err: From<A::Error> + From<B::Error>,\n {\n-    srv: Cell<(A, B, F)>,\n+    srv: Rc<RefCell<(A, B, F)>>,\n     r: PhantomData<(Fut, Res, Err)>,\n }\n \n@@ -31,7 +31,7 @@ where\n     /// Create new `Apply` combinator\n     pub(crate) fn new(a: A, b: B, f: F) -> Self {\n         Self {\n-            srv: Cell::new((a, b, f)),\n+            srv:  Rc::new(RefCell::new((a, b, f))),\n             r: PhantomData,\n         }\n     }\n@@ -67,7 +67,7 @@ where\n     type Future = AndThenApplyFnFuture<A, B, F, Fut, Res, Err>;\n \n     fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {\n-        let inner = self.srv.get_mut();\n+        let mut inner = self.srv.borrow_mut();\n         let not_ready = inner.0.poll_ready(cx)?.is_pending();\n         if inner.1.poll_ready(cx)?.is_pending() || not_ready {\n             Poll::Pending\n@@ -77,7 +77,7 @@ where\n     }\n \n     fn call(&mut self, req: A::Request) -> Self::Future {\n-        let fut = self.srv.get_mut().0.call(req);\n+        let fut = self.srv.borrow_mut().0.call(req);\n         AndThenApplyFnFuture {\n             state: State::A(fut, Some(self.srv.clone())),\n         }\n@@ -108,7 +108,7 @@ where\n     Err: From<A::Error>,\n     Err: From<B::Error>,\n {\n-    A(#[pin] A::Future, Option<Cell<(A, B, F)>>),\n+    A(#[pin] A::Future, Option<Rc<RefCell<(A, B, F)>>>),\n     B(#[pin] Fut),\n     Empty,\n }\n@@ -129,10 +129,10 @@ where\n         match this.state.as_mut().project() {\n             StateProj::A(fut, b) => match fut.poll(cx)? {\n                 Poll::Ready(res) => {\n-                    let mut b = b.take().unwrap();\n+                    let b = b.take().unwrap();\n                     this.state.set(State::Empty);\n-                    let b = b.get_mut();\n-                    let fut = (&mut b.2)(res, &mut b.1);\n+                    let (_, b, f) = &mut *b.borrow_mut();\n+                    let fut = f(res, b);\n                     this.state.set(State::B(fut));\n                     self.poll(cx)\n                 }\n@@ -255,11 +255,11 @@ where\n \n         if this.a.is_some() && this.b.is_some() {\n             Poll::Ready(Ok(AndThenApplyFn {\n-                srv: Cell::new((\n+                srv: Rc::new(RefCell::new((\n                     this.a.take().unwrap(),\n                     this.b.take().unwrap(),\n                     this.f.clone(),\n-                )),\n+                ))),\n                 r: PhantomData,\n             }))\n         } else {\n",
    "diff_parsed": "{'added': [(5, 'use std::cell::RefCell;'), (19, '    srv: Rc<RefCell<(A, B, F)>>,'), (34, '            srv:  Rc::new(RefCell::new((a, b, f))),'), (70, '        let mut inner = self.srv.borrow_mut();'), (80, '        let fut = self.srv.borrow_mut().0.call(req);'), (111, '    A(#[pin] A::Future, Option<Rc<RefCell<(A, B, F)>>>),'), (132, '                    let b = b.take().unwrap();'), (134, '                    let (_, b, f) = &mut *b.borrow_mut();'), (135, '                    let fut = f(res, b);'), (258, '                srv: Rc::new(RefCell::new(('), (262, '                ))),')], 'deleted': [(7, 'use crate::cell::Cell;'), (19, '    srv: Cell<(A, B, F)>,'), (34, '            srv: Cell::new((a, b, f)),'), (70, '        let inner = self.srv.get_mut();'), (80, '        let fut = self.srv.get_mut().0.call(req);'), (111, '    A(#[pin] A::Future, Option<Cell<(A, B, F)>>),'), (132, '                    let mut b = b.take().unwrap();'), (134, '                    let b = b.get_mut();'), (135, '                    let fut = (&mut b.2)(res, &mut b.1);'), (258, '                srv: Cell::new(('), (262, '                )),')]}",
    "num_lines_added": "11",
    "num_lines_deleted": "11",
    "nloc": "304.0"
  },
  {
    "file_change_id": "152427587320615",
    "hash": "5d3207830790420468b1e4f88d6a607df9e3379",
    "old_path": "actix-service/src/apply_cfg.rs",
    "new_path": "actix-service/src/apply_cfg.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -2,8 +2,9 @@ use std::future::Future;\n use std::marker::PhantomData;\n use std::pin::Pin;\n use std::task::{Context, Poll};\n+use std::rc::Rc;\n+use std::cell::RefCell;\n \n-use crate::cell::Cell;\n use crate::{Service, ServiceFactory};\n \n /// Convert `Fn(Config, &mut Service1) -> Future<Service2>` fn to a service factory\n@@ -26,7 +27,7 @@ where\n     S: Service,\n {\n     ApplyConfigService {\n-        srv: Cell::new((srv, f)),\n+        srv: Rc::new(RefCell::new((srv, f))),\n         _t: PhantomData,\n     }\n }\n@@ -53,7 +54,7 @@ where\n     S: Service,\n {\n     ApplyConfigServiceFactory {\n-        srv: Cell::new((factory, f)),\n+        srv: Rc::new(RefCell::new((factory, f))),\n         _t: PhantomData,\n     }\n }\n@@ -66,7 +67,7 @@ where\n     R: Future<Output = Result<S, E>>,\n     S: Service,\n {\n-    srv: Cell<(T, F)>,\n+    srv: Rc<RefCell<(T, F)>>,\n     _t: PhantomData<(C, R, S)>,\n }\n \n@@ -102,10 +103,8 @@ where\n     type Future = R;\n \n     fn new_service(&self, cfg: C) -> Self::Future {\n-        unsafe {\n-            let srv = self.srv.get_mut_unsafe();\n-            (srv.1)(cfg, &mut srv.0)\n-        }\n+        let (t, f) = &mut *self.srv.borrow_mut();\n+        f(cfg, t)\n     }\n }\n \n@@ -117,7 +116,7 @@ where\n     R: Future<Output = Result<S, T::InitError>>,\n     S: Service,\n {\n-    srv: Cell<(T, F)>,\n+    srv: Rc<RefCell<(T, F)>>,\n     _t: PhantomData<(C, R, S)>,\n }\n \n@@ -157,7 +156,7 @@ where\n         ApplyConfigServiceFactoryResponse {\n             cfg: Some(cfg),\n             store: self.srv.clone(),\n-            state: State::A(self.srv.get_ref().0.new_service(())),\n+            state: State::A(self.srv.borrow().0.new_service(())),\n         }\n     }\n }\n@@ -172,7 +171,7 @@ where\n     S: Service,\n {\n     cfg: Option<C>,\n-    store: Cell<(T, F)>,\n+    store: Rc<RefCell<(T, F)>>,\n     #[pin]\n     state: State<T, R, S>,\n }\n@@ -213,8 +212,11 @@ where\n             },\n             StateProj::B(srv) => match srv.poll_ready(cx)? {\n                 Poll::Ready(_) => {\n-                    let fut = (this.store.get_mut().1)(this.cfg.take().unwrap(), srv);\n-                    this.state.set(State::C(fut));\n+                    {\n+                        let (_, f) = &mut *this.store.borrow_mut();\n+                        let fut = f(this.cfg.take().unwrap(), srv);\n+                        this.state.set(State::C(fut));\n+                    }\n                     self.poll(cx)\n                 }\n                 Poll::Pending => Poll::Pending,\n",
    "diff_parsed": "{'added': [(5, 'use std::rc::Rc;'), (6, 'use std::cell::RefCell;'), (30, '        srv: Rc::new(RefCell::new((srv, f))),'), (57, '        srv: Rc::new(RefCell::new((factory, f))),'), (70, '    srv: Rc<RefCell<(T, F)>>,'), (106, '        let (t, f) = &mut *self.srv.borrow_mut();'), (107, '        f(cfg, t)'), (119, '    srv: Rc<RefCell<(T, F)>>,'), (159, '            state: State::A(self.srv.borrow().0.new_service(())),'), (174, '    store: Rc<RefCell<(T, F)>>,'), (215, '                    {'), (216, '                        let (_, f) = &mut *this.store.borrow_mut();'), (217, '                        let fut = f(this.cfg.take().unwrap(), srv);'), (218, '                        this.state.set(State::C(fut));'), (219, '                    }')], 'deleted': [(6, 'use crate::cell::Cell;'), (29, '        srv: Cell::new((srv, f)),'), (56, '        srv: Cell::new((factory, f)),'), (69, '    srv: Cell<(T, F)>,'), (105, '        unsafe {'), (106, '            let srv = self.srv.get_mut_unsafe();'), (107, '            (srv.1)(cfg, &mut srv.0)'), (108, '        }'), (120, '    srv: Cell<(T, F)>,'), (160, '            state: State::A(self.srv.get_ref().0.new_service(())),'), (175, '    store: Cell<(T, F)>,'), (216, '                    let fut = (this.store.get_mut().1)(this.cfg.take().unwrap(), srv);'), (217, '                    this.state.set(State::C(fut));')]}",
    "num_lines_added": "15",
    "num_lines_deleted": "13",
    "nloc": "202.0"
  },
  {
    "file_change_id": "205994198467044",
    "hash": "5d3207830790420468b1e4f88d6a607df9e3379",
    "old_path": "actix-service/src/cell.rs",
    "new_path": "None",
    "change_type": "ModificationType.DELETE",
    "diff": "@@ -1,57 +0,0 @@\n-//! Custom cell impl, internal use only\n-use std::task::{Context, Poll};\n-use std::{cell::UnsafeCell, fmt, rc::Rc};\n-\n-pub(crate) struct Cell<T> {\n-    inner: Rc<UnsafeCell<T>>,\n-}\n-\n-impl<T> Clone for Cell<T> {\n-    fn clone(&self) -> Self {\n-        Self {\n-            inner: self.inner.clone(),\n-        }\n-    }\n-}\n-\n-impl<T: fmt::Debug> fmt::Debug for Cell<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.inner.fmt(f)\n-    }\n-}\n-\n-impl<T> Cell<T> {\n-    pub(crate) fn new(inner: T) -> Self {\n-        Self {\n-            inner: Rc::new(UnsafeCell::new(inner)),\n-        }\n-    }\n-\n-    pub(crate) fn get_ref(&self) -> &T {\n-        unsafe { &*self.inner.as_ref().get() }\n-    }\n-\n-    pub(crate) fn get_mut(&mut self) -> &mut T {\n-        unsafe { &mut *self.inner.as_ref().get() }\n-    }\n-\n-    #[allow(clippy::mut_from_ref)]\n-    pub(crate) unsafe fn get_mut_unsafe(&self) -> &mut T {\n-        &mut *self.inner.as_ref().get()\n-    }\n-}\n-\n-impl<T: crate::Service> crate::Service for Cell<T> {\n-    type Request = T::Request;\n-    type Response = T::Response;\n-    type Error = T::Error;\n-    type Future = T::Future;\n-\n-    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {\n-        self.get_mut().poll_ready(cx)\n-    }\n-\n-    fn call(&mut self, req: Self::Request) -> Self::Future {\n-        self.get_mut().call(req)\n-    }\n-}\n",
    "diff_parsed": "{'added': [], 'deleted': [(2, 'use std::task::{Context, Poll};'), (3, 'use std::{cell::UnsafeCell, fmt, rc::Rc};'), (5, 'pub(crate) struct Cell<T> {'), (6, '    inner: Rc<UnsafeCell<T>>,'), (7, '}'), (9, 'impl<T> Clone for Cell<T> {'), (10, '    fn clone(&self) -> Self {'), (11, '        Self {'), (12, '            inner: self.inner.clone(),'), (13, '        }'), (14, '    }'), (15, '}'), (17, 'impl<T: fmt::Debug> fmt::Debug for Cell<T> {'), (18, \"    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\"), (19, '        self.inner.fmt(f)'), (20, '    }'), (21, '}'), (23, 'impl<T> Cell<T> {'), (24, '    pub(crate) fn new(inner: T) -> Self {'), (25, '        Self {'), (26, '            inner: Rc::new(UnsafeCell::new(inner)),'), (27, '        }'), (28, '    }'), (30, '    pub(crate) fn get_ref(&self) -> &T {'), (31, '        unsafe { &*self.inner.as_ref().get() }'), (32, '    }'), (34, '    pub(crate) fn get_mut(&mut self) -> &mut T {'), (35, '        unsafe { &mut *self.inner.as_ref().get() }'), (36, '    }'), (38, '    #[allow(clippy::mut_from_ref)]'), (39, '    pub(crate) unsafe fn get_mut_unsafe(&self) -> &mut T {'), (40, '        &mut *self.inner.as_ref().get()'), (41, '    }'), (42, '}'), (44, 'impl<T: crate::Service> crate::Service for Cell<T> {'), (45, '    type Request = T::Request;'), (46, '    type Response = T::Response;'), (47, '    type Error = T::Error;'), (48, '    type Future = T::Future;'), (50, \"    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {\"), (51, '        self.get_mut().poll_ready(cx)'), (52, '    }'), (54, '    fn call(&mut self, req: Self::Request) -> Self::Future {'), (55, '        self.get_mut().call(req)'), (56, '    }'), (57, '}')]}",
    "num_lines_added": "0",
    "num_lines_deleted": "46",
    "nloc": "nan"
  },
  {
    "file_change_id": "66436322942704",
    "hash": "5d3207830790420468b1e4f88d6a607df9e3379",
    "old_path": "actix-service/src/lib.rs",
    "new_path": "actix-service/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -12,7 +12,6 @@ mod and_then_apply_fn;\n mod apply;\n mod apply_cfg;\n pub mod boxed;\n-mod cell;\n mod fn_service;\n mod map;\n mod map_config;\n",
    "diff_parsed": "{'added': [], 'deleted': [(15, 'mod cell;')]}",
    "num_lines_added": "0",
    "num_lines_deleted": "1",
    "nloc": "237.0"
  },
  {
    "file_change_id": "90560868088377",
    "hash": "5d3207830790420468b1e4f88d6a607df9e3379",
    "old_path": "actix-service/src/then.rs",
    "new_path": "actix-service/src/then.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,16 +1,16 @@\n use std::future::Future;\n use std::pin::Pin;\n use std::rc::Rc;\n+use std::cell::RefCell;\n use std::task::{Context, Poll};\n \n use super::{Service, ServiceFactory};\n-use crate::cell::Cell;\n \n /// Service for the `then` combinator, chaining a computation onto the end of\n /// another service.\n ///\n /// This is created by the `Pipeline::then` method.\n-pub(crate) struct ThenService<A, B>(Cell<(A, B)>);\n+pub(crate) struct ThenService<A, B>(Rc<RefCell<(A, B)>>);\n \n impl<A, B> ThenService<A, B> {\n     /// Create new `.then()` combinator\n@@ -19,7 +19,7 @@ impl<A, B> ThenService<A, B> {\n         A: Service,\n         B: Service<Request = Result<A::Response, A::Error>, Error = A::Error>,\n     {\n-        Self(Cell::new((a, b)))\n+        Self(Rc::new(RefCell::new((a, b))))\n     }\n }\n \n@@ -40,7 +40,7 @@ where\n     type Future = ThenServiceResponse<A, B>;\n \n     fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {\n-        let srv = self.0.get_mut();\n+        let mut srv = self.0.borrow_mut();\n         let not_ready = !srv.0.poll_ready(cx)?.is_ready();\n         if !srv.1.poll_ready(cx)?.is_ready() || not_ready {\n             Poll::Pending\n@@ -51,7 +51,7 @@ where\n \n     fn call(&mut self, req: A::Request) -> Self::Future {\n         ThenServiceResponse {\n-            state: State::A(self.0.get_mut().0.call(req), Some(self.0.clone())),\n+            state: State::A(self.0.borrow_mut().0.call(req), Some(self.0.clone())),\n         }\n     }\n }\n@@ -72,7 +72,7 @@ where\n     A: Service,\n     B: Service<Request = Result<A::Response, A::Error>>,\n {\n-    A(#[pin] A::Future, Option<Cell<(A, B)>>),\n+    A(#[pin] A::Future, Option<Rc<RefCell<(A, B)>>>),\n     B(#[pin] B::Future),\n     Empty,\n }\n@@ -90,9 +90,9 @@ where\n         match this.state.as_mut().project() {\n             StateProj::A(fut, b) => match fut.poll(cx) {\n                 Poll::Ready(res) => {\n-                    let mut b = b.take().unwrap();\n+                    let b = b.take().unwrap();\n                     this.state.set(State::Empty); // drop fut A\n-                    let fut = b.get_mut().1.call(res);\n+                    let fut = b.borrow_mut().1.call(res);\n                     this.state.set(State::B(fut));\n                     self.poll(cx)\n                 }\n",
    "diff_parsed": "{'added': [(4, 'use std::cell::RefCell;'), (13, 'pub(crate) struct ThenService<A, B>(Rc<RefCell<(A, B)>>);'), (22, '        Self(Rc::new(RefCell::new((a, b))))'), (43, '        let mut srv = self.0.borrow_mut();'), (54, '            state: State::A(self.0.borrow_mut().0.call(req), Some(self.0.clone())),'), (75, '    A(#[pin] A::Future, Option<Rc<RefCell<(A, B)>>>),'), (93, '                    let b = b.take().unwrap();'), (95, '                    let fut = b.borrow_mut().1.call(res);')], 'deleted': [(7, 'use crate::cell::Cell;'), (13, 'pub(crate) struct ThenService<A, B>(Cell<(A, B)>);'), (22, '        Self(Cell::new((a, b)))'), (43, '        let srv = self.0.get_mut();'), (54, '            state: State::A(self.0.get_mut().0.call(req), Some(self.0.clone())),'), (75, '    A(#[pin] A::Future, Option<Cell<(A, B)>>),'), (93, '                    let mut b = b.take().unwrap();'), (95, '                    let fut = b.get_mut().1.call(res);')]}",
    "num_lines_added": "8",
    "num_lines_deleted": "8",
    "nloc": "296.0"
  },
  {
    "file_change_id": "126420998765405",
    "hash": "f7c378b26e273d237575154800f6c2bd3bf2005",
    "old_path": "crossbeam-utils/src/atomic/atomic_cell.rs",
    "new_path": "crossbeam-utils/src/atomic/atomic_cell.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -465,8 +465,24 @@ macro_rules! impl_arithmetic {\n             /// ```\n             #[inline]\n             pub fn fetch_add(&self, val: $t) -> $t {\n-                let a = unsafe { &*(self.value.get() as *const $atomic) };\n-                a.fetch_add(val, Ordering::AcqRel)\n+                if can_transmute::<$t, $atomic>() {\n+                    let a = unsafe { &*(self.value.get() as *const $atomic) };\n+                    a.fetch_add(val, Ordering::AcqRel)\n+                } else {\n+                    #[cfg(crossbeam_loom)]\n+                    {\n+                        let _ = val;\n+                        unimplemented!(\"loom does not support non-atomic atomic ops\");\n+                    }\n+                    #[cfg(not(crossbeam_loom))]\n+                    {\n+                        let _guard = lock(self.value.get() as usize).write();\n+                        let value = unsafe { &mut *(self.value.get()) };\n+                        let old = *value;\n+                        *value = value.wrapping_add(val);\n+                        old\n+                    }\n+                }\n             }\n \n             /// Decrements the current value by `val` and returns the previous value.\n@@ -485,8 +501,24 @@ macro_rules! impl_arithmetic {\n             /// ```\n             #[inline]\n             pub fn fetch_sub(&self, val: $t) -> $t {\n-                let a = unsafe { &*(self.value.get() as *const $atomic) };\n-                a.fetch_sub(val, Ordering::AcqRel)\n+                if can_transmute::<$t, $atomic>() {\n+                    let a = unsafe { &*(self.value.get() as *const $atomic) };\n+                    a.fetch_sub(val, Ordering::AcqRel)\n+                } else {\n+                    #[cfg(crossbeam_loom)]\n+                    {\n+                        let _ = val;\n+                        unimplemented!(\"loom does not support non-atomic atomic ops\");\n+                    }\n+                    #[cfg(not(crossbeam_loom))]\n+                    {\n+                        let _guard = lock(self.value.get() as usize).write();\n+                        let value = unsafe { &mut *(self.value.get()) };\n+                        let old = *value;\n+                        *value = value.wrapping_sub(val);\n+                        old\n+                    }\n+                }\n             }\n \n             /// Applies bitwise \"and\" to the current value and returns the previous value.\n@@ -503,8 +535,24 @@ macro_rules! impl_arithmetic {\n             /// ```\n             #[inline]\n             pub fn fetch_and(&self, val: $t) -> $t {\n-                let a = unsafe { &*(self.value.get() as *const $atomic) };\n-                a.fetch_and(val, Ordering::AcqRel)\n+                if can_transmute::<$t, $atomic>() {\n+                    let a = unsafe { &*(self.value.get() as *const $atomic) };\n+                    a.fetch_and(val, Ordering::AcqRel)\n+                } else {\n+                    #[cfg(crossbeam_loom)]\n+                    {\n+                        let _ = val;\n+                        unimplemented!(\"loom does not support non-atomic atomic ops\");\n+                    }\n+                    #[cfg(not(crossbeam_loom))]\n+                    {\n+                        let _guard = lock(self.value.get() as usize).write();\n+                        let value = unsafe { &mut *(self.value.get()) };\n+                        let old = *value;\n+                        *value &= val;\n+                        old\n+                    }\n+                }\n             }\n \n             /// Applies bitwise \"or\" to the current value and returns the previous value.\n@@ -521,8 +569,24 @@ macro_rules! impl_arithmetic {\n             /// ```\n             #[inline]\n             pub fn fetch_or(&self, val: $t) -> $t {\n-                let a = unsafe { &*(self.value.get() as *const $atomic) };\n-                a.fetch_or(val, Ordering::AcqRel)\n+                if can_transmute::<$t, $atomic>() {\n+                    let a = unsafe { &*(self.value.get() as *const $atomic) };\n+                    a.fetch_or(val, Ordering::AcqRel)\n+                } else {\n+                    #[cfg(crossbeam_loom)]\n+                    {\n+                        let _ = val;\n+                        unimplemented!(\"loom does not support non-atomic atomic ops\");\n+                    }\n+                    #[cfg(not(crossbeam_loom))]\n+                    {\n+                        let _guard = lock(self.value.get() as usize).write();\n+                        let value = unsafe { &mut *(self.value.get()) };\n+                        let old = *value;\n+                        *value |= val;\n+                        old\n+                    }\n+                }\n             }\n \n             /// Applies bitwise \"xor\" to the current value and returns the previous value.\n@@ -539,8 +603,24 @@ macro_rules! impl_arithmetic {\n             /// ```\n             #[inline]\n             pub fn fetch_xor(&self, val: $t) -> $t {\n-                let a = unsafe { &*(self.value.get() as *const $atomic) };\n-                a.fetch_xor(val, Ordering::AcqRel)\n+                if can_transmute::<$t, $atomic>() {\n+                    let a = unsafe { &*(self.value.get() as *const $atomic) };\n+                    a.fetch_xor(val, Ordering::AcqRel)\n+                } else {\n+                    #[cfg(crossbeam_loom)]\n+                    {\n+                        let _ = val;\n+                        unimplemented!(\"loom does not support non-atomic atomic ops\");\n+                    }\n+                    #[cfg(not(crossbeam_loom))]\n+                    {\n+                        let _guard = lock(self.value.get() as usize).write();\n+                        let value = unsafe { &mut *(self.value.get()) };\n+                        let old = *value;\n+                        *value ^= val;\n+                        old\n+                    }\n+                }\n             }\n         }\n     };\n",
    "diff_parsed": "{'added': [(468, '                if can_transmute::<$t, $atomic>() {'), (469, '                    let a = unsafe { &*(self.value.get() as *const $atomic) };'), (470, '                    a.fetch_add(val, Ordering::AcqRel)'), (471, '                } else {'), (472, '                    #[cfg(crossbeam_loom)]'), (473, '                    {'), (474, '                        let _ = val;'), (475, '                        unimplemented!(\"loom does not support non-atomic atomic ops\");'), (476, '                    }'), (477, '                    #[cfg(not(crossbeam_loom))]'), (478, '                    {'), (479, '                        let _guard = lock(self.value.get() as usize).write();'), (480, '                        let value = unsafe { &mut *(self.value.get()) };'), (481, '                        let old = *value;'), (482, '                        *value = value.wrapping_add(val);'), (483, '                        old'), (484, '                    }'), (485, '                }'), (504, '                if can_transmute::<$t, $atomic>() {'), (505, '                    let a = unsafe { &*(self.value.get() as *const $atomic) };'), (506, '                    a.fetch_sub(val, Ordering::AcqRel)'), (507, '                } else {'), (508, '                    #[cfg(crossbeam_loom)]'), (509, '                    {'), (510, '                        let _ = val;'), (511, '                        unimplemented!(\"loom does not support non-atomic atomic ops\");'), (512, '                    }'), (513, '                    #[cfg(not(crossbeam_loom))]'), (514, '                    {'), (515, '                        let _guard = lock(self.value.get() as usize).write();'), (516, '                        let value = unsafe { &mut *(self.value.get()) };'), (517, '                        let old = *value;'), (518, '                        *value = value.wrapping_sub(val);'), (519, '                        old'), (520, '                    }'), (521, '                }'), (538, '                if can_transmute::<$t, $atomic>() {'), (539, '                    let a = unsafe { &*(self.value.get() as *const $atomic) };'), (540, '                    a.fetch_and(val, Ordering::AcqRel)'), (541, '                } else {'), (542, '                    #[cfg(crossbeam_loom)]'), (543, '                    {'), (544, '                        let _ = val;'), (545, '                        unimplemented!(\"loom does not support non-atomic atomic ops\");'), (546, '                    }'), (547, '                    #[cfg(not(crossbeam_loom))]'), (548, '                    {'), (549, '                        let _guard = lock(self.value.get() as usize).write();'), (550, '                        let value = unsafe { &mut *(self.value.get()) };'), (551, '                        let old = *value;'), (552, '                        *value &= val;'), (553, '                        old'), (554, '                    }'), (555, '                }'), (572, '                if can_transmute::<$t, $atomic>() {'), (573, '                    let a = unsafe { &*(self.value.get() as *const $atomic) };'), (574, '                    a.fetch_or(val, Ordering::AcqRel)'), (575, '                } else {'), (576, '                    #[cfg(crossbeam_loom)]'), (577, '                    {'), (578, '                        let _ = val;'), (579, '                        unimplemented!(\"loom does not support non-atomic atomic ops\");'), (580, '                    }'), (581, '                    #[cfg(not(crossbeam_loom))]'), (582, '                    {'), (583, '                        let _guard = lock(self.value.get() as usize).write();'), (584, '                        let value = unsafe { &mut *(self.value.get()) };'), (585, '                        let old = *value;'), (586, '                        *value |= val;'), (587, '                        old'), (588, '                    }'), (589, '                }'), (606, '                if can_transmute::<$t, $atomic>() {'), (607, '                    let a = unsafe { &*(self.value.get() as *const $atomic) };'), (608, '                    a.fetch_xor(val, Ordering::AcqRel)'), (609, '                } else {'), (610, '                    #[cfg(crossbeam_loom)]'), (611, '                    {'), (612, '                        let _ = val;'), (613, '                        unimplemented!(\"loom does not support non-atomic atomic ops\");'), (614, '                    }'), (615, '                    #[cfg(not(crossbeam_loom))]'), (616, '                    {'), (617, '                        let _guard = lock(self.value.get() as usize).write();'), (618, '                        let value = unsafe { &mut *(self.value.get()) };'), (619, '                        let old = *value;'), (620, '                        *value ^= val;'), (621, '                        old'), (622, '                    }'), (623, '                }')], 'deleted': [(468, '                let a = unsafe { &*(self.value.get() as *const $atomic) };'), (469, '                a.fetch_add(val, Ordering::AcqRel)'), (488, '                let a = unsafe { &*(self.value.get() as *const $atomic) };'), (489, '                a.fetch_sub(val, Ordering::AcqRel)'), (506, '                let a = unsafe { &*(self.value.get() as *const $atomic) };'), (507, '                a.fetch_and(val, Ordering::AcqRel)'), (524, '                let a = unsafe { &*(self.value.get() as *const $atomic) };'), (525, '                a.fetch_or(val, Ordering::AcqRel)'), (542, '                let a = unsafe { &*(self.value.get() as *const $atomic) };'), (543, '                a.fetch_xor(val, Ordering::AcqRel)')]}",
    "num_lines_added": "90",
    "num_lines_deleted": "10",
    "nloc": "548"
  },
  {
    "file_change_id": "170667163415115",
    "hash": "7b5c8fe6b684239213e7e3e9d74c3dfc12599f1",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -377,8 +377,7 @@ impl<T: Float + AddAssign> AddAssign for NotNan<T> {\n /// Panics if the provided value is NaN.\n impl<T: Float + AddAssign> AddAssign<T> for NotNan<T> {\n     fn add_assign(&mut self, other: T) {\n-        self.0 += other;\n-        assert!(!self.0.is_nan(), \"Addition resulted in NaN\");\n+        *self = *self + other;\n     }\n }\n \n@@ -425,8 +424,7 @@ impl<T: Float + SubAssign> SubAssign for NotNan<T> {\n /// Panics if the provided value is NaN or the computation results in NaN\n impl<T: Float + SubAssign> SubAssign<T> for NotNan<T> {\n     fn sub_assign(&mut self, other: T) {\n-        self.0 -= other;\n-        assert!(!self.0.is_nan(), \"Subtraction resulted in NaN\");\n+        *self = *self - other;\n     }\n }\n \n@@ -460,8 +458,7 @@ impl<T: Float + MulAssign> MulAssign for NotNan<T> {\n /// Panics if the provided value is NaN.\n impl<T: Float + MulAssign> MulAssign<T> for NotNan<T> {\n     fn mul_assign(&mut self, other: T) {\n-        self.0 *= other;\n-        assert!(!self.0.is_nan(), \"Multiplication resulted in NaN\");\n+        *self = *self * other;\n     }\n }\n \n@@ -507,8 +504,7 @@ impl<T: Float + DivAssign> DivAssign for NotNan<T> {\n /// Panics if the provided value is NaN or the computation results in NaN\n impl<T: Float + DivAssign> DivAssign<T> for NotNan<T> {\n     fn div_assign(&mut self, other: T) {\n-        self.0 /= other;\n-        assert!(!self.0.is_nan(), \"Division resulted in NaN\");\n+        *self = *self / other;\n     }\n }\n \n@@ -542,8 +538,7 @@ impl<T: Float + RemAssign> RemAssign for NotNan<T> {\n /// Panics if the provided value is NaN or the computation results in NaN\n impl<T: Float + RemAssign> RemAssign<T> for NotNan<T> {\n     fn rem_assign(&mut self, other: T) {\n-        self.0 %= other;\n-        assert!(!self.0.is_nan(), \"Rem resulted in NaN\");\n+        *self = *self % other;\n     }\n }\n \n",
    "diff_parsed": "{'added': [(380, '        *self = *self + other;'), (427, '        *self = *self - other;'), (461, '        *self = *self * other;'), (507, '        *self = *self / other;'), (541, '        *self = *self % other;')], 'deleted': [(380, '        self.0 += other;'), (381, '        assert!(!self.0.is_nan(), \"Addition resulted in NaN\");'), (428, '        self.0 -= other;'), (429, '        assert!(!self.0.is_nan(), \"Subtraction resulted in NaN\");'), (463, '        self.0 *= other;'), (464, '        assert!(!self.0.is_nan(), \"Multiplication resulted in NaN\");'), (510, '        self.0 /= other;'), (511, '        assert!(!self.0.is_nan(), \"Division resulted in NaN\");'), (545, '        self.0 %= other;'), (546, '        assert!(!self.0.is_nan(), \"Rem resulted in NaN\");')]}",
    "num_lines_added": "5",
    "num_lines_deleted": "10",
    "nloc": "585"
  },
  {
    "file_change_id": "264232016167019",
    "hash": "7b5c8fe6b684239213e7e3e9d74c3dfc12599f1",
    "old_path": "tests/test.rs",
    "new_path": "tests/test.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -590,3 +590,18 @@ fn not_nan_usage_in_const_context() {\n     const A: NotNan<f32> = unsafe { NotNan::unchecked_new(111f32) };\n     assert_eq!(A, NotNan::new(111f32).unwrap());\n }\n+\n+#[test]\n+fn not_nan_panic_safety() {\n+    let catch_op = |mut num, op: fn(&mut NotNan<_>)| {\n+        let mut num_ref = panic::AssertUnwindSafe(&mut num);\n+        let _ = panic::catch_unwind(move || op(*num_ref));\n+        num\n+    };\n+\n+    assert!(!catch_op(not_nan(f32::INFINITY), |a| *a += f32::NEG_INFINITY).is_nan());\n+    assert!(!catch_op(not_nan(f32::INFINITY), |a| *a -= f32::INFINITY).is_nan());\n+    assert!(!catch_op(not_nan(0.0), |a| *a *= f32::INFINITY).is_nan());\n+    assert!(!catch_op(not_nan(0.0), |a| *a /= 0.0).is_nan());\n+    assert!(!catch_op(not_nan(0.0), |a| *a %= 0.0).is_nan());\n+}\n",
    "diff_parsed": "{'added': [(594, '#[test]'), (595, 'fn not_nan_panic_safety() {'), (596, '    let catch_op = |mut num, op: fn(&mut NotNan<_>)| {'), (597, '        let mut num_ref = panic::AssertUnwindSafe(&mut num);'), (598, '        let _ = panic::catch_unwind(move || op(*num_ref));'), (599, '        num'), (600, '    };'), (602, '    assert!(!catch_op(not_nan(f32::INFINITY), |a| *a += f32::NEG_INFINITY).is_nan());'), (603, '    assert!(!catch_op(not_nan(f32::INFINITY), |a| *a -= f32::INFINITY).is_nan());'), (604, '    assert!(!catch_op(not_nan(0.0), |a| *a *= f32::INFINITY).is_nan());'), (605, '    assert!(!catch_op(not_nan(0.0), |a| *a /= 0.0).is_nan());'), (606, '    assert!(!catch_op(not_nan(0.0), |a| *a %= 0.0).is_nan());'), (607, '}')], 'deleted': []}",
    "num_lines_added": "13",
    "num_lines_deleted": "0",
    "nloc": "537"
  },
  {
    "file_change_id": "90754898784669",
    "hash": "15cb335e66d518a25950ff40906676f982b64a2",
    "old_path": "openssl/src/cms.rs",
    "new_path": "openssl/src/cms.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -138,22 +138,14 @@ impl CmsContentInfo {\n         flags: CMSOptions,\n     ) -> Result<CmsContentInfo, ErrorStack> {\n         unsafe {\n-            let signcert = match signcert {\n-                Some(cert) => cert.as_ptr(),\n-                None => ptr::null_mut(),\n-            };\n-            let pkey = match pkey {\n-                Some(pkey) => pkey.as_ptr(),\n-                None => ptr::null_mut(),\n-            };\n-            let data_bio_ptr = match data {\n-                Some(data) => MemBioSlice::new(data)?.as_ptr(),\n-                None => ptr::null_mut(),\n-            };\n-            let certs = match certs {\n-                Some(certs) => certs.as_ptr(),\n-                None => ptr::null_mut(),\n+            let signcert = signcert.map_or(ptr::null_mut(), |p| p.as_ptr());\n+            let pkey = pkey.map_or(ptr::null_mut(), |p| p.as_ptr());\n+            let data_bio = match data {\n+                Some(data) => Some(MemBioSlice::new(data)?),\n+                None => None,\n             };\n+            let data_bio_ptr = data_bio.as_ref().map_or(ptr::null_mut(), |p| p.as_ptr());\n+            let certs = certs.map_or(ptr::null_mut(), |p| p.as_ptr());\n \n             let cms = cvt_p(ffi::CMS_sign(\n                 signcert,\n",
    "diff_parsed": "{'added': [(141, '            let signcert = signcert.map_or(ptr::null_mut(), |p| p.as_ptr());'), (142, '            let pkey = pkey.map_or(ptr::null_mut(), |p| p.as_ptr());'), (143, '            let data_bio = match data {'), (144, '                Some(data) => Some(MemBioSlice::new(data)?),'), (145, '                None => None,'), (147, '            let data_bio_ptr = data_bio.as_ref().map_or(ptr::null_mut(), |p| p.as_ptr());'), (148, '            let certs = certs.map_or(ptr::null_mut(), |p| p.as_ptr());')], 'deleted': [(141, '            let signcert = match signcert {'), (142, '                Some(cert) => cert.as_ptr(),'), (143, '                None => ptr::null_mut(),'), (144, '            };'), (145, '            let pkey = match pkey {'), (146, '                Some(pkey) => pkey.as_ptr(),'), (147, '                None => ptr::null_mut(),'), (148, '            };'), (149, '            let data_bio_ptr = match data {'), (150, '                Some(data) => MemBioSlice::new(data)?.as_ptr(),'), (151, '                None => ptr::null_mut(),'), (152, '            };'), (153, '            let certs = match certs {'), (154, '                Some(certs) => certs.as_ptr(),'), (155, '                None => ptr::null_mut(),')]}",
    "num_lines_added": "7",
    "num_lines_deleted": "15",
    "nloc": "105"
  },
  {
    "file_change_id": "46249252780107",
    "hash": "dde31d26fd7b8ea23fbcb2928583a7882748e65",
    "old_path": "pnet_macros/src/decorator.rs",
    "new_path": "pnet_macros/src/decorator.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -657,14 +657,10 @@ fn handle_vec_primitive(\n         };\n \n         let copy_vals = if inner_ty_str == \"u8\" {\n-            // Efficient copy_nonoverlapping (memcpy)\n+            // Efficient copy_from_slice (memcpy)\n             format!(\"\n-                                    // &mut and & can never overlap\n-                                    unsafe {{\n-                                        copy_nonoverlapping(vals[..].as_ptr(),\n-                                                            _self.packet[current_offset..].as_mut_ptr(),\n-                                                            vals.len())\n-                                    }}\n+                                    _self.packet[current_offset..current_offset + vals.len()]\n+                                        .copy_from_slice(vals);\n                                 \")\n         } else {\n             // e.g. Vec<u16> -> Vec<u8>\n@@ -689,7 +685,6 @@ fn handle_vec_primitive(\n                                 #[allow(trivial_numeric_casts)]\n                                 #[cfg_attr(feature = \\\"clippy\\\", allow(used_underscore_binding))]\n                                 pub fn set_{name}(&mut self, vals: &[{inner_ty_str}]) {{\n-                                    use std::ptr::copy_nonoverlapping;\n                                     let mut _self = self;\n                                     let current_offset = {co};\n \n",
    "diff_parsed": "{'added': [(662, '                                    _self.packet[current_offset..current_offset + vals.len()]'), (663, '                                        .copy_from_slice(vals);')], 'deleted': [(663, '                                    unsafe {{'), (664, '                                        copy_nonoverlapping(vals[..].as_ptr(),'), (665, '                                                            _self.packet[current_offset..].as_mut_ptr(),'), (666, '                                                            vals.len())'), (667, '                                    }}'), (692, '                                    use std::ptr::copy_nonoverlapping;')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "6",
    "nloc": "1553.0"
  },
  {
    "file_change_id": "106876710139561",
    "hash": "dde31d26fd7b8ea23fbcb2928583a7882748e65",
    "old_path": "pnet_packet/src/ipv4.rs.in",
    "new_path": "pnet_packet/src/ipv4.rs.in",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -378,3 +378,27 @@ fn ipv4_packet_option_test() {\n \n     assert_eq!(&ref_packet[..], &packet[..]);\n }\n+\n+#[test]\n+fn ipv4_packet_set_payload_test() {\n+    use Packet;\n+\n+    let mut packet = [0u8; 25]; // allow 20 byte header and 5 byte payload\n+    let mut ip_packet = MutableIpv4Packet::new(&mut packet[..]).unwrap();\n+    ip_packet.set_total_length(25);\n+    ip_packet.set_header_length(5);\n+    let payload = b\"stuff\"; // 5 bytes\n+    ip_packet.set_payload(&payload[..]);\n+    assert_eq!(ip_packet.payload(), payload);\n+}\n+\n+#[test]\n+#[should_panic(expected = \"index 25 out of range for slice of length 24\")]\n+fn ipv4_packet_set_payload_test_panic() {\n+    let mut packet = [0u8; 24]; // allow 20 byte header and 4 byte payload\n+    let mut ip_packet = MutableIpv4Packet::new(&mut packet[..]).unwrap();\n+    ip_packet.set_total_length(25);\n+    ip_packet.set_header_length(5);\n+    let payload = b\"stuff\"; // 5 bytes\n+    ip_packet.set_payload(&payload[..]); // panic\n+}\n",
    "diff_parsed": "{'added': [(382, '#[test]'), (383, 'fn ipv4_packet_set_payload_test() {'), (384, '    use Packet;'), (386, '    let mut packet = [0u8; 25]; // allow 20 byte header and 5 byte payload'), (387, '    let mut ip_packet = MutableIpv4Packet::new(&mut packet[..]).unwrap();'), (388, '    ip_packet.set_total_length(25);'), (389, '    ip_packet.set_header_length(5);'), (390, '    let payload = b\"stuff\"; // 5 bytes'), (391, '    ip_packet.set_payload(&payload[..]);'), (392, '    assert_eq!(ip_packet.payload(), payload);'), (393, '}'), (395, '#[test]'), (396, '#[should_panic(expected = \"index 25 out of range for slice of length 24\")]'), (397, 'fn ipv4_packet_set_payload_test_panic() {'), (398, '    let mut packet = [0u8; 24]; // allow 20 byte header and 4 byte payload'), (399, '    let mut ip_packet = MutableIpv4Packet::new(&mut packet[..]).unwrap();'), (400, '    ip_packet.set_total_length(25);'), (401, '    ip_packet.set_header_length(5);'), (402, '    let payload = b\"stuff\"; // 5 bytes'), (403, '    ip_packet.set_payload(&payload[..]); // panic'), (404, '}')], 'deleted': []}",
    "num_lines_added": "21",
    "num_lines_deleted": "0",
    "nloc": "nan"
  },
  {
    "file_change_id": "99780425375773",
    "hash": "7d13cc67dbe94ab0340e2a492c489dc16815300",
    "old_path": "src/vector/focus.rs",
    "new_path": "src/vector/focus.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -279,10 +279,10 @@ impl<A> Clone for TreeFocus<A> {\n \n #[allow(unsafe_code)]\n #[cfg(threadsafe)]\n-unsafe impl<A> Send for TreeFocus<A> {}\n+unsafe impl<A: Send> Send for TreeFocus<A> {}\n #[allow(unsafe_code)]\n #[cfg(threadsafe)]\n-unsafe impl<A> Sync for TreeFocus<A> {}\n+unsafe impl<A: Sync> Sync for TreeFocus<A> {}\n \n #[inline]\n fn contains<A: Ord>(range: &Range<A>, index: &A) -> bool {\n",
    "diff_parsed": "{'added': [(282, 'unsafe impl<A: Send> Send for TreeFocus<A> {}'), (285, 'unsafe impl<A: Sync> Sync for TreeFocus<A> {}')], 'deleted': [(282, 'unsafe impl<A> Send for TreeFocus<A> {}'), (285, 'unsafe impl<A> Sync for TreeFocus<A> {}')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "589"
  },
  {
    "file_change_id": "219078746445078",
    "hash": "623b87397a569729c4bcabae747823c5668cce9",
    "old_path": "src/common.rs",
    "new_path": "src/common.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -239,7 +239,7 @@ impl FromStr for HeaderField {\n     type Err = ();\n \n     fn from_str(s: &str) -> Result<HeaderField, ()> {\n-        AsciiString::from_ascii(s.trim())\n+        AsciiString::from_ascii(s)\n             .map(HeaderField)\n             .map_err(|_| ())\n     }\n",
    "diff_parsed": "{'added': [(242, '        AsciiString::from_ascii(s)')], 'deleted': [(242, '        AsciiString::from_ascii(s.trim())')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "403"
  },
  {
    "file_change_id": "79702544731495",
    "hash": "d4133288261612d43853245aa886e1a3a0d2dbf",
    "old_path": "diesel/src/sqlite/connection/statement_iterator.rs",
    "new_path": "diesel/src/sqlite/connection/statement_iterator.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -42,28 +42,35 @@ where\n \n pub struct NamedStatementIterator<'a, T> {\n     stmt: StatementUse<'a>,\n-    column_indices: HashMap<&'a str, usize>,\n+    column_indices: Option<HashMap<&'a str, usize>>,\n     _marker: PhantomData<T>,\n }\n \n impl<'a, T> NamedStatementIterator<'a, T> {\n     #[allow(clippy::new_ret_no_self)]\n     pub fn new(stmt: StatementUse<'a>) -> QueryResult<Self> {\n-        let column_indices = (0..stmt.num_fields())\n+        Ok(NamedStatementIterator {\n+            stmt,\n+            column_indices: None,\n+            _marker: PhantomData,\n+        })\n+    }\n+\n+    fn populate_column_indices(&mut self) -> QueryResult<()> {\n+        let column_indices = (0..self.stmt.num_fields())\n             .filter_map(|i| {\n-                stmt.field_name(i).map(|column| {\n-                    let column = column\n-                        .to_str()\n+                dbg!(i);\n+                dbg!(self.stmt.field_name(i)).map(|column| {\n+                    let column = dbg!(column\n+                        .to_str())\n                         .map_err(|e| DeserializationError(e.into()))?;\n                     Ok((column, i))\n                 })\n             })\n             .collect::<QueryResult<_>>()?;\n-        Ok(NamedStatementIterator {\n-            stmt,\n-            column_indices,\n-            _marker: PhantomData,\n-        })\n+\n+        self.column_indices = Some(column_indices);\n+        Ok(())\n     }\n }\n \n@@ -78,8 +85,13 @@ where\n             Ok(row) => row,\n             Err(e) => return Some(Err(e)),\n         };\n+        if self.column_indices.is_none() {\n+            if let Err(e) = self.populate_column_indices() {\n+                return Some(Err(e));\n+            }\n+        }\n         row.map(|row| {\n-            let row = row.into_named(&self.column_indices);\n+            let row = row.into_named(self.column_indices.as_ref().expect(\"it's there because we populated it above\"));\n             T::build(&row).map_err(DeserializationError)\n         })\n     }\n",
    "diff_parsed": "{'added': [(45, \"    column_indices: Option<HashMap<&'a str, usize>>,\"), (52, '        Ok(NamedStatementIterator {'), (53, '            stmt,'), (54, '            column_indices: None,'), (55, '            _marker: PhantomData,'), (56, '        })'), (57, '    }'), (59, '    fn populate_column_indices(&mut self) -> QueryResult<()> {'), (60, '        let column_indices = (0..self.stmt.num_fields())'), (62, '                dbg!(i);'), (63, '                dbg!(self.stmt.field_name(i)).map(|column| {'), (64, '                    let column = dbg!(column'), (65, '                        .to_str())'), (72, '        self.column_indices = Some(column_indices);'), (73, '        Ok(())'), (88, '        if self.column_indices.is_none() {'), (89, '            if let Err(e) = self.populate_column_indices() {'), (90, '                return Some(Err(e));'), (91, '            }'), (92, '        }'), (94, '            let row = row.into_named(self.column_indices.as_ref().expect(\"it\\'s there because we populated it above\"));')], 'deleted': [(45, \"    column_indices: HashMap<&'a str, usize>,\"), (52, '        let column_indices = (0..stmt.num_fields())'), (54, '                stmt.field_name(i).map(|column| {'), (55, '                    let column = column'), (56, '                        .to_str()'), (62, '        Ok(NamedStatementIterator {'), (63, '            stmt,'), (64, '            column_indices,'), (65, '            _marker: PhantomData,'), (66, '        })'), (82, '            let row = row.into_named(&self.column_indices);')]}",
    "num_lines_added": "21",
    "num_lines_deleted": "11",
    "nloc": "94"
  },
  {
    "file_change_id": "248247403394184",
    "hash": "a90cf79fcac7c8b56ee5301752938aa1d2e4260",
    "old_path": "core/src/eval/misc.rs",
    "new_path": "core/src/eval/misc.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -126,9 +126,9 @@ pub fn jump(state: &mut Machine) -> Control {\n pub fn jumpi(state: &mut Machine) -> Control {\n \tpop_u256!(state, dest);\n \tpop!(state, value);\n-\tlet dest = as_usize_or_fail!(dest, ExitError::InvalidJump);\n \n \tif value != H256::zero() {\n+\t\tlet dest = as_usize_or_fail!(dest, ExitError::InvalidJump);\n \t\tif state.valids.is_valid(dest) {\n \t\t\tControl::Jump(dest)\n \t\t} else {\n",
    "diff_parsed": "{'added': [(131, '\\t\\tlet dest = as_usize_or_fail!(dest, ExitError::InvalidJump);')], 'deleted': [(129, '\\tlet dest = as_usize_or_fail!(dest, ExitError::InvalidJump);')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "184"
  },
  {
    "file_change_id": "170918033802496",
    "hash": "d61b49cb90391fc4f7f72a1abe597476c8651a0",
    "old_path": "src/scanner.rs",
    "new_path": "src/scanner.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -149,7 +149,7 @@ pub struct Scanner<T> {\n     simple_keys: Vec<SimpleKey>,\n     indent: isize,\n     indents: Vec<isize>,\n-    flow_level: usize,\n+    flow_level: u8,\n     tokens_parsed: usize,\n     token_available: bool,\n }\n@@ -906,7 +906,7 @@ impl<T: Iterator<Item=char>> Scanner<T> {\n         // The indicators '[' and '{' may start a simple key.\n         try!(self.save_simple_key());\n \n-        self.increase_flow_level();\n+        self.increase_flow_level()?;\n \n         self.allow_simple_key();\n \n@@ -941,9 +941,11 @@ impl<T: Iterator<Item=char>> Scanner<T> {\n         Ok(())\n     }\n \n-    fn increase_flow_level(&mut self) {\n+    fn increase_flow_level(&mut self) -> ScanResult {\n         self.simple_keys.push(SimpleKey::new(Marker::new(0,0,0)));\n-        self.flow_level += 1;\n+        self.flow_level = self.flow_level.checked_add(1)\n+            .ok_or_else(|| ScanError::new(self.mark, \"Recursion limit exceeded\"))?;\n+        Ok(())\n     }\n     fn decrease_flow_level(&mut self) {\n         if self.flow_level > 0 {\n",
    "diff_parsed": "{'added': [(152, '    flow_level: u8,'), (909, '        self.increase_flow_level()?;'), (944, '    fn increase_flow_level(&mut self) -> ScanResult {'), (946, '        self.flow_level = self.flow_level.checked_add(1)'), (947, '            .ok_or_else(|| ScanError::new(self.mark, \"Recursion limit exceeded\"))?;'), (948, '        Ok(())')], 'deleted': [(152, '    flow_level: usize,'), (909, '        self.increase_flow_level();'), (944, '    fn increase_flow_level(&mut self) {'), (946, '        self.flow_level += 1;')]}",
    "num_lines_added": "6",
    "num_lines_deleted": "4",
    "nloc": "1685"
  },
  {
    "file_change_id": "118884955440562",
    "hash": "d61b49cb90391fc4f7f72a1abe597476c8651a0",
    "old_path": "src/yaml.rs",
    "new_path": "src/yaml.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -638,4 +638,16 @@ c: ~\n         let first = out.into_iter().next().unwrap();\n         assert_eq!(first[0][\"important\"].as_bool().unwrap(), true);\n     }\n+\n+    #[test]\n+    fn test_recursion_depth_check_objects() {\n+        let s = \"{a:\".repeat(10_000) + &\"}\".repeat(10_000);\n+        assert!(YamlLoader::load_from_str(&s).is_err());\n+    }\n+\n+    #[test]\n+    fn test_recursion_depth_check_arrays() {\n+        let s = \"[\".repeat(10_000) + &\"]\".repeat(10_000);\n+        assert!(YamlLoader::load_from_str(&s).is_err());\n+    }\n }\n",
    "diff_parsed": "{'added': [(642, '    #[test]'), (643, '    fn test_recursion_depth_check_objects() {'), (644, '        let s = \"{a:\".repeat(10_000) + &\"}\".repeat(10_000);'), (645, '        assert!(YamlLoader::load_from_str(&s).is_err());'), (646, '    }'), (648, '    #[test]'), (649, '    fn test_recursion_depth_check_arrays() {'), (650, '        let s = \"[\".repeat(10_000) + &\"]\".repeat(10_000);'), (651, '        assert!(YamlLoader::load_from_str(&s).is_err());'), (652, '    }')], 'deleted': []}",
    "num_lines_added": "10",
    "num_lines_deleted": "0",
    "nloc": "565"
  },
  {
    "file_change_id": "223620267144106",
    "hash": "86354da6f5ea3af009c42331dc20c9a717fe980",
    "old_path": "examples/tests-loader/src/generators/rust.rs",
    "new_path": "examples/tests-loader/src/generators/rust.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -220,6 +220,15 @@ impl GenTest for types::Vector {\n                     .build();\n                 let expected = #name::from_slice(#expected).unwrap();\n                 #assert_stmt\n+                assert_eq!(\n+                    result.total_size(),\n+                    result.as_slice().len(),\n+                    \"\\nstruct: {}:\\n  data: {:#x}\\n  partial read total_size: {}, actual: {}\\n\",\n+                    #name::NAME,\n+                    result,\n+                    result.total_size(),\n+                    result.as_slice().len()\n+                );\n             }\n         );\n         vec![test]\n",
    "diff_parsed": "{'added': [(223, '                assert_eq!('), (224, '                    result.total_size(),'), (225, '                    result.as_slice().len(),'), (226, '                    \"\\\\nstruct: {}:\\\\n  data: {:#x}\\\\n  partial read total_size: {}, actual: {}\\\\n\",'), (227, '                    #name::NAME,'), (228, '                    result,'), (229, '                    result.total_size(),'), (230, '                    result.as_slice().len()'), (231, '                );')], 'deleted': []}",
    "num_lines_added": "9",
    "num_lines_deleted": "0",
    "nloc": "223"
  },
  {
    "file_change_id": "7648747159207",
    "hash": "86354da6f5ea3af009c42331dc20c9a717fe980",
    "old_path": "tools/codegen/src/generator/languages/rust/properties.rs",
    "new_path": "tools/codegen/src/generator/languages/rust/properties.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -47,7 +47,7 @@ impl DefProperties for ast::FixVec {\n     fn def_properties(&self) -> m4::TokenStream {\n         quote!(\n             pub fn total_size(&self) -> usize {\n-                molecule::NUMBER_SIZE * (self.item_count() + 1)\n+                molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()\n             }\n             pub fn item_count(&self) -> usize {\n                 molecule::unpack_number(self.as_slice()) as usize\n",
    "diff_parsed": "{'added': [(50, '                molecule::NUMBER_SIZE + Self::ITEM_SIZE * self.item_count()')], 'deleted': [(50, '                molecule::NUMBER_SIZE * (self.item_count() + 1)')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "103"
  },
  {
    "file_change_id": "266540864255828",
    "hash": "18e3cc6b1f611809eed260b05797e2b488157ac",
    "old_path": "src/download.rs",
    "new_path": "src/download.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -170,12 +170,13 @@ fn check_image_and_sig(\n         .with_context(|| format!(\"opening {}\", path.display()))?;\n \n     // perform GPG verification\n-    let mut reader = GpgReader::new(\n+    let mut reader = VerifyReader::new(\n         BufReader::with_capacity(BUFFER_SIZE, &mut file),\n-        signature,\n+        Some(signature),\n         keys,\n     )?;\n     copy(&mut reader, &mut io::sink())?;\n+    reader.verify()?;\n \n     Ok(())\n }\n@@ -241,16 +242,14 @@ pub fn write_image<F>(\n where\n     F: FnOnce(&[u8], &mut dyn Read, &mut File, &Path, Option<&SavedPartitions>) -> Result<()>,\n {\n-    let mut reader: Box<dyn Read> = Box::new(&mut source.reader);\n-\n-    // wrap source for GPG verification\n-    if let Some(signature) = source.signature.as_ref() {\n-        reader = Box::new(GpgReader::new(reader, signature, keys)?);\n-    }\n+    // wrap source for signature verification, if available\n+    // keep the reader so we can explicitly check the result afterward\n+    let mut verify_reader =\n+        VerifyReader::new(&mut source.reader, source.signature.as_deref(), keys)?;\n \n     // wrap again for progress reporting\n-    reader = Box::new(ProgressReader::new(\n-        reader,\n+    let mut reader: Box<dyn Read> = Box::new(ProgressReader::new(\n+        &mut verify_reader,\n         source.length_hint,\n         &source.artifact_type,\n     ));\n@@ -297,6 +296,10 @@ where\n     // call the callback to copy the image\n     image_copy(&first_mb, &mut reader, dest, dest_path, saved)?;\n \n+    // check signature\n+    drop(reader);\n+    verify_reader.verify()?;\n+\n     // finish I/O before closing the progress bar\n     dest.sync_all().context(\"syncing data to disk\")?;\n \n@@ -517,6 +520,11 @@ mod tests {\n             &include_bytes!(\"../fixtures/verify/1M.sig\")[..],\n             &[0; 1 << 20][..],\n         );\n+        test_one_signed_file(\n+            &include_bytes!(\"../fixtures/verify/1M.gz\")[..],\n+            &include_bytes!(\"../fixtures/verify/1M.gz.sig\")[..],\n+            &[0; 1 << 20][..],\n+        );\n         test_one_signed_file(\n             &include_bytes!(\"../fixtures/verify/1M.xz\")[..],\n             &include_bytes!(\"../fixtures/verify/1M.xz.sig\")[..],\n",
    "diff_parsed": "{'added': [(173, '    let mut reader = VerifyReader::new('), (175, '        Some(signature),'), (179, '    reader.verify()?;'), (247, '    let mut verify_reader ='), (248, '        VerifyReader::new(&mut source.reader, source.signature.as_deref(), keys)?;'), (251, '    let mut reader: Box<dyn Read> = Box::new(ProgressReader::new('), (252, '        &mut verify_reader,'), (300, '    drop(reader);'), (301, '    verify_reader.verify()?;'), (523, '        test_one_signed_file('), (524, '            &include_bytes!(\"../fixtures/verify/1M.gz\")[..],'), (525, '            &include_bytes!(\"../fixtures/verify/1M.gz.sig\")[..],'), (526, '            &[0; 1 << 20][..],'), (527, '        );')], 'deleted': [(173, '    let mut reader = GpgReader::new('), (175, '        signature,'), (244, '    let mut reader: Box<dyn Read> = Box::new(&mut source.reader);'), (247, '    if let Some(signature) = source.signature.as_ref() {'), (248, '        reader = Box::new(GpgReader::new(reader, signature, keys)?);'), (249, '    }'), (252, '    reader = Box::new(ProgressReader::new('), (253, '        reader,')]}",
    "num_lines_added": "14",
    "num_lines_deleted": "8",
    "nloc": "613"
  },
  {
    "file_change_id": "176815791828461",
    "hash": "18e3cc6b1f611809eed260b05797e2b488157ac",
    "old_path": "src/io/verify.rs",
    "new_path": "src/io/verify.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -37,7 +37,46 @@ enum VerifyReport {\n     Ignore,\n }\n \n-pub struct GpgReader<R: Read> {\n+pub struct VerifyReader<R: Read> {\n+    typ: VerifyType<R>,\n+}\n+\n+enum VerifyType<R: Read> {\n+    None(R),\n+    Gpg(GpgReader<R>),\n+}\n+\n+impl<R: Read> VerifyReader<R> {\n+    pub fn new(source: R, gpg_signature: Option<&[u8]>, keys: VerifyKeys) -> Result<Self> {\n+        let typ = if let Some(signature) = gpg_signature {\n+            VerifyType::Gpg(GpgReader::new(source, signature, keys)?)\n+        } else {\n+            VerifyType::None(source)\n+        };\n+        Ok(VerifyReader { typ })\n+    }\n+\n+    /// Return an error if signature verification fails, and report the\n+    /// result to stderr\n+    pub fn verify(&mut self) -> Result<()> {\n+        match &mut self.typ {\n+            VerifyType::None(_) => (),\n+            VerifyType::Gpg(reader) => reader.finish(VerifyReport::Stderr)?,\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl<R: Read> Read for VerifyReader<R> {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        match &mut self.typ {\n+            VerifyType::None(reader) => reader.read(buf),\n+            VerifyType::Gpg(reader) => reader.read(buf),\n+        }\n+    }\n+}\n+\n+struct GpgReader<R: Read> {\n     _gpgdir: TempDir,\n     source: R,\n     child: Child,\n@@ -45,7 +84,7 @@ pub struct GpgReader<R: Read> {\n }\n \n impl<R: Read> GpgReader<R> {\n-    pub fn new(source: R, signature: &[u8], keys: VerifyKeys) -> Result<Self> {\n+    fn new(source: R, signature: &[u8], keys: VerifyKeys) -> Result<Self> {\n         // create GPG home directory with restrictive mode\n         let gpgdir = tempfile::Builder::new()\n             .prefix(\"coreos-installer-\")\n@@ -235,9 +274,6 @@ impl<R: Read> Read for GpgReader<R> {\n                 .as_mut()\n                 .unwrap()\n                 .write_all(&buf[0..count])?;\n-        } else {\n-            // end of input; check result\n-            self.finish(VerifyReport::Stderr)?;\n         }\n         Ok(count)\n     }\n@@ -261,11 +297,12 @@ mod tests {\n         let data = include_bytes!(\"../../fixtures/verify/test-key.priv.asc\");\n         let sig = include_bytes!(\"../../fixtures/verify/test-key.priv.asc.sig\");\n \n-        let mut reader = GpgReader::new(&data[..], &sig[..], VerifyKeys::InsecureTest).unwrap();\n+        let mut reader =\n+            VerifyReader::new(&data[..], Some(&sig[..]), VerifyKeys::InsecureTest).unwrap();\n         let mut buf = Vec::new();\n         reader.read_to_end(&mut buf).unwrap();\n-        reader.finish(VerifyReport::Stderr).unwrap();\n-        reader.finish(VerifyReport::Stderr).unwrap();\n+        reader.verify().unwrap();\n+        reader.verify().unwrap();\n         assert_eq!(&buf[..], &data[..]);\n     }\n \n@@ -276,11 +313,13 @@ mod tests {\n         let sig = include_bytes!(\"../../fixtures/verify/test-key.priv.asc.sig\");\n         data[data.len() - 1] = b'!';\n \n-        let mut reader = GpgReader::new(&data[..], &sig[..], VerifyKeys::InsecureTest).unwrap();\n+        let mut reader =\n+            VerifyReader::new(&data[..], Some(&sig[..]), VerifyKeys::InsecureTest).unwrap();\n         let mut buf = Vec::new();\n-        reader.read_to_end(&mut buf).unwrap_err();\n-        reader.finish(VerifyReport::Stderr).unwrap_err();\n-        reader.finish(VerifyReport::Stderr).unwrap_err();\n+        reader.read_to_end(&mut buf).unwrap();\n+        reader.verify().unwrap_err();\n+        reader.verify().unwrap_err();\n+        assert_eq!(&buf[..], &data[..]);\n     }\n \n     /// Read truncated data with otherwise-valid signature\n@@ -289,11 +328,13 @@ mod tests {\n         let data = include_bytes!(\"../../fixtures/verify/test-key.priv.asc\");\n         let sig = include_bytes!(\"../../fixtures/verify/test-key.priv.asc.sig\");\n \n-        let mut reader = GpgReader::new(&data[..1000], &sig[..], VerifyKeys::InsecureTest).unwrap();\n+        let mut reader =\n+            VerifyReader::new(&data[..1000], Some(&sig[..]), VerifyKeys::InsecureTest).unwrap();\n         let mut buf = Vec::new();\n-        reader.read_to_end(&mut buf).unwrap_err();\n-        reader.finish(VerifyReport::Stderr).unwrap_err();\n-        reader.finish(VerifyReport::Stderr).unwrap_err();\n+        reader.read_to_end(&mut buf).unwrap();\n+        reader.verify().unwrap_err();\n+        reader.verify().unwrap_err();\n+        assert_eq!(&buf[..], &data[..1000]);\n     }\n \n     /// Read data with signing key not in keyring\n@@ -302,10 +343,12 @@ mod tests {\n         let data = include_bytes!(\"../../fixtures/verify/test-key.priv.asc\");\n         let sig = include_bytes!(\"../../fixtures/verify/test-key.priv.asc.random.sig\");\n \n-        let mut reader = GpgReader::new(&data[..], &sig[..], VerifyKeys::InsecureTest).unwrap();\n+        let mut reader =\n+            VerifyReader::new(&data[..], Some(&sig[..]), VerifyKeys::InsecureTest).unwrap();\n         let mut buf = Vec::new();\n-        reader.read_to_end(&mut buf).unwrap_err();\n-        reader.finish(VerifyReport::Stderr).unwrap_err();\n-        reader.finish(VerifyReport::Stderr).unwrap_err();\n+        reader.read_to_end(&mut buf).unwrap();\n+        reader.verify().unwrap_err();\n+        reader.verify().unwrap_err();\n+        assert_eq!(&buf[..], &data[..]);\n     }\n }\n",
    "diff_parsed": "{'added': [(40, 'pub struct VerifyReader<R: Read> {'), (41, '    typ: VerifyType<R>,'), (42, '}'), (44, 'enum VerifyType<R: Read> {'), (45, '    None(R),'), (46, '    Gpg(GpgReader<R>),'), (47, '}'), (49, 'impl<R: Read> VerifyReader<R> {'), (50, '    pub fn new(source: R, gpg_signature: Option<&[u8]>, keys: VerifyKeys) -> Result<Self> {'), (51, '        let typ = if let Some(signature) = gpg_signature {'), (52, '            VerifyType::Gpg(GpgReader::new(source, signature, keys)?)'), (53, '        } else {'), (54, '            VerifyType::None(source)'), (55, '        };'), (56, '        Ok(VerifyReader { typ })'), (57, '    }'), (61, '    pub fn verify(&mut self) -> Result<()> {'), (62, '        match &mut self.typ {'), (63, '            VerifyType::None(_) => (),'), (64, '            VerifyType::Gpg(reader) => reader.finish(VerifyReport::Stderr)?,'), (65, '        }'), (66, '        Ok(())'), (67, '    }'), (68, '}'), (70, 'impl<R: Read> Read for VerifyReader<R> {'), (71, '    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {'), (72, '        match &mut self.typ {'), (73, '            VerifyType::None(reader) => reader.read(buf),'), (74, '            VerifyType::Gpg(reader) => reader.read(buf),'), (75, '        }'), (76, '    }'), (77, '}'), (79, 'struct GpgReader<R: Read> {'), (87, '    fn new(source: R, signature: &[u8], keys: VerifyKeys) -> Result<Self> {'), (300, '        let mut reader ='), (301, '            VerifyReader::new(&data[..], Some(&sig[..]), VerifyKeys::InsecureTest).unwrap();'), (304, '        reader.verify().unwrap();'), (305, '        reader.verify().unwrap();'), (316, '        let mut reader ='), (317, '            VerifyReader::new(&data[..], Some(&sig[..]), VerifyKeys::InsecureTest).unwrap();'), (319, '        reader.read_to_end(&mut buf).unwrap();'), (320, '        reader.verify().unwrap_err();'), (321, '        reader.verify().unwrap_err();'), (322, '        assert_eq!(&buf[..], &data[..]);'), (331, '        let mut reader ='), (332, '            VerifyReader::new(&data[..1000], Some(&sig[..]), VerifyKeys::InsecureTest).unwrap();'), (334, '        reader.read_to_end(&mut buf).unwrap();'), (335, '        reader.verify().unwrap_err();'), (336, '        reader.verify().unwrap_err();'), (337, '        assert_eq!(&buf[..], &data[..1000]);'), (346, '        let mut reader ='), (347, '            VerifyReader::new(&data[..], Some(&sig[..]), VerifyKeys::InsecureTest).unwrap();'), (349, '        reader.read_to_end(&mut buf).unwrap();'), (350, '        reader.verify().unwrap_err();'), (351, '        reader.verify().unwrap_err();'), (352, '        assert_eq!(&buf[..], &data[..]);')], 'deleted': [(40, 'pub struct GpgReader<R: Read> {'), (48, '    pub fn new(source: R, signature: &[u8], keys: VerifyKeys) -> Result<Self> {'), (238, '        } else {'), (240, '            self.finish(VerifyReport::Stderr)?;'), (264, '        let mut reader = GpgReader::new(&data[..], &sig[..], VerifyKeys::InsecureTest).unwrap();'), (267, '        reader.finish(VerifyReport::Stderr).unwrap();'), (268, '        reader.finish(VerifyReport::Stderr).unwrap();'), (279, '        let mut reader = GpgReader::new(&data[..], &sig[..], VerifyKeys::InsecureTest).unwrap();'), (281, '        reader.read_to_end(&mut buf).unwrap_err();'), (282, '        reader.finish(VerifyReport::Stderr).unwrap_err();'), (283, '        reader.finish(VerifyReport::Stderr).unwrap_err();'), (292, '        let mut reader = GpgReader::new(&data[..1000], &sig[..], VerifyKeys::InsecureTest).unwrap();'), (294, '        reader.read_to_end(&mut buf).unwrap_err();'), (295, '        reader.finish(VerifyReport::Stderr).unwrap_err();'), (296, '        reader.finish(VerifyReport::Stderr).unwrap_err();'), (305, '        let mut reader = GpgReader::new(&data[..], &sig[..], VerifyKeys::InsecureTest).unwrap();'), (307, '        reader.read_to_end(&mut buf).unwrap_err();'), (308, '        reader.finish(VerifyReport::Stderr).unwrap_err();'), (309, '        reader.finish(VerifyReport::Stderr).unwrap_err();')]}",
    "num_lines_added": "56",
    "num_lines_deleted": "19",
    "nloc": "268"
  },
  {
    "file_change_id": "254061984958009",
    "hash": "99c67ffdf9111e5d3b0de9f4be2447c4b4ca84f",
    "old_path": "src/io/compress.rs",
    "new_path": "src/io/compress.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -13,9 +13,9 @@\n // limitations under the License.\n \n use anyhow::{Context, Result};\n-use flate2::read::GzDecoder;\n+use flate2::bufread::GzDecoder;\n use std::io::{self, BufRead, Read};\n-use xz2::read::XzDecoder;\n+use xz2::bufread::XzDecoder;\n \n enum CompressDecoder<R: BufRead> {\n     Uncompressed(R),\n",
    "diff_parsed": "{'added': [(16, 'use flate2::bufread::GzDecoder;'), (18, 'use xz2::bufread::XzDecoder;')], 'deleted': [(16, 'use flate2::read::GzDecoder;'), (18, 'use xz2::read::XzDecoder;')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "36"
  },
  {
    "file_change_id": "248484754434304",
    "hash": "99c67ffdf9111e5d3b0de9f4be2447c4b4ca84f",
    "old_path": "src/osmet/file.rs",
    "new_path": "src/osmet/file.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -20,7 +20,7 @@ use anyhow::{anyhow, bail, Context, Result};\n use bincode::Options;\n use serde::{Deserialize, Serialize};\n use structopt::clap::crate_version;\n-use xz2::read::XzDecoder;\n+use xz2::bufread::XzDecoder;\n \n use crate::io::{bincoder, BUFFER_SIZE};\n \n",
    "diff_parsed": "{'added': [(23, 'use xz2::bufread::XzDecoder;')], 'deleted': [(23, 'use xz2::read::XzDecoder;')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "146"
  },
  {
    "file_change_id": "4581592371645",
    "hash": "dbcbefe069fcd53ebc1981fc97fd5b3f94f396d",
    "old_path": "src/io/compress.rs",
    "new_path": "src/io/compress.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -14,7 +14,7 @@\n \n use anyhow::{Context, Result};\n use flate2::bufread::GzDecoder;\n-use std::io::{self, BufRead, Read};\n+use std::io::{self, BufRead, ErrorKind, Read};\n use xz2::bufread::XzDecoder;\n \n enum CompressDecoder<R: BufRead> {\n@@ -48,8 +48,60 @@ impl<R: BufRead> Read for DecompressReader<R> {\n         use CompressDecoder::*;\n         match &mut self.decoder {\n             Uncompressed(d) => d.read(buf),\n-            Gzip(d) => d.read(buf),\n+            Gzip(d) => {\n+                let count = d.read(buf)?;\n+                if count == 0 {\n+                    // GzDecoder stops reading as soon as it encounters the\n+                    // gzip trailer, so it doesn't notice trailing data,\n+                    // which indicates something wrong with the input.  Try\n+                    // reading one more byte, and fail if there is one.\n+                    let mut buf = [0; 1];\n+                    if d.get_mut().read(&mut buf)? > 0 {\n+                        return Err(io::Error::new(\n+                            ErrorKind::InvalidData,\n+                            \"found trailing data after compressed gzip stream\",\n+                        ));\n+                    }\n+                }\n+                Ok(count)\n+            }\n             Xz(d) => d.read(buf),\n         }\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use std::io::BufReader;\n+\n+    /// Test that DecompressReader fails if data is appended to the\n+    /// compressed stream.\n+    #[test]\n+    fn test_decompress_reader_trailing_data() {\n+        test_decompress_reader_trailing_data_one(\n+            &include_bytes!(\"../../fixtures/verify/1M.gz\")[..],\n+        );\n+        test_decompress_reader_trailing_data_one(\n+            &include_bytes!(\"../../fixtures/verify/1M.xz\")[..],\n+        );\n+    }\n+\n+    fn test_decompress_reader_trailing_data_one(input: &[u8]) {\n+        let mut input = input.to_vec();\n+        let mut output = Vec::new();\n+\n+        // successful run\n+        DecompressReader::new(BufReader::new(&*input))\n+            .unwrap()\n+            .read_to_end(&mut output)\n+            .unwrap();\n+\n+        // add trailing garbage, make sure we notice\n+        input.push(0);\n+        DecompressReader::new(BufReader::new(&*input))\n+            .unwrap()\n+            .read_to_end(&mut output)\n+            .unwrap_err();\n+    }\n+}\n",
    "diff_parsed": "{'added': [(17, 'use std::io::{self, BufRead, ErrorKind, Read};'), (51, '            Gzip(d) => {'), (52, '                let count = d.read(buf)?;'), (53, '                if count == 0 {'), (58, '                    let mut buf = [0; 1];'), (59, '                    if d.get_mut().read(&mut buf)? > 0 {'), (60, '                        return Err(io::Error::new('), (61, '                            ErrorKind::InvalidData,'), (62, '                            \"found trailing data after compressed gzip stream\",'), (63, '                        ));'), (64, '                    }'), (65, '                }'), (66, '                Ok(count)'), (67, '            }'), (73, '#[cfg(test)]'), (74, 'mod tests {'), (75, '    use super::*;'), (76, '    use std::io::BufReader;'), (80, '    #[test]'), (81, '    fn test_decompress_reader_trailing_data() {'), (82, '        test_decompress_reader_trailing_data_one('), (83, '            &include_bytes!(\"../../fixtures/verify/1M.gz\")[..],'), (84, '        );'), (85, '        test_decompress_reader_trailing_data_one('), (86, '            &include_bytes!(\"../../fixtures/verify/1M.xz\")[..],'), (87, '        );'), (88, '    }'), (90, '    fn test_decompress_reader_trailing_data_one(input: &[u8]) {'), (91, '        let mut input = input.to_vec();'), (92, '        let mut output = Vec::new();'), (95, '        DecompressReader::new(BufReader::new(&*input))'), (96, '            .unwrap()'), (97, '            .read_to_end(&mut output)'), (98, '            .unwrap();'), (101, '        input.push(0);'), (102, '        DecompressReader::new(BufReader::new(&*input))'), (103, '            .unwrap()'), (104, '            .read_to_end(&mut output)'), (105, '            .unwrap_err();'), (106, '    }'), (107, '}')], 'deleted': [(17, 'use std::io::{self, BufRead, Read};'), (51, '            Gzip(d) => d.read(buf),')]}",
    "num_lines_added": "41",
    "num_lines_deleted": "2",
    "nloc": "75"
  },
  {
    "file_change_id": "67603933067845",
    "hash": "1faf18eee11f14969b77ae0f76dcd9ebd437d0c",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -372,8 +372,8 @@ pub struct RcuCell<T> {\n     link: LinkWrapper<T>,\n }\n \n-unsafe impl<T> Send for RcuCell<T> {}\n-unsafe impl<T> Sync for RcuCell<T> {}\n+unsafe impl<T: Send> Send for RcuCell<T> {}\n+unsafe impl<T: Sync> Sync for RcuCell<T> {}\n \n impl<T> Default for RcuCell<T> {\n     fn default() -> Self {\n",
    "diff_parsed": "{'added': [(375, 'unsafe impl<T: Send> Send for RcuCell<T> {}'), (376, 'unsafe impl<T: Sync> Sync for RcuCell<T> {}')], 'deleted': [(375, 'unsafe impl<T> Send for RcuCell<T> {}'), (376, 'unsafe impl<T> Sync for RcuCell<T> {}')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "416"
  },
  {
    "file_change_id": "145629760212871",
    "hash": "0940e509dca55d19197adbe7cb5c1d5423a390c",
    "old_path": "src/biguint/multiplication.rs",
    "new_path": "src/biguint/multiplication.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -69,14 +69,20 @@ fn bigint_from_slice(slice: &[BigDigit]) -> BigInt {\n fn mac3(mut acc: &mut [BigDigit], mut b: &[BigDigit], mut c: &[BigDigit]) {\n     // Least-significant zeros have no effect on the output.\n     if let Some(&0) = b.first() {\n-        let nz = b.iter().position(|&d| d != 0).unwrap();\n-        b = &b[nz..];\n-        acc = &mut acc[nz..];\n+        if let Some(nz) = b.iter().position(|&d| d != 0) {\n+            b = &b[nz..];\n+            acc = &mut acc[nz..];\n+        } else {\n+            return;\n+        }\n     }\n     if let Some(&0) = c.first() {\n-        let nz = c.iter().position(|&d| d != 0).unwrap();\n-        c = &c[nz..];\n-        acc = &mut acc[nz..];\n+        if let Some(nz) = c.iter().position(|&d| d != 0) {\n+            c = &c[nz..];\n+            acc = &mut acc[nz..];\n+        } else {\n+            return;\n+        }\n     }\n \n     let acc = acc;\n",
    "diff_parsed": "{'added': [(72, '        if let Some(nz) = b.iter().position(|&d| d != 0) {'), (73, '            b = &b[nz..];'), (74, '            acc = &mut acc[nz..];'), (75, '        } else {'), (76, '            return;'), (77, '        }'), (80, '        if let Some(nz) = c.iter().position(|&d| d != 0) {'), (81, '            c = &c[nz..];'), (82, '            acc = &mut acc[nz..];'), (83, '        } else {'), (84, '            return;'), (85, '        }')], 'deleted': [(72, '        let nz = b.iter().position(|&d| d != 0).unwrap();'), (73, '        b = &b[nz..];'), (74, '        acc = &mut acc[nz..];'), (77, '        let nz = c.iter().position(|&d| d != 0).unwrap();'), (78, '        c = &c[nz..];'), (79, '        acc = &mut acc[nz..];')]}",
    "num_lines_added": "12",
    "num_lines_deleted": "6",
    "nloc": "330"
  },
  {
    "file_change_id": "277216668520381",
    "hash": "0940e509dca55d19197adbe7cb5c1d5423a390c",
    "old_path": "None",
    "new_path": "tests/fuzzed.rs",
    "change_type": "ModificationType.ADD",
    "diff": "@@ -0,0 +1,185 @@\n+//! Check buggy inputs that were found by fuzzing\n+\n+use num_bigint::BigUint;\n+use num_traits::Num;\n+\n+#[test]\n+fn fuzzed_mul_1() {\n+    let hex1 = \"\\\n+        cd6839ee857cf791a40494c2e522846eefbca9eca9912fdc1feed4561dbde75c75f1ddca2325ebb1\\\n+        b9cd6eae07308578e58e57f4ddd7dc239b4fd347b883e37d87232a8e5d5a8690c8dba69c97fe8ac4\\\n+        58add18be7e460e03c9d1ae8223db53d20681a4027ffc17d1e43b764791c4db5ff7add849da7e378\\\n+        ac8d9be0e8b517c490da3c0f944b6a52a0c5dc5217c71da8eec35d2c3110d8b041d2b52f3e2a8904\\\n+        abcaaca517a8f2ef6cd26ceadd39a1cf9f770bc08f55f5a230cd81961348bb18534245430699de77\\\n+        d93b805153cffd05dfd0f2cfc2332888cec9c5abf3ece9b4d7886ad94c784bf74fce12853b2a9a75\\\n+        b62a845151a703446cc20300eafe7332330e992ae88817cd6ccef8877b66a7252300a4664d7074da\\\n+        181cd9fd502ea1cd71c0b02db3c009fe970a7d226382cdba5b5576c5c0341694681c7adc4ca2d059\\\n+        d9a6b300957a2235a4eb6689b71d34dcc4037b520eabd2c8b66604bb662fe2bcf533ba8d242dbc91\\\n+        f04c1795b9f0fee800d197d8c6e998248b15855a9602b76cb3f94b148d8f71f7d6225b79d63a8e20\\\n+        8ec8f0fa56a1c381b6c09bad9886056aec17fc92b9bb0f8625fd3444e40cccc2ede768ddb23c66ad\\\n+        59a680a26a26d519d02e4d46ce93cce9e9dd86702bdd376abae0959a0e8e418aa507a63fafb8f422\\\n+        83b03dc26f371c5e261a8f90f3ac9e2a6bcc7f0a39c3f73043b5aa5a950d4e945e9f68b2c2e593e3\\\n+        b995be174714c1967b71f579043f89bfce37437af9388828a3ba0465c88954110cae6d38b638e094\\\n+        13c15c9faddd6fb63623fd50e06d00c4d5954e787158b3e4eea7e9fae8b189fa8a204b23ac2f7bbc\\\n+        b601189c0df2075977c2424336024ba3594172bea87f0f92beb20276ce8510c8ef2a4cd5ede87e7e\\\n+        38b3fa49d66fbcd322be686a349c24919f4000000000000000000000000000000000000000000000\\\n+        000000000000000000000000000000000\";\n+    let hex2 = \"\\\n+        40000000000000000000000000000000000000000000000000000000000000000000000000000000\\\n+        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\n+        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\n+        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\n+        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\n+        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\n+        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\n+        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\n+        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\n+        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\n+        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\n+        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\n+        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\n+        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\n+        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\n+        00000000000000000000000000000000000000000000000000000000000000000000000007\";\n+\n+    // Result produced independently in Python\n+    let hex_result = \"\\\n+        335a0e7ba15f3de469012530b948a11bbbef2a7b2a644bf707fbb515876f79d71d7c777288c97aec\\\n+        6e735bab81cc215e396395fd3775f708e6d3f4d1ee20f8df61c8caa39756a1a43236e9a725ffa2b1\\\n+        162b7462f9f918380f2746ba088f6d4f481a069009fff05f4790edd91e47136d7fdeb7612769f8de\\\n+        2b2366f83a2d45f124368f03e512da94a831771485f1c76a3bb0d74b0c44362c1074ad4bcf8aa241\\\n+        2af2ab2945ea3cbbdb349b3ab74e6873e7ddc2f023d57d688c33606584d22ec614d09150c1a6779d\\\n+        f64ee01454f3ff4177f43cb3f08cca2233b2716afcfb3a6d35e21ab6531e12fdd3f384a14ecaa69d\\\n+        6d8aa1145469c0d11b3080c03abf9ccc8cc3a64aba2205f35b33be21ded9a9c948c02919935c1d36\\\n+        8607367f540ba8735c702c0b6cf0027fa5c29f4898e0b36e96d55db1700d05a51a071eb71328b416\\\n+        7669acc0255e888d693ad9a26dc74d373100ded483aaf4b22d99812ed98bf8af3d4ceea3490b6f24\\\n+        7c1305e56e7c3fba003465f631ba660922c56156a580addb2cfe52c52363dc7df58896de758ea388\\\n+        23b23c3e95a870e06db026eb6621815abb05ff24ae6ec3e1897f4d1139033330bb79da376c8f19ab\\\n+        5669a0289a89b546740b9351b3a4f33a7a77619c0af74ddaaeb8256683a39062a941e98febee3d08\\\n+        a0ec0f709bcdc7178986a3e43ceb278a9af31fc28e70fdcc10ed6a96a54353a517a7da2cb0b964f8\\\n+        ee656f85d1c530659edc7d5e410fe26ff38dd0debe4e220a28ee811972225504432b9b4e2d8e3825\\\n+        04f05727eb775bed8d88ff54381b40313565539e1c562cf93ba9fa7eba2c627ea28812c8eb0bdeef\\\n+        2d804627037c81d65df09090cd8092e8d6505cafaa1fc3e4afac809db3a144323bca93358117f935\\\n+        13d3695771180f461cf38bb995b531c9e072f84f04df87ce5ad0315387399d1086f60971dc149e06\\\n+        c23253a64e46e467b210e704f93f2ec6f60b9b386eb1f629e48d79adf57e018e4827f5cb5e6cc0ba\\\n+        d3573ea621a84bbc58efaff4abe2d8b7c117fe4a6bd3da03bf4fc61ff9fc5c0ea04f97384cb7df43\\\n+        265cf3a65ff5f7a46d0e0fe8426569063ea671cf9e87578c355775ecd1ccc2f44ab329bf20b28ab8\\\n+        83a59ea48bf9c0fa6c0c936cad5c415243eb59b76f559e8b1a86fd1daa46cfe4d52e351546f0a082\\\n+        394aafeb291eb6a3ae4f661bbda78467b3ab7a63f1e4baebf1174a13c32ea281a49e2a3937fb299e\\\n+        393b9116def94e15066cf5265f6566302c5bb8a69df9a8cbb45fce9203f5047ecc1e1331f6a8c9f5\\\n+        ed31466c9e1c44d13fea4045f621496bf0b893a0187f563f68416c9e0ed8c75c061873b274f38ee5\\\n+        041656ef77826fcdc401cc72095c185f3e66b2c37cfcca211fcb4f332ab46a19dbfd4027fd9214a5\\\n+        181596f85805bb26ed706328ffcd96a57a1a1303f8ebd10d8fdeec1dc6daf08054db99e2e3e77e96\\\n+        d85e6c588bff4441bf2baa25ec74a7e803141d6cab09ec6de23c5999548153de0fdfa6cebd738d84\\\n+        70e70fd3b4b1441cefa60a9a65650ead11330c83eb1c24173665e3caca83358bbdce0eacf199d1b0\\\n+        510a81c6930ab9ecf6a9b85328f2977947945bc251d9f7a87a135d260e965bdce354470b3a131832\\\n+        a2f1914b1d601db64f1dbcc43ea382d85cd08bb91c7a161ec87bc14c7758c4fc8cfb8e240c8a4988\\\n+        5dc10e0dfb7afbed3622fb0561d715254b196ceb42869765dc5cdac5d9c6e20df9b54c6228fa07ac\\\n+        44619e3372464fcfd67a10117770ca23369b796d0336de113fa5a3757e8a2819d9815b75738cebd8\\\n+        04dd0e29c5f334dae77044fffb5ac000000000000000000000000000000000000000000000000000\\\n+        000000000000000000000000000\";\n+\n+    let bn1 = &BigUint::from_str_radix(hex1, 16).unwrap();\n+    let bn2 = &BigUint::from_str_radix(hex2, 16).unwrap();\n+    let result = BigUint::from_str_radix(hex_result, 16).unwrap();\n+\n+    assert_eq!(bn1 * bn2, result);\n+    assert_eq!(bn2 * bn1, result);\n+}\n+\n+#[test]\n+fn fuzzed_mul_2() {\n+    let hex_a = \"\\\n+        812cff04ff812cff04ff8180ff80ffff11ff80ff2cff04ff812cff04ff812cff04ff81232cff047d\\\n+        ff04ff812cff04ff812cff04ff812cff047f812cff04ff8180ff2cff04ff04ff8180ff2cff04ff04\\\n+        ff812cbf04ff8180ff2cff04ff812cff0401010000000000000000ffff1a80ffc006c70084ffff80\\\n+        ffc0064006000084ffff72ffc020ffffffffffff06d709000000dbffffffc799999999b999999999\\\n+        99999999000084ffff72ffc02006e1ffffffc70900ffffff00f312ff80ebffffff6f505f6c2e6712\\\n+        108970ffff5f6c6f6727020000000000007400000000000000000000a50000000000000000000000\\\n+        000000000000000000000000ff812cff04ff812cff2c04ff812cff8180ff2cff04ff04ff818b8b8b\\\n+        8b8b8b8b8b8b8b8b8b8b8b8b8b06c70084ffff80ffc006c700847fff80ffc006c700ffff12c70084\\\n+        ffff80ffc0060000000000000056ff00c789bfff80ffc006c70084ffff80ffc006c700ffff840100\\\n+        00000000001289ffc08b8b8b8b8b8b8b2c\";\n+    let hex_b = \"\\\n+        7ed300fb007ed300fb007e7f00db00fb007ed3007ed300fb007edcd300fb8200fb007ed300fb007e\\\n+        d300fb007ed300fb007ed300fbfeffffffffffffa8fb007e7f00d300fb00fb007ed340fb007e7f00\\\n+        00fb007ed300fb007ed300fb007e7f00d300fb00fb007e7f00d300fb007efb007e7f00d300fb007e\\\n+        d300fb007e7f0097d300fb00bf007ed300fb007ed300fb00fb00fb00fbffffffffffffffffffff00\\\n+        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\n+        000000000000df9b3900ff908fa08d9e968c9a0000e7fffb7fff0000003fd9004c90d8f600de7f00\\\n+        3fdf9b3900ff908fa08d9e968cf9b9ff0000ed38ff7b00007f003ff9ffffffffffffffa900ff3876\\\n+        000078003ff938ff7b00007f003ff938ff00007bfeffffffffffffed76003f74747474747474d300\\\n+        fb00fb007e7f00d300fb007efb007e7f00d3003e7f007ed300fb007ed300fb007e7f00d300fb017e\\\n+        d300fb007ed300fb007edcd300fb8200fb007e0000e580\";\n+    let hex_c = \"\\\n+        7b00387ffff938ff7b80007f003ff9b9ff00fdec38ff7b00007f003ff9ffffffffffffffa900ff38\\\n+        76000078003ff938ff7b00007f003ff938ff00007bfeffffffffffffed76003f74747474747474d3\\\n+        00fb00fb007e7f00d300fb007efb007e7f00d3003e7f007ed300fb007ed300fb007e7f00d300fb01\\\n+        7ed300fb007ed300fb007edcd300fb8200fb007e000000ee7f003f0000007b00387ffff938ff7b80\\\n+        007f003ff9b9ff00fdec38ff7b00007f003ff9ffffffffffffffa900ff3876000078003ff938ff7b\\\n+        00007f003ff938ff00007bfeffffffffffffed76003f74747474747474d300fb00fb007e7f00d300\\\n+        fb007efb007e7f00d3003e7f007ed300fb007ed300fb007e7f00d300fb017ed300fb007ed300fb00\\\n+        7edcd300fb8200fb007e000000ee7f003f000000000000000000000000000000002a000000000000\\\n+        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\n+        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\n+        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\n+        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\n+        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\n+        0000000000000000000000df9b3900ff908fa08d9e968c9a0000e7fffb7fff0000003fd9004c90d8\\\n+        f600de7f003fdf9b3900ff908fa08d9e968c9a0000e7fffa7fff0000004005004c90d8f600de908f\\\n+        dcd300fb8200fb007e0000e57f003ff938ff7b00007f003d7ed300fb007ed300fb007ed300fb007e\\\n+        fa00fb007ed300fbf9ffffffffffffffa900ff387600007f003ff938ff7b00007f003ff938fd0000\\\n+        7bfeffffffffffffed76003f74747474747474d300fc\";\n+\n+    // Result produced independently in Python\n+    let hex_result = \"\\\n+        1ebf6415da7ac71a689cd450727b7a361402a1626e0b6cd057e0e2a77d4cb722c1b7d0cbd73a7c07\\\n+        d756813fe97d73d5905c4a26404c7162769ba2dbc1e2742855a1db803e2d2c2fddc77c0598cc70fe\\\n+        066fd4b81cae3e23c55b4795de63acacd1343cf5ad5e715e6919d140c01bab1af1a737ebbf8a7775\\\n+        7602acd611f555ee2d5be56cc14b97c248009cd77490a3dfd6762bae25459a544e369eb4b0cc952a\\\n+        8e6a551ff35a4a7a6e5f5b0b72495c4baadf3a26b9d5d97402ad60fa2324e93adc96ca159b62d147\\\n+        5695f26ff27da100a76e2d273420572e61b4dfbd97e826d9d946f85b87434523f6aa7ce43c443285\\\n+        33f5b5adf32574167b1e9ea3bf6254d6afacf865894907de196285169cfcc1c0fcf438873d13f7e8\\\n+        654acc27c1abb00bec2729e34c994ff2152f60406f75db3ab616541795d9db8ca0b381148de7875f\\\n+        e7a8191407abc390718003698ca28498948caf1dbc3f02593dd85fa929ebae86cfe783d7be473e98\\\n+        0060d9ec60843661cb4cb9b8ddb24bb710f93700b22530501b5ea26c5c94c7370fe0ccbafe0ce7e4\\\n+        cd4f071d0cf0ac151c85a5b132ecaa75793abfb4a6ee33fddd2aa2f5cf2a8eb19c75322792c0d8dc\\\n+        1efb2dcd8ae2b49dd57b84898f531c7f745464f637716151831db56b3e293f587dc95a5e12edfe6b\\\n+        8458033dddf3556da55bef55ba3c3769def0c0f0c86786aca8313dc0ce09118760721eb545d69b46\\\n+        cdb89d377f2c80e67b572da0f75760c2849288a8457c18c6f0b58244b7f95a7567ce23756f1fe359\\\n+        64f7e84fbe28b188157519dd99b8798b076e21984d15c37f41da1309e0fbc539e8b9b09fed36a908\\\n+        28c94f72e7b755c187e58db6bfef0c02309086626ad0fe2efd2ff1467b3de11e057687865f4f85e7\\\n+        0a39bcbc4674dcaded9b04562afe08eb92fbd96ea4a99aa4f9347a075d4421f070ce3a33225f5af1\\\n+        9c27ec5d1720e659ca7fff9686f46b01d76d7de64c738671aaec57ee5582ef7956206fb37c6a36f8\\\n+        8f226ce2124a7f9894a0e9a7aa02001746e6def35699d7adc84a7dcf513ff3da20fd849950f41a5d\\\n+        bb02c91666697156d69ebbe2ef26732b6595d1b6d014a60006d2d3c7055ff9b531779195b8dcd7d9\\\n+        426e776cbc9041735384568ba4adbf7eeea7e0e6cbb47b70335a7ed12a68904eecd334921e4ae6d9\\\n+        c983af20d73215c39573963f03bc87082450cc1c70250e1e8eaa318acaf044a072891fc60324d134\\\n+        6c0a1d02cceb4d4806e536d6017bf6bc125c41694ded38766fea51bfbf7a008ca0b3eb1168766486\\\n+        8aa8469b3e6787a5d5bad6cd67c24005a5cbaa10b63d1b4d05ac42a8b31263052a1260b5900be628\\\n+        4dcab4eb0cf5cda815412ced7bd78f87c00ac3581f41a04352a4a186805a5c9e37b14561a5fc97d2\\\n+        52ca4654fe3d82f42080c21483789cc4b4cbb568f79844f7a317aa2a6555774da26c6f027d3cb0ee\\\n+        9276c6dc4f285fc3b4b9a3cd51c8815cebf110e73c80a9b842cc3b7c80af13f702662b10e868eb61\\\n+        947000b390cd2f3a0899f6f1bab86acf767062f5526507790645ae13b9701ba96b3f873047c9d3b8\\\n+        5e8a5d904a01fbfe10e63495b6021e7cc082aa66679e4d92b3e4e2d62490b44f7e250584cedff0e7\\\n+        072a870ddaa9687a1eae11afc874d83065fb98dbc3cfd90f39517ff3015c71a8c0ab36a6483c7b87\\\n+        f41b2c832fa9428fe95ffba4e49cc553d9e2d33a540958da51588e5120fef6497bfaa96a4dcfc024\\\n+        8170c57f78e9ab9546efbbaf8e9ad6a993493577edd3d29ce8fd9a2e9eb4363b5b472a4ecb2065eb\\\n+        38f876a841af1f227a703248955c8978329dffcd8e065d8da4d42504796ff7abc62832ed86c4f8d0\\\n+        0f55cd567fb9d42524be57ebdacef730c3f94c0372f86fa1b0114f8620f553e4329b2a586fcfeedc\\\n+        af47934909090e14a1f1204e6f1681fb2df05356381e6340f4feaf0787e06218b0b0d8df51acb0bc\\\n+        f98546f33273adf260da959d6fc4a04872122af6508d124abb963c14c30e7c07fee368324921fe33\\\n+        9ae89490c5d6cdae0c356bb6921de95ea13b54e23800\";\n+\n+    let a = &BigUint::from_str_radix(hex_a, 16).unwrap();\n+    let b = &BigUint::from_str_radix(hex_b, 16).unwrap();\n+    let c = &BigUint::from_str_radix(hex_c, 16).unwrap();\n+    let result = BigUint::from_str_radix(hex_result, 16).unwrap();\n+\n+    assert_eq!(a * b * c, result);\n+    assert_eq!(a * c * b, result);\n+    assert_eq!(b * a * c, result);\n+    assert_eq!(b * c * a, result);\n+    assert_eq!(c * a * b, result);\n+    assert_eq!(c * b * a, result);\n+}\n",
    "diff_parsed": "{'added': [(3, 'use num_bigint::BigUint;'), (4, 'use num_traits::Num;'), (6, '#[test]'), (7, 'fn fuzzed_mul_1() {'), (8, '    let hex1 = \"\\\\'), (9, '        cd6839ee857cf791a40494c2e522846eefbca9eca9912fdc1feed4561dbde75c75f1ddca2325ebb1\\\\'), (10, '        b9cd6eae07308578e58e57f4ddd7dc239b4fd347b883e37d87232a8e5d5a8690c8dba69c97fe8ac4\\\\'), (11, '        58add18be7e460e03c9d1ae8223db53d20681a4027ffc17d1e43b764791c4db5ff7add849da7e378\\\\'), (12, '        ac8d9be0e8b517c490da3c0f944b6a52a0c5dc5217c71da8eec35d2c3110d8b041d2b52f3e2a8904\\\\'), (13, '        abcaaca517a8f2ef6cd26ceadd39a1cf9f770bc08f55f5a230cd81961348bb18534245430699de77\\\\'), (14, '        d93b805153cffd05dfd0f2cfc2332888cec9c5abf3ece9b4d7886ad94c784bf74fce12853b2a9a75\\\\'), (15, '        b62a845151a703446cc20300eafe7332330e992ae88817cd6ccef8877b66a7252300a4664d7074da\\\\'), (16, '        181cd9fd502ea1cd71c0b02db3c009fe970a7d226382cdba5b5576c5c0341694681c7adc4ca2d059\\\\'), (17, '        d9a6b300957a2235a4eb6689b71d34dcc4037b520eabd2c8b66604bb662fe2bcf533ba8d242dbc91\\\\'), (18, '        f04c1795b9f0fee800d197d8c6e998248b15855a9602b76cb3f94b148d8f71f7d6225b79d63a8e20\\\\'), (19, '        8ec8f0fa56a1c381b6c09bad9886056aec17fc92b9bb0f8625fd3444e40cccc2ede768ddb23c66ad\\\\'), (20, '        59a680a26a26d519d02e4d46ce93cce9e9dd86702bdd376abae0959a0e8e418aa507a63fafb8f422\\\\'), (21, '        83b03dc26f371c5e261a8f90f3ac9e2a6bcc7f0a39c3f73043b5aa5a950d4e945e9f68b2c2e593e3\\\\'), (22, '        b995be174714c1967b71f579043f89bfce37437af9388828a3ba0465c88954110cae6d38b638e094\\\\'), (23, '        13c15c9faddd6fb63623fd50e06d00c4d5954e787158b3e4eea7e9fae8b189fa8a204b23ac2f7bbc\\\\'), (24, '        b601189c0df2075977c2424336024ba3594172bea87f0f92beb20276ce8510c8ef2a4cd5ede87e7e\\\\'), (25, '        38b3fa49d66fbcd322be686a349c24919f4000000000000000000000000000000000000000000000\\\\'), (26, '        000000000000000000000000000000000\";'), (27, '    let hex2 = \"\\\\'), (28, '        40000000000000000000000000000000000000000000000000000000000000000000000000000000\\\\'), (29, '        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\\'), (30, '        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\\'), (31, '        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\\'), (32, '        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\\'), (33, '        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\\'), (34, '        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\\'), (35, '        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\\'), (36, '        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\\'), (37, '        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\\'), (38, '        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\\'), (39, '        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\\'), (40, '        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\\'), (41, '        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\\'), (42, '        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\\'), (43, '        00000000000000000000000000000000000000000000000000000000000000000000000007\";'), (46, '    let hex_result = \"\\\\'), (47, '        335a0e7ba15f3de469012530b948a11bbbef2a7b2a644bf707fbb515876f79d71d7c777288c97aec\\\\'), (48, '        6e735bab81cc215e396395fd3775f708e6d3f4d1ee20f8df61c8caa39756a1a43236e9a725ffa2b1\\\\'), (49, '        162b7462f9f918380f2746ba088f6d4f481a069009fff05f4790edd91e47136d7fdeb7612769f8de\\\\'), (50, '        2b2366f83a2d45f124368f03e512da94a831771485f1c76a3bb0d74b0c44362c1074ad4bcf8aa241\\\\'), (51, '        2af2ab2945ea3cbbdb349b3ab74e6873e7ddc2f023d57d688c33606584d22ec614d09150c1a6779d\\\\'), (52, '        f64ee01454f3ff4177f43cb3f08cca2233b2716afcfb3a6d35e21ab6531e12fdd3f384a14ecaa69d\\\\'), (53, '        6d8aa1145469c0d11b3080c03abf9ccc8cc3a64aba2205f35b33be21ded9a9c948c02919935c1d36\\\\'), (54, '        8607367f540ba8735c702c0b6cf0027fa5c29f4898e0b36e96d55db1700d05a51a071eb71328b416\\\\'), (55, '        7669acc0255e888d693ad9a26dc74d373100ded483aaf4b22d99812ed98bf8af3d4ceea3490b6f24\\\\'), (56, '        7c1305e56e7c3fba003465f631ba660922c56156a580addb2cfe52c52363dc7df58896de758ea388\\\\'), (57, '        23b23c3e95a870e06db026eb6621815abb05ff24ae6ec3e1897f4d1139033330bb79da376c8f19ab\\\\'), (58, '        5669a0289a89b546740b9351b3a4f33a7a77619c0af74ddaaeb8256683a39062a941e98febee3d08\\\\'), (59, '        a0ec0f709bcdc7178986a3e43ceb278a9af31fc28e70fdcc10ed6a96a54353a517a7da2cb0b964f8\\\\'), (60, '        ee656f85d1c530659edc7d5e410fe26ff38dd0debe4e220a28ee811972225504432b9b4e2d8e3825\\\\'), (61, '        04f05727eb775bed8d88ff54381b40313565539e1c562cf93ba9fa7eba2c627ea28812c8eb0bdeef\\\\'), (62, '        2d804627037c81d65df09090cd8092e8d6505cafaa1fc3e4afac809db3a144323bca93358117f935\\\\'), (63, '        13d3695771180f461cf38bb995b531c9e072f84f04df87ce5ad0315387399d1086f60971dc149e06\\\\'), (64, '        c23253a64e46e467b210e704f93f2ec6f60b9b386eb1f629e48d79adf57e018e4827f5cb5e6cc0ba\\\\'), (65, '        d3573ea621a84bbc58efaff4abe2d8b7c117fe4a6bd3da03bf4fc61ff9fc5c0ea04f97384cb7df43\\\\'), (66, '        265cf3a65ff5f7a46d0e0fe8426569063ea671cf9e87578c355775ecd1ccc2f44ab329bf20b28ab8\\\\'), (67, '        83a59ea48bf9c0fa6c0c936cad5c415243eb59b76f559e8b1a86fd1daa46cfe4d52e351546f0a082\\\\'), (68, '        394aafeb291eb6a3ae4f661bbda78467b3ab7a63f1e4baebf1174a13c32ea281a49e2a3937fb299e\\\\'), (69, '        393b9116def94e15066cf5265f6566302c5bb8a69df9a8cbb45fce9203f5047ecc1e1331f6a8c9f5\\\\'), (70, '        ed31466c9e1c44d13fea4045f621496bf0b893a0187f563f68416c9e0ed8c75c061873b274f38ee5\\\\'), (71, '        041656ef77826fcdc401cc72095c185f3e66b2c37cfcca211fcb4f332ab46a19dbfd4027fd9214a5\\\\'), (72, '        181596f85805bb26ed706328ffcd96a57a1a1303f8ebd10d8fdeec1dc6daf08054db99e2e3e77e96\\\\'), (73, '        d85e6c588bff4441bf2baa25ec74a7e803141d6cab09ec6de23c5999548153de0fdfa6cebd738d84\\\\'), (74, '        70e70fd3b4b1441cefa60a9a65650ead11330c83eb1c24173665e3caca83358bbdce0eacf199d1b0\\\\'), (75, '        510a81c6930ab9ecf6a9b85328f2977947945bc251d9f7a87a135d260e965bdce354470b3a131832\\\\'), (76, '        a2f1914b1d601db64f1dbcc43ea382d85cd08bb91c7a161ec87bc14c7758c4fc8cfb8e240c8a4988\\\\'), (77, '        5dc10e0dfb7afbed3622fb0561d715254b196ceb42869765dc5cdac5d9c6e20df9b54c6228fa07ac\\\\'), (78, '        44619e3372464fcfd67a10117770ca23369b796d0336de113fa5a3757e8a2819d9815b75738cebd8\\\\'), (79, '        04dd0e29c5f334dae77044fffb5ac000000000000000000000000000000000000000000000000000\\\\'), (80, '        000000000000000000000000000\";'), (82, '    let bn1 = &BigUint::from_str_radix(hex1, 16).unwrap();'), (83, '    let bn2 = &BigUint::from_str_radix(hex2, 16).unwrap();'), (84, '    let result = BigUint::from_str_radix(hex_result, 16).unwrap();'), (86, '    assert_eq!(bn1 * bn2, result);'), (87, '    assert_eq!(bn2 * bn1, result);'), (88, '}'), (90, '#[test]'), (91, 'fn fuzzed_mul_2() {'), (92, '    let hex_a = \"\\\\'), (93, '        812cff04ff812cff04ff8180ff80ffff11ff80ff2cff04ff812cff04ff812cff04ff81232cff047d\\\\'), (94, '        ff04ff812cff04ff812cff04ff812cff047f812cff04ff8180ff2cff04ff04ff8180ff2cff04ff04\\\\'), (95, '        ff812cbf04ff8180ff2cff04ff812cff0401010000000000000000ffff1a80ffc006c70084ffff80\\\\'), (96, '        ffc0064006000084ffff72ffc020ffffffffffff06d709000000dbffffffc799999999b999999999\\\\'), (97, '        99999999000084ffff72ffc02006e1ffffffc70900ffffff00f312ff80ebffffff6f505f6c2e6712\\\\'), (98, '        108970ffff5f6c6f6727020000000000007400000000000000000000a50000000000000000000000\\\\'), (99, '        000000000000000000000000ff812cff04ff812cff2c04ff812cff8180ff2cff04ff04ff818b8b8b\\\\'), (100, '        8b8b8b8b8b8b8b8b8b8b8b8b8b06c70084ffff80ffc006c700847fff80ffc006c700ffff12c70084\\\\'), (101, '        ffff80ffc0060000000000000056ff00c789bfff80ffc006c70084ffff80ffc006c700ffff840100\\\\'), (102, '        00000000001289ffc08b8b8b8b8b8b8b2c\";'), (103, '    let hex_b = \"\\\\'), (104, '        7ed300fb007ed300fb007e7f00db00fb007ed3007ed300fb007edcd300fb8200fb007ed300fb007e\\\\'), (105, '        d300fb007ed300fb007ed300fbfeffffffffffffa8fb007e7f00d300fb00fb007ed340fb007e7f00\\\\'), (106, '        00fb007ed300fb007ed300fb007e7f00d300fb00fb007e7f00d300fb007efb007e7f00d300fb007e\\\\'), (107, '        d300fb007e7f0097d300fb00bf007ed300fb007ed300fb00fb00fb00fbffffffffffffffffffff00\\\\'), (108, '        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\\'), (109, '        000000000000df9b3900ff908fa08d9e968c9a0000e7fffb7fff0000003fd9004c90d8f600de7f00\\\\'), (110, '        3fdf9b3900ff908fa08d9e968cf9b9ff0000ed38ff7b00007f003ff9ffffffffffffffa900ff3876\\\\'), (111, '        000078003ff938ff7b00007f003ff938ff00007bfeffffffffffffed76003f74747474747474d300\\\\'), (112, '        fb00fb007e7f00d300fb007efb007e7f00d3003e7f007ed300fb007ed300fb007e7f00d300fb017e\\\\'), (113, '        d300fb007ed300fb007edcd300fb8200fb007e0000e580\";'), (114, '    let hex_c = \"\\\\'), (115, '        7b00387ffff938ff7b80007f003ff9b9ff00fdec38ff7b00007f003ff9ffffffffffffffa900ff38\\\\'), (116, '        76000078003ff938ff7b00007f003ff938ff00007bfeffffffffffffed76003f74747474747474d3\\\\'), (117, '        00fb00fb007e7f00d300fb007efb007e7f00d3003e7f007ed300fb007ed300fb007e7f00d300fb01\\\\'), (118, '        7ed300fb007ed300fb007edcd300fb8200fb007e000000ee7f003f0000007b00387ffff938ff7b80\\\\'), (119, '        007f003ff9b9ff00fdec38ff7b00007f003ff9ffffffffffffffa900ff3876000078003ff938ff7b\\\\'), (120, '        00007f003ff938ff00007bfeffffffffffffed76003f74747474747474d300fb00fb007e7f00d300\\\\'), (121, '        fb007efb007e7f00d3003e7f007ed300fb007ed300fb007e7f00d300fb017ed300fb007ed300fb00\\\\'), (122, '        7edcd300fb8200fb007e000000ee7f003f000000000000000000000000000000002a000000000000\\\\'), (123, '        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\\'), (124, '        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\\'), (125, '        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\\'), (126, '        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\\'), (127, '        00000000000000000000000000000000000000000000000000000000000000000000000000000000\\\\'), (128, '        0000000000000000000000df9b3900ff908fa08d9e968c9a0000e7fffb7fff0000003fd9004c90d8\\\\'), (129, '        f600de7f003fdf9b3900ff908fa08d9e968c9a0000e7fffa7fff0000004005004c90d8f600de908f\\\\'), (130, '        dcd300fb8200fb007e0000e57f003ff938ff7b00007f003d7ed300fb007ed300fb007ed300fb007e\\\\'), (131, '        fa00fb007ed300fbf9ffffffffffffffa900ff387600007f003ff938ff7b00007f003ff938fd0000\\\\'), (132, '        7bfeffffffffffffed76003f74747474747474d300fc\";'), (135, '    let hex_result = \"\\\\'), (136, '        1ebf6415da7ac71a689cd450727b7a361402a1626e0b6cd057e0e2a77d4cb722c1b7d0cbd73a7c07\\\\'), (137, '        d756813fe97d73d5905c4a26404c7162769ba2dbc1e2742855a1db803e2d2c2fddc77c0598cc70fe\\\\'), (138, '        066fd4b81cae3e23c55b4795de63acacd1343cf5ad5e715e6919d140c01bab1af1a737ebbf8a7775\\\\'), (139, '        7602acd611f555ee2d5be56cc14b97c248009cd77490a3dfd6762bae25459a544e369eb4b0cc952a\\\\'), (140, '        8e6a551ff35a4a7a6e5f5b0b72495c4baadf3a26b9d5d97402ad60fa2324e93adc96ca159b62d147\\\\'), (141, '        5695f26ff27da100a76e2d273420572e61b4dfbd97e826d9d946f85b87434523f6aa7ce43c443285\\\\'), (142, '        33f5b5adf32574167b1e9ea3bf6254d6afacf865894907de196285169cfcc1c0fcf438873d13f7e8\\\\'), (143, '        654acc27c1abb00bec2729e34c994ff2152f60406f75db3ab616541795d9db8ca0b381148de7875f\\\\'), (144, '        e7a8191407abc390718003698ca28498948caf1dbc3f02593dd85fa929ebae86cfe783d7be473e98\\\\'), (145, '        0060d9ec60843661cb4cb9b8ddb24bb710f93700b22530501b5ea26c5c94c7370fe0ccbafe0ce7e4\\\\'), (146, '        cd4f071d0cf0ac151c85a5b132ecaa75793abfb4a6ee33fddd2aa2f5cf2a8eb19c75322792c0d8dc\\\\'), (147, '        1efb2dcd8ae2b49dd57b84898f531c7f745464f637716151831db56b3e293f587dc95a5e12edfe6b\\\\'), (148, '        8458033dddf3556da55bef55ba3c3769def0c0f0c86786aca8313dc0ce09118760721eb545d69b46\\\\'), (149, '        cdb89d377f2c80e67b572da0f75760c2849288a8457c18c6f0b58244b7f95a7567ce23756f1fe359\\\\'), (150, '        64f7e84fbe28b188157519dd99b8798b076e21984d15c37f41da1309e0fbc539e8b9b09fed36a908\\\\'), (151, '        28c94f72e7b755c187e58db6bfef0c02309086626ad0fe2efd2ff1467b3de11e057687865f4f85e7\\\\'), (152, '        0a39bcbc4674dcaded9b04562afe08eb92fbd96ea4a99aa4f9347a075d4421f070ce3a33225f5af1\\\\'), (153, '        9c27ec5d1720e659ca7fff9686f46b01d76d7de64c738671aaec57ee5582ef7956206fb37c6a36f8\\\\'), (154, '        8f226ce2124a7f9894a0e9a7aa02001746e6def35699d7adc84a7dcf513ff3da20fd849950f41a5d\\\\'), (155, '        bb02c91666697156d69ebbe2ef26732b6595d1b6d014a60006d2d3c7055ff9b531779195b8dcd7d9\\\\'), (156, '        426e776cbc9041735384568ba4adbf7eeea7e0e6cbb47b70335a7ed12a68904eecd334921e4ae6d9\\\\'), (157, '        c983af20d73215c39573963f03bc87082450cc1c70250e1e8eaa318acaf044a072891fc60324d134\\\\'), (158, '        6c0a1d02cceb4d4806e536d6017bf6bc125c41694ded38766fea51bfbf7a008ca0b3eb1168766486\\\\'), (159, '        8aa8469b3e6787a5d5bad6cd67c24005a5cbaa10b63d1b4d05ac42a8b31263052a1260b5900be628\\\\'), (160, '        4dcab4eb0cf5cda815412ced7bd78f87c00ac3581f41a04352a4a186805a5c9e37b14561a5fc97d2\\\\'), (161, '        52ca4654fe3d82f42080c21483789cc4b4cbb568f79844f7a317aa2a6555774da26c6f027d3cb0ee\\\\'), (162, '        9276c6dc4f285fc3b4b9a3cd51c8815cebf110e73c80a9b842cc3b7c80af13f702662b10e868eb61\\\\'), (163, '        947000b390cd2f3a0899f6f1bab86acf767062f5526507790645ae13b9701ba96b3f873047c9d3b8\\\\'), (164, '        5e8a5d904a01fbfe10e63495b6021e7cc082aa66679e4d92b3e4e2d62490b44f7e250584cedff0e7\\\\'), (165, '        072a870ddaa9687a1eae11afc874d83065fb98dbc3cfd90f39517ff3015c71a8c0ab36a6483c7b87\\\\'), (166, '        f41b2c832fa9428fe95ffba4e49cc553d9e2d33a540958da51588e5120fef6497bfaa96a4dcfc024\\\\'), (167, '        8170c57f78e9ab9546efbbaf8e9ad6a993493577edd3d29ce8fd9a2e9eb4363b5b472a4ecb2065eb\\\\'), (168, '        38f876a841af1f227a703248955c8978329dffcd8e065d8da4d42504796ff7abc62832ed86c4f8d0\\\\'), (169, '        0f55cd567fb9d42524be57ebdacef730c3f94c0372f86fa1b0114f8620f553e4329b2a586fcfeedc\\\\'), (170, '        af47934909090e14a1f1204e6f1681fb2df05356381e6340f4feaf0787e06218b0b0d8df51acb0bc\\\\'), (171, '        f98546f33273adf260da959d6fc4a04872122af6508d124abb963c14c30e7c07fee368324921fe33\\\\'), (172, '        9ae89490c5d6cdae0c356bb6921de95ea13b54e23800\";'), (174, '    let a = &BigUint::from_str_radix(hex_a, 16).unwrap();'), (175, '    let b = &BigUint::from_str_radix(hex_b, 16).unwrap();'), (176, '    let c = &BigUint::from_str_radix(hex_c, 16).unwrap();'), (177, '    let result = BigUint::from_str_radix(hex_result, 16).unwrap();'), (179, '    assert_eq!(a * b * c, result);'), (180, '    assert_eq!(a * c * b, result);'), (181, '    assert_eq!(b * a * c, result);'), (182, '    assert_eq!(b * c * a, result);'), (183, '    assert_eq!(c * a * b, result);'), (184, '    assert_eq!(c * b * a, result);'), (185, '}')], 'deleted': []}",
    "num_lines_added": "173",
    "num_lines_deleted": "0",
    "nloc": "173"
  },
  {
    "file_change_id": "73116505967850",
    "hash": "8008707fea97b9215f3b949a0eb6044aec709a3",
    "old_path": "src/biguint/multiplication.rs",
    "new_path": "src/biguint/multiplication.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -174,7 +174,7 @@ fn mac3(mut acc: &mut [BigDigit], mut b: &[BigDigit], mut c: &[BigDigit]) {\n \n         // We reuse the same BigUint for all the intermediate multiplies and have to size p\n         // appropriately here: x1.len() >= x0.len and y1.len() >= y0.len():\n-        let len = x1.len() + y1.len();\n+        let len = x1.len() + y1.len() + 1;\n         let mut p = BigUint { data: vec![0; len] };\n \n         // p2 = x1 * y1\n@@ -350,7 +350,7 @@ fn mac3(mut acc: &mut [BigDigit], mut b: &[BigDigit], mut c: &[BigDigit]) {\n }\n \n fn mul3(x: &[BigDigit], y: &[BigDigit]) -> BigUint {\n-    let len = x.len() + y.len();\n+    let len = x.len() + y.len() + 1;\n     let mut prod = BigUint { data: vec![0; len] };\n \n     mac3(&mut prod.data, x, y);\n",
    "diff_parsed": "{'added': [(177, '        let len = x1.len() + y1.len() + 1;'), (353, '    let len = x.len() + y.len() + 1;')], 'deleted': [(177, '        let len = x1.len() + y1.len();'), (353, '    let len = x.len() + y.len();')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "330"
  },
  {
    "file_change_id": "247926752817270",
    "hash": "8008707fea97b9215f3b949a0eb6044aec709a3",
    "old_path": "tests/biguint.rs",
    "new_path": "tests/biguint.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1008,12 +1008,26 @@ fn test_checked_mul() {\n #[test]\n fn test_mul_overflow() {\n     // Test for issue #187 - overflow due to mac3 incorrectly sizing temporary\n-    let s = \"531137992816767098689588206552468627329593117727031923199444138200403559860852242739162502232636710047537552105951370000796528760829212940754539968588340162273730474622005920097370111\";\n+    let s = \"5311379928167670986895882065524686273295931177270319231994441382\\\n+             0040355986085224273916250223263671004753755210595137000079652876\\\n+             0829212940754539968588340162273730474622005920097370111\";\n     let a: BigUint = s.parse().unwrap();\n     let b = a.clone();\n     let _ = a.checked_mul(&b);\n }\n \n+#[test]\n+fn test_mul_overflow_2() {\n+    // Try a bunch of sizes that are right on the edge of multiplication length\n+    // overflow, where (x * x).data.len() == 2 * x.data.len() + 1.\n+    for i in 1u8..20 {\n+        let bits = 1u32 << i;\n+        let x = (BigUint::one() << bits) - 1u32;\n+        let x2 = (BigUint::one() << (2 * bits)) - &x - &x - 1u32;\n+        assert_eq!(&x * &x, x2);\n+    }\n+}\n+\n #[test]\n fn test_checked_div() {\n     for elm in MUL_TRIPLES.iter() {\n",
    "diff_parsed": "{'added': [(1011, '    let s = \"5311379928167670986895882065524686273295931177270319231994441382\\\\'), (1012, '             0040355986085224273916250223263671004753755210595137000079652876\\\\'), (1013, '             0829212940754539968588340162273730474622005920097370111\";'), (1019, '#[test]'), (1020, 'fn test_mul_overflow_2() {'), (1023, '    for i in 1u8..20 {'), (1024, '        let bits = 1u32 << i;'), (1025, '        let x = (BigUint::one() << bits) - 1u32;'), (1026, '        let x2 = (BigUint::one() << (2 * bits)) - &x - &x - 1u32;'), (1027, '        assert_eq!(&x * &x, x2);'), (1028, '    }'), (1029, '}')], 'deleted': [(1011, '    let s = \"531137992816767098689588206552468627329593117727031923199444138200403559860852242739162502232636710047537552105951370000796528760829212940754539968588340162273730474622005920097370111\";')]}",
    "num_lines_added": "12",
    "num_lines_deleted": "1",
    "nloc": "1684"
  },
  {
    "file_change_id": "110493076499184",
    "hash": "c13df26bf356b8c33c390b310f22227a7fd654d",
    "old_path": "src/elf.rs",
    "new_path": "src/elf.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,4 +1,3 @@\n-#![allow(clippy::integer_arithmetic)]\n //! This module relocates a BPF ELF\n \n // Note: Typically ELF shared objects are loaded using the program headers and\n@@ -243,10 +242,14 @@ impl<E: UserDefinedError, I: InstructionMeter> Executable<E, I> {\n \n     /// Get the .text section virtual address and bytes\n     pub fn get_text_bytes(&self) -> (u64, &[u8]) {\n-        let offset = (self.text_section_info.vaddr - ebpf::MM_PROGRAM_START) as usize;\n+        let offset = (self\n+            .text_section_info\n+            .vaddr\n+            .saturating_sub(ebpf::MM_PROGRAM_START)) as usize;\n         (\n             self.text_section_info.vaddr,\n-            &self.ro_section[offset..offset + self.text_section_info.offset_range.len()],\n+            &self.ro_section\n+                [offset..offset.saturating_add(self.text_section_info.offset_range.len())],\n         )\n     }\n \n@@ -312,7 +315,10 @@ impl<E: UserDefinedError, I: InstructionMeter> Executable<E, I> {\n         }\n         Err(ElfError::UnresolvedSymbol(\n             name.to_string(),\n-            file_offset / ebpf::INSN_SIZE + ebpf::ELF_INSN_DUMP_OFFSET,\n+            file_offset\n+                .checked_div(ebpf::INSN_SIZE)\n+                .and_then(|offset| offset.checked_add(ebpf::ELF_INSN_DUMP_OFFSET))\n+                .unwrap_or(ebpf::ELF_INSN_DUMP_OFFSET),\n             file_offset,\n         )\n         .into())\n@@ -408,21 +414,25 @@ impl<E: UserDefinedError, I: InstructionMeter> Executable<E, I> {\n         )?;\n \n         // calculate entrypoint offset into the text section\n-        let offset = elf.header.e_entry - text_section.sh_addr;\n-        if offset % ebpf::INSN_SIZE as u64 != 0 {\n+        let offset = elf.header.e_entry.saturating_sub(text_section.sh_addr);\n+        if offset.checked_rem(ebpf::INSN_SIZE as u64) != Some(0) {\n+            return Err(ElfError::InvalidEntrypoint);\n+        }\n+        if let Some(entrypoint) = (offset as usize).checked_div(ebpf::INSN_SIZE) {\n+            bpf_functions.remove(&ebpf::hash_symbol_name(b\"entrypoint\"));\n+            register_bpf_function(\n+                &mut bpf_functions,\n+                entrypoint,\n+                \"entrypoint\",\n+                config.enable_symbol_and_section_labels,\n+            )?;\n+        } else {\n             return Err(ElfError::InvalidEntrypoint);\n         }\n-        let entrypoint = offset as usize / ebpf::INSN_SIZE;\n-        bpf_functions.remove(&ebpf::hash_symbol_name(b\"entrypoint\"));\n-        register_bpf_function(\n-            &mut bpf_functions,\n-            entrypoint,\n-            \"entrypoint\",\n-            config.enable_symbol_and_section_labels,\n-        )?;\n \n         // concatenate the read-only sections into one\n-        let mut ro_length = text_section.sh_addr as usize + text_section_info.offset_range.len();\n+        let mut ro_length =\n+            (text_section.sh_addr as usize).saturating_add(text_section_info.offset_range.len());\n         let ro_slices = elf\n             .section_headers\n             .iter()\n@@ -446,13 +456,17 @@ impl<E: UserDefinedError, I: InstructionMeter> Executable<E, I> {\n                     .as_slice()\n                     .get(section_header.file_range().unwrap_or_default())\n                     .ok_or(ElfError::ValueOutOfBounds)?;\n-                ro_length = ro_length.max(section_header.sh_addr as usize + slice.len());\n+                ro_length =\n+                    ro_length.max((section_header.sh_addr as usize).saturating_add(slice.len()));\n                 Ok((section_header.sh_addr as usize, slice))\n             })\n             .collect::<Result<Vec<_>, ElfError>>()?;\n+        if ro_length > elf_bytes.len() {\n+            return Err(ElfError::ValueOutOfBounds);\n+        }\n         let mut ro_section = vec![0; ro_length];\n         ro_section[text_section.sh_addr as usize\n-            ..text_section.sh_addr as usize + text_section_info.offset_range.len()]\n+            ..(text_section.sh_addr as usize).saturating_add(text_section_info.offset_range.len())]\n             .copy_from_slice(\n                 elf_bytes\n                     .as_slice()\n@@ -460,7 +474,7 @@ impl<E: UserDefinedError, I: InstructionMeter> Executable<E, I> {\n                     .ok_or(ElfError::ValueOutOfBounds)?,\n             );\n         for (offset, slice) in ro_slices.iter() {\n-            ro_section[*offset..*offset + slice.len()].copy_from_slice(slice);\n+            ro_section[*offset..offset.saturating_add(slice.len())].copy_from_slice(slice);\n         }\n \n         Ok(Self {\n@@ -483,13 +497,19 @@ impl<E: UserDefinedError, I: InstructionMeter> Executable<E, I> {\n         bpf_functions: &mut BTreeMap<u32, (usize, String)>,\n         elf_bytes: &mut [u8],\n     ) -> Result<(), ElfError> {\n-        for i in 0..elf_bytes.len() / ebpf::INSN_SIZE {\n+        let instruction_count = elf_bytes\n+            .len()\n+            .checked_div(ebpf::INSN_SIZE)\n+            .ok_or(ElfError::ValueOutOfBounds)?;\n+        for i in 0..instruction_count {\n             let mut insn = ebpf::get_insn(elf_bytes, i);\n             if insn.opc == ebpf::CALL_IMM && insn.imm != -1 {\n-                let target_pc = i as isize + 1 + insn.imm as isize;\n-                if target_pc < 0 || target_pc >= (elf_bytes.len() / ebpf::INSN_SIZE) as isize {\n+                let target_pc = (i as isize)\n+                    .saturating_add(1)\n+                    .saturating_add(insn.imm as isize);\n+                if target_pc < 0 || target_pc >= instruction_count as isize {\n                     return Err(ElfError::RelativeJumpOutOfBounds(\n-                        i + ebpf::ELF_INSN_DUMP_OFFSET,\n+                        i.saturating_add(ebpf::ELF_INSN_DUMP_OFFSET),\n                     ));\n                 }\n                 let name = format!(\"function_{}\", target_pc);\n@@ -500,8 +520,9 @@ impl<E: UserDefinedError, I: InstructionMeter> Executable<E, I> {\n                     enable_symbol_and_section_labels,\n                 )?;\n                 insn.imm = hash as i64;\n+                let offset = i.saturating_mul(ebpf::INSN_SIZE);\n                 let checked_slice = elf_bytes\n-                    .get_mut(i * ebpf::INSN_SIZE..(i * ebpf::INSN_SIZE) + ebpf::INSN_SIZE)\n+                    .get_mut(offset..offset.saturating_add(ebpf::INSN_SIZE))\n                     .ok_or(ElfError::ValueOutOfBounds)?;\n                 checked_slice.copy_from_slice(&insn.to_vec());\n             }\n@@ -527,14 +548,17 @@ impl<E: UserDefinedError, I: InstructionMeter> Executable<E, I> {\n             return Err(ElfError::WrongType);\n         }\n \n-        let num_text_sections = elf.section_headers.iter().fold(0, |count, section_header| {\n-            if let Some(this_name) = elf.shdr_strtab.get_at(section_header.sh_name) {\n-                if this_name == \".text\" {\n-                    return count + 1;\n-                }\n-            }\n-            count\n-        });\n+        let num_text_sections =\n+            elf.section_headers\n+                .iter()\n+                .fold(0, |count: usize, section_header| {\n+                    if let Some(this_name) = elf.shdr_strtab.get_at(section_header.sh_name) {\n+                        if this_name == \".text\" {\n+                            return count.saturating_add(1);\n+                        }\n+                    }\n+                    count\n+                });\n         if 1 != num_text_sections {\n             return Err(ElfError::NotOneTextSection);\n         }\n@@ -628,19 +652,19 @@ impl<E: UserDefinedError, I: InstructionMeter> Executable<E, I> {\n                         .dynsyms\n                         .get(relocation.r_sym)\n                         .ok_or(ElfError::UnknownSymbol(relocation.r_sym))?;\n-                    let addr = (sym.st_value + refd_pa) as u64;\n+                    let addr = sym.st_value.saturating_add(refd_pa) as u64;\n                     let checked_slice = elf_bytes\n                         .get_mut(imm_offset..imm_offset.saturating_add(BYTE_LENGTH_IMMEIDATE))\n                         .ok_or(ElfError::ValueOutOfBounds)?;\n                     LittleEndian::write_u32(checked_slice, (addr & 0xFFFFFFFF) as u32);\n+                    let file_offset = imm_offset.saturating_add(ebpf::INSN_SIZE);\n                     let checked_slice = elf_bytes\n-                        .get_mut(\n-                            imm_offset.saturating_add(ebpf::INSN_SIZE)\n-                                ..imm_offset\n-                                    .saturating_add(ebpf::INSN_SIZE + BYTE_LENGTH_IMMEIDATE),\n-                        )\n+                        .get_mut(file_offset..file_offset.saturating_add(BYTE_LENGTH_IMMEIDATE))\n                         .ok_or(ElfError::ValueOutOfBounds)?;\n-                    LittleEndian::write_u32(checked_slice, (addr >> 32) as u32);\n+                    LittleEndian::write_u32(\n+                        checked_slice,\n+                        addr.checked_shr(32).unwrap_or_default() as u32,\n+                    );\n                 }\n                 Some(BpfRelocationType::R_Bpf_64_Relative) => {\n                     // Raw relocation between sections.  The instruction being relocated contains\n@@ -674,14 +698,14 @@ impl<E: UserDefinedError, I: InstructionMeter> Executable<E, I> {\n                             .get_mut(imm_offset..imm_offset.saturating_add(BYTE_LENGTH_IMMEIDATE))\n                             .ok_or(ElfError::ValueOutOfBounds)?;\n                         LittleEndian::write_u32(checked_slice, (refd_pa & 0xFFFFFFFF) as u32);\n+                        let file_offset = imm_offset.saturating_add(ebpf::INSN_SIZE);\n                         let checked_slice = elf_bytes\n-                            .get_mut(\n-                                imm_offset.saturating_add(ebpf::INSN_SIZE)\n-                                    ..imm_offset\n-                                        .saturating_add(ebpf::INSN_SIZE + BYTE_LENGTH_IMMEIDATE),\n-                            )\n+                            .get_mut(file_offset..file_offset.saturating_add(BYTE_LENGTH_IMMEIDATE))\n                             .ok_or(ElfError::ValueOutOfBounds)?;\n-                        LittleEndian::write_u32(checked_slice, (refd_pa >> 32) as u32);\n+                        LittleEndian::write_u32(\n+                            checked_slice,\n+                            refd_pa.checked_shr(32).unwrap_or_default() as u32,\n+                        );\n                     } else {\n                         // 64 bit memory location, write entire 64 bit physical address directly\n                         let checked_slice = elf_bytes\n@@ -708,8 +732,10 @@ impl<E: UserDefinedError, I: InstructionMeter> Executable<E, I> {\n                         if !text_section.vm_range().contains(&(sym.st_value as usize)) {\n                             return Err(ElfError::ValueOutOfBounds);\n                         }\n-                        let target_pc =\n-                            (sym.st_value - text_section.sh_addr) as usize / ebpf::INSN_SIZE;\n+                        let target_pc = (sym.st_value.saturating_sub(text_section.sh_addr)\n+                            as usize)\n+                            .checked_div(ebpf::INSN_SIZE)\n+                            .unwrap_or_default();\n                         register_bpf_function(\n                             bpf_functions,\n                             target_pc,\n@@ -727,7 +753,12 @@ impl<E: UserDefinedError, I: InstructionMeter> Executable<E, I> {\n                         {\n                             return Err(ElfError::UnresolvedSymbol(\n                                 name.to_string(),\n-                                r_offset / ebpf::INSN_SIZE + ebpf::ELF_INSN_DUMP_OFFSET,\n+                                r_offset\n+                                    .checked_div(ebpf::INSN_SIZE)\n+                                    .and_then(|offset| {\n+                                        offset.checked_add(ebpf::ELF_INSN_DUMP_OFFSET)\n+                                    })\n+                                    .unwrap_or(ebpf::ELF_INSN_DUMP_OFFSET),\n                                 r_offset,\n                             ));\n                         }\n@@ -760,7 +791,9 @@ impl<E: UserDefinedError, I: InstructionMeter> Executable<E, I> {\n                 {\n                     return Err(ElfError::ValueOutOfBounds);\n                 }\n-                let target_pc = (symbol.st_value - text_section.sh_addr) as usize / ebpf::INSN_SIZE;\n+                let target_pc = (symbol.st_value.saturating_sub(text_section.sh_addr) as usize)\n+                    .checked_div(ebpf::INSN_SIZE)\n+                    .unwrap_or_default();\n                 let name = elf\n                     .strtab\n                     .get_at(symbol.st_name)\n",
    "diff_parsed": "{'added': [(245, '        let offset = (self'), (246, '            .text_section_info'), (247, '            .vaddr'), (248, '            .saturating_sub(ebpf::MM_PROGRAM_START)) as usize;'), (251, '            &self.ro_section'), (252, '                [offset..offset.saturating_add(self.text_section_info.offset_range.len())],'), (318, '            file_offset'), (319, '                .checked_div(ebpf::INSN_SIZE)'), (320, '                .and_then(|offset| offset.checked_add(ebpf::ELF_INSN_DUMP_OFFSET))'), (321, '                .unwrap_or(ebpf::ELF_INSN_DUMP_OFFSET),'), (417, '        let offset = elf.header.e_entry.saturating_sub(text_section.sh_addr);'), (418, '        if offset.checked_rem(ebpf::INSN_SIZE as u64) != Some(0) {'), (419, '            return Err(ElfError::InvalidEntrypoint);'), (420, '        }'), (421, '        if let Some(entrypoint) = (offset as usize).checked_div(ebpf::INSN_SIZE) {'), (422, '            bpf_functions.remove(&ebpf::hash_symbol_name(b\"entrypoint\"));'), (423, '            register_bpf_function('), (424, '                &mut bpf_functions,'), (425, '                entrypoint,'), (426, '                \"entrypoint\",'), (427, '                config.enable_symbol_and_section_labels,'), (428, '            )?;'), (429, '        } else {'), (434, '        let mut ro_length ='), (435, '            (text_section.sh_addr as usize).saturating_add(text_section_info.offset_range.len());'), (459, '                ro_length ='), (460, '                    ro_length.max((section_header.sh_addr as usize).saturating_add(slice.len()));'), (464, '        if ro_length > elf_bytes.len() {'), (465, '            return Err(ElfError::ValueOutOfBounds);'), (466, '        }'), (469, '            ..(text_section.sh_addr as usize).saturating_add(text_section_info.offset_range.len())]'), (477, '            ro_section[*offset..offset.saturating_add(slice.len())].copy_from_slice(slice);'), (500, '        let instruction_count = elf_bytes'), (501, '            .len()'), (502, '            .checked_div(ebpf::INSN_SIZE)'), (503, '            .ok_or(ElfError::ValueOutOfBounds)?;'), (504, '        for i in 0..instruction_count {'), (507, '                let target_pc = (i as isize)'), (508, '                    .saturating_add(1)'), (509, '                    .saturating_add(insn.imm as isize);'), (510, '                if target_pc < 0 || target_pc >= instruction_count as isize {'), (512, '                        i.saturating_add(ebpf::ELF_INSN_DUMP_OFFSET),'), (523, '                let offset = i.saturating_mul(ebpf::INSN_SIZE);'), (525, '                    .get_mut(offset..offset.saturating_add(ebpf::INSN_SIZE))'), (551, '        let num_text_sections ='), (552, '            elf.section_headers'), (553, '                .iter()'), (554, '                .fold(0, |count: usize, section_header| {'), (555, '                    if let Some(this_name) = elf.shdr_strtab.get_at(section_header.sh_name) {'), (556, '                        if this_name == \".text\" {'), (557, '                            return count.saturating_add(1);'), (558, '                        }'), (559, '                    }'), (560, '                    count'), (561, '                });'), (655, '                    let addr = sym.st_value.saturating_add(refd_pa) as u64;'), (660, '                    let file_offset = imm_offset.saturating_add(ebpf::INSN_SIZE);'), (662, '                        .get_mut(file_offset..file_offset.saturating_add(BYTE_LENGTH_IMMEIDATE))'), (664, '                    LittleEndian::write_u32('), (665, '                        checked_slice,'), (666, '                        addr.checked_shr(32).unwrap_or_default() as u32,'), (667, '                    );'), (701, '                        let file_offset = imm_offset.saturating_add(ebpf::INSN_SIZE);'), (703, '                            .get_mut(file_offset..file_offset.saturating_add(BYTE_LENGTH_IMMEIDATE))'), (705, '                        LittleEndian::write_u32('), (706, '                            checked_slice,'), (707, '                            refd_pa.checked_shr(32).unwrap_or_default() as u32,'), (708, '                        );'), (735, '                        let target_pc = (sym.st_value.saturating_sub(text_section.sh_addr)'), (736, '                            as usize)'), (737, '                            .checked_div(ebpf::INSN_SIZE)'), (738, '                            .unwrap_or_default();'), (756, '                                r_offset'), (757, '                                    .checked_div(ebpf::INSN_SIZE)'), (758, '                                    .and_then(|offset| {'), (759, '                                        offset.checked_add(ebpf::ELF_INSN_DUMP_OFFSET)'), (760, '                                    })'), (761, '                                    .unwrap_or(ebpf::ELF_INSN_DUMP_OFFSET),'), (794, '                let target_pc = (symbol.st_value.saturating_sub(text_section.sh_addr) as usize)'), (795, '                    .checked_div(ebpf::INSN_SIZE)'), (796, '                    .unwrap_or_default();')], 'deleted': [(1, '#![allow(clippy::integer_arithmetic)]'), (246, '        let offset = (self.text_section_info.vaddr - ebpf::MM_PROGRAM_START) as usize;'), (249, '            &self.ro_section[offset..offset + self.text_section_info.offset_range.len()],'), (315, '            file_offset / ebpf::INSN_SIZE + ebpf::ELF_INSN_DUMP_OFFSET,'), (411, '        let offset = elf.header.e_entry - text_section.sh_addr;'), (412, '        if offset % ebpf::INSN_SIZE as u64 != 0 {'), (415, '        let entrypoint = offset as usize / ebpf::INSN_SIZE;'), (416, '        bpf_functions.remove(&ebpf::hash_symbol_name(b\"entrypoint\"));'), (417, '        register_bpf_function('), (418, '            &mut bpf_functions,'), (419, '            entrypoint,'), (420, '            \"entrypoint\",'), (421, '            config.enable_symbol_and_section_labels,'), (422, '        )?;'), (425, '        let mut ro_length = text_section.sh_addr as usize + text_section_info.offset_range.len();'), (449, '                ro_length = ro_length.max(section_header.sh_addr as usize + slice.len());'), (455, '            ..text_section.sh_addr as usize + text_section_info.offset_range.len()]'), (463, '            ro_section[*offset..*offset + slice.len()].copy_from_slice(slice);'), (486, '        for i in 0..elf_bytes.len() / ebpf::INSN_SIZE {'), (489, '                let target_pc = i as isize + 1 + insn.imm as isize;'), (490, '                if target_pc < 0 || target_pc >= (elf_bytes.len() / ebpf::INSN_SIZE) as isize {'), (492, '                        i + ebpf::ELF_INSN_DUMP_OFFSET,'), (504, '                    .get_mut(i * ebpf::INSN_SIZE..(i * ebpf::INSN_SIZE) + ebpf::INSN_SIZE)'), (530, '        let num_text_sections = elf.section_headers.iter().fold(0, |count, section_header| {'), (531, '            if let Some(this_name) = elf.shdr_strtab.get_at(section_header.sh_name) {'), (532, '                if this_name == \".text\" {'), (533, '                    return count + 1;'), (534, '                }'), (535, '            }'), (536, '            count'), (537, '        });'), (631, '                    let addr = (sym.st_value + refd_pa) as u64;'), (637, '                        .get_mut('), (638, '                            imm_offset.saturating_add(ebpf::INSN_SIZE)'), (639, '                                ..imm_offset'), (640, '                                    .saturating_add(ebpf::INSN_SIZE + BYTE_LENGTH_IMMEIDATE),'), (641, '                        )'), (643, '                    LittleEndian::write_u32(checked_slice, (addr >> 32) as u32);'), (678, '                            .get_mut('), (679, '                                imm_offset.saturating_add(ebpf::INSN_SIZE)'), (680, '                                    ..imm_offset'), (681, '                                        .saturating_add(ebpf::INSN_SIZE + BYTE_LENGTH_IMMEIDATE),'), (682, '                            )'), (684, '                        LittleEndian::write_u32(checked_slice, (refd_pa >> 32) as u32);'), (711, '                        let target_pc ='), (712, '                            (sym.st_value - text_section.sh_addr) as usize / ebpf::INSN_SIZE;'), (730, '                                r_offset / ebpf::INSN_SIZE + ebpf::ELF_INSN_DUMP_OFFSET,'), (763, '                let target_pc = (symbol.st_value - text_section.sh_addr) as usize / ebpf::INSN_SIZE;')]}",
    "num_lines_added": "81",
    "num_lines_deleted": "48",
    "nloc": "950"
  },
  {
    "file_change_id": "104369242777265",
    "hash": "fae052b834b097ced9a89a8fff8466e18f38307",
    "old_path": "src/crypto/generichash/digest.rs",
    "new_path": "src/crypto/generichash/digest.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -26,7 +26,7 @@ impl PartialEq for Digest {\n         if other.len != self.len {\n             return false;\n         }\n-        memcmp(self.as_ref(), self.as_ref())\n+        memcmp(self.as_ref(), other.as_ref())\n     }\n }\n \n",
    "diff_parsed": "{'added': [(29, '        memcmp(self.as_ref(), other.as_ref())')], 'deleted': [(29, '        memcmp(self.as_ref(), self.as_ref())')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "88"
  },
  {
    "file_change_id": "275276115077826",
    "hash": "fae052b834b097ced9a89a8fff8466e18f38307",
    "old_path": "src/crypto/generichash/mod.rs",
    "new_path": "src/crypto/generichash/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -191,4 +191,25 @@ mod test {\n             assert!(result_hash.as_ref() == expected_hash.as_slice());\n         }\n     }\n+\n+    #[test]\n+    fn test_digest_equality() {\n+        let data1 = [1, 2];\n+        let data2 = [3, 4];\n+\n+        let h1 = {\n+            let mut hasher = State::new(32, None).unwrap();\n+            hasher.update(&data1).unwrap();\n+            hasher.finalize().unwrap()\n+        };\n+\n+        let h2 = {\n+            let mut hasher = State::new(32, None).unwrap();\n+            hasher.update(&data2).unwrap();\n+            hasher.finalize().unwrap()\n+        };\n+\n+        assert_eq!(h1, h1);\n+        assert_ne!(h1, h2);\n+    }\n }\n",
    "diff_parsed": "{'added': [(195, '    #[test]'), (196, '    fn test_digest_equality() {'), (197, '        let data1 = [1, 2];'), (198, '        let data2 = [3, 4];'), (200, '        let h1 = {'), (201, '            let mut hasher = State::new(32, None).unwrap();'), (202, '            hasher.update(&data1).unwrap();'), (203, '            hasher.finalize().unwrap()'), (204, '        };'), (206, '        let h2 = {'), (207, '            let mut hasher = State::new(32, None).unwrap();'), (208, '            hasher.update(&data2).unwrap();'), (209, '            hasher.finalize().unwrap()'), (210, '        };'), (212, '        assert_eq!(h1, h1);'), (213, '        assert_ne!(h1, h2);'), (214, '    }')], 'deleted': []}",
    "num_lines_added": "17",
    "num_lines_deleted": "0",
    "nloc": "162"
  },
  {
    "file_change_id": "7155289982412",
    "hash": "e88c6ff22e0d1a7b0733d9b90fadc4722763d7d",
    "old_path": "src/cfb.rs",
    "new_path": "src/cfb.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -245,9 +245,7 @@ impl Sectors {\n         let end = start + self.size;\n         if end > self.data.len() {\n             let mut len = self.data.len();\n-            unsafe {\n-                self.data.set_len(end);\n-            }\n+            self.data.resize(end, 0);\n             // read_exact or stop if EOF\n             while len < end {\n                 let read = r.read(&mut self.data[len..end]).map_err(CfbError::Io)?;\n",
    "diff_parsed": "{'added': [(248, '            self.data.resize(end, 0);')], 'deleted': [(248, '            unsafe {'), (249, '                self.data.set_len(end);'), (250, '            }')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "3",
    "nloc": "383"
  },
  {
    "file_change_id": "154739926868843",
    "hash": "e093c2b7b6ecbf34f8afbd87ee111df256957e4",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1103,8 +1103,9 @@ pub fn prefresh(pad: WINDOW, pmin_row: i32, pmin_col: i32, smin_row: i32, smin_c\n { unsafe { ll::prefresh(pad, pmin_row, pmin_col, smin_row, smin_col, smax_row, smax_col) } }\n \n \n-pub fn printw(s: &str) -> i32\n-{ unsafe { ll::printw(s.to_c_str().as_ptr()) } }\n+#[deprecated(since = \"5.98.0\", note = \"printw can segfault when printing string that contains % sign. Use addstr instead\")]\n+unsafe pub fn printw(s: &str) -> i32\n+{ ll::printw(s.to_c_str().as_ptr()) }\n \n \n pub fn putp(s: &str) -> i32\n",
    "diff_parsed": "{'added': [(1106, '#[deprecated(since = \"5.98.0\", note = \"printw can segfault when printing string that contains % sign. Use addstr instead\")]'), (1107, 'unsafe pub fn printw(s: &str) -> i32'), (1108, '{ ll::printw(s.to_c_str().as_ptr()) }')], 'deleted': [(1106, 'pub fn printw(s: &str) -> i32'), (1107, '{ unsafe { ll::printw(s.to_c_str().as_ptr()) } }')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "2",
    "nloc": "1259"
  },
  {
    "file_change_id": "241703351301203",
    "hash": "a9165de8065bab6ee6969a1b31ddac549f634c1",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1104,7 +1104,7 @@ pub fn prefresh(pad: WINDOW, pmin_row: i32, pmin_col: i32, smin_row: i32, smin_c\n \n \n #[deprecated(since = \"5.98.0\", note = \"printw can segfault when printing string that contains % sign. Use addstr instead\")]\n-unsafe pub fn printw(s: &str) -> i32\n+pub fn printw(s: &str) -> i32\n { ll::printw(s.to_c_str().as_ptr()) }\n \n \n",
    "diff_parsed": "{'added': [(1107, 'pub fn printw(s: &str) -> i32')], 'deleted': [(1107, 'unsafe pub fn printw(s: &str) -> i32')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "1259"
  },
  {
    "file_change_id": "41555617713080",
    "hash": "7fcee591341b3d37c25676cbac868bd27b4b208",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1105,7 +1105,7 @@ pub fn prefresh(pad: WINDOW, pmin_row: i32, pmin_col: i32, smin_row: i32, smin_c\n \n #[deprecated(since = \"5.98.0\", note = \"printw can segfault when printing string that contains % sign. Use addstr instead\")]\n pub fn printw(s: &str) -> i32\n-{ ll::printw(s.to_c_str().as_ptr()) }\n+{ unsafe { ll::printw(s.to_c_str().as_ptr()) } }\n \n \n pub fn putp(s: &str) -> i32\n",
    "diff_parsed": "{'added': [(1108, '{ unsafe { ll::printw(s.to_c_str().as_ptr()) } }')], 'deleted': [(1108, '{ ll::printw(s.to_c_str().as_ptr()) }')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "1259"
  },
  {
    "file_change_id": "217103208423453",
    "hash": "0df01c9d0c5d42166dc49e903002f53978ef10e",
    "old_path": "src/rw_lock.rs",
    "new_path": "src/rw_lock.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -3,6 +3,7 @@ use core::cell::UnsafeCell;\n use core::ops::{Deref, DerefMut};\n use core::fmt;\n use core::default::Default;\n+use core::mem;\n \n /// A reader-writer lock\n ///\n@@ -16,9 +17,12 @@ use core::default::Default;\n /// allow concurrent access through readers. The RAII guards returned from the\n /// locking methods implement `Deref` (and `DerefMut` for the `write` methods)\n /// to allow access to the contained of the lock.\n+/// \n+/// Read RAII guards are upgradeable to write RAII locks through the\n+/// [`upgrade`](RwLockReadGuard::upgrade) / [`try_upgrade`](RwLockReadGuard::try_upgrade) functions.\n ///\n-/// Based on\n-/// <https://jfdube.wordpress.com/2014/01/03/implementing-a-recursive-read-write-spinlock/>\n+/// Based on Facebook's\n+/// [`folly/RWSpinLock.h`](https://github.com/facebook/folly/blob/a0394d84f2d5c3e50ebfd0566f9d3acb52cfab5a/folly/synchronization/RWSpinLock.h).\n ///\n /// # Examples\n ///\n@@ -48,6 +52,10 @@ pub struct RwLock<T: ?Sized>\n     data: UnsafeCell<T>,\n }\n \n+const READER: usize = 4;\n+const UPGRADED: usize = 2;\n+const WRITER: usize = 1;\n+\n /// A guard from which the protected data can be read\n ///\n /// When the guard falls out of scope it will decrement the read count,\n@@ -69,12 +77,25 @@ pub struct RwLockWriteGuard<'a, T: 'a + ?Sized>\n     data: &'a mut T,\n }\n \n+/// A guard from which the protected data can be read, and can be upgraded\n+/// to a writable guard if needed\n+/// \n+/// No writers or other upgradeable guards can exist while this is in scope. New reader\n+/// creation is prevented (to alleviate writer starvation) but there may be existing readers\n+/// when the lock is acquired.\n+/// \n+/// When the guard falls out of scope it will release the lock.\n+#[derive(Debug)]\n+pub struct RwLockUpgradeableGuard<'a, T: 'a + ?Sized>\n+{\n+    lock: &'a AtomicUsize,\n+    data: &'a T,\n+}\n+\n // Same unsafe impls as `std::sync::RwLock`\n unsafe impl<T: ?Sized + Send> Send for RwLock<T> {}\n unsafe impl<T: ?Sized + Send + Sync> Sync for RwLock<T> {}\n \n-const USIZE_MSB: usize = ::core::isize::MIN as usize;\n-\n impl<T> RwLock<T>\n {\n     /// Creates a new spinlock wrapping the supplied data.\n@@ -103,6 +124,7 @@ impl<T> RwLock<T>\n     }\n \n     /// Consumes this `RwLock`, returning the underlying data.\n+    #[inline]\n     pub fn into_inner(self) -> T\n     {\n         // We know statically that there are no outstanding references to\n@@ -136,35 +158,13 @@ impl<T: ?Sized> RwLock<T>\n     /// }\n     /// ```\n     #[inline]\n-    pub fn read<'a>(&'a self) -> RwLockReadGuard<'a, T>\n+    pub fn read(&self) -> RwLockReadGuard<T>\n     {\n-        // (funny do-while loop)\n-        while {\n-            // Old value, with write bit unset\n-            let mut old;\n-\n-            // Wait for for writer to go away before doing expensive atomic ops\n-            // (funny do-while loop)\n-            while {\n-                old = self.lock.load(Ordering::Relaxed);\n-                old & USIZE_MSB != 0\n-            } {\n-                cpu_relax();\n+        loop {\n+            match self.try_read() {\n+                Some(guard) => return guard,\n+                None => cpu_relax(),\n             }\n-\n-            // unset write bit\n-            old &= !USIZE_MSB;\n-\n-            let new = old + 1;\n-            debug_assert!(new != (!USIZE_MSB) & (!0));\n-\n-            self.lock.compare_and_swap(old, new, Ordering::SeqCst) != old\n-        } {\n-            cpu_relax();\n-        }\n-        RwLockReadGuard {\n-            lock: &self.lock,\n-            data: unsafe { & *self.data.get() },\n         }\n     }\n \n@@ -193,21 +193,19 @@ impl<T: ?Sized> RwLock<T>\n     #[inline]\n     pub fn try_read(&self) -> Option<RwLockReadGuard<T>>\n     {\n-        // Old value, with write bit unset\n-        let old = (!USIZE_MSB) & self.lock.load(Ordering::Relaxed);\n-\n-        let new = old + 1;\n-        debug_assert!(new != (!USIZE_MSB) & (!0));\n-        if self.lock.compare_and_swap(old,\n-                                      new,\n-                                      Ordering::SeqCst) == old\n-        {\n+        let value = self.lock.fetch_add(READER, Ordering::Acquire);\n+\n+        // We check the UPGRADED bit here so that new readers are prevented when an UPGRADED lock is held.\n+        // This helps reduce writer starvation.\n+        if value & (WRITER | UPGRADED) != 0 {\n+            // Lock is taken, undo.\n+            self.lock.fetch_sub(READER, Ordering::Release);\n+            None\n+        } else {\n             Some(RwLockReadGuard {\n                 lock: &self.lock,\n-                data: unsafe { & *self.data.get() },\n+                data: unsafe { &*self.data.get() },\n             })\n-        } else {\n-            None\n         }\n     }\n \n@@ -216,20 +214,23 @@ impl<T: ?Sized> RwLock<T>\n     /// This is *extremely* unsafe if there are outstanding `RwLockReadGuard`s\n     /// live, or if called more times than `read` has been called, but can be\n     /// useful in FFI contexts where the caller doesn't know how to deal with\n-    /// RAII.\n+    /// RAII. The underlying atomic operation uses `Ordering::Release`.\n+    #[inline]\n     pub unsafe fn force_read_decrement(&self) {\n-        debug_assert!(self.lock.load(Ordering::Relaxed) & (!USIZE_MSB) > 0);\n-        self.lock.fetch_sub(1, Ordering::SeqCst);\n+        debug_assert!(self.lock.load(Ordering::Relaxed) & !WRITER > 0);\n+        self.lock.fetch_sub(READER, Ordering::Release);\n     }\n \n     /// Force unlock exclusive write access.\n     ///\n     /// This is *extremely* unsafe if there are outstanding `RwLockWriteGuard`s\n     /// live, or if called when there are current readers, but can be useful in\n-    /// FFI contexts where the caller doesn't know how to deal with RAII.\n+    /// FFI contexts where the caller doesn't know how to deal with RAII. The\n+    /// underlying atomic operation uses `Ordering::Release`.\n+    #[inline]\n     pub unsafe fn force_write_unlock(&self) {\n-        debug_assert_eq!(self.lock.load(Ordering::Relaxed), USIZE_MSB);\n-        self.lock.store(0, Ordering::Relaxed);\n+        debug_assert_eq!(self.lock.load(Ordering::Relaxed) & !(WRITER | UPGRADED), 0);\n+        self.lock.fetch_and(!(WRITER | UPGRADED), Ordering::Release);\n     }\n \n     /// Lock this rwlock with exclusive write access, blocking the current\n@@ -251,29 +252,20 @@ impl<T: ?Sized> RwLock<T>\n     /// }\n     /// ```\n     #[inline]\n-    pub fn write<'a>(&'a self) -> RwLockWriteGuard<'a, T>\n+    pub fn write(&self) -> RwLockWriteGuard<T>\n     {\n-        loop\n-        {\n-            // Old value, with write bit unset.\n-            let old = (!USIZE_MSB) & self.lock.load(Ordering::Relaxed);\n-            // Old value, with write bit set.\n-            let new = USIZE_MSB | old;\n-            if self.lock.compare_and_swap(old,\n-                                          new,\n-                                          Ordering::SeqCst) == old\n-            {\n-                // Wait for readers to go away, then lock is ours.\n-                while self.lock.load(Ordering::Relaxed) != USIZE_MSB {\n-                    cpu_relax();\n-                }\n-                break\n+        loop {\n+            // Use compare_exchange_weak as a slight optimisation instead of just calling try_write which\n+            // uses compare_exchange (strong) internally.\n+            if self.lock.compare_exchange_weak(0, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {\n+                return RwLockWriteGuard {\n+                    lock: &self.lock,\n+                    data: unsafe { &mut *self.data.get() },\n+                };\n+            } else {\n+                cpu_relax();\n             }\n         }\n-        RwLockWriteGuard {\n-            lock: &self.lock,\n-            data: unsafe { &mut *self.data.get() },\n-        }\n     }\n \n     /// Attempt to lock this rwlock with exclusive write access.\n@@ -298,10 +290,7 @@ impl<T: ?Sized> RwLock<T>\n     #[inline]\n     pub fn try_write(&self) -> Option<RwLockWriteGuard<T>>\n     {\n-        if self.lock.compare_and_swap(0,\n-                                      USIZE_MSB,\n-                                      Ordering::SeqCst) == 0\n-        {\n+        if self.lock.compare_exchange(0, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {\n             Some(RwLockWriteGuard {\n                 lock: &self.lock,\n                 data: unsafe { &mut *self.data.get() },\n@@ -310,6 +299,111 @@ impl<T: ?Sized> RwLock<T>\n             None\n         }\n     }\n+\n+    /// Obtain a readable lock guard that can later be upgraded to a writable lock guard.\n+    /// Upgrades can be done through the [`RwLock::upgrade`](RwLock::upgrade) method.\n+    #[inline]\n+    pub fn upgradeable_read(&self) -> RwLockUpgradeableGuard<T> {\n+        loop {\n+            match self.try_upgradeable_read() {\n+                Some(guard) => return guard,\n+                None => cpu_relax(),\n+            }\n+        }\n+    }\n+\n+    /// Tries to obtain an upgradeable lock guard.\n+    #[inline]\n+    pub fn try_upgradeable_read(&self) -> Option<RwLockUpgradeableGuard<T>> {\n+        if self.lock.fetch_or(UPGRADED, Ordering::Acquire) & (WRITER | UPGRADED) == 0 {\n+            Some(RwLockUpgradeableGuard {\n+                lock: &self.lock,\n+                data: unsafe { &mut *self.data.get() },\n+            })\n+        } else {\n+            // We can't unflip the UPGRADED bit back just yet as there is another upgradeable or write lock. \n+            // When they unlock, they will clear the bit.\n+            None\n+        }\n+    }\n+\n+    /// Upgrades an upgradeable lock guard to a writable lock guard.\n+    /// \n+    /// ```\n+    /// let mylock = spin::RwLock::new(0);\n+    /// \n+    /// let upgradeable = mylock.upgradeable_read(); // Readable, but not yet writable\n+    /// let writable = mylock.upgrade(upgradeable);\n+    /// ```\n+    #[inline]\n+    pub fn upgrade<'a>(&self, guard: RwLockUpgradeableGuard<'a, T>) -> RwLockWriteGuard<T> {\n+        loop {\n+            // Use compare_exchange_weak as a slight optimisation instead of just calling try_upgrade which\n+            // uses compare_exchange (strong) internally.\n+            if self.lock.compare_exchange_weak(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {\n+                // Upgrade successful - forget the old guard so its destructor doesn't run\n+                mem::forget(guard);\n+\n+                return RwLockWriteGuard {\n+                    lock: &self.lock,\n+                    data: unsafe { &mut *self.data.get() },\n+                };\n+            }\n+\n+            cpu_relax();\n+        }\n+    }\n+\n+    /// Tries to upgrade an upgradeable lock guard to a writable lock guard.\n+    /// \n+    /// ```\n+    /// let mylock = spin::RwLock::new(0);\n+    /// let upgradeable = mylock.upgradeable_read(); // Readable, but not yet writable\n+    /// \n+    /// match mylock.try_upgrade(upgradeable) {\n+    ///     Ok(writable) => /* upgrade successful - use writable lock guard */ (),\n+    ///     Err(upgradeable) => /* upgrade unsuccessful */ (),\n+    /// };\n+    /// ```\n+    #[inline]\n+    pub fn try_upgrade<'a>(&self, guard: RwLockUpgradeableGuard<'a, T>) -> Result<RwLockWriteGuard<T>, RwLockUpgradeableGuard<'a, T>> {\n+        if self.lock.compare_exchange(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {\n+            // Upgrade successful - forget the old guard so its destructor doesn't run\n+            mem::forget(guard);\n+\n+            Ok(RwLockWriteGuard {\n+                lock: &self.lock,\n+                data: unsafe { &mut *self.data.get() },\n+            })\n+        } else {\n+            Err(guard)\n+        }\n+    }\n+\n+    /// Downgrades the writable lock guard to a readable, shared lock guard. Cannot fail and is guaranteed not to spin.\n+    /// \n+    /// ```\n+    /// let mylock = spin::RwLock::new(0);\n+    /// \n+    /// let mut writable = mylock.write();\n+    /// *writable = 1;\n+    /// \n+    /// let readable = mylock.downgrade(writable); // This is guaranteed not to spin\n+    /// # let readable_2 = mylock.try_read().unwrap();\n+    /// assert_eq!(*readable, 1);\n+    /// ```\n+    #[inline]\n+    pub fn downgrade<'a>(&self, guard: RwLockWriteGuard<'a, T>) -> RwLockReadGuard<T> {\n+        self.lock.fetch_add(READER, Ordering::Acquire);\n+\n+        // Remove the WRITER bit\n+        mem::drop(guard);\n+\n+        RwLockReadGuard {\n+            lock: &self.lock,\n+            data: unsafe { &*self.data.get() },\n+        }\n+    }\n }\n \n impl<T: ?Sized + fmt::Debug> fmt::Debug for RwLock<T>\n@@ -338,6 +432,12 @@ impl<'rwlock, T: ?Sized> Deref for RwLockReadGuard<'rwlock, T> {\n     fn deref(&self) -> &T { self.data }\n }\n \n+impl<'rwlock, T: ?Sized> Deref for RwLockUpgradeableGuard<'rwlock, T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T { self.data }\n+}\n+\n impl<'rwlock, T: ?Sized> Deref for RwLockWriteGuard<'rwlock, T> {\n     type Target = T;\n \n@@ -350,15 +450,25 @@ impl<'rwlock, T: ?Sized> DerefMut for RwLockWriteGuard<'rwlock, T> {\n \n impl<'rwlock, T: ?Sized> Drop for RwLockReadGuard<'rwlock, T> {\n     fn drop(&mut self) {\n-        debug_assert!(self.lock.load(Ordering::Relaxed) & (!USIZE_MSB) > 0);\n-        self.lock.fetch_sub(1, Ordering::SeqCst);\n+        debug_assert!(self.lock.load(Ordering::Relaxed) & !(WRITER | UPGRADED) > 0);\n+        self.lock.fetch_sub(READER, Ordering::Release);\n+    }\n+}\n+\n+impl<'rwlock, T: ?Sized> Drop for RwLockUpgradeableGuard<'rwlock, T> {\n+    fn drop(&mut self) {\n+        debug_assert_eq!(self.lock.load(Ordering::Relaxed) & (WRITER | UPGRADED), UPGRADED);\n+        self.lock.fetch_sub(UPGRADED, Ordering::AcqRel);\n     }\n }\n \n impl<'rwlock, T: ?Sized> Drop for RwLockWriteGuard<'rwlock, T> {\n     fn drop(&mut self) {\n-        debug_assert_eq!(self.lock.load(Ordering::Relaxed), USIZE_MSB);\n-        self.lock.store(0, Ordering::Relaxed);\n+        debug_assert_eq!(self.lock.load(Ordering::Relaxed) & WRITER, WRITER);\n+        \n+        // Writer is responsible for clearing both WRITER and UPGRADED bits.\n+        // The UPGRADED bit may be set if an upgradeable lock attempts an upgrade while this lock is held.\n+        self.lock.fetch_and(!(WRITER | UPGRADED), Ordering::Release);\n     }\n }\n \n@@ -451,7 +561,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_rw_arc_access_in_unwind() {\n+    fn test_rw_access_in_unwind() {\n         let arc = Arc::new(RwLock::new(1));\n         let arc2 = arc.clone();\n         let _ = thread::spawn(move|| -> () {\n@@ -499,6 +609,13 @@ mod tests {\n         drop(read_guard);\n     }\n \n+    #[test]\n+    fn test_rw_try_read() {\n+        let m = RwLock::new(0);\n+        mem::forget(m.write());\n+        assert!(m.try_read().is_none());\n+    }\n+\n     #[test]\n     fn test_into_inner() {\n         let m = RwLock::new(NonCopy(10));\n@@ -551,4 +668,26 @@ mod tests {\n         }\n         assert!(m.try_read().is_some());\n     }\n+\n+    #[test]\n+    fn test_upgrade() {\n+        let m = RwLock::new(());\n+        {\n+            let _r = m.read();\n+            let upg = m.try_upgradeable_read().unwrap();\n+            assert!(m.try_read().is_none());\n+            assert!(m.try_write().is_none());\n+            assert!(m.try_upgrade(upg).is_err());\n+        }\n+        {\n+            let _w = m.write();\n+            assert!(m.try_upgradeable_read().is_none());\n+        }\n+        {\n+            let _u = m.upgradeable_read();\n+            assert!(m.try_upgradeable_read().is_none());\n+        }\n+\n+        assert!(m.try_upgrade(m.try_upgradeable_read().unwrap()).is_ok());\n+    }\n }\n",
    "diff_parsed": "{'added': [(6, 'use core::mem;'), (55, 'const READER: usize = 4;'), (56, 'const UPGRADED: usize = 2;'), (57, 'const WRITER: usize = 1;'), (88, '#[derive(Debug)]'), (89, \"pub struct RwLockUpgradeableGuard<'a, T: 'a + ?Sized>\"), (90, '{'), (91, \"    lock: &'a AtomicUsize,\"), (92, \"    data: &'a T,\"), (93, '}'), (127, '    #[inline]'), (161, '    pub fn read(&self) -> RwLockReadGuard<T>'), (163, '        loop {'), (164, '            match self.try_read() {'), (165, '                Some(guard) => return guard,'), (166, '                None => cpu_relax(),'), (196, '        let value = self.lock.fetch_add(READER, Ordering::Acquire);'), (200, '        if value & (WRITER | UPGRADED) != 0 {'), (202, '            self.lock.fetch_sub(READER, Ordering::Release);'), (203, '            None'), (204, '        } else {'), (207, '                data: unsafe { &*self.data.get() },'), (218, '    #[inline]'), (220, '        debug_assert!(self.lock.load(Ordering::Relaxed) & !WRITER > 0);'), (221, '        self.lock.fetch_sub(READER, Ordering::Release);'), (230, '    #[inline]'), (232, '        debug_assert_eq!(self.lock.load(Ordering::Relaxed) & !(WRITER | UPGRADED), 0);'), (233, '        self.lock.fetch_and(!(WRITER | UPGRADED), Ordering::Release);'), (255, '    pub fn write(&self) -> RwLockWriteGuard<T>'), (257, '        loop {'), (260, '            if self.lock.compare_exchange_weak(0, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {'), (261, '                return RwLockWriteGuard {'), (262, '                    lock: &self.lock,'), (263, '                    data: unsafe { &mut *self.data.get() },'), (264, '                };'), (265, '            } else {'), (266, '                cpu_relax();'), (293, '        if self.lock.compare_exchange(0, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {'), (305, '    #[inline]'), (306, '    pub fn upgradeable_read(&self) -> RwLockUpgradeableGuard<T> {'), (307, '        loop {'), (308, '            match self.try_upgradeable_read() {'), (309, '                Some(guard) => return guard,'), (310, '                None => cpu_relax(),'), (311, '            }'), (312, '        }'), (313, '    }'), (316, '    #[inline]'), (317, '    pub fn try_upgradeable_read(&self) -> Option<RwLockUpgradeableGuard<T>> {'), (318, '        if self.lock.fetch_or(UPGRADED, Ordering::Acquire) & (WRITER | UPGRADED) == 0 {'), (319, '            Some(RwLockUpgradeableGuard {'), (320, '                lock: &self.lock,'), (321, '                data: unsafe { &mut *self.data.get() },'), (322, '            })'), (323, '        } else {'), (326, '            None'), (327, '        }'), (328, '    }'), (338, '    #[inline]'), (339, \"    pub fn upgrade<'a>(&self, guard: RwLockUpgradeableGuard<'a, T>) -> RwLockWriteGuard<T> {\"), (340, '        loop {'), (343, '            if self.lock.compare_exchange_weak(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {'), (345, '                mem::forget(guard);'), (347, '                return RwLockWriteGuard {'), (348, '                    lock: &self.lock,'), (349, '                    data: unsafe { &mut *self.data.get() },'), (350, '                };'), (351, '            }'), (353, '            cpu_relax();'), (354, '        }'), (355, '    }'), (368, '    #[inline]'), (369, \"    pub fn try_upgrade<'a>(&self, guard: RwLockUpgradeableGuard<'a, T>) -> Result<RwLockWriteGuard<T>, RwLockUpgradeableGuard<'a, T>> {\"), (370, '        if self.lock.compare_exchange(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {'), (372, '            mem::forget(guard);'), (374, '            Ok(RwLockWriteGuard {'), (375, '                lock: &self.lock,'), (376, '                data: unsafe { &mut *self.data.get() },'), (377, '            })'), (378, '        } else {'), (379, '            Err(guard)'), (380, '        }'), (381, '    }'), (395, '    #[inline]'), (396, \"    pub fn downgrade<'a>(&self, guard: RwLockWriteGuard<'a, T>) -> RwLockReadGuard<T> {\"), (397, '        self.lock.fetch_add(READER, Ordering::Acquire);'), (400, '        mem::drop(guard);'), (402, '        RwLockReadGuard {'), (403, '            lock: &self.lock,'), (404, '            data: unsafe { &*self.data.get() },'), (405, '        }'), (406, '    }'), (435, \"impl<'rwlock, T: ?Sized> Deref for RwLockUpgradeableGuard<'rwlock, T> {\"), (436, '    type Target = T;'), (438, '    fn deref(&self) -> &T { self.data }'), (439, '}'), (453, '        debug_assert!(self.lock.load(Ordering::Relaxed) & !(WRITER | UPGRADED) > 0);'), (454, '        self.lock.fetch_sub(READER, Ordering::Release);'), (455, '    }'), (456, '}'), (458, \"impl<'rwlock, T: ?Sized> Drop for RwLockUpgradeableGuard<'rwlock, T> {\"), (459, '    fn drop(&mut self) {'), (460, '        debug_assert_eq!(self.lock.load(Ordering::Relaxed) & (WRITER | UPGRADED), UPGRADED);'), (461, '        self.lock.fetch_sub(UPGRADED, Ordering::AcqRel);'), (467, '        debug_assert_eq!(self.lock.load(Ordering::Relaxed) & WRITER, WRITER);'), (471, '        self.lock.fetch_and(!(WRITER | UPGRADED), Ordering::Release);'), (564, '    fn test_rw_access_in_unwind() {'), (612, '    #[test]'), (613, '    fn test_rw_try_read() {'), (614, '        let m = RwLock::new(0);'), (615, '        mem::forget(m.write());'), (616, '        assert!(m.try_read().is_none());'), (617, '    }'), (672, '    #[test]'), (673, '    fn test_upgrade() {'), (674, '        let m = RwLock::new(());'), (675, '        {'), (676, '            let _r = m.read();'), (677, '            let upg = m.try_upgradeable_read().unwrap();'), (678, '            assert!(m.try_read().is_none());'), (679, '            assert!(m.try_write().is_none());'), (680, '            assert!(m.try_upgrade(upg).is_err());'), (681, '        }'), (682, '        {'), (683, '            let _w = m.write();'), (684, '            assert!(m.try_upgradeable_read().is_none());'), (685, '        }'), (686, '        {'), (687, '            let _u = m.upgradeable_read();'), (688, '            assert!(m.try_upgradeable_read().is_none());'), (689, '        }'), (691, '        assert!(m.try_upgrade(m.try_upgradeable_read().unwrap()).is_ok());'), (692, '    }')], 'deleted': [(76, 'const USIZE_MSB: usize = ::core::isize::MIN as usize;'), (139, \"    pub fn read<'a>(&'a self) -> RwLockReadGuard<'a, T>\"), (142, '        while {'), (144, '            let mut old;'), (148, '            while {'), (149, '                old = self.lock.load(Ordering::Relaxed);'), (150, '                old & USIZE_MSB != 0'), (151, '            } {'), (152, '                cpu_relax();'), (156, '            old &= !USIZE_MSB;'), (158, '            let new = old + 1;'), (159, '            debug_assert!(new != (!USIZE_MSB) & (!0));'), (161, '            self.lock.compare_and_swap(old, new, Ordering::SeqCst) != old'), (162, '        } {'), (163, '            cpu_relax();'), (164, '        }'), (165, '        RwLockReadGuard {'), (166, '            lock: &self.lock,'), (167, '            data: unsafe { & *self.data.get() },'), (197, '        let old = (!USIZE_MSB) & self.lock.load(Ordering::Relaxed);'), (199, '        let new = old + 1;'), (200, '        debug_assert!(new != (!USIZE_MSB) & (!0));'), (201, '        if self.lock.compare_and_swap(old,'), (202, '                                      new,'), (203, '                                      Ordering::SeqCst) == old'), (204, '        {'), (207, '                data: unsafe { & *self.data.get() },'), (209, '        } else {'), (210, '            None'), (221, '        debug_assert!(self.lock.load(Ordering::Relaxed) & (!USIZE_MSB) > 0);'), (222, '        self.lock.fetch_sub(1, Ordering::SeqCst);'), (231, '        debug_assert_eq!(self.lock.load(Ordering::Relaxed), USIZE_MSB);'), (232, '        self.lock.store(0, Ordering::Relaxed);'), (254, \"    pub fn write<'a>(&'a self) -> RwLockWriteGuard<'a, T>\"), (256, '        loop'), (257, '        {'), (259, '            let old = (!USIZE_MSB) & self.lock.load(Ordering::Relaxed);'), (261, '            let new = USIZE_MSB | old;'), (262, '            if self.lock.compare_and_swap(old,'), (263, '                                          new,'), (264, '                                          Ordering::SeqCst) == old'), (265, '            {'), (267, '                while self.lock.load(Ordering::Relaxed) != USIZE_MSB {'), (268, '                    cpu_relax();'), (269, '                }'), (270, '                break'), (273, '        RwLockWriteGuard {'), (274, '            lock: &self.lock,'), (275, '            data: unsafe { &mut *self.data.get() },'), (276, '        }'), (301, '        if self.lock.compare_and_swap(0,'), (302, '                                      USIZE_MSB,'), (303, '                                      Ordering::SeqCst) == 0'), (304, '        {'), (353, '        debug_assert!(self.lock.load(Ordering::Relaxed) & (!USIZE_MSB) > 0);'), (354, '        self.lock.fetch_sub(1, Ordering::SeqCst);'), (360, '        debug_assert_eq!(self.lock.load(Ordering::Relaxed), USIZE_MSB);'), (361, '        self.lock.store(0, Ordering::Relaxed);'), (454, '    fn test_rw_arc_access_in_unwind() {')]}",
    "num_lines_added": "133",
    "num_lines_deleted": "59",
    "nloc": "388"
  },
  {
    "file_change_id": "60081091620819",
    "hash": "6d1c1e335998339263f651f33d34220c4bebc5c",
    "old_path": "src/rw_lock.rs",
    "new_path": "src/rw_lock.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,9 +1,10 @@\n-use core::sync::atomic::{AtomicUsize, Ordering, spin_loop_hint as cpu_relax};\n use core::cell::UnsafeCell;\n-use core::ops::{Deref, DerefMut};\n-use core::fmt;\n use core::default::Default;\n+use core::fmt;\n use core::mem;\n+use core::ops::{Deref, DerefMut};\n+use core::ptr::NonNull;\n+use core::sync::atomic::{spin_loop_hint as cpu_relax, AtomicUsize, Ordering};\n \n /// A reader-writer lock\n ///\n@@ -17,9 +18,12 @@ use core::mem;\n /// allow concurrent access through readers. The RAII guards returned from the\n /// locking methods implement `Deref` (and `DerefMut` for the `write` methods)\n /// to allow access to the contained of the lock.\n-/// \n-/// Read RAII guards are upgradeable to write RAII locks through the\n-/// [`upgrade`](RwLockReadGuard::upgrade) / [`try_upgrade`](RwLockReadGuard::try_upgrade) functions.\n+///\n+/// An [`RwLockUpgradeableGuard`](RwLockUpgradeableGuard) can be upgraded to a\n+/// writable guard through the [`RwLockUpgradeableGuard::upgrade`](RwLockUpgradeableGuard::upgrade)\n+/// [`RwLockUpgradeableGuard::try_upgrade`](RwLockUpgradeableGuard::try_upgrade) functions.\n+/// Writable or upgradeable guards can be downgraded through their respective `downgrade`\n+/// functions.\n ///\n /// Based on Facebook's\n /// [`folly/RWSpinLock.h`](https://github.com/facebook/folly/blob/a0394d84f2d5c3e50ebfd0566f9d3acb52cfab5a/folly/synchronization/RWSpinLock.h).\n@@ -46,8 +50,7 @@ use core::mem;\n ///     assert_eq!(*w, 6);\n /// } // write lock is dropped here\n /// ```\n-pub struct RwLock<T: ?Sized>\n-{\n+pub struct RwLock<T: ?Sized> {\n     lock: AtomicUsize,\n     data: UnsafeCell<T>,\n }\n@@ -61,43 +64,39 @@ const WRITER: usize = 1;\n /// When the guard falls out of scope it will decrement the read count,\n /// potentially releasing the lock.\n #[derive(Debug)]\n-pub struct RwLockReadGuard<'a, T: 'a + ?Sized>\n-{\n+pub struct RwLockReadGuard<'a, T: 'a + ?Sized> {\n     lock: &'a AtomicUsize,\n-    data: &'a T,\n+    data: NonNull<T>,\n }\n \n /// A guard to which the protected data can be written\n ///\n /// When the guard falls out of scope it will release the lock.\n #[derive(Debug)]\n-pub struct RwLockWriteGuard<'a, T: 'a + ?Sized>\n-{\n+pub struct RwLockWriteGuard<'a, T: 'a + ?Sized> {\n     lock: &'a AtomicUsize,\n-    data: &'a mut T,\n+    data: NonNull<T>,\n }\n \n /// A guard from which the protected data can be read, and can be upgraded\n /// to a writable guard if needed\n-/// \n+///\n /// No writers or other upgradeable guards can exist while this is in scope. New reader\n /// creation is prevented (to alleviate writer starvation) but there may be existing readers\n /// when the lock is acquired.\n-/// \n+///\n /// When the guard falls out of scope it will release the lock.\n #[derive(Debug)]\n-pub struct RwLockUpgradeableGuard<'a, T: 'a + ?Sized>\n-{\n+pub struct RwLockUpgradeableGuard<'a, T: 'a + ?Sized> {\n     lock: &'a AtomicUsize,\n-    data: &'a T,\n+    data: NonNull<T>,\n }\n \n // Same unsafe impls as `std::sync::RwLock`\n unsafe impl<T: ?Sized + Send> Send for RwLock<T> {}\n unsafe impl<T: ?Sized + Send + Sync> Sync for RwLock<T> {}\n \n-impl<T> RwLock<T>\n-{\n+impl<T> RwLock<T> {\n     /// Creates a new spinlock wrapping the supplied data.\n     ///\n     /// May be used statically:\n@@ -114,10 +113,8 @@ impl<T> RwLock<T>\n     /// }\n     /// ```\n     #[inline]\n-    pub const fn new(user_data: T) -> RwLock<T>\n-    {\n-        RwLock\n-        {\n+    pub const fn new(user_data: T) -> RwLock<T> {\n+        RwLock {\n             lock: AtomicUsize::new(0),\n             data: UnsafeCell::new(user_data),\n         }\n@@ -125,8 +122,7 @@ impl<T> RwLock<T>\n \n     /// Consumes this `RwLock`, returning the underlying data.\n     #[inline]\n-    pub fn into_inner(self) -> T\n-    {\n+    pub fn into_inner(self) -> T {\n         // We know statically that there are no outstanding references to\n         // `self` so there's no need to lock.\n         let RwLock { data, .. } = self;\n@@ -134,8 +130,7 @@ impl<T> RwLock<T>\n     }\n }\n \n-impl<T: ?Sized> RwLock<T>\n-{\n+impl<T: ?Sized> RwLock<T> {\n     /// Locks this rwlock with shared read access, blocking the current thread\n     /// until it can be acquired.\n     ///\n@@ -158,8 +153,7 @@ impl<T: ?Sized> RwLock<T>\n     /// }\n     /// ```\n     #[inline]\n-    pub fn read(&self) -> RwLockReadGuard<T>\n-    {\n+    pub fn read(&self) -> RwLockReadGuard<T> {\n         loop {\n             match self.try_read() {\n                 Some(guard) => return guard,\n@@ -191,8 +185,7 @@ impl<T: ?Sized> RwLock<T>\n     /// }\n     /// ```\n     #[inline]\n-    pub fn try_read(&self) -> Option<RwLockReadGuard<T>>\n-    {\n+    pub fn try_read(&self) -> Option<RwLockReadGuard<T>> {\n         let value = self.lock.fetch_add(READER, Ordering::Acquire);\n \n         // We check the UPGRADED bit here so that new readers are prevented when an UPGRADED lock is held.\n@@ -204,7 +197,7 @@ impl<T: ?Sized> RwLock<T>\n         } else {\n             Some(RwLockReadGuard {\n                 lock: &self.lock,\n-                data: unsafe { &*self.data.get() },\n+                data: unsafe { NonNull::new_unchecked(self.data.get()) },\n             })\n         }\n     }\n@@ -252,15 +245,18 @@ impl<T: ?Sized> RwLock<T>\n     /// }\n     /// ```\n     #[inline]\n-    pub fn write(&self) -> RwLockWriteGuard<T>\n-    {\n+    pub fn write(&self) -> RwLockWriteGuard<T> {\n         loop {\n             // Use compare_exchange_weak as a slight optimisation instead of just calling try_write which\n             // uses compare_exchange (strong) internally.\n-            if self.lock.compare_exchange_weak(0, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {\n+            if self\n+                .lock\n+                .compare_exchange_weak(0, WRITER, Ordering::Acquire, Ordering::Relaxed)\n+                .is_ok()\n+            {\n                 return RwLockWriteGuard {\n                     lock: &self.lock,\n-                    data: unsafe { &mut *self.data.get() },\n+                    data: unsafe { NonNull::new_unchecked(self.data.get()) },\n                 };\n             } else {\n                 cpu_relax();\n@@ -288,12 +284,15 @@ impl<T: ?Sized> RwLock<T>\n     /// }\n     /// ```\n     #[inline]\n-    pub fn try_write(&self) -> Option<RwLockWriteGuard<T>>\n-    {\n-        if self.lock.compare_exchange(0, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {\n+    pub fn try_write(&self) -> Option<RwLockWriteGuard<T>> {\n+        if self\n+            .lock\n+            .compare_exchange(0, WRITER, Ordering::Acquire, Ordering::Relaxed)\n+            .is_ok()\n+        {\n             Some(RwLockWriteGuard {\n                 lock: &self.lock,\n-                data: unsafe { &mut *self.data.get() },\n+                data: unsafe { NonNull::new_unchecked(self.data.get()) },\n             })\n         } else {\n             None\n@@ -301,7 +300,7 @@ impl<T: ?Sized> RwLock<T>\n     }\n \n     /// Obtain a readable lock guard that can later be upgraded to a writable lock guard.\n-    /// Upgrades can be done through the [`RwLock::upgrade`](RwLock::upgrade) method.\n+    /// Upgrades can be done through the [`RwLockUpgradeableGuard::upgrade`](RwLockUpgradeableGuard::upgrade) method.\n     #[inline]\n     pub fn upgradeable_read(&self) -> RwLockUpgradeableGuard<T> {\n         loop {\n@@ -318,36 +317,62 @@ impl<T: ?Sized> RwLock<T>\n         if self.lock.fetch_or(UPGRADED, Ordering::Acquire) & (WRITER | UPGRADED) == 0 {\n             Some(RwLockUpgradeableGuard {\n                 lock: &self.lock,\n-                data: unsafe { &mut *self.data.get() },\n+                data: unsafe { NonNull::new_unchecked(self.data.get()) },\n             })\n         } else {\n-            // We can't unflip the UPGRADED bit back just yet as there is another upgradeable or write lock. \n+            // We can't unflip the UPGRADED bit back just yet as there is another upgradeable or write lock.\n             // When they unlock, they will clear the bit.\n             None\n         }\n     }\n+}\n \n+impl<T: ?Sized + fmt::Debug> fmt::Debug for RwLock<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.try_read() {\n+            Some(guard) => write!(f, \"RwLock {{ data: \")\n+                .and_then(|()| (&*guard).fmt(f))\n+                .and_then(|()| write!(f, \"}}\")),\n+            None => write!(f, \"RwLock {{ <locked> }}\"),\n+        }\n+    }\n+}\n+\n+impl<T: ?Sized + Default> Default for RwLock<T> {\n+    fn default() -> RwLock<T> {\n+        RwLock::new(Default::default())\n+    }\n+}\n+\n+impl<'rwlock, T: ?Sized> RwLockUpgradeableGuard<'rwlock, T> {\n     /// Upgrades an upgradeable lock guard to a writable lock guard.\n-    /// \n+    ///\n     /// ```\n     /// let mylock = spin::RwLock::new(0);\n-    /// \n+    ///\n     /// let upgradeable = mylock.upgradeable_read(); // Readable, but not yet writable\n-    /// let writable = mylock.upgrade(upgradeable);\n+    /// let writable = upgradeable.upgrade();\n     /// ```\n     #[inline]\n-    pub fn upgrade<'a>(&self, guard: RwLockUpgradeableGuard<'a, T>) -> RwLockWriteGuard<T> {\n+    pub fn upgrade(self) -> RwLockWriteGuard<'rwlock, T> {\n         loop {\n             // Use compare_exchange_weak as a slight optimisation instead of just calling try_upgrade which\n             // uses compare_exchange (strong) internally.\n-            if self.lock.compare_exchange_weak(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {\n-                // Upgrade successful - forget the old guard so its destructor doesn't run\n-                mem::forget(guard);\n-\n-                return RwLockWriteGuard {\n-                    lock: &self.lock,\n-                    data: unsafe { &mut *self.data.get() },\n+            if self\n+                .lock\n+                .compare_exchange_weak(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed)\n+                .is_ok()\n+            {\n+                // Upgrade successful\n+                let out = RwLockWriteGuard {\n+                    lock: self.lock,\n+                    data: self.data,\n                 };\n+\n+                // Forget the old guard so its destructor doesn't run\n+                mem::forget(self);\n+\n+                return out;\n             }\n \n             cpu_relax();\n@@ -355,97 +380,120 @@ impl<T: ?Sized> RwLock<T>\n     }\n \n     /// Tries to upgrade an upgradeable lock guard to a writable lock guard.\n-    /// \n+    ///\n     /// ```\n     /// let mylock = spin::RwLock::new(0);\n     /// let upgradeable = mylock.upgradeable_read(); // Readable, but not yet writable\n-    /// \n-    /// match mylock.try_upgrade(upgradeable) {\n+    ///\n+    /// match upgradeable.try_upgrade() {\n     ///     Ok(writable) => /* upgrade successful - use writable lock guard */ (),\n     ///     Err(upgradeable) => /* upgrade unsuccessful */ (),\n     /// };\n     /// ```\n     #[inline]\n-    pub fn try_upgrade<'a>(&self, guard: RwLockUpgradeableGuard<'a, T>) -> Result<RwLockWriteGuard<T>, RwLockUpgradeableGuard<'a, T>> {\n-        if self.lock.compare_exchange(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {\n-            // Upgrade successful - forget the old guard so its destructor doesn't run\n-            mem::forget(guard);\n-\n-            Ok(RwLockWriteGuard {\n+    pub fn try_upgrade(self) -> Result<RwLockWriteGuard<'rwlock, T>, Self> {\n+        if self\n+            .lock\n+            .compare_exchange(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed)\n+            .is_ok()\n+        {\n+            // Upgrade successful\n+            let out = Ok(RwLockWriteGuard {\n                 lock: &self.lock,\n-                data: unsafe { &mut *self.data.get() },\n-            })\n+                data: self.data,\n+            });\n+\n+            // Forget the old guard so its destructor doesn't run\n+            mem::forget(self);\n+\n+            out\n         } else {\n-            Err(guard)\n+            Err(self)\n+        }\n+    }\n+\n+    #[inline]\n+    /// Downgrades the upgradeable lock guard to a readable, shared lock guard. Cannot fail and is guaranteed not to spin.\n+    ///\n+    /// ```\n+    /// let mylock = spin::RwLock::new(1);\n+    ///\n+    /// let upgradeable = mylock.upgradeable_read();\n+    /// assert!(mylock.try_read().is_none());\n+    /// assert_eq!(*upgradeable, 1);\n+    ///\n+    /// let readable = upgradeable.downgrade(); // This is guaranteed not to spin\n+    /// assert!(mylock.try_read().is_some());\n+    /// assert_eq!(*readable, 1);\n+    /// ```\n+    pub fn downgrade(self) -> RwLockReadGuard<'rwlock, T> {\n+        // Reserve the read guard for ourselves\n+        self.lock.fetch_add(READER, Ordering::Acquire);\n+\n+        RwLockReadGuard {\n+            lock: &self.lock,\n+            data: self.data,\n         }\n+\n+        // Dropping self removes the UPGRADED bit\n     }\n+}\n \n+impl<'rwlock, T: ?Sized> RwLockWriteGuard<'rwlock, T> {\n     /// Downgrades the writable lock guard to a readable, shared lock guard. Cannot fail and is guaranteed not to spin.\n-    /// \n+    ///\n     /// ```\n     /// let mylock = spin::RwLock::new(0);\n-    /// \n+    ///\n     /// let mut writable = mylock.write();\n     /// *writable = 1;\n-    /// \n-    /// let readable = mylock.downgrade(writable); // This is guaranteed not to spin\n+    ///\n+    /// let readable = writable.downgrade(); // This is guaranteed not to spin\n     /// # let readable_2 = mylock.try_read().unwrap();\n     /// assert_eq!(*readable, 1);\n     /// ```\n     #[inline]\n-    pub fn downgrade<'a>(&self, guard: RwLockWriteGuard<'a, T>) -> RwLockReadGuard<T> {\n+    pub fn downgrade(self) -> RwLockReadGuard<'rwlock, T> {\n+        // Reserve the read guard for ourselves\n         self.lock.fetch_add(READER, Ordering::Acquire);\n \n-        // Remove the WRITER bit\n-        mem::drop(guard);\n-\n         RwLockReadGuard {\n             lock: &self.lock,\n-            data: unsafe { &*self.data.get() },\n+            data: self.data,\n         }\n-    }\n-}\n \n-impl<T: ?Sized + fmt::Debug> fmt::Debug for RwLock<T>\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result\n-    {\n-        match self.try_read()\n-        {\n-            Some(guard) => write!(f, \"RwLock {{ data: \")\n-                .and_then(|()| (&*guard).fmt(f))\n-                .and_then(|()| write!(f, \"}}\")),\n-            None => write!(f, \"RwLock {{ <locked> }}\"),\n-        }\n-    }\n-}\n-\n-impl<T: ?Sized + Default> Default for RwLock<T> {\n-    fn default() -> RwLock<T> {\n-        RwLock::new(Default::default())\n+        // Dropping self removes the WRITER bit\n     }\n }\n \n impl<'rwlock, T: ?Sized> Deref for RwLockReadGuard<'rwlock, T> {\n     type Target = T;\n \n-    fn deref(&self) -> &T { self.data }\n+    fn deref(&self) -> &T {\n+        unsafe { self.data.as_ref() }\n+    }\n }\n \n impl<'rwlock, T: ?Sized> Deref for RwLockUpgradeableGuard<'rwlock, T> {\n     type Target = T;\n \n-    fn deref(&self) -> &T { self.data }\n+    fn deref(&self) -> &T {\n+        unsafe { self.data.as_ref() }\n+    }\n }\n \n impl<'rwlock, T: ?Sized> Deref for RwLockWriteGuard<'rwlock, T> {\n     type Target = T;\n \n-    fn deref(&self) -> &T { self.data }\n+    fn deref(&self) -> &T {\n+        unsafe { self.data.as_ref() }\n+    }\n }\n \n impl<'rwlock, T: ?Sized> DerefMut for RwLockWriteGuard<'rwlock, T> {\n-    fn deref_mut(&mut self) -> &mut T { self.data }\n+    fn deref_mut(&mut self) -> &mut T {\n+        unsafe { self.data.as_mut() }\n+    }\n }\n \n impl<'rwlock, T: ?Sized> Drop for RwLockReadGuard<'rwlock, T> {\n@@ -457,7 +505,10 @@ impl<'rwlock, T: ?Sized> Drop for RwLockReadGuard<'rwlock, T> {\n \n impl<'rwlock, T: ?Sized> Drop for RwLockUpgradeableGuard<'rwlock, T> {\n     fn drop(&mut self) {\n-        debug_assert_eq!(self.lock.load(Ordering::Relaxed) & (WRITER | UPGRADED), UPGRADED);\n+        debug_assert_eq!(\n+            self.lock.load(Ordering::Relaxed) & (WRITER | UPGRADED),\n+            UPGRADED\n+        );\n         self.lock.fetch_sub(UPGRADED, Ordering::AcqRel);\n     }\n }\n@@ -465,7 +516,7 @@ impl<'rwlock, T: ?Sized> Drop for RwLockUpgradeableGuard<'rwlock, T> {\n impl<'rwlock, T: ?Sized> Drop for RwLockWriteGuard<'rwlock, T> {\n     fn drop(&mut self) {\n         debug_assert_eq!(self.lock.load(Ordering::Relaxed) & WRITER, WRITER);\n-        \n+\n         // Writer is responsible for clearing both WRITER and UPGRADED bits.\n         // The UPGRADED bit may be set if an upgradeable lock attempts an upgrade while this lock is held.\n         self.lock.fetch_and(!(WRITER | UPGRADED), Ordering::Release);\n@@ -476,9 +527,9 @@ impl<'rwlock, T: ?Sized> Drop for RwLockWriteGuard<'rwlock, T> {\n mod tests {\n     use std::prelude::v1::*;\n \n-    use std::sync::Arc;\n-    use std::sync::mpsc::channel;\n     use std::sync::atomic::{AtomicUsize, Ordering};\n+    use std::sync::mpsc::channel;\n+    use std::sync::Arc;\n     use std::thread;\n \n     use super::*;\n@@ -528,7 +579,7 @@ mod tests {\n         let arc2 = arc.clone();\n         let (tx, rx) = channel();\n \n-        thread::spawn(move|| {\n+        thread::spawn(move || {\n             let mut lock = arc2.write();\n             for _ in 0..10 {\n                 let tmp = *lock;\n@@ -543,7 +594,7 @@ mod tests {\n         let mut children = Vec::new();\n         for _ in 0..5 {\n             let arc3 = arc.clone();\n-            children.push(thread::spawn(move|| {\n+            children.push(thread::spawn(move || {\n                 let lock = arc3.read();\n                 assert!(*lock >= 0);\n             }));\n@@ -564,7 +615,7 @@ mod tests {\n     fn test_rw_access_in_unwind() {\n         let arc = Arc::new(RwLock::new(1));\n         let arc2 = arc.clone();\n-        let _ = thread::spawn(move|| -> () {\n+        let _ = thread::spawn(move || -> () {\n             struct Unwinder {\n                 i: Arc<RwLock<isize>>,\n             }\n@@ -576,7 +627,8 @@ mod tests {\n             }\n             let _u = Unwinder { i: arc2 };\n             panic!();\n-        }).join();\n+        })\n+        .join();\n         let lock = arc.read();\n         assert_eq!(*lock, 2);\n     }\n@@ -603,7 +655,10 @@ mod tests {\n         let write_result = lock.try_write();\n         match write_result {\n             None => (),\n-            Some(_) => assert!(false, \"try_write should not succeed while read_guard is in scope\"),\n+            Some(_) => assert!(\n+                false,\n+                \"try_write should not succeed while read_guard is in scope\"\n+            ),\n         }\n \n         drop(read_guard);\n@@ -670,24 +725,28 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_upgrade() {\n+    fn test_upgrade_downgrade() {\n         let m = RwLock::new(());\n         {\n             let _r = m.read();\n             let upg = m.try_upgradeable_read().unwrap();\n             assert!(m.try_read().is_none());\n             assert!(m.try_write().is_none());\n-            assert!(m.try_upgrade(upg).is_err());\n+            assert!(upg.try_upgrade().is_err());\n         }\n         {\n-            let _w = m.write();\n+            let w = m.write();\n             assert!(m.try_upgradeable_read().is_none());\n+            let _r = w.downgrade();\n+            assert!(m.try_upgradeable_read().is_some());\n+            assert!(m.try_read().is_some());\n+            assert!(m.try_write().is_none());\n         }\n         {\n             let _u = m.upgradeable_read();\n             assert!(m.try_upgradeable_read().is_none());\n         }\n \n-        assert!(m.try_upgrade(m.try_upgradeable_read().unwrap()).is_ok());\n+        assert!(m.try_upgradeable_read().unwrap().try_upgrade().is_ok());\n     }\n }\n",
    "diff_parsed": "{'added': [(3, 'use core::fmt;'), (5, 'use core::ops::{Deref, DerefMut};'), (6, 'use core::ptr::NonNull;'), (7, 'use core::sync::atomic::{spin_loop_hint as cpu_relax, AtomicUsize, Ordering};'), (53, 'pub struct RwLock<T: ?Sized> {'), (67, \"pub struct RwLockReadGuard<'a, T: 'a + ?Sized> {\"), (69, '    data: NonNull<T>,'), (76, \"pub struct RwLockWriteGuard<'a, T: 'a + ?Sized> {\"), (78, '    data: NonNull<T>,'), (90, \"pub struct RwLockUpgradeableGuard<'a, T: 'a + ?Sized> {\"), (92, '    data: NonNull<T>,'), (99, 'impl<T> RwLock<T> {'), (116, '    pub const fn new(user_data: T) -> RwLock<T> {'), (117, '        RwLock {'), (125, '    pub fn into_inner(self) -> T {'), (133, 'impl<T: ?Sized> RwLock<T> {'), (156, '    pub fn read(&self) -> RwLockReadGuard<T> {'), (188, '    pub fn try_read(&self) -> Option<RwLockReadGuard<T>> {'), (200, '                data: unsafe { NonNull::new_unchecked(self.data.get()) },'), (248, '    pub fn write(&self) -> RwLockWriteGuard<T> {'), (252, '            if self'), (253, '                .lock'), (254, '                .compare_exchange_weak(0, WRITER, Ordering::Acquire, Ordering::Relaxed)'), (255, '                .is_ok()'), (256, '            {'), (259, '                    data: unsafe { NonNull::new_unchecked(self.data.get()) },'), (287, '    pub fn try_write(&self) -> Option<RwLockWriteGuard<T>> {'), (288, '        if self'), (289, '            .lock'), (290, '            .compare_exchange(0, WRITER, Ordering::Acquire, Ordering::Relaxed)'), (291, '            .is_ok()'), (292, '        {'), (295, '                data: unsafe { NonNull::new_unchecked(self.data.get()) },'), (320, '                data: unsafe { NonNull::new_unchecked(self.data.get()) },'), (328, '}'), (330, 'impl<T: ?Sized + fmt::Debug> fmt::Debug for RwLock<T> {'), (331, '    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {'), (332, '        match self.try_read() {'), (333, '            Some(guard) => write!(f, \"RwLock {{ data: \")'), (334, '                .and_then(|()| (&*guard).fmt(f))'), (335, '                .and_then(|()| write!(f, \"}}\")),'), (336, '            None => write!(f, \"RwLock {{ <locked> }}\"),'), (337, '        }'), (338, '    }'), (339, '}'), (341, 'impl<T: ?Sized + Default> Default for RwLock<T> {'), (342, '    fn default() -> RwLock<T> {'), (343, '        RwLock::new(Default::default())'), (344, '    }'), (345, '}'), (347, \"impl<'rwlock, T: ?Sized> RwLockUpgradeableGuard<'rwlock, T> {\"), (357, \"    pub fn upgrade(self) -> RwLockWriteGuard<'rwlock, T> {\"), (361, '            if self'), (362, '                .lock'), (363, '                .compare_exchange_weak(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed)'), (364, '                .is_ok()'), (365, '            {'), (367, '                let out = RwLockWriteGuard {'), (368, '                    lock: self.lock,'), (369, '                    data: self.data,'), (373, '                mem::forget(self);'), (375, '                return out;'), (394, \"    pub fn try_upgrade(self) -> Result<RwLockWriteGuard<'rwlock, T>, Self> {\"), (395, '        if self'), (396, '            .lock'), (397, '            .compare_exchange(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed)'), (398, '            .is_ok()'), (399, '        {'), (401, '            let out = Ok(RwLockWriteGuard {'), (403, '                data: self.data,'), (404, '            });'), (407, '            mem::forget(self);'), (409, '            out'), (411, '            Err(self)'), (412, '        }'), (413, '    }'), (415, '    #[inline]'), (429, \"    pub fn downgrade(self) -> RwLockReadGuard<'rwlock, T> {\"), (431, '        self.lock.fetch_add(READER, Ordering::Acquire);'), (433, '        RwLockReadGuard {'), (434, '            lock: &self.lock,'), (435, '            data: self.data,'), (440, '}'), (442, \"impl<'rwlock, T: ?Sized> RwLockWriteGuard<'rwlock, T> {\"), (456, \"    pub fn downgrade(self) -> RwLockReadGuard<'rwlock, T> {\"), (462, '            data: self.data,'), (472, '    fn deref(&self) -> &T {'), (473, '        unsafe { self.data.as_ref() }'), (474, '    }'), (480, '    fn deref(&self) -> &T {'), (481, '        unsafe { self.data.as_ref() }'), (482, '    }'), (488, '    fn deref(&self) -> &T {'), (489, '        unsafe { self.data.as_ref() }'), (490, '    }'), (494, '    fn deref_mut(&mut self) -> &mut T {'), (495, '        unsafe { self.data.as_mut() }'), (496, '    }'), (508, '        debug_assert_eq!('), (509, '            self.lock.load(Ordering::Relaxed) & (WRITER | UPGRADED),'), (510, '            UPGRADED'), (511, '        );'), (531, '    use std::sync::mpsc::channel;'), (532, '    use std::sync::Arc;'), (582, '        thread::spawn(move || {'), (597, '            children.push(thread::spawn(move || {'), (618, '        let _ = thread::spawn(move || -> () {'), (630, '        })'), (631, '        .join();'), (658, '            Some(_) => assert!('), (659, '                false,'), (660, '                \"try_write should not succeed while read_guard is in scope\"'), (661, '            ),'), (728, '    fn test_upgrade_downgrade() {'), (735, '            assert!(upg.try_upgrade().is_err());'), (738, '            let w = m.write();'), (740, '            let _r = w.downgrade();'), (741, '            assert!(m.try_upgradeable_read().is_some());'), (742, '            assert!(m.try_read().is_some());'), (743, '            assert!(m.try_write().is_none());'), (750, '        assert!(m.try_upgradeable_read().unwrap().try_upgrade().is_ok());')], 'deleted': [(1, 'use core::sync::atomic::{AtomicUsize, Ordering, spin_loop_hint as cpu_relax};'), (3, 'use core::ops::{Deref, DerefMut};'), (4, 'use core::fmt;'), (49, 'pub struct RwLock<T: ?Sized>'), (50, '{'), (64, \"pub struct RwLockReadGuard<'a, T: 'a + ?Sized>\"), (65, '{'), (67, \"    data: &'a T,\"), (74, \"pub struct RwLockWriteGuard<'a, T: 'a + ?Sized>\"), (75, '{'), (77, \"    data: &'a mut T,\"), (89, \"pub struct RwLockUpgradeableGuard<'a, T: 'a + ?Sized>\"), (90, '{'), (92, \"    data: &'a T,\"), (99, 'impl<T> RwLock<T>'), (100, '{'), (117, '    pub const fn new(user_data: T) -> RwLock<T>'), (118, '    {'), (119, '        RwLock'), (120, '        {'), (128, '    pub fn into_inner(self) -> T'), (129, '    {'), (137, 'impl<T: ?Sized> RwLock<T>'), (138, '{'), (161, '    pub fn read(&self) -> RwLockReadGuard<T>'), (162, '    {'), (194, '    pub fn try_read(&self) -> Option<RwLockReadGuard<T>>'), (195, '    {'), (207, '                data: unsafe { &*self.data.get() },'), (255, '    pub fn write(&self) -> RwLockWriteGuard<T>'), (256, '    {'), (260, '            if self.lock.compare_exchange_weak(0, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {'), (263, '                    data: unsafe { &mut *self.data.get() },'), (291, '    pub fn try_write(&self) -> Option<RwLockWriteGuard<T>>'), (292, '    {'), (293, '        if self.lock.compare_exchange(0, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {'), (296, '                data: unsafe { &mut *self.data.get() },'), (321, '                data: unsafe { &mut *self.data.get() },'), (339, \"    pub fn upgrade<'a>(&self, guard: RwLockUpgradeableGuard<'a, T>) -> RwLockWriteGuard<T> {\"), (343, '            if self.lock.compare_exchange_weak(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {'), (345, '                mem::forget(guard);'), (347, '                return RwLockWriteGuard {'), (348, '                    lock: &self.lock,'), (349, '                    data: unsafe { &mut *self.data.get() },'), (369, \"    pub fn try_upgrade<'a>(&self, guard: RwLockUpgradeableGuard<'a, T>) -> Result<RwLockWriteGuard<T>, RwLockUpgradeableGuard<'a, T>> {\"), (370, '        if self.lock.compare_exchange(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed).is_ok() {'), (372, '            mem::forget(guard);'), (374, '            Ok(RwLockWriteGuard {'), (376, '                data: unsafe { &mut *self.data.get() },'), (377, '            })'), (379, '            Err(guard)'), (396, \"    pub fn downgrade<'a>(&self, guard: RwLockWriteGuard<'a, T>) -> RwLockReadGuard<T> {\"), (400, '        mem::drop(guard);'), (404, '            data: unsafe { &*self.data.get() },'), (406, '    }'), (407, '}'), (409, 'impl<T: ?Sized + fmt::Debug> fmt::Debug for RwLock<T>'), (410, '{'), (411, '    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result'), (412, '    {'), (413, '        match self.try_read()'), (414, '        {'), (415, '            Some(guard) => write!(f, \"RwLock {{ data: \")'), (416, '                .and_then(|()| (&*guard).fmt(f))'), (417, '                .and_then(|()| write!(f, \"}}\")),'), (418, '            None => write!(f, \"RwLock {{ <locked> }}\"),'), (419, '        }'), (420, '    }'), (421, '}'), (423, 'impl<T: ?Sized + Default> Default for RwLock<T> {'), (424, '    fn default() -> RwLock<T> {'), (425, '        RwLock::new(Default::default())'), (432, '    fn deref(&self) -> &T { self.data }'), (438, '    fn deref(&self) -> &T { self.data }'), (444, '    fn deref(&self) -> &T { self.data }'), (448, '    fn deref_mut(&mut self) -> &mut T { self.data }'), (460, '        debug_assert_eq!(self.lock.load(Ordering::Relaxed) & (WRITER | UPGRADED), UPGRADED);'), (479, '    use std::sync::Arc;'), (480, '    use std::sync::mpsc::channel;'), (531, '        thread::spawn(move|| {'), (546, '            children.push(thread::spawn(move|| {'), (567, '        let _ = thread::spawn(move|| -> () {'), (579, '        }).join();'), (606, '            Some(_) => assert!(false, \"try_write should not succeed while read_guard is in scope\"),'), (673, '    fn test_upgrade() {'), (680, '            assert!(m.try_upgrade(upg).is_err());'), (683, '            let _w = m.write();'), (691, '        assert!(m.try_upgrade(m.try_upgradeable_read().unwrap()).is_ok());')]}",
    "num_lines_added": "121",
    "num_lines_deleted": "88",
    "nloc": "471"
  },
  {
    "file_change_id": "84098656472139",
    "hash": "2aab6e058ae16f9caa3aff2a6bf2602926eb60a",
    "old_path": "src/rw_lock.rs",
    "new_path": "src/rw_lock.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -4,6 +4,7 @@ use core::fmt;\n use core::mem;\n use core::ops::{Deref, DerefMut};\n use core::ptr::NonNull;\n+use core::marker::PhantomData;\n use core::sync::atomic::{spin_loop_hint as cpu_relax, AtomicUsize, Ordering};\n \n /// A reader-writer lock\n@@ -76,6 +77,8 @@ pub struct RwLockReadGuard<'a, T: 'a + ?Sized> {\n pub struct RwLockWriteGuard<'a, T: 'a + ?Sized> {\n     lock: &'a AtomicUsize,\n     data: NonNull<T>,\n+    #[doc(hidden)]\n+    _invariant: PhantomData<&'a mut T>,\n }\n \n /// A guard from which the protected data can be read, and can be upgraded\n@@ -90,6 +93,8 @@ pub struct RwLockWriteGuard<'a, T: 'a + ?Sized> {\n pub struct RwLockUpgradeableGuard<'a, T: 'a + ?Sized> {\n     lock: &'a AtomicUsize,\n     data: NonNull<T>,\n+    #[doc(hidden)]\n+    _invariant: PhantomData<&'a mut T>,\n }\n \n // Same unsafe impls as `std::sync::RwLock`\n@@ -257,6 +262,7 @@ impl<T: ?Sized> RwLock<T> {\n                 return RwLockWriteGuard {\n                     lock: &self.lock,\n                     data: unsafe { NonNull::new_unchecked(self.data.get()) },\n+                    _invariant: PhantomData,\n                 };\n             } else {\n                 cpu_relax();\n@@ -293,6 +299,7 @@ impl<T: ?Sized> RwLock<T> {\n             Some(RwLockWriteGuard {\n                 lock: &self.lock,\n                 data: unsafe { NonNull::new_unchecked(self.data.get()) },\n+                _invariant: PhantomData,\n             })\n         } else {\n             None\n@@ -318,6 +325,7 @@ impl<T: ?Sized> RwLock<T> {\n             Some(RwLockUpgradeableGuard {\n                 lock: &self.lock,\n                 data: unsafe { NonNull::new_unchecked(self.data.get()) },\n+                _invariant: PhantomData,\n             })\n         } else {\n             // We can't unflip the UPGRADED bit back just yet as there is another upgradeable or write lock.\n@@ -367,6 +375,7 @@ impl<'rwlock, T: ?Sized> RwLockUpgradeableGuard<'rwlock, T> {\n                 let out = RwLockWriteGuard {\n                     lock: self.lock,\n                     data: self.data,\n+                    _invariant: PhantomData,\n                 };\n \n                 // Forget the old guard so its destructor doesn't run\n@@ -401,6 +410,7 @@ impl<'rwlock, T: ?Sized> RwLockUpgradeableGuard<'rwlock, T> {\n             let out = Ok(RwLockWriteGuard {\n                 lock: &self.lock,\n                 data: self.data,\n+                _invariant: PhantomData,\n             });\n \n             // Forget the old guard so its destructor doesn't run\n",
    "diff_parsed": "{'added': [(7, 'use core::marker::PhantomData;'), (80, '    #[doc(hidden)]'), (81, \"    _invariant: PhantomData<&'a mut T>,\"), (96, '    #[doc(hidden)]'), (97, \"    _invariant: PhantomData<&'a mut T>,\"), (265, '                    _invariant: PhantomData,'), (302, '                _invariant: PhantomData,'), (328, '                _invariant: PhantomData,'), (378, '                    _invariant: PhantomData,'), (413, '                _invariant: PhantomData,')], 'deleted': []}",
    "num_lines_added": "10",
    "num_lines_deleted": "0",
    "nloc": "490"
  },
  {
    "file_change_id": "66779353852773",
    "hash": "ba0220287e8801d6ecff0de2199b39d2e699698",
    "old_path": "src/rw_lock.rs",
    "new_path": "src/rw_lock.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,10 +1,10 @@\n use core::cell::UnsafeCell;\n use core::default::Default;\n use core::fmt;\n+use core::marker::PhantomData;\n use core::mem;\n use core::ops::{Deref, DerefMut};\n use core::ptr::NonNull;\n-use core::marker::PhantomData;\n use core::sync::atomic::{spin_loop_hint as cpu_relax, AtomicUsize, Ordering};\n \n /// A reader-writer lock\n@@ -231,6 +231,28 @@ impl<T: ?Sized> RwLock<T> {\n         self.lock.fetch_and(!(WRITER | UPGRADED), Ordering::Release);\n     }\n \n+    #[inline(always)]\n+    fn try_write_internal(&self, strong: bool) -> Option<RwLockWriteGuard<T>> {\n+        if compare_exchange(\n+            &self.lock,\n+            0,\n+            WRITER,\n+            Ordering::Acquire,\n+            Ordering::Relaxed,\n+            strong,\n+        )\n+        .is_ok()\n+        {\n+            Some(RwLockWriteGuard {\n+                lock: &self.lock,\n+                data: unsafe { NonNull::new_unchecked(self.data.get()) },\n+                _invariant: PhantomData,\n+            })\n+        } else {\n+            None\n+        }\n+    }\n+\n     /// Lock this rwlock with exclusive write access, blocking the current\n     /// thread until it can be acquired.\n     ///\n@@ -252,20 +274,9 @@ impl<T: ?Sized> RwLock<T> {\n     #[inline]\n     pub fn write(&self) -> RwLockWriteGuard<T> {\n         loop {\n-            // Use compare_exchange_weak as a slight optimisation instead of just calling try_write which\n-            // uses compare_exchange (strong) internally.\n-            if self\n-                .lock\n-                .compare_exchange_weak(0, WRITER, Ordering::Acquire, Ordering::Relaxed)\n-                .is_ok()\n-            {\n-                return RwLockWriteGuard {\n-                    lock: &self.lock,\n-                    data: unsafe { NonNull::new_unchecked(self.data.get()) },\n-                    _invariant: PhantomData,\n-                };\n-            } else {\n-                cpu_relax();\n+            match self.try_write_internal(false) {\n+                Some(guard) => return guard,\n+                None => cpu_relax(),\n             }\n         }\n     }\n@@ -291,19 +302,7 @@ impl<T: ?Sized> RwLock<T> {\n     /// ```\n     #[inline]\n     pub fn try_write(&self) -> Option<RwLockWriteGuard<T>> {\n-        if self\n-            .lock\n-            .compare_exchange(0, WRITER, Ordering::Acquire, Ordering::Relaxed)\n-            .is_ok()\n-        {\n-            Some(RwLockWriteGuard {\n-                lock: &self.lock,\n-                data: unsafe { NonNull::new_unchecked(self.data.get()) },\n-                _invariant: PhantomData,\n-            })\n-        } else {\n-            None\n-        }\n+        self.try_write_internal(false)\n     }\n \n     /// Obtain a readable lock guard that can later be upgraded to a writable lock guard.\n@@ -353,6 +352,34 @@ impl<T: ?Sized + Default> Default for RwLock<T> {\n }\n \n impl<'rwlock, T: ?Sized> RwLockUpgradeableGuard<'rwlock, T> {\n+    #[inline(always)]\n+    fn try_upgrade_internal(self, strong: bool) -> Result<RwLockWriteGuard<'rwlock, T>, Self> {\n+        if compare_exchange(\n+            &self.lock,\n+            UPGRADED,\n+            WRITER,\n+            Ordering::Acquire,\n+            Ordering::Relaxed,\n+            strong,\n+        )\n+        .is_ok()\n+        {\n+            // Upgrade successful\n+            let out = Ok(RwLockWriteGuard {\n+                lock: &self.lock,\n+                data: self.data,\n+                _invariant: PhantomData,\n+            });\n+\n+            // Forget the old guard so its destructor doesn't run\n+            mem::forget(self);\n+\n+            out\n+        } else {\n+            Err(self)\n+        }\n+    }\n+\n     /// Upgrades an upgradeable lock guard to a writable lock guard.\n     ///\n     /// ```\n@@ -362,27 +389,12 @@ impl<'rwlock, T: ?Sized> RwLockUpgradeableGuard<'rwlock, T> {\n     /// let writable = upgradeable.upgrade();\n     /// ```\n     #[inline]\n-    pub fn upgrade(self) -> RwLockWriteGuard<'rwlock, T> {\n+    pub fn upgrade(mut self) -> RwLockWriteGuard<'rwlock, T> {\n         loop {\n-            // Use compare_exchange_weak as a slight optimisation instead of just calling try_upgrade which\n-            // uses compare_exchange (strong) internally.\n-            if self\n-                .lock\n-                .compare_exchange_weak(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed)\n-                .is_ok()\n-            {\n-                // Upgrade successful\n-                let out = RwLockWriteGuard {\n-                    lock: self.lock,\n-                    data: self.data,\n-                    _invariant: PhantomData,\n-                };\n-\n-                // Forget the old guard so its destructor doesn't run\n-                mem::forget(self);\n-\n-                return out;\n-            }\n+            self = match self.try_upgrade_internal(false) {\n+                Ok(guard) => return guard,\n+                Err(e) => e,\n+            };\n \n             cpu_relax();\n         }\n@@ -401,25 +413,7 @@ impl<'rwlock, T: ?Sized> RwLockUpgradeableGuard<'rwlock, T> {\n     /// ```\n     #[inline]\n     pub fn try_upgrade(self) -> Result<RwLockWriteGuard<'rwlock, T>, Self> {\n-        if self\n-            .lock\n-            .compare_exchange(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed)\n-            .is_ok()\n-        {\n-            // Upgrade successful\n-            let out = Ok(RwLockWriteGuard {\n-                lock: &self.lock,\n-                data: self.data,\n-                _invariant: PhantomData,\n-            });\n-\n-            // Forget the old guard so its destructor doesn't run\n-            mem::forget(self);\n-\n-            out\n-        } else {\n-            Err(self)\n-        }\n+        self.try_upgrade_internal(true)\n     }\n \n     #[inline]\n@@ -533,6 +527,22 @@ impl<'rwlock, T: ?Sized> Drop for RwLockWriteGuard<'rwlock, T> {\n     }\n }\n \n+#[inline(always)]\n+fn compare_exchange(\n+    atomic: &AtomicUsize,\n+    current: usize,\n+    new: usize,\n+    success: Ordering,\n+    failure: Ordering,\n+    strong: bool,\n+) -> Result<usize, usize> {\n+    if strong {\n+        atomic.compare_exchange(current, new, success, failure)\n+    } else {\n+        atomic.compare_exchange_weak(current, new, success, failure)\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use std::prelude::v1::*;\n",
    "diff_parsed": "{'added': [(4, 'use core::marker::PhantomData;'), (234, '    #[inline(always)]'), (235, '    fn try_write_internal(&self, strong: bool) -> Option<RwLockWriteGuard<T>> {'), (236, '        if compare_exchange('), (237, '            &self.lock,'), (238, '            0,'), (239, '            WRITER,'), (240, '            Ordering::Acquire,'), (241, '            Ordering::Relaxed,'), (242, '            strong,'), (243, '        )'), (244, '        .is_ok()'), (245, '        {'), (246, '            Some(RwLockWriteGuard {'), (247, '                lock: &self.lock,'), (248, '                data: unsafe { NonNull::new_unchecked(self.data.get()) },'), (249, '                _invariant: PhantomData,'), (250, '            })'), (251, '        } else {'), (252, '            None'), (253, '        }'), (254, '    }'), (277, '            match self.try_write_internal(false) {'), (278, '                Some(guard) => return guard,'), (279, '                None => cpu_relax(),'), (305, '        self.try_write_internal(false)'), (355, '    #[inline(always)]'), (356, \"    fn try_upgrade_internal(self, strong: bool) -> Result<RwLockWriteGuard<'rwlock, T>, Self> {\"), (357, '        if compare_exchange('), (358, '            &self.lock,'), (359, '            UPGRADED,'), (360, '            WRITER,'), (361, '            Ordering::Acquire,'), (362, '            Ordering::Relaxed,'), (363, '            strong,'), (364, '        )'), (365, '        .is_ok()'), (366, '        {'), (368, '            let out = Ok(RwLockWriteGuard {'), (369, '                lock: &self.lock,'), (370, '                data: self.data,'), (371, '                _invariant: PhantomData,'), (372, '            });'), (375, '            mem::forget(self);'), (377, '            out'), (378, '        } else {'), (379, '            Err(self)'), (380, '        }'), (381, '    }'), (392, \"    pub fn upgrade(mut self) -> RwLockWriteGuard<'rwlock, T> {\"), (394, '            self = match self.try_upgrade_internal(false) {'), (395, '                Ok(guard) => return guard,'), (396, '                Err(e) => e,'), (397, '            };'), (416, '        self.try_upgrade_internal(true)'), (530, '#[inline(always)]'), (531, 'fn compare_exchange('), (532, '    atomic: &AtomicUsize,'), (533, '    current: usize,'), (534, '    new: usize,'), (535, '    success: Ordering,'), (536, '    failure: Ordering,'), (537, '    strong: bool,'), (538, ') -> Result<usize, usize> {'), (539, '    if strong {'), (540, '        atomic.compare_exchange(current, new, success, failure)'), (541, '    } else {'), (542, '        atomic.compare_exchange_weak(current, new, success, failure)'), (543, '    }'), (544, '}')], 'deleted': [(7, 'use core::marker::PhantomData;'), (257, '            if self'), (258, '                .lock'), (259, '                .compare_exchange_weak(0, WRITER, Ordering::Acquire, Ordering::Relaxed)'), (260, '                .is_ok()'), (261, '            {'), (262, '                return RwLockWriteGuard {'), (263, '                    lock: &self.lock,'), (264, '                    data: unsafe { NonNull::new_unchecked(self.data.get()) },'), (265, '                    _invariant: PhantomData,'), (266, '                };'), (267, '            } else {'), (268, '                cpu_relax();'), (294, '        if self'), (295, '            .lock'), (296, '            .compare_exchange(0, WRITER, Ordering::Acquire, Ordering::Relaxed)'), (297, '            .is_ok()'), (298, '        {'), (299, '            Some(RwLockWriteGuard {'), (300, '                lock: &self.lock,'), (301, '                data: unsafe { NonNull::new_unchecked(self.data.get()) },'), (302, '                _invariant: PhantomData,'), (303, '            })'), (304, '        } else {'), (305, '            None'), (306, '        }'), (365, \"    pub fn upgrade(self) -> RwLockWriteGuard<'rwlock, T> {\"), (369, '            if self'), (370, '                .lock'), (371, '                .compare_exchange_weak(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed)'), (372, '                .is_ok()'), (373, '            {'), (375, '                let out = RwLockWriteGuard {'), (376, '                    lock: self.lock,'), (377, '                    data: self.data,'), (378, '                    _invariant: PhantomData,'), (379, '                };'), (382, '                mem::forget(self);'), (384, '                return out;'), (385, '            }'), (404, '        if self'), (405, '            .lock'), (406, '            .compare_exchange(UPGRADED, WRITER, Ordering::Acquire, Ordering::Relaxed)'), (407, '            .is_ok()'), (408, '        {'), (410, '            let out = Ok(RwLockWriteGuard {'), (411, '                lock: &self.lock,'), (412, '                data: self.data,'), (413, '                _invariant: PhantomData,'), (414, '            });'), (417, '            mem::forget(self);'), (419, '            out'), (420, '        } else {'), (421, '            Err(self)'), (422, '        }')]}",
    "num_lines_added": "70",
    "num_lines_deleted": "55",
    "nloc": "513"
  },
  {
    "file_change_id": "168099714014287",
    "hash": "4bda3d9e3837e90008de3a26fb0d8182fc5227e",
    "old_path": "src/rw_lock.rs",
    "new_path": "src/rw_lock.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -302,7 +302,7 @@ impl<T: ?Sized> RwLock<T> {\n     /// ```\n     #[inline]\n     pub fn try_write(&self) -> Option<RwLockWriteGuard<T>> {\n-        self.try_write_internal(false)\n+        self.try_write_internal(true)\n     }\n \n     /// Obtain a readable lock guard that can later be upgraded to a writable lock guard.\n",
    "diff_parsed": "{'added': [(305, '        self.try_write_internal(true)')], 'deleted': [(305, '        self.try_write_internal(false)')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "513"
  },
  {
    "file_change_id": "193050187568203",
    "hash": "75cdea2c14c81678dbecdfba67c8b75c583b1cd4",
    "old_path": "src/sys/windows/net.rs",
    "new_path": "src/sys/windows/net.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,10 +1,13 @@\n use std::io;\n-use std::mem::size_of_val;\n+use std::mem;\n use std::net::SocketAddr;\n use std::sync::Once;\n \n use winapi::ctypes::c_int;\n-use winapi::shared::ws2def::SOCKADDR;\n+use winapi::shared::inaddr::IN_ADDR;\n+use winapi::shared::in6addr::IN6_ADDR;\n+use winapi::shared::ws2def::{AF_INET, AF_INET6, ADDRESS_FAMILY, SOCKADDR, SOCKADDR_IN};\n+use winapi::shared::ws2ipdef::SOCKADDR_IN6_LH;\n use winapi::um::winsock2::{ioctlsocket, socket, FIONBIO, INVALID_SOCKET, SOCKET};\n \n /// Initialise the network stack for Windows.\n@@ -41,15 +44,50 @@ pub(crate) fn new_socket(domain: c_int, socket_type: c_int) -> io::Result<SOCKET\n     })\n }\n \n-pub(crate) fn socket_addr(addr: &SocketAddr) -> (*const SOCKADDR, c_int) {\n+/// A type with the same memory layout as `SOCKADDR`. Used in converting Rust level\n+/// SocketAddr* types into their system representation. The benefit of this specific\n+/// type over using `SOCKADDR_STORAGE` is that this type is exactly as large as it\n+/// needs to be and not a lot larger. And it can be initialized cleaner from Rust.\n+#[repr(C)]\n+pub(crate) union SocketAddrCRepr {\n+    v4: SOCKADDR_IN,\n+    v6: SOCKADDR_IN6_LH,\n+}\n+\n+impl SocketAddrCRepr {\n+    pub(crate) fn as_ptr(&self) -> *const SOCKADDR {\n+        self as *const _ as *const SOCKADDR\n+    }\n+}\n+\n+pub(crate) fn socket_addr(addr: &SocketAddr) -> (SocketAddrCRepr, c_int) {\n     match addr {\n-        SocketAddr::V4(ref addr) => (\n-            addr as *const _ as *const SOCKADDR,\n-            size_of_val(addr) as c_int,\n-        ),\n-        SocketAddr::V6(ref addr) => (\n-            addr as *const _ as *const SOCKADDR,\n-            size_of_val(addr) as c_int,\n-        ),\n+        SocketAddr::V4(ref addr) => {\n+            // `s_addr` is stored as BE on all machine and the array is in BE order.\n+            // So the native endian conversion method is used so that it's never swapped.\n+            let sin_addr = IN_ADDR { S_un: unsafe { mem::transmute(u32::from_ne_bytes(addr.ip().octets())) } };\n+\n+            let sockaddr_in = SOCKADDR_IN {\n+                sin_family: AF_INET as ADDRESS_FAMILY,\n+                sin_port: addr.port().to_be(),\n+                sin_addr,\n+                sin_zero: [0; 8],\n+            };\n+\n+            let sockaddr = SocketAddrCRepr { v4: sockaddr_in };\n+            (sockaddr, mem::size_of::<SOCKADDR_IN>() as c_int)\n+        },\n+        SocketAddr::V6(ref addr) => {\n+            let sockaddr_in6 = SOCKADDR_IN6_LH {\n+                sin6_family: AF_INET6 as ADDRESS_FAMILY,\n+                sin6_port: addr.port().to_be(),\n+                sin6_addr: IN6_ADDR { u: unsafe { mem::transmute(addr.ip().octets()) } },\n+                sin6_flowinfo: addr.flowinfo(),\n+                u: unsafe { mem::transmute(addr.scope_id()) },\n+            };\n+\n+            let sockaddr = SocketAddrCRepr { v6: sockaddr_in6 };\n+            (sockaddr, mem::size_of::<SOCKADDR_IN6_LH>() as c_int)\n+        }\n     }\n }\n",
    "diff_parsed": "{'added': [(2, 'use std::mem;'), (7, 'use winapi::shared::inaddr::IN_ADDR;'), (8, 'use winapi::shared::in6addr::IN6_ADDR;'), (9, 'use winapi::shared::ws2def::{AF_INET, AF_INET6, ADDRESS_FAMILY, SOCKADDR, SOCKADDR_IN};'), (10, 'use winapi::shared::ws2ipdef::SOCKADDR_IN6_LH;'), (51, '#[repr(C)]'), (52, 'pub(crate) union SocketAddrCRepr {'), (53, '    v4: SOCKADDR_IN,'), (54, '    v6: SOCKADDR_IN6_LH,'), (55, '}'), (57, 'impl SocketAddrCRepr {'), (58, '    pub(crate) fn as_ptr(&self) -> *const SOCKADDR {'), (59, '        self as *const _ as *const SOCKADDR'), (60, '    }'), (61, '}'), (63, 'pub(crate) fn socket_addr(addr: &SocketAddr) -> (SocketAddrCRepr, c_int) {'), (65, '        SocketAddr::V4(ref addr) => {'), (68, '            let sin_addr = IN_ADDR { S_un: unsafe { mem::transmute(u32::from_ne_bytes(addr.ip().octets())) } };'), (70, '            let sockaddr_in = SOCKADDR_IN {'), (71, '                sin_family: AF_INET as ADDRESS_FAMILY,'), (72, '                sin_port: addr.port().to_be(),'), (73, '                sin_addr,'), (74, '                sin_zero: [0; 8],'), (75, '            };'), (77, '            let sockaddr = SocketAddrCRepr { v4: sockaddr_in };'), (78, '            (sockaddr, mem::size_of::<SOCKADDR_IN>() as c_int)'), (79, '        },'), (80, '        SocketAddr::V6(ref addr) => {'), (81, '            let sockaddr_in6 = SOCKADDR_IN6_LH {'), (82, '                sin6_family: AF_INET6 as ADDRESS_FAMILY,'), (83, '                sin6_port: addr.port().to_be(),'), (84, '                sin6_addr: IN6_ADDR { u: unsafe { mem::transmute(addr.ip().octets()) } },'), (85, '                sin6_flowinfo: addr.flowinfo(),'), (86, '                u: unsafe { mem::transmute(addr.scope_id()) },'), (87, '            };'), (89, '            let sockaddr = SocketAddrCRepr { v6: sockaddr_in6 };'), (90, '            (sockaddr, mem::size_of::<SOCKADDR_IN6_LH>() as c_int)'), (91, '        }')], 'deleted': [(2, 'use std::mem::size_of_val;'), (7, 'use winapi::shared::ws2def::SOCKADDR;'), (44, 'pub(crate) fn socket_addr(addr: &SocketAddr) -> (*const SOCKADDR, c_int) {'), (46, '        SocketAddr::V4(ref addr) => ('), (47, '            addr as *const _ as *const SOCKADDR,'), (48, '            size_of_val(addr) as c_int,'), (49, '        ),'), (50, '        SocketAddr::V6(ref addr) => ('), (51, '            addr as *const _ as *const SOCKADDR,'), (52, '            size_of_val(addr) as c_int,'), (53, '        ),')]}",
    "num_lines_added": "38",
    "num_lines_deleted": "11",
    "nloc": "70"
  },
  {
    "file_change_id": "50445572197387",
    "hash": "75cdea2c14c81678dbecdfba67c8b75c583b1cd4",
    "old_path": "src/sys/windows/tcp.rs",
    "new_path": "src/sys/windows/tcp.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -35,7 +35,7 @@ pub(crate) fn bind(socket: TcpSocket, addr: SocketAddr) -> io::Result<()> {\n \n     let (raw_addr, raw_addr_length) = socket_addr(&addr);\n     syscall!(\n-        bind(socket, raw_addr, raw_addr_length),\n+        bind(socket, raw_addr.as_ptr(), raw_addr_length),\n         PartialEq::eq,\n         SOCKET_ERROR\n     )?;\n@@ -48,7 +48,7 @@ pub(crate) fn connect(socket: TcpSocket, addr: SocketAddr) -> io::Result<net::Tc\n     let (raw_addr, raw_addr_length) = socket_addr(&addr);\n \n     let res = syscall!(\n-        connect(socket, raw_addr, raw_addr_length),\n+        connect(socket, raw_addr.as_ptr(), raw_addr_length),\n         PartialEq::eq,\n         SOCKET_ERROR\n     );\n",
    "diff_parsed": "{'added': [(38, '        bind(socket, raw_addr.as_ptr(), raw_addr_length),'), (51, '        connect(socket, raw_addr.as_ptr(), raw_addr_length),')], 'deleted': [(38, '        bind(socket, raw_addr, raw_addr_length),'), (51, '        connect(socket, raw_addr, raw_addr_length),')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "183"
  },
  {
    "file_change_id": "14055630920322",
    "hash": "75cdea2c14c81678dbecdfba67c8b75c583b1cd4",
    "old_path": "src/sys/windows/udp.rs",
    "new_path": "src/sys/windows/udp.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -12,7 +12,7 @@ pub fn bind(addr: SocketAddr) -> io::Result<net::UdpSocket> {\n     new_ip_socket(addr, SOCK_DGRAM).and_then(|socket| {\n         let (raw_addr, raw_addr_length) = socket_addr(&addr);\n         syscall!(\n-            win_bind(socket, raw_addr, raw_addr_length,),\n+            win_bind(socket, raw_addr.as_ptr(), raw_addr_length,),\n             PartialEq::eq,\n             SOCKET_ERROR\n         )\n",
    "diff_parsed": "{'added': [(15, '            win_bind(socket, raw_addr.as_ptr(), raw_addr_length,),')], 'deleted': [(15, '            win_bind(socket, raw_addr, raw_addr_length,),')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "22"
  },
  {
    "file_change_id": "276761208030008",
    "hash": "a790f9935ab0f74f28d24507c19b7ac0ad0e3b14",
    "old_path": "src/sys/unix/net.rs",
    "new_path": "src/sys/unix/net.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,4 +1,4 @@\n-use std::net::SocketAddr;\n+use std::net::{Ipv4Addr, Ipv6Addr, SocketAddr, SocketAddrV4, SocketAddrV6};\n \n pub(crate) fn new_ip_socket(\n     addr: SocketAddr,\n@@ -64,32 +64,76 @@ pub(crate) fn new_socket(\n     socket\n }\n \n-pub(crate) fn socket_addr(addr: &SocketAddr) -> (*const libc::sockaddr, libc::socklen_t) {\n-    use std::mem::size_of_val;\n+/// A type with the same memory layout as `libc::sockaddr`. Used in converting Rust level\n+/// SocketAddr* types into their system representation. The benefit of this specific\n+/// type over using `libc::sockaddr_storage` is that this type is exactly as large as it\n+/// needs to be and not a lot larger. And it can be initialized cleaner from Rust.\n+#[repr(C)]\n+pub(crate) union SocketAddrCRepr {\n+    v4: libc::sockaddr_in,\n+    v6: libc::sockaddr_in6,\n+}\n+\n+impl SocketAddrCRepr {\n+    pub fn as_ptr(&self) -> *const libc::sockaddr {\n+        self as *const _ as *const libc::sockaddr\n+    }\n+}\n+\n+/// Converts a Rust `SocketAddr` into the system representation.\n+pub(crate) fn socket_addr(addr: &SocketAddr) -> (SocketAddrCRepr, libc::socklen_t) {\n+    use std::mem;\n \n     match addr {\n-        SocketAddr::V4(ref addr) => (\n-            addr as *const _ as *const libc::sockaddr,\n-            size_of_val(addr) as libc::socklen_t,\n-        ),\n-        SocketAddr::V6(ref addr) => (\n-            addr as *const _ as *const libc::sockaddr,\n-            size_of_val(addr) as libc::socklen_t,\n-        ),\n+        SocketAddr::V4(ref a) => {\n+            // `s_addr` is stored as BE on all machine and the array is in BE order.\n+            // So the native endian conversion method is used so that it's never swapped.\n+            let sin_addr = libc::in_addr { s_addr: u32::from_ne_bytes(a.ip().octets()) };\n+\n+            let sockaddr_in = libc::sockaddr_in {\n+                sin_family: libc::AF_INET as libc::sa_family_t,\n+                sin_port: a.port().to_be(),\n+                sin_addr,\n+                ..unsafe { mem::zeroed() }\n+            };\n+\n+            let sockaddr = SocketAddrCRepr { v4: sockaddr_in };\n+            (sockaddr, mem::size_of::<libc::sockaddr_in>() as libc::socklen_t)\n+        }\n+        SocketAddr::V6(ref a) => {\n+            let sockaddr_in6 = libc::sockaddr_in6 {\n+                sin6_family: libc::AF_INET6 as libc::sa_family_t,\n+                sin6_port: a.port().to_be(),\n+                sin6_addr: libc::in6_addr { s6_addr: a.ip().octets() },\n+                sin6_flowinfo: a.flowinfo(),\n+                sin6_scope_id: a.scope_id(),\n+                ..unsafe { mem::zeroed() }\n+            };\n+\n+            let sockaddr = SocketAddrCRepr { v6: sockaddr_in6 };\n+            (sockaddr, mem::size_of::<libc::sockaddr_in6>() as libc::socklen_t)\n+        }\n     }\n }\n \n-/// `storage` must be initialised to `sockaddr_in` or `sockaddr_in6`.\n+/// Converts a `libc::sockaddr` compatible struct into a native Rust `SocketAddr`.\n+/// SAFETY: `storage` must be initialised to `sockaddr_in` or `sockaddr_in6`.\n pub(crate) unsafe fn to_socket_addr(\n     storage: *const libc::sockaddr_storage,\n ) -> std::io::Result<SocketAddr> {\n     match (*storage).ss_family as libc::c_int {\n-        libc::AF_INET => Ok(SocketAddr::V4(\n-            *(storage as *const libc::sockaddr_in as *const _),\n-        )),\n-        libc::AF_INET6 => Ok(SocketAddr::V6(\n-            *(storage as *const libc::sockaddr_in6 as *const _),\n-        )),\n+        libc::AF_INET => {\n+            let addr: &libc::sockaddr_in = &*(storage as *const libc::sockaddr_in);\n+            let ip = Ipv4Addr::from(addr.sin_addr.s_addr.to_ne_bytes());\n+            let port = u16::from_be(addr.sin_port);\n+            Ok(SocketAddr::V4(SocketAddrV4::new(ip, port)))\n+        },\n+        libc::AF_INET6 => {\n+            let addr: &libc::sockaddr_in6 = &*(storage as *const libc::sockaddr_in6);\n+            let ip = Ipv6Addr::from(addr.sin6_addr.s6_addr);\n+            let port = u16::from_be(addr.sin6_port);\n+            Ok(SocketAddr::V6(SocketAddrV6::new(ip, port, addr.sin6_flowinfo, addr.sin6_scope_id)))\n+        },\n         _ => Err(std::io::ErrorKind::InvalidInput.into()),\n     }\n }\n",
    "diff_parsed": "{'added': [(1, 'use std::net::{Ipv4Addr, Ipv6Addr, SocketAddr, SocketAddrV4, SocketAddrV6};'), (71, '#[repr(C)]'), (72, 'pub(crate) union SocketAddrCRepr {'), (73, '    v4: libc::sockaddr_in,'), (74, '    v6: libc::sockaddr_in6,'), (75, '}'), (77, 'impl SocketAddrCRepr {'), (78, '    pub fn as_ptr(&self) -> *const libc::sockaddr {'), (79, '        self as *const _ as *const libc::sockaddr'), (80, '    }'), (81, '}'), (84, 'pub(crate) fn socket_addr(addr: &SocketAddr) -> (SocketAddrCRepr, libc::socklen_t) {'), (85, '    use std::mem;'), (88, '        SocketAddr::V4(ref a) => {'), (91, '            let sin_addr = libc::in_addr { s_addr: u32::from_ne_bytes(a.ip().octets()) };'), (93, '            let sockaddr_in = libc::sockaddr_in {'), (94, '                sin_family: libc::AF_INET as libc::sa_family_t,'), (95, '                sin_port: a.port().to_be(),'), (96, '                sin_addr,'), (97, '                ..unsafe { mem::zeroed() }'), (98, '            };'), (100, '            let sockaddr = SocketAddrCRepr { v4: sockaddr_in };'), (101, '            (sockaddr, mem::size_of::<libc::sockaddr_in>() as libc::socklen_t)'), (102, '        }'), (103, '        SocketAddr::V6(ref a) => {'), (104, '            let sockaddr_in6 = libc::sockaddr_in6 {'), (105, '                sin6_family: libc::AF_INET6 as libc::sa_family_t,'), (106, '                sin6_port: a.port().to_be(),'), (107, '                sin6_addr: libc::in6_addr { s6_addr: a.ip().octets() },'), (108, '                sin6_flowinfo: a.flowinfo(),'), (109, '                sin6_scope_id: a.scope_id(),'), (110, '                ..unsafe { mem::zeroed() }'), (111, '            };'), (113, '            let sockaddr = SocketAddrCRepr { v6: sockaddr_in6 };'), (114, '            (sockaddr, mem::size_of::<libc::sockaddr_in6>() as libc::socklen_t)'), (115, '        }'), (125, '        libc::AF_INET => {'), (126, '            let addr: &libc::sockaddr_in = &*(storage as *const libc::sockaddr_in);'), (127, '            let ip = Ipv4Addr::from(addr.sin_addr.s_addr.to_ne_bytes());'), (128, '            let port = u16::from_be(addr.sin_port);'), (129, '            Ok(SocketAddr::V4(SocketAddrV4::new(ip, port)))'), (130, '        },'), (131, '        libc::AF_INET6 => {'), (132, '            let addr: &libc::sockaddr_in6 = &*(storage as *const libc::sockaddr_in6);'), (133, '            let ip = Ipv6Addr::from(addr.sin6_addr.s6_addr);'), (134, '            let port = u16::from_be(addr.sin6_port);'), (135, '            Ok(SocketAddr::V6(SocketAddrV6::new(ip, port, addr.sin6_flowinfo, addr.sin6_scope_id)))'), (136, '        },')], 'deleted': [(1, 'use std::net::SocketAddr;'), (67, 'pub(crate) fn socket_addr(addr: &SocketAddr) -> (*const libc::sockaddr, libc::socklen_t) {'), (68, '    use std::mem::size_of_val;'), (71, '        SocketAddr::V4(ref addr) => ('), (72, '            addr as *const _ as *const libc::sockaddr,'), (73, '            size_of_val(addr) as libc::socklen_t,'), (74, '        ),'), (75, '        SocketAddr::V6(ref addr) => ('), (76, '            addr as *const _ as *const libc::sockaddr,'), (77, '            size_of_val(addr) as libc::socklen_t,'), (78, '        ),'), (87, '        libc::AF_INET => Ok(SocketAddr::V4('), (88, '            *(storage as *const libc::sockaddr_in as *const _),'), (89, '        )),'), (90, '        libc::AF_INET6 => Ok(SocketAddr::V6('), (91, '            *(storage as *const libc::sockaddr_in6 as *const _),'), (92, '        )),')]}",
    "num_lines_added": "48",
    "num_lines_deleted": "17",
    "nloc": "106"
  },
  {
    "file_change_id": "135552042492666",
    "hash": "a790f9935ab0f74f28d24507c19b7ac0ad0e3b14",
    "old_path": "src/sys/unix/tcp.rs",
    "new_path": "src/sys/unix/tcp.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -20,14 +20,14 @@ pub(crate) fn new_v6_socket() -> io::Result<TcpSocket> {\n \n pub(crate) fn bind(socket: TcpSocket, addr: SocketAddr) -> io::Result<()> {\n     let (raw_addr, raw_addr_length) = socket_addr(&addr);\n-    syscall!(bind(socket, raw_addr, raw_addr_length))?;\n+    syscall!(bind(socket, raw_addr.as_ptr(), raw_addr_length))?;\n     Ok(())\n }\n \n pub(crate) fn connect(socket: TcpSocket, addr: SocketAddr) -> io::Result<net::TcpStream> {\n     let (raw_addr, raw_addr_length) = socket_addr(&addr);\n \n-    match syscall!(connect(socket, raw_addr, raw_addr_length)) {\n+    match syscall!(connect(socket, raw_addr.as_ptr(), raw_addr_length)) {\n         Err(err) if err.raw_os_error() != Some(libc::EINPROGRESS) => {\n             Err(err)\n         }\n",
    "diff_parsed": "{'added': [(23, '    syscall!(bind(socket, raw_addr.as_ptr(), raw_addr_length))?;'), (30, '    match syscall!(connect(socket, raw_addr.as_ptr(), raw_addr_length)) {')], 'deleted': [(23, '    syscall!(bind(socket, raw_addr, raw_addr_length))?;'), (30, '    match syscall!(connect(socket, raw_addr, raw_addr_length)) {')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "187"
  },
  {
    "file_change_id": "89263496396476",
    "hash": "a790f9935ab0f74f28d24507c19b7ac0ad0e3b14",
    "old_path": "src/sys/unix/udp.rs",
    "new_path": "src/sys/unix/udp.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -11,7 +11,7 @@ pub fn bind(addr: SocketAddr) -> io::Result<net::UdpSocket> {\n \n     socket.and_then(|socket| {\n         let (raw_addr, raw_addr_length) = socket_addr(&addr);\n-        syscall!(bind(socket, raw_addr, raw_addr_length))\n+        syscall!(bind(socket, raw_addr.as_ptr(), raw_addr_length))\n             .map_err(|err| {\n                 // Close the socket if we hit an error, ignoring the error\n                 // from closing since we can't pass back two errors.\n",
    "diff_parsed": "{'added': [(14, '        syscall!(bind(socket, raw_addr.as_ptr(), raw_addr_length))')], 'deleted': [(14, '        syscall!(bind(socket, raw_addr, raw_addr_length))')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "17"
  },
  {
    "file_change_id": "254787969022381",
    "hash": "f1320f02cb404ec6e8ad5ef638260dcacc9c8b9",
    "old_path": "matrix/src/lib.rs",
    "new_path": "matrix/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -8,7 +8,10 @@ extern crate basic_dsp_vector;\n \n use basic_dsp_vector::numbers::*;\n use basic_dsp_vector::*;\n-use std::{mem, ptr};\n+use std::{\n+    mem::ManuallyDrop,\n+    ptr\n+};\n \n mod mat_impl;\n pub use self::mat_impl::*;\n@@ -230,13 +233,12 @@ impl<S, D> TransformContent<S, D> for [S; 2] {\n     where\n         F: FnMut(S) -> D,\n     {\n+        let self_forget = ManuallyDrop::new(self);\n         unsafe {\n-            let result = [\n-                conversion(ptr::read(&self[0])),\n-                conversion(ptr::read(&self[1])),\n-            ];\n-            mem::forget(self);\n-            result\n+            [\n+                conversion(ptr::read(&self_forget[0])),\n+                conversion(ptr::read(&self_forget[1])),\n+            ]\n         }\n     }\n \n@@ -244,11 +246,11 @@ impl<S, D> TransformContent<S, D> for [S; 2] {\n     where\n         F: FnMut(S) -> TransRes<D>,\n     {\n+        let self_forget = ManuallyDrop::new(self);\n         unsafe {\n             let mut error = None;\n-            let first = try_conv!(conversion(ptr::read(&self[0])), error);\n-            let second = try_conv!(conversion(ptr::read(&self[1])), error);\n-            mem::forget(self);\n+            let first = try_conv!(conversion(ptr::read(&self_forget[0])), error);\n+            let second = try_conv!(conversion(ptr::read(&self_forget[1])), error);\n \n             match error {\n                 None => Ok([first, second]),\n@@ -265,14 +267,14 @@ impl<S, D> TransformContent<S, D> for [S; 3] {\n     where\n         F: FnMut(S) -> D,\n     {\n+        let self_forget = ManuallyDrop::new(self);\n+        \n         unsafe {\n-            let result = [\n-                conversion(ptr::read(&self[0])),\n-                conversion(ptr::read(&self[1])),\n-                conversion(ptr::read(&self[2])),\n-            ];\n-            mem::forget(self);\n-            result\n+            [\n+                conversion(ptr::read(&self_forget[0])),\n+                conversion(ptr::read(&self_forget[1])),\n+                conversion(ptr::read(&self_forget[2])),\n+            ]\n         }\n     }\n \n@@ -280,12 +282,13 @@ impl<S, D> TransformContent<S, D> for [S; 3] {\n     where\n         F: FnMut(S) -> TransRes<D>,\n     {\n+        let self_forget = ManuallyDrop::new(self);\n+\n         unsafe {\n             let mut error = None;\n-            let first = try_conv!(conversion(ptr::read(&self[0])), error);\n-            let second = try_conv!(conversion(ptr::read(&self[1])), error);\n-            let third = try_conv!(conversion(ptr::read(&self[2])), error);\n-            mem::forget(self);\n+            let first = try_conv!(conversion(ptr::read(&self_forget[0])), error);\n+            let second = try_conv!(conversion(ptr::read(&self_forget[1])), error);\n+            let third = try_conv!(conversion(ptr::read(&self_forget[2])), error);\n \n             match error {\n                 None => Ok([first, second, third]),\n@@ -302,15 +305,15 @@ impl<S, D> TransformContent<S, D> for [S; 4] {\n     where\n         F: FnMut(S) -> D,\n     {\n+        let self_forget = ManuallyDrop::new(self);\n+\n         unsafe {\n-            let result = [\n-                conversion(ptr::read(&self[0])),\n-                conversion(ptr::read(&self[1])),\n-                conversion(ptr::read(&self[2])),\n-                conversion(ptr::read(&self[3])),\n-            ];\n-            mem::forget(self);\n-            result\n+            [\n+                conversion(ptr::read(&self_forget[0])),\n+                conversion(ptr::read(&self_forget[1])),\n+                conversion(ptr::read(&self_forget[2])),\n+                conversion(ptr::read(&self_forget[3])),\n+            ]\n         }\n     }\n \n@@ -318,13 +321,14 @@ impl<S, D> TransformContent<S, D> for [S; 4] {\n     where\n         F: FnMut(S) -> TransRes<D>,\n     {\n+        let self_forget = ManuallyDrop::new(self);\n+\n         unsafe {\n             let mut error = None;\n-            let first = try_conv!(conversion(ptr::read(&self[0])), error);\n-            let second = try_conv!(conversion(ptr::read(&self[1])), error);\n-            let third = try_conv!(conversion(ptr::read(&self[2])), error);\n-            let fourth = try_conv!(conversion(ptr::read(&self[3])), error);\n-            mem::forget(self);\n+            let first = try_conv!(conversion(ptr::read(&self_forget[0])), error);\n+            let second = try_conv!(conversion(ptr::read(&self_forget[1])), error);\n+            let third = try_conv!(conversion(ptr::read(&self_forget[2])), error);\n+            let fourth = try_conv!(conversion(ptr::read(&self_forget[3])), error);\n \n             match error {\n                 None => Ok([first, second, third, fourth]),\n",
    "diff_parsed": "{'added': [(11, 'use std::{'), (12, '    mem::ManuallyDrop,'), (13, '    ptr'), (14, '};'), (236, '        let self_forget = ManuallyDrop::new(self);'), (238, '            ['), (239, '                conversion(ptr::read(&self_forget[0])),'), (240, '                conversion(ptr::read(&self_forget[1])),'), (241, '            ]'), (249, '        let self_forget = ManuallyDrop::new(self);'), (252, '            let first = try_conv!(conversion(ptr::read(&self_forget[0])), error);'), (253, '            let second = try_conv!(conversion(ptr::read(&self_forget[1])), error);'), (270, '        let self_forget = ManuallyDrop::new(self);'), (273, '            ['), (274, '                conversion(ptr::read(&self_forget[0])),'), (275, '                conversion(ptr::read(&self_forget[1])),'), (276, '                conversion(ptr::read(&self_forget[2])),'), (277, '            ]'), (285, '        let self_forget = ManuallyDrop::new(self);'), (289, '            let first = try_conv!(conversion(ptr::read(&self_forget[0])), error);'), (290, '            let second = try_conv!(conversion(ptr::read(&self_forget[1])), error);'), (291, '            let third = try_conv!(conversion(ptr::read(&self_forget[2])), error);'), (308, '        let self_forget = ManuallyDrop::new(self);'), (311, '            ['), (312, '                conversion(ptr::read(&self_forget[0])),'), (313, '                conversion(ptr::read(&self_forget[1])),'), (314, '                conversion(ptr::read(&self_forget[2])),'), (315, '                conversion(ptr::read(&self_forget[3])),'), (316, '            ]'), (324, '        let self_forget = ManuallyDrop::new(self);'), (328, '            let first = try_conv!(conversion(ptr::read(&self_forget[0])), error);'), (329, '            let second = try_conv!(conversion(ptr::read(&self_forget[1])), error);'), (330, '            let third = try_conv!(conversion(ptr::read(&self_forget[2])), error);'), (331, '            let fourth = try_conv!(conversion(ptr::read(&self_forget[3])), error);')], 'deleted': [(11, 'use std::{mem, ptr};'), (234, '            let result = ['), (235, '                conversion(ptr::read(&self[0])),'), (236, '                conversion(ptr::read(&self[1])),'), (237, '            ];'), (238, '            mem::forget(self);'), (239, '            result'), (249, '            let first = try_conv!(conversion(ptr::read(&self[0])), error);'), (250, '            let second = try_conv!(conversion(ptr::read(&self[1])), error);'), (251, '            mem::forget(self);'), (269, '            let result = ['), (270, '                conversion(ptr::read(&self[0])),'), (271, '                conversion(ptr::read(&self[1])),'), (272, '                conversion(ptr::read(&self[2])),'), (273, '            ];'), (274, '            mem::forget(self);'), (275, '            result'), (285, '            let first = try_conv!(conversion(ptr::read(&self[0])), error);'), (286, '            let second = try_conv!(conversion(ptr::read(&self[1])), error);'), (287, '            let third = try_conv!(conversion(ptr::read(&self[2])), error);'), (288, '            mem::forget(self);'), (306, '            let result = ['), (307, '                conversion(ptr::read(&self[0])),'), (308, '                conversion(ptr::read(&self[1])),'), (309, '                conversion(ptr::read(&self[2])),'), (310, '                conversion(ptr::read(&self[3])),'), (311, '            ];'), (312, '            mem::forget(self);'), (313, '            result'), (323, '            let first = try_conv!(conversion(ptr::read(&self[0])), error);'), (324, '            let second = try_conv!(conversion(ptr::read(&self[1])), error);'), (325, '            let third = try_conv!(conversion(ptr::read(&self[2])), error);'), (326, '            let fourth = try_conv!(conversion(ptr::read(&self[3])), error);'), (327, '            mem::forget(self);')]}",
    "num_lines_added": "34",
    "num_lines_deleted": "34",
    "nloc": "278"
  },
  {
    "file_change_id": "191097057925823",
    "hash": "b3a53796b7335d22b9c3d6810dda3fc9acf15df",
    "old_path": "src/header/map.rs",
    "new_path": "src/header/map.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -638,6 +638,8 @@ impl<T> HeaderMap<T> {\n \n         if cap > self.indices.len() {\n             let cap = cap.next_power_of_two();\n+            assert!(cap < MAX_SIZE, \"header map reserve over max capacity\");\n+            assert!(cap != 0, \"header map reserve overflowed\");\n \n             if self.entries.len() == 0 {\n                 self.mask = cap - 1;\n",
    "diff_parsed": "{'added': [(641, '            assert!(cap < MAX_SIZE, \"header map reserve over max capacity\");'), (642, '            assert!(cap != 0, \"header map reserve overflowed\");')], 'deleted': []}",
    "num_lines_added": "2",
    "num_lines_deleted": "0",
    "nloc": "2217"
  },
  {
    "file_change_id": "16384130894850",
    "hash": "b3a53796b7335d22b9c3d6810dda3fc9acf15df",
    "old_path": "tests/header_map.rs",
    "new_path": "tests/header_map.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -37,6 +37,22 @@ fn smoke() {\n     }\n }\n \n+#[test]\n+#[should_panic]\n+fn reserve_over_capacity() {\n+    // See https://github.com/hyperium/http/issues/352\n+    let mut headers = HeaderMap::<u32>::with_capacity(32);\n+    headers.reserve(50_000); // over MAX_SIZE\n+}\n+\n+#[test]\n+#[should_panic]\n+fn reserve_overflow() {\n+    // See https://github.com/hyperium/http/issues/352\n+    let mut headers = HeaderMap::<u32>::with_capacity(0);\n+    headers.reserve(std::usize::MAX); // next_power_of_two overflows\n+}\n+\n #[test]\n fn drain() {\n     let mut headers = HeaderMap::new();\n",
    "diff_parsed": "{'added': [(40, '#[test]'), (41, '#[should_panic]'), (42, 'fn reserve_over_capacity() {'), (44, '    let mut headers = HeaderMap::<u32>::with_capacity(32);'), (45, '    headers.reserve(50_000); // over MAX_SIZE'), (46, '}'), (48, '#[test]'), (49, '#[should_panic]'), (50, 'fn reserve_overflow() {'), (52, '    let mut headers = HeaderMap::<u32>::with_capacity(0);'), (53, '    headers.reserve(std::usize::MAX); // next_power_of_two overflows'), (54, '}')], 'deleted': []}",
    "num_lines_added": "12",
    "num_lines_deleted": "0",
    "nloc": "298"
  },
  {
    "file_change_id": "223975257965290",
    "hash": "a064d69ba4a62d455cab67693cd61e6509db5a1",
    "old_path": "src/ms_queue.rs",
    "new_path": "src/ms_queue.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,6 +1,7 @@\n-use std::sync::atomic::Ordering::{Acquire, Relaxed, Release};\n+use std::mem::{self, ManuallyDrop};\n+use std::ptr;\n use std::sync::atomic::AtomicBool;\n-use std::{mem, ptr};\n+use std::sync::atomic::Ordering::{Acquire, Relaxed, Release};\n use std::thread::{self, Thread};\n \n use epoch::{self, Atomic, Owned, Shared};\n@@ -28,7 +29,7 @@ struct Node<T> {\n #[derive(Debug)]\n enum Payload<T> {\n     /// A node with actual data that can be popped.\n-    Data(T),\n+    Data(ManuallyDrop<T>),\n     /// A node representing a blocked request for data.\n     Blocked(*mut Signal<T>),\n }\n@@ -122,7 +123,7 @@ impl<T> MsQueue<T> {\n             fn into_node(self) -> Owned<Node<T>> {\n                 match self {\n                     Cache::Data(t) => Owned::new(Node {\n-                        payload: Payload::Data(t),\n+                        payload: Payload::Data(ManuallyDrop::new(t)),\n                         next: Atomic::null(),\n                     }),\n                     Cache::Node(n) => n,\n@@ -134,7 +135,7 @@ impl<T> MsQueue<T> {\n                 match self {\n                     Cache::Data(t) => t,\n                     Cache::Node(node) => match (*node.into_box()).payload {\n-                        Payload::Data(t) => t,\n+                        Payload::Data(t) => ManuallyDrop::into_inner(t),\n                         _ => unreachable!(),\n                     },\n                 }\n@@ -195,9 +196,9 @@ impl<T> MsQueue<T> {\n         }\n     }\n \n-    #[inline(always)]\n     // Attempt to pop a data node. `Ok(None)` if queue is empty or in blocking\n     // mode; `Err(())` if lost race to pop.\n+    #[inline(always)]\n     fn pop_internal(&self, guard: &epoch::Guard) -> Result<Option<T>, ()> {\n         let head_shared = self.head.load(Acquire, guard);\n         let head = unsafe { head_shared.as_ref() }.unwrap();\n@@ -210,7 +211,7 @@ impl<T> MsQueue<T> {\n                         .is_ok()\n                     {\n                         guard.defer(move || head_shared.into_owned());\n-                        Ok(Some(ptr::read(t)))\n+                        Ok(Some(ManuallyDrop::into_inner(ptr::read(t))))\n                     } else {\n                         Err(())\n                     }\n",
    "diff_parsed": "{'added': [(1, 'use std::mem::{self, ManuallyDrop};'), (2, 'use std::ptr;'), (4, 'use std::sync::atomic::Ordering::{Acquire, Relaxed, Release};'), (32, '    Data(ManuallyDrop<T>),'), (126, '                        payload: Payload::Data(ManuallyDrop::new(t)),'), (138, '                        Payload::Data(t) => ManuallyDrop::into_inner(t),'), (201, '    #[inline(always)]'), (214, '                        Ok(Some(ManuallyDrop::into_inner(ptr::read(t))))')], 'deleted': [(1, 'use std::sync::atomic::Ordering::{Acquire, Relaxed, Release};'), (3, 'use std::{mem, ptr};'), (31, '    Data(T),'), (125, '                        payload: Payload::Data(t),'), (137, '                        Payload::Data(t) => t,'), (198, '    #[inline(always)]'), (213, '                        Ok(Some(ptr::read(t)))')]}",
    "num_lines_added": "8",
    "num_lines_deleted": "7",
    "nloc": "430"
  },
  {
    "file_change_id": "27774150951501",
    "hash": "a064d69ba4a62d455cab67693cd61e6509db5a1",
    "old_path": "src/seg_queue.rs",
    "new_path": "src/seg_queue.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,9 +1,10 @@\n+use std::cell::UnsafeCell;\n+use std::cmp;\n+use std::fmt;\n+use std::mem::{self, ManuallyDrop};\n+use std::ptr;\n use std::sync::atomic::Ordering::{Acquire, Relaxed, Release};\n use std::sync::atomic::{AtomicBool, AtomicUsize};\n-use std::fmt;\n-use std::{mem, ptr};\n-use std::cmp;\n-use std::cell::UnsafeCell;\n \n use epoch::{self, Atomic, Owned};\n \n@@ -21,7 +22,7 @@ pub struct SegQueue<T> {\n \n struct Segment<T> {\n     low: AtomicUsize,\n-    data: [UnsafeCell<(T, AtomicBool)>; SEG_SIZE],\n+    data: ManuallyDrop<[UnsafeCell<(T, AtomicBool)>; SEG_SIZE]>,\n     high: AtomicUsize,\n     next: Atomic<Segment<T>>,\n }\n@@ -37,7 +38,7 @@ unsafe impl<T: Send> Sync for Segment<T> {}\n impl<T> Segment<T> {\n     fn new() -> Segment<T> {\n         let rqueue = Segment {\n-            data: unsafe { mem::uninitialized() },\n+            data: unsafe { ManuallyDrop::new(mem::uninitialized()) },\n             low: AtomicUsize::new(0),\n             high: AtomicUsize::new(0),\n             next: Atomic::null(),\n",
    "diff_parsed": "{'added': [(1, 'use std::cell::UnsafeCell;'), (2, 'use std::cmp;'), (3, 'use std::fmt;'), (4, 'use std::mem::{self, ManuallyDrop};'), (5, 'use std::ptr;'), (25, '    data: ManuallyDrop<[UnsafeCell<(T, AtomicBool)>; SEG_SIZE]>,'), (41, '            data: unsafe { ManuallyDrop::new(mem::uninitialized()) },')], 'deleted': [(3, 'use std::fmt;'), (4, 'use std::{mem, ptr};'), (5, 'use std::cmp;'), (6, 'use std::cell::UnsafeCell;'), (24, '    data: [UnsafeCell<(T, AtomicBool)>; SEG_SIZE],'), (40, '            data: unsafe { mem::uninitialized() },')]}",
    "num_lines_added": "7",
    "num_lines_deleted": "6",
    "nloc": "265"
  },
  {
    "file_change_id": "66370175490704",
    "hash": "4496dd9c1cf543536c024c6d47f0b62613c75f5",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -33,125 +33,49 @@\n #![warn(missing_docs, missing_debug_implementations, rust_2018_idioms)]\n \n use std::io;\n-use std::mem::{self, MaybeUninit};\n use std::net::{SocketAddr, TcpStream};\n-use std::ptr;\n \n-#[cfg(unix)]\n-use {\n-    libc::{sockaddr, sockaddr_storage, socklen_t},\n-    std::os::unix::net::UnixStream,\n-    std::os::unix::prelude::{FromRawFd, RawFd},\n-    std::path::Path,\n-};\n-\n-#[cfg(windows)]\n-use {\n-    std::os::windows::io::FromRawSocket,\n-    winapi::shared::ws2def::{SOCKADDR as sockaddr, SOCKADDR_STORAGE as sockaddr_storage},\n-    winapi::um::ws2tcpip::socklen_t,\n-};\n-\n-/// A raw socket address.\n-struct Addr {\n-    storage: sockaddr_storage,\n-    len: socklen_t,\n-}\n-\n-impl Addr {\n-    /// Creates a raw socket address from `SocketAddr`.\n-    fn new(addr: SocketAddr) -> Self {\n-        let (addr, len): (*const sockaddr, socklen_t) = match &addr {\n-            SocketAddr::V4(addr) => (addr as *const _ as *const _, mem::size_of_val(addr) as _),\n-            SocketAddr::V6(addr) => (addr as *const _ as *const _, mem::size_of_val(addr) as _),\n-        };\n-        unsafe { Self::from_raw_parts(addr, len) }\n-    }\n-\n-    /// Creates an `Addr` from its raw parts.\n-    unsafe fn from_raw_parts(addr: *const sockaddr, len: socklen_t) -> Self {\n-        let mut storage = MaybeUninit::<sockaddr_storage>::uninit();\n-        ptr::copy_nonoverlapping(\n-            addr as *const _ as *const u8,\n-            &mut storage as *mut _ as *mut u8,\n-            len as usize,\n-        );\n-        Self {\n-            storage: storage.assume_init(),\n-            len,\n-        }\n-    }\n-}\n+use socket2::{Domain, Protocol, SockAddr, Socket, Type};\n \n #[cfg(unix)]\n-fn connect(addr: Addr, family: libc::c_int, protocol: libc::c_int) -> io::Result<RawFd> {\n-    /// Calls a libc function and results in `io::Result`.\n-    macro_rules! syscall {\n-        ($fn:ident $args:tt) => {{\n-            let res = unsafe { libc::$fn $args };\n-            if res == -1 {\n-                Err(std::io::Error::last_os_error())\n-            } else {\n-                Ok(res)\n-            }\n-        }};\n-    }\n-\n-    // A guard that closes the file descriptor if an error occurs before the end.\n-    let mut guard;\n-\n-    // On linux, we pass the `SOCK_CLOEXEC` flag to atomically create the socket and set it as\n-    // CLOEXEC.\n-    #[cfg(target_os = \"linux\")]\n-    let fd = {\n-        let fd = syscall!(socket(\n-            family,\n-            libc::SOCK_STREAM | libc::SOCK_CLOEXEC,\n-            protocol,\n-        ))?;\n-        guard = CallOnDrop(Some(move || drop(syscall!(close(fd)))));\n-        fd\n-    };\n-\n-    // On other systems, we first create the socket and then set it as CLOEXEC.\n-    #[cfg(not(target_os = \"linux\"))]\n-    let fd = {\n-        let fd = syscall!(socket(family, libc::SOCK_STREAM, protocol))?;\n-        guard = CallOnDrop(Some(move || drop(syscall!(close(fd)))));\n-\n-        let flags = syscall!(fcntl(fd, libc::F_GETFD))? | libc::FD_CLOEXEC;\n-        syscall!(fcntl(fd, libc::F_SETFD, flags))?;\n-\n-        #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-        {\n-            let payload = &1i32 as *const i32 as *const libc::c_void;\n-            syscall!(setsockopt(\n-                fd,\n-                libc::SOL_SOCKET,\n-                libc::SO_NOSIGPIPE,\n-                payload,\n-                std::mem::size_of::<i32>() as libc::socklen_t,\n-            ))?;\n-        }\n-        fd\n-    };\n-\n-    // Put socket into non-blocking mode.\n-    let flags = syscall!(fcntl(fd, libc::F_GETFL))? | libc::O_NONBLOCK;\n-    syscall!(fcntl(fd, libc::F_SETFL, flags))?;\n-\n-    // Start connecting.\n-    match syscall!(connect(fd, &addr.storage as *const _ as *const _, addr.len)) {\n+use std::{os::unix::net::UnixStream, path::Path};\n+\n+fn connect(addr: SockAddr, domain: Domain, protocol: Option<Protocol>) -> io::Result<Socket> {\n+    let sock_type = Type::STREAM;\n+    #[cfg(any(\n+        target_os = \"android\",\n+        target_os = \"dragonfly\",\n+        target_os = \"freebsd\",\n+        target_os = \"fuchsia\",\n+        target_os = \"illumos\",\n+        target_os = \"linux\",\n+        target_os = \"netbsd\",\n+        target_os = \"openbsd\"\n+    ))]\n+    // If we can, set nonblocking at socket creation for unix\n+    let sock_type = sock_type.nonblocking();\n+    // This automatically handles cloexec on unix, no_inherit on windows and nosigpipe on macos\n+    let socket = Socket::new(domain, sock_type, protocol)?;\n+    #[cfg(not(any(\n+        target_os = \"android\",\n+        target_os = \"dragonfly\",\n+        target_os = \"freebsd\",\n+        target_os = \"fuchsia\",\n+        target_os = \"illumos\",\n+        target_os = \"linux\",\n+        target_os = \"netbsd\",\n+        target_os = \"openbsd\"\n+    )))]\n+    // If the current platform doesn't support nonblocking at creation, enable it after creation\n+    socket.set_nonblocking(true)?;\n+    match socket.connect(&addr) {\n         Ok(_) => {}\n+        #[cfg(unix)]\n         Err(err) if err.raw_os_error() == Some(libc::EINPROGRESS) => {}\n         Err(err) if err.kind() == io::ErrorKind::WouldBlock => {}\n         Err(err) => return Err(err),\n     }\n-\n-    // Disarm the guard so that it doesn't close the file descriptor.\n-    guard.0.take();\n-\n-    Ok(fd)\n+    Ok(socket)\n }\n \n /// Creates a pending Unix connection to the specified path.\n@@ -184,52 +108,8 @@ fn connect(addr: Addr, family: libc::c_int, protocol: libc::c_int) -> io::Result\n /// ```\n #[cfg(unix)]\n pub fn unix<P: AsRef<Path>>(path: P) -> io::Result<UnixStream> {\n-    use std::cmp::Ordering;\n-    use std::os::unix::ffi::OsStrExt;\n-\n-    let addr = unsafe {\n-        let mut addr = mem::zeroed::<libc::sockaddr_un>();\n-        addr.sun_family = libc::AF_UNIX as libc::sa_family_t;\n-\n-        let bytes = path.as_ref().as_os_str().as_bytes();\n-\n-        match (bytes.get(0), bytes.len().cmp(&addr.sun_path.len())) {\n-            // Abstract paths don't need a null terminator\n-            (Some(&0), Ordering::Greater) => {\n-                return Err(io::Error::new(\n-                    io::ErrorKind::InvalidInput,\n-                    \"path must be no longer than SUN_LEN\",\n-                ));\n-            }\n-            (Some(&0), _) => {}\n-            (_, Ordering::Greater) | (_, Ordering::Equal) => {\n-                return Err(io::Error::new(\n-                    io::ErrorKind::InvalidInput,\n-                    \"path must be shorter than SUN_LEN\",\n-                ));\n-            }\n-            _ => {}\n-        }\n-\n-        for (dst, src) in addr.sun_path.iter_mut().zip(bytes) {\n-            *dst = *src as libc::c_char;\n-        }\n-        // null byte for pathname is already there since we zeroed up front\n-\n-        let base = &addr as *const _ as usize;\n-        let path = &addr.sun_path as *const _ as usize;\n-        let sun_path_offset = path - base;\n-\n-        let mut len = sun_path_offset + bytes.len();\n-        match bytes.get(0) {\n-            Some(&0) | None => {}\n-            Some(_) => len += 1,\n-        }\n-        Addr::from_raw_parts(&addr as *const _ as *const _, len as libc::socklen_t)\n-    };\n-\n-    let fd = connect(addr, libc::AF_UNIX, 0)?;\n-    unsafe { Ok(UnixStream::from_raw_fd(fd)) }\n+    let socket = connect(SockAddr::unix(path)?, Domain::UNIX, None)?;\n+    Ok(socket.into())\n }\n \n /// Creates a pending TCP connection to the specified address.\n@@ -263,99 +143,8 @@ pub fn unix<P: AsRef<Path>>(path: P) -> io::Result<UnixStream> {\n /// # std::io::Result::Ok(())\n /// ```\n pub fn tcp<A: Into<SocketAddr>>(addr: A) -> io::Result<TcpStream> {\n-    tcp_connect(addr.into())\n-}\n-\n-#[cfg(unix)]\n-fn tcp_connect(addr: SocketAddr) -> io::Result<TcpStream> {\n     let addr = addr.into();\n-    let fd = connect(\n-        Addr::new(addr),\n-        if addr.is_ipv6() {\n-            libc::AF_INET6\n-        } else {\n-            libc::AF_INET\n-        },\n-        libc::IPPROTO_TCP,\n-    )?;\n-    unsafe { Ok(TcpStream::from_raw_fd(fd)) }\n-}\n-\n-#[cfg(windows)]\n-fn tcp_connect(addr: SocketAddr) -> io::Result<TcpStream> {\n-    use std::net::UdpSocket;\n-    use std::sync::Once;\n-\n-    use winapi::ctypes::{c_int, c_ulong};\n-    use winapi::shared::minwindef::DWORD;\n-    use winapi::shared::ntdef::HANDLE;\n-    use winapi::shared::ws2def::{AF_INET, AF_INET6, IPPROTO_TCP, SOCK_STREAM};\n-    use winapi::um::handleapi::SetHandleInformation;\n-    use winapi::um::winsock2 as sock;\n-\n-    static INIT: Once = Once::new();\n-    INIT.call_once(|| {\n-        // Initialize winsock through the standard library by just creating a dummy socket.\n-        // Whether this is successful or not we drop the result as libstd will be sure to have\n-        // initialized winsock.\n-        let _ = UdpSocket::bind(\"127.0.0.1:34254\");\n-    });\n-\n-    const HANDLE_FLAG_INHERIT: DWORD = 0x00000001;\n-    const WSA_FLAG_OVERLAPPED: DWORD = 0x01;\n-\n-    let family = if addr.is_ipv6() { AF_INET6 } else { AF_INET };\n-    let addr = Addr::new(addr);\n-\n-    unsafe {\n-        let socket = match sock::WSASocketW(\n-            family,\n-            SOCK_STREAM,\n-            IPPROTO_TCP as _,\n-            ptr::null_mut(),\n-            0,\n-            WSA_FLAG_OVERLAPPED,\n-        ) {\n-            sock::INVALID_SOCKET => {\n-                return Err(io::Error::from_raw_os_error(sock::WSAGetLastError()))\n-            }\n-            socket => socket,\n-        };\n-\n-        // Create a TCP stream now so that it closes the socket if an error occurs before the end.\n-        let stream = TcpStream::from_raw_socket(socket as _);\n-\n-        // Set no inherit.\n-        if SetHandleInformation(socket as HANDLE, HANDLE_FLAG_INHERIT, 0) == 0 {\n-            return Err(io::Error::last_os_error());\n-        }\n-\n-        // Put socket into nonblocking mode.\n-        let mut nonblocking = true as c_ulong;\n-        if sock::ioctlsocket(socket, sock::FIONBIO as c_int, &mut nonblocking) != 0 {\n-            return Err(io::Error::last_os_error());\n-        }\n-\n-        // Start connecting.\n-        match sock::connect(socket, &addr.storage as *const _ as *const _, addr.len) {\n-            0 => {}\n-            _ => match io::Error::from_raw_os_error(sock::WSAGetLastError()) {\n-                err if err.kind() == io::ErrorKind::WouldBlock => {}\n-                err => return Err(err),\n-            },\n-        }\n-\n-        Ok(stream)\n-    }\n-}\n-\n-/// Runs a closure when dropped.\n-struct CallOnDrop<F: FnOnce()>(Option<F>);\n-\n-impl<F: FnOnce()> Drop for CallOnDrop<F> {\n-    fn drop(&mut self) {\n-        if let Some(f) = self.0.take() {\n-            f();\n-        }\n-    }\n+    let domain = Domain::for_address(addr);\n+    let socket = connect(addr.into(), domain, Some(Protocol::TCP))?;\n+    Ok(socket.into())\n }\n",
    "diff_parsed": "{'added': [(38, 'use socket2::{Domain, Protocol, SockAddr, Socket, Type};'), (41, 'use std::{os::unix::net::UnixStream, path::Path};'), (43, 'fn connect(addr: SockAddr, domain: Domain, protocol: Option<Protocol>) -> io::Result<Socket> {'), (44, '    let sock_type = Type::STREAM;'), (45, '    #[cfg(any('), (46, '        target_os = \"android\",'), (47, '        target_os = \"dragonfly\",'), (48, '        target_os = \"freebsd\",'), (49, '        target_os = \"fuchsia\",'), (50, '        target_os = \"illumos\",'), (51, '        target_os = \"linux\",'), (52, '        target_os = \"netbsd\",'), (53, '        target_os = \"openbsd\"'), (54, '    ))]'), (56, '    let sock_type = sock_type.nonblocking();'), (58, '    let socket = Socket::new(domain, sock_type, protocol)?;'), (59, '    #[cfg(not(any('), (60, '        target_os = \"android\",'), (61, '        target_os = \"dragonfly\",'), (62, '        target_os = \"freebsd\",'), (63, '        target_os = \"fuchsia\",'), (64, '        target_os = \"illumos\",'), (65, '        target_os = \"linux\",'), (66, '        target_os = \"netbsd\",'), (67, '        target_os = \"openbsd\"'), (68, '    )))]'), (70, '    socket.set_nonblocking(true)?;'), (71, '    match socket.connect(&addr) {'), (73, '        #[cfg(unix)]'), (78, '    Ok(socket)'), (111, '    let socket = connect(SockAddr::unix(path)?, Domain::UNIX, None)?;'), (112, '    Ok(socket.into())'), (147, '    let domain = Domain::for_address(addr);'), (148, '    let socket = connect(addr.into(), domain, Some(Protocol::TCP))?;'), (149, '    Ok(socket.into())')], 'deleted': [(36, 'use std::mem::{self, MaybeUninit};'), (38, 'use std::ptr;'), (40, '#[cfg(unix)]'), (41, 'use {'), (42, '    libc::{sockaddr, sockaddr_storage, socklen_t},'), (43, '    std::os::unix::net::UnixStream,'), (44, '    std::os::unix::prelude::{FromRawFd, RawFd},'), (45, '    std::path::Path,'), (46, '};'), (48, '#[cfg(windows)]'), (49, 'use {'), (50, '    std::os::windows::io::FromRawSocket,'), (51, '    winapi::shared::ws2def::{SOCKADDR as sockaddr, SOCKADDR_STORAGE as sockaddr_storage},'), (52, '    winapi::um::ws2tcpip::socklen_t,'), (53, '};'), (56, 'struct Addr {'), (57, '    storage: sockaddr_storage,'), (58, '    len: socklen_t,'), (59, '}'), (61, 'impl Addr {'), (63, '    fn new(addr: SocketAddr) -> Self {'), (64, '        let (addr, len): (*const sockaddr, socklen_t) = match &addr {'), (65, '            SocketAddr::V4(addr) => (addr as *const _ as *const _, mem::size_of_val(addr) as _),'), (66, '            SocketAddr::V6(addr) => (addr as *const _ as *const _, mem::size_of_val(addr) as _),'), (67, '        };'), (68, '        unsafe { Self::from_raw_parts(addr, len) }'), (69, '    }'), (72, '    unsafe fn from_raw_parts(addr: *const sockaddr, len: socklen_t) -> Self {'), (73, '        let mut storage = MaybeUninit::<sockaddr_storage>::uninit();'), (74, '        ptr::copy_nonoverlapping('), (75, '            addr as *const _ as *const u8,'), (76, '            &mut storage as *mut _ as *mut u8,'), (77, '            len as usize,'), (78, '        );'), (79, '        Self {'), (80, '            storage: storage.assume_init(),'), (81, '            len,'), (82, '        }'), (83, '    }'), (84, '}'), (87, 'fn connect(addr: Addr, family: libc::c_int, protocol: libc::c_int) -> io::Result<RawFd> {'), (89, '    macro_rules! syscall {'), (90, '        ($fn:ident $args:tt) => {{'), (91, '            let res = unsafe { libc::$fn $args };'), (92, '            if res == -1 {'), (93, '                Err(std::io::Error::last_os_error())'), (94, '            } else {'), (95, '                Ok(res)'), (96, '            }'), (97, '        }};'), (98, '    }'), (101, '    let mut guard;'), (105, '    #[cfg(target_os = \"linux\")]'), (106, '    let fd = {'), (107, '        let fd = syscall!(socket('), (108, '            family,'), (109, '            libc::SOCK_STREAM | libc::SOCK_CLOEXEC,'), (110, '            protocol,'), (111, '        ))?;'), (112, '        guard = CallOnDrop(Some(move || drop(syscall!(close(fd)))));'), (113, '        fd'), (114, '    };'), (117, '    #[cfg(not(target_os = \"linux\"))]'), (118, '    let fd = {'), (119, '        let fd = syscall!(socket(family, libc::SOCK_STREAM, protocol))?;'), (120, '        guard = CallOnDrop(Some(move || drop(syscall!(close(fd)))));'), (122, '        let flags = syscall!(fcntl(fd, libc::F_GETFD))? | libc::FD_CLOEXEC;'), (123, '        syscall!(fcntl(fd, libc::F_SETFD, flags))?;'), (125, '        #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]'), (126, '        {'), (127, '            let payload = &1i32 as *const i32 as *const libc::c_void;'), (128, '            syscall!(setsockopt('), (129, '                fd,'), (130, '                libc::SOL_SOCKET,'), (131, '                libc::SO_NOSIGPIPE,'), (132, '                payload,'), (133, '                std::mem::size_of::<i32>() as libc::socklen_t,'), (134, '            ))?;'), (135, '        }'), (136, '        fd'), (137, '    };'), (140, '    let flags = syscall!(fcntl(fd, libc::F_GETFL))? | libc::O_NONBLOCK;'), (141, '    syscall!(fcntl(fd, libc::F_SETFL, flags))?;'), (144, '    match syscall!(connect(fd, &addr.storage as *const _ as *const _, addr.len)) {'), (152, '    guard.0.take();'), (154, '    Ok(fd)'), (187, '    use std::cmp::Ordering;'), (188, '    use std::os::unix::ffi::OsStrExt;'), (190, '    let addr = unsafe {'), (191, '        let mut addr = mem::zeroed::<libc::sockaddr_un>();'), (192, '        addr.sun_family = libc::AF_UNIX as libc::sa_family_t;'), (194, '        let bytes = path.as_ref().as_os_str().as_bytes();'), (196, '        match (bytes.get(0), bytes.len().cmp(&addr.sun_path.len())) {'), (198, '            (Some(&0), Ordering::Greater) => {'), (199, '                return Err(io::Error::new('), (200, '                    io::ErrorKind::InvalidInput,'), (201, '                    \"path must be no longer than SUN_LEN\",'), (202, '                ));'), (203, '            }'), (204, '            (Some(&0), _) => {}'), (205, '            (_, Ordering::Greater) | (_, Ordering::Equal) => {'), (206, '                return Err(io::Error::new('), (207, '                    io::ErrorKind::InvalidInput,'), (208, '                    \"path must be shorter than SUN_LEN\",'), (209, '                ));'), (210, '            }'), (211, '            _ => {}'), (212, '        }'), (214, '        for (dst, src) in addr.sun_path.iter_mut().zip(bytes) {'), (215, '            *dst = *src as libc::c_char;'), (216, '        }'), (219, '        let base = &addr as *const _ as usize;'), (220, '        let path = &addr.sun_path as *const _ as usize;'), (221, '        let sun_path_offset = path - base;'), (223, '        let mut len = sun_path_offset + bytes.len();'), (224, '        match bytes.get(0) {'), (225, '            Some(&0) | None => {}'), (226, '            Some(_) => len += 1,'), (227, '        }'), (228, '        Addr::from_raw_parts(&addr as *const _ as *const _, len as libc::socklen_t)'), (229, '    };'), (231, '    let fd = connect(addr, libc::AF_UNIX, 0)?;'), (232, '    unsafe { Ok(UnixStream::from_raw_fd(fd)) }'), (266, '    tcp_connect(addr.into())'), (267, '}'), (269, '#[cfg(unix)]'), (270, 'fn tcp_connect(addr: SocketAddr) -> io::Result<TcpStream> {'), (272, '    let fd = connect('), (273, '        Addr::new(addr),'), (274, '        if addr.is_ipv6() {'), (275, '            libc::AF_INET6'), (276, '        } else {'), (277, '            libc::AF_INET'), (278, '        },'), (279, '        libc::IPPROTO_TCP,'), (280, '    )?;'), (281, '    unsafe { Ok(TcpStream::from_raw_fd(fd)) }'), (282, '}'), (284, '#[cfg(windows)]'), (285, 'fn tcp_connect(addr: SocketAddr) -> io::Result<TcpStream> {'), (286, '    use std::net::UdpSocket;'), (287, '    use std::sync::Once;'), (289, '    use winapi::ctypes::{c_int, c_ulong};'), (290, '    use winapi::shared::minwindef::DWORD;'), (291, '    use winapi::shared::ntdef::HANDLE;'), (292, '    use winapi::shared::ws2def::{AF_INET, AF_INET6, IPPROTO_TCP, SOCK_STREAM};'), (293, '    use winapi::um::handleapi::SetHandleInformation;'), (294, '    use winapi::um::winsock2 as sock;'), (296, '    static INIT: Once = Once::new();'), (297, '    INIT.call_once(|| {'), (301, '        let _ = UdpSocket::bind(\"127.0.0.1:34254\");'), (302, '    });'), (304, '    const HANDLE_FLAG_INHERIT: DWORD = 0x00000001;'), (305, '    const WSA_FLAG_OVERLAPPED: DWORD = 0x01;'), (307, '    let family = if addr.is_ipv6() { AF_INET6 } else { AF_INET };'), (308, '    let addr = Addr::new(addr);'), (310, '    unsafe {'), (311, '        let socket = match sock::WSASocketW('), (312, '            family,'), (313, '            SOCK_STREAM,'), (314, '            IPPROTO_TCP as _,'), (315, '            ptr::null_mut(),'), (316, '            0,'), (317, '            WSA_FLAG_OVERLAPPED,'), (318, '        ) {'), (319, '            sock::INVALID_SOCKET => {'), (320, '                return Err(io::Error::from_raw_os_error(sock::WSAGetLastError()))'), (321, '            }'), (322, '            socket => socket,'), (323, '        };'), (326, '        let stream = TcpStream::from_raw_socket(socket as _);'), (329, '        if SetHandleInformation(socket as HANDLE, HANDLE_FLAG_INHERIT, 0) == 0 {'), (330, '            return Err(io::Error::last_os_error());'), (331, '        }'), (334, '        let mut nonblocking = true as c_ulong;'), (335, '        if sock::ioctlsocket(socket, sock::FIONBIO as c_int, &mut nonblocking) != 0 {'), (336, '            return Err(io::Error::last_os_error());'), (337, '        }'), (340, '        match sock::connect(socket, &addr.storage as *const _ as *const _, addr.len) {'), (341, '            0 => {}'), (342, '            _ => match io::Error::from_raw_os_error(sock::WSAGetLastError()) {'), (343, '                err if err.kind() == io::ErrorKind::WouldBlock => {}'), (344, '                err => return Err(err),'), (345, '            },'), (346, '        }'), (348, '        Ok(stream)'), (349, '    }'), (350, '}'), (353, 'struct CallOnDrop<F: FnOnce()>(Option<F>);'), (355, 'impl<F: FnOnce()> Drop for CallOnDrop<F> {'), (356, '    fn drop(&mut self) {'), (357, '        if let Some(f) = self.0.take() {'), (358, '            f();'), (359, '        }'), (360, '    }')]}",
    "num_lines_added": "35",
    "num_lines_deleted": "195",
    "nloc": "51"
  },
  {
    "file_change_id": "85065173242332",
    "hash": "4ba0d0f689440963e38b8adbe7fc2cabc6e573d",
    "old_path": "lib.rs",
    "new_path": "lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -665,6 +665,8 @@ impl<A: Array> SmallVec<A> {\n                 if unspilled {\n                     return;\n                 }\n+            } else {\n+                return;\n             }\n             deallocate(ptr, cap);\n         }\n@@ -2341,4 +2343,18 @@ mod tests {\n         v.extend(it);\n         assert_eq!(v[..], ['a']);\n     }\n+\n+    #[test]\n+    fn grow_spilled_same_size() {\n+        let mut v: SmallVec<[u8; 2]> = SmallVec::new();\n+        v.push(0);\n+        v.push(1);\n+        v.push(2);\n+        assert!(v.spilled());\n+        assert_eq!(v.capacity(), 4);\n+        // grow with the same capacity\n+        v.grow(4);\n+        assert_eq!(v.capacity(), 4);\n+        assert_eq!(v[..], [0, 1, 2]);\n+    }\n }\n",
    "diff_parsed": "{'added': [(668, '            } else {'), (669, '                return;'), (2347, '    #[test]'), (2348, '    fn grow_spilled_same_size() {'), (2349, '        let mut v: SmallVec<[u8; 2]> = SmallVec::new();'), (2350, '        v.push(0);'), (2351, '        v.push(1);'), (2352, '        v.push(2);'), (2353, '        assert!(v.spilled());'), (2354, '        assert_eq!(v.capacity(), 4);'), (2356, '        v.grow(4);'), (2357, '        assert_eq!(v.capacity(), 4);'), (2358, '        assert_eq!(v[..], [0, 1, 2]);'), (2359, '    }')], 'deleted': []}",
    "num_lines_added": "14",
    "num_lines_deleted": "0",
    "nloc": "1813"
  },
  {
    "file_change_id": "191641670508003",
    "hash": "31a8de9c2f9b096352c4df3877aa8d3df5b73d0",
    "old_path": "build.rs",
    "new_path": "build.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -6,7 +6,7 @@ fn main() {\n     assert!(version().unwrap().major >= 1);\n \n     // Check for a minimum version\n-    if version().unwrap() >= Version::parse(\"1.33.0\").unwrap() {\n-        println!(\"cargo:rustc-cfg=memoffset_constant_expression\");\n+    if version().unwrap() >= Version::parse(\"1.37.0\").unwrap() {\n+        println!(\"cargo:rustc-cfg=memoffset_maybe_uninit\");\n     }\n }\n",
    "diff_parsed": "{'added': [(9, '    if version().unwrap() >= Version::parse(\"1.37.0\").unwrap() {'), (10, '        println!(\"cargo:rustc-cfg=memoffset_maybe_uninit\");')], 'deleted': [(9, '    if version().unwrap() >= Version::parse(\"1.33.0\").unwrap() {'), (10, '        println!(\"cargo:rustc-cfg=memoffset_constant_expression\");')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "8.0"
  },
  {
    "file_change_id": "181528592108513",
    "hash": "31a8de9c2f9b096352c4df3877aa8d3df5b73d0",
    "old_path": "src/constant_impl.rs",
    "new_path": "None",
    "change_type": "ModificationType.DELETE",
    "diff": "@@ -1,13 +0,0 @@\n-// A helper to get a const fn version of size_of_val\n-#[doc(hidden)]\n-pub const fn size_of<T>(_: &T) -> usize {\n-    ::mem::size_of::<T>()\n-}\n-\n-// While constant pointer transmutation isn't stable, union transmutation is\n-// This hack should go away after rust-lang/rust#51910\n-#[doc(hidden)]\n-pub union Transmuter<T: 'static> {\n-    pub ptr: &'static T,\n-    pub int: usize,\n-}\n",
    "diff_parsed": "{'added': [], 'deleted': [(2, '#[doc(hidden)]'), (3, 'pub const fn size_of<T>(_: &T) -> usize {'), (4, '    ::mem::size_of::<T>()'), (5, '}'), (9, '#[doc(hidden)]'), (10, \"pub union Transmuter<T: 'static> {\"), (11, \"    pub ptr: &'static T,\"), (12, '    pub int: usize,'), (13, '}')]}",
    "num_lines_added": "0",
    "num_lines_deleted": "9",
    "nloc": "nan"
  },
  {
    "file_change_id": "56793701820189",
    "hash": "31a8de9c2f9b096352c4df3877aa8d3df5b73d0",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -67,12 +67,8 @@\n #[doc(hidden)]\n pub use core::mem;\n \n-#[cfg(memoffset_constant_expression)]\n #[doc(hidden)]\n-mod constant_impl;\n-\n-#[cfg(memoffset_constant_expression)]\n-pub use constant_impl::{size_of, Transmuter};\n+pub use core::ptr;\n \n #[macro_use]\n mod offset_of;\n",
    "diff_parsed": "{'added': [(71, 'pub use core::ptr;')], 'deleted': [(70, '#[cfg(memoffset_constant_expression)]'), (72, 'mod constant_impl;'), (74, '#[cfg(memoffset_constant_expression)]'), (75, 'pub use constant_impl::{size_of, Transmuter};')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "4",
    "nloc": "9.0"
  },
  {
    "file_change_id": "265307835795773",
    "hash": "31a8de9c2f9b096352c4df3877aa8d3df5b73d0",
    "old_path": "src/offset_of.rs",
    "new_path": "src/offset_of.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -66,30 +66,30 @@\n /// }\n /// ```\n #[macro_export]\n-#[cfg(memoffset_constant_expression)]\n+#[cfg(memoffset_maybe_uninit)]\n macro_rules! offset_of {\n-    ($parent:ty, $($field:tt)+) => (unsafe {\n-        let x: &'static $parent = $crate::Transmuter::<$parent> { int: 0 }.ptr;\n-        $crate::Transmuter { ptr: &x.$($field)+ }.int\n+    ($parent:ty, $field:tt) => (unsafe {\n+        // Create an instance of the container and calculate the offset to its\n+        // field. Although we are creating references to uninitialized data this\n+        // is fine since we are not dereferencing them.\n+        let val = $crate::mem::MaybeUninit::<$parent>::uninitialized();\n+        let &$container { $field: ref f, .. } = &*val.as_ptr();\n+        #[allow(unused_unsafe)]\n+        let result = unsafe { (f as *const _ as *const u8).offset_from(val.as_ptr() as *const u8) };\n+        result as isize\n     });\n }\n \n #[macro_export]\n-#[cfg(not(memoffset_constant_expression))]\n+#[cfg(not(memoffset_maybe_uninit))]\n macro_rules! offset_of {\n-    ($father:ty, $($field:tt)+) => ({\n-        #[allow(unused_unsafe)]\n-        let root: $father = unsafe { $crate::mem::uninitialized() };\n-\n-        let base = &root as *const _ as usize;\n-\n-        // Future error: borrow of packed field requires unsafe function or block (error E0133)\n+    ($parent:ty, $field:tt) => ({\n+        let non_null = $crate::ptr::NonNull::<$parent>::dangling();\n+        let base_ptr = unsafe { non_null.as_ref() };\n         #[allow(unused_unsafe)]\n-        let member =  unsafe { &root.$($field)* as *const _ as usize };\n-\n-        $crate::mem::forget(root);\n-\n-        member - base\n+        let field_ptr = unsafe { &base_ptr.$field };\n+        let offset = (field_ptr as *const _ as usize) - (base_ptr as *const _ as usize);\n+        offset\n     });\n }\n \n@@ -109,18 +109,6 @@ mod tests {\n         assert_eq!(offset_of!(Foo, c), 8);\n     }\n \n-    #[test]\n-    fn offset_index() {\n-        assert_eq!(offset_of!(Foo, b[2]), 6);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    #[allow(const_err)]\n-    fn offset_index_out_of_bounds() {\n-        offset_of!(Foo, b[4]);\n-    }\n-\n     #[test]\n     fn tuple_struct() {\n         #[repr(C, packed)]\n",
    "diff_parsed": "{'added': [(69, '#[cfg(memoffset_maybe_uninit)]'), (71, '    ($parent:ty, $field:tt) => (unsafe {'), (75, '        let val = $crate::mem::MaybeUninit::<$parent>::uninitialized();'), (76, '        let &$container { $field: ref f, .. } = &*val.as_ptr();'), (77, '        #[allow(unused_unsafe)]'), (78, '        let result = unsafe { (f as *const _ as *const u8).offset_from(val.as_ptr() as *const u8) };'), (79, '        result as isize'), (84, '#[cfg(not(memoffset_maybe_uninit))]'), (86, '    ($parent:ty, $field:tt) => ({'), (87, '        let non_null = $crate::ptr::NonNull::<$parent>::dangling();'), (88, '        let base_ptr = unsafe { non_null.as_ref() };'), (90, '        let field_ptr = unsafe { &base_ptr.$field };'), (91, '        let offset = (field_ptr as *const _ as usize) - (base_ptr as *const _ as usize);'), (92, '        offset')], 'deleted': [(69, '#[cfg(memoffset_constant_expression)]'), (71, '    ($parent:ty, $($field:tt)+) => (unsafe {'), (72, \"        let x: &'static $parent = $crate::Transmuter::<$parent> { int: 0 }.ptr;\"), (73, '        $crate::Transmuter { ptr: &x.$($field)+ }.int'), (78, '#[cfg(not(memoffset_constant_expression))]'), (80, '    ($father:ty, $($field:tt)+) => ({'), (81, '        #[allow(unused_unsafe)]'), (82, '        let root: $father = unsafe { $crate::mem::uninitialized() };'), (84, '        let base = &root as *const _ as usize;'), (88, '        let member =  unsafe { &root.$($field)* as *const _ as usize };'), (90, '        $crate::mem::forget(root);'), (92, '        member - base'), (112, '    #[test]'), (113, '    fn offset_index() {'), (114, '        assert_eq!(offset_of!(Foo, b[2]), 6);'), (115, '    }'), (117, '    #[test]'), (118, '    #[should_panic]'), (119, '    #[allow(const_err)]'), (120, '    fn offset_index_out_of_bounds() {'), (121, '        offset_of!(Foo, b[4]);'), (122, '    }')]}",
    "num_lines_added": "14",
    "num_lines_deleted": "22",
    "nloc": "44.0"
  },
  {
    "file_change_id": "237074075200393",
    "hash": "31a8de9c2f9b096352c4df3877aa8d3df5b73d0",
    "old_path": "src/span_of.rs",
    "new_path": "src/span_of.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -267,30 +267,15 @@ mod tests {\n             span_of!(Test, y..),\n             offset_of!(Test, y)..mem::size_of::<Test>()\n         );\n-        assert_eq!(\n-            span_of!(Test, y[0]..),\n-            offset_of!(Test, y[0])..mem::size_of::<Test>()\n-        );\n+        \n         assert_eq!(\n             span_of!(Test, z..),\n             offset_of!(Test, z)..mem::size_of::<Test>()\n         );\n-        assert_eq!(\n-            span_of!(Test, z.foo..),\n-            offset_of!(Test, z.foo)..mem::size_of::<Test>()\n-        );\n         assert_eq!(\n             span_of!(Test, egg..),\n             offset_of!(Test, egg)..mem::size_of::<Test>()\n         );\n-        assert_eq!(\n-            span_of!(Test, egg[0]..),\n-            offset_of!(Test, egg[0])..mem::size_of::<Test>()\n-        );\n-        assert_eq!(\n-            span_of!(Test, egg[0][0]..),\n-            offset_of!(Test, egg[0][0])..mem::size_of::<Test>()\n-        );\n         assert_eq!(\n             span_of!(Test, x..y),\n             offset_of!(Test, x)..offset_of!(Test, y)\n@@ -299,25 +284,9 @@ mod tests {\n             span_of!(Test, x..=y),\n             offset_of!(Test, x)..offset_of!(Test, y) + mem::size_of::<[u8; 56]>()\n         );\n-        assert_eq!(\n-            span_of!(Test, x..y[4]),\n-            offset_of!(Test, x)..offset_of!(Test, y[4])\n-        );\n         assert_eq!(\n             span_of!(Test, x..=y[4]),\n             offset_of!(Test, x)..offset_of!(Test, y) + mem::size_of::<[u8; 5]>()\n         );\n-        assert_eq!(\n-            span_of!(Test, x..z.foo),\n-            offset_of!(Test, x)..offset_of!(Test, z.foo)\n-        );\n-        assert_eq!(\n-            span_of!(Test, x..=z.foo),\n-            offset_of!(Test, x)..offset_of!(Test, z.foo) + mem::size_of::<u32>()\n-        );\n-        assert_eq!(\n-            span_of!(Test, egg[0][0]..egg[1][0]),\n-            offset_of!(Test, egg[0][0])..offset_of!(Test, egg[1][0])\n-        );\n     }\n }\n",
    "diff_parsed": "{'added': [], 'deleted': [(270, '        assert_eq!('), (271, '            span_of!(Test, y[0]..),'), (272, '            offset_of!(Test, y[0])..mem::size_of::<Test>()'), (273, '        );'), (278, '        assert_eq!('), (279, '            span_of!(Test, z.foo..),'), (280, '            offset_of!(Test, z.foo)..mem::size_of::<Test>()'), (281, '        );'), (286, '        assert_eq!('), (287, '            span_of!(Test, egg[0]..),'), (288, '            offset_of!(Test, egg[0])..mem::size_of::<Test>()'), (289, '        );'), (290, '        assert_eq!('), (291, '            span_of!(Test, egg[0][0]..),'), (292, '            offset_of!(Test, egg[0][0])..mem::size_of::<Test>()'), (293, '        );'), (302, '        assert_eq!('), (303, '            span_of!(Test, x..y[4]),'), (304, '            offset_of!(Test, x)..offset_of!(Test, y[4])'), (305, '        );'), (310, '        assert_eq!('), (311, '            span_of!(Test, x..z.foo),'), (312, '            offset_of!(Test, x)..offset_of!(Test, z.foo)'), (313, '        );'), (314, '        assert_eq!('), (315, '            span_of!(Test, x..=z.foo),'), (316, '            offset_of!(Test, x)..offset_of!(Test, z.foo) + mem::size_of::<u32>()'), (317, '        );'), (318, '        assert_eq!('), (319, '            span_of!(Test, egg[0][0]..egg[1][0]),'), (320, '            offset_of!(Test, egg[0][0])..offset_of!(Test, egg[1][0])'), (321, '        );')]}",
    "num_lines_added": "0",
    "num_lines_deleted": "32",
    "nloc": "193.0"
  },
  {
    "file_change_id": "105681048553157",
    "hash": "2d7317336ebaba7a6ffd778dbc8c52b5bbbd151",
    "old_path": "futures-util/src/stream/futures_unordered/iter.rs",
    "new_path": "futures-util/src/stream/futures_unordered/iter.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -2,6 +2,7 @@ use super::FuturesUnordered;\n use super::task::Task;\n use core::marker::PhantomData;\n use core::pin::Pin;\n+use core::sync::atomic::Ordering::Relaxed;\n \n #[derive(Debug)]\n /// Mutable iterator over all futures in the unordered set.\n@@ -20,6 +21,7 @@ pub struct IterMut<'a, Fut: Unpin> (pub(super) IterPinMut<'a, Fut>);\n pub struct IterPinRef<'a, Fut> {\n     pub(super) task: *const Task<Fut>,\n     pub(super) len: usize,\n+    pub(super) pending_next_all: *mut Task<Fut>,\n     pub(super) _marker: PhantomData<&'a FuturesUnordered<Fut>>\n }\n \n@@ -36,7 +38,12 @@ impl<'a, Fut> Iterator for IterPinMut<'a, Fut> {\n         }\n         unsafe {\n             let future = (*(*self.task).future.get()).as_mut().unwrap();\n-            let next = *(*self.task).next_all.get();\n+\n+            // Mutable access to a previously shared `FuturesUnordered` implies\n+            // that the other threads already released the object before the\n+            // current thread acquired it, so relaxed ordering can be used and\n+            // valid `next_all` checks can be skipped.\n+            let next = (*self.task).next_all.load(Relaxed);\n             self.task = next;\n             self.len -= 1;\n             Some(Pin::new_unchecked(future))\n@@ -73,7 +80,15 @@ impl<'a, Fut> Iterator for IterPinRef<'a, Fut> {\n         }\n         unsafe {\n             let future = (*(*self.task).future.get()).as_ref().unwrap();\n-            let next = *(*self.task).next_all.get();\n+\n+            // Relaxed ordering can be used since acquire ordering when\n+            // `head_all` was initially read for this iterator implies acquire\n+            // ordering for all previously inserted nodes (and we don't need to\n+            // read `len_all` again for any other nodes).\n+            let next = (*self.task).spin_next_all(\n+                self.pending_next_all,\n+                Relaxed,\n+            );\n             self.task = next;\n             self.len -= 1;\n             Some(Pin::new_unchecked(future))\n",
    "diff_parsed": "{'added': [(5, 'use core::sync::atomic::Ordering::Relaxed;'), (24, '    pub(super) pending_next_all: *mut Task<Fut>,'), (46, '            let next = (*self.task).next_all.load(Relaxed);'), (88, '            let next = (*self.task).spin_next_all('), (89, '                self.pending_next_all,'), (90, '                Relaxed,'), (91, '            );')], 'deleted': [(39, '            let next = *(*self.task).next_all.get();'), (76, '            let next = *(*self.task).next_all.get();')]}",
    "num_lines_added": "7",
    "num_lines_deleted": "2",
    "nloc": "91"
  },
  {
    "file_change_id": "9469866046256",
    "hash": "2d7317336ebaba7a6ffd778dbc8c52b5bbbd151",
    "old_path": "futures-util/src/stream/futures_unordered/mod.rs",
    "new_path": "futures-util/src/stream/futures_unordered/mod.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -8,14 +8,14 @@ use futures_core::stream::{FusedStream, Stream};\n use futures_core::task::{Context, Poll};\n use futures_task::{FutureObj, LocalFutureObj, Spawn, LocalSpawn, SpawnError};\n use crate::task::AtomicWaker;\n-use core::cell::{Cell, UnsafeCell};\n+use core::cell::UnsafeCell;\n use core::fmt::{self, Debug};\n use core::iter::FromIterator;\n use core::marker::PhantomData;\n use core::mem;\n use core::pin::Pin;\n use core::ptr;\n-use core::sync::atomic::Ordering::SeqCst;\n+use core::sync::atomic::Ordering::{AcqRel, Acquire, Relaxed, Release, SeqCst};\n use core::sync::atomic::{AtomicPtr, AtomicBool};\n use alloc::sync::{Arc, Weak};\n \n@@ -30,15 +30,6 @@ use self::task::Task;\n mod ready_to_run_queue;\n use self::ready_to_run_queue::{ReadyToRunQueue, Dequeue};\n \n-/// Constant used for a `FuturesUnordered` to indicate we are empty and have\n-/// yielded a `None` element so can return `true` from\n-/// `FusedStream::is_terminated`\n-///\n-/// It is safe to not check for this when incrementing as even a ZST future will\n-/// have a `Task` allocated for it, so we cannot ever reach usize::max_value()\n-/// without running out of ram.\n-const TERMINATED_SENTINEL_LENGTH: usize = usize::max_value();\n-\n /// Constant used for a `FuturesUnordered` to determine how many times it is\n /// allowed to poll underlying futures without yielding.\n ///\n@@ -79,8 +70,8 @@ const YIELD_EVERY: usize = 32;\n #[must_use = \"streams do nothing unless polled\"]\n pub struct FuturesUnordered<Fut> {\n     ready_to_run_queue: Arc<ReadyToRunQueue<Fut>>,\n-    len: Cell<usize>,\n-    head_all: Cell<*const Task<Fut>>,\n+    head_all: AtomicPtr<Task<Fut>>,\n+    is_terminated: AtomicBool,\n }\n \n unsafe impl<Fut: Send> Send for FuturesUnordered<Fut> {}\n@@ -107,10 +98,12 @@ impl LocalSpawn for FuturesUnordered<LocalFutureObj<'_, ()>> {\n \n // FuturesUnordered is implemented using two linked lists. One which links all\n // futures managed by a `FuturesUnordered` and one that tracks futures that have\n-// been scheduled for polling. The first linked list is not thread safe and is\n-// only accessed by the thread that owns the `FuturesUnordered` value. The\n-// second linked list is an implementation of the intrusive MPSC queue algorithm\n-// described by 1024cores.net.\n+// been scheduled for polling. The first linked list allows for thread safe\n+// insertion of nodes at the head as well as forward iteration, but is otherwise\n+// not thread safe and is only accessed by the thread that owns the\n+// `FuturesUnordered` value for any other operations. The second linked list is\n+// an implementation of the intrusive MPSC queue algorithm described by\n+// 1024cores.net.\n //\n // When a future is submitted to the set, a task is allocated and inserted in\n // both linked lists. The next call to `poll_next` will (eventually) see this\n@@ -137,8 +130,9 @@ impl<Fut: Future> FuturesUnordered<Fut> {\n     pub fn new() -> FuturesUnordered<Fut> {\n         let stub = Arc::new(Task {\n             future: UnsafeCell::new(None),\n-            next_all: UnsafeCell::new(ptr::null()),\n+            next_all: AtomicPtr::new(ptr::null_mut()),\n             prev_all: UnsafeCell::new(ptr::null()),\n+            len_all: UnsafeCell::new(0),\n             next_ready_to_run: AtomicPtr::new(ptr::null_mut()),\n             queued: AtomicBool::new(true),\n             ready_to_run_queue: Weak::new(),\n@@ -152,9 +146,9 @@ impl<Fut: Future> FuturesUnordered<Fut> {\n         });\n \n         FuturesUnordered {\n-            len: 0.into(),\n-            head_all: Cell::from(ptr::null()),\n+            head_all: AtomicPtr::new(ptr::null_mut()),\n             ready_to_run_queue,\n+            is_terminated: AtomicBool::new(false),\n         }\n     }\n }\n@@ -170,14 +164,15 @@ impl<Fut> FuturesUnordered<Fut> {\n     ///\n     /// This represents the total number of in-flight futures.\n     pub fn len(&self) -> usize {\n-        let len = self.len.get();\n-        if len == TERMINATED_SENTINEL_LENGTH { 0 } else { len }\n+        let (_, len) = self.atomic_load_head_and_len_all();\n+        len\n     }\n \n     /// Returns `true` if the set contains no futures.\n     pub fn is_empty(&self) -> bool {\n-        let len = self.len.get();\n-        len == 0 || len == TERMINATED_SENTINEL_LENGTH\n+        // Relaxed ordering can be used here since we don't need to read from\n+        // the head pointer, only check whether it is null.\n+        self.head_all.load(Relaxed).is_null()\n     }\n \n     /// Push a future into the set.\n@@ -189,18 +184,17 @@ impl<Fut> FuturesUnordered<Fut> {\n     pub fn push(&self, future: Fut) {\n         let task = Arc::new(Task {\n             future: UnsafeCell::new(Some(future)),\n-            next_all: UnsafeCell::new(ptr::null_mut()),\n+            next_all: AtomicPtr::new(self.pending_next_all()),\n             prev_all: UnsafeCell::new(ptr::null_mut()),\n+            len_all: UnsafeCell::new(0),\n             next_ready_to_run: AtomicPtr::new(ptr::null_mut()),\n             queued: AtomicBool::new(true),\n             ready_to_run_queue: Arc::downgrade(&self.ready_to_run_queue),\n         });\n \n-        // If we've previously marked ourselves as terminated we need to reset\n-        // len to 0 to track it correctly\n-        if self.len.get() == TERMINATED_SENTINEL_LENGTH {\n-            self.len.set(0);\n-        }\n+        // Reset the `is_terminated` flag if we've previously marked ourselves\n+        // as terminated.\n+        self.is_terminated.store(false, Relaxed);\n \n         // Right now our task has a strong reference count of 1. We transfer\n         // ownership of this reference count to our internal linked list\n@@ -221,9 +215,12 @@ impl<Fut> FuturesUnordered<Fut> {\n \n     /// Returns an iterator that allows inspecting each future in the set.\n     fn iter_pin_ref(self: Pin<&Self>) -> IterPinRef<'_, Fut> {\n+        let (task, len) = self.atomic_load_head_and_len_all();\n+\n         IterPinRef {\n-            task: self.head_all.get(),\n-            len: self.len(),\n+            task,\n+            len,\n+            pending_next_all: self.pending_next_all(),\n             _marker: PhantomData,\n         }\n     }\n@@ -234,21 +231,49 @@ impl<Fut> FuturesUnordered<Fut> {\n     }\n \n     /// Returns an iterator that allows modifying each future in the set.\n-    pub fn iter_pin_mut(self: Pin<&mut Self>) -> IterPinMut<'_, Fut> {\n+    pub fn iter_pin_mut(mut self: Pin<&mut Self>) -> IterPinMut<'_, Fut> {\n+        // `head_all` can be accessed directly and we don't need to spin on\n+        // `Task::next_all` since we have exclusive access to the set.\n+        let task = *self.head_all.get_mut();\n+        let len = if task.is_null() {\n+            0\n+        } else {\n+            unsafe {\n+                *(*task).len_all.get()\n+            }\n+        };\n+\n         IterPinMut {\n-            task: self.head_all.get(),\n-            len: self.len(),\n+            task,\n+            len,\n             _marker: PhantomData\n         }\n     }\n \n+    /// Returns the current head node and number of futures in the list of all\n+    /// futures within a context where access is shared with other threads\n+    /// (mostly for use with the `len` and `iter_pin_ref` methods).\n+    fn atomic_load_head_and_len_all(&self) -> (*const Task<Fut>, usize) {\n+        let task = self.head_all.load(Acquire);\n+        let len = if task.is_null() {\n+            0\n+        } else {\n+            unsafe {\n+                (*task).spin_next_all(self.pending_next_all(), Acquire);\n+                *(*task).len_all.get()\n+            }\n+        };\n+\n+        (task, len)\n+    }\n+\n     /// Releases the task. It destorys the future inside and either drops\n     /// the `Arc<Task>` or transfers ownership to the ready to run queue.\n     /// The task this method is called on must have been unlinked before.\n     fn release_task(&mut self, task: Arc<Task<Fut>>) {\n         // `release_task` must only be called on unlinked tasks\n+        debug_assert_eq!(task.next_all.load(Relaxed), self.pending_next_all());\n         unsafe {\n-            debug_assert!((*task.next_all.get()).is_null());\n             debug_assert!((*task.prev_all.get()).is_null());\n         }\n \n@@ -284,17 +309,38 @@ impl<Fut> FuturesUnordered<Fut> {\n \n     /// Insert a new task into the internal linked list.\n     fn link(&self, task: Arc<Task<Fut>>) -> *const Task<Fut> {\n+        // `next_all` should already be reset to the pending state before this\n+        // function is called.\n+        debug_assert_eq!(task.next_all.load(Relaxed), self.pending_next_all());\n         let ptr = Arc::into_raw(task);\n+\n+        // Atomically swap out the old head node to get the node that should be\n+        // assigned to `next_all`.\n+        let next = self.head_all.swap(ptr as *mut _, AcqRel);\n+\n         unsafe {\n-            *(*ptr).next_all.get() = self.head_all.get();\n-            if !self.head_all.get().is_null() {\n-                *(*self.head_all.get()).prev_all.get() = ptr;\n+            // Store the new list length in the new node.\n+            let new_len = if next.is_null() {\n+                1\n+            } else {\n+                // Make sure `next_all` has been written to signal that it is\n+                // safe to read `len_all`.\n+                (*next).spin_next_all(self.pending_next_all(), Acquire);\n+                *(*next).len_all.get() + 1\n+            };\n+            *(*ptr).len_all.get() = new_len;\n+\n+            // Write the old head as the next node pointer, signaling to other\n+            // threads that `len_all` and `next_all` are ready to read.\n+            (*ptr).next_all.store(next, Release);\n+\n+            // `prev_all` updates don't need to be synchronized, as the field is\n+            // only ever used after exclusive access has been acquired.\n+            if !next.is_null() {\n+                *(*next).prev_all.get() = ptr;\n             }\n         }\n \n-        self.head_all.set(ptr);\n-        let old_len = self.len.get();\n-        self.len.set(old_len + 1);\n         ptr\n     }\n \n@@ -303,10 +349,16 @@ impl<Fut> FuturesUnordered<Fut> {\n     /// This method is unsafe because it has be guaranteed that `task` is a\n     /// valid pointer.\n     unsafe fn unlink(&mut self, task: *const Task<Fut>) -> Arc<Task<Fut>> {\n+        // Compute the new list length now in case we're removing the head node\n+        // and won't be able to retrieve the correct length later.\n+        let head = *self.head_all.get_mut();\n+        debug_assert!(!head.is_null());\n+        let new_len = *(*head).len_all.get() - 1;\n+\n         let task = Arc::from_raw(task);\n-        let next = *task.next_all.get();\n+        let next = task.next_all.load(Relaxed);\n         let prev = *task.prev_all.get();\n-        *task.next_all.get() = ptr::null_mut();\n+        task.next_all.store(self.pending_next_all(), Relaxed);\n         *task.prev_all.get() = ptr::null_mut();\n \n         if !next.is_null() {\n@@ -314,14 +366,48 @@ impl<Fut> FuturesUnordered<Fut> {\n         }\n \n         if !prev.is_null() {\n-            *(*prev).next_all.get() = next;\n+            (*prev).next_all.store(next, Relaxed);\n         } else {\n-            self.head_all.set(next);\n+            *self.head_all.get_mut() = next;\n+        }\n+\n+        // Store the new list length in the head node.\n+        let head = *self.head_all.get_mut();\n+        if !head.is_null() {\n+            *(*head).len_all.get() = new_len;\n         }\n-        let old_len = self.len.get();\n-        self.len.set(old_len - 1);\n+\n         task\n     }\n+\n+    /// Returns the reserved value for `Task::next_all` to indicate a pending\n+    /// assignment from the thread that inserted the task.\n+    ///\n+    /// `FuturesUnordered::link` needs to update `Task` pointers in an order\n+    /// that ensures any iterators created on other threads can correctly\n+    /// traverse the entire `Task` list using the chain of `next_all` pointers.\n+    /// This could be solved with a compare-exchange loop that stores the\n+    /// current `head_all` in `next_all` and swaps out `head_all` with the new\n+    /// `Task` pointer if the head hasn't already changed. Under heavy thread\n+    /// contention, this compare-exchange loop could become costly.\n+    ///\n+    /// An alternative is to initialize `next_all` to a reserved pending state\n+    /// first, perform an atomic swap on `head_all`, and finally update\n+    /// `next_all` with the old head node. Iterators will then either see the\n+    /// pending state value or the correct next node pointer, and can reload\n+    /// `next_all` as needed until the correct value is loaded. The number of\n+    /// retries needed (if any) would be small and will always be finite, so\n+    /// this should generally perform better than the compare-exchange loop.\n+    ///\n+    /// A valid `Task` pointer in the `head_all` list is guaranteed to never be\n+    /// this value, so it is safe to use as a reserved value until the correct\n+    /// value can be written.\n+    fn pending_next_all(&self) -> *mut Task<Fut> {\n+        // The `ReadyToRunQueue` stub is never inserted into the `head_all`\n+        // list, and its pointer value will remain valid for the lifetime of\n+        // this `FuturesUnordered`, so we can make use of its value here.\n+        &*self.ready_to_run_queue.stub as *const _ as *mut _\n+    }\n }\n \n impl<Fut: Future> Stream for FuturesUnordered<Fut> {\n@@ -345,7 +431,7 @@ impl<Fut: Future> Stream for FuturesUnordered<Fut> {\n                     if self.is_empty() {\n                         // We can only consider ourselves terminated once we\n                         // have yielded a `None`\n-                        self.len.set(TERMINATED_SENTINEL_LENGTH);\n+                        *self.is_terminated.get_mut() = true;\n                         return Poll::Ready(None);\n                     } else {\n                         return Poll::Pending;\n@@ -385,8 +471,11 @@ impl<Fut: Future> Stream for FuturesUnordered<Fut> {\n \n                     // Double check that the call to `release_task` really\n                     // happened. Calling it required the task to be unlinked.\n+                    debug_assert_eq!(\n+                        task.next_all.load(Relaxed),\n+                        self.pending_next_all()\n+                    );\n                     unsafe {\n-                        debug_assert!((*task.next_all.get()).is_null());\n                         debug_assert!((*task.prev_all.get()).is_null());\n                     }\n                     continue\n@@ -496,8 +585,8 @@ impl<Fut> Drop for FuturesUnordered<Fut> {\n         // wakers flying around which contain `Task<Fut>` references\n         // inside them. We'll let those naturally get deallocated.\n         unsafe {\n-            while !self.head_all.get().is_null() {\n-                let head = self.head_all.get();\n+            while !self.head_all.get_mut().is_null() {\n+                let head = *self.head_all.get_mut();\n                 let task = self.unlink(head);\n                 self.release_task(task);\n             }\n@@ -530,6 +619,6 @@ impl<Fut: Future> FromIterator<Fut> for FuturesUnordered<Fut> {\n \n impl<Fut: Future> FusedStream for FuturesUnordered<Fut> {\n     fn is_terminated(&self) -> bool {\n-        self.len.get() == TERMINATED_SENTINEL_LENGTH\n+        self.is_terminated.load(Relaxed)\n     }\n }\n",
    "diff_parsed": "{'added': [(11, 'use core::cell::UnsafeCell;'), (18, 'use core::sync::atomic::Ordering::{AcqRel, Acquire, Relaxed, Release, SeqCst};'), (73, '    head_all: AtomicPtr<Task<Fut>>,'), (74, '    is_terminated: AtomicBool,'), (133, '            next_all: AtomicPtr::new(ptr::null_mut()),'), (135, '            len_all: UnsafeCell::new(0),'), (149, '            head_all: AtomicPtr::new(ptr::null_mut()),'), (151, '            is_terminated: AtomicBool::new(false),'), (167, '        let (_, len) = self.atomic_load_head_and_len_all();'), (168, '        len'), (175, '        self.head_all.load(Relaxed).is_null()'), (187, '            next_all: AtomicPtr::new(self.pending_next_all()),'), (189, '            len_all: UnsafeCell::new(0),'), (197, '        self.is_terminated.store(false, Relaxed);'), (218, '        let (task, len) = self.atomic_load_head_and_len_all();'), (221, '            task,'), (222, '            len,'), (223, '            pending_next_all: self.pending_next_all(),'), (234, \"    pub fn iter_pin_mut(mut self: Pin<&mut Self>) -> IterPinMut<'_, Fut> {\"), (237, '        let task = *self.head_all.get_mut();'), (238, '        let len = if task.is_null() {'), (239, '            0'), (240, '        } else {'), (241, '            unsafe {'), (242, '                *(*task).len_all.get()'), (243, '            }'), (244, '        };'), (247, '            task,'), (248, '            len,'), (256, '    fn atomic_load_head_and_len_all(&self) -> (*const Task<Fut>, usize) {'), (257, '        let task = self.head_all.load(Acquire);'), (258, '        let len = if task.is_null() {'), (259, '            0'), (260, '        } else {'), (261, '            unsafe {'), (262, '                (*task).spin_next_all(self.pending_next_all(), Acquire);'), (263, '                *(*task).len_all.get()'), (264, '            }'), (265, '        };'), (267, '        (task, len)'), (268, '    }'), (275, '        debug_assert_eq!(task.next_all.load(Relaxed), self.pending_next_all());'), (314, '        debug_assert_eq!(task.next_all.load(Relaxed), self.pending_next_all());'), (319, '        let next = self.head_all.swap(ptr as *mut _, AcqRel);'), (323, '            let new_len = if next.is_null() {'), (324, '                1'), (325, '            } else {'), (328, '                (*next).spin_next_all(self.pending_next_all(), Acquire);'), (329, '                *(*next).len_all.get() + 1'), (330, '            };'), (331, '            *(*ptr).len_all.get() = new_len;'), (335, '            (*ptr).next_all.store(next, Release);'), (339, '            if !next.is_null() {'), (340, '                *(*next).prev_all.get() = ptr;'), (354, '        let head = *self.head_all.get_mut();'), (355, '        debug_assert!(!head.is_null());'), (356, '        let new_len = *(*head).len_all.get() - 1;'), (359, '        let next = task.next_all.load(Relaxed);'), (361, '        task.next_all.store(self.pending_next_all(), Relaxed);'), (369, '            (*prev).next_all.store(next, Relaxed);'), (371, '            *self.head_all.get_mut() = next;'), (372, '        }'), (375, '        let head = *self.head_all.get_mut();'), (376, '        if !head.is_null() {'), (377, '            *(*head).len_all.get() = new_len;'), (405, '    fn pending_next_all(&self) -> *mut Task<Fut> {'), (409, '        &*self.ready_to_run_queue.stub as *const _ as *mut _'), (410, '    }'), (434, '                        *self.is_terminated.get_mut() = true;'), (474, '                    debug_assert_eq!('), (475, '                        task.next_all.load(Relaxed),'), (476, '                        self.pending_next_all()'), (477, '                    );'), (588, '            while !self.head_all.get_mut().is_null() {'), (589, '                let head = *self.head_all.get_mut();'), (622, '        self.is_terminated.load(Relaxed)')], 'deleted': [(11, 'use core::cell::{Cell, UnsafeCell};'), (18, 'use core::sync::atomic::Ordering::SeqCst;'), (40, 'const TERMINATED_SENTINEL_LENGTH: usize = usize::max_value();'), (82, '    len: Cell<usize>,'), (83, '    head_all: Cell<*const Task<Fut>>,'), (140, '            next_all: UnsafeCell::new(ptr::null()),'), (155, '            len: 0.into(),'), (156, '            head_all: Cell::from(ptr::null()),'), (173, '        let len = self.len.get();'), (174, '        if len == TERMINATED_SENTINEL_LENGTH { 0 } else { len }'), (179, '        let len = self.len.get();'), (180, '        len == 0 || len == TERMINATED_SENTINEL_LENGTH'), (192, '            next_all: UnsafeCell::new(ptr::null_mut()),'), (201, '        if self.len.get() == TERMINATED_SENTINEL_LENGTH {'), (202, '            self.len.set(0);'), (203, '        }'), (225, '            task: self.head_all.get(),'), (226, '            len: self.len(),'), (237, \"    pub fn iter_pin_mut(self: Pin<&mut Self>) -> IterPinMut<'_, Fut> {\"), (239, '            task: self.head_all.get(),'), (240, '            len: self.len(),'), (251, '            debug_assert!((*task.next_all.get()).is_null());'), (289, '            *(*ptr).next_all.get() = self.head_all.get();'), (290, '            if !self.head_all.get().is_null() {'), (291, '                *(*self.head_all.get()).prev_all.get() = ptr;'), (295, '        self.head_all.set(ptr);'), (296, '        let old_len = self.len.get();'), (297, '        self.len.set(old_len + 1);'), (307, '        let next = *task.next_all.get();'), (309, '        *task.next_all.get() = ptr::null_mut();'), (317, '            *(*prev).next_all.get() = next;'), (319, '            self.head_all.set(next);'), (321, '        let old_len = self.len.get();'), (322, '        self.len.set(old_len - 1);'), (348, '                        self.len.set(TERMINATED_SENTINEL_LENGTH);'), (389, '                        debug_assert!((*task.next_all.get()).is_null());'), (499, '            while !self.head_all.get().is_null() {'), (500, '                let head = self.head_all.get();'), (533, '        self.len.get() == TERMINATED_SENTINEL_LENGTH')]}",
    "num_lines_added": "76",
    "num_lines_deleted": "39",
    "nloc": "353"
  },
  {
    "file_change_id": "178916244375336",
    "hash": "2d7317336ebaba7a6ffd778dbc8c52b5bbbd151",
    "old_path": "futures-util/src/stream/futures_unordered/task.rs",
    "new_path": "futures-util/src/stream/futures_unordered/task.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,6 +1,6 @@\n use core::cell::UnsafeCell;\n use core::sync::atomic::{AtomicPtr, AtomicBool};\n-use core::sync::atomic::Ordering::SeqCst;\n+use core::sync::atomic::Ordering::{self, SeqCst};\n use alloc::sync::{Arc, Weak};\n \n use crate::task::{ArcWake, WakerRef, waker_ref};\n@@ -11,12 +11,18 @@ pub(super) struct Task<Fut> {\n     // The future\n     pub(super) future: UnsafeCell<Option<Fut>>,\n \n-    // Next pointer for linked list tracking all active tasks\n-    pub(super) next_all: UnsafeCell<*const Task<Fut>>,\n+    // Next pointer for linked list tracking all active tasks (use\n+    // `spin_next_all` to read when access is shared across threads)\n+    pub(super) next_all: AtomicPtr<Task<Fut>>,\n \n     // Previous task in linked list tracking all active tasks\n     pub(super) prev_all: UnsafeCell<*const Task<Fut>>,\n \n+    // Length of the linked list tracking all active tasks when this node was\n+    // inserted (use `spin_next_all` to synchronize before reading when access\n+    // is shared across threads)\n+    pub(super) len_all: UnsafeCell<usize>,\n+\n     // Next pointer in ready to run queue\n     pub(super) next_ready_to_run: AtomicPtr<Task<Fut>>,\n \n@@ -67,6 +73,30 @@ impl<Fut> Task<Fut> {\n     pub(super) fn waker_ref<'a>(this: &'a Arc<Task<Fut>>) -> WakerRef<'a> {\n         waker_ref(this)\n     }\n+\n+    /// Spins until `next_all` is no longer set to `pending_next_all`.\n+    ///\n+    /// The temporary `pending_next_all` value is typically overwritten fairly\n+    /// quickly after a node is inserted into the list of all futures, so this\n+    /// should rarely spin much.\n+    ///\n+    /// When it returns, the correct `next_all` value is returned.\n+    ///\n+    /// `Relaxed` or `Acquire` ordering can be used. `Acquire` ordering must be\n+    /// used before `len_all` can be safely read.\n+    #[inline]\n+    pub(super) fn spin_next_all(\n+        &self,\n+        pending_next_all: *mut Self,\n+        ordering: Ordering,\n+    ) -> *const Self {\n+        loop {\n+            let next = self.next_all.load(ordering);\n+            if next != pending_next_all {\n+                return next;\n+            }\n+        }\n+    }\n }\n \n impl<Fut> Drop for Task<Fut> {\n",
    "diff_parsed": "{'added': [(3, 'use core::sync::atomic::Ordering::{self, SeqCst};'), (16, '    pub(super) next_all: AtomicPtr<Task<Fut>>,'), (24, '    pub(super) len_all: UnsafeCell<usize>,'), (87, '    #[inline]'), (88, '    pub(super) fn spin_next_all('), (89, '        &self,'), (90, '        pending_next_all: *mut Self,'), (91, '        ordering: Ordering,'), (92, '    ) -> *const Self {'), (93, '        loop {'), (94, '            let next = self.next_all.load(ordering);'), (95, '            if next != pending_next_all {'), (96, '                return next;'), (97, '            }'), (98, '        }'), (99, '    }')], 'deleted': [(3, 'use core::sync::atomic::Ordering::SeqCst;'), (15, '    pub(super) next_all: UnsafeCell<*const Task<Fut>>,')]}",
    "num_lines_added": "16",
    "num_lines_deleted": "2",
    "nloc": "72"
  },
  {
    "file_change_id": "274886828350170",
    "hash": "2d7317336ebaba7a6ffd778dbc8c52b5bbbd151",
    "old_path": "futures/tests/futures_unordered.rs",
    "new_path": "futures/tests/futures_unordered.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -245,3 +245,43 @@ fn futures_not_moved_after_poll() {\n     assert_stream_next!(stream, ());\n     assert_stream_done!(stream);\n }\n+\n+#[test]\n+fn len_valid_during_out_of_order_completion() {\n+    // Complete futures out-of-order and add new futures afterwards to ensure\n+    // length values remain correct.\n+    let (a_tx, a_rx) = oneshot::channel::<i32>();\n+    let (b_tx, b_rx) = oneshot::channel::<i32>();\n+    let (c_tx, c_rx) = oneshot::channel::<i32>();\n+    let (d_tx, d_rx) = oneshot::channel::<i32>();\n+\n+    let mut cx = noop_context();\n+    let mut stream = FuturesUnordered::new();\n+    assert_eq!(stream.len(), 0);\n+\n+    stream.push(a_rx);\n+    assert_eq!(stream.len(), 1);\n+    stream.push(b_rx);\n+    assert_eq!(stream.len(), 2);\n+    stream.push(c_rx);\n+    assert_eq!(stream.len(), 3);\n+\n+    b_tx.send(4).unwrap();\n+    assert_eq!(stream.poll_next_unpin(&mut cx), Poll::Ready(Some(Ok(4))));\n+    assert_eq!(stream.len(), 2);\n+\n+    stream.push(d_rx);\n+    assert_eq!(stream.len(), 3);\n+\n+    c_tx.send(5).unwrap();\n+    assert_eq!(stream.poll_next_unpin(&mut cx), Poll::Ready(Some(Ok(5))));\n+    assert_eq!(stream.len(), 2);\n+\n+    d_tx.send(6).unwrap();\n+    assert_eq!(stream.poll_next_unpin(&mut cx), Poll::Ready(Some(Ok(6))));\n+    assert_eq!(stream.len(), 1);\n+\n+    a_tx.send(7).unwrap();\n+    assert_eq!(stream.poll_next_unpin(&mut cx), Poll::Ready(Some(Ok(7))));\n+    assert_eq!(stream.len(), 0);\n+}\n",
    "diff_parsed": "{'added': [(249, '#[test]'), (250, 'fn len_valid_during_out_of_order_completion() {'), (253, '    let (a_tx, a_rx) = oneshot::channel::<i32>();'), (254, '    let (b_tx, b_rx) = oneshot::channel::<i32>();'), (255, '    let (c_tx, c_rx) = oneshot::channel::<i32>();'), (256, '    let (d_tx, d_rx) = oneshot::channel::<i32>();'), (258, '    let mut cx = noop_context();'), (259, '    let mut stream = FuturesUnordered::new();'), (260, '    assert_eq!(stream.len(), 0);'), (262, '    stream.push(a_rx);'), (263, '    assert_eq!(stream.len(), 1);'), (264, '    stream.push(b_rx);'), (265, '    assert_eq!(stream.len(), 2);'), (266, '    stream.push(c_rx);'), (267, '    assert_eq!(stream.len(), 3);'), (269, '    b_tx.send(4).unwrap();'), (270, '    assert_eq!(stream.poll_next_unpin(&mut cx), Poll::Ready(Some(Ok(4))));'), (271, '    assert_eq!(stream.len(), 2);'), (273, '    stream.push(d_rx);'), (274, '    assert_eq!(stream.len(), 3);'), (276, '    c_tx.send(5).unwrap();'), (277, '    assert_eq!(stream.poll_next_unpin(&mut cx), Poll::Ready(Some(Ok(5))));'), (278, '    assert_eq!(stream.len(), 2);'), (280, '    d_tx.send(6).unwrap();'), (281, '    assert_eq!(stream.poll_next_unpin(&mut cx), Poll::Ready(Some(Ok(6))));'), (282, '    assert_eq!(stream.len(), 1);'), (284, '    a_tx.send(7).unwrap();'), (285, '    assert_eq!(stream.poll_next_unpin(&mut cx), Poll::Ready(Some(Ok(7))));'), (286, '    assert_eq!(stream.len(), 0);'), (287, '}')], 'deleted': []}",
    "num_lines_added": "30",
    "num_lines_deleted": "0",
    "nloc": "235"
  },
  {
    "file_change_id": "84364837611621",
    "hash": "70c87a49451c4dfcb170461ad9c55fe2f104b7b",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -748,7 +748,7 @@ impl<T> SliceDeque<T> {\n             new_head += cap as isize;\n             debug_assert!(new_head >= 0);\n             self.tail_ += cap;\n-        } else if new_head as usize > cap {\n+        } else if new_head as usize >= cap {\n             // cannot panic because new_head >= 0\n             // If the new head is larger than the capacity, we shift the range\n             // by -capacity to move it towards the first mirrored\n@@ -765,6 +765,8 @@ impl<T> SliceDeque<T> {\n \n         debug_assert!(self.tail() <= self.tail_upper_bound());\n         debug_assert!(self.head() <= self.head_upper_bound());\n+\n+        debug_assert!(self.head() != self.capacity());\n     }\n \n     /// Moves the deque head by `x`.\n@@ -5890,4 +5892,21 @@ mod tests {\n             assert_eq!(v.as_ptr() as usize, mem::align_of::<Foo>());\n         }\n     }\n+\n+    #[test]\n+    fn issue_57() {\n+        const C: [i16; 3] = [42; 3];\n+\n+        let mut deque = SliceDeque::new();\n+\n+        for _ in 0..918 {\n+            deque.push_front(C);\n+        }\n+\n+        for _ in 0..237 {\n+            assert_eq!(deque.pop_front(), Some(C));\n+            assert!(!deque.is_empty());\n+            assert_eq!(*deque.back().unwrap(), C);\n+        }\n+    }\n }\n",
    "diff_parsed": "{'added': [(751, '        } else if new_head as usize >= cap {'), (769, '        debug_assert!(self.head() != self.capacity());'), (5896, '    #[test]'), (5897, '    fn issue_57() {'), (5898, '        const C: [i16; 3] = [42; 3];'), (5900, '        let mut deque = SliceDeque::new();'), (5902, '        for _ in 0..918 {'), (5903, '            deque.push_front(C);'), (5904, '        }'), (5906, '        for _ in 0..237 {'), (5907, '            assert_eq!(deque.pop_front(), Some(C));'), (5908, '            assert!(!deque.is_empty());'), (5909, '            assert_eq!(*deque.back().unwrap(), C);'), (5910, '        }'), (5911, '    }')], 'deleted': [(751, '        } else if new_head as usize > cap {')]}",
    "num_lines_added": "15",
    "num_lines_deleted": "1",
    "nloc": "4031"
  },
  {
    "file_change_id": "88447332763606",
    "hash": "11f396ca9accf6ae000db13a44505b57608733c",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -27,7 +27,7 @@ pub struct LateStatic<T> {\n }\n \n unsafe impl<T: Send> core::marker::Send for LateStatic<T> {}\n-unsafe impl<T: Send> core::marker::Sync for LateStatic<T> {}\n+unsafe impl<T: Sync> core::marker::Sync for LateStatic<T> {}\n \n impl<T> LateStatic<T> {\n     /// Construct a LateStatic.\n",
    "diff_parsed": "{'added': [(30, 'unsafe impl<T: Sync> core::marker::Sync for LateStatic<T> {}')], 'deleted': [(30, 'unsafe impl<T: Send> core::marker::Sync for LateStatic<T> {}')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "126"
  },
  {
    "file_change_id": "93928299299058",
    "hash": "26b249075930b46cfafc70b1d18fd0cb35fd231",
    "old_path": "lib.rs",
    "new_path": "lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -771,24 +771,33 @@ impl<A: Array> SmallVec<A> {\n         unsafe {\n             let old_len = self.len();\n             assert!(index <= old_len);\n-            let ptr = self.as_mut_ptr().offset(index as isize);\n+            let mut ptr = self.as_mut_ptr().offset(index as isize);\n+\n+            // Move the trailing elements.\n             ptr::copy(ptr, ptr.offset(lower_size_bound as isize), old_len - index);\n-            for (off, element) in iter.enumerate() {\n-                if off < lower_size_bound {\n-                    ptr::write(ptr.offset(off as isize), element);\n-                    let len = self.len() + 1;\n-                    self.set_len(len);\n-                } else {\n-                    // Iterator provided more elements than the hint.\n-                    assert!(index + off >= index);  // Protect against overflow.\n-                    self.insert(index + off, element);\n+\n+            // In case the iterator panics, don't double-drop the items we just copied above.\n+            self.set_len(index);\n+\n+            let mut num_added = 0;\n+            for element in iter {\n+                let mut cur = ptr.offset(num_added as isize);\n+                if num_added >= lower_size_bound {\n+                    // Iterator provided more elements than the hint.  Move trailing items again.\n+                    self.reserve(1);\n+                    ptr = self.as_mut_ptr().offset(index as isize);\n+                    cur = ptr.offset(num_added as isize);\n+                    ptr::copy(cur, cur.offset(1), old_len - index);\n                 }\n+                ptr::write(cur, element);\n+                num_added += 1;\n             }\n-            let num_added = self.len() - old_len;\n             if num_added < lower_size_bound {\n                 // Iterator provided fewer elements than the hint\n                 ptr::copy(ptr.offset(lower_size_bound as isize), ptr.offset(num_added as isize), old_len - index);\n             }\n+\n+            self.set_len(old_len + num_added);\n         }\n     }\n \n@@ -1645,6 +1654,37 @@ mod tests {\n         assert_eq!(&v.iter().map(|v| *v).collect::<Vec<_>>(), &[0, 5, 6, 1, 2, 3]);\n     }\n \n+    #[test]\n+    // https://github.com/servo/rust-smallvec/issues/96\n+    fn test_insert_many_panic() {\n+        struct PanicOnDoubleDrop {\n+            dropped: Box<bool>\n+        }\n+\n+        impl Drop for PanicOnDoubleDrop {\n+            fn drop(&mut self) {\n+                assert!(!*self.dropped, \"already dropped\");\n+                *self.dropped = true;\n+            }\n+        }\n+\n+        struct BadIter;\n+        impl Iterator for BadIter {\n+            type Item = PanicOnDoubleDrop;\n+            fn size_hint(&self) -> (usize, Option<usize>) { (1, None) }\n+            fn next(&mut self) -> Option<Self::Item> { panic!() }\n+        }\n+\n+        let mut vec: SmallVec<[PanicOnDoubleDrop; 0]> = vec![\n+            PanicOnDoubleDrop { dropped: Box::new(false) },\n+            PanicOnDoubleDrop { dropped: Box::new(false) },\n+        ].into();\n+        let result = ::std::panic::catch_unwind(move || {\n+            vec.insert_many(0, BadIter);\n+        });\n+        assert!(result.is_err());\n+    }\n+\n     #[test]\n     #[should_panic]\n     fn test_invalid_grow() {\n",
    "diff_parsed": "{'added': [(774, '            let mut ptr = self.as_mut_ptr().offset(index as isize);'), (780, '            self.set_len(index);'), (782, '            let mut num_added = 0;'), (783, '            for element in iter {'), (784, '                let mut cur = ptr.offset(num_added as isize);'), (785, '                if num_added >= lower_size_bound {'), (787, '                    self.reserve(1);'), (788, '                    ptr = self.as_mut_ptr().offset(index as isize);'), (789, '                    cur = ptr.offset(num_added as isize);'), (790, '                    ptr::copy(cur, cur.offset(1), old_len - index);'), (792, '                ptr::write(cur, element);'), (793, '                num_added += 1;'), (800, '            self.set_len(old_len + num_added);'), (1657, '    #[test]'), (1659, '    fn test_insert_many_panic() {'), (1660, '        struct PanicOnDoubleDrop {'), (1661, '            dropped: Box<bool>'), (1662, '        }'), (1664, '        impl Drop for PanicOnDoubleDrop {'), (1665, '            fn drop(&mut self) {'), (1666, '                assert!(!*self.dropped, \"already dropped\");'), (1667, '                *self.dropped = true;'), (1668, '            }'), (1669, '        }'), (1671, '        struct BadIter;'), (1672, '        impl Iterator for BadIter {'), (1673, '            type Item = PanicOnDoubleDrop;'), (1674, '            fn size_hint(&self) -> (usize, Option<usize>) { (1, None) }'), (1675, '            fn next(&mut self) -> Option<Self::Item> { panic!() }'), (1676, '        }'), (1678, '        let mut vec: SmallVec<[PanicOnDoubleDrop; 0]> = vec!['), (1679, '            PanicOnDoubleDrop { dropped: Box::new(false) },'), (1680, '            PanicOnDoubleDrop { dropped: Box::new(false) },'), (1681, '        ].into();'), (1682, '        let result = ::std::panic::catch_unwind(move || {'), (1683, '            vec.insert_many(0, BadIter);'), (1684, '        });'), (1685, '        assert!(result.is_err());'), (1686, '    }')], 'deleted': [(774, '            let ptr = self.as_mut_ptr().offset(index as isize);'), (776, '            for (off, element) in iter.enumerate() {'), (777, '                if off < lower_size_bound {'), (778, '                    ptr::write(ptr.offset(off as isize), element);'), (779, '                    let len = self.len() + 1;'), (780, '                    self.set_len(len);'), (781, '                } else {'), (783, '                    assert!(index + off >= index);  // Protect against overflow.'), (784, '                    self.insert(index + off, element);'), (787, '            let num_added = self.len() - old_len;')]}",
    "num_lines_added": "39",
    "num_lines_deleted": "10",
    "nloc": "1552"
  },
  {
    "file_change_id": "212577837664379",
    "hash": "1f4025218c4321ea42ad01d80dd6110def2d86d",
    "old_path": "lib.rs",
    "new_path": "lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -946,19 +946,17 @@ impl<A: Array> SmallVec<A> where A::Item: Clone {\n         if n > A::size() {\n             vec![elem; n].into()\n         } else {\n+            let mut v = SmallVec::<A>::new();\n             unsafe {\n-                let mut arr: A = ::std::mem::uninitialized();\n-                let ptr = arr.ptr_mut();\n+                let (ptr, len_ptr, _) = v.triple_mut();\n+                let mut local_len = SetLenOnDrop::new(len_ptr);\n \n                 for i in 0..n as isize {\n                     ::std::ptr::write(ptr.offset(i), elem.clone());\n-                }\n-\n-                SmallVec {\n-                    capacity: n,\n-                    data: SmallVecData::from_inline(arr),\n+                    local_len.increment_len(1);\n                 }\n             }\n+            v\n         }\n     }\n }\n@@ -1346,6 +1344,33 @@ pub unsafe trait Array {\n     fn ptr_mut(&mut self) -> *mut Self::Item;\n }\n \n+/// Set the length of the vec when the `SetLenOnDrop` value goes out of scope.\n+///\n+/// Copied from https://github.com/rust-lang/rust/pull/36355\n+struct SetLenOnDrop<'a> {\n+    len: &'a mut usize,\n+    local_len: usize,\n+}\n+\n+impl<'a> SetLenOnDrop<'a> {\n+    #[inline]\n+    fn new(len: &'a mut usize) -> Self {\n+        SetLenOnDrop { local_len: *len, len: len }\n+    }\n+\n+    #[inline]\n+    fn increment_len(&mut self, increment: usize) {\n+        self.local_len += increment;\n+    }\n+}\n+\n+impl<'a> Drop for SetLenOnDrop<'a> {\n+    #[inline]\n+    fn drop(&mut self) {\n+        *self.len = self.local_len;\n+    }\n+}\n+\n macro_rules! impl_array(\n     ($($size:expr),+) => {\n         $(\n",
    "diff_parsed": "{'added': [(949, '            let mut v = SmallVec::<A>::new();'), (951, '                let (ptr, len_ptr, _) = v.triple_mut();'), (952, '                let mut local_len = SetLenOnDrop::new(len_ptr);'), (956, '                    local_len.increment_len(1);'), (959, '            v'), (1350, \"struct SetLenOnDrop<'a> {\"), (1351, \"    len: &'a mut usize,\"), (1352, '    local_len: usize,'), (1353, '}'), (1355, \"impl<'a> SetLenOnDrop<'a> {\"), (1356, '    #[inline]'), (1357, \"    fn new(len: &'a mut usize) -> Self {\"), (1358, '        SetLenOnDrop { local_len: *len, len: len }'), (1359, '    }'), (1361, '    #[inline]'), (1362, '    fn increment_len(&mut self, increment: usize) {'), (1363, '        self.local_len += increment;'), (1364, '    }'), (1365, '}'), (1367, \"impl<'a> Drop for SetLenOnDrop<'a> {\"), (1368, '    #[inline]'), (1369, '    fn drop(&mut self) {'), (1370, '        *self.len = self.local_len;'), (1371, '    }'), (1372, '}')], 'deleted': [(950, '                let mut arr: A = ::std::mem::uninitialized();'), (951, '                let ptr = arr.ptr_mut();'), (955, '                }'), (957, '                SmallVec {'), (958, '                    capacity: n,'), (959, '                    data: SmallVecData::from_inline(arr),')]}",
    "num_lines_added": "25",
    "num_lines_deleted": "6",
    "nloc": "1605"
  },
  {
    "file_change_id": "129576123153853",
    "hash": "b1f4e6d166b6c5cc693bfbfe5856db4b098dbd8",
    "old_path": "src/tcell.rs",
    "new_path": "src/tcell.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -5,6 +5,10 @@ use std::collections::HashSet;\n use std::marker::PhantomData;\n use std::sync::{Condvar, Mutex};\n \n+// needs an abstraction as a struct, otherwise we'll get spurious error\n+// regarding \"function pointers cannot appear in constant functions\"\n+struct Invariant<Q>(fn(Q) -> Q);\n+\n static SINGLETON_CHECK: Lazy<Mutex<HashSet<TypeId>>> = Lazy::new(|| Mutex::new(HashSet::new()));\n static SINGLETON_CHECK_CONDVAR: Lazy<Condvar> = Lazy::new(Condvar::new);\n \n@@ -13,8 +17,8 @@ static SINGLETON_CHECK_CONDVAR: Lazy<Condvar> = Lazy::new(Condvar::new);\n ///\n /// See [crate documentation](index.html).\n pub struct TCellOwner<Q: 'static> {\n-    // Allow Send and Sync\n-    typ: PhantomData<Q>,\n+    // Allow Send and Sync, and Q is invariant\n+    typ: PhantomData<Invariant<Q>>,\n }\n \n impl<Q: 'static> Drop for TCellOwner<Q> {\n@@ -174,9 +178,11 @@ impl<Q: 'static> TCellOwner<Q> {\n ///\n /// [`TCellOwner`]: struct.TCellOwner.html\n pub struct TCell<Q, T: ?Sized> {\n-    // Use *const to disable Send and Sync, which are then re-enabled\n-    // below under certain conditions\n-    owner: PhantomData<*const Q>,\n+    // Use *const () to disable Send and Sync, which are then re-enabled\n+    // below under certain conditions,\n+    // use Invariant<Q> for invariant parameter, not influencing\n+    // other auto-traits like UnwindSafe\n+    owner: PhantomData<(*const (), Invariant<Q>)>,\n     value: UnsafeCell<T>,\n }\n \n",
    "diff_parsed": "{'added': [(10, 'struct Invariant<Q>(fn(Q) -> Q);'), (21, '    typ: PhantomData<Invariant<Q>>,'), (185, '    owner: PhantomData<(*const (), Invariant<Q>)>,')], 'deleted': [(17, '    typ: PhantomData<Q>,'), (179, '    owner: PhantomData<*const Q>,')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "2",
    "nloc": "297"
  },
  {
    "file_change_id": "204350284900545",
    "hash": "b1f4e6d166b6c5cc693bfbfe5856db4b098dbd8",
    "old_path": "src/tlcell.rs",
    "new_path": "src/tlcell.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -3,6 +3,10 @@ use std::cell::UnsafeCell;\n use std::collections::HashSet;\n use std::marker::PhantomData;\n \n+// needs an abstraction as a struct, otherwise we'll get spurious error\n+// regarding \"function pointers cannot appear in constant functions\"\n+struct Invariant<Q>(fn(Q) -> Q);\n+\n std::thread_local! {\n     static SINGLETON_CHECK: std::cell::RefCell<HashSet<TypeId>> = std::cell::RefCell::new(HashSet::new());\n }\n@@ -12,8 +16,10 @@ std::thread_local! {\n ///\n /// See [crate documentation](index.html).\n pub struct TLCellOwner<Q: 'static> {\n-    // Use *const to disable Send and Sync\n-    typ: PhantomData<*const Q>,\n+    // Use *const () to disable Send and Sync,\n+    // use Invariant<Q> for invariant parameter, not influencing\n+    // other auto-traits like UnwindSafe\n+    typ: PhantomData<(*const (), Invariant<Q>)>,\n }\n \n impl<Q: 'static> Drop for TLCellOwner<Q> {\n@@ -123,8 +129,10 @@ impl<Q: 'static> TLCellOwner<Q> {\n ///\n /// [`TLCellOwner`]: struct.TLCellOwner.html\n pub struct TLCell<Q, T: ?Sized> {\n-    // Use *const to disable Send and Sync\n-    owner: PhantomData<*const Q>,\n+    // Use *const () to disable Send and Sync,\n+    // use Invariant<Q> for invariant parameter, not influencing\n+    // other auto-traits like UnwindSafe\n+    owner: PhantomData<(*const (), Invariant<Q>)>,\n     value: UnsafeCell<T>,\n }\n \n",
    "diff_parsed": "{'added': [(8, 'struct Invariant<Q>(fn(Q) -> Q);'), (22, '    typ: PhantomData<(*const (), Invariant<Q>)>,'), (135, '    owner: PhantomData<(*const (), Invariant<Q>)>,')], 'deleted': [(16, '    typ: PhantomData<*const Q>,'), (127, '    owner: PhantomData<*const Q>,')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "2",
    "nloc": "212"
  },
  {
    "file_change_id": "222172617297670",
    "hash": "b03b1588858f0a47ab5909bfa6b4e1b395292b16",
    "old_path": "src/lcell.rs",
    "new_path": "src/lcell.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,7 +1,8 @@\n use std::cell::{Cell, UnsafeCell};\n use std::marker::PhantomData;\n+struct Invariant<Q>(fn(Q) -> Q);\n \n-type Id<'id> = PhantomData<Cell<&'id mut ()>>;\n+type Id<'id> = PhantomData<Invariant<&'id ()>>;\n \n /// Borrowing-owner of zero or more [`LCell`](struct.LCell.html)\n /// instances.\n@@ -169,7 +170,7 @@ impl<'id, T: ?Sized> LCell<'id, T> {\n     }\n }\n \n-// LCellOwner and LCell already automatically implement Send, but not\n+// LCell already automatically implements Send, but not\n // Sync. We can add these implementations though, since it's fine to\n // send a &LCell to another thread, and even mutably borrow the value\n // there, as long as T is Send and Sync.\n@@ -185,7 +186,6 @@ impl<'id, T: ?Sized> LCell<'id, T> {\n // as those of std::sync::RwLock<T>. That's not a coincidence.\n // The way these types let you access T concurrently is the same,\n // even though the locking mechanisms are different.\n-unsafe impl<'id> Sync for LCellOwner<'id> {}\n unsafe impl<'id, T: Send + Sync + ?Sized> Sync for LCell<'id, T> {}\n \n #[cfg(test)]\n",
    "diff_parsed": "{'added': [(3, 'struct Invariant<Q>(fn(Q) -> Q);'), (5, \"type Id<'id> = PhantomData<Invariant<&'id ()>>;\")], 'deleted': [(4, \"type Id<'id> = PhantomData<Cell<&'id mut ()>>;\"), (188, \"unsafe impl<'id> Sync for LCellOwner<'id> {}\")]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "220"
  },
  {
    "file_change_id": "245169591503478",
    "hash": "392a889f02c17edf0df4a9c08c134896b045387",
    "old_path": "futures-util/src/lock/mutex.rs",
    "new_path": "futures-util/src/lock/mutex.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -3,15 +3,16 @@ use futures_core::task::{Context, Poll, Waker};\n use slab::Slab;\n use std::{fmt, mem};\n use std::cell::UnsafeCell;\n+use std::marker::PhantomData;\n use std::ops::{Deref, DerefMut};\n use std::pin::Pin;\n use std::sync::Mutex as StdMutex;\n use std::sync::atomic::{AtomicUsize, Ordering};\n \n /// A futures-aware mutex.\n-/// \n+///\n /// # Fairness\n-/// \n+///\n /// This mutex provides no fairness guarantees. Tasks may not acquire the mutex\n /// in the order that they requested the lock, and it's possible for a single task\n /// which repeatedly takes the lock to starve other tasks, which may be left waiting\n@@ -288,7 +289,7 @@ impl<'a, T: ?Sized> MutexGuard<'a, T> {\n         // Don't run the `drop` method for MutexGuard. The ownership of the underlying\n         // locked state is being moved to the returned MappedMutexGuard.\n         mem::forget(this);\n-        MappedMutexGuard { mutex, value }\n+        MappedMutexGuard { mutex, value, _marker: PhantomData }\n     }\n }\n \n@@ -325,6 +326,7 @@ impl<T: ?Sized> DerefMut for MutexGuard<'_, T> {\n pub struct MappedMutexGuard<'a, T: ?Sized, U: ?Sized> {\n     mutex: &'a Mutex<T>,\n     value: *mut U,\n+    _marker: PhantomData<&'a mut U>,\n }\n \n impl<'a, T: ?Sized, U: ?Sized> MappedMutexGuard<'a, T, U> {\n@@ -354,7 +356,7 @@ impl<'a, T: ?Sized, U: ?Sized> MappedMutexGuard<'a, T, U> {\n         // Don't run the `drop` method for MappedMutexGuard. The ownership of the underlying\n         // locked state is being moved to the returned MappedMutexGuard.\n         mem::forget(this);\n-        MappedMutexGuard { mutex, value }\n+        MappedMutexGuard { mutex, value, _marker: PhantomData }\n     }\n }\n \n@@ -401,8 +403,8 @@ unsafe impl<T: ?Sized> Sync for MutexLockFuture<'_, T> {}\n // lock is essentially spinlock-equivalent (attempt to flip an atomic bool)\n unsafe impl<T: ?Sized + Send> Send for MutexGuard<'_, T> {}\n unsafe impl<T: ?Sized + Sync> Sync for MutexGuard<'_, T> {}\n-unsafe impl<T: ?Sized + Send, U: ?Sized> Send for MappedMutexGuard<'_, T, U> {}\n-unsafe impl<T: ?Sized + Sync, U: ?Sized> Sync for MappedMutexGuard<'_, T, U> {}\n+unsafe impl<T: ?Sized + Send, U: ?Sized + Send> Send for MappedMutexGuard<'_, T, U> {}\n+unsafe impl<T: ?Sized + Sync, U: ?Sized + Sync> Sync for MappedMutexGuard<'_, T, U> {}\n \n #[test]\n fn test_mutex_guard_debug_not_recurse() {\n",
    "diff_parsed": "{'added': [(6, 'use std::marker::PhantomData;'), (292, '        MappedMutexGuard { mutex, value, _marker: PhantomData }'), (329, \"    _marker: PhantomData<&'a mut U>,\"), (359, '        MappedMutexGuard { mutex, value, _marker: PhantomData }'), (406, \"unsafe impl<T: ?Sized + Send, U: ?Sized + Send> Send for MappedMutexGuard<'_, T, U> {}\"), (407, \"unsafe impl<T: ?Sized + Sync, U: ?Sized + Sync> Sync for MappedMutexGuard<'_, T, U> {}\")], 'deleted': [(291, '        MappedMutexGuard { mutex, value }'), (357, '        MappedMutexGuard { mutex, value }'), (404, \"unsafe impl<T: ?Sized + Send, U: ?Sized> Send for MappedMutexGuard<'_, T, U> {}\"), (405, \"unsafe impl<T: ?Sized + Sync, U: ?Sized> Sync for MappedMutexGuard<'_, T, U> {}\")]}",
    "num_lines_added": "6",
    "num_lines_deleted": "4",
    "nloc": "335"
  },
  {
    "file_change_id": "49001906287265",
    "hash": "0e6006de464caa331643f86cd2d9ba3b32b0983",
    "old_path": "src/de.rs",
    "new_path": "src/de.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -70,7 +70,7 @@ where\n     fn read_vec(&mut self) -> Result<Vec<u8>> {\n         let len: u32 = de::Deserialize::deserialize(&mut *self)?;\n         let mut buf = Vec::with_capacity(len as usize);\n-        unsafe { buf.set_len(len as usize) }\n+        buf.resize(len as usize, 0);\n         self.read_size(u64::from(len))?;\n         self.reader.read_exact(&mut buf[..])?;\n         Ok(buf)\n",
    "diff_parsed": "{'added': [(73, '        buf.resize(len as usize, 0);')], 'deleted': [(73, '        unsafe { buf.set_len(len as usize) }')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "452"
  },
  {
    "file_change_id": "273745510541398",
    "hash": "aabf5562f8c6374ab30f615b28e0cff9b5c79e5",
    "old_path": "src/greedy.rs",
    "new_path": "src/greedy.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -15,6 +15,7 @@ use std::ops::RangeBounds;\n /// [`std::io::BufReader`]: https://doc.rust-lang.org/std/io/struct.BufReader.html\n /// [`new`]: ./struct.GreedyAccessReader.html#method.new\n /// [`with_capacity`]: ./struct.GreedyAccessReader.html#method.with_capacity\n+#[derive(Debug, Clone)]\n pub struct GreedyAccessReader<R> {\n     inner: R,\n     buf: Vec<u8>,\n@@ -197,26 +198,14 @@ where\n         }\n \n         let b = self.buf.len();\n-        let buf = unsafe {\n-            // safe because it's within the buffer's limits\n-            // and we won't be reading uninitialized memory\n-            std::slice::from_raw_parts_mut(\n-                self.buf.as_mut_ptr().add(b),\n-                self.buf.capacity() - b)\n-        };\n+        self.buf.resize(self.buf.capacity(), 0);\n+        let buf = &mut self.buf[b..];\n+        let o = self.inner.read(buf)?;\n \n-        match self.inner.read(buf) {\n-            Ok(o) => {\n-                unsafe {\n-                    // reset the size to include the written portion,\n-                    // safe because the extra data is initialized\n-                    self.buf.set_len(b + o);\n-                }\n+        // truncate to exclude non-written portion\n+        self.buf.truncate(b + o);\n \n-                Ok(&self.buf[self.consumed..])\n-            }\n-            Err(e) => Err(e),\n-        }\n+        Ok(&self.buf[self.consumed..])\n     }\n \n     fn consume(&mut self, amt: usize) {\n",
    "diff_parsed": "{'added': [(18, '#[derive(Debug, Clone)]'), (201, '        self.buf.resize(self.buf.capacity(), 0);'), (202, '        let buf = &mut self.buf[b..];'), (203, '        let o = self.inner.read(buf)?;'), (206, '        self.buf.truncate(b + o);'), (208, '        Ok(&self.buf[self.consumed..])')], 'deleted': [(200, '        let buf = unsafe {'), (203, '            std::slice::from_raw_parts_mut('), (204, '                self.buf.as_mut_ptr().add(b),'), (205, '                self.buf.capacity() - b)'), (206, '        };'), (208, '        match self.inner.read(buf) {'), (209, '            Ok(o) => {'), (210, '                unsafe {'), (213, '                    self.buf.set_len(b + o);'), (214, '                }'), (216, '                Ok(&self.buf[self.consumed..])'), (217, '            }'), (218, '            Err(e) => Err(e),'), (219, '        }')]}",
    "num_lines_added": "6",
    "num_lines_deleted": "14",
    "nloc": "214"
  },
  {
    "file_change_id": "45055834166573",
    "hash": "f6d9bc6e8f6ad7f0d949a444a1c1d91d6d837e6",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -126,7 +126,7 @@ impl<T, U> LazyTransform<T, U>\n \n unsafe impl<T, U> Sync for LazyTransform<T, U>\n     where T: Sync + Send,\n-          U: Sync\n+          U: Send + Sync\n {\n }\n \n",
    "diff_parsed": "{'added': [(129, '          U: Send + Sync')], 'deleted': [(129, '          U: Sync')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "184"
  },
  {
    "file_change_id": "49638915142181",
    "hash": "50a50ed90d6ad78d812a40680257d8338843869",
    "old_path": "lib.rs",
    "new_path": "lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -654,6 +654,7 @@ impl<A: Array> SmallVec<A> {\n                 }\n                 self.data = SmallVecData::from_inline(mem::uninitialized());\n                 ptr::copy_nonoverlapping(ptr, self.data.inline_mut().ptr_mut(), len);\n+                self.capacity = len;\n             } else if new_cap != cap {\n                 let mut vec = Vec::with_capacity(new_cap);\n                 let new_alloc = vec.as_mut_ptr();\n@@ -2311,4 +2312,21 @@ mod tests {\n         let decoded: SmallVec<[i32; 2]> = deserialize(&encoded).unwrap();\n         assert_eq!(small_vec, decoded);\n     }\n+\n+    #[test]\n+    fn grow_to_shrink() {\n+        let mut v: SmallVec<[u8; 2]> = SmallVec::new();\n+        v.push(1);\n+        v.push(2);\n+        v.push(3);\n+        assert!(v.spilled());\n+        v.clear();\n+        // Shrink to inline.\n+        v.grow(2);\n+        assert!(!v.spilled());\n+        assert_eq!(v.capacity(), 2);\n+        assert_eq!(v.len(), 0);\n+        v.push(4);\n+        assert_eq!(v[..], [4]);\n+    }\n }\n",
    "diff_parsed": "{'added': [(657, '                self.capacity = len;'), (2316, '    #[test]'), (2317, '    fn grow_to_shrink() {'), (2318, '        let mut v: SmallVec<[u8; 2]> = SmallVec::new();'), (2319, '        v.push(1);'), (2320, '        v.push(2);'), (2321, '        v.push(3);'), (2322, '        assert!(v.spilled());'), (2323, '        v.clear();'), (2325, '        v.grow(2);'), (2326, '        assert!(!v.spilled());'), (2327, '        assert_eq!(v.capacity(), 2);'), (2328, '        assert_eq!(v.len(), 0);'), (2329, '        v.push(4);'), (2330, '        assert_eq!(v[..], [4]);'), (2331, '    }')], 'deleted': []}",
    "num_lines_added": "16",
    "num_lines_deleted": "0",
    "nloc": "1692"
  },
  {
    "file_change_id": "262019079031315",
    "hash": "ea809ba4ae37c4b0de54158e05699f1907c9e83",
    "old_path": "ash/src/util.rs",
    "new_path": "ash/src/util.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -113,15 +113,12 @@ pub fn read_spv<R: io::Read + io::Seek>(x: &mut R) -> io::Result<Vec<u32>> {\n         return Err(io::Error::new(io::ErrorKind::InvalidData, \"input too long\"));\n     }\n     let words = (size / 4) as usize;\n-    let mut result = Vec::<u32>::with_capacity(words);\n+    // https://github.com/MaikKlein/ash/issues/354:\n+    // Zero-initialize the result to prevent read_exact from possibly\n+    // reading uninitialized memory.\n+    let mut result = vec![0u32; words];\n     x.seek(io::SeekFrom::Start(0))?;\n-    unsafe {\n-        x.read_exact(slice::from_raw_parts_mut(\n-            result.as_mut_ptr() as *mut u8,\n-            words * 4,\n-        ))?;\n-        result.set_len(words);\n-    }\n+    x.read_exact(unsafe { slice::from_raw_parts_mut(result.as_mut_ptr() as *mut u8, words * 4) })?;\n     const MAGIC_NUMBER: u32 = 0x0723_0203;\n     if !result.is_empty() && result[0] == MAGIC_NUMBER.swap_bytes() {\n         for word in &mut result {\n",
    "diff_parsed": "{'added': [(119, '    let mut result = vec![0u32; words];'), (121, '    x.read_exact(unsafe { slice::from_raw_parts_mut(result.as_mut_ptr() as *mut u8, words * 4) })?;')], 'deleted': [(116, '    let mut result = Vec::<u32>::with_capacity(words);'), (118, '    unsafe {'), (119, '        x.read_exact(slice::from_raw_parts_mut('), (120, '            result.as_mut_ptr() as *mut u8,'), (121, '            words * 4,'), (122, '        ))?;'), (123, '        result.set_len(words);'), (124, '    }')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "8",
    "nloc": "102"
  },
  {
    "file_change_id": "8331358240533",
    "hash": "ffa2e8d54e4701e4d1f11fcfa5e1497ed6d4c8d",
    "old_path": "src/hazardous/hash/blake2b.rs",
    "new_path": "src/hazardous/hash/blake2b.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -305,30 +305,26 @@ impl Blake2b {\n \t#[inline(always)]\n \t/// Reset to `init()` state.\n \tpub fn reset(&mut self, secret_key: Option<&SecretKey>) -> Result<(), UnknownCryptoError> {\n-\t\tif self.is_finalized {\n-\t\t\tif secret_key.is_some() && (!self.is_keyed) {\n-\t\t\t\treturn Err(UnknownCryptoError);\n-\t\t\t}\n+\t\tif secret_key.is_some() && (!self.is_keyed) {\n+\t\t\treturn Err(UnknownCryptoError);\n+\t\t}\n \n-\t\t\tif secret_key.is_none() && self.is_keyed {\n-\t\t\t\treturn Err(UnknownCryptoError);\n-\t\t\t}\n+\t\tif secret_key.is_none() && self.is_keyed {\n+\t\t\treturn Err(UnknownCryptoError);\n+\t\t}\n \n-\t\t\tself.internal_state.copy_from_slice(&self.init_state);\n-\t\t\tself.buffer = [0u8; BLAKE2B_BLOCKSIZE];\n-\t\t\tself.leftover = 0;\n-\t\t\tself.t = [0u64; 2];\n-\t\t\tself.f = [0u64; 2];\n-\t\t\tself.is_finalized = false;\n+\t\tself.internal_state.copy_from_slice(&self.init_state);\n+\t\tself.buffer = [0u8; BLAKE2B_BLOCKSIZE];\n+\t\tself.leftover = 0;\n+\t\tself.t = [0u64; 2];\n+\t\tself.f = [0u64; 2];\n+\t\tself.is_finalized = false;\n \n-\t\t\tif secret_key.is_some() && self.is_keyed {\n-\t\t\t\tself.update(secret_key.unwrap().unprotected_as_bytes())?;\n-\t\t\t}\n-\n-\t\t\tOk(())\n-\t\t} else {\n-\t\t\tOk(())\n+\t\tif secret_key.is_some() && self.is_keyed {\n+\t\t\tself.update(secret_key.unwrap().unprotected_as_bytes())?;\n \t\t}\n+\n+\t\tOk(())\n \t}\n \n \t#[must_use]\n@@ -596,3 +592,22 @@ fn err_on_keyed_switch_on_reset() {\n \tlet _ = state_second.finalize().unwrap();\n \tassert!(state_second.reset(Some(&secret_key)).is_err());\n }\n+\n+#[test]\n+fn reset_after_update_correct_resets() {\n+\tlet state_1 = init(None, 64).unwrap();\n+\n+\tlet mut state_2 = init(None, 64).unwrap();\n+\tstate_2.update(b\"Tests\").unwrap();\n+\tstate_2.reset(None).unwrap();\n+\n+\tassert_eq!(state_1.init_state, state_2.init_state);\n+\tassert_eq!(state_1.internal_state, state_2.internal_state);\n+\tassert_eq!(state_1.buffer[..], state_2.buffer[..]);\n+\tassert_eq!(state_1.leftover, state_2.leftover);\n+\tassert_eq!(state_1.t, state_2.t);\n+\tassert_eq!(state_1.f, state_2.f);\n+\tassert_eq!(state_1.is_finalized, state_2.is_finalized);\n+\tassert_eq!(state_1.is_keyed, state_2.is_keyed);\n+\tassert_eq!(state_1.size, state_2.size);\n+}\n",
    "diff_parsed": "{'added': [(308, '\\t\\tif secret_key.is_some() && (!self.is_keyed) {'), (309, '\\t\\t\\treturn Err(UnknownCryptoError);'), (310, '\\t\\t}'), (312, '\\t\\tif secret_key.is_none() && self.is_keyed {'), (313, '\\t\\t\\treturn Err(UnknownCryptoError);'), (314, '\\t\\t}'), (316, '\\t\\tself.internal_state.copy_from_slice(&self.init_state);'), (317, '\\t\\tself.buffer = [0u8; BLAKE2B_BLOCKSIZE];'), (318, '\\t\\tself.leftover = 0;'), (319, '\\t\\tself.t = [0u64; 2];'), (320, '\\t\\tself.f = [0u64; 2];'), (321, '\\t\\tself.is_finalized = false;'), (323, '\\t\\tif secret_key.is_some() && self.is_keyed {'), (324, '\\t\\t\\tself.update(secret_key.unwrap().unprotected_as_bytes())?;'), (327, '\\t\\tOk(())'), (596, '#[test]'), (597, 'fn reset_after_update_correct_resets() {'), (598, '\\tlet state_1 = init(None, 64).unwrap();'), (600, '\\tlet mut state_2 = init(None, 64).unwrap();'), (601, '\\tstate_2.update(b\"Tests\").unwrap();'), (602, '\\tstate_2.reset(None).unwrap();'), (604, '\\tassert_eq!(state_1.init_state, state_2.init_state);'), (605, '\\tassert_eq!(state_1.internal_state, state_2.internal_state);'), (606, '\\tassert_eq!(state_1.buffer[..], state_2.buffer[..]);'), (607, '\\tassert_eq!(state_1.leftover, state_2.leftover);'), (608, '\\tassert_eq!(state_1.t, state_2.t);'), (609, '\\tassert_eq!(state_1.f, state_2.f);'), (610, '\\tassert_eq!(state_1.is_finalized, state_2.is_finalized);'), (611, '\\tassert_eq!(state_1.is_keyed, state_2.is_keyed);'), (612, '\\tassert_eq!(state_1.size, state_2.size);'), (613, '}')], 'deleted': [(308, '\\t\\tif self.is_finalized {'), (309, '\\t\\t\\tif secret_key.is_some() && (!self.is_keyed) {'), (310, '\\t\\t\\t\\treturn Err(UnknownCryptoError);'), (311, '\\t\\t\\t}'), (313, '\\t\\t\\tif secret_key.is_none() && self.is_keyed {'), (314, '\\t\\t\\t\\treturn Err(UnknownCryptoError);'), (315, '\\t\\t\\t}'), (317, '\\t\\t\\tself.internal_state.copy_from_slice(&self.init_state);'), (318, '\\t\\t\\tself.buffer = [0u8; BLAKE2B_BLOCKSIZE];'), (319, '\\t\\t\\tself.leftover = 0;'), (320, '\\t\\t\\tself.t = [0u64; 2];'), (321, '\\t\\t\\tself.f = [0u64; 2];'), (322, '\\t\\t\\tself.is_finalized = false;'), (324, '\\t\\t\\tif secret_key.is_some() && self.is_keyed {'), (325, '\\t\\t\\t\\tself.update(secret_key.unwrap().unprotected_as_bytes())?;'), (326, '\\t\\t\\t}'), (328, '\\t\\t\\tOk(())'), (329, '\\t\\t} else {'), (330, '\\t\\t\\tOk(())')]}",
    "num_lines_added": "31",
    "num_lines_deleted": "19",
    "nloc": "431"
  },
  {
    "file_change_id": "105592746234952",
    "hash": "ffa2e8d54e4701e4d1f11fcfa5e1497ed6d4c8d",
    "old_path": "src/hazardous/mac/hmac.rs",
    "new_path": "src/hazardous/mac/hmac.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -147,11 +147,8 @@ impl Hmac {\n \n \t/// Reset to `init()` state.\n \tpub fn reset(&mut self) {\n-\t\tif self.is_finalized {\n-\t\t\tself.ipad_hasher.input(self.ipad.as_ref());\n-\t\t\tself.is_finalized = false;\n-\t\t} else {\n-\t\t}\n+\t\tself.ipad_hasher.input(self.ipad.as_ref());\n+\t\tself.is_finalized = false;\n \t}\n \n \t#[must_use]\n@@ -350,3 +347,17 @@ fn double_reset_ok() {\n \ttag.reset();\n \ttag.reset();\n }\n+\n+#[test]\n+fn reset_after_update_correct_resets() {\n+\tlet secret_key = SecretKey::from_slice(\"Jefe\".as_bytes());\n+\n+\tlet state_1 = init(&secret_key);\n+\n+\tlet mut state_2 = init(&secret_key);\n+\tstate_2.update(b\"Tests\").unwrap();\n+\tstate_2.reset();\n+\n+\tassert_eq!(state_1.ipad[..], state_2.ipad[..]);\n+\tassert_eq!(state_1.is_finalized, state_2.is_finalized);\n+}\n",
    "diff_parsed": "{'added': [(150, '\\t\\tself.ipad_hasher.input(self.ipad.as_ref());'), (151, '\\t\\tself.is_finalized = false;'), (351, '#[test]'), (352, 'fn reset_after_update_correct_resets() {'), (353, '\\tlet secret_key = SecretKey::from_slice(\"Jefe\".as_bytes());'), (355, '\\tlet state_1 = init(&secret_key);'), (357, '\\tlet mut state_2 = init(&secret_key);'), (358, '\\tstate_2.update(b\"Tests\").unwrap();'), (359, '\\tstate_2.reset();'), (361, '\\tassert_eq!(state_1.ipad[..], state_2.ipad[..]);'), (362, '\\tassert_eq!(state_1.is_finalized, state_2.is_finalized);'), (363, '}')], 'deleted': [(150, '\\t\\tif self.is_finalized {'), (151, '\\t\\t\\tself.ipad_hasher.input(self.ipad.as_ref());'), (152, '\\t\\t\\tself.is_finalized = false;'), (153, '\\t\\t} else {'), (154, '\\t\\t}')]}",
    "num_lines_added": "12",
    "num_lines_deleted": "5",
    "nloc": "222"
  },
  {
    "file_change_id": "30993371307958",
    "hash": "ffa2e8d54e4701e4d1f11fcfa5e1497ed6d4c8d",
    "old_path": "src/hazardous/mac/poly1305.rs",
    "new_path": "src/hazardous/mac/poly1305.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -294,12 +294,10 @@ impl Poly1305 {\n \t#[inline(always)]\n \t/// Reset to `init()` state.\n \tpub fn reset(&mut self) {\n-\t\tif self.is_finalized {\n-\t\t\tself.a = [0u32; 5];\n-\t\t\tself.leftover = 0;\n-\t\t\tself.is_finalized = false;\n-\t\t} else {\n-\t\t}\n+\t\tself.a = [0u32; 5];\n+\t\tself.leftover = 0;\n+\t\tself.is_finalized = false;\n+\t\tself.buffer = [0u8; POLY1305_BLOCKSIZE];\n \t}\n \n \t#[must_use]\n@@ -524,3 +522,21 @@ fn double_reset_ok() {\n \tpoly1305_state.reset();\n \tpoly1305_state.reset();\n }\n+\n+#[test]\n+fn reset_after_update_correct_resets() {\n+\tlet secret_key = OneTimeKey::from_slice(&[0u8; 32]).unwrap();\n+\n+\tlet state_1 = init(&secret_key);\n+\n+\tlet mut state_2 = init(&secret_key);\n+\tstate_2.update(b\"Tests\").unwrap();\n+\tstate_2.reset();\n+\n+\tassert_eq!(state_1.a, state_2.a);\n+\tassert_eq!(state_1.r, state_2.r);\n+\tassert_eq!(state_1.s, state_2.s);\n+\tassert_eq!(state_1.leftover, state_2.leftover);\n+\tassert_eq!(state_1.buffer[..], state_2.buffer[..]);\n+\tassert_eq!(state_1.is_finalized, state_2.is_finalized);\n+}\n",
    "diff_parsed": "{'added': [(297, '\\t\\tself.a = [0u32; 5];'), (298, '\\t\\tself.leftover = 0;'), (299, '\\t\\tself.is_finalized = false;'), (300, '\\t\\tself.buffer = [0u8; POLY1305_BLOCKSIZE];'), (526, '#[test]'), (527, 'fn reset_after_update_correct_resets() {'), (528, '\\tlet secret_key = OneTimeKey::from_slice(&[0u8; 32]).unwrap();'), (530, '\\tlet state_1 = init(&secret_key);'), (532, '\\tlet mut state_2 = init(&secret_key);'), (533, '\\tstate_2.update(b\"Tests\").unwrap();'), (534, '\\tstate_2.reset();'), (536, '\\tassert_eq!(state_1.a, state_2.a);'), (537, '\\tassert_eq!(state_1.r, state_2.r);'), (538, '\\tassert_eq!(state_1.s, state_2.s);'), (539, '\\tassert_eq!(state_1.leftover, state_2.leftover);'), (540, '\\tassert_eq!(state_1.buffer[..], state_2.buffer[..]);'), (541, '\\tassert_eq!(state_1.is_finalized, state_2.is_finalized);'), (542, '}')], 'deleted': [(297, '\\t\\tif self.is_finalized {'), (298, '\\t\\t\\tself.a = [0u32; 5];'), (299, '\\t\\t\\tself.leftover = 0;'), (300, '\\t\\t\\tself.is_finalized = false;'), (301, '\\t\\t} else {'), (302, '\\t\\t}')]}",
    "num_lines_added": "18",
    "num_lines_deleted": "6",
    "nloc": "378"
  },
  {
    "file_change_id": "107228774445850",
    "hash": "ffa2e8d54e4701e4d1f11fcfa5e1497ed6d4c8d",
    "old_path": "src/hazardous/xof/cshake.rs",
    "new_path": "src/hazardous/xof/cshake.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -121,11 +121,8 @@ impl CShake {\n \n \t/// Reset to `init()` state.\n \tpub fn reset(&mut self) {\n-\t\tif self.is_finalized {\n-\t\t\tself.hasher = self.setup_hasher.clone();\n-\t\t\tself.is_finalized = false;\n-\t\t} else {\n-\t\t}\n+\t\tself.hasher = self.setup_hasher.clone();\n+\t\tself.is_finalized = false;\n \t}\n \n \t#[must_use]\n@@ -480,4 +477,25 @@ mod test {\n \t\tcshake.reset();\n \t\tcshake.reset();\n \t}\n+\n+\t#[test]\n+\tfn reset_after_update_correct_resets() {\n+\t\tlet input = b\"\\x00\\x01\\x02\\x03\";\n+\t\tlet custom = b\"\";\n+\t\tlet name = b\"Email Signature\";\n+\t\tlet mut out = [0u8; 64];\n+\t\tlet mut out2 = [0u8; 64];\n+\n+\t\tlet mut cshake = init(custom, Some(name)).unwrap();\n+\t\tcshake.update(input).unwrap();\n+\t\tcshake.finalize(&mut out).unwrap();\n+\n+\t\tlet mut cshake2 = init(custom, Some(name)).unwrap();\n+\t\tcshake2.update(input).unwrap();\n+\t\tcshake2.reset();\n+\t\tcshake2.update(input).unwrap();\n+\t\tcshake2.finalize(&mut out2).unwrap();\n+\n+\t\tassert!(out[..] == out2[..]);\n+\t}\n }\n",
    "diff_parsed": "{'added': [(124, '\\t\\tself.hasher = self.setup_hasher.clone();'), (125, '\\t\\tself.is_finalized = false;'), (481, '\\t#[test]'), (482, '\\tfn reset_after_update_correct_resets() {'), (483, '\\t\\tlet input = b\"\\\\x00\\\\x01\\\\x02\\\\x03\";'), (484, '\\t\\tlet custom = b\"\";'), (485, '\\t\\tlet name = b\"Email Signature\";'), (486, '\\t\\tlet mut out = [0u8; 64];'), (487, '\\t\\tlet mut out2 = [0u8; 64];'), (489, '\\t\\tlet mut cshake = init(custom, Some(name)).unwrap();'), (490, '\\t\\tcshake.update(input).unwrap();'), (491, '\\t\\tcshake.finalize(&mut out).unwrap();'), (493, '\\t\\tlet mut cshake2 = init(custom, Some(name)).unwrap();'), (494, '\\t\\tcshake2.update(input).unwrap();'), (495, '\\t\\tcshake2.reset();'), (496, '\\t\\tcshake2.update(input).unwrap();'), (497, '\\t\\tcshake2.finalize(&mut out2).unwrap();'), (499, '\\t\\tassert!(out[..] == out2[..]);'), (500, '\\t}')], 'deleted': [(124, '\\t\\tif self.is_finalized {'), (125, '\\t\\t\\tself.hasher = self.setup_hasher.clone();'), (126, '\\t\\t\\tself.is_finalized = false;'), (127, '\\t\\t} else {'), (128, '\\t\\t}')]}",
    "num_lines_added": "19",
    "num_lines_deleted": "5",
    "nloc": "331"
  },
  {
    "file_change_id": "122146212650193",
    "hash": "9803f31fbd1717d482d848f041044d061fca6da",
    "old_path": "derive-com-impl/src/derive.rs",
    "new_path": "derive-com-impl/src/derive.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -122,6 +122,8 @@ impl<'a> ComImpl<'a> {\n                         return winapi::shared::winerror::E_POINTER;\n                     }\n                     if #( #is_equal_iid )||* {\n+                        let that = &*(this as *const Self);\n+                        that.#refcount.add_ref();\n                         *ppv = this as *mut winapi::ctypes::c_void;\n                         winapi::shared::winerror::S_OK\n                     } else {\n",
    "diff_parsed": "{'added': [(125, '                        let that = &*(this as *const Self);'), (126, '                        that.#refcount.add_ref();')], 'deleted': []}",
    "num_lines_added": "2",
    "num_lines_deleted": "0",
    "nloc": "338"
  },
  {
    "file_change_id": "139442074088001",
    "hash": "8559aee7c5485426e3d5f7cfb7368248b6ca437",
    "old_path": "rmpv/src/decode/value.rs",
    "new_path": "rmpv/src/decode/value.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,4 +1,4 @@\n-use std::io::Read;\n+use std::io::{self, Read};\n \n use rmp::Marker;\n use rmp::decode::{read_marker, read_data_u8, read_data_u16, read_data_u32, read_data_u64,\n@@ -9,7 +9,9 @@ use crate::{Utf8String, Value};\n use super::Error;\n \n fn read_array_data<R: Read>(rd: &mut R, mut len: usize) -> Result<Vec<Value>, Error> {\n-    let mut vec = Vec::with_capacity(len);\n+    // Note: Do not preallocate a Vec of size `len`.\n+    // See https://github.com/3Hren/msgpack-rust/issues/151\n+    let mut vec = Vec::new();\n \n     while len > 0 {\n         vec.push(read_value(rd)?);\n@@ -20,7 +22,9 @@ fn read_array_data<R: Read>(rd: &mut R, mut len: usize) -> Result<Vec<Value>, Er\n }\n \n fn read_map_data<R: Read>(rd: &mut R, mut len: usize) -> Result<Vec<(Value, Value)>, Error> {\n-    let mut vec = Vec::with_capacity(len);\n+    // Note: Do not preallocate a Vec of size `len`.\n+    // See https://github.com/3Hren/msgpack-rust/issues/151\n+    let mut vec = Vec::new();\n \n     while len > 0 {\n         vec.push((read_value(rd)?, read_value(rd)?));\n@@ -44,9 +48,16 @@ fn read_str_data<R: Read>(rd: &mut R, len: usize) -> Result<Utf8String, Error> {\n }\n \n fn read_bin_data<R: Read>(rd: &mut R, len: usize) -> Result<Vec<u8>, Error> {\n-    let mut buf = Vec::with_capacity(len);\n-    buf.resize(len as usize, 0u8);\n-    rd.read_exact(&mut buf[..]).map_err(Error::InvalidDataRead)?;\n+    // Note: Do not preallocate a Vec of size `len`.\n+    // See https://github.com/3Hren/msgpack-rust/issues/151\n+    let mut buf = Vec::new();\n+    let bytes_read = rd.take(len as u64).read_to_end(&mut buf).map_err(Error::InvalidDataRead)?;\n+    if bytes_read != len {\n+        return Err(Error::InvalidDataRead(io::Error::new(\n+            io::ErrorKind::UnexpectedEof,\n+            format!(\"Expected {} bytes, read {} bytes\", len, bytes_read),\n+        )));\n+    }\n \n     Ok(buf)\n }\n",
    "diff_parsed": "{'added': [(1, 'use std::io::{self, Read};'), (14, '    let mut vec = Vec::new();'), (27, '    let mut vec = Vec::new();'), (53, '    let mut buf = Vec::new();'), (54, '    let bytes_read = rd.take(len as u64).read_to_end(&mut buf).map_err(Error::InvalidDataRead)?;'), (55, '    if bytes_read != len {'), (56, '        return Err(Error::InvalidDataRead(io::Error::new('), (57, '            io::ErrorKind::UnexpectedEof,'), (58, '            format!(\"Expected {} bytes, read {} bytes\", len, bytes_read),'), (59, '        )));'), (60, '    }')], 'deleted': [(1, 'use std::io::Read;'), (12, '    let mut vec = Vec::with_capacity(len);'), (23, '    let mut vec = Vec::with_capacity(len);'), (47, '    let mut buf = Vec::with_capacity(len);'), (48, '    buf.resize(len as usize, 0u8);'), (49, '    rd.read_exact(&mut buf[..]).map_err(Error::InvalidDataRead)?;')]}",
    "num_lines_added": "11",
    "num_lines_deleted": "6",
    "nloc": "176"
  },
  {
    "file_change_id": "225852113804302",
    "hash": "8559aee7c5485426e3d5f7cfb7368248b6ca437",
    "old_path": "rmpv/src/decode/value_ref.rs",
    "new_path": "rmpv/src/decode/value_ref.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -53,7 +53,9 @@ fn read_ext_body<'a, R>(rd: &mut R, len: usize) -> Result<(i8, &'a [u8]), Error>\n fn read_array_data<'a, R>(rd: &mut R, mut len: usize) -> Result<Vec<ValueRef<'a>>, Error>\n     where R: BorrowRead<'a>\n {\n-    let mut vec = Vec::with_capacity(len);\n+    // Note: Do not preallocate a Vec of size `len`.\n+    // See https://github.com/3Hren/msgpack-rust/issues/151\n+    let mut vec = Vec::new();\n \n     while len > 0 {\n         vec.push(read_value_ref(rd)?);\n@@ -66,7 +68,9 @@ fn read_array_data<'a, R>(rd: &mut R, mut len: usize) -> Result<Vec<ValueRef<'a>\n fn read_map_data<'a, R>(rd: &mut R, mut len: usize) -> Result<Vec<(ValueRef<'a>, ValueRef<'a>)>, Error>\n     where R: BorrowRead<'a>\n {\n-    let mut vec = Vec::with_capacity(len);\n+    // Note: Do not preallocate a Vec of size `len`.\n+    // See https://github.com/3Hren/msgpack-rust/issues/151\n+    let mut vec = Vec::new();\n \n     while len > 0 {\n         vec.push((read_value_ref(rd)?, read_value_ref(rd)?));\n",
    "diff_parsed": "{'added': [(58, '    let mut vec = Vec::new();'), (73, '    let mut vec = Vec::new();')], 'deleted': [(56, '    let mut vec = Vec::with_capacity(len);'), (69, '    let mut vec = Vec::with_capacity(len);')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "220"
  },
  {
    "file_change_id": "36055464852160",
    "hash": "8559aee7c5485426e3d5f7cfb7368248b6ca437",
    "old_path": "rmpv/tests/decode.rs",
    "new_path": "rmpv/tests/decode.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -361,3 +361,39 @@ fn from_array_of_two_integers() {\n     let vec = vec![Value::from(4), Value::from(42)];\n     assert_eq!(Value::Array(vec), read_value(&mut &buf[..]).unwrap());\n }\n+\n+#[test]\n+fn invalid_buf_size_bin32() {\n+    // This invalid buffer requests a 4 GiB byte vec.\n+    let buf: &[u8] = &[0xc6, 0xff, 0xff, 0xff, 0xff, 0x00];\n+    match read_value(&mut &buf[..]) {\n+        Ok(_) => panic!(\"Unexpected success\"),\n+        Err(Error::InvalidDataRead(_)) => { /* expected */ },\n+        Err(e) => panic!(\"Unexpected error: {}\", e),\n+    }\n+}\n+\n+#[test]\n+fn invalid_buf_size_arr() {\n+    // This invalid buffer requests a nested array of depth 10.\n+    // All arrays contain the maximum possible number of elements.\n+    // If a byte is preallocated for every array content,\n+    // that would require 40 GiB of RAM.\n+    let buf: &[u8] = &[\n+        0xdd, 0xff, 0xff, 0xff, 0xff,\n+        0xdd, 0xff, 0xff, 0xff, 0xff,\n+        0xdd, 0xff, 0xff, 0xff, 0xff,\n+        0xdd, 0xff, 0xff, 0xff, 0xff,\n+        0xdd, 0xff, 0xff, 0xff, 0xff,\n+        0xdd, 0xff, 0xff, 0xff, 0xff,\n+        0xdd, 0xff, 0xff, 0xff, 0xff,\n+        0xdd, 0xff, 0xff, 0xff, 0xff,\n+        0xdd, 0xff, 0xff, 0xff, 0xff,\n+        0xdd, 0xff, 0xff, 0xff, 0xff,\n+    ];\n+    match read_value(&mut &buf[..]) {\n+        Ok(_) => panic!(\"Unexpected success\"),\n+        Err(Error::InvalidMarkerRead(_)) => { /* expected */ },\n+        Err(e) => panic!(\"Unexpected error: {}\", e),\n+    }\n+}\n",
    "diff_parsed": "{'added': [(365, '#[test]'), (366, 'fn invalid_buf_size_bin32() {'), (368, '    let buf: &[u8] = &[0xc6, 0xff, 0xff, 0xff, 0xff, 0x00];'), (369, '    match read_value(&mut &buf[..]) {'), (370, '        Ok(_) => panic!(\"Unexpected success\"),'), (371, '        Err(Error::InvalidDataRead(_)) => { /* expected */ },'), (372, '        Err(e) => panic!(\"Unexpected error: {}\", e),'), (373, '    }'), (374, '}'), (376, '#[test]'), (377, 'fn invalid_buf_size_arr() {'), (382, '    let buf: &[u8] = &['), (383, '        0xdd, 0xff, 0xff, 0xff, 0xff,'), (384, '        0xdd, 0xff, 0xff, 0xff, 0xff,'), (385, '        0xdd, 0xff, 0xff, 0xff, 0xff,'), (386, '        0xdd, 0xff, 0xff, 0xff, 0xff,'), (387, '        0xdd, 0xff, 0xff, 0xff, 0xff,'), (388, '        0xdd, 0xff, 0xff, 0xff, 0xff,'), (389, '        0xdd, 0xff, 0xff, 0xff, 0xff,'), (390, '        0xdd, 0xff, 0xff, 0xff, 0xff,'), (391, '        0xdd, 0xff, 0xff, 0xff, 0xff,'), (392, '        0xdd, 0xff, 0xff, 0xff, 0xff,'), (393, '    ];'), (394, '    match read_value(&mut &buf[..]) {'), (395, '        Ok(_) => panic!(\"Unexpected success\"),'), (396, '        Err(Error::InvalidMarkerRead(_)) => { /* expected */ },'), (397, '        Err(e) => panic!(\"Unexpected error: {}\", e),'), (398, '    }'), (399, '}')], 'deleted': []}",
    "num_lines_added": "29",
    "num_lines_deleted": "0",
    "nloc": "326"
  },
  {
    "file_change_id": "185234519707627",
    "hash": "cb068895ca2aa236ad8bc858c80b2209cbc4f04",
    "old_path": "src/context.rs",
    "new_path": "src/context.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -48,7 +48,7 @@ pub trait Hotplug<T: UsbContext> {\n \n pub type Registration = c_int;\n \n-pub trait UsbContext: Clone + Sized {\n+pub trait UsbContext: Clone + Sized + Send + Sync {\n     /// Get the raw libusb_context pointer, for advanced use in unsafe code.\n     fn as_raw(&self) -> *mut libusb_context;\n \n",
    "diff_parsed": "{'added': [(51, 'pub trait UsbContext: Clone + Sized + Send + Sync {')], 'deleted': [(51, 'pub trait UsbContext: Clone + Sized {')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "203"
  },
  {
    "file_change_id": "96333757348630",
    "hash": "c66cd3085742c50ae231c77f1bc5b577d0cceb9",
    "old_path": "rust/flatbuffers/src/primitives.rs",
    "new_path": "rust/flatbuffers/src/primitives.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -263,6 +263,14 @@ impl<'a, T: Follow<'a> + 'a> Follow<'a> for SkipFileIdentifier<T> {\n     }\n }\n \n+impl<'a> Follow<'a> for bool {\n+    type Inner = bool;\n+    #[inline(always)]\n+    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+        read_scalar_at::<u8>(buf, loc) != 0\n+    }\n+}\n+\n /// Follow trait impls for primitive types.\n ///\n /// Ideally, these would be implemented as a single impl using trait bounds on\n@@ -280,7 +288,6 @@ macro_rules! impl_follow_for_endian_scalar {\n     };\n }\n \n-impl_follow_for_endian_scalar!(bool);\n impl_follow_for_endian_scalar!(u8);\n impl_follow_for_endian_scalar!(u16);\n impl_follow_for_endian_scalar!(u32);\n",
    "diff_parsed": "{'added': [(266, \"impl<'a> Follow<'a> for bool {\"), (267, '    type Inner = bool;'), (268, '    #[inline(always)]'), (269, \"    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\"), (270, '        read_scalar_at::<u8>(buf, loc) != 0'), (271, '    }'), (272, '}')], 'deleted': [(283, 'impl_follow_for_endian_scalar!(bool);')]}",
    "num_lines_added": "7",
    "num_lines_deleted": "1",
    "nloc": "209"
  },
  {
    "file_change_id": "265355120269678",
    "hash": "b3356ccba102cffa2c63cb61be5b704a29c474b",
    "old_path": "futures-task/src/noop_waker.rs",
    "new_path": "futures-task/src/noop_waker.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -3,7 +3,7 @@\n use core::task::{RawWaker, RawWakerVTable, Waker};\n use core::ptr::null;\n #[cfg(feature = \"std\")]\n-use core::cell::UnsafeCell;\n+use once_cell::sync::Lazy;\n \n unsafe fn noop_clone(_data: *const ()) -> RawWaker {\n     noop_raw_waker()\n@@ -47,9 +47,16 @@ pub fn noop_waker() -> Waker {\n #[inline]\n #[cfg(feature = \"std\")]\n pub fn noop_waker_ref() -> &'static Waker {\n-    thread_local! {\n-        static NOOP_WAKER_INSTANCE: UnsafeCell<Waker> =\n-            UnsafeCell::new(noop_waker());\n+    static NOOP_WAKER_INSTANCE: Lazy<Waker> = Lazy::new(noop_waker);\n+    &*NOOP_WAKER_INSTANCE\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    #[test]\n+    #[cfg(feature = \"std\")]\n+    fn issue_2091_cross_thread_segfault() {\n+        let waker = std::thread::spawn(super::noop_waker_ref).join().unwrap();\n+        waker.wake_by_ref();\n     }\n-    NOOP_WAKER_INSTANCE.with(|l| unsafe { &*l.get() })\n }\n",
    "diff_parsed": "{'added': [(6, 'use once_cell::sync::Lazy;'), (50, '    static NOOP_WAKER_INSTANCE: Lazy<Waker> = Lazy::new(noop_waker);'), (51, '    &*NOOP_WAKER_INSTANCE'), (52, '}'), (54, '#[cfg(test)]'), (55, 'mod tests {'), (56, '    #[test]'), (57, '    #[cfg(feature = \"std\")]'), (58, '    fn issue_2091_cross_thread_segfault() {'), (59, '        let waker = std::thread::spawn(super::noop_waker_ref).join().unwrap();'), (60, '        waker.wake_by_ref();')], 'deleted': [(6, 'use core::cell::UnsafeCell;'), (50, '    thread_local! {'), (51, '        static NOOP_WAKER_INSTANCE: UnsafeCell<Waker> ='), (52, '            UnsafeCell::new(noop_waker());'), (54, '    NOOP_WAKER_INSTANCE.with(|l| unsafe { &*l.get() })')]}",
    "num_lines_added": "11",
    "num_lines_deleted": "5",
    "nloc": "33"
  },
  {
    "file_change_id": "26167377265449",
    "hash": "b3356ccba102cffa2c63cb61be5b704a29c474b",
    "old_path": "futures-test/src/task/panic_waker.rs",
    "new_path": "futures-test/src/task/panic_waker.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,6 +1,6 @@\n use futures_core::task::{Waker, RawWaker, RawWakerVTable};\n-use core::cell::UnsafeCell;\n use core::ptr::null;\n+use once_cell::sync::Lazy;\n \n unsafe fn clone_panic_waker(_data: *const ()) -> RawWaker {\n     raw_panic_waker()\n@@ -52,9 +52,16 @@ pub fn panic_waker() -> Waker {\n /// waker.wake_by_ref(); // Will panic\n /// ```\n pub fn panic_waker_ref() -> &'static Waker {\n-    thread_local! {\n-        static PANIC_WAKER_INSTANCE: UnsafeCell<Waker> =\n-            UnsafeCell::new(panic_waker());\n+    static PANIC_WAKER_INSTANCE: Lazy<Waker> = Lazy::new(panic_waker);\n+    &*PANIC_WAKER_INSTANCE\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    #[test]\n+    #[should_panic(expected = \"should not be woken\")]\n+    fn issue_2091_cross_thread_segfault() {\n+        let waker = std::thread::spawn(super::panic_waker_ref).join().unwrap();\n+        waker.wake_by_ref();\n     }\n-    PANIC_WAKER_INSTANCE.with(|l| unsafe { &*l.get() })\n }\n",
    "diff_parsed": "{'added': [(3, 'use once_cell::sync::Lazy;'), (55, '    static PANIC_WAKER_INSTANCE: Lazy<Waker> = Lazy::new(panic_waker);'), (56, '    &*PANIC_WAKER_INSTANCE'), (57, '}'), (59, '#[cfg(test)]'), (60, 'mod tests {'), (61, '    #[test]'), (62, '    #[should_panic(expected = \"should not be woken\")]'), (63, '    fn issue_2091_cross_thread_segfault() {'), (64, '        let waker = std::thread::spawn(super::panic_waker_ref).join().unwrap();'), (65, '        waker.wake_by_ref();')], 'deleted': [(2, 'use core::cell::UnsafeCell;'), (55, '    thread_local! {'), (56, '        static PANIC_WAKER_INSTANCE: UnsafeCell<Waker> ='), (57, '            UnsafeCell::new(panic_waker());'), (59, '    PANIC_WAKER_INSTANCE.with(|l| unsafe { &*l.get() })')]}",
    "num_lines_added": "11",
    "num_lines_deleted": "5",
    "nloc": "35"
  },
  {
    "file_change_id": "125809728326684",
    "hash": "3f733cd056098d5e8de6ae8da40950500edc881",
    "old_path": "actix-utils/src/cell.rs",
    "new_path": "None",
    "change_type": "ModificationType.DELETE",
    "diff": "@@ -1,48 +0,0 @@\n-//! Custom cell impl\n-\n-use std::cell::UnsafeCell;\n-use std::fmt;\n-use std::rc::Rc;\n-\n-pub(crate) struct Cell<T> {\n-    pub(crate) inner: Rc<UnsafeCell<T>>,\n-}\n-\n-impl<T> Clone for Cell<T> {\n-    fn clone(&self) -> Self {\n-        Self {\n-            inner: self.inner.clone(),\n-        }\n-    }\n-}\n-\n-impl<T: fmt::Debug> fmt::Debug for Cell<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.inner.fmt(f)\n-    }\n-}\n-\n-impl<T> Cell<T> {\n-    pub(crate) fn new(inner: T) -> Self {\n-        Self {\n-            inner: Rc::new(UnsafeCell::new(inner)),\n-        }\n-    }\n-\n-    pub(crate) fn strong_count(&self) -> usize {\n-        Rc::strong_count(&self.inner)\n-    }\n-\n-    pub(crate) fn get_ref(&self) -> &T {\n-        unsafe { &*self.inner.as_ref().get() }\n-    }\n-\n-    pub(crate) fn get_mut(&mut self) -> &mut T {\n-        unsafe { &mut *self.inner.as_ref().get() }\n-    }\n-\n-    #[allow(clippy::mut_from_ref)]\n-    pub(crate) unsafe fn get_mut_unsafe(&self) -> &mut T {\n-        &mut *self.inner.as_ref().get()\n-    }\n-}\n",
    "diff_parsed": "{'added': [], 'deleted': [(3, 'use std::cell::UnsafeCell;'), (4, 'use std::fmt;'), (5, 'use std::rc::Rc;'), (7, 'pub(crate) struct Cell<T> {'), (8, '    pub(crate) inner: Rc<UnsafeCell<T>>,'), (9, '}'), (11, 'impl<T> Clone for Cell<T> {'), (12, '    fn clone(&self) -> Self {'), (13, '        Self {'), (14, '            inner: self.inner.clone(),'), (15, '        }'), (16, '    }'), (17, '}'), (19, 'impl<T: fmt::Debug> fmt::Debug for Cell<T> {'), (20, \"    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\"), (21, '        self.inner.fmt(f)'), (22, '    }'), (23, '}'), (25, 'impl<T> Cell<T> {'), (26, '    pub(crate) fn new(inner: T) -> Self {'), (27, '        Self {'), (28, '            inner: Rc::new(UnsafeCell::new(inner)),'), (29, '        }'), (30, '    }'), (32, '    pub(crate) fn strong_count(&self) -> usize {'), (33, '        Rc::strong_count(&self.inner)'), (34, '    }'), (36, '    pub(crate) fn get_ref(&self) -> &T {'), (37, '        unsafe { &*self.inner.as_ref().get() }'), (38, '    }'), (40, '    pub(crate) fn get_mut(&mut self) -> &mut T {'), (41, '        unsafe { &mut *self.inner.as_ref().get() }'), (42, '    }'), (44, '    #[allow(clippy::mut_from_ref)]'), (45, '    pub(crate) unsafe fn get_mut_unsafe(&self) -> &mut T {'), (46, '        &mut *self.inner.as_ref().get()'), (47, '    }'), (48, '}')]}",
    "num_lines_added": "0",
    "num_lines_deleted": "38",
    "nloc": "nan"
  },
  {
    "file_change_id": "36199330351390",
    "hash": "3f733cd056098d5e8de6ae8da40950500edc881",
    "old_path": "actix-utils/src/condition.rs",
    "new_path": "actix-utils/src/condition.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,14 +1,15 @@\n+use std::cell::RefCell;\n use std::future::Future;\n use std::pin::Pin;\n+use std::rc::Rc;\n use std::task::{Context, Poll};\n \n use slab::Slab;\n \n-use crate::cell::Cell;\n use crate::task::LocalWaker;\n \n /// Condition allows to notify multiple receivers at the same time\n-pub struct Condition(Cell<Inner>);\n+pub struct Condition(Rc<RefCell<Inner>>);\n \n struct Inner {\n     data: Slab<Option<LocalWaker>>,\n@@ -22,12 +23,12 @@ impl Default for Condition {\n \n impl Condition {\n     pub fn new() -> Condition {\n-        Condition(Cell::new(Inner { data: Slab::new() }))\n+        Condition(Rc::new(RefCell::new(Inner { data: Slab::new() })))\n     }\n \n     /// Get condition waiter\n     pub fn wait(&mut self) -> Waiter {\n-        let token = self.0.get_mut().data.insert(None);\n+        let token = self.0.borrow_mut().data.insert(None);\n         Waiter {\n             token,\n             inner: self.0.clone(),\n@@ -36,7 +37,7 @@ impl Condition {\n \n     /// Notify all waiters\n     pub fn notify(&self) {\n-        let inner = self.0.get_ref();\n+        let inner = self.0.borrow();\n         for item in inner.data.iter() {\n             if let Some(waker) = item.1 {\n                 waker.wake();\n@@ -54,12 +55,12 @@ impl Drop for Condition {\n #[must_use = \"Waiter do nothing unless polled\"]\n pub struct Waiter {\n     token: usize,\n-    inner: Cell<Inner>,\n+    inner: Rc<RefCell<Inner>>,\n }\n \n impl Clone for Waiter {\n     fn clone(&self) -> Self {\n-        let token = unsafe { self.inner.get_mut_unsafe() }.data.insert(None);\n+        let token = self.inner.borrow_mut().data.insert(None);\n         Waiter {\n             token,\n             inner: self.inner.clone(),\n@@ -73,7 +74,8 @@ impl Future for Waiter {\n     fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n         let this = self.get_mut();\n \n-        let inner = unsafe { this.inner.get_mut().data.get_unchecked_mut(this.token) };\n+        let mut inner = this.inner.borrow_mut();\n+        let inner = unsafe { inner.data.get_unchecked_mut(this.token) };\n         if inner.is_none() {\n             let waker = LocalWaker::default();\n             waker.register(cx.waker());\n@@ -89,7 +91,7 @@ impl Future for Waiter {\n \n impl Drop for Waiter {\n     fn drop(&mut self) {\n-        self.inner.get_mut().data.remove(self.token);\n+        self.inner.borrow_mut().data.remove(self.token);\n     }\n }\n \n",
    "diff_parsed": "{'added': [(1, 'use std::cell::RefCell;'), (4, 'use std::rc::Rc;'), (12, 'pub struct Condition(Rc<RefCell<Inner>>);'), (26, '        Condition(Rc::new(RefCell::new(Inner { data: Slab::new() })))'), (31, '        let token = self.0.borrow_mut().data.insert(None);'), (40, '        let inner = self.0.borrow();'), (58, '    inner: Rc<RefCell<Inner>>,'), (63, '        let token = self.inner.borrow_mut().data.insert(None);'), (77, '        let mut inner = this.inner.borrow_mut();'), (78, '        let inner = unsafe { inner.data.get_unchecked_mut(this.token) };'), (94, '        self.inner.borrow_mut().data.remove(self.token);')], 'deleted': [(7, 'use crate::cell::Cell;'), (11, 'pub struct Condition(Cell<Inner>);'), (25, '        Condition(Cell::new(Inner { data: Slab::new() }))'), (30, '        let token = self.0.get_mut().data.insert(None);'), (39, '        let inner = self.0.get_ref();'), (57, '    inner: Cell<Inner>,'), (62, '        let token = unsafe { self.inner.get_mut_unsafe() }.data.insert(None);'), (76, '        let inner = unsafe { this.inner.get_mut().data.get_unchecked_mut(this.token) };'), (92, '        self.inner.get_mut().data.remove(self.token);')]}",
    "num_lines_added": "11",
    "num_lines_deleted": "9",
    "nloc": "107.0"
  },
  {
    "file_change_id": "61711746639297",
    "hash": "3f733cd056098d5e8de6ae8da40950500edc881",
    "old_path": "actix-utils/src/either.rs",
    "new_path": "actix-utils/src/either.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -3,7 +3,7 @@ use std::pin::Pin;\n use std::task::{Context, Poll};\n \n use actix_service::{Service, ServiceFactory};\n-use futures_util::{future, ready, future::Future};\n+use futures_util::{future, future::Future, ready};\n \n /// Combine two different service types into a single type.\n ///\n",
    "diff_parsed": "{'added': [(6, 'use futures_util::{future, future::Future, ready};')], 'deleted': [(6, 'use futures_util::{future, ready, future::Future};')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "140.0"
  },
  {
    "file_change_id": "279347838131912",
    "hash": "3f733cd056098d5e8de6ae8da40950500edc881",
    "old_path": "actix-utils/src/lib.rs",
    "new_path": "actix-utils/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -2,7 +2,6 @@\n #![deny(rust_2018_idioms)]\n #![allow(clippy::type_complexity)]\n \n-mod cell;\n pub mod condition;\n pub mod counter;\n pub mod either;\n",
    "diff_parsed": "{'added': [], 'deleted': [(5, 'mod cell;')]}",
    "num_lines_added": "0",
    "num_lines_deleted": "1",
    "nloc": "15.0"
  },
  {
    "file_change_id": "121442423560695",
    "hash": "3f733cd056098d5e8de6ae8da40950500edc881",
    "old_path": "actix-utils/src/mpsc.rs",
    "new_path": "actix-utils/src/mpsc.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,24 +1,25 @@\n //! A multi-producer, single-consumer, futures-aware, FIFO queue.\n use std::any::Any;\n+use std::cell::RefCell;\n use std::collections::VecDeque;\n use std::error::Error;\n use std::fmt;\n use std::pin::Pin;\n+use std::rc::Rc;\n use std::task::{Context, Poll};\n \n use futures_sink::Sink;\n use futures_util::stream::Stream;\n \n-use crate::cell::Cell;\n use crate::task::LocalWaker;\n \n /// Creates a unbounded in-memory channel with buffered storage.\n pub fn channel<T>() -> (Sender<T>, Receiver<T>) {\n-    let shared = Cell::new(Shared {\n+    let shared = Rc::new(RefCell::new(Shared {\n         has_receiver: true,\n         buffer: VecDeque::new(),\n         blocked_recv: LocalWaker::new(),\n-    });\n+    }));\n     let sender = Sender {\n         shared: shared.clone(),\n     };\n@@ -38,7 +39,7 @@ struct Shared<T> {\n /// This is created by the `channel` function.\n #[derive(Debug)]\n pub struct Sender<T> {\n-    shared: Cell<Shared<T>>,\n+    shared: Rc<RefCell<Shared<T>>>,\n }\n \n impl<T> Unpin for Sender<T> {}\n@@ -46,7 +47,7 @@ impl<T> Unpin for Sender<T> {}\n impl<T> Sender<T> {\n     /// Sends the provided message along this channel.\n     pub fn send(&self, item: T) -> Result<(), SendError<T>> {\n-        let shared = unsafe { self.shared.get_mut_unsafe() };\n+        let mut shared = self.shared.borrow_mut();\n         if !shared.has_receiver {\n             return Err(SendError(item)); // receiver was dropped\n         };\n@@ -60,7 +61,7 @@ impl<T> Sender<T> {\n     /// This prevents any further messages from being sent on the channel while\n     /// still enabling the receiver to drain messages that are buffered.\n     pub fn close(&mut self) {\n-        self.shared.get_mut().has_receiver = false;\n+        self.shared.borrow_mut().has_receiver = false;\n     }\n }\n \n@@ -94,8 +95,8 @@ impl<T> Sink<T> for Sender<T> {\n \n impl<T> Drop for Sender<T> {\n     fn drop(&mut self) {\n-        let count = self.shared.strong_count();\n-        let shared = self.shared.get_mut();\n+        let count = Rc::strong_count(&self.shared);\n+        let shared = self.shared.borrow_mut();\n \n         // check is last sender is about to drop\n         if shared.has_receiver && count == 2 {\n@@ -110,7 +111,7 @@ impl<T> Drop for Sender<T> {\n /// This is created by the `channel` function.\n #[derive(Debug)]\n pub struct Receiver<T> {\n-    shared: Cell<Shared<T>>,\n+    shared: Rc<RefCell<Shared<T>>>,\n }\n \n impl<T> Receiver<T> {\n@@ -127,15 +128,16 @@ impl<T> Unpin for Receiver<T> {}\n impl<T> Stream for Receiver<T> {\n     type Item = T;\n \n-    fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {\n-        if self.shared.strong_count() == 1 {\n+    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {\n+        let mut shared = self.shared.borrow_mut();\n+        if Rc::strong_count(&self.shared) == 1 {\n             // All senders have been dropped, so drain the buffer and end the\n             // stream.\n-            Poll::Ready(self.shared.get_mut().buffer.pop_front())\n-        } else if let Some(msg) = self.shared.get_mut().buffer.pop_front() {\n+            Poll::Ready(shared.buffer.pop_front())\n+        } else if let Some(msg) = shared.buffer.pop_front() {\n             Poll::Ready(Some(msg))\n         } else {\n-            self.shared.get_mut().blocked_recv.register(cx.waker());\n+            shared.blocked_recv.register(cx.waker());\n             Poll::Pending\n         }\n     }\n@@ -143,7 +145,7 @@ impl<T> Stream for Receiver<T> {\n \n impl<T> Drop for Receiver<T> {\n     fn drop(&mut self) {\n-        let shared = self.shared.get_mut();\n+        let mut shared = self.shared.borrow_mut();\n         shared.buffer.clear();\n         shared.has_receiver = false;\n     }\n",
    "diff_parsed": "{'added': [(3, 'use std::cell::RefCell;'), (8, 'use std::rc::Rc;'), (18, '    let shared = Rc::new(RefCell::new(Shared {'), (22, '    }));'), (42, '    shared: Rc<RefCell<Shared<T>>>,'), (50, '        let mut shared = self.shared.borrow_mut();'), (64, '        self.shared.borrow_mut().has_receiver = false;'), (98, '        let count = Rc::strong_count(&self.shared);'), (99, '        let shared = self.shared.borrow_mut();'), (114, '    shared: Rc<RefCell<Shared<T>>>,'), (131, \"    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {\"), (132, '        let mut shared = self.shared.borrow_mut();'), (133, '        if Rc::strong_count(&self.shared) == 1 {'), (136, '            Poll::Ready(shared.buffer.pop_front())'), (137, '        } else if let Some(msg) = shared.buffer.pop_front() {'), (140, '            shared.blocked_recv.register(cx.waker());'), (148, '        let mut shared = self.shared.borrow_mut();')], 'deleted': [(12, 'use crate::cell::Cell;'), (17, '    let shared = Cell::new(Shared {'), (21, '    });'), (41, '    shared: Cell<Shared<T>>,'), (49, '        let shared = unsafe { self.shared.get_mut_unsafe() };'), (63, '        self.shared.get_mut().has_receiver = false;'), (97, '        let count = self.shared.strong_count();'), (98, '        let shared = self.shared.get_mut();'), (113, '    shared: Cell<Shared<T>>,'), (130, \"    fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {\"), (131, '        if self.shared.strong_count() == 1 {'), (134, '            Poll::Ready(self.shared.get_mut().buffer.pop_front())'), (135, '        } else if let Some(msg) = self.shared.get_mut().buffer.pop_front() {'), (138, '            self.shared.get_mut().blocked_recv.register(cx.waker());'), (146, '        let shared = self.shared.get_mut();')]}",
    "num_lines_added": "17",
    "num_lines_deleted": "15",
    "nloc": "184.0"
  },
  {
    "file_change_id": "8599452955172",
    "hash": "3f733cd056098d5e8de6ae8da40950500edc881",
    "old_path": "actix-utils/src/oneshot.rs",
    "new_path": "actix-utils/src/oneshot.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,20 +1,21 @@\n //! A one-shot, futures-aware channel.\n+use std::cell::RefCell;\n use std::future::Future;\n use std::pin::Pin;\n+use std::rc::Rc;\n use std::task::{Context, Poll};\n \n pub use futures_channel::oneshot::Canceled;\n use slab::Slab;\n \n-use crate::cell::Cell;\n use crate::task::LocalWaker;\n \n /// Creates a new futures-aware, one-shot channel.\n pub fn channel<T>() -> (Sender<T>, Receiver<T>) {\n-    let inner = Cell::new(Inner {\n+    let inner = Rc::new(RefCell::new(Inner {\n         value: None,\n         rx_task: LocalWaker::new(),\n-    });\n+    }));\n     let tx = Sender {\n         inner: inner.clone(),\n     };\n@@ -24,14 +25,14 @@ pub fn channel<T>() -> (Sender<T>, Receiver<T>) {\n \n /// Creates a new futures-aware, pool of one-shot's.\n pub fn pool<T>() -> Pool<T> {\n-    Pool(Cell::new(Slab::new()))\n+    Pool(Rc::new(RefCell::new(Slab::new())))\n }\n \n /// Represents the completion half of a oneshot through which the result of a\n /// computation is signaled.\n #[derive(Debug)]\n pub struct Sender<T> {\n-    inner: Cell<Inner<T>>,\n+    inner: Rc<RefCell<Inner<T>>>,\n }\n \n /// A future representing the completion of a computation happening elsewhere in\n@@ -39,7 +40,7 @@ pub struct Sender<T> {\n #[derive(Debug)]\n #[must_use = \"futures do nothing unless polled\"]\n pub struct Receiver<T> {\n-    inner: Cell<Inner<T>>,\n+    inner: Rc<RefCell<Inner<T>>>,\n }\n \n // The channels do not ever project Pin to the inner T\n@@ -63,9 +64,9 @@ impl<T> Sender<T> {\n     /// then `Ok(())` is returned. If the receiving end was dropped before\n     /// this function was called, however, then `Err` is returned with the value\n     /// provided.\n-    pub fn send(mut self, val: T) -> Result<(), T> {\n-        if self.inner.strong_count() == 2 {\n-            let inner = self.inner.get_mut();\n+    pub fn send(self, val: T) -> Result<(), T> {\n+        if Rc::strong_count(&self.inner) == 2 {\n+            let mut inner = self.inner.borrow_mut();\n             inner.value = Some(val);\n             inner.rx_task.wake();\n             Ok(())\n@@ -77,13 +78,13 @@ impl<T> Sender<T> {\n     /// Tests to see whether this `Sender`'s corresponding `Receiver`\n     /// has gone away.\n     pub fn is_canceled(&self) -> bool {\n-        self.inner.strong_count() == 1\n+        Rc::strong_count(&self.inner) == 1\n     }\n }\n \n impl<T> Drop for Sender<T> {\n     fn drop(&mut self) {\n-        self.inner.get_ref().rx_task.wake();\n+        self.inner.borrow().rx_task.wake();\n     }\n }\n \n@@ -94,22 +95,22 @@ impl<T> Future for Receiver<T> {\n         let this = self.get_mut();\n \n         // If we've got a value, then skip the logic below as we're done.\n-        if let Some(val) = this.inner.get_mut().value.take() {\n+        if let Some(val) = this.inner.borrow_mut().value.take() {\n             return Poll::Ready(Ok(val));\n         }\n \n         // Check if sender is dropped and return error if it is.\n-        if this.inner.strong_count() == 1 {\n+        if Rc::strong_count(&this.inner) == 1 {\n             Poll::Ready(Err(Canceled))\n         } else {\n-            this.inner.get_ref().rx_task.register(cx.waker());\n+            this.inner.borrow().rx_task.register(cx.waker());\n             Poll::Pending\n         }\n     }\n }\n \n /// Futures-aware, pool of one-shot's.\n-pub struct Pool<T>(Cell<Slab<PoolInner<T>>>);\n+pub struct Pool<T>(Rc<RefCell<Slab<PoolInner<T>>>>);\n \n bitflags::bitflags! {\n     pub struct Flags: u8 {\n@@ -127,7 +128,7 @@ struct PoolInner<T> {\n \n impl<T> Pool<T> {\n     pub fn channel(&mut self) -> (PSender<T>, PReceiver<T>) {\n-        let token = self.0.get_mut().insert(PoolInner {\n+        let token = self.0.borrow_mut().insert(PoolInner {\n             flags: Flags::all(),\n             value: None,\n             waker: LocalWaker::default(),\n@@ -157,7 +158,7 @@ impl<T> Clone for Pool<T> {\n #[derive(Debug)]\n pub struct PSender<T> {\n     token: usize,\n-    inner: Cell<Slab<PoolInner<T>>>,\n+    inner: Rc<RefCell<Slab<PoolInner<T>>>>,\n }\n \n /// A future representing the completion of a computation happening elsewhere in\n@@ -166,7 +167,7 @@ pub struct PSender<T> {\n #[must_use = \"futures do nothing unless polled\"]\n pub struct PReceiver<T> {\n     token: usize,\n-    inner: Cell<Slab<PoolInner<T>>>,\n+    inner: Rc<RefCell<Slab<PoolInner<T>>>>,\n }\n \n // The oneshots do not ever project Pin to the inner T\n@@ -184,8 +185,9 @@ impl<T> PSender<T> {\n     /// then `Ok(())` is returned. If the receiving end was dropped before\n     /// this function was called, however, then `Err` is returned with the value\n     /// provided.\n-    pub fn send(mut self, val: T) -> Result<(), T> {\n-        let inner = unsafe { self.inner.get_mut().get_unchecked_mut(self.token) };\n+    pub fn send(self, val: T) -> Result<(), T> {\n+        let mut inner = self.inner.borrow_mut();\n+        let inner = unsafe { inner.get_unchecked_mut(self.token) };\n \n         if inner.flags.contains(Flags::RECEIVER) {\n             inner.value = Some(val);\n@@ -199,7 +201,7 @@ impl<T> PSender<T> {\n     /// Tests to see whether this `Sender`'s corresponding `Receiver`\n     /// has gone away.\n     pub fn is_canceled(&self) -> bool {\n-        !unsafe { self.inner.get_ref().get_unchecked(self.token) }\n+        !unsafe { self.inner.borrow().get_unchecked(self.token) }\n             .flags\n             .contains(Flags::RECEIVER)\n     }\n@@ -207,23 +209,25 @@ impl<T> PSender<T> {\n \n impl<T> Drop for PSender<T> {\n     fn drop(&mut self) {\n-        let inner = unsafe { self.inner.get_mut().get_unchecked_mut(self.token) };\n-        if inner.flags.contains(Flags::RECEIVER) {\n-            inner.waker.wake();\n-            inner.flags.remove(Flags::SENDER);\n+        let mut inner = self.inner.borrow_mut();\n+        let inner_token = unsafe { inner.get_unchecked_mut(self.token) };\n+        if inner_token.flags.contains(Flags::RECEIVER) {\n+            inner_token.waker.wake();\n+            inner_token.flags.remove(Flags::SENDER);\n         } else {\n-            self.inner.get_mut().remove(self.token);\n+            inner.remove(self.token);\n         }\n     }\n }\n \n impl<T> Drop for PReceiver<T> {\n     fn drop(&mut self) {\n-        let inner = unsafe { self.inner.get_mut().get_unchecked_mut(self.token) };\n-        if inner.flags.contains(Flags::SENDER) {\n-            inner.flags.remove(Flags::RECEIVER);\n+        let mut inner = self.inner.borrow_mut();\n+        let inner_token = unsafe { inner.get_unchecked_mut(self.token) };\n+        if inner_token.flags.contains(Flags::SENDER) {\n+            inner_token.flags.remove(Flags::RECEIVER);\n         } else {\n-            self.inner.get_mut().remove(self.token);\n+            inner.remove(self.token);\n         }\n     }\n }\n@@ -233,7 +237,8 @@ impl<T> Future for PReceiver<T> {\n \n     fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n         let this = self.get_mut();\n-        let inner = unsafe { this.inner.get_mut().get_unchecked_mut(this.token) };\n+        let mut inner = this.inner.borrow_mut();\n+        let inner = unsafe { inner.get_unchecked_mut(this.token) };\n \n         // If we've got a value, then skip the logic below as we're done.\n         if let Some(val) = inner.value.take() {\n",
    "diff_parsed": "{'added': [(2, 'use std::cell::RefCell;'), (5, 'use std::rc::Rc;'), (15, '    let inner = Rc::new(RefCell::new(Inner {'), (18, '    }));'), (28, '    Pool(Rc::new(RefCell::new(Slab::new())))'), (35, '    inner: Rc<RefCell<Inner<T>>>,'), (43, '    inner: Rc<RefCell<Inner<T>>>,'), (67, '    pub fn send(self, val: T) -> Result<(), T> {'), (68, '        if Rc::strong_count(&self.inner) == 2 {'), (69, '            let mut inner = self.inner.borrow_mut();'), (81, '        Rc::strong_count(&self.inner) == 1'), (87, '        self.inner.borrow().rx_task.wake();'), (98, '        if let Some(val) = this.inner.borrow_mut().value.take() {'), (103, '        if Rc::strong_count(&this.inner) == 1 {'), (106, '            this.inner.borrow().rx_task.register(cx.waker());'), (113, 'pub struct Pool<T>(Rc<RefCell<Slab<PoolInner<T>>>>);'), (131, '        let token = self.0.borrow_mut().insert(PoolInner {'), (161, '    inner: Rc<RefCell<Slab<PoolInner<T>>>>,'), (170, '    inner: Rc<RefCell<Slab<PoolInner<T>>>>,'), (188, '    pub fn send(self, val: T) -> Result<(), T> {'), (189, '        let mut inner = self.inner.borrow_mut();'), (190, '        let inner = unsafe { inner.get_unchecked_mut(self.token) };'), (204, '        !unsafe { self.inner.borrow().get_unchecked(self.token) }'), (212, '        let mut inner = self.inner.borrow_mut();'), (213, '        let inner_token = unsafe { inner.get_unchecked_mut(self.token) };'), (214, '        if inner_token.flags.contains(Flags::RECEIVER) {'), (215, '            inner_token.waker.wake();'), (216, '            inner_token.flags.remove(Flags::SENDER);'), (218, '            inner.remove(self.token);'), (225, '        let mut inner = self.inner.borrow_mut();'), (226, '        let inner_token = unsafe { inner.get_unchecked_mut(self.token) };'), (227, '        if inner_token.flags.contains(Flags::SENDER) {'), (228, '            inner_token.flags.remove(Flags::RECEIVER);'), (230, '            inner.remove(self.token);'), (240, '        let mut inner = this.inner.borrow_mut();'), (241, '        let inner = unsafe { inner.get_unchecked_mut(this.token) };')], 'deleted': [(9, 'use crate::cell::Cell;'), (14, '    let inner = Cell::new(Inner {'), (17, '    });'), (27, '    Pool(Cell::new(Slab::new()))'), (34, '    inner: Cell<Inner<T>>,'), (42, '    inner: Cell<Inner<T>>,'), (66, '    pub fn send(mut self, val: T) -> Result<(), T> {'), (67, '        if self.inner.strong_count() == 2 {'), (68, '            let inner = self.inner.get_mut();'), (80, '        self.inner.strong_count() == 1'), (86, '        self.inner.get_ref().rx_task.wake();'), (97, '        if let Some(val) = this.inner.get_mut().value.take() {'), (102, '        if this.inner.strong_count() == 1 {'), (105, '            this.inner.get_ref().rx_task.register(cx.waker());'), (112, 'pub struct Pool<T>(Cell<Slab<PoolInner<T>>>);'), (130, '        let token = self.0.get_mut().insert(PoolInner {'), (160, '    inner: Cell<Slab<PoolInner<T>>>,'), (169, '    inner: Cell<Slab<PoolInner<T>>>,'), (187, '    pub fn send(mut self, val: T) -> Result<(), T> {'), (188, '        let inner = unsafe { self.inner.get_mut().get_unchecked_mut(self.token) };'), (202, '        !unsafe { self.inner.get_ref().get_unchecked(self.token) }'), (210, '        let inner = unsafe { self.inner.get_mut().get_unchecked_mut(self.token) };'), (211, '        if inner.flags.contains(Flags::RECEIVER) {'), (212, '            inner.waker.wake();'), (213, '            inner.flags.remove(Flags::SENDER);'), (215, '            self.inner.get_mut().remove(self.token);'), (222, '        let inner = unsafe { self.inner.get_mut().get_unchecked_mut(self.token) };'), (223, '        if inner.flags.contains(Flags::SENDER) {'), (224, '            inner.flags.remove(Flags::RECEIVER);'), (226, '            self.inner.get_mut().remove(self.token);'), (236, '        let inner = unsafe { this.inner.get_mut().get_unchecked_mut(this.token) };')]}",
    "num_lines_added": "36",
    "num_lines_deleted": "31",
    "nloc": "246.0"
  },
  {
    "file_change_id": "226284967580018",
    "hash": "3f733cd056098d5e8de6ae8da40950500edc881",
    "old_path": "actix-utils/src/stream.rs",
    "new_path": "actix-utils/src/stream.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -3,7 +3,7 @@ use std::pin::Pin;\n use std::task::{Context, Poll};\n \n use actix_service::{IntoService, Service};\n-use futures_util::{FutureExt, stream::Stream};\n+use futures_util::{stream::Stream, FutureExt};\n \n use crate::mpsc;\n \n",
    "diff_parsed": "{'added': [(6, 'use futures_util::{stream::Stream, FutureExt};')], 'deleted': [(6, 'use futures_util::{FutureExt, stream::Stream};')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "70.0"
  },
  {
    "file_change_id": "176183138984123",
    "hash": "3f733cd056098d5e8de6ae8da40950500edc881",
    "old_path": "actix-utils/src/time.rs",
    "new_path": "actix-utils/src/time.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,4 +1,6 @@\n+use std::cell::RefCell;\n use std::convert::Infallible;\n+use std::rc::Rc;\n use std::task::{Context, Poll};\n use std::time::{self, Duration, Instant};\n \n@@ -6,10 +8,8 @@ use actix_rt::time::delay_for;\n use actix_service::{Service, ServiceFactory};\n use futures_util::future::{ok, ready, FutureExt, Ready};\n \n-use super::cell::Cell;\n-\n #[derive(Clone, Debug)]\n-pub struct LowResTime(Cell<Inner>);\n+pub struct LowResTime(Rc<RefCell<Inner>>);\n \n #[derive(Debug)]\n struct Inner {\n@@ -28,7 +28,7 @@ impl Inner {\n \n impl LowResTime {\n     pub fn with(resolution: Duration) -> LowResTime {\n-        LowResTime(Cell::new(Inner::new(resolution)))\n+        LowResTime(Rc::new(RefCell::new(Inner::new(resolution))))\n     }\n \n     pub fn timer(&self) -> LowResTimeService {\n@@ -38,7 +38,7 @@ impl LowResTime {\n \n impl Default for LowResTime {\n     fn default() -> Self {\n-        LowResTime(Cell::new(Inner::new(Duration::from_secs(1))))\n+        LowResTime(Rc::new(RefCell::new(Inner::new(Duration::from_secs(1)))))\n     }\n }\n \n@@ -57,30 +57,30 @@ impl ServiceFactory for LowResTime {\n }\n \n #[derive(Clone, Debug)]\n-pub struct LowResTimeService(Cell<Inner>);\n+pub struct LowResTimeService(Rc<RefCell<Inner>>);\n \n impl LowResTimeService {\n     pub fn with(resolution: Duration) -> LowResTimeService {\n-        LowResTimeService(Cell::new(Inner::new(resolution)))\n+        LowResTimeService(Rc::new(RefCell::new(Inner::new(resolution))))\n     }\n \n     /// Get current time. This function has to be called from\n     /// future's poll method, otherwise it panics.\n     pub fn now(&self) -> Instant {\n-        let cur = self.0.get_ref().current;\n+        let cur = self.0.borrow().current;\n         if let Some(cur) = cur {\n             cur\n         } else {\n             let now = Instant::now();\n-            let mut inner = self.0.clone();\n+            let inner = self.0.clone();\n             let interval = {\n-                let mut b = inner.get_mut();\n+                let mut b = inner.borrow_mut();\n                 b.current = Some(now);\n                 b.resolution\n             };\n \n             actix_rt::spawn(delay_for(interval).then(move |_| {\n-                inner.get_mut().current.take();\n+                inner.borrow_mut().current.take();\n                 ready(())\n             }));\n             now\n@@ -104,7 +104,7 @@ impl Service for LowResTimeService {\n }\n \n #[derive(Clone, Debug)]\n-pub struct SystemTime(Cell<SystemTimeInner>);\n+pub struct SystemTime(Rc<RefCell<SystemTimeInner>>);\n \n #[derive(Debug)]\n struct SystemTimeInner {\n@@ -122,30 +122,30 @@ impl SystemTimeInner {\n }\n \n #[derive(Clone, Debug)]\n-pub struct SystemTimeService(Cell<SystemTimeInner>);\n+pub struct SystemTimeService(Rc<RefCell<SystemTimeInner>>);\n \n impl SystemTimeService {\n     pub fn with(resolution: Duration) -> SystemTimeService {\n-        SystemTimeService(Cell::new(SystemTimeInner::new(resolution)))\n+        SystemTimeService(Rc::new(RefCell::new(SystemTimeInner::new(resolution))))\n     }\n \n     /// Get current time. This function has to be called from\n     /// future's poll method, otherwise it panics.\n     pub fn now(&self) -> time::SystemTime {\n-        let cur = self.0.get_ref().current;\n+        let cur = self.0.borrow().current;\n         if let Some(cur) = cur {\n             cur\n         } else {\n             let now = time::SystemTime::now();\n-            let mut inner = self.0.clone();\n+            let inner = self.0.clone();\n             let interval = {\n-                let mut b = inner.get_mut();\n+                let mut b = inner.borrow_mut();\n                 b.current = Some(now);\n                 b.resolution\n             };\n \n             actix_rt::spawn(delay_for(interval).then(move |_| {\n-                inner.get_mut().current.take();\n+                inner.borrow_mut().current.take();\n                 ready(())\n             }));\n             now\n",
    "diff_parsed": "{'added': [(1, 'use std::cell::RefCell;'), (3, 'use std::rc::Rc;'), (12, 'pub struct LowResTime(Rc<RefCell<Inner>>);'), (31, '        LowResTime(Rc::new(RefCell::new(Inner::new(resolution))))'), (41, '        LowResTime(Rc::new(RefCell::new(Inner::new(Duration::from_secs(1)))))'), (60, 'pub struct LowResTimeService(Rc<RefCell<Inner>>);'), (64, '        LowResTimeService(Rc::new(RefCell::new(Inner::new(resolution))))'), (70, '        let cur = self.0.borrow().current;'), (75, '            let inner = self.0.clone();'), (77, '                let mut b = inner.borrow_mut();'), (83, '                inner.borrow_mut().current.take();'), (107, 'pub struct SystemTime(Rc<RefCell<SystemTimeInner>>);'), (125, 'pub struct SystemTimeService(Rc<RefCell<SystemTimeInner>>);'), (129, '        SystemTimeService(Rc::new(RefCell::new(SystemTimeInner::new(resolution))))'), (135, '        let cur = self.0.borrow().current;'), (140, '            let inner = self.0.clone();'), (142, '                let mut b = inner.borrow_mut();'), (148, '                inner.borrow_mut().current.take();')], 'deleted': [(9, 'use super::cell::Cell;'), (12, 'pub struct LowResTime(Cell<Inner>);'), (31, '        LowResTime(Cell::new(Inner::new(resolution)))'), (41, '        LowResTime(Cell::new(Inner::new(Duration::from_secs(1))))'), (60, 'pub struct LowResTimeService(Cell<Inner>);'), (64, '        LowResTimeService(Cell::new(Inner::new(resolution)))'), (70, '        let cur = self.0.get_ref().current;'), (75, '            let mut inner = self.0.clone();'), (77, '                let mut b = inner.get_mut();'), (83, '                inner.get_mut().current.take();'), (107, 'pub struct SystemTime(Cell<SystemTimeInner>);'), (125, 'pub struct SystemTimeService(Cell<SystemTimeInner>);'), (129, '        SystemTimeService(Cell::new(SystemTimeInner::new(resolution)))'), (135, '        let cur = self.0.get_ref().current;'), (140, '            let mut inner = self.0.clone();'), (142, '                let mut b = inner.get_mut();'), (148, '                inner.get_mut().current.take();')]}",
    "num_lines_added": "18",
    "num_lines_deleted": "17",
    "nloc": "179.0"
  },
  {
    "file_change_id": "14343651050019",
    "hash": "34c2b9e51cd7b85a3366104092ca4e5e9fab227",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -89,8 +89,8 @@ impl<T: Sized> Drop for AtomicBox<T> {\n     }\n }\n \n-unsafe impl<T: Sized> Sync for AtomicBox<T> {}\n-unsafe impl<T: Sized> Send for AtomicBox<T> {}\n+unsafe impl<T: Sized + Sync> Sync for AtomicBox<T> {}\n+unsafe impl<T: Sized + Send> Send for AtomicBox<T> {}\n \n #[cfg(test)]\n mod tests {\n",
    "diff_parsed": "{'added': [(92, 'unsafe impl<T: Sized + Sync> Sync for AtomicBox<T> {}'), (93, 'unsafe impl<T: Sized + Send> Send for AtomicBox<T> {}')], 'deleted': [(92, 'unsafe impl<T: Sized> Sync for AtomicBox<T> {}'), (93, 'unsafe impl<T: Sized> Send for AtomicBox<T> {}')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "172"
  },
  {
    "file_change_id": "255727531672595",
    "hash": "e1720ce38452c7f94d2ff32d2c120d7d427e2eb",
    "old_path": "impl/src/lib.rs",
    "new_path": "impl/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -98,6 +98,9 @@ fn dynamic(ident: &syn::Ident, folder_path: String, prefix: Option<&str>, includ\n     const excludes: &[&str] = &[#(#excludes),*];\n   };\n \n+  let canonical_folder_path = Path::new(&folder_path).canonicalize().expect(\"folder path must resolve to an absolute path\");\n+  let canonical_folder_path = canonical_folder_path.to_str().expect(\"absolute folder path must be valid unicode\");\n+\n   quote! {\n       #[cfg(debug_assertions)]\n       impl #ident {\n@@ -111,8 +114,15 @@ fn dynamic(ident: &syn::Ident, folder_path: String, prefix: Option<&str>, includ\n               let rel_file_path = file_path.replace(\"\\\\\", \"/\");\n               let file_path = std::path::Path::new(#folder_path).join(&rel_file_path);\n \n+              // Make sure the path requested does not escape the folder path\n+              let canonical_file_path = file_path.canonicalize().ok()?;\n+              if !canonical_file_path.starts_with(#canonical_folder_path) {\n+                  // Tried to request a path that is not in the embedded folder\n+                  return None;\n+              }\n+\n               if rust_embed::utils::is_path_included(&rel_file_path, includes, excludes) {\n-                rust_embed::utils::read_file_from_fs(&file_path).ok()\n+                rust_embed::utils::read_file_from_fs(&canonical_file_path).ok()\n               } else {\n                 None\n               }\n",
    "diff_parsed": "{'added': [(101, '  let canonical_folder_path = Path::new(&folder_path).canonicalize().expect(\"folder path must resolve to an absolute path\");'), (102, '  let canonical_folder_path = canonical_folder_path.to_str().expect(\"absolute folder path must be valid unicode\");'), (118, '              let canonical_file_path = file_path.canonicalize().ok()?;'), (119, '              if !canonical_file_path.starts_with(#canonical_folder_path) {'), (121, '                  return None;'), (122, '              }'), (125, '                rust_embed::utils::read_file_from_fs(&canonical_file_path).ok()')], 'deleted': [(115, '                rust_embed::utils::read_file_from_fs(&file_path).ok()')]}",
    "num_lines_added": "7",
    "num_lines_deleted": "1",
    "nloc": "232"
  },
  {
    "file_change_id": "107143273267924",
    "hash": "e1720ce38452c7f94d2ff32d2c120d7d427e2eb",
    "old_path": "None",
    "new_path": "tests/path_traversal_attack.rs",
    "change_type": "ModificationType.ADD",
    "diff": "@@ -0,0 +1,13 @@\n+use rust_embed::RustEmbed;\n+\n+#[derive(RustEmbed)]\n+#[folder = \"examples/public/\"]\n+struct Assets;\n+\n+/// Prevent attempts to access files outside of the embedded folder.\n+/// This is mainly a concern when running in debug mode, since that loads from\n+/// the file system at runtime.\n+#[test]\n+fn path_traversal_attack_fails() {\n+  assert!(Assets::get(\"../basic.rs\").is_none());\n+}\n",
    "diff_parsed": "{'added': [(1, 'use rust_embed::RustEmbed;'), (3, '#[derive(RustEmbed)]'), (4, '#[folder = \"examples/public/\"]'), (5, 'struct Assets;'), (10, '#[test]'), (11, 'fn path_traversal_attack_fails() {'), (12, '  assert!(Assets::get(\"../basic.rs\").is_none());'), (13, '}')], 'deleted': []}",
    "num_lines_added": "8",
    "num_lines_deleted": "0",
    "nloc": "8"
  },
  {
    "file_change_id": "23760543414196",
    "hash": "dede6fef9a50650efdd1ee36b2466911cc1b195",
    "old_path": "actix-http/src/body.rs",
    "new_path": "actix-http/src/body.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -361,10 +361,8 @@ impl MessageBody for String {\n \n /// Type represent streaming body.\n /// Response does not contain `content-length` header and appropriate transfer encoding is used.\n-#[pin_project]\n pub struct BodyStream<S, E> {\n-    #[pin]\n-    stream: S,\n+    stream: Pin<Box<S>>,\n     _t: PhantomData<E>,\n }\n \n@@ -375,7 +373,7 @@ where\n {\n     pub fn new(stream: S) -> Self {\n         BodyStream {\n-            stream,\n+            stream: Box::pin(stream),\n             _t: PhantomData,\n         }\n     }\n@@ -396,7 +394,7 @@ where\n     /// ended on a zero-length chunk, but rather proceed until the underlying\n     /// [`Stream`] ends.\n     fn poll_next(&mut self, cx: &mut Context<'_>) -> Poll<Option<Result<Bytes, Error>>> {\n-        let mut stream = unsafe { Pin::new_unchecked(self) }.project().stream;\n+        let mut stream = self.stream.as_mut();\n         loop {\n             return Poll::Ready(match ready!(stream.as_mut().poll_next(cx)) {\n                 Some(Ok(ref bytes)) if bytes.is_empty() => continue,\n@@ -408,11 +406,9 @@ where\n \n /// Type represent streaming body. This body implementation should be used\n /// if total size of stream is known. Data get sent as is without using transfer encoding.\n-#[pin_project]\n pub struct SizedStream<S> {\n     size: u64,\n-    #[pin]\n-    stream: S,\n+    stream: Pin<Box<S>>,\n }\n \n impl<S> SizedStream<S>\n@@ -420,7 +416,7 @@ where\n     S: Stream<Item = Result<Bytes, Error>>,\n {\n     pub fn new(size: u64, stream: S) -> Self {\n-        SizedStream { size, stream }\n+        SizedStream { size, stream: Box::pin(stream) }\n     }\n }\n \n@@ -438,7 +434,7 @@ where\n     /// ended on a zero-length chunk, but rather proceed until the underlying\n     /// [`Stream`] ends.\n     fn poll_next(&mut self, cx: &mut Context<'_>) -> Poll<Option<Result<Bytes, Error>>> {\n-        let mut stream = unsafe { Pin::new_unchecked(self) }.project().stream;\n+        let mut stream = self.stream.as_mut();\n         loop {\n             return Poll::Ready(match ready!(stream.as_mut().poll_next(cx)) {\n                 Some(Ok(ref bytes)) if bytes.is_empty() => continue,\n",
    "diff_parsed": "{'added': [(365, '    stream: Pin<Box<S>>,'), (376, '            stream: Box::pin(stream),'), (397, '        let mut stream = self.stream.as_mut();'), (411, '    stream: Pin<Box<S>>,'), (419, '        SizedStream { size, stream: Box::pin(stream) }'), (437, '        let mut stream = self.stream.as_mut();')], 'deleted': [(364, '#[pin_project]'), (366, '    #[pin]'), (367, '    stream: S,'), (378, '            stream,'), (399, '        let mut stream = unsafe { Pin::new_unchecked(self) }.project().stream;'), (411, '#[pin_project]'), (414, '    #[pin]'), (415, '    stream: S,'), (423, '        SizedStream { size, stream }'), (441, '        let mut stream = unsafe { Pin::new_unchecked(self) }.project().stream;')]}",
    "num_lines_added": "6",
    "num_lines_deleted": "10",
    "nloc": "583"
  },
  {
    "file_change_id": "1711365248879",
    "hash": "dede6fef9a50650efdd1ee36b2466911cc1b195",
    "old_path": "None",
    "new_path": "tests/test_weird_poll.rs",
    "change_type": "ModificationType.ADD",
    "diff": "@@ -0,0 +1,26 @@\n+// Regression test for #/1321\n+\n+use futures::task::{noop_waker, Context};\n+use futures::stream::once;\n+use actix_http::body::{MessageBody, BodyStream};\n+use bytes::Bytes;\n+\n+#[test]\n+fn weird_poll() {\n+    let (sender, receiver) = futures::channel::oneshot::channel();\n+    let mut body_stream = Ok(BodyStream::new(once(async {\n+        let x = Box::new(0);\n+        let y = &x;\n+        receiver.await.unwrap();\n+        let _z = **y;\n+        Ok::<_, ()>(Bytes::new())\n+    })));\n+\n+    let waker = noop_waker();\n+    let mut context = Context::from_waker(&waker);\n+\n+    let _ = body_stream.as_mut().unwrap().poll_next(&mut context);\n+    sender.send(()).unwrap();\n+    let _ = std::mem::replace(&mut body_stream, Err([0; 32])).unwrap().poll_next(&mut context);\n+}\n+\n",
    "diff_parsed": "{'added': [(3, 'use futures::task::{noop_waker, Context};'), (4, 'use futures::stream::once;'), (5, 'use actix_http::body::{MessageBody, BodyStream};'), (6, 'use bytes::Bytes;'), (8, '#[test]'), (9, 'fn weird_poll() {'), (10, '    let (sender, receiver) = futures::channel::oneshot::channel();'), (11, '    let mut body_stream = Ok(BodyStream::new(once(async {'), (12, '        let x = Box::new(0);'), (13, '        let y = &x;'), (14, '        receiver.await.unwrap();'), (15, '        let _z = **y;'), (16, '        Ok::<_, ()>(Bytes::new())'), (17, '    })));'), (19, '    let waker = noop_waker();'), (20, '    let mut context = Context::from_waker(&waker);'), (22, '    let _ = body_stream.as_mut().unwrap().poll_next(&mut context);'), (23, '    sender.send(()).unwrap();'), (24, '    let _ = std::mem::replace(&mut body_stream, Err([0; 32])).unwrap().poll_next(&mut context);'), (25, '}')], 'deleted': []}",
    "num_lines_added": "20",
    "num_lines_deleted": "0",
    "nloc": "20"
  },
  {
    "file_change_id": "251134041506344",
    "hash": "04731e101fed08a32942d52790e1c8c6ede6188",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -192,7 +192,7 @@ pub type DefaultStringInterner = StringInterner<Sym>;\n \n /// Caches strings efficiently, with minimal memory footprint and associates them with unique symbols.\n /// These symbols allow constant time comparisons and look-ups to the underlying interned strings.\n-#[derive(Debug, Clone, Eq)]\n+#[derive(Debug, Eq)]\n pub struct StringInterner<S, H = RandomState>\n where\n \tS: Symbol,\n@@ -219,6 +219,28 @@ impl Default for StringInterner<Sym, RandomState> {\n \t}\n }\n \n+// Should be manually cloned.\n+// See <https://github.com/Robbepop/string-interner/issues/9>.\n+impl<S, H> Clone for StringInterner<S, H>\n+where\n+\tS: Symbol,\n+\tH: Clone + BuildHasher,\n+{\n+\tfn clone(&self) -> Self {\n+\t\tlet values = self.values.clone();\n+\t\tlet mut map = HashMap::with_capacity_and_hasher(values.len(), self.map.hasher().clone());\n+\t\t// Recreate `InternalStrRef` from the newly cloned `Box<str>`s.\n+\t\t// Use `extend()` to avoid `H: Default` trait bound required by `FromIterator for HashMap`.\n+\t\tmap.extend(\n+\t\t\tvalues\n+\t\t\t.iter()\n+\t\t\t.enumerate()\n+\t\t\t.map(|(i, s)| (InternalStrRef::from_str(s), S::from_usize(i))),\n+\t\t);\n+\t\tSelf { values, map }\n+\t}\n+}\n+\n // About `Send` and `Sync` impls for `StringInterner`\n // --------------------------------------------------\n //\n",
    "diff_parsed": "{'added': [(195, '#[derive(Debug, Eq)]'), (224, 'impl<S, H> Clone for StringInterner<S, H>'), (225, 'where'), (226, '\\tS: Symbol,'), (227, '\\tH: Clone + BuildHasher,'), (228, '{'), (229, '\\tfn clone(&self) -> Self {'), (230, '\\t\\tlet values = self.values.clone();'), (231, '\\t\\tlet mut map = HashMap::with_capacity_and_hasher(values.len(), self.map.hasher().clone());'), (234, '\\t\\tmap.extend('), (235, '\\t\\t\\tvalues'), (236, '\\t\\t\\t.iter()'), (237, '\\t\\t\\t.enumerate()'), (238, '\\t\\t\\t.map(|(i, s)| (InternalStrRef::from_str(s), S::from_usize(i))),'), (239, '\\t\\t);'), (240, '\\t\\tSelf { values, map }'), (241, '\\t}'), (242, '}')], 'deleted': [(195, '#[derive(Debug, Clone, Eq)]')]}",
    "num_lines_added": "18",
    "num_lines_deleted": "1",
    "nloc": "370"
  },
  {
    "file_change_id": "103135864680122",
    "hash": "04731e101fed08a32942d52790e1c8c6ede6188",
    "old_path": "src/tests.rs",
    "new_path": "src/tests.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -398,4 +398,18 @@ mod clone_and_drop {\n \t\t\t\"`foo` should represent the string \\\"foo\\\" so they should be equal\"\n \t\t);\n \t}\n+\n+\t#[test]\n+\t// Test for new (non-`derive`) `Clone` impl.\n+\tfn clone() {\n+\t\tlet mut old = DefaultStringInterner::new();\n+\t\tlet strings = &[\"foo\", \"bar\", \"baz\", \"qux\", \"quux\", \"corge\"];\n+\t\tlet syms = strings.iter().map(|&s| old.get_or_intern(s)).collect::<Vec<_>>();\n+\n+\t\tlet mut new = old.clone();\n+\t\tfor (&s, &sym) in strings.iter().zip(&syms) {\n+\t\t\tassert_eq!(new.resolve(sym), Some(s));\n+\t\t\tassert_eq!(new.get_or_intern(s), sym);\n+\t\t}\n+\t}\n }\n",
    "diff_parsed": "{'added': [(402, '\\t#[test]'), (404, '\\tfn clone() {'), (405, '\\t\\tlet mut old = DefaultStringInterner::new();'), (406, '\\t\\tlet strings = &[\"foo\", \"bar\", \"baz\", \"qux\", \"quux\", \"corge\"];'), (407, '\\t\\tlet syms = strings.iter().map(|&s| old.get_or_intern(s)).collect::<Vec<_>>();'), (409, '\\t\\tlet mut new = old.clone();'), (410, '\\t\\tfor (&s, &sym) in strings.iter().zip(&syms) {'), (411, '\\t\\t\\tassert_eq!(new.resolve(sym), Some(s));'), (412, '\\t\\t\\tassert_eq!(new.get_or_intern(s), sym);'), (413, '\\t\\t}'), (414, '\\t}')], 'deleted': []}",
    "num_lines_added": "11",
    "num_lines_deleted": "0",
    "nloc": "347"
  },
  {
    "file_change_id": "67354642958351",
    "hash": "ae13bdac8b95966a4fdef3b17aa6d2096799f7c",
    "old_path": "quinn/src/platform/unix.rs",
    "new_path": "quinn/src/platform/unix.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -2,7 +2,7 @@ use std::{\n     io,\n     io::IoSliceMut,\n     mem::{self, MaybeUninit},\n-    net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr, SocketAddrV4, SocketAddrV6},\n+    net::{IpAddr, SocketAddr, SocketAddrV4, SocketAddrV6},\n     os::unix::io::AsRawFd,\n     ptr,\n     task::{Context, Poll},\n@@ -375,8 +375,8 @@ fn prepare_msg(\n                 IpAddr::V4(v4) => {\n                     let pktinfo = libc::in_pktinfo {\n                         ipi_ifindex: 0,\n-                        ipi_spec_dst: unsafe {\n-                            *(v4 as *const Ipv4Addr as *const () as *const libc::in_addr)\n+                        ipi_spec_dst: libc::in_addr {\n+                            s_addr: u32::from_ne_bytes(v4.octets()),\n                         },\n                         ipi_addr: libc::in_addr { s_addr: 0 },\n                     };\n@@ -385,8 +385,8 @@ fn prepare_msg(\n                 IpAddr::V6(v6) => {\n                     let pktinfo = libc::in6_pktinfo {\n                         ipi6_ifindex: 0,\n-                        ipi6_addr: unsafe {\n-                            *(v6 as *const Ipv6Addr as *const () as *const libc::in6_addr)\n+                        ipi6_addr: libc::in6_addr {\n+                            s6_addr: v6.octets(),\n                         },\n                     };\n                     encoder.push(libc::IPPROTO_IPV6, libc::IPV6_PKTINFO, pktinfo);\n",
    "diff_parsed": "{'added': [(5, '    net::{IpAddr, SocketAddr, SocketAddrV4, SocketAddrV6},'), (378, '                        ipi_spec_dst: libc::in_addr {'), (379, '                            s_addr: u32::from_ne_bytes(v4.octets()),'), (388, '                        ipi6_addr: libc::in6_addr {'), (389, '                            s6_addr: v6.octets(),')], 'deleted': [(5, '    net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr, SocketAddrV4, SocketAddrV6},'), (378, '                        ipi_spec_dst: unsafe {'), (379, '                            *(v4 as *const Ipv4Addr as *const () as *const libc::in_addr)'), (388, '                        ipi6_addr: unsafe {'), (389, '                            *(v6 as *const Ipv6Addr as *const () as *const libc::in6_addr)')]}",
    "num_lines_added": "5",
    "num_lines_deleted": "5",
    "nloc": "482"
  },
  {
    "file_change_id": "266926598554863",
    "hash": "cd64316558c7faffc7e3669298e81dc9289ac22",
    "old_path": "quinn/src/platform/unix.rs",
    "new_path": "quinn/src/platform/unix.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -198,9 +198,25 @@ fn send(io: &mio::net::UdpSocket, transmits: &[Transmit]) -> io::Result<usize> {\n     let mut msgs: [libc::mmsghdr; BATCH_SIZE] = unsafe { mem::zeroed() };\n     let mut iovecs: [libc::iovec; BATCH_SIZE] = unsafe { mem::zeroed() };\n     let mut cmsgs = [cmsg::Aligned([0u8; CMSG_LEN]); BATCH_SIZE];\n+    // This assume_init looks a bit weird because one might think it\n+    // assumes the SockAddr data to be initialized, but that call\n+    // refers to the whole array, which itself is made up of MaybeUninit\n+    // containers. Their presence protects the SockAddr inside from\n+    // being assumed as initialized by the assume_init call.\n+    // TODO: Replace this with uninit_array once it becomes MSRV-stable\n+    let mut addrs: [MaybeUninit<socket2::SockAddr>; BATCH_SIZE] =\n+        unsafe { MaybeUninit::uninit().assume_init() };\n     for (i, transmit) in transmits.iter().enumerate().take(BATCH_SIZE) {\n+        let dst_addr = unsafe {\n+            std::ptr::write(\n+                addrs[i].as_mut_ptr(),\n+                socket2::SockAddr::from(transmit.destination),\n+            );\n+            &*addrs[i].as_ptr()\n+        };\n         prepare_msg(\n             transmit,\n+            dst_addr,\n             &mut msgs[i].msg_hdr,\n             &mut iovecs[i],\n             &mut cmsgs[i],\n@@ -233,7 +249,8 @@ fn send(io: &mio::net::UdpSocket, transmits: &[Transmit]) -> io::Result<usize> {\n     let mut ctrl = cmsg::Aligned([0u8; CMSG_LEN]);\n     let mut sent = 0;\n     while sent < transmits.len() {\n-        prepare_msg(&transmits[sent], &mut hdr, &mut iov, &mut ctrl);\n+        let addr = socket2::SockAddr::from(transmits[sent].destination);\n+        prepare_msg(&transmits[sent], &addr, &mut hdr, &mut iov, &mut ctrl);\n         let n = unsafe { libc::sendmsg(io.as_raw_fd(), &hdr, 0) };\n         if n == -1 {\n             let e = io::Error::last_os_error();\n@@ -334,6 +351,7 @@ const CMSG_LEN: usize = 80;\n \n fn prepare_msg(\n     transmit: &Transmit,\n+    dst_addr: &socket2::SockAddr,\n     hdr: &mut libc::msghdr,\n     iov: &mut libc::iovec,\n     ctrl: &mut cmsg::Aligned<[u8; CMSG_LEN]>,\n@@ -341,12 +359,15 @@ fn prepare_msg(\n     iov.iov_base = transmit.contents.as_ptr() as *const _ as *mut _;\n     iov.iov_len = transmit.contents.len();\n \n-    let (name, namelen) = match transmit.destination {\n-        SocketAddr::V4(ref addr) => (addr as *const _ as _, mem::size_of::<libc::sockaddr_in>()),\n-        SocketAddr::V6(ref addr) => (addr as *const _ as _, mem::size_of::<libc::sockaddr_in6>()),\n-    };\n-    hdr.msg_name = name;\n-    hdr.msg_namelen = namelen as _;\n+    // SAFETY: Casting the pointer to a mutable one is legal,\n+    // as sendmsg is guaranteed to not alter the mutable pointer\n+    // as per the POSIX spec. See the section on the sys/socket.h\n+    // header for details. The type is only mutable in the first\n+    // place because it is reused by recvmsg as well.\n+    let name = dst_addr.as_ptr() as *mut libc::c_void;\n+    let namelen = dst_addr.len();\n+    hdr.msg_name = name as *mut _;\n+    hdr.msg_namelen = namelen;\n     hdr.msg_iov = iov;\n     hdr.msg_iovlen = 1;\n \n",
    "diff_parsed": "{'added': [(207, '    let mut addrs: [MaybeUninit<socket2::SockAddr>; BATCH_SIZE] ='), (208, '        unsafe { MaybeUninit::uninit().assume_init() };'), (210, '        let dst_addr = unsafe {'), (211, '            std::ptr::write('), (212, '                addrs[i].as_mut_ptr(),'), (213, '                socket2::SockAddr::from(transmit.destination),'), (214, '            );'), (215, '            &*addrs[i].as_ptr()'), (216, '        };'), (219, '            dst_addr,'), (252, '        let addr = socket2::SockAddr::from(transmits[sent].destination);'), (253, '        prepare_msg(&transmits[sent], &addr, &mut hdr, &mut iov, &mut ctrl);'), (354, '    dst_addr: &socket2::SockAddr,'), (367, '    let name = dst_addr.as_ptr() as *mut libc::c_void;'), (368, '    let namelen = dst_addr.len();'), (369, '    hdr.msg_name = name as *mut _;'), (370, '    hdr.msg_namelen = namelen;')], 'deleted': [(236, '        prepare_msg(&transmits[sent], &mut hdr, &mut iov, &mut ctrl);'), (344, '    let (name, namelen) = match transmit.destination {'), (345, '        SocketAddr::V4(ref addr) => (addr as *const _ as _, mem::size_of::<libc::sockaddr_in>()),'), (346, '        SocketAddr::V6(ref addr) => (addr as *const _ as _, mem::size_of::<libc::sockaddr_in6>()),'), (347, '    };'), (348, '    hdr.msg_name = name;'), (349, '    hdr.msg_namelen = namelen as _;')]}",
    "num_lines_added": "17",
    "num_lines_deleted": "7",
    "nloc": "498"
  },
  {
    "file_change_id": "233744731438261",
    "hash": "eb413b3d47baea8e8a0b9ce2ccd8299b354d3b7",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -81,8 +81,18 @@ use core::marker::PhantomData;\n #[cfg(feature = \"alloc\")]\n use std::error::Error;\n \n+/// This is one part of the secret sauce that ensures that indices from\n+/// different arenas cannot be mixed. You should never need to use this type in\n+/// your code.\n #[derive(Copy, Clone, PartialOrd, PartialEq, Eq)]\n-struct InvariantLifetime<'a>(PhantomData<fn(&'a ()) -> &'a ()>);\n+pub struct InvariantLifetime<'a>(PhantomData<fn(&'a ()) -> &'a ()>);\n+\n+/// Create an invariant lifetime. This is one part of the secret sauce that\n+/// ensures that indices from different arenas cannot be mixed. You should\n+/// never need to use this type in your code.\n+pub fn invariant_lifetime<'tag>() -> InvariantLifetime<'tag> {\n+    InvariantLifetime(PhantomData)\n+}\n \n /// An index into the arena. You will not directly use this type, but one of\n /// the aliases this crate provides (`Idx32`, `Idx16` or `Idx8`).\n@@ -201,13 +211,24 @@ pub struct SmallArena<'tag, T> {\n macro_rules! mk_arena {\n     ($name:ident) => { $crate::mk_arena!($name, 128*1024) };\n     ($name:ident, $cap:expr) => {\n-        let mut tag = ();\n+        let tag = $crate::invariant_lifetime();\n+        let _guard;\n         let mut $name = unsafe {\n             // this is not per-se unsafe but we need it to be public and\n             // calling it with a non-unique `tag` would allow arena mixups,\n             // which may introduce UB in `Index`/`IndexMut`\n-            $crate::SmallArena::new(&mut tag, $cap)\n+            $crate::SmallArena::new(tag, $cap)\n         };\n+        // this doesn't make it to MIR, but ensures that borrowck will not\n+        // unify the lifetimes of two macro calls by binding the lifetime to\n+        // drop scope\n+        if false {\n+            struct Guard<'tag>(&'tag $crate::InvariantLifetime<'tag>);\n+            impl<'tag> ::core::ops::Drop for Guard<'tag> {\n+                fn drop(&mut self) { }\n+            }\n+            _guard = Guard(&tag);\n+        }\n     };\n }\n \n@@ -244,13 +265,24 @@ macro_rules! in_arena {\n #[macro_export]\n macro_rules! mk_tiny_arena {\n     ($name:ident) => {\n-        let mut tag = ();\n+        let tag = $crate::invariant_lifetime();\n+        let _guard;\n         let mut $name = unsafe {\n             // this is not per-se unsafe but we need it to be public and\n             // calling it with a non-unique `tag` would allow arena mixups,\n             // which may introduce UB in `Index`/`IndexMut`\n-            $crate::TinyArena::new(&mut tag)\n+            $crate::TinyArena::new(tag)\n         };\n+        // this doesn't make it to MIR, but ensures that borrowck will not\n+        // unify the lifetimes of two macro calls by binding the lifetime to\n+        // drop scope\n+        if false {\n+            struct Guard<'tag>(&'tag $crate::InvariantLifetime<'tag>);\n+            impl<'tag> ::core::ops::Drop for Guard<'tag> {\n+                fn drop(&mut self) { }\n+            }\n+            _guard = Guard(&tag);\n+        }\n     };\n }\n \n@@ -289,13 +321,24 @@ macro_rules! in_tiny_arena {\n #[macro_export]\n macro_rules! mk_nano_arena {\n     ($name:ident) => {\n-        let mut tag = ();\n+        let tag = $crate::invariant_lifetime();\n+        let _guard;\n         let mut $name = unsafe {\n             // this is not per-se unsafe but we need it to be public and\n             // calling it with a non-unique `tag` would allow arena mixups,\n             // which may introduce UB in `Index`/`IndexMut`\n-            $crate::NanoArena::new(&mut tag)\n+            $crate::NanoArena::new(tag)\n         };\n+        // this doesn't make it to MIR, but ensures that borrowck will not\n+        // unify the lifetimes of two macro calls by binding the lifetime to\n+        // drop scope\n+        if false {\n+            struct Guard<'tag>(&'tag $crate::InvariantLifetime<'tag>);\n+            impl<'tag> ::core::ops::Drop for Guard<'tag> {\n+                fn drop(&mut self) { }\n+            }\n+            _guard = Guard(&tag);\n+        }\n     };\n }\n \n@@ -331,9 +374,9 @@ impl<'tag, T> SmallArena<'tag, T> {\n     /// constructor. You must never use this value in another arena, lest you\n     /// might be able to mix up the indices of the two, which could lead to\n     /// out of bounds access and thus **Undefined Behavior**!\n-    pub unsafe fn new(_: &'tag mut (), capacity: usize) -> Self {\n+    pub unsafe fn new(tag: InvariantLifetime<'tag>, capacity: usize) -> Self {\n         SmallArena {\n-            tag: InvariantLifetime(PhantomData),\n+            tag,\n             data: Vec::with_capacity(capacity),\n         }\n     }\n@@ -394,7 +437,6 @@ pub use tiny_arena::{TinyArena, NanoArena};\n mod tiny_arena {\n     use crate::{CapacityExceeded, Idx16, Idx8, InvariantLifetime,\n                 TINY_ARENA_ITEMS, NANO_ARENA_ITEMS};\n-    use core::marker::PhantomData;\n \n     /// A \"tiny\" arena containing up to 65536 elements. This variant only works with\n     /// types implementing `Default`.\n@@ -416,9 +458,9 @@ mod tiny_arena {\n         /// this constructor. You must never use this value in another arena,\n         /// lest you might be able to mix up the indices of the two, which\n         /// could lead to out of bounds access and thus **Undefined Behavior**!\n-        pub unsafe fn new(_: &'tag mut ()) -> TinyArena<'tag, T> {\n+        pub unsafe fn new(tag: InvariantLifetime<'tag>) -> TinyArena<'tag, T> {\n             TinyArena {\n-                tag: InvariantLifetime(PhantomData),\n+                tag,\n                 data: [Default::default(); TINY_ARENA_ITEMS as usize],\n                 len: 0\n             }\n@@ -463,9 +505,9 @@ mod tiny_arena {\n         /// this constructor. You must never use this value in another arena,\n         /// lest you might be able to mix up the indices of the two, which\n         /// could lead to out of bounds access and thus **Undefined Behavior**!\n-        pub unsafe fn new(_: &'tag mut ()) -> NanoArena<'tag, T> {\n+        pub unsafe fn new(tag: InvariantLifetime<'tag>) -> NanoArena<'tag, T> {\n             NanoArena {\n-                tag: InvariantLifetime(PhantomData),\n+                tag,\n                 data: [Default::default(); NANO_ARENA_ITEMS as usize],\n                 len: 0\n             }\n@@ -495,7 +537,6 @@ mod tiny_arena {\n mod tiny_arena {\n     use crate::{CapacityExceeded, Idx16, Idx8, InvariantLifetime,\n                 TINY_ARENA_ITEMS, NANO_ARENA_ITEMS};\n-    use core::marker::PhantomData;\n     use core::mem::{self, ManuallyDrop};\n     use core::ptr;\n \n@@ -508,9 +549,9 @@ mod tiny_arena {\n \n     impl<'tag, T> TinyArena<'tag, T> {\n         /// create a new TinyArena\n-        pub unsafe fn new(_: &'tag mut ()) -> TinyArena<'tag, T> {\n+        pub unsafe fn new(tag: InvariantLifetime<'tag>) -> TinyArena<'tag, T> {\n             TinyArena {\n-                tag: InvariantLifetime(PhantomData),\n+                tag,\n                 data: mem::uninitialized(),\n                 len: 0\n             }\n@@ -566,9 +607,9 @@ mod tiny_arena {\n         /// this constructor. You must never use this value in another arena,\n         /// lest you might be able to mix up the indices of the two, which\n         /// could lead to out of bounds access and thus **Undefined Behavior**!\n-        pub unsafe fn new(_: &'tag mut ()) -> NanoArena<'tag, T> {\n+        pub unsafe fn new(tag: InvariantLifetime<'tag>) -> NanoArena<'tag, T> {\n             NanoArena {\n-                tag: InvariantLifetime(PhantomData),\n+                tag,\n                 data: mem::uninitialized(),\n                 len: 0,\n             }\n",
    "diff_parsed": "{'added': [(88, \"pub struct InvariantLifetime<'a>(PhantomData<fn(&'a ()) -> &'a ()>);\"), (93, \"pub fn invariant_lifetime<'tag>() -> InvariantLifetime<'tag> {\"), (94, '    InvariantLifetime(PhantomData)'), (95, '}'), (214, '        let tag = $crate::invariant_lifetime();'), (215, '        let _guard;'), (220, '            $crate::SmallArena::new(tag, $cap)'), (225, '        if false {'), (226, \"            struct Guard<'tag>(&'tag $crate::InvariantLifetime<'tag>);\"), (227, \"            impl<'tag> ::core::ops::Drop for Guard<'tag> {\"), (228, '                fn drop(&mut self) { }'), (229, '            }'), (230, '            _guard = Guard(&tag);'), (231, '        }'), (268, '        let tag = $crate::invariant_lifetime();'), (269, '        let _guard;'), (274, '            $crate::TinyArena::new(tag)'), (279, '        if false {'), (280, \"            struct Guard<'tag>(&'tag $crate::InvariantLifetime<'tag>);\"), (281, \"            impl<'tag> ::core::ops::Drop for Guard<'tag> {\"), (282, '                fn drop(&mut self) { }'), (283, '            }'), (284, '            _guard = Guard(&tag);'), (285, '        }'), (324, '        let tag = $crate::invariant_lifetime();'), (325, '        let _guard;'), (330, '            $crate::NanoArena::new(tag)'), (335, '        if false {'), (336, \"            struct Guard<'tag>(&'tag $crate::InvariantLifetime<'tag>);\"), (337, \"            impl<'tag> ::core::ops::Drop for Guard<'tag> {\"), (338, '                fn drop(&mut self) { }'), (339, '            }'), (340, '            _guard = Guard(&tag);'), (341, '        }'), (377, \"    pub unsafe fn new(tag: InvariantLifetime<'tag>, capacity: usize) -> Self {\"), (379, '            tag,'), (461, \"        pub unsafe fn new(tag: InvariantLifetime<'tag>) -> TinyArena<'tag, T> {\"), (463, '                tag,'), (508, \"        pub unsafe fn new(tag: InvariantLifetime<'tag>) -> NanoArena<'tag, T> {\"), (510, '                tag,'), (552, \"        pub unsafe fn new(tag: InvariantLifetime<'tag>) -> TinyArena<'tag, T> {\"), (554, '                tag,'), (610, \"        pub unsafe fn new(tag: InvariantLifetime<'tag>) -> NanoArena<'tag, T> {\"), (612, '                tag,')], 'deleted': [(85, \"struct InvariantLifetime<'a>(PhantomData<fn(&'a ()) -> &'a ()>);\"), (204, '        let mut tag = ();'), (209, '            $crate::SmallArena::new(&mut tag, $cap)'), (247, '        let mut tag = ();'), (252, '            $crate::TinyArena::new(&mut tag)'), (292, '        let mut tag = ();'), (297, '            $crate::NanoArena::new(&mut tag)'), (334, \"    pub unsafe fn new(_: &'tag mut (), capacity: usize) -> Self {\"), (336, '            tag: InvariantLifetime(PhantomData),'), (397, '    use core::marker::PhantomData;'), (419, \"        pub unsafe fn new(_: &'tag mut ()) -> TinyArena<'tag, T> {\"), (421, '                tag: InvariantLifetime(PhantomData),'), (466, \"        pub unsafe fn new(_: &'tag mut ()) -> NanoArena<'tag, T> {\"), (468, '                tag: InvariantLifetime(PhantomData),'), (498, '    use core::marker::PhantomData;'), (511, \"        pub unsafe fn new(_: &'tag mut ()) -> TinyArena<'tag, T> {\"), (513, '                tag: InvariantLifetime(PhantomData),'), (569, \"        pub unsafe fn new(_: &'tag mut ()) -> NanoArena<'tag, T> {\"), (571, '                tag: InvariantLifetime(PhantomData),')]}",
    "num_lines_added": "44",
    "num_lines_deleted": "19",
    "nloc": "452"
  },
  {
    "file_change_id": "216865179938549",
    "hash": "eb413b3d47baea8e8a0b9ce2ccd8299b354d3b7",
    "old_path": "tests/threads.rs",
    "new_path": "tests/threads.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -5,7 +5,8 @@ use crossbeam_utils::thread::scope;\n \n // With crossbeam's `scope`d threads, it is even possible to share an arena\n // and its indices between multiple threads.\n-fn main() {\n+#[test]\n+fn test_scoped_arena() {\n     mk_nano_arena!(arena);\n     let i = arena.add(1usize);\n     let v = scope(|s| {\n",
    "diff_parsed": "{'added': [(8, '#[test]'), (9, 'fn test_scoped_arena() {')], 'deleted': [(8, 'fn main() {')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "1",
    "nloc": "16"
  },
  {
    "file_change_id": "4259795641163",
    "hash": "1e462c32e7933821ddb26dc49fd4ffa5aeca97b",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -76,9 +76,9 @@ impl<T> Drop for QueueSender<T> {\n     }\n }\n \n-unsafe impl<T> Sync for QueueSender<T> {}\n+unsafe impl<T: Send> Sync for QueueSender<T> {}\n \n-unsafe impl<T> Send for QueueSender<T> {}\n+unsafe impl<T: Send> Send for QueueSender<T> {}\n \n /// A `QueueReceiver` is used to pop previously\n /// pushed items from the queue.\n@@ -181,7 +181,7 @@ impl<T> Drop for QueueReceiver<T> {\n     }\n }\n \n-unsafe impl<T> Send for QueueReceiver<T> {}\n+unsafe impl<T: Send> Send for QueueReceiver<T> {}\n \n pub struct Queue;\n \n",
    "diff_parsed": "{'added': [(79, 'unsafe impl<T: Send> Sync for QueueSender<T> {}'), (81, 'unsafe impl<T: Send> Send for QueueSender<T> {}'), (184, 'unsafe impl<T: Send> Send for QueueReceiver<T> {}')], 'deleted': [(79, 'unsafe impl<T> Sync for QueueSender<T> {}'), (81, 'unsafe impl<T> Send for QueueSender<T> {}'), (184, 'unsafe impl<T> Send for QueueReceiver<T> {}')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "3",
    "nloc": "295"
  },
  {
    "file_change_id": "210598178781716",
    "hash": "416a2d480547f6b88ef6d23aa34b1fea292f65f",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -684,7 +684,7 @@ impl<K: Hash + Eq, V, S: BuildHasher> LruCache<K, V, S> {\n     }\n \n     /// An iterator visiting all entries in most-recently used order. The iterator element type is\n-    /// `(&'a K, &'a V)`.\n+    /// `(&K, &V)`.\n     ///\n     /// # Examples\n     ///\n@@ -700,7 +700,7 @@ impl<K: Hash + Eq, V, S: BuildHasher> LruCache<K, V, S> {\n     ///     println!(\"key: {} val: {}\", key, val);\n     /// }\n     /// ```\n-    pub fn iter<'a>(&'_ self) -> Iter<'a, K, V> {\n+    pub fn iter(&self) -> Iter<'_, K, V> {\n         Iter {\n             len: self.len(),\n             ptr: unsafe { (*self.head).next },\n@@ -710,7 +710,7 @@ impl<K: Hash + Eq, V, S: BuildHasher> LruCache<K, V, S> {\n     }\n \n     /// An iterator visiting all entries in most-recently-used order, giving a mutable reference on\n-    /// V.  The iterator element type is `(&'a K, &'a mut V)`.\n+    /// V.  The iterator element type is `(&K, &mut V)`.\n     ///\n     /// # Examples\n     ///\n@@ -735,7 +735,7 @@ impl<K: Hash + Eq, V, S: BuildHasher> LruCache<K, V, S> {\n     ///     }\n     /// }\n     /// ```\n-    pub fn iter_mut<'a>(&'_ mut self) -> IterMut<'a, K, V> {\n+    pub fn iter_mut(&mut self) -> IterMut<'_, K, V> {\n         IterMut {\n             len: self.len(),\n             ptr: unsafe { (*self.head).next },\n",
    "diff_parsed": "{'added': [(703, \"    pub fn iter(&self) -> Iter<'_, K, V> {\"), (738, \"    pub fn iter_mut(&mut self) -> IterMut<'_, K, V> {\")], 'deleted': [(703, \"    pub fn iter<'a>(&'_ self) -> Iter<'a, K, V> {\"), (738, \"    pub fn iter_mut<'a>(&'_ mut self) -> IterMut<'a, K, V> {\")]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "1065"
  },
  {
    "file_change_id": "38173279823917",
    "hash": "3850b645a89666f3efa84c47fad17976e4702c0",
    "old_path": "crates/server/src/store/file/authority.rs",
    "new_path": "crates/server/src/store/file/authority.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -92,6 +92,7 @@ impl FileAuthority {\n             origin,\n             records.len()\n         );\n+        debug!(\"zone: {:#?}\", records);\n \n         FileAuthority::new(origin, records, zone_type, allow_axfr)\n     }\n",
    "diff_parsed": "{'added': [(95, '        debug!(\"zone: {:#?}\", records);')], 'deleted': []}",
    "num_lines_added": "1",
    "num_lines_deleted": "0",
    "nloc": "178"
  },
  {
    "file_change_id": "222140517612475",
    "hash": "3850b645a89666f3efa84c47fad17976e4702c0",
    "old_path": "crates/server/src/store/in_memory/authority.rs",
    "new_path": "crates/server/src/store/in_memory/authority.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -227,7 +227,8 @@ impl InMemoryAuthority {\n         and_rrsigs: bool,\n         supported_algorithms: SupportedAlgorithms,\n     ) -> Option<Arc<RecordSet>> {\n-        let wildcard = if name.is_wildcard() {\n+        // if this is a wildcard or a root, both should break continued lookups\n+        let wildcard = if name.is_wildcard() || name.is_root() {\n             return None;\n         } else {\n             name.clone().into_wildcard()\n",
    "diff_parsed": "{'added': [(231, '        let wildcard = if name.is_wildcard() || name.is_root() {')], 'deleted': [(230, '        let wildcard = if name.is_wildcard() {')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "773"
  },
  {
    "file_change_id": "13960814998594",
    "hash": "3850b645a89666f3efa84c47fad17976e4702c0",
    "old_path": "crates/server/tests/authority_battery/basic.rs",
    "new_path": "crates/server/tests/authority_battery/basic.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -146,6 +146,29 @@ pub fn test_mx<A: Authority<Lookup = AuthLookup>>(authority: A) {\n     assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1), *aaaa);\n }\n \n+pub fn test_mx_to_null<A: Authority<Lookup = AuthLookup>>(authority: A) {\n+    let query = Query::query(\n+        Name::from_str(\"no-service.example.com.\").unwrap(),\n+        RecordType::MX,\n+    );\n+\n+    let mut lookup =\n+        block_on(authority.search(&query.into(), false, SupportedAlgorithms::new())).unwrap();\n+\n+    // In this case there should be no additional records\n+    assert!(lookup.take_additionals().is_none());\n+\n+    let mx = lookup\n+        .into_iter()\n+        .next()\n+        .expect(\"MX record not found in authority\")\n+        .rdata()\n+        .as_mx()\n+        .expect(\"Not an MX record\");\n+\n+    assert_eq!(Name::from_str(\".\").unwrap(), *mx.exchange());\n+}\n+\n pub fn test_cname<A: Authority<Lookup = AuthLookup>>(authority: A) {\n     let query = Query::query(\n         Name::from_str(\"alias.example.com.\").unwrap(),\n@@ -565,6 +588,9 @@ macro_rules! define_basic_test {\n         $(\n             #[test]\n             fn $f () {\n+                // Useful for getting debug logs\n+                // env_logger::init();\n+\n                 let authority = crate::$new(\"../../tests/test-data/named_test_configs/example.com.zone\", module_path!(), stringify!($f));\n                 crate::authority_battery::basic::$f(authority);\n             }\n@@ -583,6 +609,7 @@ macro_rules! basic_battery {\n                     test_ns,\n                     test_ns_lookup,\n                     test_mx,\n+                    test_mx_to_null,\n                     test_cname,\n                     test_cname_alias,\n                     test_cname_chain,\n",
    "diff_parsed": "{'added': [(149, 'pub fn test_mx_to_null<A: Authority<Lookup = AuthLookup>>(authority: A) {'), (150, '    let query = Query::query('), (151, '        Name::from_str(\"no-service.example.com.\").unwrap(),'), (152, '        RecordType::MX,'), (153, '    );'), (155, '    let mut lookup ='), (156, '        block_on(authority.search(&query.into(), false, SupportedAlgorithms::new())).unwrap();'), (159, '    assert!(lookup.take_additionals().is_none());'), (161, '    let mx = lookup'), (162, '        .into_iter()'), (163, '        .next()'), (164, '        .expect(\"MX record not found in authority\")'), (165, '        .rdata()'), (166, '        .as_mx()'), (167, '        .expect(\"Not an MX record\");'), (169, '    assert_eq!(Name::from_str(\".\").unwrap(), *mx.exchange());'), (170, '}'), (612, '                    test_mx_to_null,')], 'deleted': []}",
    "num_lines_added": "18",
    "num_lines_deleted": "0",
    "nloc": "494"
  },
  {
    "file_change_id": "66890603156189",
    "hash": "565d508993936821950009ec4c7c1e33301db81",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -159,12 +159,16 @@ macro_rules! impl_arrays {\n         $(\n         impl<T: Random> Random for [T; $s] {\n             fn random() -> Self {\n+                use std::mem::{MaybeUninit, transmute_copy, size_of};\n                 unsafe {\n-                    let mut array: [T; $s] = std::mem::uninitialized();\n-                    for i in 0..$s {\n-                        std::ptr::write(&mut array[i], T::random());\n+                    let mut array: [MaybeUninit<T>; $s] = MaybeUninit::uninit().assume_init();\n+                    for elem in &mut array[..] {\n+                        *elem = MaybeUninit::new(T::random());\n                     }\n-                    array\n+\n+                    // See https://github.com/rust-lang/rust/issues/47966\n+                    debug_assert!(size_of::<[MaybeUninit<T>; $s]>() == size_of::<[T; $s]>());\n+                    transmute_copy::<_, [T; $s]>(&array)\n                 }\n             }\n         }\n",
    "diff_parsed": "{'added': [(162, '                use std::mem::{MaybeUninit, transmute_copy, size_of};'), (164, '                    let mut array: [MaybeUninit<T>; $s] = MaybeUninit::uninit().assume_init();'), (165, '                    for elem in &mut array[..] {'), (166, '                        *elem = MaybeUninit::new(T::random());'), (170, '                    debug_assert!(size_of::<[MaybeUninit<T>; $s]>() == size_of::<[T; $s]>());'), (171, '                    transmute_copy::<_, [T; $s]>(&array)')], 'deleted': [(163, '                    let mut array: [T; $s] = std::mem::uninitialized();'), (164, '                    for i in 0..$s {'), (165, '                        std::ptr::write(&mut array[i], T::random());'), (167, '                    array')]}",
    "num_lines_added": "6",
    "num_lines_deleted": "4",
    "nloc": "217"
  },
  {
    "file_change_id": "154062086697511",
    "hash": "15b282877d1e576de2b337d8162bbf43ed1a0f2",
    "old_path": "syncpool/src/bucket.rs",
    "new_path": "syncpool/src/bucket.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -333,7 +333,7 @@ impl<T> Drop for Bucket2<T> {\n     }\n }\n \n-unsafe impl<T> Send for Bucket2<T> {}\n+unsafe impl<T: Send> Send for Bucket2<T> {}\n \n pub(crate) struct RingBucket<T> {\n     /// The actual data store. Data are stored in heap and not managed by the runtime, so we must\n",
    "diff_parsed": "{'added': [(336, 'unsafe impl<T: Send> Send for Bucket2<T> {}')], 'deleted': [(336, 'unsafe impl<T> Send for Bucket2<T> {}')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "196"
  },
  {
    "file_change_id": "6926964254611",
    "hash": "a34d6e10f6f5654ed01a35288cf683d014ebc9c",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -33,7 +33,7 @@ where\n \n unsafe impl<R> Send for Decoder<R>\n where\n-        R: Read,\n+        R: Read + Send,\n {\n }\n \n",
    "diff_parsed": "{'added': [(36, '        R: Read + Send,')], 'deleted': [(36, '        R: Read,')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "109"
  },
  {
    "file_change_id": "272551062273951",
    "hash": "8e6daabbc6fb14972a9db5fc94f06801b2d41c2",
    "old_path": "metrics-util/src/bucket.rs",
    "new_path": "metrics-util/src/bucket.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -96,8 +96,8 @@ impl<T> Block<T> {\n     }\n }\n \n-unsafe impl<T> Send for Block<T> {}\n-unsafe impl<T> Sync for Block<T> {}\n+unsafe impl<T: Send> Send for Block<T> {}\n+unsafe impl<T: Sync> Sync for Block<T> {}\n \n impl<T> std::fmt::Debug for Block<T> {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n",
    "diff_parsed": "{'added': [(99, 'unsafe impl<T: Send> Send for Block<T> {}'), (100, 'unsafe impl<T: Sync> Sync for Block<T> {}')], 'deleted': [(99, 'unsafe impl<T> Send for Block<T> {}'), (100, 'unsafe impl<T> Sync for Block<T> {}')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "409"
  },
  {
    "file_change_id": "9935504848042",
    "hash": "5ba266a853bc8232993c84fe736cb87241f9506",
    "old_path": "protocols/deflate/src/lib.rs",
    "new_path": "protocols/deflate/src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -133,10 +133,7 @@ impl<S> AsyncRead for DeflateOutput<S>\n         loop {\n             // Read from `self.inner` into `self.read_interm` if necessary.\n             if this.read_interm.is_empty() && !this.inner_read_eof {\n-                unsafe {\n-                    this.read_interm.reserve(256);\n-                    this.read_interm.set_len(this.read_interm.capacity());\n-                }\n+                this.read_interm.resize(this.read_interm.capacity() + 256, 0);\n \n                 match AsyncRead::poll_read(Pin::new(&mut this.inner), cx, &mut this.read_interm) {\n                     Poll::Ready(Ok(0)) => {\n",
    "diff_parsed": "{'added': [(136, '                this.read_interm.resize(this.read_interm.capacity() + 256, 0);')], 'deleted': [(136, '                unsafe {'), (137, '                    this.read_interm.reserve(256);'), (138, '                    this.read_interm.set_len(this.read_interm.capacity());'), (139, '                }')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "4",
    "nloc": "188"
  },
  {
    "file_change_id": "122194779397932",
    "hash": "1f3709632dccdfd49cbcb152a2f81b95c0b1a3e",
    "old_path": "src/rayon/map.rs",
    "new_path": "src/rayon/map.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -149,7 +149,7 @@ where\n                 let guard = Arc::new(guard);\n                 sref.iter().map(move |(k, v)| {\n                     let guard = Arc::clone(&guard);\n-                    RefMulti::new(guard, k, v.get())\n+                    unsafe { RefMulti::new(guard, k, v.get()) }\n                 })\n             })\n             .drive_unindexed(consumer)\n@@ -213,7 +213,7 @@ where\n                 let guard = Arc::new(guard);\n                 sref.iter_mut().map(move |(k, v)| {\n                     let guard = Arc::clone(&guard);\n-                    RefMutMulti::new(guard, k, v.get_mut())\n+                    unsafe { RefMutMulti::new(guard, k, v.get_mut()) }\n                 })\n             })\n             .drive_unindexed(consumer)\n",
    "diff_parsed": "{'added': [(152, '                    unsafe { RefMulti::new(guard, k, v.get()) }'), (216, '                    unsafe { RefMutMulti::new(guard, k, v.get_mut()) }')], 'deleted': [(152, '                    RefMulti::new(guard, k, v.get())'), (216, '                    RefMutMulti::new(guard, k, v.get_mut())')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "198"
  },
  {
    "file_change_id": "77837734116007",
    "hash": "fbb6ffb1d70ae520889062728476d7d607c9309e",
    "old_path": "src/mapref/entry.rs",
    "new_path": "src/mapref/entry.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -28,7 +28,7 @@ impl<'a, K: Eq + Hash, V, S: BuildHasher> Entry<'a, K, V, S> {\n     }\n \n     /// Get the key of the entry.\n-    pub fn key(&self) -> &K {\n+    pub fn key<'r>(&'r self) -> &'r K {\n         match *self {\n             Entry::Occupied(ref entry) => entry.key(),\n             Entry::Vacant(ref entry) => entry.key(),\n@@ -125,7 +125,7 @@ impl<'a, K: Eq + Hash, V, S: BuildHasher> VacantEntry<'a, K, V, S> {\n         self.key\n     }\n \n-    pub fn key(&self) -> &K {\n+    pub fn key<'r>(&'r self) -> &'r K {\n         &self.key\n     }\n }\n@@ -152,11 +152,11 @@ impl<'a, K: Eq + Hash, V, S: BuildHasher> OccupiedEntry<'a, K, V, S> {\n         Self { shard, elem, key }\n     }\n \n-    pub fn get(&self) -> &V {\n+    pub fn get<'r>(&'r self) -> &'r V {\n         self.elem.1\n     }\n \n-    pub fn get_mut(&mut self) -> &mut V {\n+    pub fn get_mut<'r>(&'r mut self) -> &'r mut V {\n         self.elem.1\n     }\n \n@@ -172,7 +172,7 @@ impl<'a, K: Eq + Hash, V, S: BuildHasher> OccupiedEntry<'a, K, V, S> {\n         self.key\n     }\n \n-    pub fn key(&self) -> &K {\n+    pub fn key<'r>(&'r self) -> &'r K {\n         self.elem.0\n     }\n \n",
    "diff_parsed": "{'added': [(31, \"    pub fn key<'r>(&'r self) -> &'r K {\"), (128, \"    pub fn key<'r>(&'r self) -> &'r K {\"), (155, \"    pub fn get<'r>(&'r self) -> &'r V {\"), (159, \"    pub fn get_mut<'r>(&'r mut self) -> &'r mut V {\"), (175, \"    pub fn key<'r>(&'r self) -> &'r K {\")], 'deleted': [(31, '    pub fn key(&self) -> &K {'), (128, '    pub fn key(&self) -> &K {'), (155, '    pub fn get(&self) -> &V {'), (159, '    pub fn get_mut(&mut self) -> &mut V {'), (175, '    pub fn key(&self) -> &K {')]}",
    "num_lines_added": "5",
    "num_lines_deleted": "5",
    "nloc": "166"
  },
  {
    "file_change_id": "102105249511752",
    "hash": "fbb6ffb1d70ae520889062728476d7d607c9309e",
    "old_path": "src/mapref/multiple.rs",
    "new_path": "src/mapref/multiple.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -6,7 +6,6 @@ use parking_lot::{RwLockReadGuard, RwLockWriteGuard};\n use std::collections::hash_map::RandomState;\n use std::sync::Arc;\n \n-// -- Shared\n pub struct RefMulti<'a, K, V, S = RandomState> {\n     _guard: Arc<RwLockReadGuard<'a, HashMap<K, V, S>>>,\n     k: &'a K,\n@@ -33,15 +32,15 @@ impl<'a, K: Eq + Hash, V, S: BuildHasher> RefMulti<'a, K, V, S> {\n         }\n     }\n \n-    pub fn key(&self) -> &'a K {\n+    pub fn key<'r>(&'r self) -> &'r K {\n         self.k\n     }\n \n-    pub fn value(&self) -> &'a V {\n+    pub fn value<'r>(&'r self) -> &'r V {\n         self.v\n     }\n \n-    pub fn pair(&self) -> (&'a K, &'a V) {\n+    pub fn pair<'r>(&'r self) -> (&'r K, &'r V) {\n         (self.k, self.v)\n     }\n }\n@@ -54,8 +53,6 @@ impl<'a, K: Eq + Hash, V, S: BuildHasher> Deref for RefMulti<'a, K, V, S> {\n     }\n }\n \n-// --\n-// -- Unique\n pub struct RefMutMulti<'a, K, V, S = RandomState> {\n     _guard: Arc<RwLockWriteGuard<'a, HashMap<K, V, S>>>,\n     k: &'a K,\n@@ -82,23 +79,23 @@ impl<'a, K: Eq + Hash, V, S: BuildHasher> RefMutMulti<'a, K, V, S> {\n         }\n     }\n \n-    pub fn key(&self) -> &'a K {\n+    pub fn key<'r>(&'r self) -> &'r K {\n         self.k\n     }\n \n-    pub fn value(&self) -> &V {\n+    pub fn value<'r>(&'r self) -> &'r V {\n         self.v\n     }\n \n-    pub fn value_mut(&mut self) -> &mut V {\n+    pub fn value_mut<'r>(&'r mut self) -> &'r mut V {\n         self.v\n     }\n \n-    pub fn pair(&self) -> (&'a K, &V) {\n+    pub fn pair<'r>(&'r self) -> (&'r K, &'r V) {\n         (self.k, self.v)\n     }\n \n-    pub fn pair_mut(&mut self) -> (&'a K, &mut V) {\n+    pub fn pair_mut<'r>(&'r mut self) -> (&'r K, &'r mut V) {\n         (self.k, self.v)\n     }\n }\n@@ -116,5 +113,3 @@ impl<'a, K: Eq + Hash, V, S: BuildHasher> DerefMut for RefMutMulti<'a, K, V, S>\n         self.value_mut()\n     }\n }\n-\n-// --\n",
    "diff_parsed": "{'added': [(35, \"    pub fn key<'r>(&'r self) -> &'r K {\"), (39, \"    pub fn value<'r>(&'r self) -> &'r V {\"), (43, \"    pub fn pair<'r>(&'r self) -> (&'r K, &'r V) {\"), (82, \"    pub fn key<'r>(&'r self) -> &'r K {\"), (86, \"    pub fn value<'r>(&'r self) -> &'r V {\"), (90, \"    pub fn value_mut<'r>(&'r mut self) -> &'r mut V {\"), (94, \"    pub fn pair<'r>(&'r self) -> (&'r K, &'r V) {\"), (98, \"    pub fn pair_mut<'r>(&'r mut self) -> (&'r K, &'r mut V) {\")], 'deleted': [(36, \"    pub fn key(&self) -> &'a K {\"), (40, \"    pub fn value(&self) -> &'a V {\"), (44, \"    pub fn pair(&self) -> (&'a K, &'a V) {\"), (85, \"    pub fn key(&self) -> &'a K {\"), (89, '    pub fn value(&self) -> &V {'), (93, '    pub fn value_mut(&mut self) -> &mut V {'), (97, \"    pub fn pair(&self) -> (&'a K, &V) {\"), (101, \"    pub fn pair_mut(&mut self) -> (&'a K, &mut V) {\")]}",
    "num_lines_added": "8",
    "num_lines_deleted": "8",
    "nloc": "108"
  },
  {
    "file_change_id": "109070053888753",
    "hash": "fbb6ffb1d70ae520889062728476d7d607c9309e",
    "old_path": "src/mapref/one.rs",
    "new_path": "src/mapref/one.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -4,7 +4,6 @@ use core::ops::{Deref, DerefMut};\n use parking_lot::{RwLockReadGuard, RwLockWriteGuard};\n use std::collections::hash_map::RandomState;\n \n-// -- Shared\n pub struct Ref<'a, K, V, S = RandomState> {\n     _guard: RwLockReadGuard<'a, HashMap<K, V, S>>,\n     k: &'a K,\n@@ -27,15 +26,15 @@ impl<'a, K: Eq + Hash, V, S: BuildHasher> Ref<'a, K, V, S> {\n         }\n     }\n \n-    pub fn key(&self) -> &'a K {\n+    pub fn key<'r>(&'r self) -> &'r K {\n         self.k\n     }\n \n-    pub fn value(&self) -> &'a V {\n+    pub fn value<'r>(&'r self) -> &'r V {\n         self.v\n     }\n \n-    pub fn pair(&self) -> (&'a K, &'a V) {\n+    pub fn pair<'r>(&'r self) -> (&'r K, &'r V) {\n         (self.k, self.v)\n     }\n }\n@@ -48,8 +47,6 @@ impl<'a, K: Eq + Hash, V, S: BuildHasher> Deref for Ref<'a, K, V, S> {\n     }\n }\n \n-// --\n-// -- Unique\n pub struct RefMut<'a, K, V, S = RandomState> {\n     guard: RwLockWriteGuard<'a, HashMap<K, V, S>>,\n     k: &'a K,\n@@ -72,23 +69,23 @@ impl<'a, K: Eq + Hash, V, S: BuildHasher> RefMut<'a, K, V, S> {\n         Self { guard, k, v }\n     }\n \n-    pub fn key(&self) -> &'a K {\n+    pub fn key<'r>(&'r self) -> &'r K {\n         self.k\n     }\n \n-    pub fn value(&self) -> &V {\n+    pub fn value<'r>(&'r self) -> &'r V {\n         self.v\n     }\n \n-    pub fn value_mut(&mut self) -> &mut V {\n+    pub fn value_mut<'r>(&'r mut self) -> &'r mut V {\n         self.v\n     }\n \n-    pub fn pair(&self) -> (&'a K, &V) {\n+    pub fn pair<'r>(&'r self) -> (&'r K, &'r V) {\n         (self.k, self.v)\n     }\n \n-    pub fn pair_mut(&mut self) -> (&'a K, &mut V) {\n+    pub fn pair_mut<'r>(&'r mut self) -> (&'r K, &'r mut V) {\n         (self.k, self.v)\n     }\n \n@@ -114,5 +111,3 @@ impl<'a, K: Eq + Hash, V, S: BuildHasher> DerefMut for RefMut<'a, K, V, S> {\n         self.value_mut()\n     }\n }\n-\n-// --\n",
    "diff_parsed": "{'added': [(29, \"    pub fn key<'r>(&'r self) -> &'r K {\"), (33, \"    pub fn value<'r>(&'r self) -> &'r V {\"), (37, \"    pub fn pair<'r>(&'r self) -> (&'r K, &'r V) {\"), (72, \"    pub fn key<'r>(&'r self) -> &'r K {\"), (76, \"    pub fn value<'r>(&'r self) -> &'r V {\"), (80, \"    pub fn value_mut<'r>(&'r mut self) -> &'r mut V {\"), (84, \"    pub fn pair<'r>(&'r self) -> (&'r K, &'r V) {\"), (88, \"    pub fn pair_mut<'r>(&'r mut self) -> (&'r K, &'r mut V) {\")], 'deleted': [(30, \"    pub fn key(&self) -> &'a K {\"), (34, \"    pub fn value(&self) -> &'a V {\"), (38, \"    pub fn pair(&self) -> (&'a K, &'a V) {\"), (75, \"    pub fn key(&self) -> &'a K {\"), (79, '    pub fn value(&self) -> &V {'), (83, '    pub fn value_mut(&mut self) -> &mut V {'), (87, \"    pub fn pair(&self) -> (&'a K, &V) {\"), (91, \"    pub fn pair_mut(&mut self) -> (&'a K, &mut V) {\")]}",
    "num_lines_added": "8",
    "num_lines_deleted": "8",
    "nloc": "103"
  },
  {
    "file_change_id": "241499401111890",
    "hash": "fbb6ffb1d70ae520889062728476d7d607c9309e",
    "old_path": "src/setref/multiple.rs",
    "new_path": "src/setref/multiple.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -11,7 +11,7 @@ impl<'a, K: Eq + Hash, S: BuildHasher> RefMulti<'a, K, S> {\n         Self { inner }\n     }\n \n-    pub fn key(&self) -> &'a K {\n+    pub fn key<'r>(&'r self) -> &'r K {\n         self.inner.key()\n     }\n }\n",
    "diff_parsed": "{'added': [(14, \"    pub fn key<'r>(&'r self) -> &'r K {\")], 'deleted': [(14, \"    pub fn key(&self) -> &'a K {\")]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "22"
  },
  {
    "file_change_id": "275853579765691",
    "hash": "fbb6ffb1d70ae520889062728476d7d607c9309e",
    "old_path": "src/setref/one.rs",
    "new_path": "src/setref/one.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -15,7 +15,7 @@ impl<'a, K: Eq + Hash, S: BuildHasher> Ref<'a, K, S> {\n         Self { inner }\n     }\n \n-    pub fn key(&self) -> &'a K {\n+    pub fn key<'r>(&'r self) -> &'r K {\n         self.inner.key()\n     }\n }\n",
    "diff_parsed": "{'added': [(18, \"    pub fn key<'r>(&'r self) -> &'r K {\")], 'deleted': [(18, \"    pub fn key(&self) -> &'a K {\")]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "24"
  },
  {
    "file_change_id": "26305336239336",
    "hash": "b0d2bd20eb40b9cbc2958b981ba2dcd9e6f9396",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -81,8 +81,10 @@ pub struct Singleton<T: 'static> {\n \n // The Singleton need to implement Send & Sync to ensure cross core compile check mechanics\n // this is safe as the inner RWLock ensures cross core safety\n-unsafe impl<T> Sync for Singleton<T> {}\n-unsafe impl<T> Send for Singleton<T> {}\n+// but we need to be conditional on the inner type to prevent interior mutable types beeing used\n+// inside a singleton\n+unsafe impl<T> Sync for Singleton<T> where T: Sync {}\n+unsafe impl<T> Send for Singleton<T> where T: Send {}\n \n impl<T: 'static> Singleton<T> {\n     /// Create a new [Singleton] instance to be used in a static variable. Only ``const fn`` constructors are allowed\n",
    "diff_parsed": "{'added': [(86, 'unsafe impl<T> Sync for Singleton<T> where T: Sync {}'), (87, 'unsafe impl<T> Send for Singleton<T> where T: Send {}')], 'deleted': [(84, 'unsafe impl<T> Sync for Singleton<T> {}'), (85, 'unsafe impl<T> Send for Singleton<T> {}')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "51"
  },
  {
    "file_change_id": "81512297366861",
    "hash": "14ee7a6f775c5018e71521b52b3c24de8a82c90",
    "old_path": "src/unistd.rs",
    "new_path": "src/unistd.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1540,8 +1540,7 @@ pub fn getgrouplist(user: &CStr, group: Gid) -> Result<Vec<Gid>> {\n         Ok(None) | Err(_) => <c_int>::max_value(),\n     };\n     use std::cmp::min;\n-    let mut ngroups = min(ngroups_max, 8);\n-    let mut groups = Vec::<Gid>::with_capacity(ngroups as usize);\n+    let mut groups = Vec::<Gid>::with_capacity(min(ngroups_max, 8) as usize);\n     cfg_if! {\n         if #[cfg(any(target_os = \"ios\", target_os = \"macos\"))] {\n             type getgrouplist_group_t = c_int;\n@@ -1551,6 +1550,7 @@ pub fn getgrouplist(user: &CStr, group: Gid) -> Result<Vec<Gid>> {\n     }\n     let gid: gid_t = group.into();\n     loop {\n+        let mut ngroups = groups.capacity() as i32;\n         let ret = unsafe {\n             libc::getgrouplist(user.as_ptr(),\n                                gid as getgrouplist_group_t,\n@@ -1567,8 +1567,16 @@ pub fn getgrouplist(user: &CStr, group: Gid) -> Result<Vec<Gid>> {\n             // BSD systems will still fill the groups buffer with as many\n             // groups as possible, but Linux manpages do not mention this\n             // behavior.\n-            reserve_double_buffer_size(&mut groups, ngroups_max as usize)\n-                .map_err(|_| Errno::EINVAL)?;\n+            // Linux stores the number of groups found in ngroups.  We can\n+            // use that to resize the buffer exactly.\n+            cfg_if! {\n+                if #[cfg(target_os = \"linux\")] {\n+                    groups.reserve_exact(ngroups as usize);\n+                } else {\n+                    reserve_double_buffer_size(&mut groups, ngroups_max as usize)\n+                        .map_err(|_| Errno::EINVAL)?;       \n+                }\n+            }            \n         }\n     }\n }\n",
    "diff_parsed": "{'added': [(1543, '    let mut groups = Vec::<Gid>::with_capacity(min(ngroups_max, 8) as usize);'), (1553, '        let mut ngroups = groups.capacity() as i32;'), (1572, '            cfg_if! {'), (1573, '                if #[cfg(target_os = \"linux\")] {'), (1574, '                    groups.reserve_exact(ngroups as usize);'), (1575, '                } else {'), (1576, '                    reserve_double_buffer_size(&mut groups, ngroups_max as usize)'), (1577, '                        .map_err(|_| Errno::EINVAL)?;'), (1578, '                }'), (1579, '            }')], 'deleted': [(1543, '    let mut ngroups = min(ngroups_max, 8);'), (1544, '    let mut groups = Vec::<Gid>::with_capacity(ngroups as usize);'), (1570, '            reserve_double_buffer_size(&mut groups, ngroups_max as usize)'), (1571, '                .map_err(|_| Errno::EINVAL)?;')]}",
    "num_lines_added": "10",
    "num_lines_deleted": "4",
    "nloc": "1615"
  },
  {
    "file_change_id": "271604226961847",
    "hash": "c8f82d45060c9e936ab49cd3838135208de0924",
    "old_path": "tokio/src/sync/oneshot.rs",
    "new_path": "tokio/src/sync/oneshot.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -839,13 +839,15 @@ impl<T> Receiver<T> {\n         let result = if let Some(inner) = self.inner.as_ref() {\n             let state = State::load(&inner.state, Acquire);\n \n-            if state.is_complete() {\n+            // First, check if the channel has been closed. If the channel is\n+            // closed, return an error.\n+            if state.is_closed() {\n+                Err(TryRecvError::Closed)\n+            } else if state.is_complete() {\n                 match unsafe { inner.consume_value() } {\n                     Some(value) => Ok(value),\n                     None => Err(TryRecvError::Closed),\n                 }\n-            } else if state.is_closed() {\n-                Err(TryRecvError::Closed)\n             } else {\n                 // Not ready, this does not clear `inner`\n                 return Err(TryRecvError::Empty);\n",
    "diff_parsed": "{'added': [(844, '            if state.is_closed() {'), (845, '                Err(TryRecvError::Closed)'), (846, '            } else if state.is_complete() {')], 'deleted': [(842, '            if state.is_complete() {'), (847, '            } else if state.is_closed() {'), (848, '                Err(TryRecvError::Closed)')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "3",
    "nloc": "543"
  },
  {
    "file_change_id": "132001533177210",
    "hash": "d08bc37de3dd471ea564a954a2de1d0caf045f6",
    "old_path": "src/lib.rs",
    "new_path": "src/lib.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1130,7 +1130,7 @@ unsafe impl<'a> alloc::Alloc for &'a Bump {\n             if let Some(p) =\n                 self.try_alloc_layout_fast(layout_from_size_align(delta, layout.align()))\n             {\n-                ptr::copy(ptr.as_ptr(), p.as_ptr(), new_size);\n+                ptr::copy(ptr.as_ptr(), p.as_ptr(), old_size);\n                 return Ok(p);\n             }\n         }\n@@ -1200,4 +1200,23 @@ mod tests {\n             b.reset();\n         }\n     }\n+\n+    #[test]\n+    fn invalid_read() {\n+        use alloc::Alloc;\n+\n+        let mut b = &Bump::new();\n+\n+        unsafe {\n+            let l1 = Layout::from_size_align(12000, 4).unwrap();\n+            let p1 = Alloc::alloc(&mut b, l1).unwrap();\n+\n+            let l2 = Layout::from_size_align(1000, 4).unwrap();\n+            Alloc::alloc(&mut b, l2).unwrap();\n+\n+            let p1 = b.realloc(p1, l1, 24000).unwrap();\n+            let l3 = Layout::from_size_align(24000, 4).unwrap();\n+            b.realloc(p1, l3, 48000).unwrap();\n+        }\n+    }\n }\n",
    "diff_parsed": "{'added': [(1133, '                ptr::copy(ptr.as_ptr(), p.as_ptr(), old_size);'), (1204, '    #[test]'), (1205, '    fn invalid_read() {'), (1206, '        use alloc::Alloc;'), (1208, '        let mut b = &Bump::new();'), (1210, '        unsafe {'), (1211, '            let l1 = Layout::from_size_align(12000, 4).unwrap();'), (1212, '            let p1 = Alloc::alloc(&mut b, l1).unwrap();'), (1214, '            let l2 = Layout::from_size_align(1000, 4).unwrap();'), (1215, '            Alloc::alloc(&mut b, l2).unwrap();'), (1217, '            let p1 = b.realloc(p1, l1, 24000).unwrap();'), (1218, '            let l3 = Layout::from_size_align(24000, 4).unwrap();'), (1219, '            b.realloc(p1, l3, 48000).unwrap();'), (1220, '        }'), (1221, '    }')], 'deleted': [(1133, '                ptr::copy(ptr.as_ptr(), p.as_ptr(), new_size);')]}",
    "num_lines_added": "15",
    "num_lines_deleted": "1",
    "nloc": "514"
  },
  {
    "file_change_id": "234984025750207",
    "hash": "d08bc37de3dd471ea564a954a2de1d0caf045f6",
    "old_path": "tests/vec.rs",
    "new_path": "tests/vec.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -57,3 +57,29 @@ fn test_into_bump_slice_mut() {\n \n     assert_eq!(slice, [3, 2, 1]);\n }\n+\n+quickcheck::quickcheck! {\n+    fn vec_resizes_causing_reallocs(sizes: std::vec::Vec<usize>) -> () {\n+        // Exercise `realloc` by doing a bunch of `resize`s followed by\n+        // `shrink_to_fit`s.\n+\n+        let b = Bump::new();\n+        let mut v = bumpalo::vec![in &b];\n+\n+        for len in sizes {\n+            // We don't want to get too big and OOM.\n+            const MAX_SIZE: usize = 1 << 15;\n+\n+            // But we want allocations to get fairly close to the minimum chunk\n+            // size, so that we are exercising both realloc'ing within a chunk\n+            // and when we need new chunks.\n+            const MIN_SIZE: usize = 1 << 7;\n+\n+            let len = std::cmp::min(len, MAX_SIZE);\n+            let len = std::cmp::max(len, MIN_SIZE);\n+\n+            v.resize(len, 0);\n+            v.shrink_to_fit();\n+        }\n+    }\n+}\n",
    "diff_parsed": "{'added': [(61, 'quickcheck::quickcheck! {'), (62, '    fn vec_resizes_causing_reallocs(sizes: std::vec::Vec<usize>) -> () {'), (66, '        let b = Bump::new();'), (67, '        let mut v = bumpalo::vec![in &b];'), (69, '        for len in sizes {'), (71, '            const MAX_SIZE: usize = 1 << 15;'), (76, '            const MIN_SIZE: usize = 1 << 7;'), (78, '            let len = std::cmp::min(len, MAX_SIZE);'), (79, '            let len = std::cmp::max(len, MIN_SIZE);'), (81, '            v.resize(len, 0);'), (82, '            v.shrink_to_fit();'), (83, '        }'), (84, '    }'), (85, '}')], 'deleted': []}",
    "num_lines_added": "14",
    "num_lines_deleted": "0",
    "nloc": "60"
  },
  {
    "file_change_id": "211732542147865",
    "hash": "0562cbfe79f68e061628e5cf0d29d9f879b6913",
    "old_path": "src/demuxer.rs",
    "new_path": "src/demuxer.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -262,7 +262,7 @@ where\n     events: T,\n }\n \n-unsafe impl<T> Send for Demuxer<T> where T: DemuxerEvents {}\n+unsafe impl<T> Send for Demuxer<T> where T: DemuxerEvents + Send {}\n \n impl<T> Demuxer<T>\n where\n",
    "diff_parsed": "{'added': [(265, 'unsafe impl<T> Send for Demuxer<T> where T: DemuxerEvents + Send {}')], 'deleted': [(265, 'unsafe impl<T> Send for Demuxer<T> where T: DemuxerEvents {}')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "430"
  },
  {
    "file_change_id": "255889875213306",
    "hash": "e7fb2f5b5f95437a37d99b8c430c8adc9045f35",
    "old_path": "src/processing/image.rs",
    "new_path": "src/processing/image.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -157,8 +157,8 @@ impl<T> ImageChunkMut<'_, T> {\n     }\n }\n \n-unsafe impl<T> Send for ImageChunkMut<'_, T> {}\n-unsafe impl<T> Sync for ImageChunkMut<'_, T> {}\n+unsafe impl<T: Send> Send for ImageChunkMut<'_, T> {}\n+unsafe impl<T: Sync> Sync for ImageChunkMut<'_, T> {}\n \n impl<T> Index<(usize, usize)> for ImageChunkMut<'_, T> {\n     type Output = T;\n",
    "diff_parsed": "{'added': [(160, \"unsafe impl<T: Send> Send for ImageChunkMut<'_, T> {}\"), (161, \"unsafe impl<T: Sync> Sync for ImageChunkMut<'_, T> {}\")], 'deleted': [(160, \"unsafe impl<T> Send for ImageChunkMut<'_, T> {}\"), (161, \"unsafe impl<T> Sync for ImageChunkMut<'_, T> {}\")]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "206"
  },
  {
    "file_change_id": "5972755025786",
    "hash": "ef4aa05cdd3b81ae9f8a42acd211e95530b1ab7",
    "old_path": "async-coap/src/arc_guard.rs",
    "new_path": "async-coap/src/arc_guard.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -160,8 +160,8 @@ impl<RC, T> ArcGuard<RC, T> {\n     }\n }\n \n-unsafe impl<RC, T: Send> Send for ArcGuard<RC, T> {}\n-unsafe impl<RC, T: Sync> Sync for ArcGuard<RC, T> {}\n+unsafe impl<RC: Send, T: Send> Send for ArcGuard<RC, T> {}\n+unsafe impl<RC: Sync, T: Sync> Sync for ArcGuard<RC, T> {}\n \n impl<RC, T> Deref for ArcGuard<RC, T> {\n     type Target = T;\n",
    "diff_parsed": "{'added': [(163, 'unsafe impl<RC: Send, T: Send> Send for ArcGuard<RC, T> {}'), (164, 'unsafe impl<RC: Sync, T: Sync> Sync for ArcGuard<RC, T> {}')], 'deleted': [(163, 'unsafe impl<RC, T: Send> Send for ArcGuard<RC, T> {}'), (164, 'unsafe impl<RC, T: Sync> Sync for ArcGuard<RC, T> {}')]}",
    "num_lines_added": "2",
    "num_lines_deleted": "2",
    "nloc": "112"
  },
  {
    "file_change_id": "86914410247262",
    "hash": "5bff5368bf38ddfa31416e4ae9897b163031a51",
    "old_path": "src/base/vec_storage.rs",
    "new_path": "src/base/vec_storage.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -13,6 +13,12 @@ use crate::base::storage::{\n };\n use crate::base::{Scalar, Vector};\n \n+#[cfg(feature = \"serde-serialize-no-std\")]\n+use serde::{\n+    de::{Deserialize, Deserializer, Error},\n+    ser::{Serialize, Serializer},\n+};\n+\n #[cfg(feature = \"abomonation-serialize\")]\n use abomonation::Abomonation;\n \n@@ -24,13 +30,54 @@ use abomonation::Abomonation;\n /// A Vec-based matrix data storage. It may be dynamically-sized.\n #[repr(C)]\n #[derive(Eq, Debug, Clone, PartialEq)]\n-#[cfg_attr(feature = \"serde-serialize\", derive(Serialize, Deserialize))]\n pub struct VecStorage<T, R: Dim, C: Dim> {\n     data: Vec<T>,\n     nrows: R,\n     ncols: C,\n }\n \n+#[cfg(feature = \"serde-serialize\")]\n+impl<T, R: Dim, C: Dim> Serialize for VecStorage<T, R, C>\n+where\n+    T: Serialize,\n+    R: Serialize,\n+    C: Serialize,\n+{\n+    fn serialize<Ser>(&self, serializer: Ser) -> Result<Ser::Ok, Ser::Error>\n+    where\n+        Ser: Serializer,\n+    {\n+        (&self.data, &self.nrows, &self.ncols).serialize(serializer)\n+    }\n+}\n+\n+#[cfg(feature = \"serde-serialize\")]\n+impl<'a, T, R: Dim, C: Dim> Deserialize<'a> for VecStorage<T, R, C>\n+where\n+    T: Deserialize<'a>,\n+    R: Deserialize<'a>,\n+    C: Deserialize<'a>,\n+{\n+    fn deserialize<Des>(deserializer: Des) -> Result<Self, Des::Error>\n+    where\n+        Des: Deserializer<'a>,\n+    {\n+        let (data, nrows, ncols): (Vec<T>, R, C) = Deserialize::deserialize(deserializer)?;\n+\n+        // SAFETY: make sure the data we deserialize have the\n+        //         correct number of elements.\n+        if nrows.value() * ncols.value() != data.len() {\n+            return Err(Des::Error::custom(format!(\n+                \"Expected {} components, found {}\",\n+                nrows.value() * ncols.value(),\n+                data.len()\n+            )));\n+        }\n+\n+        Ok(Self { data, nrows, ncols })\n+    }\n+}\n+\n #[deprecated(note = \"renamed to `VecStorage`\")]\n /// Renamed to [VecStorage].\n pub type MatrixVec<T, R, C> = VecStorage<T, R, C>;\n",
    "diff_parsed": "{'added': [(16, '#[cfg(feature = \"serde-serialize-no-std\")]'), (17, 'use serde::{'), (18, '    de::{Deserialize, Deserializer, Error},'), (19, '    ser::{Serialize, Serializer},'), (20, '};'), (39, '#[cfg(feature = \"serde-serialize\")]'), (40, 'impl<T, R: Dim, C: Dim> Serialize for VecStorage<T, R, C>'), (41, 'where'), (42, '    T: Serialize,'), (43, '    R: Serialize,'), (44, '    C: Serialize,'), (45, '{'), (46, '    fn serialize<Ser>(&self, serializer: Ser) -> Result<Ser::Ok, Ser::Error>'), (47, '    where'), (48, '        Ser: Serializer,'), (49, '    {'), (50, '        (&self.data, &self.nrows, &self.ncols).serialize(serializer)'), (51, '    }'), (52, '}'), (54, '#[cfg(feature = \"serde-serialize\")]'), (55, \"impl<'a, T, R: Dim, C: Dim> Deserialize<'a> for VecStorage<T, R, C>\"), (56, 'where'), (57, \"    T: Deserialize<'a>,\"), (58, \"    R: Deserialize<'a>,\"), (59, \"    C: Deserialize<'a>,\"), (60, '{'), (61, '    fn deserialize<Des>(deserializer: Des) -> Result<Self, Des::Error>'), (62, '    where'), (63, \"        Des: Deserializer<'a>,\"), (64, '    {'), (65, '        let (data, nrows, ncols): (Vec<T>, R, C) = Deserialize::deserialize(deserializer)?;'), (69, '        if nrows.value() * ncols.value() != data.len() {'), (70, '            return Err(Des::Error::custom(format!('), (71, '                \"Expected {} components, found {}\",'), (72, '                nrows.value() * ncols.value(),'), (73, '                data.len()'), (74, '            )));'), (75, '        }'), (77, '        Ok(Self { data, nrows, ncols })'), (78, '    }'), (79, '}')], 'deleted': [(27, '#[cfg_attr(feature = \"serde-serialize\", derive(Serialize, Deserialize))]')]}",
    "num_lines_added": "41",
    "num_lines_deleted": "1",
    "nloc": "358"
  },
  {
    "file_change_id": "185956083083383",
    "hash": "5bff5368bf38ddfa31416e4ae9897b163031a51",
    "old_path": "tests/core/serde.rs",
    "new_path": "tests/core/serde.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -1,8 +1,8 @@\n #![cfg(feature = \"serde-serialize\")]\n \n use na::{\n-    DMatrix, Isometry2, Isometry3, IsometryMatrix2, IsometryMatrix3, Matrix3x4, Point2, Point3,\n-    Quaternion, Rotation2, Rotation3, Similarity2, Similarity3, SimilarityMatrix2,\n+    DMatrix, Isometry2, Isometry3, IsometryMatrix2, IsometryMatrix3, Matrix2x3, Matrix3x4, Point2,\n+    Point3, Quaternion, Rotation2, Rotation3, Similarity2, Similarity3, SimilarityMatrix2,\n     SimilarityMatrix3, Translation2, Translation3, Unit, Vector2,\n };\n use rand;\n@@ -27,6 +27,32 @@ fn serde_dmatrix() {\n     let serialized = serde_json::to_string(&v).unwrap();\n     let deserialized: DMatrix<f32> = serde_json::from_str(&serialized).unwrap();\n     assert_eq!(v, deserialized);\n+\n+    let m = DMatrix::from_column_slice(2, 3, &[1.0, 2.0, 3.0, 4.0, 5.0, 6.0]);\n+    let mat_str = \"[[1.0, 2.0, 3.0, 4.0, 5.0, 6.0],2,3]\";\n+    let deserialized: DMatrix<f32> = serde_json::from_str(&mat_str).unwrap();\n+    assert_eq!(m, deserialized);\n+\n+    let m = Matrix2x3::from_column_slice(&[1.0, 2.0, 3.0, 4.0, 5.0, 6.0]);\n+    let mat_str = \"[1.0, 2.0, 3.0, 4.0, 5.0, 6.0]\";\n+    let deserialized: Matrix2x3<f32> = serde_json::from_str(&mat_str).unwrap();\n+    assert_eq!(m, deserialized);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn serde_dmatrix_invalid_len() {\n+    // This must fail: we attempt to deserialize a 2x3 with only 5 elements.\n+    let mat_str = \"[[1.0, 2.0, 3.0, 4.0, 5.0],2,3]\";\n+    let _: DMatrix<f32> = serde_json::from_str(&mat_str).unwrap();\n+}\n+\n+#[test]\n+#[should_panic]\n+fn serde_smatrix_invalid_len() {\n+    // This must fail: we attempt to deserialize a 2x3 with only 5 elements.\n+    let mat_str = \"[1.0, 2.0, 3.0, 4.0, 5.0]\";\n+    let _: Matrix2x3<f32> = serde_json::from_str(&mat_str).unwrap();\n }\n \n test_serde!(\n",
    "diff_parsed": "{'added': [(4, '    DMatrix, Isometry2, Isometry3, IsometryMatrix2, IsometryMatrix3, Matrix2x3, Matrix3x4, Point2,'), (5, '    Point3, Quaternion, Rotation2, Rotation3, Similarity2, Similarity3, SimilarityMatrix2,'), (31, '    let m = DMatrix::from_column_slice(2, 3, &[1.0, 2.0, 3.0, 4.0, 5.0, 6.0]);'), (32, '    let mat_str = \"[[1.0, 2.0, 3.0, 4.0, 5.0, 6.0],2,3]\";'), (33, '    let deserialized: DMatrix<f32> = serde_json::from_str(&mat_str).unwrap();'), (34, '    assert_eq!(m, deserialized);'), (36, '    let m = Matrix2x3::from_column_slice(&[1.0, 2.0, 3.0, 4.0, 5.0, 6.0]);'), (37, '    let mat_str = \"[1.0, 2.0, 3.0, 4.0, 5.0, 6.0]\";'), (38, '    let deserialized: Matrix2x3<f32> = serde_json::from_str(&mat_str).unwrap();'), (39, '    assert_eq!(m, deserialized);'), (40, '}'), (42, '#[test]'), (43, '#[should_panic]'), (44, 'fn serde_dmatrix_invalid_len() {'), (46, '    let mat_str = \"[[1.0, 2.0, 3.0, 4.0, 5.0],2,3]\";'), (47, '    let _: DMatrix<f32> = serde_json::from_str(&mat_str).unwrap();'), (48, '}'), (50, '#[test]'), (51, '#[should_panic]'), (52, 'fn serde_smatrix_invalid_len() {'), (54, '    let mat_str = \"[1.0, 2.0, 3.0, 4.0, 5.0]\";'), (55, '    let _: Matrix2x3<f32> = serde_json::from_str(&mat_str).unwrap();')], 'deleted': [(4, '    DMatrix, Isometry2, Isometry3, IsometryMatrix2, IsometryMatrix3, Matrix3x4, Point2, Point3,'), (5, '    Quaternion, Rotation2, Rotation3, Similarity2, Similarity3, SimilarityMatrix2,')]}",
    "num_lines_added": "22",
    "num_lines_deleted": "2",
    "nloc": "82"
  },
  {
    "file_change_id": "265426648823631",
    "hash": "55dd22f447492e272b75230c3d8108faa10c6fc",
    "old_path": "src/pcap.rs",
    "new_path": "src/pcap.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -19,7 +19,7 @@ pub struct Input<R: Read> {\n     iter: Box<dyn PcapReaderIterator<R>>,\n }\n \n-unsafe impl<R: Read> std::marker::Send for Input<R> {}\n+unsafe impl<R: Read + Send> Send for Input<R> {}\n \n impl<R: Read + 'static> Input<R> {\n     pub fn with_read(\n",
    "diff_parsed": "{'added': [(22, 'unsafe impl<R: Read + Send> Send for Input<R> {}')], 'deleted': [(22, 'unsafe impl<R: Read> std::marker::Send for Input<R> {}')]}",
    "num_lines_added": "1",
    "num_lines_deleted": "1",
    "nloc": "152"
  },
  {
    "file_change_id": "245086102622707",
    "hash": "5f8e17b1c144e49d244e4e15b985ffa498c4ede",
    "old_path": "src/ffi/generated.rs",
    "new_path": "src/ffi/generated.rs",
    "change_type": "ModificationType.MODIFY",
    "diff": "@@ -2,7 +2,7 @@\n \n /// ABI-compatible struct for [`ArrowSchema`](https://arrow.apache.org/docs/format/CDataInterface.html#structure-definitions)\n #[repr(C)]\n-#[derive(Debug, Clone)]\n+#[derive(Debug)]\n pub struct ArrowSchema {\n     pub(super) format: *const ::std::os::raw::c_char,\n     pub(super) name: *const ::std::os::raw::c_char,\n@@ -17,7 +17,7 @@ pub struct ArrowSchema {\n \n /// ABI-compatible struct for [`ArrowArray`](https://arrow.apache.org/docs/format/CDataInterface.html#structure-definitions)\n #[repr(C)]\n-#[derive(Debug, Clone)]\n+#[derive(Debug)]\n pub struct ArrowArray {\n     pub(super) length: i64,\n     pub(super) null_count: i64,\n@@ -33,7 +33,7 @@ pub struct ArrowArray {\n \n /// ABI-compatible struct for [`ArrowArrayStream`](https://arrow.apache.org/docs/format/CStreamInterface.html).\n #[repr(C)]\n-#[derive(Debug, Clone)]\n+#[derive(Debug)]\n pub struct ArrowArrayStream {\n     pub(super) get_schema: ::std::option::Option<\n         unsafe extern \"C\" fn(\n",
    "diff_parsed": "{'added': [(5, '#[derive(Debug)]'), (20, '#[derive(Debug)]'), (36, '#[derive(Debug)]')], 'deleted': [(5, '#[derive(Debug, Clone)]'), (20, '#[derive(Debug, Clone)]'), (36, '#[derive(Debug, Clone)]')]}",
    "num_lines_added": "3",
    "num_lines_deleted": "3",
    "nloc": "48"
  }
]
