id,package,repo_url,sfp_id,modified,published,vul_version,summary,details,severity,references
GHSA-x446-3xhq-5xfp,Simple-Wayland-HotKey-Daemon,https://github.com/waycrate/swhkd,['Information Leak'],2022-04-26 13:03:51+00:00,2022-04-15T00:00:40Z,"[('0', '1.2.0')]","Exposure of Resource to Wrong Sphere in Simple-Wayland-HotKey-Daemon
","SWHKD 1.1.5 allows arbitrary file-existence tests via the -c option.
",Low,"['https://nvd.nist.gov/vuln/detail/CVE-2022-27814', 'https://github.com/waycrate/swhkd', 'https://www.openwall.com/lists/oss-security/2022/04/14/1', 'https://github.com/waycrate/swhkd/releases', 'https://github.com/waycrate/swhkd/releases/tag/1.2.0']"
GHSA-h6xw-mghq-7523,Simple-Wayland-HotKey-Daemon,https://github.com/waycrate/swhkd,['Resource Management'],2022-04-15 16:14:51+00:00,2022-04-08T00:00:24Z,"[('0', '1.1.7')]","Unsafe parsing in SWHKD
","SWHKD 1.1.5 allows unsafe parsing via the -c option. An information leak might occur but there is a simple denial of service (memory exhaustion) upon an attempt to parse a large or infinite file (such as a block or character device).
",Medium,"['https://nvd.nist.gov/vuln/detail/CVE-2022-27819', 'https://github.com/waycrate/swhkd', 'https://github.com/waycrate/swhkd/commit/b4e6dc76f4845ab03104187a42ac6d1bbc1e0021', 'https://github.com/waycrate/swhkd/releases/tag/1.1.7', 'https://github.com/waycrate/swhkd/releases', 'http://www.openwall.com/lists/oss-security/2022/04/14/1']"
GHSA-h5wh-7h2j-h999,Simple-Wayland-HotKey-Daemon,https://github.com/waycrate/swhkd,['Information Leak'],2022-04-26 13:04:22+00:00,2022-04-15T00:00:40Z,"[('0', None)]","Exposure of Resource to Wrong Sphere in Simple-Wayland-HotKey-Daemon
","SWHKD 1.1.5 consumes the keyboard events of unintended users. This could potentially cause an information leak, but is usually a denial of functionality.
",Medium,"['https://www.openwall.com/lists/oss-security/2022/04/14/1', 'https://github.com/waycrate/swhkd/releases', 'https://github.com/waycrate/swhkd', 'https://nvd.nist.gov/vuln/detail/CVE-2022-27817']"
GHSA-p4jg-pccf-h82c,Simple-Wayland-HotKey-Daemon,https://github.com/waycrate/swhkd,['Information Leak'],2022-04-06 23:57:05+00:00,2022-03-31T00:00:24Z,"[('0', '1.2.0')]","Insecure Temporary File in SWHKD
","SWHKD is a display protocol-independent hotkey daemon made in Rust. In SWHKD versions 1.1.5 and prior, SWHKD uses the /tmp/swhkd.pid pathname. As /tmp is accessible to all users, there can be an information leak or denial of service. No known workarounds exist. A patch is available on the `1.1.0` branch of the repository.
",Critical,"['https://github.com/waycrate/swhkd/commit/e661a4940df78fbb7b52c622ac4ae6a3a7f7d8aa', 'https://nvd.nist.gov/vuln/detail/CVE-2022-27815', 'https://github.com/waycrate/swhkd', 'https://github.com/waycrate/swhkd/releases', 'https://github.com/waycrate/swhkd/releases/tag/1.2.0', 'http://www.openwall.com/lists/oss-security/2022/04/14/1']"
GHSA-8m49-2xj8-67v9,Simple-Wayland-HotKey-Daemon,https://github.com/waycrate/swhkd,['Path Resolution'],2022-04-28 18:02:03+00:00,2022-03-31T00:00:24Z,"[('0', '1.2.0')]","Data Loss/Denial of Service in SWHKD
","SWHKD 1.1.5 unsafely uses the /tmp/swhks.pid pathname. There can be data loss or a denial of service. A patch is available on the `1.1.0` branch of the repository.
",High,"['https://nvd.nist.gov/vuln/detail/CVE-2022-27816', 'https://github.com/waycrate/swhkd/commit/0b620a09605afb815c6d8d8953bbb7a10a8c0575', 'https://github.com/waycrate/swhkd', 'https://github.com/waycrate/swhkd/releases/tag/1.2.0', 'http://www.openwall.com/lists/oss-security/2022/04/14/1']"
GHSA-r3r5-jhw6-4634,Simple-Wayland-HotKey-Daemon,https://github.com/waycrate/swhkd,['Information Leak'],2022-04-19 18:16:59+00:00,2022-04-08T00:00:24Z,"[('0', '1.1.7')]","Insecure temporary file usage in SWHKD
","SWHKD 1.1.5 unsafely uses the /tmp/swhkd.sock pathname. There can be an information leak or denial of service.
",Critical,"['https://github.com/waycrate/swhkd/commit/f70b99dd575fab79d8a942111a6980431f006818', 'https://github.com/waycrate/swhkd', 'https://github.com/waycrate/swhkd/releases/tag/1.1.7', 'https://github.com/waycrate/swhkd/releases', 'https://nvd.nist.gov/vuln/detail/CVE-2022-27818', 'http://www.openwall.com/lists/oss-security/2022/04/14/1']"
GHSA-wqxc-qrq4-w5v4,abi_stable,https://github.com/rodrimati1992/abi_stable_crates/,"['Resource Management', 'Memory Management', 'Tainted Input']",2021-07-26 17:18:54+00:00,2021-08-25T21:01:33Z,"[('0', '0.9.1'), ('0.0.0-0', '0.9.1')]","Update unsound DrainFilter and RString::retain
Update unsound DrainFilter and RString::retain
Update unsound DrainFilter and RString::retain
","Affected versions of this crate contained code from the Rust standard library that contained soundness bugs rust-lang/rust#60977 (double drop) & rust-lang/rust#78498 (create invalid utf-8 string).

The flaw was corrected in v0.9.1 by making a similar fix to the one made in the Rust standard library.
An issue was discovered in the abi_stable crate before 0.9.1 for Rust. DrainFilter lacks soundness because of a double drop.
An issue was discovered in the abi_stable crate before 0.9.1 for Rust. A retain call can create an invalid UTF-8 string, violating soundness.
",High,"['https://github.com/rodrimati1992/abi_stable_crates/issues/44', 'https://rustsec.org/advisories/RUSTSEC-2020-0105.html', 'https://crates.io/crates/abi_stable', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36212', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36213']"
RUSTSEC-2021-0120,abomonation,https://github.com/TimelyDataflow/abomonation.git,['Information Leak'],2021-10-17 21:33:02+00:00,2021-10-17T12:00:00Z,"[('0.0.0-0', None), ('0', None)]","Exposure of Resource to Wrong Sphere in abomonation
abomonation transmutes &T to and from &[u8] without sufficient constraints
","An issue was discovered in the abomonation crate through 2021-10-17 for Rust. Because transmute operations are insufficiently constrained, there can be an information leak or ASLR bypass.
This transmute is at the core of the abomonation crates. It's so easy to use it to violate alignment requirements that no test in the crate's test suite passes under miri.
The use of this transmute in serialization/deserialization also incorrectly assumes that the layout of a repr(Rust) type is stable.
This transmute can also disclose both the contents of padding bytes which may be an information leak and the contents of pointers, which may be used to defeat ASLR.
",High,"['https://github.com/TimelyDataflow/abomonation/issues/23', 'https://crates.io/crates/abomonation', 'https://github.com/TimelyDataflow/abomonation', 'https://nvd.nist.gov/vuln/detail/CVE-2021-45708', 'https://rustsec.org/advisories/RUSTSEC-2021-0120.html', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/abomonation/RUSTSEC-2021-0120.md']"
GHSA-r626-fc64-3q28,abox,https://github.com/SonicFrog/abox,"['Memory Access', 'Synchronization', 'Memory Management']",2021-08-24 19:15:13+00:00,2021-08-25T20:59:06Z,"[('0.0.0-0', '0.4.1'), ('0', '0.4.1')]","AtomicBox<T> implements Send/Sync for any `T: Sized`
Data race in abox
","Affected versions of this crate implements `Send`/`Sync` for `AtomicBox<T>` without requiring `T: Send`/`T: Sync`. This allows to create data races to `T: !Sync` and send `T: !Send` to another thread.

Such behavior breaks the compile-time thread safety guarantees of Rust, and allows users to incur undefined behavior using safe Rust (e.g. memory corruption from data race).

The flaw was corrected in commit 34c2b9e by adding trait bound `T: Send` to `Send` impl for `AtomicBox<T>` and trait bound `T: Sync` to `Sync` impl for `AtomicBox<T>`.
An issue was discovered in the abox crate before 0.4.1 for Rust. 

Affected versions of this crate implements `Send`/`Sync` for `AtomicBox<T>` without requiring `T: Send`/`T: Sync`. This allows to create data races to `T: !Sync` and send `T: !Send` to another thread.

Such behavior breaks the compile-time thread safety guarantees of Rust, and allows users to incur undefined behavior using safe Rust (e.g. memory corruption from data race).

The flaw was corrected in commit 34c2b9e by adding trait bound `T: Send` to `Send` impl for `AtomicBox<T>` and trait bound `T: Sync` to `Sync` impl for `AtomicBox<T>`.
",High,"['https://rustsec.org/advisories/RUSTSEC-2020-0121.html', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36441', 'https://github.com/SonicFrog/abox/issues/1', 'https://crates.io/crates/abox', 'https://github.com/SonicFrog/abox/pull/2', 'https://github.com/SonicFrog/abox/commit/34c2b9e', 'https://github.com/SonicFrog/abox']"
GHSA-p4cr-64x4-f92f,acc_reader,https://github.com/netvl/acc_reader,"['Memory Access', 'Exception Management']",2022-01-07 16:21:25+00:00,2022-01-06T22:17:23Z,"[('0.0.0-0', None), ('0', None)]","Use of Uninitialized Resource in acc_reader.
`Read` on uninitialized buffer in `fill_buf()` and `read_up_to()`
Use of Uninitialized Resource in acc_reader.
","An issue was discovered in the acc_reader crate through 2020-12-27 for Rust. read_up_to may read from uninitialized memory locations.
Affected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation.

Arbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.
Reading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.
An issue was discovered in the acc_reader crate through 2020-12-27 for Rust. fill_buf may read from uninitialized memory locations.
",Critical,"['https://github.com/netvl/acc_reader', 'https://crates.io/crates/acc_reader', 'https://rustsec.org/advisories/RUSTSEC-2020-0155.html', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36514', 'https://github.com/netvl/acc_reader/issues/1', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36513', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/acc_reader/RUSTSEC-2020-0155.md']"
RUSTSEC-2020-0049,actix-codec,https://github.com/actix/actix-net,"['Memory Access', 'Memory Management']",2021-10-19 22:14:35+00:00,2020-01-30T12:00:00Z,"[('0', '0.3.0'), ('0.0.0-0', '0.3.0-beta.1')]","Use-after-free in actix-codec
Use-after-free in Framed due to lack of pinning
","An issue was discovered in the actix-codec crate before 0.3.0-beta.1 for Rust. There is a use-after-free in Framed.
Affected versions of this crate did not require the buffer wrapped in `Framed` to be pinned,
but treated it as if it had a fixed location in memory. This may result in a use-after-free.
 
The flaw was corrected by making the affected functions accept `Pin<&mut Self>` instead of `&mut self`.
",Critical,"['https://github.com/actix/actix-net', 'https://crates.io/crates/actix-codec', 'https://rustsec.org/advisories/RUSTSEC-2020-0049.html', 'https://github.com/actix/actix-net/issues/91', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35902']"
RUSTSEC-2021-0081,actix-http,https://github.com/actix/actix-web.git,['Tainted Input'],2021-10-19 22:14:35+00:00,2021-06-16T12:00:00Z,"[('0', '2.2.1'), ('0.0.0-0', '2.2.1')]","HTTP Request Smuggling in actix-http
Potential request smuggling capabilities due to lack of input validation
","Affected versions of this crate did not properly detect invalid requests that could allow HTTP/1 request smuggling (HRS) attacks when running alongside a vulnerable front-end proxy server. This can result in leaked internal and/or user data, including credentials, when the front-end proxy is also vulnerable.

Popular front-end proxies and load balancers already mitigate HRS attacks so it is recommended that they are also kept up to date; check your specific set up. You should upgrade even if the front-end proxy receives exclusively HTTP/2 traffic and connects to the back-end using HTTP/1; several downgrade attacks are known that can also expose HRS vulnerabilities.
Affected versions of this crate did not properly detect invalid requests that could allow HTTP/1 request smuggling (HRS) attacks when running alongside a vulnerable front-end proxy server. This can result in leaked internal and/or user data, including credentials, when the front-end proxy is also vulnerable.

Popular front-end proxies and load balancers already mitigate HRS attacks so it is recommended that they are also kept up to date; check your specific set up. You should upgrade even if the front-end proxy receives exclusively HTTP/2 traffic and connects to the back-end using HTTP/1; several downgrade attacks are known that can also expose HRS vulnerabilities.
",High,"['https://rustsec.org/advisories/RUSTSEC-2021-0081.html', 'https://nvd.nist.gov/vuln/detail/CVE-2021-38512', 'https://github.com/actix/actix-web/pull/2363', 'https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/67URRW4K47SR6LNQB4YALPLGGQMQK7HO/', 'https://github.com/actix/actix-web/commit/e965d8298f421e9c89fe98b1300b8361e948c324', 'https://crates.io/crates/actix-http', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/actix-http/RUSTSEC-2021-0081.md', 'https://github.com/actix/actix-web']"
RUSTSEC-2020-0048,actix-http,https://github.com/actix/actix-web.git,"['Memory Access', 'Memory Management']",2021-10-19 22:14:35+00:00,2020-01-24T12:00:00Z,"[('0', '2.0.0'), ('0.0.0-0', '2.0.0-alpha.1')]","Use-after-free in actix-http
Use-after-free in BodyStream due to lack of pinning
","An issue was discovered in the actix-http crate before 2.0.0-alpha.1 for Rust. There is a use-after-free in BodyStream.
Affected versions of this crate did not require the buffer wrapped in `BodyStream` to be pinned,
but treated it as if it had a fixed location in memory. This may result in a use-after-free.
 
The flaw was corrected by making the trait `MessageBody` require `Unpin`
and making `poll_next()` function accept `Pin<&mut Self>` instead of `&mut self`.
",High,"['https://github.com/actix/actix-web/issues/1321', 'https://rustsec.org/advisories/RUSTSEC-2020-0048.html', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35901', 'https://crates.io/crates/actix-http', 'https://github.com/actix/actix-web']"
GHSA-whc7-5p35-4ww2,actix-service,https://github.com/actix/actix-net,"['Memory Access', 'Memory Management']",2021-08-19 20:54:21+00:00,2021-08-25T20:49:06Z,"[('0.0.0-0', '1.0.6'), ('0', '1.0.6')]","bespoke Cell implementation allows obtaining several mutable references to the same data
Use after free in actix-service
","The custom implementation of a Cell primitive in the affected versions of this crate
does not keep track of mutable references to the underlying data.

This allows obtaining several mutable references to the same object
which may result in arbitrary memory corruption, most likely use-after-free.

The flaw was corrected by switching from a bespoke `Cell<T>` implementation to `Rc<RefCell<T>>`.
An issue was discovered in the actix-service crate before 1.0.6 for Rust. The Cell implementation allows obtaining more than one mutable reference to the same data.
",Medium,"['https://github.com/actix/actix-net', 'https://rustsec.org/advisories/RUSTSEC-2020-0046.html', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35899', 'https://crates.io/crates/actix-service', 'https://github.com/actix/actix-net/pull/158']"
GHSA-hhw2-pqhf-vmx2,actix-utils,https://github.com/actix/actix-net,"['Memory Access', 'Memory Management']",2021-08-19 20:53:53+00:00,2021-08-25T20:49:09Z,"[('0', '2.0.0'), ('0.0.0-0', '2.0.0')]","bespoke Cell implementation allows obtaining several mutable references to the same data
Use after free in actix-utils
","The custom implementation of a Cell primitive in the affected versions of this crate
does not keep track of mutable references to the underlying data.

This allows obtaining several mutable references to the same object
which may result in arbitrary memory corruption, most likely use-after-free.

The flaw was corrected by switching from a bespoke `Cell<T>` implementation to `Rc<RefCell<T>>`.
An issue was discovered in the actix-utils crate before 2.0.0 for Rust. The Cell implementation allows obtaining more than one mutable reference to the same data.
",Critical,"['https://github.com/actix/actix-net', 'https://rustsec.org/advisories/RUSTSEC-2020-0045.html', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35898', 'https://crates.io/crates/actix-utils', 'https://github.com/actix/actix-net/issues/160']"
RUSTSEC-2018-0019,actix-web,https://github.com/actix/actix-web.git,"['Memory Access', 'Memory Management']",2021-08-22 01:18:11+00:00,2018-06-08T12:00:00Z,"[('0.0.0-0', '0.7.15'), ('0', '0.7.15')]","Out-of-bounds Write in actix-web
Out-of-bounds Write in actix-web
Out-of-bounds Write in actix-web
Multiple memory safety issues
","An issue was discovered in the actix-web crate before 0.7.15 for Rust. It can add the Send marker trait to an object that cannot be sent between threads safely, leading to memory corruption.
An issue was discovered in the actix-web crate before 0.7.15 for Rust. It can unsoundly extend the lifetime of a string, leading to memory corruption.
An issue was discovered in the actix-web crate before 0.7.15 for Rust. It can unsoundly coerce an immutable reference into a mutable reference, leading to memory corruption.
Affected versions contain multiple memory safety issues, such as:

 - Unsoundly coercing immutable references to mutable references
 - Unsoundly extending lifetimes of strings
 - Adding the `Send` marker trait to objects that cannot be safely sent between threads

This may result in a variety of memory corruption scenarios, most likely use-after-free.
 
A significant refactoring effort has been conducted to resolve these issues.
",Critical,"['https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/actix-web/RUSTSEC-2018-0019.md', 'https://nvd.nist.gov/vuln/detail/CVE-2018-25025', 'https://nvd.nist.gov/vuln/detail/CVE-2018-25026', 'https://nvd.nist.gov/vuln/detail/CVE-2018-25024', 'https://github.com/actix/actix-web.git', 'https://github.com/actix/actix-web/issues/289', 'https://rustsec.org/advisories/RUSTSEC-2018-0019.html', 'https://crates.io/crates/actix-web']"
GHSA-w65j-g6c7-g3m4,actix-web,https://github.com/actix/actix-web.git,['Synchronization'],2021-08-24 19:13:30+00:00,2021-08-25T20:42:50Z,"[('0', '0.7.15')]","Multiple memory safety issues in actix-web
","Affected versions contain multiple memory safety issues, such as:

 - Unsoundly coercing immutable references to mutable references
 - Unsoundly extending lifetimes of strings
 - Adding the `Send` marker trait to objects that cannot be safely sent between threads

This may result in a variety of memory corruption scenarios, most likely use-after-free.
 
A signficant refactoring effort has been conducted to resolve these issues.

",nan,"['https://github.com/actix/actix-web', 'https://rustsec.org/advisories/RUSTSEC-2018-0019', 'https://github.com/actix/actix-web/issues/289']"
RUSTSEC-2021-0045,adtensor,https://github.com/charles-r-earp/adtensor,"['Exception Management', 'Memory Management']",2021-10-19 22:14:35+00:00,2021-01-11T12:00:00Z,"[('0.0.0-0', None), ('0', None)]","Free of uninitialized memory in adtensor
FromIterator implementation for Vector/Matrix can drop uninitialized memory
","An issue was discovered in the adtensor crate through 0.0.3 for Rust. There is a drop of uninitialized memory via the FromIterator implementation for Vector and Matrix.
The `FromIterator<T>` methods for `Vector` and `Matrix` rely on the type
parameter `N` to allocate space in the iterable.

If the passed in `N` type parameter is larger than the number of items returned
by the iterator, it can lead to uninitialized memory being left in the
`Vector` or `Matrix` type which gets dropped.
",Critical,"['https://github.com/charles-r-earp/adtensor', 'https://nvd.nist.gov/vuln/detail/CVE-2021-29936', 'https://crates.io/crates/adtensor', 'https://rustsec.org/advisories/RUSTSEC-2021-0045.html', 'https://github.com/charles-r-earp/adtensor/issues/4']"
RUSTSEC-2021-0061,aes-ctr,https://github.com/RustCrypto/block-ciphers/tree/master/aes,[],2021-05-04 01:28:43+00:00,2021-04-29T12:00:00Z,"[('0.0.0-0', None)]","`aes-ctr` has been merged into the `aes` crate
","Please use the `aes` crate going forward. The new repository location is at:

<https://github.com/RustCrypto/block-ciphers/tree/master/aes>

The `aes` crate now has an optional `ctr` feature which autodetects SIMD
features on `i686`/`x86-64` targets and uses them if available, or otherwise
falls back to the implementation in the `ctr` crate.

If you would prefer not to have this autodetection performed, use the `aes`
crate directly with the `ctr` crate.
",nan,"['https://crates.io/crates/aes-ctr', 'https://rustsec.org/advisories/RUSTSEC-2021-0061.html', 'https://github.com/RustCrypto/block-ciphers/pull/200']"
RUSTSEC-2021-0060,aes-soft,https://github.com/RustCrypto/block-ciphers/tree/master/aes,[],2021-05-04 01:28:43+00:00,2021-04-29T12:00:00Z,"[('0.0.0-0', None)]","`aes-soft` has been merged into the `aes` crate
","Please use the `aes` crate going forward. The new repository location is at:

<https://github.com/RustCrypto/block-ciphers/tree/master/aes>

AES-NI is now autodetected at runtime on `i686`/`x86-64` platforms.
If AES-NI is not present, the `aes` crate will fallback to a constant-time
portable software implementation.

To force the use of a constant-time portable implementation on these platforms,
even if AES-NI is available, use the new `force-soft` feature of the `aes`
crate to disable autodetection.
",nan,"['https://crates.io/crates/aes-soft', 'https://github.com/RustCrypto/block-ciphers/pull/200', 'https://rustsec.org/advisories/RUSTSEC-2021-0060.html']"
RUSTSEC-2021-0059,aesni,https://github.com/RustCrypto/block-ciphers/tree/master/aes,[],2021-05-04 01:28:43+00:00,2021-04-29T12:00:00Z,"[('0.0.0-0', None)]","`aesni` has been merged into the `aes` crate
","Please use the `aes` crate going forward. The new repository location is at:

<https://github.com/RustCrypto/block-ciphers/tree/master/aes>

AES-NI is now autodetected at runtime on `i686`/`x86-64` platforms.
If AES-NI is not present, the `aes` crate will fallback to a constant-time
portable software implementation.

To prevent this fallback (and have absence of AES-NI result in an illegal
instruction crash instead), continue to pass the same RUSTFLAGS which were
previously required for the `aesni` crate to compile:

```
RUSTFLAGS=-Ctarget-feature=+aes,+ssse3
```
",nan,"['https://rustsec.org/advisories/RUSTSEC-2021-0059.html', 'https://crates.io/crates/aesni', 'https://github.com/RustCrypto/block-ciphers/pull/200']"
GHSA-3227-r97m-8j95,afire,https://github.com/Basicprogrammer10/afire,['Path Resolution'],2022-04-22 20:16:45+00:00,2022-04-22T20:16:45Z,"[('0.2.1', '1.1.0')]","Relative Path Traversal in afire serve_static
","### Impact
This vulnerability effects the built-in afire serve_static extension allowing paths containing `//....` to bypass the previous path sanitation and request files in higher directories that should not be accessible.

### Patches
The issue has been fixed in [afire 1.1.0](https://crates.io/crates/afire/1.1.0).
If you can, just update to the newest version of afire.

### Workarounds
If you can't update afire you can simply disallow paths containing `/..` with the following middleware.
Make sure this is the last middleware added to the server so it runs first, stopping the bad requests.
```rust
use afire::prelude::*;

struct PathTraversalFix;

impl Middleware for PathTraversalFix {
    fn pre(&self, req: Request) -> MiddleRequest {
        if req.path.replace(""\\"", ""/"").contains(""/.."") {
            return MiddleRequest::Send(
                Response::new()
                    .status(400)
                    .text(""Paths containing `..` are not allowed""),
            );
        }

        MiddleRequest::Continue
    }
}
```
```rust
let mut server = Server::new(host, port);
PathTraversalFix.attach(&mut server);
```

### References
You can read about the new changes to afire in 1.1.0 [here](https://connorcode.com/writing/afire/update-3)

### For more information
If you have any questions or comments about this advisory you can email me or message me on discord.
[[https://connorcode.com/contact](https://connorcode.com/contact)]
",nan,"['https://github.com/Basicprogrammer10/afire/security/advisories/GHSA-3227-r97m-8j95', 'https://github.com/Basicprogrammer10/afire', 'https://github.com/Basicprogrammer10/afire/commit/da7904c04f82e1cb43cc42eaf6a1dba072b5c921', 'https://github.com/Basicprogrammer10/afire/releases/tag/v1.1.0']"
RUSTSEC-2020-0033,alg_ds,https://gitlab.com/dvshapkin/alg-ds,['Exception Management'],2021-10-19 22:14:35+00:00,2020-08-25T12:00:00Z,"[('0.0.0-0', None), ('0', None)]","Use of Uninitialized Resource in alg_ds
Matrix::new() drops uninitialized memory
","An issue was discovered in the alg_ds crate through 2020-08-25 for Rust. `Matrix::new()` internally calls `Matrix::fill_with()` which uses `*ptr = value` pattern to initialize the buffer. This pattern assumes that there is an initialized struct at the address and drops it, which results in dropping of uninitialized struct.
`Matrix::new()` internally calls `Matrix::fill_with()` which uses `*ptr = value` pattern to initialize the buffer.
This pattern assumes that there is an initialized struct at the address and drops it, which results in dropping of uninitialized struct.
",Critical,"['https://rustsec.org/advisories/RUSTSEC-2020-0033.html', 'https://crates.io/crates/alg_ds', 'https://gitlab.com/dvshapkin/alg-ds', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36432', 'https://gitlab.com/dvshapkin/alg-ds/-/issues/1']"
RUSTSEC-2021-0053,algorithmica,https://github.com/AbrarNitk/algorithmica,['Memory Management'],2021-11-06 20:37:35+00:00,2021-03-07T12:00:00Z,"[('0.0.0-0', None), ('0', None)]","Double free in algorithmica
'merge_sort::merge()' crashes with double-free for `T: Drop`
","An issue was discovered in the algorithmica crate through 2021-03-07 for Rust. In the affected versions of this crate, `merge_sort::merge()` wildly duplicates and drops ownership of `T` without guarding against double-free. Due to such implementation, simply invoking `merge_sort::merge()` on `Vec<T: Drop>` can cause **double free** bugs.

In the affected versions of this crate, `merge_sort::merge()` wildly duplicates and drops ownership of `T` without guarding against double-free. Due to such implementation,
simply invoking `merge_sort::merge()` on `Vec<T: Drop>` can cause **double free** bugs.
",High,"['https://nvd.nist.gov/vuln/detail/CVE-2021-31996', 'https://rustsec.org/advisories/RUSTSEC-2021-0053.html', 'https://github.com/AbrarNitk/algorithmica/issues/1', 'https://crates.io/crates/algorithmica']"
RUSTSEC-2020-0032,alpm-rs,https://github.com/BahNahNah/rust-arch/tree/master/alpm-rs,['Memory Management'],2021-10-19 22:14:35+00:00,2020-08-20T12:00:00Z,"[('0.0.0-0', None), ('0', None)]","Double free in alpm-rs
StrcCtx deallocates a memory region that it doesn't own
","An issue was discovered in the alpm-rs crate through 2020-08-20 for Rust. StrcCtx performs improper memory deallocation.
`StrcCtx` deallocate a memory region that it doesn't own when `StrcCtx` is created without using `StrcCtx::new`.
This can introduce memory safety issues such as double-free and use-after-free to client programs.
",Critical,"['https://github.com/BahNahNah/rust-arch/tree/master/alpm-rs', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35885', 'https://github.com/pigeonhands/rust-arch/issues/2', 'https://rustsec.org/advisories/RUSTSEC-2020-0032.html', 'https://crates.io/crates/alpm-rs']"
RUSTSEC-2021-0074,ammonia,https://github.com/rust-ammonia/ammonia,['Tainted Input'],2021-11-06 20:37:35+00:00,2021-07-08T12:00:00Z,"[('0.0.0-0', '2.1.3'), ('0', '2.1.3'), ('3.0.0', '3.1.0')]","Cross-site Scripting in ammonia
Incorrect handling of embedded SVG and MathML leads to mutation XSS
","An issue was discovered in the ammonia crate before 3.1.0 for Rust. XSS can occur because the parsing differences for HTML, SVG, and MathML are mishandled, a similar issue to CVE-2020-26870.
Affected versions of this crate did not account for namespace-related parsing
differences between HTML, SVG, and MathML. Even if the `svg` and `math` elements
are not allowed, the underlying HTML parser still treats them differently.
Running cleanup without accounting for these differing namespaces resulted in an ""impossible""
DOM, which appeared ""safe"" when examining the DOM tree, but when serialized and deserialized,
could be exploited to inject abitrary markup.

To exploit this, the application using this library must allow a tag that is parsed as raw text in HTML.
These [elements] are:

* title
* textarea
* xmp
* iframe
* noembed
* noframes
* plaintext
* noscript
* style
* script

Applications that do not explicitly allow any of these tags should not be affected, since none are allowed by default.

[elements]: https://github.com/servo/html5ever/blob/57eb334c0ffccc6f88d563419f0fbeef6ff5741c/html5ever/src/tree_builder/rules.rs
",Medium,"['https://nvd.nist.gov/vuln/detail/CVE-2021-38193', 'https://crates.io/crates/ammonia', 'https://rustsec.org/advisories/RUSTSEC-2021-0074.html', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/ammonia/RUSTSEC-2021-0074.md', 'https://github.com/rust-ammonia/ammonia', 'https://github.com/rust-ammonia/ammonia/pull/142']"
RUSTSEC-2022-0003,ammonia,https://github.com/rust-ammonia/ammonia,['Tainted Input'],2022-01-19 22:35:01+00:00,2022-01-19T12:00:00Z,"[('3.0.0', '3.1.3')]","Space bug in `clean_text`
","An incorrect mapping from HTML specification to ASCII codes was used.
Because HTML treats the Form Feed as whitespace, code like this has an injection bug:

    let html = format!(""<div title={}>"", clean_text(user_supplied_string));

Applications are not affected if they quote their attributes, or if they don't use `clean_text` at all.
",nan,"['https://crates.io/crates/ammonia', 'https://rustsec.org/advisories/RUSTSEC-2022-0003.html', 'https://github.com/rust-ammonia/ammonia/pull/147']"
RUSTSEC-2019-0001,ammonia,https://github.com/rust-ammonia/ammonia,['Resource Management'],2021-10-19 22:14:35+00:00,2019-04-27T12:00:00Z,"[('0.0.0-0', '2.1.0'), ('0', '2.1.0')]","Uncontrolled recursion in ammonia
Uncontrolled recursion leads to abort in HTML serialization
","An issue was discovered in the ammonia crate before 2.1.0 for Rust. There is uncontrolled recursion during HTML DOM tree serialization.
Affected versions of this crate did use recursion for serialization of HTML
DOM trees.

This allows an attacker to cause abort due to stack overflow by providing
a pathologically nested input.

The flaw was corrected by serializing the DOM tree iteratively instead.
",High,"['https://rustsec.org/advisories/RUSTSEC-2019-0001.html', 'https://crates.io/crates/ammonia', 'https://github.com/rust-ammonia/ammonia', 'https://nvd.nist.gov/vuln/detail/CVE-2019-15542', 'https://github.com/rust-ammonia/ammonia/blob/master/CHANGELOG.md#210']"
RUSTSEC-2021-0065,anymap,https://github.com/chris-morgan/anymap,['Risky Values'],2021-11-06 20:37:35+00:00,2021-05-07T12:00:00Z,"[('0.0.0-0', None), ('0', None)]","Incorrect cast in anymap
anymap is unmaintained.
","An issue was discovered in the anymap crate through 0.12.1 for Rust. It violates soundness via conversion of a *u8 to a *u64.
The `anymap` crate does not appear to be maintained, and the most recent
published version 0.12.1 includes a soundness bug. This has been
[fixed](https://github.com/chris-morgan/anymap/pull/32) a few years ago, but
was never released.
",Critical,"['https://crates.io/crates/anymap', 'https://nvd.nist.gov/vuln/detail/CVE-2021-38187', 'https://github.com/chris-morgan/anymap', 'https://github.com/chris-morgan/anymap/issues/37', 'https://rustsec.org/advisories/RUSTSEC-2021-0065.html']"
RUSTSEC-2020-0099,aovec,https://github.com/krl/aovec,"['Memory Access', 'Synchronization', 'Memory Management']",2021-10-19 22:14:35+00:00,2020-12-10T12:00:00Z,"[('0.0.0-0', None), ('0', None)]","Data races in aovec
Aovec<T> lacks bound on its Send and Sync traits allowing data races
","An issue was discovered in the aovec crate through 2020-12-10 for Rust. Because Aovec<T> does not have bounds on its Send trait or Sync trait, a data race and memory corruption can occur.
`aovec::Aovec<T>` is a vector type that implements `Send` and `Sync` for all
types `T`.

This allows non-Send types such as `Rc` and non-Sync types such as `Cell` to
be used across thread boundaries which can trigger undefined behavior and
memory corruption.
",High,"['https://nvd.nist.gov/vuln/detail/CVE-2020-36207', 'https://crates.io/crates/aovec', 'https://github.com/krl/aovec', 'https://rustsec.org/advisories/RUSTSEC-2020-0099.html']"
GHSA-fvhr-7j8m-3cvc,appendix,https://github.com/krl/appendix,"['Synchronization', 'Memory Management']",2021-08-24 19:08:25+00:00,2021-08-25T20:57:02Z,"[('0.0.0-0', None), ('0', None)]","Data race and memory safety issue in `Index`
Data races in appendix
","The `appendix` crate implements a key-value mapping data structure called
`Index<K, V>` that is stored on disk. The crate allows for any type to inhabit
the generic `K` and `V` type parameters and implements Send and Sync for them
unconditionally.

Using a type that is not marked as `Send` or `Sync` with `Index` can allow it
to be used across multiple threads leading to data races. Additionally using
reference types for the keys or values will lead to the segmentation faults
in the crate's code.
The `appendix` crate implements a key-value mapping data structure called
`Index<K, V>` that is stored on disk. The crate allows for any type to inhabit
the generic `K` and `V` type parameters and implements Send and Sync for them
unconditionally.

Using a type that is not marked as `Send` or `Sync` with `Index` can allow it
to be used across multiple threads leading to data races. Additionally using
reference types for the keys or values will lead to the segmentation faults
in the crate's code.
",Medium,"['https://github.com/krl/appendix/issues/6', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36469', 'https://rustsec.org/advisories/RUSTSEC-2020-0149.html', 'https://crates.io/crates/appendix', 'https://github.com/krl/appendix']"
RUSTSEC-2020-0091,arc-swap,https://github.com/vorner/arc-swap,['Memory Management'],2021-10-19 22:14:35+00:00,2020-12-10T12:00:00Z,"[('0.4.2', '0.4.8')]","Dangling reference in `access::Map` with Constant
","Using the `arc_swap::access::Map` with the `Constant` test helper (or with
user-provided implementation of the `Access` trait) could sometimes lead to the
map returning dangling references.

Replaced by implementation without `unsafe`, at the cost of added `Clone` bound
on the closure and small penalty on performance.
",High,"['https://github.com/vorner/arc-swap/issues/45', 'https://crates.io/crates/arc-swap', 'https://rustsec.org/advisories/RUSTSEC-2020-0091.html']"
RUSTSEC-2021-0040,arenavec,https://github.com/ibabushkin/arenavec,"['Memory Access', 'Memory Management']",2021-10-19 22:14:35+00:00,2021-01-12T12:00:00Z,"[('0.0.0-0', None), ('0', None)]","Out of bounds write in arenavec
Double free in arenavec
panic safety: double drop or uninitialized drop of T upon panic
","An issue was discovered in the arenavec crate through 0.1.1. A drop of uninitialized memory can sometimes occur upon a panic in T::default().
An issue was discovered in the arenavec crate through 2021-01-12 for Rust. A double drop can sometimes occur upon a panic in T::drop().
Affected versions of this crate did not guard against potential panics that may happen from user-provided functions `T::default()` and `T::drop()`.

Panic within `T::default()` leads to dropping uninitialized `T`, when it is invoked from `common::Slice::<T, H>::new()`.
Panic within `T::drop()` leads to double drop of `T`, when it is invoked either from `common::SliceVec::<T, H>::resize_with()` or `common::SliceVec::<T, H>::resize()`

Either case causes memory corruption in the heap memory.
",High,"['https://github.com/ibabushkin/arenavec/issues/1', 'https://crates.io/crates/arenavec', 'https://rustsec.org/advisories/RUSTSEC-2021-0040.html', 'https://github.com/ibabushkin/arenavec', 'https://nvd.nist.gov/vuln/detail/CVE-2021-29931', 'https://nvd.nist.gov/vuln/detail/CVE-2021-29930']"
GHSA-qj3v-q2vj-4c8h,ark-r1cs-std,https://github.com/arkworks-rs/r1cs-std,"['Cryptography', 'Other']",2021-08-18 21:27:27+00:00,2021-08-25T20:55:58Z,"[('0.2.0', '0.3.1'), ('0.0.0-0', '0.3.1')]","Flaw in `FieldVar::mul_by_inverse` allows unsound R1CS constraint systems
Calculation error in ark-r1cs-std
","Versions `0.2.0` to `0.3.0` of ark-r1cs-std did not enforce any constraints in the `FieldVar::mul_by_inverse` method, allowing a malicious prover to produce an unsound proof that passes all verifier checks.
This method was used primarily in scalar multiplication for [`short_weierstrass::ProjectiveVar`](https://docs.rs/ark-r1cs-std/0.3.0/ark_r1cs_std/groups/curves/short_weierstrass/struct.ProjectiveVar.html).

This bug was fixed in commit `47ddbaa`, and was released as part of version `0.3.1` on `crates.io`.
An issue was discovered in the ark-r1cs-std crate before 0.3.1 for Rust. It does not enforce any constraints in the FieldVar::mul_by_inverse method. Thus, a prover can produce a proof that is unsound but is nonetheless verified.
",nan,"['https://github.com/arkworks-rs/r1cs-std', 'https://nvd.nist.gov/vuln/detail/CVE-2021-38194', 'https://rustsec.org/advisories/RUSTSEC-2021-0075.html', 'https://crates.io/crates/ark-r1cs-std', 'https://github.com/arkworks-rs/r1cs-std/pull/70', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/ark-r1cs-std/RUSTSEC-2021-0075.md']"
RUSTSEC-2020-0034,arr,https://github.com/sjep/array.git,"['Memory Access', 'Exception Management', 'Synchronization', 'Memory Management']",2021-01-31 04:02:50+00:00,2020-08-25T12:00:00Z,"[('0.0.0-0', None), ('0', None)]","Uninitialized memory drop in arr
Buffer overflow in arr
Data races in arr
Multiple security issues including data race, buffer overflow, and uninitialized memory drop
","An issue was discovered in the arr crate through 2020-08-25 for Rust. Uninitialized memory is dropped by Array::new_from_template.
An issue was discovered in the arr crate through 2020-08-25 for Rust. There is a buffer overflow in Index and IndexMut.
An issue was discovered in the arr crate through 2020-08-25 for Rust. An attacker can smuggle non-Sync/Send types across a thread boundary to cause a data race.
`arr` crate contains multiple security issues. Specifically,

1. It incorrectly implements Sync/Send bounds, which allows to smuggle non-Sync/Send types across the thread boundary.
2. `Index` and `IndexMut` implementation does not check the array bound.
3. `Array::new_from_template()` drops uninitialized memory.
",Critical,"['https://crates.io/crates/arr', 'https://github.com/sjep/array/issues/1', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35887', 'https://github.com/sjep/array', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35888', 'https://rustsec.org/advisories/RUSTSEC-2020-0034.html', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35886']"
RUSTSEC-2022-0017,array-macro,https://gitlab.com/KonradBorowski/array-macro,"['Memory Access', 'Other', 'Memory Management']",2022-04-27 19:05:18+00:00,2022-04-27T12:00:00Z,"[('2.1.0', '2.1.2')]","`array!` macro is unsound when its length is impure constant
","Affected versions of this crate did substitute the array length provided by an user at compile-time multiple times.

When an impure constant expression is passed as an array length (such as a result of an impure procedural macro), this can result in the initialization of an array with uninitialized types, which in turn can allow an attacker to execute arbitrary code.

The flaw was corrected in commit [d5b63f72](https://gitlab.com/KonradBorowski/array-macro/-/commit/d5b63f72090f3809c21ac28f9cfd84f12559bf7d) by making sure that array length is substituted just once.
",nan,"['https://crates.io/crates/array-macro', 'https://rustsec.org/advisories/RUSTSEC-2022-0017.html', 'https://gitlab.com/KonradBorowski/array-macro/-/issues/5']"
RUSTSEC-2020-0161,array-macro,https://gitlab.com/KonradBorowski/array-macro,['Memory Management'],2022-01-21 17:52:31+00:00,2020-05-07T12:00:00Z,"[('0.1.2', '1.0.5')]","`array!` macro is unsound in presence of traits that implement methods it calls internally
","Affected versions of this crate called some methods using auto-ref. The affected code looked like this.

```rust
let mut arr = $crate::__core::mem::MaybeUninit::uninit();
let mut vec = $crate::__ArrayVec::<T>::new(arr.as_mut_ptr() as *mut T);
```

In this case, the problem is that `as_mut_ptr` is a method of `&mut MaybeUninit`, not `MaybeUninit`. This made it possible for traits to hijack the method calls in order to cause unsoundness.

```rust
trait AsMutPtr<T> {
    fn as_mut_ptr(&self) -> *mut T;
}
impl<T> AsMutPtr<T> for std::mem::MaybeUninit<T> {
    fn as_mut_ptr(&self) -> *mut T {
        std::ptr::null_mut()
    }
}
array![0; 1];
```

The flaw was corrected by explicitly referencing variables in macro body in order to avoid auto-ref.
",nan,"['https://rustsec.org/advisories/RUSTSEC-2020-0161.html', 'https://gitlab.com/KonradBorowski/array-macro/-/commit/01940637dd8f3bfeeee3faf9639fa9ae52f19f4d', 'https://crates.io/crates/array-macro']"
GHSA-75cq-g75g-rxff,array-queue,https://github.com/raviqqe/array-queue,['Memory Access'],2021-08-18 22:36:31+00:00,2021-08-25T21:00:43Z,"[('0.3.0', None)]","array_queue pop_back() may cause a use-after-free
use-after-free vulnerability in Rust array-queue
","array_queue implements a circular queue that wraps around an array. However, it
fails to properly index into the array in the `pop_back` function allowing the
reading of previously dropped or uninitialized memory.
An issue was discovered in the array-queue crate through 2020-09-26 for Rust. A pop_back() call may lead to a use-after-free.
",Medium,"['https://github.com/raviqqe/array-queue/issues/2', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35900', 'https://rustsec.org/advisories/RUSTSEC-2020-0047.html', 'https://github.com/raviqqe/array-queue', 'https://crates.io/crates/array-queue']"
GHSA-6wp2-fw3v-mfmc,array-tools,https://github.com/L117/array-tools,"['Memory Management', 'Exception Management']",2021-08-24 18:54:26+00:00,2021-08-25T20:57:19Z,"[('0.0.0-0', '0.3.2'), ('0', '0.3.2')]","`FixedCapacityDequeLike::clone()` can cause dropping uninitialized memory
Memory corruption in array-tools
","Affected versions of this crate don't guard against panics, so that partially uninitialized buffer is dropped when user-provided `T::clone()` panics in `FixedCapacityDequeLike<T, A>::clone()`. This causes memory corruption.
An issue was discovered in the array-tools crate before 0.3.2 for Rust. Affected versions of this crate don't guard against panics, so that partially uninitialized buffer is dropped when user-provided `T::clone()` panics in `FixedCapacityDequeLike<T, A>::clone()`. This causes memory corruption.

",Critical,"['https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/array-tools/RUSTSEC-2020-0132.md', 'https://github.com/L117/array-tools', 'https://rustsec.org/advisories/RUSTSEC-2020-0132.html', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36452', 'https://github.com/L117/array-tools/issues/2', 'https://crates.io/crates/array-tools']"
GHSA-69fv-gw6g-8ccg,arrayfire,https://github.com/arrayfire/arrayfire-rust,"['Memory Access', 'Memory Management']",2021-08-19 21:24:28+00:00,2021-08-25T20:43:26Z,"[('0', '3.6.0'), ('3.5.1-0', '3.6.0')]","Enum repr causing potential memory corruption
Potential memory corruption in arrayfire
","The attribute repr() added to enums to be compatible with C-FFI caused
memory corruption on MSVC toolchain.

arrayfire crates <= version 3.5.0 do not have this issue when used with
Rust versions 1.27 or earlier. The issue only started to appear since
Rust version 1.28.

The issue seems to be interlinked with which version of Rust is being used.

The issue was fixed in crate 3.6.0.
An issue was discovered in the arrayfire crate before 3.6.0 for Rust. Addition of the repr() attribute to an enum is mishandled, leading to memory corruption.
",Critical,"['https://github.com/arrayfire/arrayfire-rust', 'https://crates.io/crates/arrayfire', 'https://github.com/arrayfire/arrayfire-rust/pull/177', 'https://nvd.nist.gov/vuln/detail/CVE-2018-20998', 'https://rustsec.org/advisories/RUSTSEC-2018-0011.html']"
RUSTSEC-2021-0117,arrow,https://github.com/apache/arrow-rs,['Memory Access'],2021-12-22 21:15:54+00:00,2021-09-14T12:00:00Z,"[('0.0.0-0', '6.4.0')]","`DecimalArray` does not perform bound checks on accessing values and offsets
","`DecimalArray` performs insufficient bounds checks,
which allows out-of-bounds reads in safe code
if the lenght of the backing buffer is not a multiple of 16.
",nan,"['https://github.com/apache/arrow-rs/issues/775', 'https://rustsec.org/advisories/RUSTSEC-2021-0117.html', 'https://crates.io/crates/arrow']"
RUSTSEC-2021-0116,arrow,https://github.com/apache/arrow-rs,['Memory Access'],2021-12-22 21:15:54+00:00,2021-09-14T12:00:00Z,"[('0.0.0-0', '6.4.0')]","`BinaryArray` does not perform bound checks on reading values and offsets
","`BinaryArray` performs insufficient validation on creation, which allows out-of-bounds reads in safe code.
",nan,"['https://github.com/apache/arrow-rs/issues/773', 'https://github.com/apache/arrow-rs/issues/772', 'https://rustsec.org/advisories/RUSTSEC-2021-0116.html', 'https://crates.io/crates/arrow']"
RUSTSEC-2021-0118,arrow,https://github.com/apache/arrow-rs,['Memory Access'],2021-12-22 21:15:54+00:00,2021-09-14T12:00:00Z,"[('0.0.0-0', '6.4.0')]","`FixedSizeBinaryArray` does not perform bound checks on accessing values and offsets
","`FixedSizeBinaryArray` performs insufficient bounds checks, which allows out-of-bounds reads in safe code.
",nan,"['https://rustsec.org/advisories/RUSTSEC-2021-0118.html', 'https://github.com/apache/arrow-rs/issues/774', 'https://crates.io/crates/arrow']"
RUSTSEC-2022-0012,arrow2,https://github.com/jorgecarleitao/arrow2,['Memory Management'],2022-04-05 15:24:42+00:00,2022-03-04T12:00:00Z,"[('0.0.0-0', '0.7.1')]","Arrow2 allows double free in `safe` code
","The struct `Ffi_ArrowArray` implements `#derive(Clone)` that is inconsistent with
its custom implementation of `Drop`, resulting in a double free when cloned.

Cloning this struct in `safe` results in a segmentation fault, which is unsound.

This derive was removed from this struct. All users are advised to either:
* bump the patch version of this crate (for versions `v0.7,v0.8,v0.9`), or
* migrate to a more recent version of  the crate (when using `<0.7`).

Doing so elimitates this vulnerability (code no longer compiles).
",nan,"['https://crates.io/crates/arrow2', 'https://rustsec.org/advisories/RUSTSEC-2022-0012.html', 'https://github.com/jorgecarleitao/arrow2/issues/880']"
RUSTSEC-2021-0090,ash,https://github.com/ash-rs/ash,"['Memory Access', 'Exception Management']",2021-08-23 12:04:28+00:00,2021-01-07T12:00:00Z,"[('0', '0.33.1'), ('0.0.0-0', '0.33.1')]","Use of Uninitialized Resource in ash.
Reading on uninitialized memory may cause UB ( `util::read_spv()` )
","An issue was discovered in the ash crate before 0.33.1 for Rust. util::read_spv may read from uninitialized memory locations.
Affected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation.

Arbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.
Reading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.
",Critical,"['https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/ash/RUSTSEC-2021-0090.md', 'https://github.com/MaikKlein/ash', 'https://crates.io/crates/ash', 'https://github.com/MaikKlein/ash/issues/354', 'https://rustsec.org/advisories/RUSTSEC-2021-0090.html', 'https://nvd.nist.gov/vuln/detail/CVE-2021-45688']"
GHSA-v5r6-6r3c-wqxc,asn1_der,https://github.com/KizzyCode/asn1_der-rust,['Resource Management'],2021-08-19 21:22:28+00:00,2021-08-25T20:44:56Z,"[('0', '0.6.2'), ('0.0.0-0', '0.6.2')]","Processing of maliciously crafted length fields causes memory allocation SIGABRTs
Memory exhaustion in asn1_der
","Affected versions of this crate tried to preallocate a vector for an arbitrary amount of bytes announced by the ASN.1-DER length field without further checks.

This allows an attacker to trigger a SIGABRT by creating length fields that announce more bytes than the allocator can provide.
 
The flaw was corrected by not preallocating memory.
An issue was discovered in the asn1_der crate before 0.6.2 for Rust. Attackers can trigger memory exhaustion by supplying a large value in a length field.
",High,"['https://crates.io/crates/asn1_der', 'https://github.com/KizzyCode/asn1_der', 'https://github.com/KizzyCode/asn1_der/issues/1', 'https://rustsec.org/advisories/RUSTSEC-2019-0007.html', 'https://nvd.nist.gov/vuln/detail/CVE-2019-15549']"
GHSA-9j8q-m9x5-9g6j,async-coap,https://github.com/google/rust-async-coap,"['Memory Access', 'Synchronization', 'Memory Management']",2021-08-24 18:52:16+00:00,2021-08-25T20:59:11Z,"[('0.0.0-0', None), ('0', None)]","ArcGuard's Send and Sync should have bounds on RC
Data races in async-coap
","Affected versions of this crate implement Send/Sync for `ArcGuard<RC, T>` with no trait bounds on `RC`. This allows users to send `RC: !Send` to other threads and also allows users to concurrently access `Rc: !Sync` from multiple threads.

This can result in memory corruption from data race or other undefined behavior caused by sending `T: !Send` to other threads (e.g. dropping `MutexGuard<T>` in another thread that didn't lock its mutex).
An issue was discovered in the async-coap crate through 2020-12-08 for Rust. 
Affected versions of this crate implement Send/Sync for `ArcGuard<RC, T>` with no trait bounds on `RC`. This allows users to send `RC: !Send` to other threads and also allows users to concurrently access `Rc: !Sync` from multiple threads.

This can result in memory corruption from data race or other undefined behavior caused by sending `T: !Send` to other threads (e.g. dropping `MutexGuard<T>` in another thread that didn't lock its mutex).

",High,"['https://nvd.nist.gov/vuln/detail/CVE-2020-36444', 'https://crates.io/crates/async-coap', 'https://rustsec.org/advisories/RUSTSEC-2020-0124.html', 'https://github.com/google/rust-async-coap', 'https://github.com/google/rust-async-coap/issues/33']"
RUSTSEC-2020-0093,async-h1,https://github.com/http-rs/async-h1,[],2021-02-26 01:00:25+00:00,2020-12-17T12:00:00Z,"[('0.0.0-0', '2.3.0')]","Async-h1 request smuggling possible with long unread bodies
","This vulnerability affects any webserver that uses async-h1 behind a reverse proxy, including all such Tide applications.

If the server does not read the body of a request which is longer than some buffer length, async-h1 will attempt to read a subsequent request from the body content starting at that offset into the body.

One way to exploit this vulnerability would be for an adversary to craft a request such that the body contains a request that would not be noticed by a reverse proxy, allowing it to forge forwarded/x-forwarded headers. If an application trusted the authenticity of these headers, it could be misled by the smuggled request.

Another potential concern with this vulnerability is that if a reverse proxy is sending multiple http clients' requests along the same keep-alive connection, it would be possible for the smuggled request to specify a long content and capture another user's request in its body. This content could be captured in a post request to an endpoint that allows the content to be subsequently retrieved by the adversary.

The flaw was corrected in commit [7df79f](https://github.com/http-rs/async-h1/commit/7df79f1d5d99fc0f492b315eebc7f0d301a85212) by ensuring that the request body is always consumed from the tcp stream before attempting to read subsequent keep-alive request headers from it.
",nan,"['https://crates.io/crates/async-h1', 'https://rustsec.org/advisories/RUSTSEC-2020-0093.html', 'https://github.com/http-rs/async-h1/releases/tag/v2.3.0']"
GHSA-4vr9-8cjf-vf9c,async-h1,https://github.com/http-rs/async-h1,['Tainted Input'],2021-10-08 22:14:28+00:00,2021-10-12T16:00:37Z,"[('0', '2.3.0')]","Async-h1 request smuggling possible with long unread bodies
","### Impact
This vulnerability affects any webserver that uses async-h1 behind a reverse proxy, including all such Tide applications.

If the server does not read the body of a request which is longer than some buffer length, async-h1 will attempt to read a subsequent request from the body content starting at that offset into the body.

One way to exploit this vulnerability would be for an adversary to craft a request such that the body contains a request that would not be noticed by a reverse proxy, allowing it to forge forwarded/x-forwarded headers. If an application trusted the authenticity of these headers, it could be misled by the smuggled request.

Another potential concern with this vulnerability is that if a reverse proxy is sending multiple http clients' requests along the same keep-alive connection, it would be possible for the smuggled request to specify a long content and capture another user's request in its body. This content could be captured in a post request to an endpoint that allows the content to be subsequently retrieved by the adversary.


### Patches
This has been addressed in async-h1 2.3.0 and previous versions have been yanked.

### Workarounds
none

### References
https://github.com/http-rs/async-h1/releases/tag/v2.3.0

### For more information
If you have any questions or comments about this advisory:
* Open an issue in [async-h1](https://github.com/http-rs/async-h1)
* Contact a core team member on [zulip](https://http-rs.zulip-chat.com) or [discord](https://discord.gg/x2gKzst)
",Medium,"['https://github.com/http-rs/async-h1/security/advisories/GHSA-4vr9-8cjf-vf9c', 'https://nvd.nist.gov/vuln/detail/CVE-2020-26281', 'https://github.com/http-rs/async-h1', 'https://github.com/http-rs/async-h1/releases/tag/v2.3.0']"
RUSTSEC-2020-0044,atom,https://github.com/slide-rs/atom,['Synchronization'],2021-10-19 22:14:35+00:00,2020-09-21T12:00:00Z,"[('0.0.0-0', '0.3.6'), ('0', '0.3.6')]","Data races in atom
Unsafe Send implementation in Atom allows data races
","An issue was discovered in the atom crate before 0.3.6 for Rust. An unsafe Send implementation allows a cross-thread data race.
The `atom` crate contains a security issue revolving around its implementation
of the Send trait. It incorrectly allows any arbitrary type to be sent across
threads potentially leading to use-after-free issues through memory races.
",Medium,"['https://rustsec.org/advisories/RUSTSEC-2020-0044.html', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35897', 'https://crates.io/crates/atom', 'https://github.com/slide-rs/atom/issues/13', 'https://github.com/slide-rs/atom']"
GHSA-8gf5-q9p9-wvmc,atomic-option,https://github.com/reem/rust-atomic-option.git,"['Synchronization', 'Memory Management']",2021-08-19 18:48:32+00:00,2021-08-25T20:51:42Z,"[('0.0.0-0', None), ('0', None)]","AtomicOption should have Send + Sync bound on its type argument.
Data race in atomic-option
","In the affected versions of this crate,
`AtomicOption<T>` unconditionally implements `Sync`.

This allows programmers to move non-Sync types across thread boundaries (e.g. `Rc<T>`, `Arc<Cell<T>>`), which can lead to data races and undefined behavior. 
It is also possible to send non-Send types like `std::sync::MutexGuard` to other threads, which can lead to undefined behavior.
An issue was discovered in the atomic-option crate through 2020-10-31 for Rust. Because AtomicOption<T> implements Sync unconditionally, a data race can occur.
",Medium,"['https://github.com/reem/rust-atomic-option/issues/4', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36219', 'https://crates.io/crates/atomic-option', 'https://github.com/reem/rust-atomic-option', 'https://rustsec.org/advisories/RUSTSEC-2020-0113.html']"
GHSA-cgmg-2v6m-fjg7,autorand,https://github.com/mersinvald/autorand-rs,"['Memory Management', 'Exception Management']",2021-08-19 18:53:20+00:00,2021-08-25T20:50:41Z,"[('0', '0.2.3'), ('0.0.0-0', '0.2.3')]","`impl Random` on arrays can lead to dropping uninitialized memory
Free of uninitialized memory in autorand
","Affected versions of this crate had a panic safety issue to drop partially uninitialized array of `T` upon panic in a user provided function `T::random()`. Dropping uninitialized `T` can potentially cause memory corruption or undefined behavior.

The flaw was corrected in commit 565d508 by using `MaybeUninit<T>` to avoid possible dropping of uninitialized memory upon panic.
An issue was discovered in the autorand crate before 0.2.3 for Rust. Because of impl Random on arrays, uninitialized memory can be dropped when a panic occurs, leading to memory corruption.
",High,"['https://github.com/mersinvald/autorand-rs/issues/5', 'https://rustsec.org/advisories/RUSTSEC-2020-0103.html', 'https://crates.io/crates/autorand', 'https://github.com/mersinvald/autorand-rs', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36210']"
RUSTSEC-2021-0007,av-data,https://github.com/rust-av/rust-av,"['Memory Access', 'Privilege']",2021-10-19 22:14:35+00:00,2021-01-07T12:00:00Z,"[('0', '0.3.0'), ('0.0.0-0', '0.3.0')]","Null pointer deference in av-data
`Frame::copy_from_raw_parts` can lead to segfault without `unsafe`
","An issue was discovered in the av-data crate before 0.3.0 for Rust. A raw pointer is dereferenced, leading to a read of an arbitrary memory address, sometimes causing a segfault.
`fn Frame::copy_from_raw_parts()` is a safe API that can take a
raw pointer and dereference it. It is possible to read arbitrary memory address
with an arbitrarily fed pointer. This allows the safe API to access & read
arbitrary address in memory. Feeding an invalid memory address pointer to
the API may also cause the program to segfault.

The flaw was corrected in https://github.com/rust-av/rust-av/pull/137,
by removing the API `fn Frame::copy_from_raw_parts()`.
",High,"['https://crates.io/crates/av-data', 'https://nvd.nist.gov/vuln/detail/CVE-2021-25904', 'https://github.com/rust-av/rust-av/issues/136', 'https://rustsec.org/advisories/RUSTSEC-2021-0007.html', 'https://github.com/rust-av/rust-av']"
RUSTSEC-2021-0027,bam,https://gitlab.com/tprodanov/bam,['Memory Management'],2021-10-19 22:14:35+00:00,2021-01-07T12:00:00Z,"[('0.0.0-0', '0.1.3')]","Loading a bgzip block can write out of bounds if size overflows.
","Affected versions of `bam` set the length of an internal buffer using
`self.compressed.set_len(block_size - HEADER_SIZE - MIN_EXTRA_SIZE)` and then
wrote into it. While `block_size` was constrained to a proper maximum, when it
was too small the subtraction could overflow negatively to a large number past
the capacity of `self.compressed`.

This can result in memory corruption in the form of writing out of bounds when
loading a `bgzip` file with a small `block_size`.

Commit `061eee38d4` fixed this issue by checking for the underflow when setting
the buffer size.
",Critical,"['https://crates.io/crates/bam', 'https://rustsec.org/advisories/RUSTSEC-2021-0027.html', 'https://gitlab.com/tprodanov/bam/-/issues/4']"
GHSA-x67x-vg9m-65c3,base64,https://github.com/marshallpierce/rust-base64,['Memory Access'],2021-08-19 17:02:46+00:00,2021-08-25T20:55:27Z,"[('0', '0.5.2')]","Integer overflow in base64
","Affected versions of this crate suffered from an integer overflow bug when
calculating the size of a buffer to use when encoding base64 using the
`encode_config_buf` and `encode_config` functions.  If the input string
was large, this would cause a buffer to be allocated that was too small.
Since this function writes to the buffer using unsafe code, it would
allow an attacker to write beyond the buffer, causing memory corruption
and possibly the execution of arbitrary code.

This flaw was corrected by using checked arithmetic to calculate
the size of the buffer.

",Critical,"['https://rustsec.org/advisories/RUSTSEC-2017-0004', 'https://github.com/alicemaz/rust-base64/commit/24ead980daf11ba563e4fb2516187a56a71ad319', 'https://nvd.nist.gov/vuln/detail/CVE-2017-1000430', 'https://github.com/alicemaz/rust-base64']"
RUSTSEC-2017-0004,base64,https://github.com/marshallpierce/rust-base64,[],2021-10-19 22:14:35+00:00,2017-05-03T12:00:00Z,"[('0.0.0-0', '0.5.2')]","Integer overflow leads to heap-based buffer overflow in encode_config_buf
","Affected versions of this crate suffered from an integer overflow bug when
calculating the size of a buffer to use when encoding base64 using the
`encode_config_buf` and `encode_config` functions.  If the input string
was large, this would cause a buffer to be allocated that was too small.
Since this function writes to the buffer using unsafe code, it would
allow an attacker to write beyond the buffer, causing memory corruption
and possibly the execution of arbitrary code.

This flaw was corrected by using checked arithmetic to calculate
the size of the buffer.
",Critical,"['https://crates.io/crates/base64', 'https://rustsec.org/advisories/RUSTSEC-2017-0004.html', 'https://github.com/alicemaz/rust-base64/commit/24ead980daf11ba563e4fb2516187a56a71ad319']"
RUSTSEC-2021-0009,basic_dsp_matrix,https://github.com/liebharc/basic_dsp,['Memory Management'],2021-10-19 22:14:35+00:00,2021-01-10T12:00:00Z,"[('0', '0.9.2'), ('0.0.0-0', '0.9.2')]","Double free in basic_dsp_matrix
panic safety issue in `impl TransformContent<S, D> for [S; (2|3|4)]`
","An issue was discovered in the basic_dsp_matrix crate before 0.9.2 for Rust. When a TransformContent panic occurs, a double drop can be performed.
Affected versions of this crate did not guard against double drop while temporarily duplicating objects' ownership using `ptr::read()`. Upon panic in a user-provided function `conversion`, objects that are copied by `ptr::read()` are dropped twice, leading to memory corruption.

The flaw was corrected in v0.9.2 by using `ManuallyDrop<T>` to enclose objects that are to be temporarily duplicated.
",High,"['https://crates.io/crates/basic_dsp_matrix', 'https://nvd.nist.gov/vuln/detail/CVE-2021-25906', 'https://rustsec.org/advisories/RUSTSEC-2021-0009.html', 'https://github.com/liebharc/basic_dsp/issues/47', 'https://github.com/liebharc/basic_dsp']"
GHSA-p24j-h477-76q3,bat,https://github.com/sharkdp/bat,"['Other', 'Tainted Input']",2021-09-09 16:57:53+00:00,2021-08-25T21:01:37Z,"[('0', '0.18.2'), ('0.0.0-0', '0.18.2')]","Uncontrolled Search Path Element in sharkdp/bat
Uncontrolled Search Path Element in sharkdp/bat
","bat on windows before 0.18.2 executes programs named less.exe from the current working directory. This can lead to unintended code execution.
bat on windows before 0.18.2 executes programs named less.exe from the current working directory. This can lead to unintended code execution.
",High,"['https://github.com/sharkdp/bat/releases/tag/v0.18.2', 'https://vuln.ryotak.me/advisories/53', 'https://nvd.nist.gov/vuln/detail/CVE-2021-36753', 'https://crates.io/crates/bat', 'https://github.com/sharkdp/bat', 'https://rustsec.org/advisories/RUSTSEC-2021-0106.html', 'https://github.com/sharkdp/bat/pull/1724', 'https://github.com/sharkdp/bat/commit/bf2b2df9c9e218e35e5a38ce3d03cffb7c363956']"
GHSA-m7w4-8wp8-m2xq,beef,https://github.com/maciejhirsz/beef,"['Memory Access', 'Synchronization', 'Memory Management']",2021-08-24 18:35:48+00:00,2021-08-25T20:59:08Z,"[('0.0.0-0', '0.5.0'), ('0', '0.5.0')]","beef::Cow lacks a Sync bound on its Send trait allowing for data races
Data races in beef
","Affected versions of this crate did not have a `T: Sync` bound in the `Send` impl for `Cow<'_, T, U>`. This allows users to create data races by making `Cow` contain types that are (Send && !Sync) like `Cell<_>` or `RefCell<_>`.

Such data races can lead to memory corruption.

The flaw was corrected in commit d1c7658 by adding trait bounds `T: Sync` and `T::Owned: Send` to the `Send` impl for `Cow<'_, T, U>`.
An issue was discovered in the beef crate before 0.5.0 for Rust. 
Affected versions of this crate did not have a `T: Sync` bound in the `Send` impl for `Cow<'_, T, U>`. This allows users to create data races by making `Cow` contain types that are (Send && !Sync) like `Cell<_>` or `RefCell<_>`.

Such data races can lead to memory corruption.

The flaw was corrected in commit d1c7658 by adding trait bounds `T: Sync` and `T::Owned: Send` to the `Send` impl for `Cow<'_, T, U>`.

",High,"['https://github.com/maciejhirsz/beef/issues/37', 'https://rustsec.org/advisories/RUSTSEC-2020-0122.html', 'https://github.com/maciejhirsz/beef', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36442', 'https://crates.io/crates/beef']"
GHSA-79wf-qcqv-r22r,better-macro,https://github.com/raycar5/better-macro,"['Other', 'Tainted Input']",2021-08-18 21:21:03+00:00,2021-08-25T20:56:00Z,"[('0.0.0-0', None), ('0', None)]","`better-macro` has deliberate RCE to prove a point
Remote code execution in better-macro
","[better-macro](https://crates.io/crates/better-macro) is a fake crate which is
""Proving A Point"" that proc-macros can run arbitrary code. This is not a particularly
novel or interesting observation.

It currently opens `https://github.com/raycar5/better-macro/blob/master/doc/hi.md`
which doesn't appear to have any malicious content, but there's no guarantee that
will remain the case.

This crate has no useful functionality, and should not be used.
An issue was discovered in the better-macro crate through 2021-07-22 for Rust. It intentionally demonstrates that remote attackers can execute arbitrary code via proc-macros, and otherwise has no legitimate purpose.
",nan,"['https://github.com/raycar5/better-macro/blob/24ff1702397b9c19bbfa4c660e2316cd77d3b900/src/lib.rs#L36-L38', 'https://crates.io/crates/better-macro', 'https://github.com/raycar5/better-macro', 'https://rustsec.org/advisories/RUSTSEC-2021-0077.html', 'https://nvd.nist.gov/vuln/detail/CVE-2021-38196']"
RUSTSEC-2020-0025,bigint,https://github.com/paritytech/bigint,['Risky Values'],2021-10-19 22:14:35+00:00,2020-05-07T12:00:00Z,"[('0.0.0-0', None), ('0', None)]","Unsoundness in bigint
bigint is unmaintained, use uint instead
","An issue was discovered in the bigint crate through 2020-05-07 for Rust. It allows a soundness violation.
The `bigint` crate is not maintained any more and contains several known bugs (including a soundness bug);
use [`uint`](https://crates.io/crates/uint) instead.
",Critical,"['https://nvd.nist.gov/vuln/detail/CVE-2020-35880', 'https://rustsec.org/advisories/RUSTSEC-2020-0025.html', 'https://github.com/paritytech/bigint/commit/7e71521a61b009afc94c91135353102658550d42', 'https://github.com/paritytech/bigint', 'https://github.com/rustsec/advisory-db/pull/290', 'https://crates.io/crates/bigint']"
GHSA-gm68-g349-gxgg,bingrep,https://github.com/m4b/bingrep,['Resource Management'],2022-01-28 22:20:30+00:00,2022-01-28T22:35:16Z,"[('0.8.5', '0.8.5')]","Denial of service in bingrep
","Bingrep v0.8.5 was discovered to contain a memory allocation failure which can cause a Denial of Service (DoS).
",nan,"['https://nvd.nist.gov/vuln/detail/CVE-2021-39480', 'https://github.com/m4b/bingrep', 'https://github.com/m4b/bingrep/issues/30']"
GHSA-cw4j-cf6c-mmfv,binjs_io,https://github.com/Yoric/binjs-ref,"['Memory Access', 'Exception Management']",2022-01-07 17:36:37+00:00,2022-01-06T22:14:24Z,"[('0.0.0-0', None), ('0', None)]","'Read' on uninitialized memory may cause UB
Use of Uninitialized Resource in binjs_io.
","Affected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation. The crate currently contains 4 occurrences of such cases.

Arbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.
Reading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.
An issue was discovered in the binjs_io crate through 2021-01-03 for Rust. The Read method may read from uninitialized memory locations.
",nan,"['https://rustsec.org/advisories/RUSTSEC-2021-0085.html', 'https://github.com/binast/binjs-ref/issues/460', 'https://nvd.nist.gov/vuln/detail/CVE-2021-45683', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/binjs_io/RUSTSEC-2021-0085.md', 'https://github.com/Yoric/binjs-ref', 'https://crates.io/crates/binjs_io']"
GHSA-v2ch-fc8f-qm33,bite,https://github.com/hinaria/bite,"['Memory Access', 'Exception Management']",2022-01-07 16:24:37+00:00,2022-01-06T22:16:57Z,"[('0.0.0-0', None), ('0', None)]","`read` on uninitialized buffer may cause UB (bite::read::BiteReadExpandedExt::read_framed_max)
Use of Uninitialized Resource in bite.
","Affected versions of this crate calls a user provided `Read` implementation on an uninitialized buffer.

`Read` on uninitialized buffer is defined as undefined behavior in Rust.
An issue was discovered in the bite crate through 2020-12-31 for Rust. read::BiteReadExpandedExt::read_framed_max may read from uninitialized memory locations.
",nan,"['https://nvd.nist.gov/vuln/detail/CVE-2020-36511', 'https://github.com/hinaria/bite', 'https://crates.io/crates/bite', 'https://rustsec.org/advisories/RUSTSEC-2020-0153.html', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/bite/RUSTSEC-2020-0153.md', 'https://github.com/hinaria/bite/issues/1']"
GHSA-7cjc-hvxf-gqh7,bitvec,https://github.com/bitvecto-rs/bitvec,"['Memory Access', 'Memory Management']",2021-08-19 21:18:16+00:00,2021-08-25T20:47:39Z,"[('0', '0.17.4'), ('0.11.0', '0.17.4')]","use-after or double free of allocated memory
Use after free and double free in bitvec
","Conversion of `BitVec` to `BitBox` did not account for allocation movement.

The flaw was corrected by using the address after resizing, rather than the original base address.
An issue was discovered in the bitvec crate before 0.17.4 for Rust. BitVec to BitBox conversion leads to a use-after-free or double free.
",Critical,"['https://github.com/myrrlyn/bitvec/issues/55', 'https://rustsec.org/advisories/RUSTSEC-2020-0007.html', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35862', 'https://crates.io/crates/bitvec', 'https://github.com/myrrlyn/bitvec']"
RUSTSEC-2019-0019,blake2,https://github.com/RustCrypto/hashes,['Cryptography'],2021-10-19 22:14:35+00:00,2019-08-25T12:00:00Z,"[('0.0.0-0', '0.8.1'), ('0', '0.8.1')]","Algorithms compute incorrect results in blake2
HMAC-BLAKE2 algorithms compute incorrect results
","An issue was discovered in the blake2 crate before 0.8.1 for Rust. The BLAKE2b and BLAKE2s algorithms, when used with HMAC, produce incorrect results because the block sizes are half of the required sizes.
When used in conjunction with the Hash-based Message Authentication Code (HMAC),
the BLAKE2b and BLAKE2s implementations in `blake2` crate versions prior to
v0.8.1 used an incorrect block size (32-bytes instead of 64-bytes for BLAKE2s,
and 64-bytes instead of 128-bytes for BLAKE2b), causing them to miscompute the
`MacResult`.

The v0.8.1 release of the `blake2` crate uses the correct block sizes.

Note that this advisory only impacts usage of BLAKE2 with HMAC, and does not
impact `Digest` functionality.
",Critical,"['https://crates.io/crates/blake2', 'https://github.com/RustCrypto/MACs/issues/19', 'https://github.com/RustCrypto/hashes/tree/master/blake2', 'https://rustsec.org/advisories/RUSTSEC-2019-0019.html', 'https://nvd.nist.gov/vuln/detail/CVE-2019-16143']"
RUSTSEC-2020-0057,block-cipher,https://github.com/RustCrypto/traits/tree/master/cipher,[],2020-10-25 19:05:32+00:00,2020-10-15T12:00:00Z,"[('0.0.0-0', None)]","crate has been renamed to `cipher`
","This crate has been renamed from `block-cipher` to `cipher`.

The new repository location is at:

<https://github.com/RustCrypto/traits/tree/master/cipher>
",nan,"['https://github.com/RustCrypto/traits/pull/337', 'https://crates.io/crates/block-cipher', 'https://rustsec.org/advisories/RUSTSEC-2020-0057.html']"
RUSTSEC-2020-0018,block-cipher-trait,https://github.com/RustCrypto/traits/tree/master/cipher,[],2020-10-02 01:29:11+00:00,2020-05-26T12:00:00Z,"[('0.0.0-0', None)]","crate has been renamed to `block-cipher`
","This crate has been renamed from `block-cipher-trait` to `block-cipher`.

The new repository location is at:

<https://github.com/RustCrypto/traits/tree/master/block-cipher>
",nan,"['https://github.com/RustCrypto/traits/pull/139', 'https://rustsec.org/advisories/RUSTSEC-2020-0018.html', 'https://crates.io/crates/block-cipher-trait']"
GHSA-j8qq-58cr-8cc7,bra,https://github.com/Enet4/bra-rs,"['Memory Access', 'Exception Management']",2022-05-05 00:44:22+00:00,2021-08-25T20:52:53Z,"[('0.0.0-0', '0.1.1'), ('0', '0.1.1')]","reading on uninitialized buffer can cause UB (`impl<R> BufRead for GreedyAccessReader<R>`)
Out of bounds read in bra
","Affected versions of this crate creates an uninitialized buffer and passes it to user-provided `Read` implementation.

This is unsound, because it allows safe Rust code to exhibit an undefined behavior (read from uninitialized memory).

The flaw was corrected in version 0.1.1 by zero-initializing a newly allocated buffer
before handing it to a user-provided `Read` implementation.
Buffered Random Access (BRA) provides easy random memory access to a sequential source of data in Rust. This is achieved by greedily retaining all memory read from a given source. Buffered Random Access (BRA) provides easy random memory access to a sequential source of data in Rust. An issue was discovered in the bra crate before 0.1.1 for Rust. It lacks soundness because it can read uninitialized memory.
",Critical,"['https://nvd.nist.gov/vuln/detail/CVE-2021-25905', 'https://crates.io/crates/bra', 'https://rustsec.org/advisories/RUSTSEC-2021-0008.html', 'https://github.com/Enet4/bra-rs', 'https://github.com/Enet4/bra-rs/issues/1']"
RUSTSEC-2020-0075,branca,https://github.com/return/branca,"['Resource Management', 'Tainted Input']",2021-10-19 22:14:35+00:00,2020-11-29T12:00:00Z,"[('0', '0.10.0'), ('0.0.0-0', '0.10.0')]","Unexpected panic when decoding tokens in branca
Unexpected panic when decoding tokens
","An issue was discovered in the branca crate before 0.10.0 for Rust. Decoding tokens (with invalid base62 data) can panic.
Prior to `0.10.0` it was possible to have both decoding functions panic unexpectedly,
by supplying tokens with an incorrect base62 encoding.

The documentation stated that an error should have been reported instead.
",Medium,"['https://github.com/return/branca/issues/24', 'https://github.com/return/branca', 'https://crates.io/crates/branca', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35918', 'https://github.com/tuupola/branca-spec/issues/22', 'https://rustsec.org/advisories/RUSTSEC-2020-0075.html']"
GHSA-jv2r-jx6q-89jg,bronzedb-protocol,https://github.com/Hexilee/BronzeDB,"['Memory Access', 'Exception Management']",2022-01-07 16:16:57+00:00,2022-01-06T22:16:32Z,"[('0.0.0-0', None), ('0', None)]","`Read` on uninitialized buffer can cause UB (impl of `ReadKVExt`)
Use of Uninitialized Resource in bronzedb-protocol.
","Affected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation.

Arbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.
Reading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.
An issue was discovered in the bronzedb-protocol crate through 2021-01-03 for Rust. ReadKVExt may read from uninitialized memory locations.
",nan,"['https://github.com/Hexilee/BronzeDB/issues/1', 'https://crates.io/crates/bronzedb-protocol', 'https://rustsec.org/advisories/RUSTSEC-2021-0084.html', 'https://nvd.nist.gov/vuln/detail/CVE-2021-45682', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/bronzedb-protocol/RUSTSEC-2021-0084.md', 'https://github.com/Hexilee/BronzeDB']"
RUSTSEC-2021-0131,brotli-sys,https://github.com/alexcrichton/brotli2-rs,['Memory Management'],2021-12-21 20:51:30+00:00,2021-12-20T12:00:00Z,"[('0.0.0-0', None)]","Integer overflow in the bundled Brotli C library
","A buffer overflow exists in the Brotli library versions prior to 1.0.8 where an attacker controlling the input length of a ""one-shot"" decompression request to a script can trigger a crash, which happens when copying over chunks of data larger than 2 GiB.

An updated version of `brotli-sys` has not been released. If one cannot update the C library, its authors recommend to use the ""streaming"" API as opposed to the ""one-shot"" API, and impose chunk size limits.

In Rust the issue can be mitigated by migrating to the `brotli` crate, which provides a Rust implementation of Brotli compression and decompression that is not affected by this issue.
",nan,"['https://github.com/google/brotli/releases/tag/v1.0.9', 'https://github.com/bitemyapp/brotli2-rs/issues/45', 'https://crates.io/crates/brotli-sys', 'https://rustsec.org/advisories/RUSTSEC-2021-0131.html']"
RUSTSEC-2020-0154,buffoon,https://github.com/carllerche/buffoon,"['Memory Access', 'Exception Management']",2021-08-22 01:30:23+00:00,2020-12-31T12:00:00Z,"[('0.0.0-0', None), ('0', None)]","Use of Uninitialized Resource in buffoon.
InputStream::read_exact : `Read` on uninitialized buffer causes UB
","An issue was discovered in the buffoon crate through 2020-12-31 for Rust. InputStream::read_exact may read from uninitialized memory locations.
Affected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation.

Arbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.
Reading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.
",Critical,"['https://nvd.nist.gov/vuln/detail/CVE-2020-36512', 'https://github.com/carllerche/buffoon/issues/2', 'https://rustsec.org/advisories/RUSTSEC-2020-0154.html', 'https://github.com/carllerche/buffoon', 'https://crates.io/crates/buffoon', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/buffoon/RUSTSEC-2020-0154.md']"
RUSTSEC-2020-0006,bumpalo,https://github.com/fitzgen/bumpalo,['Memory Access'],2021-10-19 22:14:35+00:00,2020-03-24T12:00:00Z,"[('3.0.0', '3.2.1')]","Out of bounds read in bumpalo
Flaw in `realloc` allows reading unknown memory
","An issue was discovered in the bumpalo crate before 3.2.1 for Rust. The realloc feature allows the reading of unknown memory. Attackers can potentially read cryptographic keys.
When `realloc`ing, if we allocate new space, we need to copy the old
allocation's bytes into the new space. There are `old_size` number of bytes in
the old allocation, but we were accidentally copying `new_size` number of bytes,
which could lead to copying bytes into the realloc'd space from past the chunk
that we're bump allocating out of, from unknown memory.

If an attacker can cause `realloc`s, and can read the `realoc`ed data back,
this could allow them to read things from other regions of memory that they
shouldn't be able to. For example, if some crypto keys happened to live in
memory right after a chunk we were bump allocating out of, this could allow
the attacker to read the crypto keys.

Beyond just fixing the bug and adding a regression test, I've also taken two
additional steps:

1. While we were already running the testsuite under `valgrind` in CI, because
   `valgrind` exits with the same code that the program did, if there are
   invalid reads/writes that happen not to trigger a segfault, the program can
   still exit OK and we will be none the wiser. I've enabled the
   `--error-exitcode=1` flag for `valgrind` in CI so that tests eagerly fail
   in these scenarios.

2. I've written a quickcheck test to exercise `realloc`. Without the bug fix
   in this patch, this quickcheck immediately triggers invalid reads when run
   under `valgrind`. We didn't previously have quickchecks that exercised
   `realloc` because `realloc` isn't publicly exposed directly, and instead
   can only be indirectly called. This new quickcheck test exercises `realloc`
   via `bumpalo::collections::Vec::resize` and
   `bumpalo::collections::Vec::shrink_to_fit` calls.
",High,"['https://github.com/fitzgen/bumpalo', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35861', 'https://crates.io/crates/bumpalo', 'https://github.com/fitzgen/bumpalo/issues/69', 'https://rustsec.org/advisories/RUSTSEC-2020-0006.html']"
RUSTSEC-2020-0130,bunch,https://github.com/krl/bunch,"['Synchronization', 'Memory Management', 'Tainted Input']",2021-10-19 22:14:35+00:00,2020-11-12T12:00:00Z,"[('0.0.0-0', None), ('0', None)]","Data races in bunch
Bunch<T> unconditionally implements Send/Sync
","An issue was discovered in the bunch crate through 2020-11-12 for Rust. 
Affected versions of this crate unconditionally implements `Send`/`Sync` for `Bunch<T>`.
This allows users to insert `T: !Sync` to `Bunch<T>`. It is possible to create a data race to a `T: !Sync` by invoking the `Bunch::get()` API (which returns `&T`) from multiple threads. It is also possible to send `T: !Send` to other threads by inserting `T` inside `Bunch<T>` and sending `Bunch<T>` to another thread, allowing to create a data race by inserting types like `T = Rc<_>`.

Such data races can lead to memory corruption.
Affected versions of this crate unconditionally implements `Send`/`Sync` for `Bunch<T>`.
This allows users to insert `T: !Sync` to `Bunch<T>`. It is possible to create a data race to a `T: !Sync` by invoking the `Bunch::get()` API (which returns `&T`) from multiple threads. It is also possible to send `T: !Send` to other threads by inserting `T` inside `Bunch<T>` and sending `Bunch<T>` to another thread, allowing to create a data race by inserting types like `T = Rc<_>`.

Such data races can lead to memory corruption.
",High,"['https://nvd.nist.gov/vuln/detail/CVE-2020-36450', 'https://github.com/krl/bunch', 'https://rustsec.org/advisories/RUSTSEC-2020-0130.html', 'https://github.com/krl/bunch/issues/1', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/bunch/RUSTSEC-2020-0130.md', 'https://crates.io/crates/bunch']"
GHSA-r7rv-2rph-hvhj,buttplug,https://github.com/buttplugio/buttplug.git,"['Synchronization', 'Memory Management']",2021-08-19 18:48:19+00:00,2021-08-25T20:51:45Z,"[('0', '1.0.4'), ('0.0.0-0', '1.0.4')]","ButtplugFutureStateShared allows data race to (!Send|!Sync) objects
Improper synchronization in buttplug
","`ButtplugFutureStateShared<T>` implements `Send` & `Sync` regardless of `T`.

If `T: !Send` for `ButtplugFutureStateShared<T>`, it is possible to move non-Send types across thread boundaries (e.g. `T`=`Rc<T>`) and lead to undefined behavior.
If `T: !Sync` for `ButtplugFutureStateShared<T>`, it is possible to cause data race to `T` (e.g. `T`=`Arc<Cell<_>>`) and lead to undefined behavior.

The flaw was corrected in version 1.0.4 by removing manual implementations of `Send`/`Sync` for `ButtplugFutureStateShared<T>` to let rustc generate auto trait implementations with correct trait bounds on `T`.
An issue was discovered in the buttplug crate before 1.0.4 for Rust. ButtplugFutureStateShared does not properly consider (!Send|!Sync) objects, leading to a data race.
",Medium,"['https://nvd.nist.gov/vuln/detail/CVE-2020-36218', 'https://rustsec.org/advisories/RUSTSEC-2020-0112.html', 'https://github.com/buttplugio/buttplug-rs/issues/225', 'https://github.com/buttplugio/buttplug-rs', 'https://crates.io/crates/buttplug']"
RUSTSEC-2021-0032,byte_struct,https://github.com/wwylele/byte-struct-rs,"['Memory Access', 'Exception Management', 'Memory Management']",2021-10-19 22:14:35+00:00,2021-03-01T12:00:00Z,"[('0.0.0-0', '0.6.1'), ('0', '0.6.1')]","Deserializing an array can free uninitialized memory in byte_struct
Deserializing an array can drop uninitialized memory on panic
","Byte_struct stack and unpack structure as raw bytes with packed or bit field layout. An issue was discovered in the byte_struct crate before 0.6.1 for Rust. There can be a drop of uninitialized memory if a certain deserialization method panics.
The `read_bytes_default_le` function for `[T; n]` arrays, used to deserialize
arrays of `T` from bytes created a `[T; n]` array with `std::mem::uninitialized`
and then called `T`'s deserialization method.

If `T`'s deserialization method panicked, the uninitialized memory could drop
invalid objects.

This flaw was corrected in `a535678` by removing the unsafe block and using
a `.map` function to deserialize each element of the array instead.
",Critical,"['https://github.com/wwylele/byte-struct-rs', 'https://crates.io/crates/byte_struct', 'https://rustsec.org/advisories/RUSTSEC-2021-0032.html', 'https://github.com/wwylele/byte-struct-rs/issues/1', 'https://nvd.nist.gov/vuln/detail/CVE-2021-28033']"
GHSA-gh87-6jr3-8q47,cache,https://github.com/krl/cache,"['Memory Access', 'Memory Management']",2021-08-19 18:45:43+00:00,2021-08-25T20:52:57Z,"[('0.0.0-0', None), ('0', None)]","Exposes internally used raw pointer
Null pointer deference in cache
","Affected versions of this crate dereference a raw pointer that can be modified
without using `unsafe` code.
An issue was discovered in the cache crate through 2021-01-01 for Rust. A raw pointer is dereferenced.
",High,"['https://rustsec.org/advisories/RUSTSEC-2021-0006.html', 'https://crates.io/crates/cache', 'https://github.com/krl/cache', 'https://github.com/krl/cache/issues/2', 'https://nvd.nist.gov/vuln/detail/CVE-2021-25903']"
RUSTSEC-2020-0128,cache,https://github.com/krl/cache,"['Synchronization', 'Memory Management', 'Tainted Input']",2021-10-19 22:14:35+00:00,2020-11-24T12:00:00Z,"[('0.0.0-0', None), ('0', None)]","Data races in cache
Cache<K>: Send/Sync impls needs trait bounds on `K`
","An issue was discovered in the cache crate through 2020-11-24 for Rust. 
Affected versions of this crate unconditionally implement Send/Sync for `Cache<K>`.
This allows users to insert `K` that is not Send or not Sync.

This allows users to create data races by using non-Send types like `Arc<Cell<T>>` or `Rc<T>` as `K` in `Cache<K>`. It is also possible to create data races by using types like `Cell<T>` or `RefCell<T>` (types that are `Send` but not `Sync`).
Such data races can lead to memory corruption.

Affected versions of this crate unconditionally implement Send/Sync for `Cache<K>`.
This allows users to insert `K` that is not Send or not Sync.

This allows users to create data races by using non-Send types like `Arc<Cell<T>>` or `Rc<T>` as `K` in `Cache<K>`. It is also possible to create data races by using types like `Cell<T>` or `RefCell<T>` (types that are `Send` but not `Sync`).
Such data races can lead to memory corruption.
",High,"['https://github.com/krl/cache/issues/1', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36448', 'https://crates.io/crates/cache', 'https://github.com/krl/cache', 'https://rustsec.org/advisories/RUSTSEC-2020-0128.html']"
GHSA-ppqp-78xx-3r38,calamine,https://github.com/tafia/calamine,"['Memory Access', 'Memory Management']",2022-04-26 18:11:53+00:00,2021-08-25T20:53:25Z,"[('0.0.0-0', '0.17.0'), ('0', '0.17.0')]","`Sectors::get` accesses unclaimed/uninitialized memory
Out of bounds write in calamine
","Affected versions of this crate arbitrarily calls `Vec::set_len` to increase length of a vector without claiming more memory for the vector. Affected versions of this crate
also calls user-provided `Read` on the uninitialized memory of the vector that was
extended with `Vec::set_len`.

This can overwrite active entities in adjacent heap memory and seems to be a major security issue. Also, calling user-provided `Read` on uninitialized memory is defined as UB in Rust.
An issue was discovered in the calamine crate before 0.17.0 for Rust. It allows attackers to overwrite heap-memory locations because Vec::set_len is used without proper memory claiming, and this uninitialized memory is used for a user-provided Read operation, as demonstrated by Sectors::get.
",Critical,"['https://nvd.nist.gov/vuln/detail/CVE-2021-26951', 'https://rustsec.org/advisories/RUSTSEC-2021-0015.html', 'https://github.com/tafia/calamine/issues/199', 'https://github.com/tafia/calamine', 'https://crates.io/crates/calamine']"
RUSTSEC-2021-0133,cargo-download,https://github.com/Xion/cargo-download.git,[],2021-12-25 18:20:22+00:00,2021-12-25T12:00:00Z,"[('0.0.0-0', None)]","cargo-download is unmaintained
","The cargo download subcommand (via cargo-download crate) is broken and maintainer has disappeared from GitHub and hasn't had any commits for a year. 

Using this downloader will result to corrupted crates.

Maintainer has not responded to maintenance takeover.

Just use wget / curl directly.
",nan,"['https://rustsec.org/advisories/RUSTSEC-2021-0133.html', 'https://crates.io/crates/cargo-download', 'https://github.com/Xion/cargo-download']"
RUSTSEC-2016-0006,cassandra,https://github.com/tupshin/cassandra-rust,[],2020-10-02 01:29:11+00:00,2016-12-15T12:00:00Z,"[('0.0.0-0', '0.8.2-0')]","`cassandra` crate is unmaintained; use `cassandra-cpp` instead
","The `cassandra` crate has not seen a release since December 2016, and its author
is unresponsive.

The `cassandra-cpp` crate is a maintained fork:

https://github.com/Metaswitch/cassandra-rs
",nan,"['https://github.com/tupshin/cassandra-rs/issues/52', 'https://crates.io/crates/cassandra', 'https://rustsec.org/advisories/RUSTSEC-2016-0006.html']"
GHSA-3vjm-36rr-7qrq,cbox,https://github.com/TomBebbington/cbox-rs,"['Memory Access', 'Memory Management']",2021-08-19 21:18:36+00:00,2021-08-25T20:47:16Z,"[('0.0.0-0', None), ('0', None)]","CBox API allows to de-reference raw pointers without `unsafe` code
NULL Pointer Dereference in cbox
","`CBox` and `CSemiBox` are part of the public API of the cbox crate
and they allow to create smart pointers from raw pointers and de-reference
them without the need of `unsafe` code.
An issue was discovered in the cbox crate through 2020-03-19 for Rust. The CBox API allows dereferencing raw pointers without a requirement for unsafe code.
",Critical,"['https://nvd.nist.gov/vuln/detail/CVE-2020-35860', 'https://github.com/TomBebbington/cbox-rs/issues/2', 'https://crates.io/crates/cbox', 'https://rustsec.org/advisories/RUSTSEC-2020-0005.html', 'https://github.com/TomBebbington/cbox-rs']"
RUSTSEC-2021-0012,cdr,https://github.com/hrektts/cdr-rs,"['Memory Access', 'Exception Management']",2021-10-19 22:14:35+00:00,2021-01-02T12:00:00Z,"[('0', '0.2.4'), ('0.0.0-0', '0.2.4')]","Read of uninitialized memory in cdr
Reading uninitialized memory can cause UB (`Deserializer::read_vec`)
","An issue was discovered in Deserializer::read_vec in the cdr crate before 0.2.4 for Rust. A user-provided Read implementation can gain access to the old contents of newly allocated heap memory, violating soundness.
`Deserializer::read_vec()` created an uninitialized buffer and passes it to a user-provided `Read` implementation (`Deserializer.reader.read_exact()`).

Passing an uninitialized buffer to an arbitrary `Read` implementation is currently defined as undefined behavior in Rust. Official documentation for the `Read` trait explains the following: ""It is your responsibility to make sure that buf is initialized before calling read. Calling read with an uninitialized buf (of the kind one obtains via MaybeUninit<T>) is not safe, and can lead to undefined behavior.""

The flaw was corrected in commit ce310f7 by zero-initializing the newly allocated buffer before handing it to `Deserializer.reader.read_exact()`.
",Critical,"['https://github.com/hrektts/cdr-rs', 'https://github.com/hrektts/cdr-rs/issues/10', 'https://crates.io/crates/cdr', 'https://rustsec.org/advisories/RUSTSEC-2021-0012.html', 'https://nvd.nist.gov/vuln/detail/CVE-2021-26305']"
GHSA-f3mq-99jr-ww4r,cgc,https://github.com/playXE/cgc,"['Other', 'Memory Management', 'Synchronization']",2021-08-24 18:18:53+00:00,2021-08-25T20:56:16Z,"[('0.0.0-0', None), ('0', None)]","Multiple soundness issues in `Ptr`
Non-atomic writes in cgc
Data races in cgc
Multiple mutable pointers in cgc
","Affected versions of this crate have the following issues:

1. `Ptr` implements `Send` and `Sync` for all types, this can lead to data
   races by sending non-thread safe types across threads.

2. `Ptr::get` violates mutable alias rules by returning multiple mutable
   references to the same object.

3. `Ptr::write` uses non-atomic writes to the underlying pointer. This means
   that when used across threads it can lead to data races.
An issue was discovered in the cgc crate through 2020-12-10 for Rust. Ptr::write performs non-atomic write operations on an underlying pointer.
An issue was discovered in the cgc crate through 2020-12-10 for Rust. Ptr implements Send and Sync for all types.
Affected versions of this crate have the following issues:

1. `Ptr` implements `Send` and `Sync` for all types, this can lead to data
   races by sending non-thread safe types across threads.

2. `Ptr::get` violates mutable alias rules by returning multiple mutable
   references to the same object.

3. `Ptr::write` uses non-atomic writes to the underlying pointer. This means
   that when used across threads it can lead to data races.

",Medium,"['https://nvd.nist.gov/vuln/detail/CVE-2020-36466', 'https://github.com/playXE/cgc/issues/5', 'https://rustsec.org/advisories/RUSTSEC-2020-0148.html', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36468', 'https://github.com/playXE/cgc', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36467', 'https://crates.io/crates/cgc', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/cgc/RUSTSEC-2020-0148.md']"
RUSTSEC-2019-0029,chacha20,https://github.com/RustCrypto/stream-ciphers,"['Risky Values', 'Cryptography']",2021-10-19 22:14:35+00:00,2019-10-22T12:00:00Z,"[('0', '0.2.3'), ('0.0.0-0', '0.2.3')]","Counter overflow in chacha20
ChaCha20 counter overflow can expose repetitions in the keystream
","An issue was discovered in the chacha20 crate before 0.2.3 for Rust. A ChaCha20 counter overflow makes it easier for attackers to determine plaintext.
The ChaCha20 stream cipher can produce a maximum of 2^32 blocks (~256GB)
before the 32-bit counter overflows. Releases of the `chacha20` crate prior
to v0.2.3 allow generating keystreams larger than this, including seeking
past the limit. When this occurs, the keystream is duplicated, with failure
modes similar to nonce reuse (i.e. exposure of the XOR of two plaintexts).

The v0.2.3 release now panics in this event, rather than exposing the
duplicated keystream. Note this is a ""hot fix"" solution to the problem
and future releases will pursue returning an error in this case.

Users of the `chacha20poly1305` crate are unaffected by this as this crate
properly asserts the length of the plaintext is less than the maximum allowed
(`P_MAX` as described in RFC 8439 Section 2.8).
",High,"['https://rustsec.org/advisories/RUSTSEC-2019-0029.html', 'https://nvd.nist.gov/vuln/detail/CVE-2019-25005', 'https://github.com/RustCrypto/stream-ciphers/tree/master/chacha20', 'https://crates.io/crates/chacha20', 'https://github.com/RustCrypto/stream-ciphers/pull/64']"
RUSTSEC-2018-0014,chan,https://github.com/BurntSushi/chan,[],2020-10-02 01:29:11+00:00,2018-07-31T12:00:00Z,"[('0.0.0-0', '0.1.24-0')]","chan is end-of-life; use crossbeam-channel instead
","**`chan` has reached its end-of-life and is now deprecated.**

The intended successor of this crate is
[`crossbeam-channel`](https://github.com/crossbeam-rs/crossbeam/tree/master/crossbeam-channel).
Its API is strikingly similar, but comes with a much better `select!` macro,
better performance, a better test suite and an all-around better
implementation.
",nan,"['https://crates.io/crates/chan', 'https://rustsec.org/advisories/RUSTSEC-2018-0014.html', 'https://github.com/BurntSushi/chan/commit/0a5c0d4ad4adc90a54ee04a427389acf2e157275']"
GHSA-5rrv-m36h-qwf8,chttp,https://github.com/sagebind/chttp,['Memory Access'],2021-08-19 21:22:50+00:00,2021-08-25T20:44:40Z,"[('0.1.1', '0.1.3'), ('0', '0.1.3')]","Use-after-free in buffer conversion implementation
Use-after-free in chttp
","The From<Buffer> implementation for Vec<u8> was not properly implemented,
returning a vector backed by freed memory. This could lead to memory corruption
or be exploited to cause undefined behavior.
 
A fix was published in version 0.1.3.
An issue was discovered in the chttp crate before 0.1.3 for Rust. There is a use-after-free during buffer conversion.
",Critical,"['https://rustsec.org/advisories/RUSTSEC-2019-0016.html', 'https://github.com/sagebind/isahc/issues/2', 'https://nvd.nist.gov/vuln/detail/CVE-2019-16140', 'https://crates.io/crates/chttp', 'https://github.com/sagebind/chttp']"
RUSTSEC-2020-0035,chunky,https://github.com/aeickhoff/chunky,['API'],2021-10-19 22:14:35+00:00,2020-08-25T12:00:00Z,"[('0.0.0-0', None), ('0', None)]","Unaligned memory allocation in chunky
Chunk API does not respect align requirement
","An issue was discovered in the chunky crate through 2020-08-25 for Rust. The Chunk API does not honor an alignment requirement.
Chunk API does not respect the align requirement of types. Unaligned reference can be created with the API, which is an undefined behavior.
",High,"['https://github.com/aeplay/chunky/issues/2', 'https://rustsec.org/advisories/RUSTSEC-2020-0035.html', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36433', 'https://github.com/aeplay/chunky', 'https://crates.io/crates/chunky']"
GHSA-45p7-c959-rgcm,ckb,https://github.com/nervosnetwork/ckb,[],2021-08-02 21:57:02+00:00,2021-08-25T21:01:18Z,"[('0', '0.40.0')]","Process crashes when the cell used as DepGroup is not alive
","### Impact

It's easy to create a malign transaction which uses the dead cell as the DepGroup in the DepCells. The transaction can crash all the receiving nodes.
",nan,['https://github.com/nervosnetwork/ckb/security/advisories/GHSA-45p7-c959-rgcm']
GHSA-2969-8hh9-57jc,ckb,https://github.com/nervosnetwork/ckb,['Resource Management'],2022-01-07 17:53:54+00:00,2022-01-06T22:09:49Z,"[('0.0.0-0', '0.40.0'), ('0', '0.40.0')]","Remote memory exhaustion in ckb
Allocation of Resources Without Limits or Throttling in ckb
","In the ckb sync protocol, SyncState maintains a HashMap called 'misbehavior' that keeps a score of a peer's violations of the protocol. This HashMap is keyed to PeerIndex (an alias for SessionId), and entries are never removed from it. SessionId is an integer that increases monotonically with every new connection.

A remote attacker can manipulate this HashMap to grow forever, resulting in degraded performance and ultimately a panic on allocation failure or being killed by the OS, depending on the platform.

This is a critical severity security bug. It could be exploited to create a targeted or network-wide denial of service, to reduce the hash power of the network as part of a 51% attack, and perhaps in other creative ways.
An issue was discovered in the ckb crate before 0.40.0 for Rust. Remote attackers may be able to conduct a 51% attack against the Nervos CKB blockchain by triggering an inability to allocate memory for the misbehavior HashMap.
",nan,"['https://github.com/nervosnetwork/ckb/security/advisories/GHSA-48vq-8jqv-gm6f', 'https://crates.io/crates/ckb', 'https://github.com/nervosnetwork/ckb', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/ckb/RUSTSEC-2021-0108.md', 'https://nvd.nist.gov/vuln/detail/CVE-2021-45699', 'https://rustsec.org/advisories/RUSTSEC-2021-0108.html']"
RUSTSEC-2021-0107,ckb,https://github.com/nervosnetwork/ckb,[],2021-09-10 15:50:27+00:00,2021-07-25T12:00:00Z,"[('0.0.0-0', '0.40.0'), ('0', '0.40.0')]","RPC call failure in ckb
Miner fails to get block template when a cell used as a cell dep has been destroyed.
","An issue was discovered in the ckb crate before 0.40.0 for Rust. A get_block_template RPC call may fail in situations where it is supposed to select a Nervos CKB blockchain transaction with a higher fee rate than another transaction.
## Impact

The RPC get_block_template fails when a cell has been used as a cell dep and an input in the different transactions.

Say cell C is used as a dep group in the transaction A, and is destroyed in the transaction B.

The node adds transaction A first, then B into the transaction pool. They are both valid. But when generating the block template, if the fee rate of B is higher, it comes before A, which will invalidate A. Currently the RPC get_block_template will fail instead of dropping A.

## Patch

First, the get_block_template should not fail but dropping the conflict transactions.

Then we can propose solution to this issue. Here is an example. When a transaction is added to the pool, the pool must consider it depending on all the transactions which dep cell (direct or indirect via dep group) has been destroyed in this transaction. Because future transactions using the destroyed cells as dep will be rejected, the spending transaction only need to wait for all the existing dep transactions on chain.

## Workaround

    Submit transaction B when A is already on chain.
    Let B depend on A explicitly, there are several solutions:
        a. Add any output cell on A as a dep cell or input in B.
        b. Merge A and B. CKB allows using the same cell as both dep and input in the same transaction.
    Ensure the fee rate of B is less than A so A always has higher priority.
",Critical,"['https://rustsec.org/advisories/RUSTSEC-2021-0107.html', 'https://crates.io/crates/ckb', 'https://github.com/nervosnetwork/ckb', 'https://nvd.nist.gov/vuln/detail/CVE-2021-45698', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/ckb/RUSTSEC-2021-0107.md', 'https://github.com/nervosnetwork/ckb/security/advisories/GHSA-v666-6w97-pcwm']"
GHSA-cw98-cx2m-9qqg,ckb,https://github.com/nervosnetwork/ckb,['Resource Management'],2022-01-07 17:53:19+00:00,2022-01-06T22:10:08Z,"[('0.0.0-0', '0.40.0'), ('0', '0.40.0')]","Process crashes when the cell used as DepGroup is not alive
Denial of Service in ckb
","It's easy to create a malign transaction which uses the dead cell as the DepGroup in the DepCells. The transaction can crash all the receiving nodes.
An issue was discovered in the ckb crate before 0.40.0 for Rust. Attackers can cause a denial of service (Nervos CKB blockchain node crash) via a dead call that is used as a DepGroup.
",nan,"['https://crates.io/crates/ckb', 'https://github.com/nervosnetwork/ckb', 'https://rustsec.org/advisories/RUSTSEC-2021-0109.html', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/ckb/RUSTSEC-2021-0109.md', 'https://nvd.nist.gov/vuln/detail/CVE-2021-45700', 'https://github.com/nervosnetwork/ckb/security/advisories/GHSA-45p7-c959-rgcm']"
GHSA-j35p-q24r-5367,ckb,https://github.com/nervosnetwork/ckb,[],2022-04-22 20:23:04+00:00,2022-04-22T20:23:04Z,"[('0', '0.43.1')]","Dep Group Remote Memory Exhaustion (Denial of Service) in ckb
","### Impact
A remote attacker could exploit this vulnerability to exhaust ckb process memory of an affected node.

### Patches
Upgrade to 0.43.1 or later.

### References
After resolving the outpoints of one dep group, we put the corresponding content into a vec ( https://github.com/nervosnetwork/ckb/blob/v0.42.0/util/types/src/core/cell.rs#L600-L617 ), there is a vulnerability to a memory dos attack because there is no determination of whether the outpoints is duplicated.

PoC:
```
before send dos tx rss:
105700

after rss:
2306932
```

DoS cost: 25.6 KB * 150 + dep_tx out_points capacity ( 36 * 150 * 100 = 540000 ) = 4380000 CKB
Send 50 dos_tx, memory exhausted: (25.6 KB * 150  * 100) * 50 = 19.2 GB


",nan,"['https://github.com/nervosnetwork/ckb/security/advisories/GHSA-j35p-q24r-5367', 'https://github.com/nervosnetwork/ckb', 'https://github.com/nervosnetwork/ckb/blob/v0.42.0/util/types/src/core/cell.rs#L600-L617']"
GHSA-48vq-8jqv-gm6f,ckb,https://github.com/nervosnetwork/ckb,['Resource Management'],2021-08-02 21:53:41+00:00,2021-08-25T21:01:23Z,"[('0', '0.40.0')]","Remote memory exhaustion in ckb
","In the ckb sync protocol, SyncState maintains a HashMap called 'misbehavior' that keeps a score of a peer's violations of the protocol. This HashMap is keyed to PeerIndex (an alias for SessionId), and entries are never removed from it. SessionId is an integer that increases monotonically with every new connection.

A remote attacker can manipulate this HashMap to grow forever, resulting in degraded performance and ultimately a panic on allocation failure or being killed by the OS, depending on the platform.

This is a critical severity security bug. It could be exploited to create a targeted or network-wide denial of service, to reduce the hash power of the network as part of a 51% attack, and perhaps in other creative ways.

An attack is trivial:

1. connect to another node
2. send an invalid sync protocol request, such as `SendHeaders` for non-consecutive blocks
3. disconnect
4. repeat
",nan,['https://github.com/nervosnetwork/ckb/security/advisories/GHSA-48vq-8jqv-gm6f']
GHSA-v666-6w97-pcwm,ckb,https://github.com/nervosnetwork/ckb,['Synchronization'],2021-08-02 21:55:20+00:00,2021-08-25T21:01:21Z,"[('0', '0.40.0')]","Miner fails to get block template when a cell used as a cell dep has been destroyed.
","### Impact

The RPC `get_block_template` fails when a cell has been used as a cell dep and an input in the different transactions.

Say cell C is used as a dep group in the transaction A, and is destroyed in the transaction B.

The node adds transaction A first, then B into the transaction pool. They are both valid. But when generating the block template, if the fee rate of B is higher, it comes before A, which will invalidate A. Currently the RPC `get_block_template` will fail instead of dropping A.

### Patch

First, the `get_block_template` should not fail but dropping the conflict transactions.

Then we can propose solution to this issue. Here is an example. When a transaction is added to the pool, the pool must consider it depending on all the transactions which dep cell (direct or indirect via dep group) has been destroyed in this transaction. Because future transactions using the destroyed cells as dep will be rejected, the spending transaction only need to wait for all the existing dep transactions on chain.

### Workaround

1. Submit transaction B when A is already on chain.
2. Let B depend on A explicitly, there are several solutions:
    * a. Add any output cell on A as a dep cell or input in B.
    * b. Merge A and B. CKB allows using the same cell as both dep and input in the same transaction.
3. Ensure the fee rate of B is less than A so A always has higher priority.

",nan,['https://github.com/nervosnetwork/ckb/security/advisories/GHSA-v666-6w97-pcwm']
RUSTSEC-2018-0004,claxon,https://github.com/ruuda/claxon,['Exception Management'],2021-10-19 22:14:35+00:00,2018-08-25T12:00:00Z,"[('0.0.0-0', '0.3.2'), ('0', '0.4.1')]","Uninitialized memory exposure in claxon
Malicious input could cause uninitialized memory to be exposed
","An issue was discovered in the claxon crate before 0.4.1 for Rust. Uninitialized memory can be exposed because certain decode buffer sizes are mishandled.
Affected versions of Claxon made an invalid assumption about the decode buffer
size being a multiple of a value read from the bitstream. This could cause parts
of the decode buffer to not be overwritten. If the decode buffer was newly
allocated and uninitialized, this uninitialized memory could be exposed.

This allows an attacker to observe parts of the uninitialized memory in the
decoded audio stream.

The flaw was corrected by checking that the value read from the bitstream divides
the decode buffer size, and returning a format error if it does not. If an error
is returned, the decode buffer is not exposed. Regression tests and an
additional fuzzer have been added to prevent similar flaws in the future.
",Medium,"['https://github.com/ruuda/claxon', 'https://rustsec.org/advisories/RUSTSEC-2018-0004.html', 'https://crates.io/crates/claxon', 'https://github.com/ruuda/claxon/commit/8f28ec275e412dd3af4f3cda460605512faf332c', 'https://nvd.nist.gov/vuln/detail/CVE-2018-20992']"
RUSTSEC-2021-0087,columnar,https://github.com/frankmcsherry/columnar.git,"['Memory Access', 'Exception Management']",2021-08-22 01:27:48+00:00,2021-01-07T12:00:00Z,"[('0.0.0-0', None), ('0', None)]","Use of Uninitialized Resource in columnar.
columnar: `Read` on uninitialized buffer may cause UB (ColumnarReadExt::read_typed_vec())
","An issue was discovered in the columnar crate through 2021-01-07 for Rust. ColumnarReadExt::read_typed_vec may read from uninitialized memory locations.
Affected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation (`ColumnarReadExt::read_typed_vec()`).

Arbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.
Reading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.
",Critical,"['https://crates.io/crates/columnar', 'https://github.com/frankmcsherry/columnar.git', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/columnar/RUSTSEC-2021-0087.md', 'https://rustsec.org/advisories/RUSTSEC-2021-0087.html', 'https://github.com/frankmcsherry/columnar/issues/6', 'https://nvd.nist.gov/vuln/detail/CVE-2021-45685']"
RUSTSEC-2019-0015,compact_arena,https://github.com/llogiq/compact_arena,"['Memory Access', 'Memory Management']",2021-10-19 22:14:35+00:00,2019-05-21T12:00:00Z,"[('0.0.0-0', '0.4.0'), ('0', '0.4.0')]","Out of bounds access in compact_arena
Flaw in generativity allows out-of-bounds access
","An issue was discovered in the compact_arena crate before 0.4.0 for Rust. Generativity is mishandled, leading to an out-of-bounds write or read.
Affected versions of this crate did not properly implement the generativity,
because the invariant lifetimes were not necessarily `drop`ped.

This allows an attacker to mix up two arenas, using indices created from one
arena with another one. This might lead to an out-of-bounds read or write
access into the memory reserved for the arena.

The flaw was corrected by implementing generativity correctly in version 0.4.0.
",Critical,"['https://rustsec.org/advisories/RUSTSEC-2019-0015.html', 'https://github.com/llogiq/compact_arena', 'https://crates.io/crates/compact_arena', 'https://nvd.nist.gov/vuln/detail/CVE-2019-16139', 'https://github.com/llogiq/compact_arena/issues/22']"
RUSTSEC-2021-0132,compu-brotli-sys,https://github.com/DoumanAsh/compu-brotli-sys,['Memory Management'],2021-12-21 22:27:44+00:00,2021-12-20T12:00:00Z,"[('0.0.0-0', '1.0.9')]","Integer overflow in the bundled Brotli C library
","A buffer overflow exists in the Brotli library versions prior to 1.0.8 where an attacker controlling the input length of a ""one-shot"" decompression request to a script can trigger a crash, which happens when copying over chunks of data larger than 2 GiB.

If one cannot update the C library, its authors recommend to use the ""streaming"" API as opposed to the ""one-shot"" API, and impose chunk size limits.
",nan,"['https://github.com/google/brotli/releases/tag/v1.0.9', 'https://crates.io/crates/compu-brotli-sys', 'https://rustsec.org/advisories/RUSTSEC-2021-0132.html']"
GHSA-xmr7-v725-2jjr,comrak,https://github.com/kivikakk/comrak,['Tainted Input'],2021-08-19 17:34:25+00:00,2021-08-25T20:52:12Z,"[('0', '0.9.1'), ('0.0.0-0', '0.9.1')]","XSS in `comrak`
XSS in comrak
","The [comrak](https://github.com/kivikakk/comrak) we were matching unsafe URL prefixes, such as `data:` or `javascript:` , in a case-sensitive manner. This meant prefixes like `Data:` were untouched.
An issue was discovered in the comrak crate before 0.9.1 for Rust. XSS can occur because the protection mechanism for data: and javascript: URIs is case-sensitive, allowing (for example) Data: to be used in an attack.
",Medium,"['https://crates.io/crates/comrak', 'https://rustsec.org/advisories/RUSTSEC-2021-0026.html', 'https://github.com/kivikakk/comrak', 'https://github.com/kivikakk/comrak/releases/tag/0.9.1', 'https://nvd.nist.gov/vuln/detail/CVE-2021-27671']"
RUSTSEC-2021-0063,comrak,https://github.com/kivikakk/comrak,['Tainted Input'],2021-11-06 20:37:35+00:00,2021-05-04T12:00:00Z,"[('0.0.0-0', '0.10.1'), ('0', '0.10.1')]","Cross-site Scripting in comrak
XSS in `comrak`
","An issue was discovered in the comrak crate before 0.10.1 for Rust. It mishandles & characters, leading to XSS via &# HTML entities.
[comrak](https://github.com/kivikakk/comrak) operates by default in a ""safe""
mode of operation where unsafe content, such as arbitrary raw HTML or URLs with
non-standard schemes, are not permitted in the output.  This is per the
reference GFM implementation, [cmark-gfm](https://github.com/github/cmark).

Ampersands were not being correctly escaped in link targets, making it possible
to fashion unsafe URLs using schemes like `data:` or `javascript:` by entering
them as HTML entities, e.g. `&#x64&#x61&#x74&#x61&#x3a`.  The intended
behaviour, demonstrated upstream, is that these should be escaped and therefore
harmless, but this behaviour was broken in comrak.
",Medium,"['https://nvd.nist.gov/vuln/detail/CVE-2021-38186', 'https://crates.io/crates/comrak', 'https://github.com/kivikakk/comrak/releases/tag/0.10.1', 'https://github.com/kivikakk/comrak', 'https://rustsec.org/advisories/RUSTSEC-2021-0063.html']"
RUSTSEC-2020-0092,concread,https://github.com/kanidm/concread,['Synchronization'],2021-10-19 22:14:35+00:00,2020-11-13T12:00:00Z,"[('0.0.0-0', '0.2.6'), ('0', '0.2.6')]","Data races in concread
Send/Sync bound needed on V in `impl Send/Sync for ARCache<K, V>`
","An issue was discovered in the concread crate before 0.2.6 for Rust. Attackers can cause an ARCache<K,V> data race by sending types that do not implement Send/Sync.
Affected versions of this crate unconditionally implemented `Send`/`Sync` traits for `ARCache<K, V>` type.

This allows users to send/access types that do not implement `Send`/`Sync`, which can cause a data race.

The flaw was corrected in the 0.2.6 release by adding bounds `K: Send + Sync` & `V: Send + Sync` to affected `Send`/`Sync` trait implementations.
",Medium,"['https://github.com/kanidm/concread/issues/48', 'https://github.com/kanidm/concread', 'https://crates.io/crates/concread', 'https://rustsec.org/advisories/RUSTSEC-2020-0092.html', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35928']"
GHSA-3jc5-5hc5-33gj,conquer-once,https://github.com/oliver-giersch/conquer-once.git,"['Memory Access', 'Synchronization', 'Memory Management']",2021-08-19 18:51:18+00:00,2021-08-25T20:50:49Z,"[('0.0.0-0', '0.3.2'), ('0', '0.3.2')]","conquer-once's OnceCell lacks Send bound for its Sync trait.
Data races in conquer-once
","Affected versions of `conquer-once` implements `Sync` for its `OnceCell` type
without restricting it to `Send`able types.

This allows non-`Send` but `Sync` types such as `MutexGuard` to be sent across
threads leading to undefined behavior and memory corruption in concurrent
programs.

The issue was fixed by adding a `Send` constraint to `OnceCell`.
An issue was discovered in the conquer-once crate before 0.3.2 for Rust. Thread crossing can occur for a non-Send but Sync type, leading to memory corruption.
",High,"['https://github.com/oliver-giersch/conquer-once', 'https://github.com/oliver-giersch/conquer-once/issues/3', 'https://crates.io/crates/conquer-once', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36208', 'https://rustsec.org/advisories/RUSTSEC-2020-0101.html']"
RUSTSEC-2020-0117,conqueue,https://github.com/longshorej/conqueue,"['Memory Access', 'Synchronization', 'Memory Management']",2021-10-19 22:14:35+00:00,2020-11-24T12:00:00Z,"[('0.0.0-0', '0.4.0'), ('0', '0.4.0')]","Data race in conqueue
QueueSender<T>/QueueReceiver<T>: Send/Sync impls need `T: Send`
","Affected versions of this crate unconditionally implemented `Send`/`Sync` for `QueueSender<T>`,
allowing to send non-Send `T` to other threads by invoking `(&QueueSender<T>).send()`.

This fails to prevent users from creating data races by sending types like `Rc<T>` or `Arc<Cell<T>>` to other threads, which can lead to memory corruption.

The flaw was corrected in commit 1e462c3 by imposing `T: Send` to both `Send`/`Sync` impls for `QueueSender<T>`/`QueueReceiver<T>`.
Affected versions of this crate unconditionally implemented `Send`/`Sync` for `QueueSender<T>`,
allowing to send non-Send `T` to other threads by invoking `(&QueueSender<T>).send()`.

This fails to prevent users from creating data races by sending types like `Rc<T>` or `Arc<Cell<T>>` to other threads, which can lead to memory corruption.

The flaw was corrected in commit 1e462c3 by imposing `T: Send` to both `Send`/`Sync` impls for `QueueSender<T>`/`QueueReceiver<T>`.
",High,"['https://github.com/longshorej/conqueue/issues/9', 'https://rustsec.org/advisories/RUSTSEC-2020-0117.html', 'https://crates.io/crates/conqueue', 'https://github.com/longshorej/conqueue', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36437']"
GHSA-cv7x-6rc6-pq5v,containers,https://github.com/strake/containers.rs,['Memory Management'],2021-08-19 18:40:39+00:00,2021-08-25T20:53:05Z,"[('0', '0.9.11'), ('0.0.0-0', '0.9.11')]","panic safety: double drop may happen within `util::{mutate, mutate2}`
Double free in containers
","Upon panic in a user-provided function `f`, `fn mutate()` & `fn mutate2` drops twice a same object.

Affected versions of this crate did not guard against double drop while temporarily duplicating an object's ownership with `ptr::read()`.

Dropping a same object can result in memory corruption.

The flaw was corrected in version ""0.9.11"" by fixing the code to abort upon panic.
An issue was discovered in the containers crate before 0.9.11 for Rust. When a panic occurs, a util::{mutate,mutate2} double drop can be performed.
",Critical,"['https://github.com/strake/containers.rs', 'https://nvd.nist.gov/vuln/detail/CVE-2021-25907', 'https://rustsec.org/advisories/RUSTSEC-2021-0010.html', 'https://crates.io/crates/containers', 'https://github.com/strake/containers.rs/issues/2']"
RUSTSEC-2020-0125,convec,https://github.com/krl/convec,"['Memory Access', 'Synchronization', 'Memory Management']",2021-10-19 22:14:35+00:00,2020-11-24T12:00:00Z,"[('0.0.0-0', None), ('0', None)]","Data races in convec
convec::ConVec<T> unconditionally implements Send/Sync
","Affected versions of this crate unconditionally implement Send/Sync for `ConVec<T>`.
This allows users to insert `T` that is not Send or not Sync.

This allows users to create data races by using non-Send types like `Arc<Cell<_>>` or `Rc<_>` as `T` in `ConVec<T>`. It is also possible to create data races by using types like `Cell<_>` or `RefCell<_>` as `T` (types that are `Send` but not `Sync`).
Such data races can lead to memory corruption.
Affected versions of this crate unconditionally implement Send/Sync for `ConVec<T>`.
This allows users to insert `T` that is not Send or not Sync.

This allows users to create data races by using non-Send types like `Arc<Cell<_>>` or `Rc<_>` as `T` in `ConVec<T>`. It is also possible to create data races by using types like `Cell<_>` or `RefCell<_>` as `T` (types that are `Send` but not `Sync`).
Such data races can lead to memory corruption.
",High,"['https://crates.io/crates/convec', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36445', 'https://github.com/krl/convec', 'https://github.com/krl/convec/issues/2', 'https://rustsec.org/advisories/RUSTSEC-2020-0125.html']"
GHSA-vjrq-cg9x-rfjp,cookie,https://github.com/SergioBenitez/cookie-rs,['Tainted Input'],2021-08-19 21:25:22+00:00,2021-08-25T20:43:02Z,"[('0', '0.7.6'), ('0.6.0', '0.6.2')]","Large cookie Max-Age values can cause a denial of service
Improper Input Validation in cookie
","Affected versions of this crate use the `time` crate and the method
`Duration::seconds` to parse the `Max-Age` duration cookie setting. This method
will panic if the value is greater than 2^64/1000 and less than or equal to
2^64, which can result in denial of service for a client or server.

This flaw was corrected by explicitly checking for the `Max-Age` being in this
integer range and clamping the value to the maximum duration value.
An issue was discovered in the cookie crate before 0.7.6 for Rust. Large integers in the Max-Age of a cookie cause a panic.
",High,"['https://rustsec.org/advisories/RUSTSEC-2017-0005.html', 'https://github.com/alexcrichton/cookie-rs', 'https://crates.io/crates/cookie', 'https://nvd.nist.gov/vuln/detail/CVE-2017-18589', 'https://github.com/alexcrichton/cookie-rs/pull/86']"
GHSA-3r3g-g73x-g593,coreos-installer,https://github.com/coreos/coreos-installer,['Cryptography'],2022-03-15 00:15:58+00:00,2021-10-12T16:06:47Z,"[('0', '0.10.1')]","Improper Verification of Cryptographic Signature in coreos
","### Impact

coreos-installer fails to correctly verify GPG signatures when decompressing gzip-compressed artifacts.  This allows bypass of signature verification in cases where coreos-installer decompresses a downloaded OS image, allowing an attacker who can modify the OS image to compromise a newly-installed system.

Default installations from ISO or PXE media in Fedora CoreOS, RHEL CoreOS, and RHEL for Edge are **not** affected, as coreos-installer installs from an OS image shipped as part of the install media.

These flows are affected:

1.  Installing with `--image-file`, `--image-url`, or `coreos.inst.image_url`.  For example, if a user has a local mirror of installation images, an attacker could replace an image with a gzip-compressed alternative (even if the file extension is `.xz`).  The result:

    ```
    $ coreos-installer install --image-url http://localhost:8080/image.xz /dev/loop0
    Downloading image from http://localhost:8080/image.xz
    Downloading signature from http://localhost:8080/image.xz.sig
    > Read disk 749.9 MiB/749.9 MiB (100%)
    gpg: Signature made Mon 20 Sep 2021 02:41:50 PM EDT
    gpg: using RSA key 8C5BA6990BDB26E19F2A1A801161AE6945719A39
    gpg: BAD signature from ""Fedora (34) <fedora-34-primary@fedoraproject.org>"" [ultimate]
    Install complete.
    ```

    Notice that GPG reports a bad signature, but coreos-installer continues anyway.  Automation that relies on coreos-installer's exit status will not notice either.

2. `coreos-installer download --decompress --image-url`:

    ```
    $ coreos-installer download --decompress --image-url http://localhost:8080/image.xz
    > Read disk 749.9 MiB/749.9 MiB (100%)
    gpg: Signature made Mon 20 Sep 2021 02:41:50 PM EDT
    gpg: using RSA key 8C5BA6990BDB26E19F2A1A801161AE6945719A39
    gpg: BAD signature from ""Fedora (34) <fedora-34-primary@fedoraproject.org>"" [ultimate]
    ./image
    ```

    Again, coreos-installer reports success.

3. Installing with default parameters, when **not** installing from the image built into live ISO or PXE media, if the hosting service is compromised or if an active attacker gains control of the HTTPS response.

4. `coreos-installer download --decompress` if the hosting service is compromised or if an active attacker gains control of the HTTPS response.

### Patches

The vulnerability is [fixed](https://github.com/coreos/coreos-installer/pull/659) in coreos-installer 0.10.1.

### Workarounds

For `coreos-installer download`, do not use the `-d` or `--decompress` options.

For `coreos-installer install`, manually inspect the stderr output.  If `BAD signature` appears, do not boot from the target disk.  Note, however, that some OS services may have already accessed data on the compromised disk.

### References

For more information, see [PR 655](https://github.com/coreos/coreos-installer/pull/655).

### For more information

If you have any questions or comments about this advisory, [open an issue in coreos-installer](https://github.com/coreos/coreos-installer/issues/new/choose) or email the CoreOS [development mailing list](https://lists.fedoraproject.org/archives/list/coreos@lists.fedoraproject.org/).
",High,"['https://github.com/coreos/coreos-installer/pull/659/commits/ad243c6f0eff2835b2da56ca5f7f33af76253c89', 'https://github.com/coreos/coreos-installer', 'https://nvd.nist.gov/vuln/detail/CVE-2021-20319', 'https://bugzilla.redhat.com/show_bug.cgi?id=2011862', 'https://github.com/coreos/coreos-installer/pull/655', 'https://github.com/coreos/coreos-installer/security/advisories/GHSA-3r3g-g73x-g593']"
GHSA-862g-9h5m-m3qv,coreos-installer,https://github.com/coreos/coreos-installer,[],2021-11-04 17:11:09+00:00,2021-11-08T18:01:13Z,"[('0', '0.10.0')]","coreos-installer < 0.10.0 writes world-readable Ignition config to installed system
","### Impact
On systems installed with coreos-installer before 0.10.0, the user-provided Ignition config was written to `/boot/ignition/config.ign` with world-readable permissions, granting unprivileged users access to any secrets included in the config.

Default configurations of Fedora CoreOS and RHEL CoreOS do not include any unprivileged user accounts.  In addition, instances launched from a cloud image, and systems provisioned with the `ignition.config.url` kernel argument, do not use the `config.ign` file and are unaffected.

### Patches
coreos-installer 0.10.0 and later [writes](https://github.com/coreos/coreos-installer/pull/571) the Ignition config with restricted permissions.

### Workarounds

On Fedora CoreOS systems installed from version 34.20210711.3.0 (stable), 34.20210711.2.0 (testing), 34.20210711.1.1 (next) and later, the `/boot/ignition` directory and its contents are removed after provisioning is complete. All Fedora CoreOS systems that have updated to these versions or later have automatically removed the `/boot/ignition` directory and no action is required.

On other systems, `/boot/ignition/config.ign` can be removed manually, as it is not used after provisioning is complete:

```
sudo mount -o remount,rw /boot
sudo rm -rf /boot/ignition
```

### References
For more information, see https://github.com/coreos/fedora-coreos-tracker/issues/889.

### For more information
If you have any questions or comments about this advisory, [open an issue in coreos-installer](https://github.com/coreos/coreos-installer/issues/new/choose) or email the CoreOS [development mailing list](https://lists.fedoraproject.org/archives/list/coreos@lists.fedoraproject.org/).
",nan,"['https://github.com/coreos/coreos-installer/commit/2a36405339c87b16ed6c76e91ad5b76638fbdb0c', 'https://github.com/coreos/coreos-installer/', 'https://github.com/coreos/coreos-installer/security/advisories/GHSA-862g-9h5m-m3qv', 'https://github.com/coreos/coreos-installer/releases/tag/v0.10.0']"
RUSTSEC-2021-0099,cosmos_sdk,https://github.com/cosmos/cosmos-rust/tree/main/cosmrs,[],2021-08-25 14:54:10+00:00,2021-08-25T12:00:00Z,"[('0.0.0-0', None)]","Crate has been renamed to `cosmrs`
","The `cosmos_sdk` crate, which provides a basic Rust SDK for the Cosmos ecosystem,
has rebranded to CosmRS in the spirit of other projects like CosmJS and CosmWasm.

You can find the new home here:

https://github.com/cosmos/cosmos-rust/tree/main/cosmrs

The new crate name is `cosmrs`:

https://crates.io/crates/cosmrs
",nan,"['https://rustsec.org/advisories/RUSTSEC-2021-0099.html', 'https://github.com/cosmos/cosmos-rust/issues/113', 'https://crates.io/crates/cosmos_sdk']"
RUSTSEC-2021-0064,cpuid-bool,https://github.com/RustCrypto/utils/tree/master/cpufeatures,[],2021-05-06 23:45:32+00:00,2021-05-06T12:00:00Z,"[('0.0.0-0', None)]","`cpuid-bool` has been renamed to `cpufeatures`
","Please use the `cpufeatures`` crate going forward:

<https://github.com/RustCrypto/utils/tree/master/cpufeatures>

There will be no further releases of `cpuid-bool`.
",nan,"['https://crates.io/crates/cpuid-bool', 'https://github.com/RustCrypto/utils/pull/381', 'https://rustsec.org/advisories/RUSTSEC-2021-0064.html']"
GHSA-hpqh-2wqx-7qp5,cranelift-codegen,https://github.com/bytecodealliance/wasmtime,['Memory Access'],2022-04-26 18:11:37+00:00,2021-08-25T21:01:55Z,"[('0', '0.73.1')]","Memory access due to code generation flaw in Cranelift module
","There is a bug in 0.73.0 of the Cranelift x64 backend that can create a scenario that could result in a potential sandbox escape in a WebAssembly module.  Users of versions 0.73.0 of Cranelift should upgrade to either 0.73.1 or 0.74 to remediate this vulnerability.  Users of Cranelift prior to 0.73.0 should update to 0.73.1 or 0.74 if they were not using the old default backend.

### Description

This bug was introduced in the new backend on 2020-09-08 and first included in a release on 2020-09-30, but the new backend was not the default prior to 0.73.0. The recently-released version 0.73.0 with default settings, and prior versions with an explicit build flag to select the new backend, are vulnerable.  The bug in question performs a sign-extend instead of a zero-extend on a value loaded from the stack, under a specific set of circumstances.  If those circumstances occur, the bug could allow access to memory addresses up to 2GiB before the start of the heap allocated for the WebAssembly module.

If the heap bound is larger than 2GiB, then it would be possible to read memory from a computable range dependent on the size of the heap's bound.  

The impact of this bug is highly dependent on heap implementation; specifically:
* if the heap has bounds checks, and
* does not rely exclusively on guard pages, and 
* the heap bound is 2GiB or smaller 

then this bug cannot be used to reach memory from another WebAssembly module heap.

The impact of the vulnerability is mitigated if there is no memory mapped in the range accessible using this bug, for example, if there is a 2 GiB guard region before the WebAssembly module heap.

The bug in question performs a sign-extend instead of a zero-extend on a value loaded from the stack when the register allocator reloads a spilled integer value narrower than 64 bits. This interacts poorly with another optimization: the instruction selector elides a 32-to-64-bit zero-extend operator when we know that an instruction producing a 32-bit value actually zeros the upper 32 bits of its destination register. Hence, we rely on these zeroed bits, but the type of the value is still i32, and the spill/reload reconstitutes those bits as the sign extension of the i32s MSB.

The issue would thus occur when:
* An i32 value is greater than or equal to 0x8000_0000;
* The value is spilled and reloaded by the register allocator due to high register pressure in the program between the values definition and its use;
* The value is produced by an instruction that we know to be ""special"" in that it zeroes the upper 32 bits of its destination: add, sub, mul, and, or;
* The value is then zero-extended to 64 bits;
* The resulting 64-bit value is used.

Under these circumstances there is a potential sandbox escape when the i32 value is a pointer. The usual code emitted for heap accesses zero-extends the WebAssembly heap address, adds it to a 64-bit heap base, and accesses the resulting address. If the zero-extend becomes a sign-extend, the module could reach backward and access memory up to 2GiB before the start of its heap.

This bug was identified by developers at Fastly following a report from Javier Cabrera Arteaga, KTH Royal Institute of Technology, with support from project Trustful of Stiftelsen fr Strategisk Forskning.  In addition to supporting the analysis and remediation of this vulnerability, Fastly will publish a related Fastly Security Advisory at [https://www.fastly.com/security-advisories](https://www.fastly.com/security-advisories).

In addition to assessing the nature of the code generation bug in Cranelift, we have also determined that under specific circumstances, both Lucet and Wasmtime using this version of Cranelift may be exploitable.

### General Impact to Lucet

Lucet inherits the heap address computation and bounds-checks of Cranelift, which it uses as its backend code generator. Of particular importance specifically is the address-space layout used by Lucet. In the default configuration for Lucet, only a single module is running, and therefore it is not possible to access memory from another module.

By default, the open source implementation of Lucet uses a maximum heap size of 4 GiB, and an instance slot size of 8 GiB, when invoking an instance from the lucet-wasi command-line tool. These settings are within the range of vulnerability described above, but only a single instance is running, so there is no other instance to read. When embedding the runtime (for example, in a long-running daemon), the default for the heap size as described in the source is 1MB; with this setting, the runtime is not vulnerable.

Lucet allocates its WebAssembly module instances into ""instance slots"", which are contiguous zones of virtual address space that contain the VM context at the bottom, the WebAssembly heap in the next page after that, a guard region in the middle, and other data at the top: the stack and the globals.

If the instance slot size is less than (max heap) + 2GiB, then the lowest accessible address using the bug will overlap with the prior instances heap. If the size of VM context + stack + globals is greater than (4GiB - heap limit), then the highest accessible address using the bug will overlap with this critical data. If neither of these conditions are true, the bug should only result in an access to the prior instances guard region.

Generally, if the limit is between 2GiB and 4GiB - ~1MB (depending on stack/global size) and the instance slot size is less than 6GiB, the configuration is vulnerable. If the limit is greater than 4GiB - ~1MB, the configuration is vulnerable regardless of instance slot size. Otherwise, the configuration is not vulnerable.

### General Impact on Wasmtime

In Wasmtime, the same Cranelift heap address computations and heap types are used as above. The memory layout, however, is slightly different, with different outcomes:
* With the mmap implementation impact is mitigated probabilistically if ASLR is enabled.
* With the pooling allocator, the vulnerability only exists if a memory reservation size lower than the default of 6GB is used.

With the default mmap-based instance memory implementation, Wasmtime uses mmap() to allocate a block of memory large enough for the heap and guard region, as specified in its configuration. If the underlying OS implements ASLR (modern Linux, macOS and Windows do) then this address will be randomized, and the region below it will (probabilistically) be free. Hence, the bug is mitigated probabilistically in the default configuration if ASLR is enabled.

If using the pooling allocator, the vulnerability exists if instance memory size (`memory_reservation_size` in InstanceLimit) is strictly less than 6GiB (4 GiB + 2 GiB of guard pages). The default is 6GiB, so the vulnerability is masked in the default pooling allocator configuration.

",High,"['https://www.fastly.com/security-advisories/memory-access-due-to-code-generation-flaw-in-cranelift-module', 'https://github.com/bytecodealliance/wasmtime/tree/main/cranelift', 'https://crates.io/crates/cranelift-codegen', 'https://github.com/bytecodealliance/wasmtime/commit/95559c01aaa7c061088a433040f31e8291fb09d0', 'https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-hpqh-2wqx-7qp5', 'https://github.com/RustSec/advisory-db/blob/main/crates/cranelift-codegen/RUSTSEC-2021-0067.md', 'https://nvd.nist.gov/vuln/detail/CVE-2021-32629']"
RUSTSEC-2021-0067,cranelift-codegen,https://github.com/bytecodealliance/wasmtime,"['Memory Access', 'Other', 'Memory Management']",2021-10-19 22:14:35+00:00,2021-05-21T12:00:00Z,"[('0.0.0-0', '0.73.1')]","Memory access due to code generation flaw in Cranelift module
","There is a bug in 0.73.0 of the Cranelift x64 backend that can create a
scenario that could result in a potential sandbox escape in a WebAssembly
module. Users of versions 0.73.0 of Cranelift should upgrade to either 0.73.1
or 0.74 to remediate this vulnerability. Users of Cranelift prior to 0.73.0
should update to 0.73.1 or 0.74 if they were not using the old default backend.

More details can be found in the GitHub Security Advisory at:

<https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-hpqh-2wqx-7qp5>
",High,"['https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-hpqh-2wqx-7qp5', 'https://rustsec.org/advisories/RUSTSEC-2021-0067.html', 'https://crates.io/crates/cranelift-codegen']"
GHSA-m833-jv95-mfjh,crayon,https://github.com/shawnscode/crayon,['Synchronization'],2021-08-19 20:56:31+00:00,2021-08-25T20:48:50Z,"[('0.0.0-0', None), ('0', None)]","Misbehaving `HandleLike` implementation can lead to memory safety violation
Memory safety violation in crayon
","Unsafe code in `ObjectPool` has time-of-check to time-of-use (TOCTOU) bug that
can eventually lead to a memory safety violation. `ObjectPool` and `HandlePool`
implicitly assumes that `HandleLike` trait methods are pure, i.e., they always
return the same value. However, this assumption is unsound since `HandleLike`
is a safe, public trait that allows a custom implementation.
An issue was discovered in the crayon crate through 2020-08-31 for Rust. A TOCTOU issue has a resultant memory safety violation via HandleLike.
",High,"['https://github.com/shawnscode/crayon', 'https://crates.io/crates/crayon', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35889', 'https://rustsec.org/advisories/RUSTSEC-2020-0037.html', 'https://github.com/shawnscode/crayon/issues/87']"
GHSA-c3cw-c387-pj65,crossbeam,https://github.com/crossbeam-rs/crossbeam,['Memory Management'],2021-08-19 21:24:34+00:00,2021-08-25T20:43:21Z,"[('0.4.0', '0.4.1'), ('0', '0.4.1')]","MsQueue and SegQueue suffer from double-free
Double free in crossbeam
","Even if an element is popped from a queue, crossbeam would run its
destructor inside the epoch-based garbage collector. This is a source
of double frees.

The flaw was corrected by wrapping elements inside queues in a
`ManuallyDrop`.

Thanks to @c0gent for reporting the issue.
An issue was discovered in the crossbeam crate before 0.4.1 for Rust. There is a double free because of destructor mishandling.
",Critical,"['https://github.com/crossbeam-rs/crossbeam-epoch', 'https://github.com/crossbeam-rs/crossbeam-epoch/issues/82', 'https://crates.io/crates/crossbeam', 'https://rustsec.org/advisories/RUSTSEC-2018-0009.html', 'https://nvd.nist.gov/vuln/detail/CVE-2018-20996']"
RUSTSEC-2022-0020,crossbeam,https://github.com/crossbeam-rs/crossbeam,[],2022-05-10 15:20:48+00:00,2022-05-10T12:00:00Z,"[('0.0.0-0', '0.7.0')]","`SegQueue` creates zero value of any type
","Affected versions of this crate called `mem::zeroed()` to create values of a user-supplied type `T`.
This is unsound e.g. if `T` is a reference type (which must be non-null).
 
The flaw was corrected by avoiding the use of `mem::zeroed()`, using `MaybeUninit` instead.
",nan,"['https://rustsec.org/advisories/RUSTSEC-2022-0020.html', 'https://crates.io/crates/crossbeam', 'https://github.com/crossbeam-rs/crossbeam/pull/458']"
RUSTSEC-2020-0052,crossbeam-channel,https://github.com/crossbeam-rs/crossbeam,"['Memory Access', 'Memory Management']",2021-01-04 17:02:59+00:00,2020-06-26T12:00:00Z,"[('0', '0.4.4'), ('0.4.3', '0.4.4')]","Undefined Behavior crossbeam-channel
Incorrect buffer size in crossbeam-channel
Undefined Behavior in bounded channel
","### Impact

The affected version of this crate's the `bounded` channel incorrectly assumes that `Vec::from_iter` has allocated capacity that same as the number of iterator elements. `Vec::from_iter` does not actually guarantee that and may allocate extra memory. The destructor of the `bounded` channel reconstructs `Vec` from the raw pointer based on the incorrect assumes described above. This is unsound and causing deallocation with the incorrect capacity when `Vec::from_iter` has allocated different sizes with the number of iterator elements.

### Patches

This has been fixed in crossbeam-channel 0.4.4.

We recommend users to upgrade to 0.4.4.

### References

See https://github.com/crossbeam-rs/crossbeam/pull/533, https://github.com/crossbeam-rs/crossbeam/issues/539, and https://github.com/RustSec/advisory-db/pull/425 for more details.

An issue was discovered in the crossbeam-channel crate before 0.4.4 for Rust. It has incorrect expectations about the relationship between the memory allocation and how many iterator elements there are.
The affected version of this crate's the `bounded` channel incorrectly assumes that `Vec::from_iter` has allocated capacity that same as the number of iterator elements. `Vec::from_iter` does not actually guarantee that and may allocate extra memory. The destructor of the `bounded` channel reconstructs `Vec` from the raw pointer based on the incorrect assumes described above. This is unsound and causing deallocation with the incorrect capacity when `Vec::from_iter` has allocated different sizes with the number of iterator elements.
",High,"['https://github.com/crossbeam-rs/crossbeam/issues/539', 'https://github.com/crossbeam-rs/crossbeam/security/advisories/GHSA-v5m7-53cv-f3hx', 'https://nvd.nist.gov/vuln/detail/CVE-2020-15254', 'https://github.com/crossbeam-rs/crossbeam', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35904', 'https://github.com/crossbeam-rs/crossbeam/pull/533', 'https://github.com/RustSec/advisory-db/pull/425', 'https://crates.io/crates/crossbeam-channel', 'https://rustsec.org/advisories/RUSTSEC-2020-0052.html']"
RUSTSEC-2022-0019,crossbeam-channel,https://github.com/crossbeam-rs/crossbeam,[],2022-05-10 15:20:48+00:00,2022-05-10T12:00:00Z,"[('0.0.0-0', '0.4.3')]","Channel creates zero value of any type
","Affected versions of this crate called `mem::zeroed()` to create values of a user-supplied type `T`.
This is unsound e.g. if `T` is a reference type (which must be non-null).
 
The flaw was corrected by avoiding the use of `mem::zeroed()`, using `MaybeUninit` instead.
",nan,"['https://github.com/crossbeam-rs/crossbeam/pull/458', 'https://rustsec.org/advisories/RUSTSEC-2022-0019.html', 'https://crates.io/crates/crossbeam-channel']"
GHSA-pqqp-xmhj-wgcw,crossbeam-deque,https://github.com/crossbeam-rs/crossbeam,"['Synchronization', 'Memory Management']",2021-08-10 17:02:12+00:00,2021-08-25T21:01:15Z,"[('0.0.0-0', '0.7.4'), ('0.8.0', '0.8.1'), ('0', '0.7.4')]","Data race in crossbeam-deque
Data race in crossbeam-deque
","In the affected version of this crate, the result of the race condition is that one or more tasks in the worker queue can be popped twice instead of other tasks that are forgotten and never popped. If tasks are allocated on the heap, this can cause double free and a memory leak. If not, this still can cause a logical bug.

Crates using `Stealer::steal`, `Stealer::steal_batch`, or `Stealer::steal_batch_and_pop` are affected by this issue.

Credits to @kmaork for discovering, reporting and fixing the bug.
### Impact

In the affected version of this crate, the result of the race condition is that one or more tasks in the worker queue can be popped twice instead of other tasks that are forgotten and never popped. If tasks are allocated on the heap, this can cause double free and a memory leak. If not, this still can cause a logical bug.

Crates using `Stealer::steal`, `Stealer::steal_batch`, or `Stealer::steal_batch_and_pop` are affected by this issue.

### Patches

This has been fixed in crossbeam-deque 0.8.1 and 0.7.4.

### Credits

This issue was reported and fixed by Maor Kleinberger.
",Critical,"['https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/OCLMH7B7B2MF55ET4NQNPH7JWISFX4RT/', 'https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/XFBZWCLG7AGLJO4A7K5IMJVPLSWZ5TJP/', 'https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/CY5T3FCE4MUYSPKEWICLVJBBODGJ6SZE/', 'https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LCIBFGBSL3JSVJQTNEDEIMZGZF23N2KE/', 'https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/AYBSLIYFANZLCYWOGTIYZUM26TJRH7WU/', 'https://github.com/crossbeam-rs/crossbeam/security/advisories/GHSA-pqqp-xmhj-wgcw', 'https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/EW5B2VTDVMJ6B3DA4VLMAMW2GGDCE2BK/', 'https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/7EZILHZDRGDPOBQ4KTW3E5PPMKLHGH5N/', 'https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/AWHNNBJCU4EHA2X5ZAMJMGLDUYS5FEPP/', 'https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/U3LSN3B43TJSFIOB3QLPBI3RCHRU5BLO/', 'https://nvd.nist.gov/vuln/detail/CVE-2021-32810', 'https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WGB2H35CTZDHOV3VLC5BM6VFGURLLVRP/', 'https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/RRPKBRXCRNGNMVFQPFD4LM3QKPEMBQQR/', 'https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/VQZIEJQBV3S72BHD5GKJQF3NVYNRV5CF/', 'https://crates.io/crates/crossbeam-deque', 'https://rustsec.org/advisories/RUSTSEC-2021-0093.html', 'https://github.com/crossbeam-rs/crossbeam', 'https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/TFUBWBYCPSSXTJGEAQ67CJUNQJBOCM26/', 'https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZQDIBB7VR3ER52FMSMNJPAWNDO5SITCE/']"
RUSTSEC-2022-0021,crossbeam-queue,https://github.com/crossbeam-rs/crossbeam,[],2022-05-10 15:20:48+00:00,2022-05-10T12:00:00Z,"[('0.0.0-0', '0.2.3')]","`SegQueue` creates zero value of any type
","Affected versions of this crate called `mem::zeroed()` to create values of a user-supplied type `T`.
This is unsound e.g. if `T` is a reference type (which must be non-null).
 
The flaw was corrected by avoiding the use of `mem::zeroed()`, using `MaybeUninit` instead.
",nan,"['https://crates.io/crates/crossbeam-queue', 'https://rustsec.org/advisories/RUSTSEC-2022-0021.html', 'https://github.com/crossbeam-rs/crossbeam/pull/458']"
GHSA-qc84-gqf4-9926,crossbeam-utils,https://github.com/crossbeam-rs/crossbeam,"['Memory Access', 'Synchronization']",2022-02-25 15:42:42+00:00,2022-02-16T22:36:21Z,"[('0', '0.8.7')]","Improper Restriction of Operations within the Bounds of a Memory Buffer and Race Condition in crossbeam-utils
","### Impact

The affected version of this crate incorrectly assumed that the alignment of `{i,u}64` was always the same as `Atomic{I,U}64`. 

However, the alignment of `{i,u}64` on a 32-bit target can be smaller than `Atomic{I,U}64`.

This can cause the following problems:

- Unaligned memory accesses
- Data race

Crates using `fetch_*` methods with `AtomicCell<{i,u}64>` are affected by this issue.

32-bit targets without `Atomic{I,U}64` and 64-bit targets are not affected by this issue.
32-bit targets with `Atomic{I,U}64` and `{i,u}64` have the same alignment are also not affected by this issue.

The following is a complete list of the builtin targets that may be affected. (last update: nightly-2022-02-11)

- armv7-apple-ios (tier 3)
- armv7s-apple-ios (tier 3)
- i386-apple-ios (tier 3)
- i586-unknown-linux-gnu
- i586-unknown-linux-musl
- i686-apple-darwin (tier 3)
- i686-linux-android
- i686-unknown-freebsd
- i686-unknown-haiku (tier 3)
- i686-unknown-linux-gnu
- i686-unknown-linux-musl
- i686-unknown-netbsd (tier 3)
- i686-unknown-openbsd (tier 3)
- i686-wrs-vxworks (tier 3)

([script to get list](https://gist.github.com/taiki-e/3c7891e8c5f5e0cbcb44d7396aabfe10))

### Patches

This has been fixed in crossbeam-utils 0.8.7.

Affected 0.8.x releases have been yanked.

### References

https://github.com/crossbeam-rs/crossbeam/pull/781 
",Critical,"['https://github.com/crossbeam-rs/crossbeam/pull/781', 'https://github.com/crossbeam-rs/crossbeam', 'https://nvd.nist.gov/vuln/detail/CVE-2022-23639', 'https://github.com/crossbeam-rs/crossbeam/security/advisories/GHSA-qc84-gqf4-9926', 'https://github.com/crossbeam-rs/crossbeam/releases/tag/crossbeam-utils-0.8.7']"
RUSTSEC-2019-0032,crust,https://github.com/maidsafe/crust,[],2020-10-02 01:29:11+00:00,2019-11-21T12:00:00Z,"[('0.0.0-0', '0.32.2-0')]","crust repo has been archived; use libp2p instead
","** The `crust` crate repo was archived with no warning or explanation.**

Given that it was archived with no warning or successor, there's not an
official replacement but [`rust-libp2p`](https://github.com/libp2p/rust-libp2p)
looks like it's got a similar feature set and is actively maintained.
",nan,"['https://rustsec.org/advisories/RUSTSEC-2019-0032.html', 'https://crates.io/crates/crust', 'https://github.com/maidsafe/crust']"
RUSTSEC-2021-0121,crypto2,https://github.com/shadowsocks/crypto2,['Cryptography'],2021-10-18 16:22:07+00:00,2021-10-08T12:00:00Z,"[('0.0.0-0', None), ('0', None)]","Use of a Broken or Risky Cryptographic Algorithm in crypto2
Non-aligned u32 read in Chacha20 encryption and decryption
","An issue was discovered in the crypto2 crate through 2021-10-08 for Rust. During Chacha20 encryption and decryption, an unaligned read of a u32 may occur.
The implementation does not enforce alignment requirements on input slices while incorrectly assuming 4-byte alignment through an unsafe call to `std::slice::from_raw_parts_mut`, which breaks the contract and introduces undefined behavior.

This affects Chacha20 encryption and decryption in crypto2.
",Critical,"['https://nvd.nist.gov/vuln/detail/CVE-2021-45709', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/crypto2/RUSTSEC-2021-0121.md', 'https://rustsec.org/advisories/RUSTSEC-2021-0121.html', 'https://crates.io/crates/crypto2', 'https://github.com/shadowsocks/crypto2/issues/27', 'https://github.com/shadowsocks/crypto2']"
GHSA-9783-42pm-x5jq,csv-sniffer,https://github.com/jblondin/csv-sniffer,"['Memory Access', 'Exception Management']",2022-01-07 17:33:33+00:00,2022-01-06T22:13:58Z,"[('0.0.0-0', None), ('0', None)]","`Read` on uninitialized memory may cause UB (fn preamble_skipcount())
Use of Uninitialized Resource in csv-sniffer.
","Affected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation (within `fn preamble_skipcount()`).

Arbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.
Reading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.
An issue was discovered in the csv-sniffer crate through 2021-01-05 for Rust. preamble_skipcount may read from uninitialized memory locations.
",nan,"['https://github.com/jblondin/csv-sniffer', 'https://github.com/jblondin/csv-sniffer/issues/1', 'https://rustsec.org/advisories/RUSTSEC-2021-0088.html', 'https://nvd.nist.gov/vuln/detail/CVE-2021-45686', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/csv-sniffer/RUSTSEC-2021-0088.md', 'https://crates.io/crates/csv-sniffer']"
RUSTSEC-2022-0002,dashmap,https://github.com/xacrimon/dashmap,"['Memory Access', 'Memory Management']",2022-02-06 17:02:38+00:00,2022-01-10T12:00:00Z,"[('5.0.0', '5.1.0')]","Unsoundness in `dashmap` references
","Reference returned by some methods of `Ref` (and similar types) may outlive the `Ref` and escape the lock.
This causes undefined behavior and may result in a segfault.

More information in [`dashmap#167`](https://github.com/xacrimon/dashmap/issues/167) issue.
",nan,"['https://crates.io/crates/dashmap', 'https://github.com/xacrimon/dashmap/issues/167', 'https://rustsec.org/advisories/RUSTSEC-2022-0002.html']"
RUSTSEC-2020-0139,dces,https://gitlab.redox-os.org/redox-os/dces-rust,"['Synchronization', 'Memory Management', 'Tainted Input']",2021-10-19 22:14:35+00:00,2020-12-09T12:00:00Z,"[('0.0.0-0', None), ('0', None)]","Data races in dces
dces' World type can cause data races
","An issue was discovered in the dces crate through 2020-12-09 for Rust. The World type is marked as Send but lacks bounds on its EntityStore and ComponentStore. This allows non-thread safe `EntityStore` and `ComponentStore`s to be sent
across threads and cause data races.

The `World` type in `dces` is marked as `Send` without bounds on its
`EntityStore` and `ComponentStore`.

This allows non-thread safe `EntityStore` and `ComponentStore`s to be sent
across threads and cause data races.
",High,"['https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/dces/RUSTSEC-2020-0139.md', 'https://crates.io/crates/dces', 'https://rustsec.org/advisories/RUSTSEC-2020-0139.html', 'https://gitlab.redox-os.org/redox-os/dces-rust/-/issues/8', 'https://gitlab.redox-os.org/redox-os/dces-rust', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36459']"
GHSA-838h-jqp6-cf2f,deno,https://github.com/denoland/deno,['Privilege'],2022-05-02 19:39:05+00:00,2022-03-29T22:10:10Z,"[('1.18.0', '1.20.3')]","Sandbox bypass leading to arbitrary code execution in Deno
","### Impact

The versions of Deno between release 1.18.0 and 1.20.2 (inclusive) are vulnerable to an attack where a malicious actor controlling the code executed in a Deno runtime could bypass permission checks and execute arbitrary shell code.

There is **no** evidence that this vulnerability has been exploited in the wild.

This vulnerability does **not** affect users of Deno Deploy.

### Patches

The vulnerability has been patched in Deno 1.20.3.

### Workarounds

There is no workaround. All users are recommended to upgrade to 1.20.3 immediately

---

The cause of this error was that certain FFI operations did not correctly check for permissions. The issue was fixed in [this](https://github.com/denoland/deno/pull/14115) pull request.
",Critical,"['https://nvd.nist.gov/vuln/detail/CVE-2022-24783', 'https://github.com/denoland/deno/security/advisories/GHSA-838h-jqp6-cf2f', 'https://github.com/denoland/deno/releases/tag/v1.20.3', 'https://github.com/denoland/deno/pull/14115', 'https://github.com/denoland/deno']"
GHSA-xpwj-7v8q-mcgj,deno,https://github.com/denoland/deno,['Access Control'],2021-09-23 21:13:15+00:00,2021-09-23T23:18:03Z,"[('1.5.0', '1.10.2')]","Static imports inside dynamically imported modules do not adhere to permission checks
","### Impact

Modules that are dynamically imported through `import()` or `new Worker` might have been able to bypass network and file system permission checks when statically importing other modules. In Deno 1.5.x and 1.6.x only programs dynamically importing (especially transitively) untrusted code are affected. In Deno 1.7.x all programs importing (especially transitively) untrusted code are affected.

In effect an attacker in control of a (possibly remote) module in a programs module graph has been able to, **irrespective of permissions**:
1. initiate GET requests to arbitrary URLs on the internet (including LAN) and possibly read (parts of) the contents of these resources.
2. check for existence of arbitrary paths on the file system, and possibly read (parts of) the contents of these files.

In Deno 1.5.x (October 27th, 2020) and Deno 1.6.x (December 8th, 2020) the attacker module had to have been granted permissions to load dynamically through the network / fs read permission. Since Deno 1.7.x (January 19th, 2021) this vulnerability was able to be exploited in a fully sandboxed isolate (without any permissions). This vulnerability was not present in releases prior to 1.5.0.

Arbitrary non-GET requests, control over request headers, or file system writes are not possible through this vulnerability. Users of the `deno_core`, `deno_runtime`, or other `deno_*` crates are not affected. This is a Deno CLI only vulnerability.

We are relatively confident this was not abused in the wild, as by default Deno prints out a green ""Download"" message when remote imports are downloaded, and this would have caused suspicion if it occurred in the middle of a programs execution. This message can be silenced with the `--quiet` flag.  

### Patches

The vulnerability has been patched in Deno release 1.10.2. You can upgrade to the latest Deno version by running the `deno upgrade` command. The release is available through all official download channels. 

### Workarounds

There is no workaround for this issue.

### For more information

If you have any questions or comments about this advisory:
* Open an issue on [the issue tracker](https://github.com/denoland/deno)
* Discuss on [Discord](https://discord.gg/deno)

",Critical,"['https://nvd.nist.gov/vuln/detail/CVE-2021-32619', 'https://github.com/denoland/deno/security/advisories/GHSA-xpwj-7v8q-mcgj', 'https://github.com/denoland/deno']"
GHSA-w4cc-pc2h-whcj,derive-com-impl,https://github.com/connicpu/com-impl,"['Memory Access', 'Memory Management']",2022-01-07 16:17:28+00:00,2022-01-06T22:16:10Z,"[('0.0.0-0', '0.1.2'), ('0', None)]","QueryInterface should call AddRef before returning pointer
Out-of-bounds Write in derive-com-impl
","Affected version of this crate, which is a required dependency in com-impl, 
provides a faulty implementation of the `IUnknown::QueryInterface` method.

`QueryInterface` implementation must call `IUnknown::AddRef` before returning the pointer,
as describe in this documentation:
<https://docs.microsoft.com/en-us/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(refiid_void)>

As it is not incrementing the refcount as expected, the following calls to `IUnknown::Release` method 
will cause WMI to drop reference to the interface, and can lead to invalid reference.

This is documented in <https://docs.microsoft.com/en-us/windows/win32/learnwin32/managing-the-lifetime-of-an-object#reference-counting>

There is no simple workaround, as you can't know how many time QueryInterface will be called.
The only way to quick fix this is to use the macro expanded version of the code and modify 
the QueryInterface method to add the AddRef call yourself.

The issue was corrected in commit `9803f31fbd1717d482d848f041044d061fca6da7`.
An issue was discovered in the derive-com-impl crate before 0.1.2 for Rust. An invalid reference (and memory corruption) can occur because AddRef might not be called before returning a pointer.
",nan,"['https://github.com/connicpu/com-impl', 'https://crates.io/crates/derive-com-impl', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/derive-com-impl/RUSTSEC-2021-0083.md', 'https://github.com/Connicpu/com-impl/issues/1', 'https://nvd.nist.gov/vuln/detail/CVE-2021-45681', 'https://rustsec.org/advisories/RUSTSEC-2021-0083.html']"
RUSTSEC-2021-0037,diesel,https://github.com/diesel-rs/diesel,['Memory Management'],2021-10-19 22:14:35+00:00,2021-03-05T12:00:00Z,"[('0.0.0-0', '1.4.6')]","Fix a use-after-free bug in diesels Sqlite backend
","We've misused `sqlite3_column_name`. The
[SQLite](https://www.sqlite.org/c3ref/column_name.html) documentation
states that the following:

> The returned string pointer is valid until either the prepared statement
> is destroyed by sqlite3_finalize() or until the statement is automatically
> reprepared by the first call to sqlite3_step() for a particular
> run or until the next call to sqlite3_column_name()
> or sqlite3_column_name16() on the same column.

As part of our `query_by_name` infrastructure we've first received all
field names for the prepared statement and stored them as string slices
for later use. After that we called `sqlite3_step()` for the first time,
which invalids the pointer and therefore the stored string slice.
",Critical,"['https://github.com/diesel-rs/diesel/pull/2663', 'https://rustsec.org/advisories/RUSTSEC-2021-0037.html', 'https://crates.io/crates/diesel']"
RUSTSEC-2020-0095,difference,https://github.com/johannhof/difference.rs,[],2021-01-24 19:50:18+00:00,2020-12-20T12:00:00Z,"[('0.0.0-0', '2.0.1-0')]","difference is unmaintained
","The author of the `difference` crate is unresponsive.

Maintained alternatives:

- [`dissimilar`](https://crates.io/crates/dissimilar)

- [`similar`](https://crates.io/crates/similar)

- [`treediff`](https://crates.io/crates/treediff)

- [`diffus`](https://crates.io/crates/diffus)
",nan,"['https://crates.io/crates/difference', 'https://rustsec.org/advisories/RUSTSEC-2020-0095.html', 'https://github.com/johannhof/difference.rs/issues/45']"
RUSTSEC-2020-0150,disrustor,https://github.com/sklose/disrustor,"['Synchronization', 'Memory Management']",2022-02-21 21:23:42+00:00,2020-12-17T12:00:00Z,"[('0.0.0-0', '0.3.0'), ('0', None)]","Data race in disrustor
RingBuffer can create multiple mutable references and cause data races
","An issue was discovered in the disrustor crate through 2020-12-17 for Rust. RingBuffer doe not properly limit the number of mutable references.
The `RingBuffer` type retrieves mutable references from the `DataProvider` in a
non-atomic manner, potentially allowing the creation of multiple mutable
references. `RingBuffer` also implements the `Send` and `Sync` traits for all
types `T`.

This allows undefined behavior from the aliased mutable references as well
as data races.
",Medium,"['https://github.com/sklose/disrustor/issues/1', 'https://rustsec.org/advisories/RUSTSEC-2020-0150.html', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36470', 'https://crates.io/crates/disrustor', 'https://github.com/sklose/disrustor']"
RUSTSEC-2022-0024,double-checked-cell,https://github.com/niklasf/double-checked-cell,[],2022-05-11 21:13:02+00:00,2022-05-11T12:00:00Z,"[('0.0.0-0', None)]","double-checked-cell is unmaintained
","The author recommends switching to
[`once_cell`](https://crates.io/crates/once_cell), which offers a superset
of the functionality.
",nan,"['https://rustsec.org/advisories/RUSTSEC-2022-0024.html', 'https://crates.io/crates/double-checked-cell', 'https://github.com/niklasf/double-checked-cell/commit/9cf94d75316ef441033ce4c80def7c1a8c7643fe']"
GHSA-qxjq-v4wf-ppvh,dync,https://github.com/elrnv/dync,['Memory Access'],2021-08-19 20:50:45+00:00,2021-08-25T20:49:47Z,"[('0.0.0-0', '0.5.0'), ('0', '0.5.0')]","VecCopy allows misaligned access to elements
Out of bounds read in dync
","`VecCopy::data` is created as a Vec of u8 but can be used to store and retrieve
elements of different types leading to misaligned access.

The issue was resolved in v0.5.0 by replacing data being stored by `Vec<u8>` with a custom managed
pointer.  Elements are now stored and retrieved using types with proper alignment corresponding to
original types.
An issue was discovered in the dync crate before 0.5.0 for Rust. VecCopy allows misaligned element access because u8 is not always the type in question.
",Medium,"['https://nvd.nist.gov/vuln/detail/CVE-2020-35903', 'https://github.com/elrnv/dync/issues/4', 'https://crates.io/crates/dync', 'https://github.com/elrnv/dync', 'https://rustsec.org/advisories/RUSTSEC-2020-0050.html']"
RUSTSEC-2021-0039,endian_trait,https://gitlab.com/myrrlyn/endian_trait,['Memory Management'],2021-10-19 22:14:35+00:00,2021-01-04T12:00:00Z,"[('0.0.0-0', None), ('0', None)]","Double free in endian_trait
panic in user-provided `Endian` impl triggers double drop of T
","An issue was discovered in the endian_trait crate through 2021-01-04 for Rust. A double drop can occur when a user-provided Endian impl panics.
Affected versions of the crate does not guard against panic from user-provided impl of `Endian` trait, which is a safe trait that users can implement.
If a user-provided implementation of the `Endian` trait panics, double-drop is triggered due to the duplicated ownership of `T` created by `ptr::read()`.

Double-drop (or double free) can cause memory corruption in the heap.
",High,"['https://crates.io/crates/endian_trait', 'https://gitlab.com/myrrlyn/endian_trait/-/issues/1', 'https://nvd.nist.gov/vuln/detail/CVE-2021-29929', 'https://rustsec.org/advisories/RUSTSEC-2021-0039.html', 'https://gitlab.com/myrrlyn/endian_trait']"
RUSTSEC-2022-0010,enum-map,https://gitlab.com/KonradBorowski/enum-map,"['Memory Access', 'Other', 'Memory Management']",2022-02-18 22:15:59+00:00,2022-02-17T12:00:00Z,"[('2.0.0-2', '2.0.2')]","enum_map macro can cause UB when `Enum` trait is incorrectly implemented
","Affected versions of this crate did not properly check the length of an enum when using `enum_map!` macro, trusting user-provided length.

When the `LENGTH` in the `Enum` trait does not match the array length in the `EnumArray` trait, this can result in the initialization of the enum map with uninitialized types, which in turn can allow an attacker to execute arbitrary code.

This problem can only occur with a manual implementation of the Enum trait, it will never occur for enums that use `#[derive(Enum)]`.

Example code that triggers this vulnerability looks like this:

```rust
enum E {
    A,
    B,
    C,
}

impl Enum for E {
    const LENGTH: usize = 2;

    fn from_usize(value: usize) -> E {
        match value {
            0 => E::A,
            1 => E::B,
            2 => E::C,
            _ => unimplemented!(),
        }
    }

    fn into_usize(self) -> usize {
        self as usize
    }
}

impl<V> EnumArray<V> for E {
    type Array = [V; 3];
}

let _map: EnumMap<E, String> = enum_map! { _ => ""Hello, world!"".into() };
```

The flaw was corrected in commit [b824e23](https://gitlab.com/KonradBorowski/enum-map/-/commit/b824e232f2fb47837740070096ac253df8e80dfc) by putting `LENGTH` property on sealed trait for macro to read.
",nan,"['https://crates.io/crates/enum-map', 'https://rustsec.org/advisories/RUSTSEC-2022-0010.html', 'https://gitlab.com/KonradBorowski/enum-map/-/blob/master/CHANGELOG.md#version-202']"
GHSA-69vj-xx27-g45w,eventio,https://github.com/petabi/eventio,"['Memory Access', 'Synchronization', 'Memory Management']",2021-08-19 18:47:45+00:00,2021-08-25T20:51:49Z,"[('0.0.0-0', '0.5.1'), ('0', '0.5.1')]","Soundness issue: Input<R> can be misused to create data race to an object
Data race in eventio
","`Input<R>` implements `Send` without requiring `R: Send`.

Affected versions of this crate allows users to send non-Send types to other threads,
which can lead to undefined behavior such as data race and memory corruption.

The flaw was corrected in version 0.5.1 by adding `R: Send` bound to the `Send` impl of `Input<R>`.
An issue was discovered in Input<R> in the eventio crate before 0.5.1 for Rust. Because a non-Send type can be sent to a different thread, a data race and memory corruption can occur.
",Medium,"['https://nvd.nist.gov/vuln/detail/CVE-2020-36216', 'https://github.com/petabi/eventio', 'https://rustsec.org/advisories/RUSTSEC-2020-0108.html', 'https://github.com/petabi/eventio/issues/33', 'https://crates.io/crates/eventio']"
GHSA-pvh2-pj76-4m96,evm,https://github.com/sorpaas/rust-evm,['Other'],2021-10-25 20:07:57+00:00,2021-10-19T15:28:35Z,"[('0', '0.31.0')]","Specification non-compliance in JUMPI
","### Impact 

In `evm` crate `< 0.31.0`, `JUMPI` opcode's condition is checked after the destination validity check. However, according to Geth and OpenEthereum, the condition check should happen before the destination validity check.

### Patches

This is a **high** severity security advisory if you use `evm` crate for Ethereum mainnet. In this case, you should update your library dependency immediately to on or after `0.31.0`.

This is a **low** severity security advisory if you use `evm` crate in Frontier or in a standalone blockchain, because there's no security exploit possible with this advisory. It is **not** recommended to update to on or after `0.31.0` until all the normal chain upgrade preparations have been done. If you use Frontier or other `pallet-evm` based Substrate blockchain, please ensure to update your `spec_version` before updating this. For other blockchains, please make sure to follow a hard-fork process before you update this.

### Workarounds

If you are dependent on an older version of `evm` and cannot update due to API interface changes, please contact Wei by email (wei@that.world), who will be happy to help you to publish patch releases for older `evm` versions.

### References

Fix PR: https://github.com/rust-blockchain/evm/pull/67

### For more information

If you have any questions or comments about this advisory:
* Open an issue in the `evm` repo.

### Special thanks

Special thanks to @rakita for reporting this issue.

",High,"['https://github.com/rust-blockchain/evm', 'https://nvd.nist.gov/vuln/detail/CVE-2021-41153', 'https://github.com/rust-blockchain/evm/security/advisories/GHSA-pvh2-pj76-4m96', 'https://github.com/rust-blockchain/evm/pull/67']"
GHSA-773q-5334-5gf9,evm-core,https://github.com/sorpaas/rust-evm,['Resource Management'],2021-08-18 21:38:27+00:00,2021-08-25T20:55:36Z,"[('0.23.0', '0.23.1'), ('0.25.0', '0.25.1'), ('0.26.0', '0.26.1'), ('0.0.0-0', '0.21.1'), ('0.24.0', '0.24.1'), ('0', '0.21.1')]","Denial of service on EVM execution due to memory over-allocation
Memory over-allocation in evm-core
","Prior to the patch, when executing specific EVM opcodes related
to memory operations that use `evm_core::Memory::copy_large`, the
crate can over-allocate memory when it is not needed, making it
possible for an attacker to perform denial-of-service attack.

The flaw was corrected in commit `19ade85`.
Prior to the patch, when executing specific EVM opcodes related
to memory operations that use `evm_core::Memory::copy_large`, the
crate can over-allocate memory when it is not needed, making it
possible for an attacker to perform denial-of-service attack.

The flaw was corrected in commit `19ade85`.

",nan,"['https://github.com/rust-blockchain/evm', 'https://github.com/rust-blockchain/evm/commit/19ade85', 'https://rustsec.org/advisories/RUSTSEC-2021-0066.html', 'https://crates.io/crates/evm-core']"
GHSA-r98r-j25q-rmpr,failure,https://github.com/rust-lang-nursery/failure,['Risky Values'],2021-08-19 21:19:54+00:00,2021-08-25T20:46:38Z,"[('0.0.0-0', None), ('0', None)]","Type confusion if __private_get_type_id__ is overridden
Type confusion in failure
","Safe Rust code can implement malfunctioning `__private_get_type_id__` and cause
type confusion when downcasting, which is an undefined behavior.

Users who derive `Fail` trait are not affected.
An issue was discovered in the failure crate through 2019-11-13 for Rust. Type confusion can occur when __private_get_type_id__ is overridden.
",Critical,"['https://nvd.nist.gov/vuln/detail/CVE-2019-25010', 'https://rustsec.org/advisories/RUSTSEC-2019-0036.html', 'https://github.com/rust-lang-nursery/failure/issues/336', 'https://github.com/rust-lang-nursery/failure', 'https://crates.io/crates/failure']"
RUSTSEC-2020-0036,failure,https://github.com/rust-lang-nursery/failure,[],2021-10-19 22:14:35+00:00,2020-05-02T12:00:00Z,"[('0.0.0-0', None)]","failure is officially deprecated/unmaintained
","The `failure` crate is officially end-of-life: it has been marked as deprecated
by the former maintainer, who has announced that there will be no updates or
maintenance work on it going forward.

The following are some suggested actively developed alternatives to switch to:

- [`anyhow`](https://crates.io/crates/anyhow)
- [`eyre`](https://crates.io/crates/eyre)
- [`fehler`](https://crates.io/crates/fehler)
- [`snafu`](https://crates.io/crates/snafu)
- [`thiserror`](https://crates.io/crates/thiserror)
",Critical,"['https://rustsec.org/advisories/RUSTSEC-2020-0036.html', 'https://crates.io/crates/failure', 'https://github.com/rust-lang-nursery/failure/pull/347']"
GHSA-8xw8-mmqv-frqq,fake-static,https://github.com/NieDzejkob/fake-static,['Other'],2021-08-18 21:41:18+00:00,2021-08-25T20:55:33Z,"[('0', None)]","fake-static allows converting any reference into a `'static` reference
","fake-static allows converting a reference with any lifetime into
a reference with `'static` lifetime without the `unsafe` keyword.

Internally, this crate does not use unsafe code, it instead
exploits a soundness bug in rustc



",nan,"['https://rustsec.org/advisories/RUSTSEC-2020-0013', 'https://github.com/rust-lang/rust/issues/25860', 'https://github.com/NieDzejkob/fake-static']"
RUSTSEC-2020-0013,fake-static,https://github.com/NieDzejkob/fake-static,[],2021-01-14 17:57:27+00:00,2020-04-24T12:00:00Z,"[('0.0.0-0', None)]","fake-static allows converting any reference into a `'static` reference
","fake-static allows converting a reference with any lifetime into
a reference with `'static` lifetime without the `unsafe` keyword.

Internally, this crate does not use unsafe code, it instead
exploits a soundness bug in rustc:

https://github.com/rust-lang/rust/issues/25860
",nan,"['https://rustsec.org/advisories/RUSTSEC-2020-0013.html', 'https://crates.io/crates/fake-static']"
RUSTSEC-2020-0065,fake_clock,https://github.com/maidsafe/sn_fake_clock,[],2020-11-02 14:46:33+00:00,2020-11-02T12:00:00Z,"[('0.0.0-0', None)]","crate has been renamed to `sn_fake_clock`
","This crate has been renamed from `fake_clock` to `sn_fake_clock`.

The new repository location is:

<https://github.com/maidsafe/sn_fake_clock>
",nan,"['https://crates.io/crates/fake_clock', 'https://rustsec.org/advisories/RUSTSEC-2020-0065.html', 'https://github.com/maidsafe/sn_fake_clock/pull/38']"
RUSTSEC-2020-0064,ffi_utils,https://github.com/maidsafe/ffi-utils,[],2020-11-02 14:45:15+00:00,2020-11-02T12:00:00Z,"[('0.0.0-0', None)]","crate has been renamed to `sn_ffi_utils`
","This crate has been renamed from `ffi_utils` to `sn_ffi_utils`.

The new repository location is:

<https://github.com/maidsafe/sn_ffi_utils>
",nan,"['https://rustsec.org/advisories/RUSTSEC-2020-0064.html', 'https://github.com/maidsafe/sn_ffi_utils/pull/45', 'https://crates.io/crates/ffi_utils']"
GHSA-x3v2-fgr6-3wmm,fil-ocl,https://github.com/filecoin-project/fil-ocl,['Memory Management'],2021-08-19 18:40:57+00:00,2021-08-25T20:53:03Z,"[('0.12.0', None)]","EventList's From<EventList> conversions can double drop on panic.
Double free in fil-ocl
","Affected versions of this crate read from a container using `ptr::read` in
`From<EventList>`, and then call a user specified `Into<Event>` function.

This issue can result in a double-free if the user provided function panics.
An issue was discovered in the fil-ocl crate through 2021-01-04 for Rust. From<EventList> can lead to a double free.
",High,"['https://crates.io/crates/fil-ocl', 'https://github.com/cogciprocate/ocl/issues/194', 'https://rustsec.org/advisories/RUSTSEC-2021-0011.html', 'https://nvd.nist.gov/vuln/detail/CVE-2021-25908', 'https://github.com/filecoin-project/fil-ocl']"
RUSTSEC-2019-0028,flatbuffers,https://github.com/google/flatbuffers,['Risky Values'],2021-10-19 22:14:35+00:00,2019-10-20T12:00:00Z,"[('0.4.0', '0.6.1')]","Unsound casting in flatbuffers
Unsound `impl Follow for bool`
","An issue was discovered in the flatbuffers crate before 0.6.1 for Rust. Arbitrary bytes can be reinterpreted as a bool, defeating soundness.
The implementation of `impl Follow for bool` allows to reinterpret arbitrary bytes as a `bool`.

In Rust `bool` has stringent requirements for its in-memory representation. Use of this function
allows to violate these requirements and invoke undefined behaviour in safe code.
",Critical,"['https://nvd.nist.gov/vuln/detail/CVE-2019-25004', 'https://github.com/google/flatbuffers/issues/5530', 'https://github.com/google/flatbuffers', 'https://crates.io/crates/flatbuffers', 'https://rustsec.org/advisories/RUSTSEC-2019-0028.html']"
GHSA-c9h5-hf8r-m97x,flatbuffers,https://github.com/google/flatbuffers,['Risky Values'],2021-08-19 21:18:24+00:00,2021-08-25T20:47:36Z,"[('0', '2.0.0'), ('0.4.0', '2.0.0')]","`read_scalar` and `read_scalar_at` allow transmuting values without `unsafe` blocks
Dangling reference in flatbuffers
","The `read_scalar` and `read_scalar_at` functions are unsound
because they allow transmuting values without `unsafe` blocks.

The following example shows how to create a dangling reference:

```
fn main() {
    #[derive(Copy, Clone, PartialEq, Debug)]
    struct S(&'static str);
    impl flatbuffers::EndianScalar for S {
        fn to_little_endian(self) -> Self { self }
        fn from_little_endian(self) -> Self { self }
    }
    println!(""{:?}"", flatbuffers::read_scalar::<S>(&[1; std::mem::size_of::<S>()]));
}
```
An issue was discovered in the flatbuffers crate through 2020-04-11 for Rust. read_scalar (and read_scalar_at) can transmute values without unsafe blocks.
",High,"['https://github.com/google/flatbuffers/issues/5825', 'https://rustsec.org/advisories/RUSTSEC-2020-0009.html', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35864', 'https://github.com/google/flatbuffers', 'https://crates.io/crates/flatbuffers']"
RUSTSEC-2021-0122,flatbuffers,https://github.com/google/flatbuffers,[],2021-11-07 17:53:20+00:00,2021-10-31T12:00:00Z,"[('0.0.0-0', None)]","Generated code can read and write out of bounds in safe code
","Code generated by flatbuffers' compiler is `unsafe` but not marked as such.
See https://github.com/google/flatbuffers/issues/6627 for details.

All users that use generated code by `flatbuffers` compiler are recommended to:
1. not expose flatbuffer generated code as part of their public APIs
2. audit their code and look for any usage of `follow`, `push`, or any method that uses them
   (e.g. `self_follow`).
3. Carefuly go through the crates' documentation to understand which ""safe"" APIs are not
   intended to be used.
",Critical,"['https://rustsec.org/advisories/RUSTSEC-2021-0122.html', 'https://crates.io/crates/flatbuffers', 'https://github.com/google/flatbuffers/issues/6627']"
GHSA-7qcc-g2m9-8533,fltk,https://github.com/fltk-rs/fltk-rs,['Memory Access'],2021-08-19 17:22:29+00:00,2021-08-25T20:53:53Z,"[('0.0.0-0', '0.15.3'), ('0', '0.15.3')]","Multiple memory safety issues
Out of bounds read in fltk
Null pointer deference in fltk
Null pointer deference in fltk
","Affected versions contain multiple memory safety issues, such as:

 - Setting a multi label type where an image doesn't exist would lead to a NULL pointer dereference.
 - Setting a window icon using a non-raster image (which FLTK rasterizes lazily) would lead to a NULL dereference.
 - Pixmap constructor would not check for correct pixmaps which could lead to out-of bound reads.
An issue was discovered in the fltk crate before 0.15.3 for Rust. There is an out-of bounds read because the pixmap constructor lacks pixmap input validation.
An issue was discovered in the fltk crate before 0.15.3 for Rust. There is a NULL pointer dereference during attempted use of a multi label type if the image is nonexistent.
An issue was discovered in the fltk crate before 0.15.3 for Rust. There is a NULL pointer dereference during attempted use of a non-raster image for a window icon.
",nan,"['https://github.com/MoAlyousef/fltk-rs/issues/519', 'https://crates.io/crates/fltk', 'https://rustsec.org/advisories/RUSTSEC-2021-0038.html', 'https://nvd.nist.gov/vuln/detail/CVE-2021-28306', 'https://github.com/MoAlyousef/fltk-rs', 'https://nvd.nist.gov/vuln/detail/CVE-2021-28308', 'https://nvd.nist.gov/vuln/detail/CVE-2021-28307']"
GHSA-p46c-w9m3-7qr2,flumedb,https://github.com/sunrise-choir/flumedb-rs,"['Memory Access', 'Exception Management']",2022-01-07 16:14:36+00:00,2022-01-06T22:18:35Z,"[('0.0.0-0', None), ('0', None)]","`Read` on uninitialized buffer may cause UB ( `read_entry()` )
Use of Uninitialized Resource in flumedb.
","Affected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation.
There are two of such cases (`go_offset_log::read_entry()` & `offset_log::read_entry()`).

Arbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.
Reading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.
An issue was discovered in the flumedb crate through 2021-01-07 for Rust. read_entry may read from uninitialized memory locations.
",nan,"['https://github.com/sunrise-choir/flumedb-rs/issues/10', 'https://rustsec.org/advisories/RUSTSEC-2021-0086.html', 'https://github.com/sunrise-choir/flumedb-rs', 'https://nvd.nist.gov/vuln/detail/CVE-2021-45684', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/flumedb/RUSTSEC-2021-0086.md', 'https://crates.io/crates/flumedb']"
GHSA-hw4v-5x4h-c3xm,frontier,https://github.com/paritytech/frontier,['Tainted Input'],2021-09-03 20:22:28+00:00,2021-09-01T18:22:48Z,"[('0', None)]","Transaction validity oversight in pallet-ethereum
","### Impact

A bug in `pallet-ethereum` can cause invalid transactions to be included in the Ethereum block state in `pallet-ethereum` due to not validating the input data size. Any invalid transactions included this way have no possibility to alter the internal Ethereum or Substrate state. The transaction will appear to have be included, but is of no effect as it is rejected by the EVM engine. The impact is further limited by Substrate extrinsic size constraints.

### Patches

Patches are applied in PR #465.

### Workarounds

None.

### References

Patch PR: https://github.com/paritytech/frontier/pull/465

### For more information

If you have any questions or comments about this advisory:
* Open an issue in the [Frontier repo](https://github.com/paritytech/frontier)

",Medium,"['https://github.com/paritytech/frontier/pull/465/commits/8a2b890a2fb477d5fedd0e4335b00623832849ae', 'https://github.com/paritytech/frontier', 'https://github.com/paritytech/frontier/pull/465', 'https://github.com/paritytech/frontier/security/advisories/GHSA-hw4v-5x4h-c3xm', 'https://github.com/paritytech/frontier/commit/0b962f218f0cdd796dadfe26c3f09e68f7861b26', 'https://github.com/paritytech/frontier/commit/dd112e', 'https://nvd.nist.gov/vuln/detail/CVE-2021-39193']"
GHSA-cjg2-2fjg-fph4,frontier,https://github.com/paritytech/frontier,['Risky Values'],2022-01-14 19:58:51+00:00,2022-01-14T21:03:36Z,"[('0', None)]","Integer underflow in Frontier
","### Impact

A bug in Frontier's MODEXP precompile implementation can cause an integer underflow in certain conditions. This will cause a node crash for debug builds. For release builds (and production WebAssembly binaries), the impact is limited as it can only cause a normal EVM out-of-gas. It is recommended that you apply the patch as soon as possible.

If you do not use MODEXP precompile in your runtime, then you are not impacted.

### Patches

Patches are applied in PR #549.

### Workarounds

None.

### References

Patch PR: #549

### Credits

Thanks to SR-Labs for discovering the security vulnerability, and thanks to PureStake team for the patches.

### For more information

If you have any questions or comments about this advisory:
* Open an issue in the [Frontier repo](https://github.com/paritytech/frontier)

",nan,"['https://github.com/paritytech/frontier/security/advisories/GHSA-cjg2-2fjg-fph4', 'https://github.com/paritytech/frontier/pull/549', 'https://github.com/paritytech/frontier/commit/8a93fdc6c9f4eb1d2f2a11b7ff1d12d70bf5a664', 'https://nvd.nist.gov/vuln/detail/CVE-2022-21685', 'https://github.com/paritytech/frontier']"
GHSA-vj62-g63v-f8mf,frontier,https://github.com/paritytech/frontier,['Tainted Input'],2021-10-13 17:34:31+00:00,2021-10-13T18:53:38Z,"[('0', None)]","Validity check missing in Frontier
","### Impact

In the newly introduced signed Frontier-specific extrinsic for `pallet-ethereum`, a large part of transaction validation logic was only called in transaction pool validation, but not in block execution. Malicious validators can take advantage of this to put invalid transactions into a block.

The attack is limited in that the signature is always validated, and the majority of the validation is done again in the subsequent `pallet-evm` execution logic. However, do note that a chain ID replay attack was possible. In addition, spamming attacks are of main concerns, while they are limited by Substrate block size limits and other factors.

### Patches

The issue is patched in commit 146bb48849e5393004be5c88beefe76fdf009aba.

### References

Patch PR: https://github.com/paritytech/frontier/pull/495

### For more information

If you have any questions or comments about this advisory:
* Open an issue in [Frontier repo](https://github.com/paritytech/frontier/issues)

### Special thanks

Special thanks to @librelois, @nanocryk and the Moonbeam team for reporting and fixing this security vulnerability.
",Medium,"['https://github.com/paritytech/frontier/commit/146bb48849e5393004be5c88beefe76fdf009aba', 'https://github.com/paritytech/frontier/pull/495', 'https://github.com/paritytech/frontier/pull/497', 'https://github.com/paritytech/frontier/security/advisories/GHSA-vj62-g63v-f8mf', 'https://nvd.nist.gov/vuln/detail/CVE-2021-41138', 'https://github.com/paritytech/frontier']"
GHSA-h352-g5vw-3926,fruity,https://github.com/nvzqz/fruity,['Tainted Input'],2021-11-19 13:24:04+00:00,2021-11-16T17:26:47Z,"[('0.1.0', '0.3.0'), ('0', None)]","Converting `NSString` to a String Truncates at Null Bytes
Improper Input Validation in fruity
","Methods of [`NSString`] for conversion to a string may return a partial result.
Since they call [`CStr::from_ptr`] on a pointer to the string buffer, the
string is terminated at the first null byte, which might not be the end of the
string.

In addition to the vulnerable functions listed for this issue, the
implementations of [`Display`], [`PartialEq`], [`PartialOrd`], and [`ToString`]
for [`NSString`] are also affected, since they call those functions.

## Impact

Since [`NSString`] is commonly used as the type for paths by the [Foundation]
framework, null byte truncation might allow for easily bypassing file extension
checks. For example, if a file name is provided by a user and validated to have
one of a specific set of extensions, with validation taking place before
truncation, an attacker can add an accepted extension after a null byte (e.g.,
`file.exe\0.txt`). After truncation, the file name used by the application
would be `file.exe`.

It would be better to generate unique names for files, instead of using
user-provided names, but not all applications take this approach.

## Example:

```rust
let string = NSString::from_str(""null\0byte"");
println!(""{}"", string);
```

That example only prints the string ""null"".

[`CStr::from_ptr`]: https://doc.rust-lang.org/std/ffi/struct.CStr.html#method.from_ptr
[`Display`]: https://doc.rust-lang.org/std/fmt/trait.Display.html
[Foundation]: https://developer.apple.com/documentation/foundation
[`NSString`]: https://docs.rs/fruity/0.2.0/fruity/foundation/struct.NSString.html
[`PartialEq`]: https://doc.rust-lang.org/std/cmp/trait.PartialEq.html
[`PartialOrd`]: https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html
[`ToString`]: https://doc.rust-lang.org/std/string/trait.ToString.html
An issue was discovered in the fruity crate through 0.2.0 for Rust. Security-relevant validation of filename extensions is plausibly affected. Methods of NSString for conversion to a string may return a partial result. Because they call CStr::from_ptr on a pointer to the string buffer, the string is terminated at the first '\0' byte, which might not be the end of the string.
",nan,"['https://github.com/nvzqz/fruity/issues/14', 'https://crates.io/crates/fruity', 'https://nvd.nist.gov/vuln/detail/CVE-2021-43620', 'https://github.com/rustsec/advisory-db/pull/1102', 'https://github.com/nvzqz/fruity', 'https://rustsec.org/advisories/RUSTSEC-2021-0123.html']"
RUSTSEC-2022-0005,ftd2xx-embedded-hal,https://github.com/newAM/ftd2xx-embedded-hal/,[],2022-01-22 18:27:42+00:00,2022-01-22T12:00:00Z,"[('0.0.0-0', None)]","crate has been renamed to `ftdi-embedded-hal`
","This crate has been renamed from `ftd2xx-embedded-hal` to `ftdi-embedded-hal`.

The new repository location is:

<https://github.com/ftdi-rs/ftdi-embedded-hal>
",nan,"['https://crates.io/crates/ftd2xx-embedded-hal', 'https://rustsec.org/advisories/RUSTSEC-2022-0005.html', 'https://github.com/newAM/ftd2xx-embedded-hal/pull/40']"
GHSA-4hjg-cx88-g9f9,futures-intrusive,https://github.com/Matthias247/futures-intrusive,"['Synchronization', 'Memory Management']",2021-08-19 20:49:04+00:00,2021-08-25T20:49:58Z,"[('0.0.0-0', '0.4.0'), ('0', '0.4.0')]","GenericMutexGuard allows data races of non-Sync types across threads
Data races in futures-intrusive
","`GenericMutexGuard<T>` was given the `Sync` auto trait as long as `T` is `Send`
due to its contained members. However, since the guard is supposed to represent
an **acquired lock** and allows concurrent access to the underlying data from
different threads, it should only be `Sync` when the underlying data is.

This is a soundness issue and allows data races, potentially leading to crashes
and segfaults from safe Rust code.

The flaw was corrected by adding a `T: Send + Sync` bound for
`GenericMutexGuard`'s `Sync` trait.

This bug is [similar to one](https://github.com/rust-lang/rust/issues/41622) in
`std::sync::Mutex`.
An issue was discovered in the futures-intrusive crate before 0.4.0 for Rust. GenericMutexGuard allows cross-thread data races of non-Sync types.
",Medium,"['https://github.com/Matthias247/futures-intrusive', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35915', 'https://rustsec.org/advisories/RUSTSEC-2020-0072.html', 'https://crates.io/crates/futures-intrusive', 'https://github.com/Matthias247/futures-intrusive/issues/53']"
RUSTSEC-2020-0060,futures-task,https://github.com/rust-lang/futures-rs,"['Other', 'Memory Management']",2021-10-19 22:14:35+00:00,2020-09-04T12:00:00Z,"[('0.2.2-0', '0.3.6')]","futures_task::waker may cause a use-after-free if used on a type that isn't 'static
","Affected versions of the crate did not properly implement a `'static` lifetime bound on the `waker` function.
This resulted in a use-after-free if `Waker::wake()` is called after original data had been dropped.

The flaw was corrected by adding `'static` lifetime bound to the data `waker` takes.
",High,"['https://github.com/rust-lang/futures-rs/pull/2206', 'https://crates.io/crates/futures-task', 'https://rustsec.org/advisories/RUSTSEC-2020-0060.html']"
RUSTSEC-2020-0061,futures-task,https://github.com/rust-lang/futures-rs,['Resource Management'],2021-10-19 22:14:35+00:00,2020-05-03T12:00:00Z,"[('0.0.0-0', '0.3.5')]","futures_task::noop_waker_ref can segfault due to dereferencing a NULL pointer
","Affected versions of the crate used a `UnsafeCell` in thread-local storage to return a noop waker reference,
assuming that the reference would never be returned from another thread.

This resulted in a segmentation fault crash if `Waker::wake_by_ref()` was called on a waker returned from another thread due to 
it attempting to dereference a pointer that wasn't accessible from the main thread.

Reproduction Example (from issue):
```rust
use futures_task::noop_waker_ref;
fn main() {
    let waker = std::thread::spawn(|| noop_waker_ref()).join().unwrap();
    waker.wake_by_ref();
}
```

The flaw was corrected by using a `OnceCell::Lazy<>` wrapper around the noop waker instead of thread-local storage.
",Medium,"['https://rustsec.org/advisories/RUSTSEC-2020-0061.html', 'https://github.com/rust-lang/futures-rs/issues/2091', 'https://crates.io/crates/futures-task']"
RUSTSEC-2020-0062,futures-util,https://github.com/rust-lang/futures-rs,"['Synchronization', 'Memory Management']",2021-10-19 22:14:35+00:00,2020-01-24T12:00:00Z,"[('0.3.0', '0.3.2')]","Improper `Sync` implementation on `FuturesUnordered` in futures-utils can cause data corruption
","Affected versions of the crate had an unsound `Sync` implementation on the `FuturesUnordered` structure, which used a `Cell` for
interior mutability without any code to handle synchronized access to the underlying task list's length and head safely.

This could of lead to data corruption since two threads modifying the list at once could see incorrect values due to the lack
of access synchronization.

The issue was fixed by adding access synchronization code around insertion of tasks into the list.
",Medium,"['https://rustsec.org/advisories/RUSTSEC-2020-0062.html', 'https://github.com/rust-lang/futures-rs/issues/2050', 'https://crates.io/crates/futures-util']"
RUSTSEC-2020-0059,futures-util,https://github.com/rust-lang/futures-rs,['Synchronization'],2021-10-19 22:14:35+00:00,2020-10-22T12:00:00Z,"[('0.3.2', '0.3.7')]","MutexGuard::map can cause a data race in safe code
","Affected versions of the crate had a Send/Sync implementation for MappedMutexGuard that only considered variance on T, while MappedMutexGuard dereferenced to U.

This could of led to data races in safe Rust code when a closure used in MutexGuard::map() returns U that is unrelated to T.

The issue was fixed by fixing `Send` and `Sync` implementations, and by adding a `PhantomData<&'a mut U>` marker to the `MappedMutexGuard` type to tell the compiler that the guard is over
U too.
",Medium,"['https://github.com/rust-lang/futures-rs/issues/2239', 'https://crates.io/crates/futures-util', 'https://rustsec.org/advisories/RUSTSEC-2020-0059.html']"
GHSA-9p8q-j6q5-mjw8,galois_2p8,https://github.com/djsweet/galois_2p8,['Memory Access'],2022-02-25 15:29:16+00:00,2022-02-15T00:02:45Z,"[('0', '0.1.2')]","Buffer Overflow in galois_2p8
","In galois_2p8 before 0.1.2, PrimitivePolynomialField::new has an off-by-one buffer overflow for a vector.
",Critical,"['https://github.com/djsweet/galois_2p8/blob/master/CHANGELOG.md', 'https://nvd.nist.gov/vuln/detail/CVE-2022-24988', 'https://github.com/djsweet/galois_2p8']"
RUSTSEC-2020-0151,generator,https://github.com/Xudong-Huang/generator-rs.git,"['Synchronization', 'Memory Management']",2021-10-19 22:14:35+00:00,2020-11-16T12:00:00Z,"[('0.0.0-0', '0.7.0'), ('0', '0.7.0')]","Data races in generator
Generators can cause data races if non-Send types are used in their generator functions
","The `Generator` type is an iterable which uses a generator function that yields
values. In affected versions of the crate, the provided function yielding values
had no `Send` bounds despite the `Generator` itself implementing `Send`.

The generator function lacking a `Send` bound means that types that are
dangerous to send across threads such as `Rc` could be sent as part of a
generator, potentially leading to data races.

This flaw was fixed in commit [`f7d120a3b`](https://github.com/Xudong-Huang/generator-rs/commit/f7d120a3b724d06a7b623d0a4306acf8f78cb4f0)
by enforcing that the generator function be bound by `Send`.
The `Generator` type is an iterable which uses a generator function that yields
values. In affected versions of the crate, the provided function yielding values
had no `Send` bounds despite the `Generator` itself implementing `Send`.

The generator function lacking a `Send` bound means that types that are
dangerous to send across threads such as `Rc` could be sent as part of a
generator, potentially leading to data races.

This flaw was fixed in commit [`f7d120a3b`](https://github.com/Xudong-Huang/generator-rs/commit/f7d120a3b724d06a7b623d0a4306acf8f78cb4f0)
by enforcing that the generator function be bound by `Send`.
",Medium,"['https://nvd.nist.gov/vuln/detail/CVE-2020-36471', 'https://rustsec.org/advisories/RUSTSEC-2020-0151.html', 'https://github.com/Xudong-Huang/generator-rs/commit/f7d120a3b724d06a7b623d0a4306acf8f78cb4f0', 'https://crates.io/crates/generator', 'https://github.com/Xudong-Huang/generator-rs', 'https://github.com/Xudong-Huang/generator-rs/issues/27']"
GHSA-6c65-xcf5-299x,generator,https://github.com/Xudong-Huang/generator-rs.git,['Exception Management'],2021-08-18 17:52:08+00:00,2021-08-25T20:58:25Z,"[('0', '0.6.18'), ('0.0.0-0', '0.6.18')]","fix unsound APIs that could lead to UB
Uninitialized memory use in generator
","Affected versions of this crate API could use uninitialized memory with some APIs in special
cases, like use the API in none generator context. This could lead to UB.
The flaw was corrected by <https://github.com/Xudong-Huang/generator-rs/issues/9>
                          <https://github.com/Xudong-Huang/generator-rs/issues/11>
                          <https://github.com/Xudong-Huang/generator-rs/issues/13>
                          <https://github.com/Xudong-Huang/generator-rs/issues/14>                                                  
This patch fixes all those issues above.
An issue was discovered in the generator crate before 0.6.18 for Rust. Uninitialized memory is used by Scope, done, and yield_ during API calls.
",High,"['https://rustsec.org/advisories/RUSTSEC-2019-0020.html', 'https://github.com/Xudong-Huang/generator-rs/issues/11', 'https://github.com/Xudong-Huang/generator-rs/issues/13', 'https://crates.io/crates/generator', 'https://github.com/Xudong-Huang/generator-rs/issues/9', 'https://github.com/Xudong-Huang/generator-rs', 'https://nvd.nist.gov/vuln/detail/CVE-2019-16144', 'https://github.com/Xudong-Huang/generator-rs/issues/14']"
RUSTSEC-2020-0146,generic-array,https://github.com/fizyk20/generic-array.git,"['Memory Access', 'Memory Management']",2021-10-19 22:14:35+00:00,2020-04-09T12:00:00Z,"[('0.8.0', '0.9.1'), ('0.13.0', '0.13.3'), ('0.10.0', '0.10.1'), ('0.12.0', '0.12.4'), ('0.8.0', '0.8.4'), ('0.11.0', '0.11.2')]","Use after free in generic-array
arr! macro erases lifetimes
","An issue was discovered in the generic-array crate before 0.13.3 for Rust. It violates soundness by using the arr! macro to extend lifetimes.
Affected versions of this crate allowed unsoundly extending
lifetimes using `arr!` macro. This may result in a variety of
memory corruption scenarios, most likely use-after-free.
",High,"['https://rustsec.org/advisories/RUSTSEC-2020-0146.html', 'https://crates.io/crates/generic-array', 'https://github.com/fizyk20/generic-array/issues/98', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36465', 'https://github.com/fizyk20/generic-array']"
GHSA-xp6v-qx65-4pp7,gfwx,https://github.com/devolutions/gfwx-rs,"['Memory Access', 'Synchronization', 'Memory Management']",2021-08-19 18:53:42+00:00,2021-08-25T20:50:39Z,"[('0', '0.3.0'), ('0.0.0-0', '0.3.0')]","ImageChunkMut needs bounds on its Send and Sync traits
Data races in gfwx
","In the affected versions of this crate, `ImageChunkMut<'_, T>` unconditionally implements `Send` and `Sync`, allowing to create data races.

This can result in a memory corruption or undefined behavior when non thread-safe types are moved and referenced across thread boundaries.

The flaw was corrected in commit e7fb2f5 by adding `T: Send` bound to the `Send` impl and adding `T: Sync` bound to the `Sync` impl.
An issue was discovered in the gfwx crate before 0.3.0 for Rust. Because ImageChunkMut does not have bounds on its Send trait or Sync trait, a data race and memory corruption can occur.
",High,"['https://github.com/Devolutions/gfwx-rs/issues/7', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36211', 'https://crates.io/crates/gfwx', 'https://rustsec.org/advisories/RUSTSEC-2020-0104.html', 'https://github.com/Devolutions/gfwx-rs']"
RUSTSEC-2021-0091,gfx-auxil,https://github.com/gfx-rs/gfx,"['Memory Access', 'Exception Management']",2021-08-22 01:39:27+00:00,2021-01-07T12:00:00Z,"[('0.0.0-0', None), ('0', None)]","Use of Uninitialized Resource in gfx-auxil
Reading on uninitialized buffer may cause UB ( `gfx_auxil::read_spirv()` )
","An issue was discovered in the gfx-auxil crate through 2021-01-07 for Rust. gfx_auxil::read_spirv may read from uninitialized memory locations.
Affected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation.

Arbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.
Reading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.
",Critical,"['https://github.com/gfx-rs/gfx/issues/3567', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/gfx-auxil/RUSTSEC-2021-0091.md', 'https://nvd.nist.gov/vuln/detail/CVE-2021-45689', 'https://rustsec.org/advisories/RUSTSEC-2021-0091.html', 'https://crates.io/crates/gfx-auxil', 'https://github.com/gfx-rs/gfx']"
GHSA-5xg3-j2j6-rcx4,git-delta,https://github.com/dandavison/delta,"['Path Resolution', 'Tainted Input']",2021-09-09 16:46:42+00:00,2021-08-25T21:01:39Z,"[('0.0.0-0', '0.8.3'), ('0', '0.8.3')]","Relative Path Traversal in git-delta
Relative Path Traversal in git-delta
","git-delta before 0.8.3 on Windows resolves an executable's pathname as a relative path from the current directory.
git-delta before 0.8.3 on Windows resolves an executable's pathname as a relative path from the current directory.
",High,"['https://nvd.nist.gov/vuln/detail/CVE-2021-36376', 'https://vuln.ryotak.me/advisories/54', 'https://github.com/dandavison/delta', 'https://github.com/dandavison/delta/commit/f01846bd443aaf92fdd5ac20f461beac3f6ee3fd', 'https://rustsec.org/advisories/RUSTSEC-2021-0105.html', 'https://github.com/dandavison/delta/releases/tag/0.8.3', 'https://crates.io/crates/git-delta']"
RUSTSEC-2021-0005,glsl-layout,https://github.com/rustgd/glsl-layout,['Memory Management'],2021-10-19 22:14:35+00:00,2021-01-10T12:00:00Z,"[('0.0.0-0', '0.4.0'), ('0', '0.4.0')]","Double free in glsl-layout
Double drop upon panic in 'fn map_array()'
","An issue was discovered in the glsl-layout crate before 0.4.0 for Rust. When a panic occurs, map_array can perform a double drop.
Affected versions of this crate did not guard against panic within the user-provided function `f` (2nd parameter of `fn map_array`), and thus panic within `f` 
causes double drop of a single object.

The flaw was corrected in the 0.4.0 release by wrapping the object vulnerable
to a double drop within `ManuallyDrop<T>`.
",High,"['https://github.com/rustgd/glsl-layout/pull/10', 'https://rustsec.org/advisories/RUSTSEC-2021-0005.html', 'https://nvd.nist.gov/vuln/detail/CVE-2021-25902', 'https://crates.io/crates/glsl-layout', 'https://github.com/rustgd/glsl-layout']"
RUSTSEC-2021-0071,grep-cli,https://github.com/BurntSushi/ripgrep/tree/master/crates/cli,['Other'],2021-10-19 22:14:35+00:00,2021-06-12T12:00:00Z,"[('0.0.0-0', '0.1.6')]","`grep-cli` may run arbitrary executables on Windows
","On Windows in versions of `grep-cli` prior to `0.1.6`, it's possible for some
of the routines to execute arbitrary executables. In particular, a quirk of
the Windows process execution API is that it will automatically consider the
current directory before other directories when resolving relative binary
names. Therefore, if you use `grep-cli` to read decompressed files in an
untrusted directory with that directory as the CWD, a malicious actor to could
put, e.g., a `gz.exe` binary in that directory and `grep-cli` will use the
malicious actor's version of `gz.exe` instead of the system's.

This is also technically possible on Unix as well, but only if the `PATH`
variable contains `.`. Conventionally, they do not.

A `DecompressionReader` has been fixed to automatically resolve binary names
using `PATH`, instead of relying on the Windows API to do it.

If you use `grep-cli`'s `CommandReader` with a `std::process::Command` value
on Windows, then it is recommended to either construct the `Command` with an
absolute binary name, or use `grep-cli`'s new
[`resolve_binary`](https://docs.rs/grep-cli/0.1.6/grep_cli/fn.resolve_binary.html)
helper function.

To be clear, `grep-cli 0.1.6` mitigates this issue in two ways:

* A `DecompressionReader` will resolve decompression programs to absolute
paths automatically using the `PATH` environment variable, instead of relying
on Windows APIs to do it (which would result in the undesirable behavior of
checking the CWD for a program first).
* A new function, `resolve_binary`, was added to help users of this crate
mitigate this behavior when they need to create their own
`std::process::Command`. For example,
[ripgrep uses `grep_cli::resolve_binary`](https://github.com/BurntSushi/ripgrep/blob/7ce66f73cf7e76e9f2557922ac8e650eb02cf4ed/crates/core/search.rs#L119-L122)
on the argument given to its `--pre` flag.

While the first mitigation fixes this issue for sensible values of `PATH`
when doing decompression search, the second mitigation is imperfect. The more
fundamental issue is that `std::process::Command` is itself vulnerable to this.
",Critical,"['https://github.com/BurntSushi/ripgrep/issues/1773', 'https://rustsec.org/advisories/RUSTSEC-2021-0071.html', 'https://crates.io/crates/grep-cli']"
RUSTSEC-2020-0107,hashconsing,https://github.com/AdrienChampion/hashconsing,"['Memory Access', 'Synchronization', 'Memory Management']",2021-10-19 22:14:35+00:00,2020-11-10T12:00:00Z,"[('0.0.0-0', '1.1.0'), ('0', '1.1.0')]","Data races in hashconsing
hashconsing's HConsed lacks Send/Sync bound for its Send/Sync trait.
","An issue was discovered in the hashconsing crate before 1.1.0 for Rust. Because HConsed does not have bounds on its Send trait or Sync trait, memory corruption can occur.
Affected versions of `hashconsing` implements `Send`/`Sync` for its `HConsed` type without restricting it to `Send`able types and `Sync`able types.

This allows non-`Sync` types such as `Cell` to be shared across threads leading to undefined behavior and memory corruption in concurrent programs.
",High,"['https://github.com/AdrienChampion/hashconsing/issues/1', 'https://crates.io/crates/hashconsing', 'https://github.com/AdrienChampion/hashconsing', 'https://rustsec.org/advisories/RUSTSEC-2020-0107.html', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36215']"
GHSA-qgwf-r2jj-2ccv,heapless,https://github.com/japaric/heapless,"['Memory Access', 'Memory Management']",2021-08-18 21:16:38+00:00,2021-08-25T20:56:09Z,"[('0.0.0-0', '0.6.1'), ('0', '0.6.1')]","Use-after-free when cloning a partially consumed `Vec` iterator
Use after free in heapless
","The `IntoIter` `Clone` implementation clones the whole underlying `Vec`.
If the iterator is partially consumed the consumed items will be copied, thus creating a use-after-free access.

A proof of concept is available in the original bug report.
An issue was discovered in the heapless crate before 0.6.1 for Rust. The IntoIter Clone implementation clones an entire underlying Vec without considering whether it has already been partially consumed.
",High,"['https://github.com/japaric/heapless/issues/181', 'https://crates.io/crates/heapless', 'https://github.com/japaric/heapless', 'https://rustsec.org/advisories/RUSTSEC-2020-0145.html', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36464']"
RUSTSEC-2019-0033,http,https://github.com/hyperium/http,"['Risky Values', 'Other', 'Resource Management']",2021-10-19 22:14:35+00:00,2019-11-16T12:00:00Z,"[('0.0.0-0', '0.1.20'), ('0', '0.1.20')]","Integer Overflow/Infinite Loop in the http crate
Integer Overflow in HeaderMap::reserve() can cause Denial of Service
","An issue was discovered in the http crate before 0.1.20 for Rust. An integer overflow in HeaderMap::reserve() could result in denial of service (e.g., an infinite loop).
`HeaderMap::reserve()` used `usize::next_power_of_two()` to calculate the increased capacity.
However, `next_power_of_two()` silently overflows to 0 if given a sufficiently large number
in release mode.

If the map was not empty when the overflow happens,
the library will invoke `self.grow(0)` and start infinite probing.
This allows an attacker who controls the argument to `reserve()`
to cause a potential denial of service (DoS).

The flaw was corrected in 0.1.20 release of `http` crate.
",High,"['https://github.com/hyperium/http', 'https://github.com/hyperium/http/issues/352', 'https://nvd.nist.gov/vuln/detail/CVE-2020-25574', 'https://rustsec.org/advisories/RUSTSEC-2019-0033.html', 'https://crates.io/crates/http']"
RUSTSEC-2019-0034,http,https://github.com/hyperium/http,['Memory Management'],2021-10-19 22:14:35+00:00,2019-11-16T12:00:00Z,"[('0.0.0-0', '0.1.20'), ('0', '0.1.20')]","Double free in http
HeaderMap::Drain API is unsound
","An issue was discovered in the http crate before 0.1.20 for Rust. The HeaderMap::Drain API can use a raw pointer, defeating soundness.
Affected versions of this crate incorrectly used raw pointer,
which introduced unsoundness in its public safe API.

[Failing to drop the Drain struct causes double-free](https://github.com/hyperium/http/issues/354),
and [it is possible to violate Rust's alias rule and cause data race with Drain's Iterator implementation](https://github.com/hyperium/http/issues/355).

The flaw was corrected in 0.1.20 release of `http` crate.
",Critical,"['https://crates.io/crates/http', 'https://nvd.nist.gov/vuln/detail/CVE-2019-25009', 'https://rustsec.org/advisories/RUSTSEC-2019-0034.html']"
RUSTSEC-2021-0078,hyper,https://github.com/hyperium/hyper,['Tainted Input'],2021-10-19 22:14:35+00:00,2021-07-07T12:00:00Z,"[('0.0.0-0', '0.14.10'), ('0', '0.14.10')]","Lenient Parsing of Content-Length Header When Prefixed with Plus Sign
Lenient `hyper` header parsing of `Content-Length` could allow request smuggling
","### Summary

hyper's HTTP/1 server code had a flaw that incorrectly parses and accepts requests with a `Content-Length` header with a prefixed plus sign, when it should have been rejected as illegal. This combined with an upstream HTTP proxy that doesn't parse such `Content-Length` headers, but forwards them, can result in ""request smuggling"" or ""desync attacks"".

### Vulnerability

The flaw exists in all prior versions of hyper, if built with [`rustc` v1.5.0 or newer](https://github.com/rust-lang/rust/pull/28826/commits/123a83326fb95366e94a3be1a74775df4db97739).

Example:

```
GET / HTTP/1.1
Host: example.com
Content-Length: +3

abc
```

This request gets accepted and hyper reads the body as abc. The request _should_ be rejected, according to RFC 7230, since the ABNF for `Content-Length` only allows for `DIGIT`s. This is due to using the `FromStr` implementation for `u64` in the standard library. By differing from the spec, it is possible to send requests like these to endpoints that have different HTTP implementations, with different interpretations of the payload semantics, and cause ""desync attacks"".

In this particular case, an upstream proxy would need to error when parsing the `Content-Length`, but _not_ reject the request (swallowing its own error), and forwarding the request as-is with the `Content-Length` still included. _Then_ the upstream proxy and hyper would disagree on the length of the request body. The combination of these factors would be extremely rare.

Read more about desync attacks: https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn

### Impact

To determine if vulnerable, all these things must be true:

- **Using hyper as an HTTP server**. While the lenient decoder also exists in the client, a vulnerability does not exist around _responses_.
- **Using HTTP/1**. The HTTP/2 code uses a stricter parser.
- **Using a vulnerable HTTP proxy upstream to hyper**. If an upstream proxy correctly rejects the illegal `Content-Length` header, *OR* can parse the length with the plus sign, the desync attack cannot succeed.

### Patches

We have released the following patch versions:

- v0.14.10 (to be released when this advisor is published)

### Workarounds

Besides upgrading hyper, you can take the following options:

- Reject requests manually that contain a plus sign prefix in the `Content-Length` header.
- Ensure any upstream proxy handles `Content-Length` headers with a plus sign prefix.

### Credits
This issue was initially reported by [Mattias Grenfeldt](https://grenfeldt.dev/) and Asta Olofsson.
`hyper`'s HTTP header parser accepted, according to RFC 7230, illegal contents inside `Content-Length` headers.
Due to this, upstream HTTP proxies that ignore the header may still forward them along if it chooses to ignore the error.

To be vulnerable, `hyper` must be used as an HTTP/1 server and using an HTTP proxy upstream that ignores the header's contents
but still forwards it. Due to all the factors that must line up, an attack exploiting this vulnerability is unlikely.
",Low,"['https://github.com/hyperium/hyper', 'https://github.com/hyperium/hyper/security/advisories/GHSA-f3pg-qwvg-p99c', 'https://nvd.nist.gov/vuln/detail/CVE-2021-32715', 'https://crates.io/crates/hyper', 'https://rustsec.org/advisories/RUSTSEC-2021-0078.html', 'https://github.com/rust-lang/rust/pull/28826/commits/123a83326fb95366e94a3be1a74775df4db97739']"
GHSA-9xjr-m6f3-v5wm,hyper,https://github.com/hyperium/hyper,['Cryptography'],2021-08-19 21:25:12+00:00,2021-08-25T20:43:06Z,"[('0', '0.9.4'), ('0.0.0-0', '0.9.4')]","HTTPS MitM vulnerability due to lack of hostname verification
HTTPS MitM vulnerability due to lack of hostname verification
","When used on Windows platforms, all versions of Hyper prior to 0.9.4 did not
perform hostname verification when making HTTPS requests.

This allows an attacker to perform MitM attacks by preventing any valid
CA-issued certificate, even if there's a hostname mismatch.

The problem was addressed by leveraging rust-openssl's built-in support for
hostname verification.
An issue was discovered in the hyper crate before 0.9.4 for Rust on Windows. There is an HTTPS man-in-the-middle vulnerability because hostname verification was omitted.
",Medium,"['https://crates.io/crates/hyper', 'https://rustsec.org/advisories/RUSTSEC-2016-0002.html', 'https://github.com/hyperium/hyper/blob/master/CHANGELOG.md#v094-2016-05-09', 'https://nvd.nist.gov/vuln/detail/CVE-2016-10932']"
GHSA-5h46-h7hh-c6x9,hyper,https://github.com/hyperium/hyper,['Risky Values'],2021-09-07 21:47:36+00:00,2021-07-12T16:55:37Z,"[('0.0.0-0', '0.14.10'), ('0', '0.14.10')]","Integer overflow in `hyper`'s parsing of the `Transfer-Encoding` header leads to data loss
Integer Overflow in Chunked Transfer-Encoding
","When decoding chunk sizes that are too large, `hyper`'s code would encounter an integer overflow. Depending on the situation,
this could lead to data loss from an incorrect total size, or in rarer cases, a request smuggling attack.

To be vulnerable, you must be using `hyper` for any HTTP/1 purpose, including as a client or server, and consumers must send
requests or responses that specify a chunk size greater than 18 exabytes. For a possible request smuggling attack to be possible,
any upstream proxies must accept a chunk size greater than 64 bits.
### Summary

hyper's HTTP server and client code had a flaw that could trigger an integer overflow when decoding chunk sizes that are too big. This allows possible data loss, or if combined with an upstream HTTP proxy that allows chunk sizes larger than hyper does, can result in ""request smuggling"" or ""desync attacks"".

### Vulnerability

Example:

```
GET / HTTP/1.1
Host: example.com
Transfer-Encoding: chunked

f0000000000000003
abc
0

```

hyper only reads the rightmost 64-bit integer as the chunk size. So it reads `f0000000000000003` as `3`. A loss of data can occur since hyper would then read only 3 bytes of the body. Additionally, an HTTP request smuggling vulnerability would occur if using a proxy which instead has prefix truncation in the chunk size, or that understands larger than 64-bit chunk sizes.

Read more about desync attacks: https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn

### Impact

To determine if vulnerable to _data loss_, these things must be true:

- **Using HTTP/1.1.** Since HTTP/2 does not use chunked encoding, it is not vulnerable.
- **Using hyper as a server or client.** The body would be improperly truncated in either case.
- **Users send requests or responses with chunk sizes greater than 18 exabytes**.

To determine if vulnerable to _desync attacks_, these things must be true:

- **Using an upstream proxy that allows chunks sizes larger than 64-bit.** If the proxy rejects chunk sizes that are too large, that request won't be forwarded to hyper.

### Patches

We have released the following patch versions:

 - v0.14.10 (to be released when this advisory is published)

### Workarounds

Besides upgrading hyper, you can take the following options:

- Reject requests manually that contain a `Transfer-Encoding` header.
- Ensure any upstream proxy rejects `Transfer-Encoding` chunk sizes greater than what fits in 64-bit unsigned integers.


### Credits
This issue was initially reported by [Mattias Grenfeldt](https://grenfeldt.dev/) and Asta Olofsson.
",Critical,"['https://github.com/hyperium/hyper', 'https://github.com/hyperium/hyper/security/advisories/GHSA-5h46-h7hh-c6x9', 'https://nvd.nist.gov/vuln/detail/CVE-2021-32714', 'https://rustsec.org/advisories/RUSTSEC-2021-0079.html', 'https://crates.io/crates/hyper']"
RUSTSEC-2020-0008,hyper,https://github.com/hyperium/hyper,['Tainted Input'],2021-10-19 22:14:35+00:00,2020-03-19T12:00:00Z,"[('0.11.0', '0.12.34')]","HTTP Request Smuggling in hyper
Flaw in hyper allows request smuggling by sending a body in GET requests
","An issue was discovered in the hyper crate before 0.12.34 for Rust. HTTP request smuggling can occur. Remote code execution can occur in certain situations with an HTTP server on the loopback interface.
Vulnerable versions of hyper allow GET requests to have bodies, even if there is
no Transfer-Encoding or Content-Length header.  As per the HTTP 1.1
specification, such requests do not have bodies, so the body will be interpreted
as a separate HTTP request.

This allows an attacker who can control the body and method of an HTTP request
made by hyper to inject a request with headers that would not otherwise be
allowed, as demonstrated by sending a malformed HTTP request from a Substrate
runtime.  This allows bypassing CORS restrictions.  In combination with other
vulnerabilities, such as an exploitable web server listening on loopback, it may
allow remote code execution.

The flaw was corrected in hyper version 0.12.34.
",Critical,"['https://github.com/hyperium/hyper', 'https://rustsec.org/advisories/RUSTSEC-2020-0008.html', 'https://github.com/hyperium/hyper/issues/1925', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35863', 'https://crates.io/crates/hyper']"
GHSA-6hfq-h8hq-87mf,hyper,https://github.com/hyperium/hyper,['Tainted Input'],2021-08-18 21:07:17+00:00,2021-08-25T20:56:18Z,"[('0.12.0', '0.12.36'), ('0.13.0', '0.13.10'), ('0.14.0', '0.14.3')]","Multiple Transfer-Encoding headers misinterprets request payload
HTTP Request Smuggling in hyper
","hyper's HTTP server code had a flaw that incorrectly understands some requests
with multiple transfer-encoding headers to have a chunked payload, when it
should have been rejected as illegal. This combined with an upstream HTTP proxy
that understands the request payload boundary differently can result in
""request smuggling"" or ""desync attacks"".
### Summary

hyper's HTTP server code had a flaw that incorrectly understands some requests with multiple transfer-encoding headers to have a chunked payload, when it should have been rejected as illegal. This combined with an upstream HTTP proxy that understands the request payload boundary differently can result in ""request smuggling"" or ""desync attacks"".

### Vulnerability

The flaw was introduced in https://github.com/hyperium/hyper/commit/26417fc24a7d05df538e0f39239b373c5c3d61f6, released in v0.12.0.

Consider this example request:

```
POST /yolo HTTP/1.1
Transfer-Encoding: chunked
Transfer-Encoding: cow
```

This request *should* be rejected, according to RFC 7230, since it has a `Transfer-Encoding` header, but after folding, it does not end in `chunked`. hyper would notice the `chunked` in the first line, and then check the second line, and thanks to a missing boolean assignment, *not* set the error condition. hyper would treat the payload as being `chunked`. By differing from the spec, it is possible to send requests like these to endpoints that have different HTTP implementations, with different interpretations of the payload semantics, and cause ""desync attacks"".

There are several parts of the spec that must also be checked, and hyper correctly handles all of those. Additionally, hyper's *client* does not allow sending requests with improper headers, so the misunderstanding cannot be propagated further.

Read more about desync attacks: https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn

### Impact

To determine if vulnerable, all these things must be true:

- **Using hyper as an HTTP *server*.** The client is not affected.
- **Using HTTP/1.1.** HTTP/2 does not use `transfer-encoding`.
- **Using a vulnerable HTTP proxy upstream to hyper.** If an upstream proxy correctly rejects the illegal transfer-encoding headers, the desync attack cannot succeed. If there is *no* proxy upstream of hyper, hyper cannot *start* the desync attack, as the client will repair the headers before forwarding.

### Patches

We have released and backported the following patch versions:

- v0.14.3
- v0.13.10

### Workarounds

Besides upgrading hyper, you can take the following options:

- Reject requests that contain a `transfer-encoding` header.
- Ensure any upstream proxy handles `transfer-encoding` correctly.

### Credits

This issue was initially reported by ZeddYu Lu From Qi An Xin Technology Research Institute.
",High,"['https://github.com/hyperium/hyper', 'https://github.com/hyperium/hyper/commit/8f93123efef5c1361086688fe4f34c83c89cec02', 'https://crates.io/crates/hyper', 'https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn', 'https://nvd.nist.gov/vuln/detail/CVE-2021-21299', 'https://rustsec.org/advisories/RUSTSEC-2021-0020.html', 'https://github.com/hyperium/hyper/security/advisories/GHSA-6hfq-h8hq-87mf']"
RUSTSEC-2022-0022,hyper,https://github.com/hyperium/hyper,[],2022-05-20 11:16:20+00:00,2022-05-10T12:00:00Z,"[('0.0.0-0', '0.14.12')]","Parser creates invalid uninitialized value
","Affected versions of this crate called `mem::uninitialized()` in the HTTP1 parser to create values of type `httparse::Header` (from the `httparse` crate).
This is unsound, since `Header` contains references and thus must be non-null.
 
The flaw was corrected by avoiding the use of `mem::uninitialized()`, using `MaybeUninit` instead.
",nan,"['https://crates.io/crates/hyper', 'https://github.com/hyperium/hyper/pull/2545', 'https://rustsec.org/advisories/RUSTSEC-2022-0022.html']"
RUSTSEC-2017-0002,hyper,https://github.com/hyperium/hyper,['Tainted Input'],2021-10-19 22:14:35+00:00,2017-01-23T12:00:00Z,"[('0', '0.10.2'), ('0.0.0-0', '0.9.18')]","Headers containing newline characters can split messages in hyper
headers containing newline characters can split messages
","An issue was discovered in the hyper crate before 0.9.18 for Rust. It mishandles newlines in headers.
Serializing of headers to the socket did not filter the values for newline bytes (`\r` or `\n`),
which allowed for header values to split a request or response. People would not likely include
newlines in the headers in their own applications, so the way for most people to exploit this
is if an application constructs headers based on unsanitized user input.

This issue was fixed by replacing all newline characters with a space during serialization of
a header value.
",Medium,"['https://github.com/hyperium/hyper', 'https://nvd.nist.gov/vuln/detail/CVE-2017-18587', 'https://rustsec.org/advisories/RUSTSEC-2017-0002.html', 'https://github.com/hyperium/hyper/wiki/Security-001', 'https://crates.io/crates/hyper']"
RUSTSEC-2021-0068,iced-x86,https://github.com/icedland/iced,['Memory Access'],2021-11-06 20:37:35+00:00,2021-05-19T12:00:00Z,"[('0.0.0-0', '1.10.4-0'), ('0', '1.11.0')]","Incorrect buffer size calculation in iced-x86
Soundness issue in `iced-x86` versions <= 1.10.3
","An issue was discovered in the iced-x86 crate through 1.10.3 for Rust. In Decoder::new(), slice.get_unchecked(slice.length()) is used unsafely.
Versions of iced-x86 <= 1.10.3 invoke undefined behavior which may cause soundness
issues in crates using the `iced_x86::Decoder` struct. The `Decoder::new()` function
made a call to `slice.get_unchecked(slice.length())` to get the end position of 
the input buffer. The flaw was fixed with safe logic that does not invoke undefined
behavior.

More details can be found at <https://github.com/icedland/iced/issues/168>.
",Critical,"['https://crates.io/crates/iced-x86', 'https://github.com/icedland/iced/commit/3c607a003e03b773108401d109167d1840487dce', 'https://github.com/icedland/iced', 'https://github.com/icedland/iced/issues/168', 'https://rustsec.org/advisories/RUSTSEC-2021-0068.html', 'https://nvd.nist.gov/vuln/detail/CVE-2021-38188']"
RUSTSEC-2021-0052,id-map,https://github.com/andrewhickman/id-map,['Memory Management'],2021-04-13 21:10:09+00:00,2021-02-26T12:00:00Z,"[('0.0.0-0', None), ('0', None)]","Double-free in id-map
Double-free in id-map
Double-free in id-map
Multiple functions can cause double-frees
","An issue was discovered in the id-map crate through 2021-02-26 for Rust. A double free can occur in remove_set upon a panic in a Drop impl.
An issue was discovered in the id-map crate through 2021-02-26 for Rust. A double free can occur in IdMap::clone_from upon a .clone panic.
An issue was discovered in the id-map crate through 2021-02-26 for Rust. A double free can occur in get_or_insert upon a panic of a user-provided f function.
The following functions in the crate are affected:

## `IdMap::clone_from`

The `clone_from` implementation for `IdMap` drops the values present in the
map and then begins cloning values from the other map. If a `.clone()` call
pancics, then the afformentioned dropped elements can be freed again.

## `get_or_insert`

`get_or_insert` reserves space for a value, before calling the user provided
insertion function `f`. If the function `f` panics then uninitialized or
previously freed memory can be dropped.

## `remove_set`

When removing a set of elements, `ptr::drop_in_place` is called on each of the
element to be removed. If the `Drop` impl of one of these elements panics then
the previously dropped elements can be dropped again.
",Critical,"['https://nvd.nist.gov/vuln/detail/CVE-2021-30457', 'https://github.com/andrewhickman/id-map', 'https://nvd.nist.gov/vuln/detail/CVE-2021-30455', 'https://github.com/andrewhickman/id-map/issues/3', 'https://crates.io/crates/id-map', 'https://rustsec.org/advisories/RUSTSEC-2021-0052.html', 'https://nvd.nist.gov/vuln/detail/CVE-2021-30456']"
RUSTSEC-2020-0096,im,https://github.com/bodil/im-rs,['Synchronization'],2021-10-19 22:14:35+00:00,2020-11-09T12:00:00Z,"[('12.0.0', None)]","Data races in im
TreeFocus lacks bounds on its Send and Sync traits
","An issue was discovered in the im crate through 2020-11-09 for Rust. Because TreeFocus does not have bounds on its Send trait or Sync trait, a data race can occur.
Affected versions of `im` contains `TreeFocus` that unconditionally implements `Send` and `Sync`.

This allows a data race in safe Rust code if `TreeFocus` is extracted from `Focus` type.
Typical users that only use `Focus` type are not affected.
",Medium,"['https://github.com/bodil/im-rs', 'https://rustsec.org/advisories/RUSTSEC-2020-0096.html', 'https://github.com/bodil/im-rs/issues/157', 'https://crates.io/crates/im', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36204']"
GHSA-m2pf-hprp-3vqm,image,https://github.com/image-rs/image,['Memory Access'],2021-08-19 21:22:44+00:00,2021-08-25T20:44:43Z,"[('0', '0.21.3'), ('0.10.2', '0.21.3')]","Flaw in interface may drop uninitialized instance of arbitrary types
Use after free in image
","Affected versions of this crate would call `Vec::set_len` on an uninitialized
vector with user-provided type parameter, in an interface of the HDR image
format decoder. They would then also call other code that could panic before
initializing all instances.

This could run Drop implementations on uninitialized types, equivalent to
use-after-free, and allow an attacker arbitrary code execution.

Two different fixes were applied. It is possible to conserve the interface by
ensuring proper initialization before calling `Vec::set_len`. Drop is no longer
called in case of panic, though.

Starting from version `0.22`, a breaking change to the interface requires
callers to pre-allocate the output buffer and pass a mutable slice instead,
avoiding all unsafe code.
An issue was discovered in the image crate before 0.21.3 for Rust, affecting the HDR image format decoder. Vec::set_len is called on an uninitialized vector, leading to a use-after-free and arbitrary code execution.
",Critical,"['https://nvd.nist.gov/vuln/detail/CVE-2019-16138', 'https://rustsec.org/advisories/RUSTSEC-2019-0014.html', 'https://github.com/image-rs/image', 'https://crates.io/crates/image', 'https://github.com/image-rs/image/pull/985']"
RUSTSEC-2020-0073,image,https://github.com/image-rs/image,['Resource Management'],2021-10-19 22:14:35+00:00,2020-11-12T12:00:00Z,"[('0.0.0-0', '0.23.12'), ('0', '0.23.12')]","Mutable reference with immutable provenance in image
Mutable reference with immutable provenance
","An issue was discovered in the image crate before 0.23.12 for Rust. A Mutable reference has immutable provenance. (In the case of LLVM, the IR may be always correct.)
A mutable reference to a struct was constructed by dereferencing a pointer
obtained from `slice::as_ptr`. Instead, `slice::as_mut_ptr` should have been
called on the mutable slice argument. The former performs an implicit reborrow
as an immutable shared reference which does not allow writing through the
derived pointer.

There is no evidence for miscompilation, exploitable or otherwise, caused by
this bug. [Further investigation on Zulip][Zulip] suggests that the unoptimized
generated LLVM IR does not contain any UB itself, effectively mitigating
further effects.

[Zulip]: https://rust-lang.zulipchat.com/#narrow/stream/146229-wg-secure-code/topic/Implications.20of.20using.20.60slice.3A.3Aas_ptr.60.20for.20mutable.20access/near/216499472
",Medium,"['https://github.com/image-rs/image', 'https://github.com/image-rs/image/issues/1357', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35916', 'https://crates.io/crates/image', 'https://rustsec.org/advisories/RUSTSEC-2020-0073.html']"
RUSTSEC-2021-0042,insert_many,https://github.com/rphmeier/insert_many.git,['Memory Management'],2021-10-19 22:14:35+00:00,2021-01-26T12:00:00Z,"[('0.0.0-0', None), ('0', None)]","Double free in insert_many
insert_many can drop elements twice on panic
","An issue was discovered in the insert_many crate through 2021-01-26 for Rust. Elements may be dropped twice if a .next() method panics.
Affected versions of `insert_many` used `ptr::copy` to move over items in a
vector to make space before inserting, duplicating their ownership. It then
iterated over a provided `Iterator` to insert the new items.

If the iterator's `.next()` method panics then the vector would drop the same
elements twice.
",High,"['https://nvd.nist.gov/vuln/detail/CVE-2021-29933', 'https://crates.io/crates/insert_many', 'https://github.com/rphmeier/insert_many', 'https://github.com/rphmeier/insert_many/issues/1', 'https://rustsec.org/advisories/RUSTSEC-2021-0042.html']"
RUSTSEC-2021-0002,interfaces2,https://github.com/aep/interfaces-rs,[],2021-01-06 16:07:19+00:00,2021-01-04T12:00:00Z,"[('0.0.0-0', None)]","interfaces2 is unmaintained, use interfaces instead
","The `interfaces2` crate is not maintained any more;
use [`interfaces`](https://crates.io/crates/interfaces) instead.
",nan,"['https://github.com/aep/interfaces-rs', 'https://crates.io/crates/interfaces2', 'https://rustsec.org/advisories/RUSTSEC-2021-0002.html']"
RUSTSEC-2021-0036,internment,https://github.com/droundy/internment,['Synchronization'],2021-10-19 22:14:35+00:00,2021-03-03T12:00:00Z,"[('0.0.0-0', '0.4.2'), ('0', '0.4.2')]","Data race in internment
Intern<T>: Data race allowed on T
","An issue was discovered in the internment crate before 0.4.2 for Rust. There is a data race that can cause memory corruption because of the unconditional implementation of Sync for Intern<T>.
Affected versions of this crate unconditionally implements `Sync` for `Intern<T>`.
This allows users to create data race on `T: !Sync`, which may lead to undefined behavior
(for example, memory corruption).

The flaw was corrected in commit 2928a87 by adding the trait bound `T: Sync` in the `Sync` impl of `Intern<T>`.
",Critical,"['https://github.com/droundy/internment/issues/20', 'https://rustsec.org/advisories/RUSTSEC-2021-0036.html', 'https://github.com/droundy/internment', 'https://nvd.nist.gov/vuln/detail/CVE-2021-28037', 'https://crates.io/crates/internment']"
RUSTSEC-2020-0017,internment,https://github.com/droundy/internment,"['Synchronization', 'Memory Management']",2021-10-19 22:14:35+00:00,2020-05-28T12:00:00Z,"[('0.3.12', '0.4.0')]","Use after free in internment
Use after free in ArcIntern::drop
","An issue was discovered in the internment crate through 2020-05-28 for Rust. ArcIntern::drop has a race condition and resultant use-after-free.
`ArcIntern::drop` has a race condition where it can release memory
which is about to get another user. The new user will get a reference
to freed memory.

This was fixed by serializing access to an interned object while it
is being deallocated.

Versions prior to 0.3.12 used stronger locking which avoided the problem.
",High,"['https://nvd.nist.gov/vuln/detail/CVE-2020-35874', 'https://github.com/droundy/internment/issues/11', 'https://github.com/droundy/internment', 'https://crates.io/crates/internment', 'https://rustsec.org/advisories/RUSTSEC-2020-0017.html']"
RUSTSEC-2021-0025,jsonrpc-quic,https://github.com/maidsafe/safe-api,[],2021-02-15 16:43:30+00:00,2021-02-15T12:00:00Z,"[('0.0.0-0', None)]","crate has been renamed to `qjsonrpc`
","This crate has been renamed from `jsonrpc-quic` to `qjsonrpc`.

The new repository location is:

<https://github.com/maidsafe/sn_api>
",nan,"['https://crates.io/crates/jsonrpc-quic', 'https://rustsec.org/advisories/RUSTSEC-2021-0025.html', 'https://github.com/maidsafe/sn_api/pull/623']"
GHSA-g83m-67wh-whpw,kekbit,https://github.com/motoras/kekbit,"['Synchronization', 'Memory Management', 'Tainted Input']",2021-08-18 20:31:24+00:00,2021-08-25T20:57:10Z,"[('0', '0.3.4'), ('0.0.0-0', '0.3.4')]","ShmWriter allows sending non-Send type across threads
Command injection in kekbit
","Affected versions of this crate implement `Send` for `ShmWriter<H>` without requiring `H: Send`. This allows users to send `H: !Send` to other threads, which can potentially lead to data races and undefined behavior.
An issue was discovered in the kekbit crate before 0.3.4 for Rust. For ShmWriter<H>, Send is implemented without requiring H: Send.
",High,"['https://github.com/motoras/kekbit/issues/34', 'https://crates.io/crates/kekbit', 'https://github.com/motoras/kekbit', 'https://rustsec.org/advisories/RUSTSEC-2020-0129.html', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36449']"
GHSA-wr55-mf5c-hhwm,late-static,https://github.com/richard-w/late-static,"['Synchronization', 'Memory Management']",2021-08-19 18:52:13+00:00,2021-08-25T20:50:44Z,"[('0.0.0-0', '0.4.0'), ('0', '0.4.0')]","LateStatic has incorrect Sync bound
Data races in late-static
","Affected versions of this crate implemented `Sync` for `LateStatic` with `T: Send`, so that it is possible to create a data race to a type `T: Send + !Sync` (e.g. `Cell<T>`).

This can result in a memory corruption or other kinds of undefined behavior.

The flaw was corrected in commit 11f396c by replacing the `T: Send` bound to `T: Sync` bound in the `Sync` impl for `LateStatic<T>`.
An issue was discovered in the late-static crate before 0.4.0 for Rust. Because Sync is implemented for LateStatic with T: Send, a data race can occur.
",High,"['https://crates.io/crates/late-static', 'https://github.com/Richard-W/late-static/issues/1', 'https://github.com/Richard-W/late-static', 'https://rustsec.org/advisories/RUSTSEC-2020-0102.html', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36209']"
RUSTSEC-2021-0004,lazy-init,https://github.com/khuey/lazy-init,"['Memory Access', 'Memory Management']",2021-10-19 22:14:35+00:00,2021-01-17T12:00:00Z,"[('0', '0.5.0'), ('0.0.0-0', '0.4.1-0')]","Out of bounds read in lazy-init
Missing Send bound for Lazy
","An issue was discovered in the lazy-init crate through 2021-01-17 for Rust. Lazy lacks a Send bound, leading to a data race.
All current versions of this crate allow causing data races in safe code.

The flaw will be fixed in the next release.
",Medium,"['https://github.com/khuey/lazy-init', 'https://nvd.nist.gov/vuln/detail/CVE-2021-25901', 'https://rustsec.org/advisories/RUSTSEC-2021-0004.html', 'https://crates.io/crates/lazy-init', 'https://github.com/khuey/lazy-init/issues/9']"
GHSA-qc36-q22q-cjw3,lettre,https://github.com/lettre/lettre,['Tainted Input'],2021-08-18 18:52:26+00:00,2021-07-12T17:03:27Z,"[('0.7.0', '0.9.6')]","SMTP command injection in body
SMTP command injection in lettre
","Affected versions of lettre allowed SMTP command injection through an attacker's controlled message body. The module for escaping lines starting with a period wouldn't catch a period that was placed after a double CRLF sequence, allowing the attacker to end the current message and write arbitrary SMTP commands after it.

The flaw is fixed by correctly handling consecutive CRLF sequences.
### Impact

Affected versions of lettre allowed SMTP command injection through an attacker's controlled message body. The module for escaping lines starting with a period wouldn't catch a period that was placed after a double CRLF sequence, allowing the attacker to end the current message and write arbitrary SMTP commands after it.

### Fix

The flaw is fixed by correctly handling consecutive CRLF sequences.

### References

* [RUSTSEC-2021-0069](https://rustsec.org/advisories/RUSTSEC-2021-0069.html)




",nan,"['https://github.com/lettre/lettre/commit/8bfc20506cc5e098fe6eb3d1cafe3bea791215ce', 'https://rustsec.org/advisories/RUSTSEC-2021-0069.html', 'https://github.com/lettre/lettre/security/advisories/GHSA-qc36-q22q-cjw3', 'https://github.com/lettre/lettre', 'https://github.com/lettre/lettre/pull/627/commits/93458d01fed0ec81c0e7b4e98e6f35961356fae2', 'https://crates.io/crates/lettre']"
GHSA-vc2p-r46x-m3vx,lettre,https://github.com/lettre/lettre,"['Path Resolution', 'Other', 'Tainted Input']",2021-08-18 20:59:57+00:00,2021-08-25T20:56:48Z,"[('0.9.0', '0.9.5'), ('0.8.0', '0.8.4'), ('0', '0.7.1'), ('0.7.0', '0.7.1')]","Argument injection in sendmail transport
Argument injection in lettre
","Affected versions of lettre allowed argument injection
to the sendmail command. It was possible, using forged `to` addresses,
to pass arbitrary arguments to the sendmail executable.

Depending on the implementation (original sendmail, postfix, exim, etc.)
it could be possible in some cases to write email data into arbitrary files (using sendmail's
logging features).
 
The flaw is corrected by modifying the executed command to stop parsing arguments
before passing the destination addresses.

NOTE: This vulnerability only affects the `sendmail` transport. Others, including `smtp`, are not
affected.

This vulnerability was reported by vin01.
### Impact

Affected versions of lettre allowed argument injection to the sendmail command. It was possible, using forged to addresses, to pass arbitrary arguments to the sendmail executable.

Depending on the implementation (original sendmail, postfix, exim, etc.) it could be possible in some cases to write email data into abritrary files (using sendmail's logging features).

*NOTE*: This vulnerability only affects the sendmail transport. Others, including smtp, are not affected.

### Fix

The flaw is corrected by modifying the executed command to stop parsing arguments before passing the destination addresses.

### References

* [RUSTSEC-2020-0069](https://rustsec.org/advisories/RUSTSEC-2020-0069.html)
* [CVE-2020-28247](https://nvd.nist.gov/vuln/detail/CVE-2020-28247)
",Medium,"['https://github.com/RustSec/advisory-db/pull/478/files', 'https://rustsec.org/advisories/RUSTSEC-2020-0069.html', 'https://nvd.nist.gov/vuln/detail/CVE-2020-28247', 'https://github.com/lettre/lettre', 'https://github.com/lettre/lettre/pull/508/commits/bbe7cc5381c5380b54fb8bbb4f77a3725917ff0b', 'https://crates.io/crates/lettre', 'https://github.com/lettre/lettre/security/advisories/GHSA-vc2p-r46x-m3vx']"
RUSTSEC-2020-0137,lever,https://github.com/vertexclique/lever,"['Synchronization', 'Memory Management', 'Tainted Input']",2021-10-19 22:14:35+00:00,2020-11-10T12:00:00Z,"[('0.0.0-0', '0.1.1'), ('0', '0.1.1')]","Data races in lever
AtomicBox<T> lacks bound on its Send and Sync traits allowing data races
","An issue was discovered in the lever crate before 0.1.1 for Rust. AtomicBox<T> implements the Send and Sync traits for all types T. This allows non-Send types such as Rc and non-Sync types such as Cell to be used across thread boundaries which can trigger undefined behavior and memory corruption.
`AtomicBox<T>` is a `Box` type designed to be used across threads, however, it
implements the `Send` and `Sync` traits for all types `T`.

This allows non-Send types such as `Rc` and non-Sync types such as `Cell` to
be used across thread boundaries which can trigger undefined behavior and
memory corruption.
",High,"['https://crates.io/crates/lever', 'https://github.com/vertexclique/lever', 'https://rustsec.org/advisories/RUSTSEC-2020-0137.html', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36457', 'https://github.com/vertexclique/lever/issues/15']"
RUSTSEC-2020-0138,lexer,https://github.com/aicacia/rs-lexer.git,"['Synchronization', 'Memory Management', 'Tainted Input']",2021-10-19 22:14:35+00:00,2020-11-10T12:00:00Z,"[('0.0.0-0', None), ('0', None)]","Data races in lexer
ReaderResult should be bounded by Sync
","lexer is a plugin based lexical reader.Affected versions of this crate implements Sync for ReaderResult<T, E> with the trait bound T: Send, E: Send. Since matching on the public enum ReaderResult<T, E> provides access to &T & &E, allowing data race to a non-Sync type T or E. This can result in a memory corruption when multiple threads concurrently access &T or &E. Suggested fix for the bug is change the trait bounds imposed on T & E to be T: Sync, E: Sync.
Affected versions of this crate implements `Sync` for `ReaderResult<T, E>` with the trait bound `T: Send, E: Send`.

Since matching on the public enum `ReaderResult<T, E>` provides access to `&T` & `&E`,
allowing data race to a non-Sync type `T` or `E`.
This can result in a memory corruption when multiple threads concurrently access `&T` or `&E`.

Suggested fix for the bug is change the trait bounds imposed on `T` & `E` to be `T: Sync, E: Sync`.
",High,"['https://nvd.nist.gov/vuln/detail/CVE-2020-36458', 'https://rustsec.org/advisories/RUSTSEC-2020-0138.html', 'https://crates.io/crates/lexer', 'https://gitlab.com/nathanfaucett/rs-lexer/-/issues/2', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/lexer/RUSTSEC-2020-0138.md', 'https://gitlab.com/nathanfaucett/rs-lexer']"
GHSA-rpcm-whqc-jfw8,libflate,https://github.com/sile/libflate,['Memory Access'],2021-08-19 21:22:31+00:00,2021-08-25T20:44:53Z,"[('0', '0.1.25'), ('0.1.14', '0.1.25')]","MultiDecoder::read() drops uninitialized memory of arbitrary type on panic in client code
Use after free in libflate
","Affected versions of libflate have set a field of an internal structure with a generic type to an uninitialized value in `MultiDecoder::read()` and reverted it to the original value after the function completed. However, execution of `MultiDecoder::read()` could be interrupted by a panic in caller-supplied `Read` implementation. This would cause `drop()` to be called on uninitialized memory of a generic type implementing `Read`.

This is equivalent to a use-after-free vulnerability and could allow an attacker to gain arbitrary code execution.

The flaw was corrected by aborting immediately instead of unwinding the stack in case of panic within `MultiDecoder::read()`. The issue was discovered and fixed by Shnatsel.
An issue was discovered in the libflate crate before 0.1.25 for Rust. MultiDecoder::read has a use-after-free, leading to arbitrary code execution.
",Critical,"['https://github.com/sile/libflate/issues/35', 'https://github.com/sile/libflate', 'https://rustsec.org/advisories/RUSTSEC-2019-0010.html', 'https://crates.io/crates/libflate', 'https://nvd.nist.gov/vuln/detail/CVE-2019-15552']"
RUSTSEC-2019-0004,libp2p-core,https://github.com/libp2p/rust-libp2p,['Cryptography'],2021-10-19 22:14:35+00:00,2019-05-15T12:00:00Z,"[('0.3.0', '0.7.1'), ('0', '0.8.1')]","Failure to properly verify ed25519 signatures in libp2p-core
Failure to properly verify ed25519 signatures makes any signature valid
","An issue was discovered in the libp2p-core crate before 0.8.1 for Rust. Attackers can spoof ed25519 signatures.
Affected versions of this crate did not properly verify ed25519 signatures.
Any signature with a correct length was considered valid.

This allows an attacker to impersonate any node identity.
",High,"['https://nvd.nist.gov/vuln/detail/CVE-2019-15545', 'https://github.com/libp2p/rust-libp2p', 'https://crates.io/crates/libp2p-core', 'https://rustsec.org/advisories/RUSTSEC-2019-0004.html']"
RUSTSEC-2022-0009,libp2p-core,https://github.com/libp2p/rust-libp2p,['Cryptography'],2022-02-07 14:18:27+00:00,2022-02-07T12:00:00Z,"[('0.30.0-rc.1', '0.30.2')]","Failure to verify the public key of a `SignedEnvelope` against the `PeerId` in a `PeerRecord`
","Affected versions of this crate did not check that the public key the signature was created with matches the peer ID of the peer record. 
Any combination was considered valid.

This allows an attacker to republish an existing `PeerRecord` with a different `PeerId`.
",nan,"['https://rustsec.org/advisories/RUSTSEC-2022-0009.html', 'https://crates.io/crates/libp2p-core']"
RUSTSEC-2020-0123,libp2p-deflate,https://github.com/libp2p/rust-libp2p,"['Memory Access', 'Exception Management']",2021-10-19 22:14:35+00:00,2020-01-24T12:00:00Z,"[('0.0.0-0', '0.27.1'), ('0', '0.27.1')]","Use of Uninitialized Resource in libp2p-deflate
Contents of uninitialized memory exposed in DeflateOutput's AsyncRead implementation
","An issue was discovered in the libp2p-deflate crate before 0.27.1 for Rust. An uninitialized buffer is passed to AsyncRead::poll_read(), which is a user-provided trait function.
Affected versions of this crate passes an uninitialized buffer to a user-provided trait function `AsyncRead::poll_read()`.

Arbitrary `AsyncRead::poll_read()` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.
Reading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.

The flaw was fixed in commit 5ba266a by ensuring the newly allocated part of the buffer is zero-initialized before passing it to a user-provided `AsyncRead::poll_read()`.
",Critical,"['https://github.com/libp2p/rust-libp2p', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36443', 'https://rustsec.org/advisories/RUSTSEC-2020-0123.html', 'https://crates.io/crates/libp2p-deflate', 'https://github.com/libp2p/rust-libp2p/issues/1932']"
GHSA-6gvc-4jvj-pwq4,libpulse-binding,https://github.com/jnqnfe/pulse-binding-rust,"['Memory Access', 'Memory Management']",2021-09-27 15:46:50+00:00,2021-08-30T16:22:34Z,"[('1.0.5', '2.5.0')]","Possible use-after-free with `proplist::Iterator`
Use after free in libpulse-binding
","Affected versions contained a possible use-after-free issue with property list iteration
due to a lack of a lifetime constraint tying the lifetime of a `proplist::Iterator` to the
`Proplist` object for which it was created. This made it possible for users, without
experiencing a compiler error/warning, to destroy the `Proplist` object before the iterator,
thus destroying the underlying C object the iterator works upon, before the iterator may be
finished with it.

This impacts all versions of the crate before `2.5.0` back to `1.0.5`. Before version
`1.0.5` the function that produces the iterator was broken to the point of being useless.
An issue was discovered in the libpulse-binding crate before 2.5.0 for Rust. proplist::Iterator can cause a use-after-free. 
",Medium,"['https://nvd.nist.gov/vuln/detail/CVE-2018-25001', 'https://crates.io/crates/libpulse-binding', 'https://rustsec.org/advisories/RUSTSEC-2018-0020.html', 'https://github.com/advisories/GHSA-6gvc-4jvj-pwq4', 'https://github.com/jnqnfe/pulse-binding-rust']"
GHSA-jqpv-jm4m-86j9,libpulse-binding,https://github.com/jnqnfe/pulse-binding-rust,"['Memory Access', 'Memory Management']",2022-01-06 18:29:31+00:00,2022-01-06T22:17:50Z,"[('0', '1.2.1'), ('0.0.0-0', '1.2.1')]","Use-after-free with objects returned by `Stream`'s `get_format_info` and `get_context` methods
Use After Free in libpulse-binding
Use after free in libpulse-binding
Use After Free in libpulse-binding
","Affected versions contained a pair of use-after-free issues with the objects returned by the `get_format_info` and `get_context` methods of `Stream` objects. These objects were mistakenly being constructed without setting an important flag to prevent destruction of the underlying C objects they reference upon their own destruction.
An issue was discovered in the libpulse-binding crate before 1.2.1 for Rust. get_format_info can cause a use-after-free.
### Overview

Version 1.2.1 of the `libpulse-binding` Rust crate, released on the 15th of June 2018, fixed a pair of use-after-free issues with the objects returned by the `get_format_info` and `get_context` methods of `Stream` objects. These objects were mistakenly being constructed without setting an important flag to prevent destruction of the underlying C objects they reference upon their own destruction.

This advisory is being written retrospectively, having previously only been noted in the changelog. No CVE assignment was sought.

### Patches

Users are required to update to version 1.2.1 or newer.

Versions older than 1.2.1 have been yanked from crates.io. This was believed to have already been done at the time of the 1.2.1 release, but upon double checking now they were found to still be available, so has been done now (22nd October 2020).
An issue was discovered in the libpulse-binding crate before 1.2.1 for Rust. get_context can cause a use-after-free.
",nan,"['https://nvd.nist.gov/vuln/detail/CVE-2018-25027', 'https://nvd.nist.gov/vuln/detail/CVE-2018-25028', 'https://github.com/jnqnfe/pulse-binding-rust/security/advisories/GHSA-ghpq-vjxw-ch5w', 'https://crates.io/crates/libpulse-binding', 'https://rustsec.org/advisories/RUSTSEC-2018-0021.html', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/libpulse-binding/RUSTSEC-2018-0021.md', 'https://github.com/jnqnfe/pulse-binding-rust']"
GHSA-xvcg-2q82-r87j,libpulse-binding,https://github.com/jnqnfe/pulse-binding-rust,"['Exception Management', 'Memory Management']",2022-01-07 16:25:11+00:00,2022-01-06T22:18:19Z,"[('0.0.0-0', '2.6.0'), ('0', '2.6.0')]"," Uncaught Exception in libpulse-binding
Fix for UB in failure to catch panics crossing FFI boundaries
Panic mishandled in libpulse-binding
","Affected versions of this crate failed to catch panics crossing FFI boundaries via callbacks, which
is a form of UB. This flaw was corrected by [this commit][1] which was included in version 2.6.0.
Affected versions of this crate failed to catch panics crossing FFI boundaries via callbacks, which
is a form of UB. This flaw was corrected by [this commit][1] which was included in version 2.6.0.

[1]: https://github.com/jnqnfe/pulse-binding-rust/commit/7fd282aef7787577c385aed88cb25d004b85f494
An issue was discovered in the libpulse-binding crate before 2.6.0 for Rust. It mishandles a panic that crosses a Foreign Function Interface (FFI) boundary.
",nan,"['https://crates.io/crates/libpulse-binding', 'https://nvd.nist.gov/vuln/detail/CVE-2019-25055', 'https://rustsec.org/advisories/RUSTSEC-2019-0038.html', 'https://github.com/jnqnfe/pulse-binding-rust', 'https://github.com/jnqnfe/pulse-binding-rust/commit/7fd282aef7787577c385aed88cb25d004b85f494', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/libpulse-binding/RUSTSEC-2019-0038.md']"
GHSA-f6g6-54hm-fhxv,libsbc,https://github.com/mvertescher/libsbc-rs,"['Memory Access', 'Synchronization', 'Memory Management']",2021-08-18 19:58:56+00:00,2021-08-25T20:59:02Z,"[('0.0.0-0', '0.1.5'), ('0', '0.1.5')]","`Decoder<R>` can carry `R: !Send` to other threads
Data races in libsbc
","Affected versions of this crate implements `Send` for `Decoder<R>` for any `R: Read`. This allows `Decoder<R>` to contain `R: !Send` and carry (move) it to another thread.

This can result in undefined behavior such as memory corruption from data race on `R`, or dropping `R = MutexGuard<_>` from a thread that didn't lock the mutex.

The flaw was corrected in commit a34d6e1 by adding trait bound `R: Send` to the `Send` impl for `Decoder<R>`.
Affected versions of this crate implements `Send` for `Decoder<R>` for any `R: Read`. This allows `Decoder<R>` to contain `R: !Send` and carry (move) it to another thread.

This can result in undefined behavior such as memory corruption from data race on `R`, or dropping `R = MutexGuard<_>` from a thread that didn't lock the mutex.

The flaw was corrected in commit a34d6e1 by adding trait bound `R: Send` to the `Send` impl for `Decoder<R>`.
",High,"['https://github.com/mvertescher/libsbc-rs', 'https://github.com/mvertescher/libsbc-rs/issues/4', 'https://crates.io/crates/libsbc', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36440', 'https://github.com/mvertescher/libsbc-rs/commit/a34d6e1', 'https://rustsec.org/advisories/RUSTSEC-2020-0120.html']"
GHSA-g4vj-x7v9-h82m,libsecp256k1,https://github.com/paritytech/libsecp256k1,"['Risky Values', 'Cryptography']",2021-08-18 21:20:32+00:00,2021-08-25T20:56:03Z,"[('0.0.0-0', '0.5.0'), ('0', '0.5.0')]","libsecp256k1 allows overflowing signatures
Overflow in libsecp256k1
","libsecp256k1 accepts signatures whose R or S parameter is larger than the
secp256k1 curve order, which differs from other implementations. This could
lead to invalid signatures being verified.

The error is resolved in 0.5.0 by adding a `check_overflow` flag.
An issue was discovered in the libsecp256k1 crate before 0.5.0 for Rust. It can verify an invalid signature because it allows the R or S parameter to be larger than the curve order, aka an overflow.
",nan,"['https://github.com/paritytech/libsecp256k1/pull/67', 'https://github.com/paritytech/libsecp256k1', 'https://rustsec.org/advisories/RUSTSEC-2021-0076.html', 'https://crates.io/crates/libsecp256k1', 'https://nvd.nist.gov/vuln/detail/CVE-2021-38195']"
GHSA-hrjm-c879-pp86,libsecp256k1,https://github.com/paritytech/libsecp256k1,"['Information Leak', 'Cryptography']",2021-08-19 21:19:40+00:00,2021-08-25T20:46:46Z,"[('0', '0.3.1'), ('0.0.0-0', '0.3.1')]","Flaw in Scalar::check_overflow allows side-channel timing attack
Side-channel timing attack in libsecp256k1
","Versions of `libsecp256k1` prior to `0.3.1` did not execute
Scalar::check_overflow in constant time.

This allows an attacker to potentially leak information via a timing attack.

The flaw was corrected by modifying Scalar::check_overflow to execute in
constant time.
An issue was discovered in the libsecp256k1 crate before 0.3.1 for Rust. Scalar::check_overflow allows a timing side-channel attack; consequently, attackers can obtain sensitive information.
",High,"['https://github.com/paritytech/libsecp256k1', 'https://nvd.nist.gov/vuln/detail/CVE-2019-25003', 'https://crates.io/crates/libsecp256k1', 'https://github.com/paritytech/libsecp256k1/commit/11ba23a9766a5079918cd9f515bc100bc8164b50', 'https://rustsec.org/advisories/RUSTSEC-2019-0027.html']"
GHSA-7cqg-8449-rmfv,libsecp256k1-rs,https://github.com/tari-labs/libsecp256k1-rs/,"['Information Leak', 'Synchronization', 'Cryptography']",2021-07-27 15:21:02+00:00,2021-08-25T21:01:27Z,"[('0', '0.3.1'), ('0.0.0-0', '0.3.1')]","Observable Discrepancy in libsecp256k1-rs
Observable Discrepancy in libsecp256k1-rs
","A timing vulnerability in the Scalar::check_overflow function in Parity libsecp256k1-rs before 0.3.1 potentially allows an attacker to leak information via a side-channel attack.
A timing vulnerability in the Scalar::check_overflow function in Parity libsecp256k1-rs before 0.3.1 potentially allows an attacker to leak information via a side-channel attack.
",Medium,"['https://github.com/paritytech/libsecp256k1/commit/11ba23a9766a5079918cd9f515bc100bc8164b50', 'https://rustsec.org/advisories/RUSTSEC-2020-0156.html', 'https://nvd.nist.gov/vuln/detail/CVE-2019-20399', 'https://crates.io/crates/libsecp256k1-rs']"
RUSTSEC-2016-0004,libusb,https://github.com/dcuddeback/libusb-rs.git,[],2020-10-02 01:29:11+00:00,2016-09-10T12:00:00Z,"[('0.0.0-0', '0.3.1-0')]","libusb is unmaintained; use rusb instead
","The `libusb` crate has not seen a release since September 2016, and its author
is unresponsive.

The `rusb` crate is a maintained fork:

https://github.com/a1ien/rusb
",nan,"['https://crates.io/crates/libusb', 'https://github.com/dcuddeback/libusb-rs/issues/33', 'https://rustsec.org/advisories/RUSTSEC-2016-0004.html']"
RUSTSEC-2019-0021,linea,https://github.com/strake/linea.rs,['Memory Management'],2021-10-19 22:14:35+00:00,2019-09-14T12:00:00Z,"[('0', '0.9.4'), ('0.0.0-0', '0.9.5-0')]","Double free in linea
`Matrix::zip_elements` causes double free
","An issue was discovered in the linea crate through 0.9.4 for Rust. There is double free in the Matrix::zip_elements method.
Affected versions of this crate did not properly implements the `Matrix::zip_elements` method, which causes an double free when the given trait implementation might panic.

This allows an attacker to corrupt or take control of the memory.
 
The flaw was corrected by Phosphorus15.
",Critical,"['https://github.com/strake/linea.rs', 'https://crates.io/crates/linea', 'https://rustsec.org/advisories/RUSTSEC-2019-0021.html', 'https://nvd.nist.gov/vuln/detail/CVE-2019-16880', 'https://github.com/strake/linea.rs/issues/2']"
GHSA-r43h-gmrm-h5c9,linked-hash-map,https://github.com/contain-rs/linked-hash-map,['Memory Access'],2021-08-19 21:21:41+00:00,2021-08-25T20:45:09Z,"[('0.0.0-0', '0.5.3'), ('0', '0.5.3')]","linked-hash-map creates uninitialized NonNull pointer
Access of Uninitialized Pointer in linked-hash-map
","Affected versions of this crate called `mem::uninitialized()` to create a `NonNull<T>`,
which is undefined behavior.
 
The flaw was corrected by avoiding the use of `mem::uninitialized()`.
An issue was discovered in the linked-hash-map crate before 0.5.3 for Rust. It creates an uninitialized NonNull pointer, which violates a non-null constraint.
",Critical,"['https://rustsec.org/advisories/RUSTSEC-2020-0026.html', 'https://github.com/contain-rs/linked-hash-map', 'https://nvd.nist.gov/vuln/detail/CVE-2020-25573', 'https://crates.io/crates/linked-hash-map', 'https://github.com/contain-rs/linked-hash-map/pull/100']"
RUSTSEC-2022-0001,lmdb,https://github.com/danburkert/lmdb-rs.git,[],2022-01-05 16:02:27+00:00,2022-01-05T12:00:00Z,"[('0.0.0-0', None)]","lmdb is unmaintained, use lmdb-rkv instead
","The lmdb crate hasn't had any updates since August 2018.

Mozilla's [lmdb-rkv](https://github.com/mozilla/lmdb-rs) fork of the crate has received additional maintenance work beyond that and is the best available replacement.
",nan,"['https://crates.io/crates/lmdb', 'https://github.com/danburkert/lmdb-rs', 'https://rustsec.org/advisories/RUSTSEC-2022-0001.html']"
GHSA-ppj3-7jw3-8vc4,lock_api,https://github.com/Amanieu/parking_lot,"['Synchronization', 'Memory Management']",2021-08-19 20:53:30+00:00,2021-08-25T20:49:35Z,"[('0.0.0-0', '0.4.2'), ('0', '0.4.2')]","Data races in lock_api
Some lock_api lock guard objects can cause data races
Data races in lock_api
Data races in lock_api
Data races in lock_api
Data races in lock_api
","An issue was discovered in the lock_api crate before 0.4.2 for Rust. A data race can occur because of MappedRwLockReadGuard unsoundness.
Affected versions of lock_api had unsound implementations of the `Send` or
`Sync` traits for some guard objects, namely:

* MappedMutexGuard
* MappedRwLockReadGuard
* MappedRwLockWriteGuard
* RwLockReadGuard
* RwLockWriteGuard

These guards could allow data races through types that are not safe to `Send`
across thread boundaries in safe Rust code.

This issue was fixed by changing the trait bounds on the `Mapped` guard types
and removing the `Sync` trait for the `RwLock` guards.
An issue was discovered in the lock_api crate before 0.4.2 for Rust. A data race can occur because of RwLockWriteGuard unsoundness.
An issue was discovered in the lock_api crate before 0.4.2 for Rust. A data race can occur because of MappedRwLockWriteGuard unsoundness.
An issue was discovered in the lock_api crate before 0.4.2 for Rust. A data race can occur because of RwLockReadGuard unsoundness.
An issue was discovered in the lock_api crate before 0.4.2 for Rust. A data race can occur because of MappedMutexGuard unsoundness.
",Medium,"['https://nvd.nist.gov/vuln/detail/CVE-2020-35913', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35911', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35910', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35914', 'https://github.com/Amanieu/parking_lot', 'https://github.com/Amanieu/parking_lot/pull/262', 'https://rustsec.org/advisories/RUSTSEC-2020-0070.html', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35912', 'https://crates.io/crates/lock_api']"
RUSTSEC-2021-0130,lru,https://github.com/jeromefroe/lru-rs.git,"['Memory Access', 'Memory Management']",2021-12-21 15:50:24+00:00,2021-12-21T12:00:00Z,"[('0.0.0-0', '0.7.1'), ('0', '0.7.1')]","Use After Free in lru
Use after free in lru crate
","An issue was discovered in the lru crate before 0.7.1 for Rust. The iterators have a use-after-free, as demonstrated by an access after a pop operation.
Lru crate has use after free vulnerability.

Lru crate has two functions for getting an iterator. Both iterators give
references to key and value. Calling specific functions, like pop(), will remove
and free the value, and but it's still possible to access the reference of value
which is already dropped causing use after free.
",High,"['https://rustsec.org/advisories/RUSTSEC-2021-0130.html', 'https://nvd.nist.gov/vuln/detail/CVE-2021-45720', 'https://github.com/jeromefroe/lru-rs/issues/120', 'https://crates.io/crates/lru', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/lru/RUSTSEC-2021-0130.md', 'https://github.com/jeromefroe/lru-rs.git']"
GHSA-hf79-8hjp-rrvq,lucet-runtime,https://github.com/fastly/lucet,['Memory Access'],2021-11-30 22:05:58+00:00,2021-11-30T22:20:36Z,"[('0', None)]","Use After Free in lucet
","### Impact
There is a bug in the main branch of Lucet's `lucet-runtime` that allows a use-after-free in an `Instance` object that could result in memory corruption, data race, or other related issues.  This bug was introduced early in the development of Lucet and is present in all releases.  As a result of this bug, and dependent on the memory backing for the `Instance` objects, it is possible to trigger a use-after-free when the `Instance` is dropped.

### Patches
Users should upgrade to the `main` branch of the Lucet repository. Lucet does not provide versioned releases on crates.io.

### Workarounds
There is no way to remediate this vulnerability without upgrading.

### Description
Lucet uses a ""pool"" allocator for new WebAssembly instances that are created. This pool allocator manages everything from the linear memory of the wasm instance, the runtime stack for async switching, as well as the memory behind the Instance itself. `Instances` are referred to via an `InstanceHandle` type which will, on drop, release the memory backing the Instance back to the pool.

When an Instance is dropped, the fields of the `Instance` are destructed top-to-bottom, however when the `alloc: Alloc` field is destructed, the memory backing the `Instance` is released back to the pool before the destructors of the remaining fields are run. If another thread allocates the same memory from the pool while these destructors are still running, a race condition occurs that can lead to use-after-free errors.

The bug was corrected by changing how the `InstanceHandle` destructor operates to ensure that the memory backing an Instance is only returned to the pool once the `Instance` has been completely destroyed.

This security advisory has been assigned CVE-2021-43790.

### For more information
If you have any questions or comments about this advisory:
* Open an issue in [lucet repository](https://github.com/bytecodealliance/lucet)
* Email [the lucet team](mailto:lucet@fastly.com)
* See the [Bytecode Alliance security policy](https://bytecodealliance.org/security)

",High,"['https://crates.io/crates/lucet-runtime', 'https://github.com/bytecodealliance/lucet/security/advisories/GHSA-hf79-8hjp-rrvq', 'https://github.com/bytecodealliance/lucet', 'https://nvd.nist.gov/vuln/detail/CVE-2021-43790', 'https://github.com/bytecodealliance/lucet/commit/7c7757c772fb709c61b1442bcc1e1fbee97bf4a8']"
RUSTSEC-2020-0004,lucet-runtime-internals,https://github.com/fastly/lucet,"['Memory Access', 'Memory Management']",2021-10-19 22:14:35+00:00,2020-01-24T12:00:00Z,"[('0.5.0', '0.5.1'), ('0.0.0-0', '0.4.3'), ('0', '0.4.3')]","Out of bounds access in lucet-runtime-internals
sigstack allocation bug can cause memory corruption or leak
","An issue was discovered in the lucet-runtime-internals crate before 0.5.1 for Rust. It mishandles sigstack allocation. Guest programs may be able to obtain sensitive information, or guest programs can experience memory corruption.
An embedding using affected versions of lucet-runtime configured to use
non-default Wasm globals sizes of more than 4KiB, or compiled in debug mode
without optimizations, could leak data from the signal handler stack to guest
programs. This can potentially cause data from the embedding host to leak to
guest programs or cause corruption of guest program memory.

This flaw was resolved by correcting the sigstack allocation logic.
",Critical,"['https://github.com/fastly/lucet', 'https://rustsec.org/advisories/RUSTSEC-2020-0004.html', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35859', 'https://github.com/bytecodealliance/lucet/pull/401', 'https://crates.io/crates/lucet-runtime-internals']"
RUSTSEC-2017-0007,lz4-compress,https://github.com/ticki/tfs,[],2020-10-02 01:29:11+00:00,2017-04-17T12:00:00Z,"[('0.0.0-0', None)]","lz4-compress is unmaintained
","[According to the developers](https://gitlab.redox-os.org/redox-os/tfs/issues/89) this crate is no longer maintained.

The suggested alternative is [`lz4-compression`](https://crates.io/crates/lz4-compression), a maintained fork of `lz4-compress`.

See also [lz-fear](https://crates.io/crates/lz-fear) which is compatible with the reference LZ4 implementation in C, but not with lz4-compress.
",nan,"['https://rustsec.org/advisories/RUSTSEC-2017-0007.html', 'https://gitlab.redox-os.org/redox-os/tfs/issues/89', 'https://crates.io/crates/lz4-compress']"
RUSTSEC-2020-0144,lzw,https://github.com/nwin/lzw.git,[],2021-02-10 18:27:15+00:00,2020-02-10T12:00:00Z,"[('0.0.0-0', '0.10.1-0')]","lzw is unmaintained
","The author of the `lzw` crate is unresponsive.

Maintained alternatives:

- [`weezl`](https://crates.io/crates/weezl)
",nan,"['https://github.com/nwin/lzw/issues/2', 'https://rustsec.org/advisories/RUSTSEC-2020-0144.html', 'https://crates.io/crates/lzw']"
GHSA-wv4p-jp67-jr97,magnetic,https://github.com/johnshaw/magnetic,['Synchronization'],2021-08-19 18:56:53+00:00,2021-08-25T20:50:05Z,"[('0.0.0-0', '2.0.1'), ('0', '2.0.1')]","MPMCConsumer/Producer allows sending non-Send type across threads
Data races in magnetic
","Affected versions of this crate unconditionally implemented `Sync` and `Send` traits for `MPMCConsumer` and `MPMCProducer` types.

This allows users to send types that do not implement `Send` trait across thread boundaries, which can cause a data race.

The flaw was corrected in the 2.0.1 release by adding `T: Send` bound to affected Sync/Send trait implementations.
An issue was discovered in the magnetic crate before 2.0.1 for Rust. MPMCConsumer and MPMCProducer allow cross-thread sending of a non-Send type.
",Medium,"['https://nvd.nist.gov/vuln/detail/CVE-2020-35925', 'https://github.com/johnshaw/magnetic', 'https://crates.io/crates/magnetic', 'https://rustsec.org/advisories/RUSTSEC-2020-0088.html', 'https://github.com/johnshaw/magnetic/issues/9']"
RUSTSEC-2021-0014,marc,https://github.com/blackbeam/rust-marc,"['Memory Access', 'Exception Management']",2021-10-19 22:14:35+00:00,2021-01-26T12:00:00Z,"[('0', '2.0.0'), ('0.0.0-0', '2.0.0')]","Uninitialized buffer use in marc
Record::read : Custom `Read` on uninitialized buffer may cause UB
","An issue was discovered in the marc crate before 2.0.0 for Rust. A user-provided Read implementation can gain access to the old contents of newly allocated memory, violating soundness.
Affected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation. (`Record::read()`)

Arbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.
Reading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.

This flaw was fixed in commit 6299af0 by zero-initializing the newly allocated memory (via `data.resize(len, 0)`) instead of exposing uninitialized memory (`unsafe { data.set_len(len) }`).
",High,"['https://github.com/blackbeam/rust-marc', 'https://crates.io/crates/marc', 'https://nvd.nist.gov/vuln/detail/CVE-2021-26308', 'https://github.com/blackbeam/rust-marc/issues/7', 'https://rustsec.org/advisories/RUSTSEC-2021-0014.html']"
GHSA-rmff-f8w9-c9rm,max7301,https://github.com/edarc/max7301,"['Synchronization', 'Memory Management']",2021-08-18 19:14:45+00:00,2021-08-25T20:59:22Z,"[('0', '0.2.0'), ('0.0.0-0', '0.2.0')]","ImmediateIO and TransactionalIO can cause data races
Data races in max7301
","The `ImmediateIO` and `TransactionalIO` types implement `Sync` for all contained
`Expander<EI>` types regardless of if the `Expander` itself is safe to use
across threads.

As the `IO` types allow retrieving the `Expander`, this can lead to non-thread
safe types being sent across threads as part of the `Expander` leading to data
races.
The `ImmediateIO` and `TransactionalIO` types implement `Sync` for all contained
`Expander<EI>` types regardless of if the `Expander` itself is safe to use
across threads.

As the `IO` types allow retrieving the `Expander`, this can lead to non-thread
safe types being sent across threads as part of the `Expander` leading to data
races.

",Medium,"['https://github.com/edarc/max7301', 'https://github.com/edarc/max7301/issues/1', 'https://crates.io/crates/max7301', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36472', 'https://rustsec.org/advisories/RUSTSEC-2020-0152.html', 'https://github.com/edarc/max7301/commit/0a1da873ddb29bca926bad8301f8d7ab8aa97c52']"
RUSTSEC-2020-0111,may_queue,https://github.com/Xudong-Huang/may.git,"['Memory Access', 'Synchronization', 'Memory Management']",2021-10-19 22:14:35+00:00,2020-11-10T12:00:00Z,"[('0.0.0-0', None), ('0', None)]","Data race in may_queue
may_queue's Queue lacks Send/Sync bound for its Send/Sync trait.
","An issue was discovered in the may_queue crate through 2020-11-10 for Rust. Because Queue does not have bounds on its Send trait or Sync trait, memory corruption can occur.
Affected versions of `may_queue` implements `Send`/`Sync` for its `Queue` type without restricting it to `Send`able types and `Sync`able types.

This allows non-`Sync` types such as `Cell` to be shared across threads leading to undefined behavior and memory corruption in concurrent programs.
",Medium,"['https://nvd.nist.gov/vuln/detail/CVE-2020-36217', 'https://github.com/Xudong-Huang/may/issues/88', 'https://rustsec.org/advisories/RUSTSEC-2020-0111.html', 'https://crates.io/crates/may_queue', 'https://github.com/Xudong-Huang/may']"
RUSTSEC-2021-0001,mdbook,https://github.com/rust-lang/mdBook,['Other'],2021-10-19 22:14:35+00:00,2021-01-04T12:00:00Z,"[('0.1.4-0', '0.4.5')]","XSS in mdBook's search page
","> This is a cross-post of [the official security advisory][ml]. The official post
> contains a signed version with our PGP key, as well.

[ml]: https://groups.google.com/g/rustlang-security-announcements/c/3-sO6of29O0

The Rust Security Response Working Group was recently notified of a security
issue affecting the search feature of mdBook, which could allow an attacker to
execute arbitrary JavaScript code on the page.

The CVE for this vulnerability is [CVE-2020-26297][1].

## Overview

The search feature of mdBook (introduced in version 0.1.4) was affected by a
cross site scripting vulnerability that allowed an attacker to execute
arbitrary JavaScript code on an user's browser by tricking the user into typing
a malicious search query, or tricking the user into clicking a link to the
search page with the malicious search query prefilled.

mdBook 0.4.5 fixes the vulnerability by properly escaping the search query.

## Mitigations

Owners of websites built with mdBook have to upgrade to mdBook 0.4.5 or greater
and rebuild their website contents with it. It's possible to install mdBook
0.4.5 on the local system with:

```
cargo install mdbook --version 0.4.5 --force
```

## Acknowledgements

Thanks to Kamil Vavra for responsibly disclosing the vulnerability to us
according to [our security policy][2].

## Timeline of events

All times are listed in UTC.

* 2020-12-30 20:14 - The issue is reported to the Rust Security Response WG
* 2020-12-30 20:32 - The issue is acknowledged and the investigation began
* 2020-12-30 21:21 - Found the cause of the vulnerability and prepared the patch
* 2021-01-04 15:00 - Patched version released and vulnerability disclosed

[1]: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-26297
[2]: https://www.rust-lang.org/policies/security
",Medium,"['https://groups.google.com/g/rustlang-security-announcements/c/3-sO6of29O0', 'https://rustsec.org/advisories/RUSTSEC-2021-0001.html', 'https://crates.io/crates/mdbook']"
RUSTSEC-2020-0077,memmap,https://github.com/danburkert/memmap-rs,[],2020-12-02 19:15:42+00:00,2020-12-02T12:00:00Z,"[('0.0.0-0', '0.7.1-0')]","memmap is unmaintained
","The author of the `memmap` crate is unresponsive.

Maintained alternatives:

- [`mapr`](https://github.com/filecoin-project/mapr)
- [`memmap2`](https://github.com/RazrFalcon/memmap2-rs)
",nan,"['https://crates.io/crates/memmap', 'https://rustsec.org/advisories/RUSTSEC-2020-0077.html', 'https://github.com/danburkert/memmap-rs/issues/90']"
GHSA-rh89-x75f-rh3c,memoffset,https://github.com/Gilnaa/memoffset,['Exception Management'],2021-08-19 21:23:41+00:00,2021-08-25T20:44:00Z,"[('0.0.0-0', '0.5.0'), ('0', '0.5.0')]","Flaw in offset_of and span_of causes SIGILL, drops uninitialized memory of arbitrary type on panic in client code
Exposure of uninitialized memory in memoffset
","Affected versions of this crate caused traps and/or memory unsafety by zero-initializing references.
They also could lead to uninitialized memory being dropped if the field for which the offset is requested was behind a deref coercion, and that deref coercion caused a panic.

The flaw was corrected by using `MaybeUninit`.
An issue was discovered in the memoffset crate before 0.5.0 for Rust. offset_of and span_of can cause exposure of uninitialized memory.
",High,"['https://nvd.nist.gov/vuln/detail/CVE-2019-15553', 'https://crates.io/crates/memoffset', 'https://rustsec.org/advisories/RUSTSEC-2019-0011.html', 'https://github.com/Gilnaa/memoffset/issues/9#issuecomment-505461490', 'https://github.com/Gilnaa/memoffset']"
GHSA-hr52-f9vp-582c,messagepack-rs,https://github.com/otake84/messagepack-rs,"['Memory Access', 'Exception Management']",2022-01-07 16:30:51+00:00,2022-01-06T22:12:28Z,"[('0.0.0-0', None), ('0', None)]","Use of Uninitialized Resource in messagepack-rs
Deserialization functions pass uninitialized memory to user-provided Read
Use of Uninitialized Resource in messagepack-rs.
Use of Uninitialized Resource in messagepack-rs.
Use of Uninitialized Resource in messagepack-rs.
","An issue was discovered in the messagepack-rs crate through 2021-01-26 for Rust. deserialize_string may read from uninitialized memory locations.
Affected versions of this crate passed an uninitialized buffer to a
user-provided `Read` instance in:

* `deserialize_binary`
* `deserialize_string`
* `deserialize_extension_others`
* `deserialize_string_primitive`

This can result in safe `Read` implementations reading from the uninitialized
buffer leading to undefined behavior.
An issue was discovered in the messagepack-rs crate through 2021-01-26 for Rust. deserialize_binary may read from uninitialized memory locations.
An issue was discovered in the messagepack-rs crate through 2021-01-26 for Rust. deserialize_string_primitive may read from uninitialized memory locations.
An issue was discovered in the messagepack-rs crate through 2021-01-26 for Rust. deserialize_extension_others may read from uninitialized memory locations.
",Critical,"['https://crates.io/crates/messagepack-rs', 'https://github.com/otake84/messagepack-rs', 'https://github.com/otake84/messagepack-rs/issues/2', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/messagepack-rs/RUSTSEC-2021-0092.md', 'https://nvd.nist.gov/vuln/detail/CVE-2021-45690', 'https://nvd.nist.gov/vuln/detail/CVE-2021-45692', 'https://rustsec.org/advisories/RUSTSEC-2021-0092.html', 'https://nvd.nist.gov/vuln/detail/CVE-2021-45691', 'https://nvd.nist.gov/vuln/detail/CVE-2021-45693']"
GHSA-cwvc-87xq-pc5m,metrics-util,https://github.com/metrics-rs/metrics,"['Memory Access', 'Synchronization', 'Memory Management']",2022-01-07 17:39:55+00:00,2022-01-06T22:08:43Z,"[('0.0.0-0', '0.7.0'), ('0', '0.7.0')]","AtomicBucket<T> unconditionally implements Send/Sync
Out-of-bounds Write and Race Condition in metrics-util
","In the affected versions of the crate, `AtomicBucket<T>` unconditionally implements `Send`/`Sync` traits. Therefore, users can create a data race to the inner
`T: !Sync` by using the `AtomicBucket::data_with()` API.
Such data races can potentially cause memory corruption or other undefined behavior.

The flaw was fixed in commit 8e6daab by adding appropriate Send/Sync bounds to the Send/Sync impl of struct `Block<T>` (which is a data type contained inside `AtomicBucket<T>`).
An issue was discovered in the metrics-util crate before 0.7.0 for Rust. There is a data race and memory corruption because AtomicBucket<T> unconditionally implements the Send and Sync traits.
",nan,"['https://nvd.nist.gov/vuln/detail/CVE-2021-45704', 'https://crates.io/crates/metrics-util', 'https://rustsec.org/advisories/RUSTSEC-2021-0113.html', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/metrics-util/RUSTSEC-2021-0113.md', 'https://github.com/metrics-rs/metrics/issues/190', 'https://github.com/metrics-rs/metrics']"
RUSTSEC-2020-0081,mio,https://github.com/tokio-rs/mio,['Other'],2021-10-19 22:14:35+00:00,2020-11-02T12:00:00Z,"[('0.7.0', '0.7.6')]","mio invalidly assumes the memory layout of std::net::SocketAddr
`mio` invalidly assumes the memory layout of std::net::SocketAddr
","An issue was discovered in the mio crate before 0.7.6 for Rust. It has false expectations about the std::net::SocketAddr memory representation.
The [`mio`](https://crates.io/crates/mio) crate has assumed `std::net::SocketAddrV4`
and `std::net::SocketAddrV6` have the same memory layout as the system C representation
`sockaddr`. It has simply casted the pointers to convert the socket addresses to the
system representation. The standard library does not say anything about the memory
layout, and this will cause invalid memory access if the standard library
changes the implementation. No warnings or errors will be emitted once the
change happens.
",Medium,"['https://nvd.nist.gov/vuln/detail/CVE-2020-35922', 'https://crates.io/crates/mio', 'https://github.com/tokio-rs/mio/issues/1386', 'https://github.com/tokio-rs/mio', 'https://rustsec.org/advisories/RUSTSEC-2020-0081.html']"
RUSTSEC-2020-0080,miow,https://github.com/yoshuawuyts/miow,['Other'],2021-10-19 22:14:35+00:00,2020-11-13T12:00:00Z,"[('0.0.0-0', '0.2.2'), ('0', '0.3.6')]","miow invalidly assumes the memory layout of std::net::SocketAddr
`miow` invalidly assumes the memory layout of std::net::SocketAddr
","An issue was discovered in the miow crate before 0.3.6 for Rust. It has false expectations about the std::net::SocketAddr memory representation.
The [`miow`](https://crates.io/crates/miow) crate has assumed `std::net::SocketAddrV4`
and `std::net::SocketAddrV6` have the same memory layout as the system C representation
`sockaddr`. It has simply casted the pointers to convert the socket addresses to the
system representation. The standard library does not say anything about the memory
layout, and this will cause invalid memory access if the standard library
changes the implementation. No warnings or errors will be emitted once the
change happens.
",Medium,"['https://github.com/yoshuawuyts/miow', 'https://rustsec.org/advisories/RUSTSEC-2020-0080.html', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35921', 'https://crates.io/crates/miow', 'https://github.com/yoshuawuyts/miow/issues/38', 'https://github.com/yoshuawuyts/miow/pull/39']"
RUSTSEC-2021-0062,miscreant,https://github.com/miscreant/miscreant.rs,[],2021-05-03 19:05:09+00:00,2021-02-28T12:00:00Z,"[('0.0.0-0', None)]","project abandoned; migrate to the `aes-siv` crate
","The Miscreant project has been abandoned and archived.

The Rust implementation has been adapted into the new `aes-siv` crate which
implements both the AES-CMAC-SIV and AES-PMAC-SIV constructions:

<https://github.com/RustCrypto/AEADs/tree/master/aes-siv>

Please migrate to the `aes-siv` crate.

Alternatively see the `aes-gcm-siv` crate for a newer, faster construction
which provides similar properties:

<https://github.com/RustCrypto/AEADs/tree/master/aes-gcm-siv>
",nan,"['https://rustsec.org/advisories/RUSTSEC-2021-0062.html', 'https://github.com/miscreant/miscreant.rs/commit/5d921f579e0c2b9960d472cf377b8487d97fbcec', 'https://crates.io/crates/miscreant']"
GHSA-mxv6-q98x-h958,model,https://github.com/spacejam/model,"['Risky Values', 'Synchronization']",2021-08-24 18:00:46+00:00,2021-08-25T20:56:07Z,"[('0.0.0-0', None), ('0', None)]","`Shared` can cause a data race
Data races in model
","`Shared` data structure in `model` crate implements `Send` and `Sync` traits regardless of the inner type.
This allows safe Rust code to trigger a data race, which is undefined behavior in Rust.

Users are advised to treat `Shared` as an unsafe type.
It should not be used outside of the testing context,
and care must be taken so that the testing code does not have a data race
besides a race condition that is expected to be caught by the test.

Check [the Rustonomicon](https://doc.rust-lang.org/nomicon/races.html) for the difference between
a data race and a general race condition.
`Shared` data structure in `model` crate implements `Send` and `Sync` traits regardless of the inner type.
This allows safe Rust code to trigger a data race, which is undefined behavior in Rust.

Users are advised to treat `Shared` as an unsafe type.
It should not be used outside of the testing context,
and care must be taken so that the testing code does not have a data race
besides a race condition that is expected to be caught by the test.

",High,"['https://nvd.nist.gov/vuln/detail/CVE-2020-36460', 'https://crates.io/crates/model', 'https://github.com/spacejam/model', 'https://rustsec.org/advisories/RUSTSEC-2020-0140.html', 'https://github.com/spacejam/model/issues/3']"
GHSA-6p3c-v8vc-c244,molecule,https://github.com/nervosnetwork/molecule,[],2022-01-07 17:57:26+00:00,2022-01-06T22:10:34Z,"[('0', '0.7.2'), ('0.0.0-0', '0.7.2')]"," Partial read is incorrect in molecule
The `total_size` function for partial read the length of any `FixVec` is incorrect in molecule.
","Anyone who uses total_size(..) function to partial read the length of any FixVec will get an incorrect result, due to an incorrect implementation. This has been resolved in the 0.7.2 release.
An issue was discovered in the molecule crate before 0.7.2 for Rust. A FixVec partial read has an incorrect result.
",nan,"['https://nvd.nist.gov/vuln/detail/CVE-2021-45697', 'https://crates.io/crates/molecule', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/molecule/RUSTSEC-2021-0103.md', 'https://github.com/nervosnetwork/molecule', 'https://rustsec.org/advisories/RUSTSEC-2021-0103.html', 'https://github.com/nervosnetwork/molecule/pull/49', 'https://github.com/nervosnetwork/molecule/security/advisories/GHSA-82hm-vh7g-hrh9']"
GHSA-82hm-vh7g-hrh9,molecule,https://github.com/nervosnetwork/molecule,[],2021-09-09 17:55:10+00:00,2021-08-25T21:01:25Z,"[('0', '0.7.2')]","Partial read is incorrect in molecule
","### Impact

Anyone who uses `total_size(..)` function to partial read the length of any `FixVec` will get an incorrect result, due to an incorrect implementation. This has been resolved in the 0.7.2 release.

### Workarounds

If you already have the whole `FixVec` `A`, you can use `A.as_slice().len()` to get the total size of the `FixVec`.

### For more information

If you have any questions or comments about this advisory:

- [Open an issue to ask use directly](https://github.com/nervosnetwork/molecule/issues/new).
",nan,"['https://github.com/nervosnetwork/molecule/pull/49', 'https://github.com/nervosnetwork/molecule/security/advisories/GHSA-82hm-vh7g-hrh9', 'https://github.com/nervosnetwork/molecule']"
GHSA-2gxj-qrp2-53jv,mopa,https://github.com/chris-morgan/mopa,"['Memory Access', 'Other', 'Memory Management']",2022-01-07 18:24:36+00:00,2022-01-06T22:11:11Z,"[('0.0.0-0', None), ('0', None)]","`mopa` is technically unsound
Incorrect reliance on Trait memory layout in mopa
","The `mopa` crate redefines the deprecated `TraitObject` struct from `core::raw` like so:
```rust
#[repr(C)]
#[derive(Copy, Clone)]
#[doc(hidden)]
pub struct TraitObject {
    pub data: *mut (),
    pub vtable: *mut (),
}
```
This is done to then transmute a reference to a trait object (`&dyn Trait` for any trait `Trait`) into this struct and retrieve the `data` field for the purpose of downcasting. This is used to implement `downcast_ref_unchecked()`, in terms of which `downcast_ref()` is also implemented. Same goes for mutable reference downcasting and `Box` downcasting.

The Rust compiler explicitly reserves the right to change the memory layout of `&dyn Trait` for any trait `Trait`. The worst case scenario is that it swaps `data` and `vtable`, making an executable location breach and compromisation of ASLR possible, since reads from `data` would read `vtable` instead. Likewise, arbitrary code execution is also theoretically possible if reads of `vtable` generated by the compiler read `data` instead.

While, as of Rust 1.52, this unsound assumption still holds true, updating the compiler may silently create UB in a crate which previously compiled and run without issues, compromising the security of builds which are believed to be reproducible.

A potential strategy to resolve this has already been suggested in an issue on the GitHub repository of the crate.
An issue was discovered in the mopa crate through 2021-06-01 for Rust. It incorrectly relies on Trait memory layout, possibly leading to future occurrences of arbitrary code execution or ASLR bypass.
",nan,"['https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/mopa/RUSTSEC-2021-0095.md', 'https://github.com/chris-morgan/mopa/issues/13', 'https://nvd.nist.gov/vuln/detail/CVE-2021-45695', 'https://github.com/chris-morgan/mopa', 'https://rustsec.org/advisories/RUSTSEC-2021-0095.html', 'https://crates.io/crates/mopa']"
GHSA-4vhw-4rw7-jfpv,mozwire,https://github.com/NilsIrl/MozWire/,['Path Resolution'],2021-08-19 20:56:07+00:00,2021-08-25T20:49:02Z,"[('0', '0.5.0'), ('0.0.0-0', '0.4.2-0')]","Missing sanitazion in mozwire allows local file overwrite of files ending in .conf
Path traversal in mozwire
","The client software downloaded a list of servers from mozilla's servers and created local files named
after the hostname field in the json document.

No verification of the content of the string was made, and it could therefore have included '../' leading to path traversal.

This allows an attacker in control of mozilla's servers to overwrite/create local files named .conf.

The flaw was corrected by sanitizing the hostname field.
An issue was discovered in the mozwire crate through 2020-08-18 for Rust. A ../ directory-traversal situation allows overwriting local files that have .conf at the end of the filename.
",Critical,"['https://rustsec.org/advisories/RUSTSEC-2020-0030.html', 'https://crates.io/crates/mozwire', 'https://github.com/NilsIrl/MozWire/issues/14', 'https://github.com/NilsIrl/MozWire/', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35883']"
RUSTSEC-2021-0016,ms3d,https://github.com/andrewhickman/ms3d,"['Memory Access', 'Exception Management']",2021-10-19 22:14:35+00:00,2021-01-26T12:00:00Z,"[('0.0.0-0', '0.1.3'), ('0', '0.1.3')]","Use of Uninitialized Resource in ms3d
`IoReader::read()`: user-provided `Read` on uninitialized buffer may cause UB
","An issue was discovered in the ms3d crate before 0.1.3 for Rust. It might allow attackers to obtain sensitive information from uninitialized memory locations via IoReader::read.
Affected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation.

Arbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.
Reading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.

The flaw was fixed in commit 599313b by zero-initializing the buffer (via `self.buf.resize(len, 0)`) before passing it to `Read`.
",High,"['https://crates.io/crates/ms3d', 'https://github.com/andrewhickman/ms3d/issues/1', 'https://rustsec.org/advisories/RUSTSEC-2021-0016.html', 'https://github.com/andrewhickman/ms3d', 'https://nvd.nist.gov/vuln/detail/CVE-2021-26952']"
GHSA-h7qh-3h6f-w79p,multihash,https://github.com/multiformats/rust-multihash,"['Resource Management', 'Tainted Input']",2021-08-19 20:51:29+00:00,2021-08-25T20:49:41Z,"[('0', '0.11.3'), ('0.0.0-0', '0.11.3')]","Unexpected panic in multihash `from_slice` parsing code
Unexpected panic in multihash
","In versions prior 0.11.3 it's possible to make `from_slice` panic by feeding it certain malformed input.
It's never documented that `from_slice` (and `from_bytes` which wraps it) can panic, and its' return type (`Result<Self, DecodeError>`) suggests otherwise.

In practice, `from_slice`/`from_bytes` is frequently used in networking code (for example [in rust-libp2p](https://github.com/libp2p/rust-libp2p/blob/7b415d5e7040e45c541f76f2c409e63d4d3249c6/core/src/peer_id.rs#L89)) and is being called with unsanitized data from untrusted sources.
This can allow attackers to cause DoS by causing an unexpected `panic` in the network client's code.
An issue was discovered in the multihash crate before 0.11.3 for Rust. The from_slice parsing code can panic via unsanitized data from a network server.
",High,"['https://crates.io/crates/multihash', 'https://github.com/multiformats/rust-multihash', 'https://github.com/multiformats/rust-multihash/pull/72', 'https://rustsec.org/advisories/RUSTSEC-2020-0068.html', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35909']"
GHSA-jf43-3v8j-qwwr,multiqueue,https://github.com/schets/multiqueue,"['Synchronization', 'Memory Management', 'Tainted Input']",2021-08-09 17:20:06+00:00,2021-08-25T20:59:56Z,"[('0.0.0-0', None), ('0', None)]","Queues allow non-Send types to be sent to other threads, allowing data races
Data races in multiqueue
Data races in multiqueue
","Affected versions of this crate unconditionally implemented `Send` for types used in queue implementations (`InnerSend<RW, T>`, `InnerRecv<RW, T>`, `FutInnerSend<RW, T>`, `FutInnerRecv<RW, T>`).

This allows users to send non-Send types to other threads, which can lead to data race bugs or other undefined behavior.
An issue was discovered in the multiqueue crate through 2020-12-25 for Rust. There are unconditional implementations of Send for InnerSend<RW, T>, InnerRecv<RW, T>, FutInnerSend<RW, T>, and FutInnerRecv<RW, T>.
Affected versions of multiqueue unconditionally implemented `Send` for types used in queue implementations (`InnerSend<RW, T>`, `InnerRecv<RW, T>`, `FutInnerSend<RW, T>`, `FutInnerRecv<RW, T>`).

This allows users to send non-Send types to other threads, which can lead to data race bugs or other undefined behavior.

",High,"['https://github.com/schets/multiqueue', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/multiqueue/RUSTSEC-2020-0143.md', 'https://crates.io/crates/multiqueue', 'https://rustsec.org/advisories/RUSTSEC-2020-0143.html', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36463', 'https://github.com/schets/multiqueue/issues/31']"
RUSTSEC-2020-0106,multiqueue2,https://github.com/abbychau/multiqueue2,"['Synchronization', 'Memory Management']",2021-10-19 22:14:35+00:00,2020-12-19T12:00:00Z,"[('0.0.0-0', '0.1.7'), ('0', '0.1.7')]","Data races in multiqueue2
Queues allow non-Send types to be sent to other threads, allowing data races
","An issue was discovered in the multiqueue2 crate before 0.1.7 for Rust. Because a non-Send type can be sent to a different thread, a data race can occur.
Affected versions of this crate unconditionally implemented `Send` for types used in queue implementations (`InnerSend<RW, T>`, `InnerRecv<RW, T>`, `FutInnerSend<RW, T>`, `FutInnerRecv<RW, T>`).

This allows users to send non-Send types to other threads, which can lead to data race bugs or other undefined behavior.

The flaw was corrected in v0.1.7 by adding `T: Send` bound to to the `Send` impl of four data types explained above.
",Medium,"['https://github.com/abbychau/multiqueue2/issues/10', 'https://crates.io/crates/multiqueue2', 'https://github.com/abbychau/multiqueue2', 'https://rustsec.org/advisories/RUSTSEC-2020-0106.html', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36214']"
GHSA-3w8g-xr3f-2mp8,nalgebra,https://github.com/dimforge/nalgebra,"['Memory Access', 'Memory Management']",2021-08-24 18:08:59+00:00,2021-08-25T20:55:49Z,"[('0.11.0', '0.27.1')]","VecStorage Deserialize Allows Violation of Length Invariant
Out of bounds write in nalgebra
","The `Deserialize` implementation for `VecStorage` did not maintain the invariant that the number of elements must equal `nrows * ncols`. Deserialization of specially crafted inputs could allow memory access beyond allocation of the vector.

This flaw was introduced in v0.11.0 ([`086e6e`](https://github.com/dimforge/nalgebra/commit/086e6e719f53fecba6dadad2e953a487976387f5)) due to the addition of an automatically derived implementation of `Deserialize` for `MatrixVec`. `MatrixVec` was later renamed to `VecStorage` in v0.16.13 ([`0f66403`](https://github.com/dimforge/nalgebra/commit/0f66403cbbe9eeac15cedd8a906c0d6a3d8841f2)) and continued to use the automatically derived implementation of `Deserialize`.

This flaw was corrected in commit [`5bff536`](https://github.com/dimforge/nalgebra/commit/5bff5368bf38ddfa31416e4ae9897b163031a513) by returning an error during deserialization if the number of elements does not exactly match the expected size.
The `Deserialize` implementation for `VecStorage` did not maintain the invariant that the number of elements must equal `nrows * ncols`. Deserialization of specially crafted inputs could allow memory access beyond allocation of the vector.

This flaw was introduced in v0.11.0 ([`086e6e`](https://github.com/dimforge/nalgebra/commit/086e6e719f53fecba6dadad2e953a487976387f5)) due to the addition of an automatically derived implementation of `Deserialize` for `MatrixVec`. `MatrixVec` was later renamed to `VecStorage` in v0.16.13 ([`0f66403`](https://github.com/dimforge/nalgebra/commit/0f66403cbbe9eeac15cedd8a906c0d6a3d8841f2)) and continued to use the automatically derived implementation of `Deserialize`.
",nan,"['https://rustsec.org/advisories/RUSTSEC-2021-0070.html', 'https://nvd.nist.gov/vuln/detail/CVE-2021-38190', 'https://github.com/dimforge/nalgebra/issues/883', 'https://github.com/dimforge/nalgebra/pull/889', 'https://github.com/dimforge/nalgebra/commit/a803271fcce75b7c151e92aa099dfa546db4adc5', 'https://crates.io/crates/nalgebra', 'https://github.com/dimforge/nalgebra/blob/dev/CHANGELOG.md#0270', 'https://github.com/dimforge/nalgebra']"
GHSA-wp34-mqw5-jj85,nano_arena,https://github.com/bennetthardwick/nano-arena,"['Memory Access', 'Memory Management']",2021-08-19 17:23:52+00:00,2021-08-25T20:52:00Z,"[('0.0.0-0', '0.5.2'), ('0', '0.5.2')]","split_at allows obtaining multiple mutable references to the same data
Use after free in nano_arena
","Affected versions of this crate assumed that `Borrow<Idx>` was guaranteed to
return the same value on `.borrow()`. The borrowed index value was used to
retrieve a mutable reference to a value.

If the `Borrow<Idx>` implementation returned a different index, the split arena
would allow retrieving the index as a mutable reference creating two mutable
references to the same element. This violates Rust's aliasing rules and allows
for memory safety issues such as writing out of bounds and use-after-frees.

The flaw was corrected in commit `6b83f9d` by storing the `.borrow()` value in
a temporary variable.
An issue was discovered in the nano_arena crate before 0.5.2 for Rust. There is an aliasing violation in split_at because two mutable references can exist for the same element, if Borrow<Idx> behaves in certain ways. This can have a resultant out-of-bounds write or use-after-free.
",Critical,"['https://github.com/bennetthardwick/nano-arena', 'https://nvd.nist.gov/vuln/detail/CVE-2021-28032', 'https://github.com/bennetthardwick/nano-arena/issues/1', 'https://crates.io/crates/nano_arena', 'https://rustsec.org/advisories/RUSTSEC-2021-0031.html']"
GHSA-r57r-j98g-587f,nanorand,https://github.com/Absolucy/nanorand-rs,[],2022-01-07 18:29:44+00:00,2022-01-06T22:08:56Z,"[('0', '0.6.1'), ('0.5.0', '0.6.1')]","Aliased mutable references from `tls_rand` & `TlsWyRand`
Pointer dereference in nanorand
","`TlsWyRand`'s implementation of `Deref` unconditionally dereferences a raw pointer, and returns 
multiple mutable references to the same object, which is undefined behavior.
An issue was discovered in the nanorand crate before 0.6.1 for Rust. There can be multiple mutable references to the same object because the TlsWyRand Deref implementation dereferences a raw pointer.
",nan,"['https://github.com/Absolucy/nanorand-rs', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/nanorand/RUSTSEC-2021-0114.md', 'https://crates.io/crates/nanorand', 'https://nvd.nist.gov/vuln/detail/CVE-2021-45705', 'https://github.com/Absolucy/nanorand-rs/issues/28', 'https://rustsec.org/advisories/RUSTSEC-2021-0114.html']"
GHSA-m9m5-cg5h-r582,nanorand,https://github.com/Absolucy/nanorand-rs,"['Cryptography', 'Predictability']",2021-08-19 18:55:41+00:00,2021-08-25T20:50:24Z,"[('0.0.0-0', '0.5.1'), ('0', '0.5.1')]","nanorand 0.5.0 - RNGs failed to generate properly for non-64-bit numbers
Improper random number generation in nanorand
","In versions of `nanorand` prior to 0.5.1, `RandomGen` implementations for standard unsigned integers could
fail to properly generate numbers, due to using bit-shifting to truncate a 64-bit number, rather than just
an `as` conversion.

This often manifested as RNGs returning nothing but 0, including the cryptographically secure `ChaCha` random
number generator..
An issue was discovered in the nanorand crate before 0.5.1 for Rust. It caused any random number generator (even ChaCha) to return all zeroes because integer truncation was mishandled.
",Medium,"['https://github.com/Absolucy/nanorand-rs', 'https://github.com/Absolucy/nanorand-rs/commit/5ba218ac29df4786b002d7d12b47fa0c04a331f2', 'https://twitter.com/aspenluxxxy/status/1336684692284772352', 'https://crates.io/crates/nanorand', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35926', 'https://rustsec.org/advisories/RUSTSEC-2020-0089.html']"
GHSA-rm4w-6696-r77p,nb-connect,https://github.com/smol-rs/nb-connect,['Memory Access'],2021-08-19 17:34:37+00:00,2021-08-25T20:52:14Z,"[('0.0.0-0', '1.0.3'), ('0', '1.0.3')]","`nb-connect` invalidly assumes the memory layout of std::net::SocketAddr
nb-connect invalidly assumes the memory layout of std::net::SocketAddr
","The [`nb-connect`](https://crates.io/crates/nb-connect) crate has assumed `std::net::SocketAddrV4`
and `std::net::SocketAddrV6` have the same memory layout as the system C representation
`sockaddr`. It has simply casted the pointers to convert the socket addresses to the
system representation. The standard library does not say anything about the memory
layout, and this will cause invalid memory access if the standard library
changes the implementation. No warnings or errors will be emitted once the
change happens.
An issue was discovered in the nb-connect crate before 1.0.3 for Rust. It may have invalid memory access for certain versions of the standard library because it relies on a direct cast of std::net::SocketAddrV4 and std::net::SocketAddrV6 data structures.
",Critical,"['https://crates.io/crates/nb-connect', 'https://rustsec.org/advisories/RUSTSEC-2021-0021.html', 'https://github.com/smol-rs/nb-connect', 'https://nvd.nist.gov/vuln/detail/CVE-2021-27376', 'https://github.com/smol-rs/nb-connect/issues/1']"
GHSA-32v7-ghpr-c8hg,ncurses,https://github.com/jeaye/ncurses-rs,"['Memory Access', 'Tainted Input']",2021-08-18 17:45:13+00:00,2021-08-25T20:58:47Z,"[('0.0.0-0', None), ('0', None)]","Buffer overflow and format vulnerabilities in functions exposed without unsafe
Buffer overflow and format vulnerabilities in ncurses
Mishandling of format strings in ncurses
","`ncurses` exposes functions from the ncurses library which:

- Pass buffers without length to C functions that may write an arbitrary amount of
  data, leading to a buffer overflow. (`instr`, `mvwinstr`, etc)
- Passes rust &str to strings expecting C format arguments, allowing hostile
  input to execute a format string attack, which trivially allows writing
  arbitrary data to stack memory (functions in the `printw` family).
An issue was discovered in the ncurses crate for Rust. There are instr and mvwinstr buffer overflows because interaction with C functions is mishandled.
An issue was discovered in the ncurses crate for Rust. There are format string issues in printw functions because C format arguments are mishandled.
",nan,"['https://nvd.nist.gov/vuln/detail/CVE-2019-15547', 'https://github.com/jeaye/ncurses-rs', 'https://nvd.nist.gov/vuln/detail/CVE-2019-15548', 'https://crates.io/crates/ncurses', 'https://github.com/jeaye/ncurses-rs/issues/172', 'https://rustsec.org/advisories/RUSTSEC-2019-0006.html', 'https://github.com/RustSec/advisory-db/issues/106']"
RUSTSEC-2020-0078,net2,https://github.com/deprecrated/net2-rs,[],2021-10-19 22:14:35+00:00,2020-11-07T12:00:00Z,"[('0.0.0-0', '0.2.36')]","`net2` invalidly assumes the memory layout of std::net::SocketAddr
","The [`net2`](https://crates.io/crates/net2) crate has assumed `std::net::SocketAddrV4`
and `std::net::SocketAddrV6` have the same memory layout as the system C representation
`sockaddr`. It has simply casted the pointers to convert the socket addresses to the
system representation. The standard library does not say anything about the memory
layout, and this will cause invalid memory access if the standard library
changes the implementation. No warnings or errors will be emitted once the
change happens.
",Medium,"['https://rustsec.org/advisories/RUSTSEC-2020-0078.html', 'https://github.com/deprecrated/net2-rs/issues/105', 'https://crates.io/crates/net2']"
RUSTSEC-2020-0016,net2,https://github.com/deprecrated/net2-rs,[],2020-10-02 01:29:11+00:00,2020-05-01T12:00:00Z,"[('0.0.0-0', None)]","`net2` crate has been deprecated; use `socket2` instead
","The [`net2`](https://crates.io/crates/net2) crate has been deprecated
and users are encouraged to considered [`socket2`](https://crates.io/crates/socket2) instead.
",nan,"['https://github.com/deprecrated/net2-rs/commit/3350e3819adf151709047e93f25583a5df681091', 'https://rustsec.org/advisories/RUSTSEC-2020-0016.html', 'https://crates.io/crates/net2']"
GHSA-76w9-p8mg-j927,nix,https://github.com/nix-rust/nix,"['Memory Access', 'Memory Management']",2022-01-07 18:28:40+00:00,2022-01-06T22:07:14Z,"[('0.21.0', '0.21.2'), ('0.22.0', '0.22.2'), ('0.16.0', '0.20.2'), ('0', '0.20.2')]","Out-of-bounds write in nix::unistd::getgrouplist
Out-of-bounds Write in nix
","On certain platforms, if a user has more than 16 groups, the
`nix::unistd::getgrouplist` function will call the libc `getgrouplist`
function with a length parameter greater than the size of the buffer it
provides, resulting in an out-of-bounds write and memory corruption.

The libc `getgrouplist` function takes an in/out parameter `ngroups`
specifying the size of the group buffer. When the buffer is too small to
hold all of the reqested user's group memberships, some libc
implementations, including glibc and Solaris libc, will modify `ngroups`
to indicate the actual number of groups for the user, in addition to
returning an error. The version of `nix::unistd::getgrouplist` in nix
0.16.0 and up will resize the buffer to twice its size, but will not
read or modify the `ngroups` variable. Thus, if the user has more than
twice as many groups as the initial buffer size of 8, the next call to
`getgrouplist` will then write past the end of the buffer.

The issue would require editing /etc/groups to exploit, which is usually
only editable by the root user.
An issue was discovered in the nix crate before 0.20.2, 0.21.x before 0.21.2, and 0.22.x before 0.22.2 for Rust. unistd::getgrouplist has an out-of-bounds write if a user is in more than 16 /etc/groups groups.
",nan,"['https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/nix/RUSTSEC-2021-0119.md', 'https://nvd.nist.gov/vuln/detail/CVE-2021-45707', 'https://rustsec.org/advisories/RUSTSEC-2021-0119.html', 'https://github.com/nix-rust/nix/issues/1541', 'https://github.com/nix-rust/nix', 'https://crates.io/crates/nix']"
GHSA-wxjf-9f4g-3v44,noise_search,https://github.com/pipedown/noise.git,"['Synchronization', 'Memory Management', 'Tainted Input']",2021-08-24 18:02:25+00:00,2021-08-25T20:56:05Z,"[('0.0.0-0', None), ('0', None)]","MvccRwLock allows data races & aliasing violations
Data races in noise_search
","Affected versions of this crate unconditionally implement Send/Sync for `MvccRwLock`.
This can lead to data races when types that are either `!Send` or `!Sync` (e.g. `Rc<T>`, `Arc<Cell<_>>`) are contained inside `MvccRwLock` and sent across thread boundaries. The data races can potentially lead to memory corruption (as demonstrated in the PoC from the original report issue).

Also, safe APIs of `MvccRwLock` allow aliasing violations by allowing `&T` and `LockResult<MutexGuard<Box<T>>>` to co-exist in conflicting lifetime regions. The APIs of `MvccRwLock` should either be marked as `unsafe` or `MbccRwLock` should be changed to private or pub(crate).
Affected versions of the `noise_search` crate unconditionally implement Send/Sync for `MvccRwLock`.
This can lead to data races when types that are either `!Send` or `!Sync` (e.g. `Rc<T>`, `Arc<Cell<_>>`) are contained inside `MvccRwLock` and sent across thread boundaries. The data races can potentially lead to memory corruption (as demonstrated in the PoC from the original report issue).

Also, safe APIs of `MvccRwLock` allow aliasing violations by allowing `&T` and `LockResult<MutexGuard<Box<T>>>` to co-exist in conflicting lifetime regions. The APIs of `MvccRwLock` should either be marked as `unsafe` or `MbccRwLock` should be changed to private or pub(crate).

",High,"['https://crates.io/crates/noise_search', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36461', 'https://rustsec.org/advisories/RUSTSEC-2020-0141.html', 'https://github.com/pipedown/noise/issues/72', 'https://github.com/pipedown/noise']"
GHSA-v935-pqmr-g8v9,num-bigint,https://github.com/rust-num/num-bigint,"['Memory Access', 'Tainted Input']",2021-11-03 15:02:32+00:00,2021-11-03T17:36:04Z,"[('0.4.1', '0.4.3')]","Unexpected panics in num-bigint
","### Impact

Two scenarios were reported where `BigInt` and `BigUint` multiplication may unexpectedly panic.

- The internal `mac3` function did not expect the possibility of non-empty all-zero inputs, leading to an `unwrap()` panic.
- A buffer was allocated with less capacity than needed for an intermediate result, leading to an assertion panic.

Rust panics can either cause stack unwinding or program abort, depending on the application configuration. In some settings, an unexpected panic may constitute a denial-of-service vulnerability.

### Patches
Both problems were introduced in version 0.4.1, and are fixed in version 0.4.3.

### For more information
If you have any questions or comments about this advisory, please open an issue in the [num-bigint](https://github.com/rust-num/num-bigint) repo.

### Acknowledgements
Thanks to Guido Vranken and Arvid Norberg for privately reporting these issues to the author.

### References
* [GHSA-v935-pqmr-g8v9](https://github.com/rust-num/num-bigint/security/advisories/GHSA-v935-pqmr-g8v9)
* [num-bigint#228](https://github.com/rust-num/num-bigint/pull/228)

",nan,"['https://github.com/rust-num/num-bigint/pull/228', 'https://github.com/rust-num/num-bigint/security/advisories/GHSA-v935-pqmr-g8v9', 'https://github.com/rust-num/num-bigint']"
RUSTSEC-2020-0040,obstack,https://github.com/petertodd/rust-obstack/,['Path Resolution'],2021-10-19 22:14:35+00:00,2020-09-03T12:00:00Z,"[('0', '0.1.4'), ('0.0.0-0', '0.1.4')]","Unaligned references in Obstack
Obstack generates unaligned references
","An issue was discovered in the obstack crate before 0.1.4 for Rust. Unaligned references can occur.
Obstack generates unaligned references for types that require a large alignment.
",High,"['https://github.com/petertodd/rust-obstack/issues/4', 'https://github.com/petertodd/rust-obstack', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35894', 'https://rustsec.org/advisories/RUSTSEC-2020-0040.html', 'https://crates.io/crates/obstack']"
RUSTSEC-2019-0017,once_cell,https://github.com/matklad/once_cell,['Tainted Input'],2021-10-19 22:14:35+00:00,2019-09-01T12:00:00Z,"[('0.2.5', '1.0.1'), ('0', '1.0.1')]","Improper Input Validation in once_cell
Panic during initialization of Lazy<T> might trigger undefined behavior
","An issue was discovered in the once_cell crate before 1.0.1 for Rust. There is a panic during initialization of Lazy.
If during the first dereference of Lazy<T> the initialization function panics,
subsequent dereferences will execute `std::hints::unreachable_unchecked`.

Applications with `panic = ""abort""` are not affected, as there will be no
subsequent dereferences.
",High,"['https://nvd.nist.gov/vuln/detail/CVE-2019-16141', 'https://github.com/matklad/once_cell/issues/46', 'https://rustsec.org/advisories/RUSTSEC-2019-0017.html', 'https://github.com/matklad/once_cell', 'https://crates.io/crates/once_cell']"
RUSTSEC-2016-0001,openssl,https://github.com/sfackler/rust-openssl,['Authentication'],2021-10-19 22:14:35+00:00,2016-11-05T12:00:00Z,"[('0.0.0-0', '0.9.0'), ('0', '0.9.0')]","Improper Certificate Validation in openssl
SSL/TLS MitM vulnerability due to insecure defaults
","An issue was discovered in the openssl crate before 0.9.0 for Rust. There is an SSL/TLS man-in-the-middle vulnerability because certificate verification is off by default and there is no API for hostname verification.
All versions of rust-openssl prior to 0.9.0 contained numerous insecure defaults
including off-by-default certificate verification and no API to perform hostname
verification.

Unless configured correctly by a developer, these defaults could allow an attacker
to perform man-in-the-middle attacks.

The problem was addressed in newer versions by enabling certificate verification
by default and exposing APIs to perform hostname verification. Use the
`SslConnector` and `SslAcceptor` types to take advantage of these new features
(as opposed to the lower-level `SslContext` type).
",High,"['https://crates.io/crates/openssl', 'https://nvd.nist.gov/vuln/detail/CVE-2016-10931', 'https://rustsec.org/advisories/RUSTSEC-2016-0001.html', 'https://github.com/sfackler/rust-openssl', 'https://github.com/sfackler/rust-openssl/releases/tag/v0.9.0']"
GHSA-xjxc-vfw2-cg96,openssl,https://github.com/sfackler/rust-openssl,['Memory Access'],2021-08-19 21:24:24+00:00,2021-08-25T20:43:45Z,"[('0', '0.10.9'), ('0.10.8', '0.10.9')]","Use after free in CMS Signing
Use after free in openssl
","Affected versions of the OpenSSL crate used structures after they'd been freed.
An issue was discovered in the openssl crate before 0.10.9 for Rust. A use-after-free occurs in CMS Signing.
",Critical,"['https://rustsec.org/advisories/RUSTSEC-2018-0010.html', 'https://crates.io/crates/openssl', 'https://nvd.nist.gov/vuln/detail/CVE-2018-20997', 'https://github.com/sfackler/rust-openssl', 'https://github.com/sfackler/rust-openssl/pull/942']"
GHSA-qgm6-9472-pwq7,openssl-src,https://github.com/alexcrichton/openssl-src-rs,"['Risky Values', 'Resource Management']",2022-02-08 21:34:31+00:00,2021-08-25T20:52:19Z,"[('0', '111.14'), ('0.0.0-0', '111.14.0')]","Integer overflow in CipherUpdate
Integer Overflow in openssl-src
","Calls to `EVP_CipherUpdate`, `EVP_EncryptUpdate` and `EVP_DecryptUpdate` may overflow
the output length argument in some cases where the input length is close to the
maximum permissable length for an integer on the platform. In such cases the
return value from the function call will be 1 (indicating success), but the
output length value will be negative. This could cause applications to behave
incorrectly or crash.
Calls to EVP_CipherUpdate, EVP_EncryptUpdate and EVP_DecryptUpdate may overflow the output length argument in some cases where the input length is close to the maximum permissable length for an integer on the platform. In such cases the return value from the function call will be 1 (indicating success), but the output length value will be negative. This could cause applications to behave incorrectly or crash. OpenSSL versions 1.1.1i and below are affected by this issue. Users of these versions should upgrade to OpenSSL 1.1.1j. OpenSSL versions 1.0.2x and below are affected by this issue. However OpenSSL 1.0.2 is out of support and no longer receiving public updates. Premium support customers of OpenSSL 1.0.2 should upgrade to 1.0.2y. Other users should upgrade to 1.1.1j. Fixed in OpenSSL 1.1.1j (Affected 1.1.1-1.1.1i). Fixed in OpenSSL 1.0.2y (Affected 1.0.2-1.0.2x).
",High,"['https://security.netapp.com/advisory/ntap-20210219-0009/', 'https://www.tenable.com/security/tns-2021-03', 'https://www.debian.org/security/2021/dsa-4855', 'https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=9b1129239f3ebb1d1c98ce9ed41d5c9476c47cb2', 'https://www.tenable.com/security/tns-2021-10', 'https://cert-portal.siemens.com/productcert/pdf/ssa-389290.pdf', 'https://www.oracle.com/security-alerts/cpuApr2021.html', 'https://www.oracle.com/security-alerts/cpuapr2022.html', 'https://rustsec.org/advisories/RUSTSEC-2021-0057.html', 'https://nvd.nist.gov/vuln/detail/CVE-2021-23840', 'https://www.tenable.com/security/tns-2021-09', 'https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=6a51b9e1d0cf0bf8515f7201b68fb0a3482b3dc1', 'https://kb.pulsesecure.net/articles/Pulse_Security_Advisories/SA44846', 'https://lists.apache.org/thread.html/rf4c02775860db415b4955778a131c2795223f61cb8c6a450893651e4@%3Cissues.bookkeeper.apache.org%3E', 'https://www.oracle.com/security-alerts/cpujan2022.html', 'https://kc.mcafee.com/corporate/index?page=content&id=SB10366', 'https://www.openssl.org/news/secadv/20210216.txt', 'https://security.gentoo.org/glsa/202103-03', 'https://lists.apache.org/thread.html/r58af02e294bd07f487e2c64ffc0a29b837db5600e33b6e698b9d696b@%3Cissues.bookkeeper.apache.org%3E', 'https://github.com/alexcrichton/openssl-src-rs', 'https://www.oracle.com/security-alerts/cpuoct2021.html', 'https://crates.io/crates/openssl-src', 'https://www.oracle.com//security-alerts/cpujul2021.html']"
RUSTSEC-2022-0027,openssl-src,https://github.com/alexcrichton/openssl-src-rs,['Cryptography'],2022-05-19 17:41:25+00:00,2022-05-03T12:00:00Z,"[('300.0.0', '300.0.6')]","`OCSP_basic_verify` may incorrectly verify the response signing certificate
","The function `OCSP_basic_verify` verifies the signer certificate on an OCSP
response. In the case where the (non-default) flag OCSP_NOCHECKS is used then
the response will be positive (meaning a successful verification) even in the
case where the response signing certificate fails to verify.

It is anticipated that most users of `OCSP_basic_verify` will not use the
OCSP_NOCHECKS flag. In this case the `OCSP_basic_verify` function will return
a negative value (indicating a fatal error) in the case of a certificate
verification failure. The normal expected return value in this case would be 0.
",Medium,"['https://crates.io/crates/openssl-src', 'https://rustsec.org/advisories/RUSTSEC-2022-0027.html', 'https://www.openssl.org/news/secadv/20220503.txt']"
RUSTSEC-2020-0015,openssl-src,https://github.com/alexcrichton/openssl-src-rs,"['Memory Access', 'Resource Management']",2021-10-19 22:14:35+00:00,2020-04-25T12:00:00Z,"[('111.6.0', '111.9.0'), ('0', '111.9')]","Null pointer deference in openssl-src 
Crash causing Denial of Service attack
","Server or client applications that call the SSL_check_chain() function during or after a TLS 1.3 handshake may crash due to a NULL pointer dereference as a result of incorrect handling of the ""signature_algorithms_cert"" TLS extension. The crash occurs if an invalid or unrecognised signature algorithm is received from the peer. This could be exploited by a malicious peer in a Denial of Service attack. OpenSSL version 1.1.1d, 1.1.1e, and 1.1.1f are affected by this issue. This issue did not affect OpenSSL versions prior to 1.1.1d. Fixed in OpenSSL 1.1.1g (Affected 1.1.1d-1.1.1f).
Server or client applications that call the SSL_check_chain() function during or after a TLS 1.3 
handshake may crash due to a NULL pointer dereference as a result of incorrect handling of the 
""signature_algorithms_cert"" TLS extension. The crash occurs if an invalid or unrecognised signature 
algorithm is received from the peer. This could be exploited by a malicious peer in a Denial of 
Service attack.
",High,"['https://lists.apache.org/thread.html/r94d6ac3f010a38fccf4f432b12180a13fa1cf303559bd805648c9064@%3Cdev.tomcat.apache.org%3E', 'https://github.com/irsl/CVE-2020-1967', 'https://www.debian.org/security/2020/dsa-4661', 'https://www.tenable.com/security/tns-2020-04', 'https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/XVEP3LAK4JSPRXFO4QF4GG2IVXADV3SO/', 'https://www.oracle.com/security-alerts/cpuoct2020.html', 'https://www.tenable.com/security/tns-2021-10', 'https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=eb563247aef3e83dda7679c43f9649270462e5b1', 'https://nvd.nist.gov/vuln/detail/CVE-2020-1967', 'https://www.oracle.com/security-alerts/cpujul2020.html', 'https://kb.pulsesecure.net/articles/Pulse_Security_Advisories/SA44440', 'https://www.oracle.com/security-alerts/cpuApr2021.html', 'https://www.synology.com/security/advisory/Synology_SA_20_05', 'https://lists.apache.org/thread.html/r9a41e304992ce6aec6585a87842b4f2e692604f5c892c37e3b0587ee@%3Cdev.tomcat.apache.org%3E', 'http://seclists.org/fulldisclosure/2020/May/5', 'https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/EXDDAOWSAIEFQNBHWYE6PPYFV4QXGMCD/', 'https://www.tenable.com/security/tns-2020-03', 'https://security.gentoo.org/glsa/202004-10', 'https://www.oracle.com/security-alerts/cpujan2021.html', 'http://packetstormsecurity.com/files/157527/OpenSSL-signature_algorithms_cert-Denial-Of-Service.html', 'https://lists.apache.org/thread.html/r66ea9c436da150683432db5fbc8beb8ae01886c6459ac30c2cea7345@%3Cdev.tomcat.apache.org%3E', 'https://security.netapp.com/advisory/ntap-20200717-0004/', 'https://rustsec.org/advisories/RUSTSEC-2020-0015.html', 'https://www.oracle.com/security-alerts/cpuoct2021.html', 'https://www.tenable.com/security/tns-2020-11', 'https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/DDHOAATPWJCXRNFMJ2SASDBBNU5RJONY/', 'https://crates.io/crates/openssl-src', 'http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00011.html', 'https://security.FreeBSD.org/advisories/FreeBSD-SA-20:11.openssl.asc', 'https://security.netapp.com/advisory/ntap-20200424-0003/', 'https://www.synology.com/security/advisory/Synology_SA_20_05_OpenSSL', 'http://www.openwall.com/lists/oss-security/2020/04/22/2', 'http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00004.html', 'https://www.oracle.com//security-alerts/cpujul2021.html', 'https://www.openssl.org/news/secadv/20200421.txt']"
RUSTSEC-2022-0026,openssl-src,https://github.com/alexcrichton/openssl-src-rs,['Cryptography'],2022-05-19 17:39:22+00:00,2022-05-03T12:00:00Z,"[('300.0.0', '300.0.6')]","Incorrect MAC key used in the RC4-MD5 ciphersuite
","The OpenSSL 3.0 implementation of the RC4-MD5 ciphersuite incorrectly uses the
AAD data as the MAC key. This makes the MAC key trivially predictable.

An attacker could exploit this issue by performing a man-in-the-middle attack to
modify data being sent from one endpoint to an OpenSSL 3.0 recipient such that
the modified data would still pass the MAC integrity check.

Note that data sent from an OpenSSL 3.0 endpoint to a non-OpenSSL 3.0 endpoint
will always be rejected by the recipient and the connection will fail at that
point. Many application protocols require data to be sent from the client to the
server first. Therefore, in such a case, only an OpenSSL 3.0 server would be
impacted when talking to a non-OpenSSL 3.0 client.

If both endpoints are OpenSSL 3.0 then the attacker could modify data being
sent in both directions. In this case both clients and servers could be
affected, regardless of the application protocol.

Note that in the absence of an attacker this bug means that an OpenSSL 3.0
endpoint communicating with a non-OpenSSL 3.0 endpoint will fail to complete the
handshake when using this ciphersuite.

The confidentiality of data is not impacted by this issue, i.e. an attacker
cannot decrypt data that has been encrypted using this ciphersuite - they can
only modify it.

In order for this attack to work both endpoints must legitimately negotiate the
RC4-MD5 ciphersuite. This ciphersuite is not compiled by default in OpenSSL 3.0,
and is not available within the default provider or the default ciphersuite
list. This ciphersuite will never be used if TLSv1.3 has been negotiated. In
order for an OpenSSL 3.0 endpoint to use this ciphersuite the following must
have occurred:

1. OpenSSL must have been compiled with the (non-default) compile time option
   enable-weak-ssl-ciphers
2. OpenSSL must have had the legacy provider explicitly loaded (either through
   application code or via configuration)
3. The ciphersuite must have been explicitly added to the ciphersuite list
4. The libssl security level must have been set to 0 (default is 1)
5. A version of SSL/TLS below TLSv1.3 must have been negotiated
6. Both endpoints must negotiate the RC4-MD5 ciphersuite in preference to any
   others that both endpoints have in common
",Medium,"['https://crates.io/crates/openssl-src', 'https://rustsec.org/advisories/RUSTSEC-2022-0026.html', 'https://www.openssl.org/news/secadv/20220503.txt']"
RUSTSEC-2021-0097,openssl-src,https://github.com/alexcrichton/openssl-src-rs,['Cryptography'],2021-10-19 22:14:35+00:00,2021-08-24T12:00:00Z,"[('0.0.0-0', '111.16.0')]","SM2 Decryption Buffer Overflow
","In order to decrypt SM2 encrypted data an application is expected to call the
API function `EVP_PKEY_decrypt()`. Typically an application will call this
function twice. The first time, on entry, the ""out"" parameter can be NULL and,
on exit, the ""outlen"" parameter is populated with the buffer size required to
hold the decrypted plaintext. The application can then allocate a sufficiently
sized buffer and call `EVP_PKEY_decrypt()` again, but this time passing a non-NULL
value for the ""out"" parameter.

A bug in the implementation of the SM2 decryption code means that the
calculation of the buffer size required to hold the plaintext returned by the
first call to `EVP_PKEY_decrypt()` can be smaller than the actual size required by
the second call. This can lead to a buffer overflow when `EVP_PKEY_decrypt()` is
called by the application a second time with a buffer that is too small.

A malicious attacker who is able present SM2 content for decryption to an
application could cause attacker chosen data to overflow the buffer by up to a
maximum of 62 bytes altering the contents of other data held after the
buffer, possibly changing application behaviour or causing the application to
crash. The location of the buffer is application dependent but is typically
heap allocated.
",Critical,"['https://crates.io/crates/openssl-src', 'https://www.openssl.org/news/secadv/20210824.txt', 'https://rustsec.org/advisories/RUSTSEC-2021-0097.html']"
GHSA-83mx-573x-5rw9,openssl-src,https://github.com/alexcrichton/openssl-src-rs,['Memory Access'],2021-08-19 17:21:40+00:00,2021-08-25T20:54:02Z,"[('0', '111.15')]","Null pointer deference in openssl-src
","An OpenSSL TLS server may crash if sent a maliciously crafted renegotiation ClientHello message from a client. If a TLSv1.2 renegotiation ClientHello omits the signature_algorithms extension (where it was present in the initial ClientHello), but includes a signature_algorithms_cert extension then a NULL pointer dereference will result, leading to a crash and a denial of service attack. A server is only vulnerable if it has TLSv1.2 and renegotiation enabled (which is the default configuration). OpenSSL TLS clients are not impacted by this issue. All OpenSSL 1.1.1 versions are affected by this issue. Users of these versions should upgrade to OpenSSL 1.1.1k. OpenSSL 1.0.2 is not impacted by this issue. Fixed in OpenSSL 1.1.1k (Affected 1.1.1-1.1.1j).
",Medium,"['https://www.openssl.org/news/secadv/20210325.txt', 'https://www.tenable.com/security/tns-2021-10', 'http://www.openwall.com/lists/oss-security/2021/03/28/4', 'https://cert-portal.siemens.com/productcert/pdf/ssa-389290.pdf', 'https://kb.pulsesecure.net/articles/Pulse_Security_Advisories/SA44845', 'https://www.oracle.com/security-alerts/cpuApr2021.html', 'https://www.oracle.com/security-alerts/cpuapr2022.html', 'https://www.tenable.com/security/tns-2021-06', 'https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-openssl-2021-GHY28dJd', 'http://www.openwall.com/lists/oss-security/2021/03/27/1', 'https://nvd.nist.gov/vuln/detail/CVE-2021-3449', 'https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=fb9fa6b51defd48157eeb207f52181f735d96148', 'https://lists.debian.org/debian-lts-announce/2021/08/msg00029.html', 'https://www.tenable.com/security/tns-2021-09', 'https://rustsec.org/advisories/RUSTSEC-2021-0055', 'https://security.netapp.com/advisory/ntap-20210326-0006/', 'https://security.gentoo.org/glsa/202103-03', 'https://kc.mcafee.com/corporate/index?page=content&id=SB10356', 'https://www.debian.org/security/2021/dsa-4875', 'https://psirt.global.sonicwall.com/vuln-detail/SNWLID-2021-0013', 'https://www.tenable.com/security/tns-2021-05', 'https://github.com/alexcrichton/openssl-src-rs', 'https://security.FreeBSD.org/advisories/FreeBSD-SA-21:07.openssl.asc', 'https://www.oracle.com/security-alerts/cpuoct2021.html', 'https://security.netapp.com/advisory/ntap-20210513-0002/', 'http://www.openwall.com/lists/oss-security/2021/03/27/2', 'https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/CCBFLLVQVILIVGZMBJL3IXZGKWQISYNP/', 'http://www.openwall.com/lists/oss-security/2021/03/28/3', 'https://cert-portal.siemens.com/productcert/pdf/ssa-772220.pdf', 'https://www.oracle.com//security-alerts/cpujul2021.html']"
RUSTSEC-2021-0058,openssl-src,https://github.com/alexcrichton/openssl-src-rs,['Resource Management'],2021-10-19 22:14:35+00:00,2021-05-01T12:00:00Z,"[('0.0.0-0', '111.14.0')]","Null pointer deref in `X509_issuer_and_serial_hash()`
","The OpenSSL public API function `X509_issuer_and_serial_hash()` attempts to
create a unique hash value based on the issuer and serial number data contained
within an X509 certificate. However it fails to correctly handle any errors
that may occur while parsing the issuer field (which might occur if the issuer
field is maliciously constructed). This may subsequently result in a NULL
pointer deref and a crash leading to a potential denial of service attack.

The function `X509_issuer_and_serial_hash()` is never directly called by OpenSSL
itself so applications are only vulnerable if they use this function directly
and they use it on certificates that may have been obtained from untrusted
sources.
",Medium,"['https://crates.io/crates/openssl-src', 'https://rustsec.org/advisories/RUSTSEC-2021-0058.html', 'https://www.openssl.org/news/secadv/20210216.txt']"
RUSTSEC-2021-0055,openssl-src,https://github.com/alexcrichton/openssl-src-rs,['Resource Management'],2021-10-19 22:14:35+00:00,2021-05-01T12:00:00Z,"[('0.0.0-0', '111.15.0')]","NULL pointer deref in signature_algorithms processing
","An OpenSSL TLS server may crash if sent a maliciously crafted renegotiation
ClientHello message from a client. If a TLSv1.2 renegotiation ClientHello omits
the signature_algorithms extension (where it was present in the initial
ClientHello), but includes a signature_algorithms_cert extension then a NULL
pointer dereference will result, leading to a crash and a denial of service
attack.

A server is only vulnerable if it has TLSv1.2 and renegotiation enabled (which
is the default configuration). OpenSSL TLS clients are not impacted by this
issue.
",Medium,"['https://crates.io/crates/openssl-src', 'https://rustsec.org/advisories/RUSTSEC-2021-0055.html', 'https://www.openssl.org/news/secadv/20210325.txt']"
GHSA-84rm-qf37-fgc2,openssl-src,https://github.com/alexcrichton/openssl-src-rs,"['Risky Values', 'Memory Access']",2021-08-19 17:35:19+00:00,2021-08-25T20:52:21Z,"[('0', '111.14')]","Integer Overflow in openssl-src
","Calls to EVP_CipherUpdate, EVP_EncryptUpdate and EVP_DecryptUpdate may overflow the output length argument in some cases where the input length is close to the maximum permissable length for an integer on the platform. In such cases the return value from the function call will be 1 (indicating success), but the output length value will be negative. This could cause applications to behave incorrectly or crash. OpenSSL versions 1.1.1i and below are affected by this issue. Users of these versions should upgrade to OpenSSL 1.1.1j. OpenSSL versions 1.0.2x and below are affected by this issue. However OpenSSL 1.0.2 is out of support and no longer receiving public updates. Premium support customers of OpenSSL 1.0.2 should upgrade to 1.0.2y. Other users should upgrade to 1.1.1j. Fixed in OpenSSL 1.1.1j (Affected 1.1.1-1.1.1i). Fixed in OpenSSL 1.0.2y (Affected 1.0.2-1.0.2x).
",Medium,"['https://security.netapp.com/advisory/ntap-20210219-0009/', 'http://seclists.org/fulldisclosure/2021/May/67', 'https://www.tenable.com/security/tns-2021-03', 'https://www.debian.org/security/2021/dsa-4855', 'https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=9b1129239f3ebb1d1c98ce9ed41d5c9476c47cb2', 'https://www.oracle.com/security-alerts/cpuApr2021.html', 'https://www.oracle.com/security-alerts/cpuapr2022.html', 'https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=8252ee4d90f3f2004d3d0aeeed003ad49c9a7807', 'https://support.apple.com/kb/HT212528', 'https://support.apple.com/kb/HT212534', 'https://www.tenable.com/security/tns-2021-09', 'https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=6a51b9e1d0cf0bf8515f7201b68fb0a3482b3dc1', 'https://kb.pulsesecure.net/articles/Pulse_Security_Advisories/SA44846', 'https://nvd.nist.gov/vuln/detail/CVE-2021-23841', 'http://seclists.org/fulldisclosure/2021/May/70', 'http://seclists.org/fulldisclosure/2021/May/68', 'https://www.openssl.org/news/secadv/20210216.txt', 'https://security.gentoo.org/glsa/202103-03', 'https://rustsec.org/advisories/RUSTSEC-2021-0058', 'https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=122a19ab48091c657f7cb1fb3af9fc07bd557bbf', 'https://support.apple.com/kb/HT212529', 'https://github.com/alexcrichton/openssl-src-rs', 'https://www.oracle.com/security-alerts/cpuoct2021.html', 'https://security.netapp.com/advisory/ntap-20210513-0002/', 'https://www.oracle.com//security-alerts/cpujul2021.html']"
RUSTSEC-2021-0056,openssl-src,https://github.com/alexcrichton/openssl-src-rs,"['Cryptography', 'Authentication']",2021-10-19 22:14:35+00:00,2021-05-01T12:00:00Z,"[('111.11', '111.15'), ('111.11.0', '111.15.0')]","Certificate check bypass in openssl-src
CA certificate check bypass with X509_V_FLAG_X509_STRICT
","The X509_V_FLAG_X509_STRICT flag enables additional security checks of the certificates present in a certificate chain. It is not set by default. Starting from OpenSSL version 1.1.1h a check to disallow certificates in the chain that have explicitly encoded elliptic curve parameters was added as an additional strict check. An error in the implementation of this check meant that the result of a previous check to confirm that certificates in the chain are valid CA certificates was overwritten. This effectively bypasses the check that non-CA certificates must not be able to issue other certificates. If a ""purpose"" has been configured then there is a subsequent opportunity for checks that the certificate is a valid CA. All of the named ""purpose"" values implemented in libcrypto perform this check. Therefore, where a purpose is set the certificate chain will still be rejected even when the strict flag has been used. A purpose is set by default in libssl client and server certificate verification routines, but it can be overridden or removed by an application. In order to be affected, an application must explicitly set the X509_V_FLAG_X509_STRICT verification flag and either not set a purpose for the certificate verification or, in the case of TLS client or server applications, override the default purpose. OpenSSL versions 1.1.1h and newer are affected by this issue. Users of these versions should upgrade to OpenSSL 1.1.1k. OpenSSL 1.0.2 is not impacted by this issue. Fixed in OpenSSL 1.1.1k (Affected 1.1.1h-1.1.1j).
The X509_V_FLAG_X509_STRICT flag enables additional security checks of the
certificates present in a certificate chain. It is not set by default.

Starting from OpenSSL version 1.1.1h a check to disallow certificates in
the chain that have explicitly encoded elliptic curve parameters was added
as an additional strict check.

An error in the implementation of this check meant that the result of a
previous check to confirm that certificates in the chain are valid CA
certificates was overwritten. This effectively bypasses the check
that non-CA certificates must not be able to issue other certificates.

If a ""purpose"" has been configured then there is a subsequent opportunity
for checks that the certificate is a valid CA.  All of the named ""purpose""
values implemented in libcrypto perform this check.  Therefore, where
a purpose is set the certificate chain will still be rejected even when the
strict flag has been used. A purpose is set by default in libssl client and
server certificate verification routines, but it can be overridden or
removed by an application.

In order to be affected, an application must explicitly set the
X509_V_FLAG_X509_STRICT verification flag and either not set a purpose
for the certificate verification or, in the case of TLS client or server
applications, override the default purpose.
",High,"['https://www.openssl.org/news/secadv/20210325.txt', 'http://www.openwall.com/lists/oss-security/2021/03/28/4', 'https://cert-portal.siemens.com/productcert/pdf/ssa-389290.pdf', 'https://kb.pulsesecure.net/articles/Pulse_Security_Advisories/SA44845', 'https://www.oracle.com/security-alerts/cpuApr2021.html', 'https://www.oracle.com/security-alerts/cpuapr2022.html', 'https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-openssl-2021-GHY28dJd', 'http://www.openwall.com/lists/oss-security/2021/03/27/1', 'https://rustsec.org/advisories/RUSTSEC-2021-0056.html', 'https://mta.openssl.org/pipermail/openssl-announce/2021-March/000198.html', 'https://www.tenable.com/security/tns-2021-09', 'https://security.netapp.com/advisory/ntap-20210326-0006/', 'https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=2a40b7bc7b94dd7de897a74571e7024f0cf0d63b', 'https://security.gentoo.org/glsa/202103-03', 'https://www.tenable.com/security/tns-2021-08', 'https://kc.mcafee.com/corporate/index?page=content&id=SB10356', 'https://psirt.global.sonicwall.com/vuln-detail/SNWLID-2021-0013', 'https://www.tenable.com/security/tns-2021-05', 'https://security.FreeBSD.org/advisories/FreeBSD-SA-21:07.openssl.asc', 'https://www.oracle.com/security-alerts/cpuoct2021.html', 'https://crates.io/crates/openssl-src', 'https://nvd.nist.gov/vuln/detail/CVE-2021-3450', 'http://www.openwall.com/lists/oss-security/2021/03/27/2', 'https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/CCBFLLVQVILIVGZMBJL3IXZGKWQISYNP/', 'http://www.openwall.com/lists/oss-security/2021/03/28/3', 'https://www.oracle.com//security-alerts/cpujul2021.html']"
RUSTSEC-2021-0129,openssl-src,https://github.com/alexcrichton/openssl-src-rs,['Resource Management'],2021-12-15 00:18:24+00:00,2021-12-14T12:00:00Z,"[('300.0.0', '300.0.4')]","Invalid handling of `X509_verify_cert()` internal errors in libssl
","Internally libssl in OpenSSL calls `X509_verify_cert()` on the client side to
verify a certificate supplied by a server. That function may return a negative
return value to indicate an internal error (for example out of memory). Such a
negative return value is mishandled by OpenSSL and will cause an IO function
(such as `SSL_connect()` or `SSL_do_handshake()`) to not indicate success and a
subsequent call to `SSL_get_error()` to return the value
`SSL_ERROR_WANT_RETRY_VERIFY`. This return value is only supposed to be returned
by OpenSSL if the application has previously called
`SSL_CTX_set_cert_verify_callback()`. Since most applications do not do this the
`SSL_ERROR_WANT_RETRY_VERIFY` return value from `SSL_get_error()` will be totally
unexpected and applications may not behave correctly as a result. The exact
behaviour will depend on the application but it could result in crashes,
infinite loops or other similar incorrect responses.

This issue is made more serious in combination with a separate bug in OpenSSL
3.0 that will cause `X509_verify_cert()` to indicate an internal error when
processing a certificate chain. This will occur where a certificate does not
include the Subject Alternative Name extension but where a Certificate Authority
has enforced name constraints. This issue can occur even with valid chains.
",nan,"['https://crates.io/crates/openssl-src', 'https://www.openssl.org/news/secadv/20211214.txt', 'https://rustsec.org/advisories/RUSTSEC-2021-0129.html']"
RUSTSEC-2021-0098,openssl-src,https://github.com/alexcrichton/openssl-src-rs,"['Cryptography', 'Resource Management']",2021-10-19 22:14:35+00:00,2021-08-24T12:00:00Z,"[('0.0.0-0', '111.16.0')]","Read buffer overruns processing ASN.1 strings
","ASN.1 strings are represented internally within OpenSSL as an ASN1_STRING
structure which contains a buffer holding the string data and a field holding
the buffer length. This contrasts with normal C strings which are represented as
a buffer for the string data which is terminated with a NUL (0) byte.

Although not a strict requirement, ASN.1 strings that are parsed using OpenSSL's
own ""d2i"" functions (and other similar parsing functions) as well as any string
whose value has been set with the ASN1_STRING_set() function will additionally
NUL terminate the byte array in the ASN1_STRING structure.

However, it is possible for applications to directly construct valid ASN1_STRING
structures which do not NUL terminate the byte array by directly setting the
""data"" and ""length"" fields in the ASN1_STRING array. This can also happen by
using the `ASN1_STRING_set0()` function.

Numerous OpenSSL functions that print ASN.1 data have been found to assume that
the ASN1_STRING byte array will be NUL terminated, even though this is not
guaranteed for strings that have been directly constructed. Where an application
requests an ASN.1 structure to be printed, and where that ASN.1 structure
contains ASN1_STRINGs that have been directly constructed by the application
without NUL terminating the ""data"" field, then a read buffer overrun can occur.

The same thing can also occur during name constraints processing of certificates
(for example if a certificate has been directly constructed by the application
instead of loading it via the OpenSSL parsing functions, and the certificate
contains non NUL terminated ASN1_STRING structures). It can also occur in the
`X509_get1_email()`, `X509_REQ_get1_email()` and `X509_get1_ocsp()` functions.

If a malicious actor can cause an application to directly construct an
ASN1_STRING and then process it through one of the affected OpenSSL functions
then this issue could be hit. This might result in a crash (causing a Denial of
Service attack). It could also result in the disclosure of private memory
contents (such as private keys, or sensitive plaintext).
",High,"['https://crates.io/crates/openssl-src', 'https://rustsec.org/advisories/RUSTSEC-2021-0098.html', 'https://www.openssl.org/news/secadv/20210824.txt']"
RUSTSEC-2022-0014,openssl-src,https://github.com/alexcrichton/openssl-src-rs,"['Other', 'Resource Management']",2022-03-16 14:05:15+00:00,2022-03-15T12:00:00Z,"[('0', '111.18'), ('0.0.0-0', '111.18.0'), ('300.0', '300.0.5')]","Infinite loop in `BN_mod_sqrt()` reachable when parsing certificates
Infinite loop in `BN_mod_sqrt()` reachable when parsing certificates
","The BN_mod_sqrt() function, which computes a modular square root, contains a bug that can cause it to loop forever for non-prime moduli. Internally this function is used when parsing certificates that contain elliptic curve public keys in compressed form or explicit elliptic curve parameters with a base point encoded in compressed form. It is possible to trigger the infinite loop by crafting a certificate that has invalid explicit curve parameters. Since certificate parsing happens prior to verification of the certificate signature, any process that parses an externally supplied certificate may thus be subject to a denial of service attack. The infinite loop can also be reached when parsing crafted private keys as they can contain explicit elliptic curve parameters. Thus vulnerable situations include: - TLS clients consuming server certificates - TLS servers consuming client certificates - Hosting providers taking certificates or private keys from customers - Certificate authorities parsing certification requests from subscribers - Anything else which parses ASN.1 elliptic curve parameters Also any other applications that use the BN_mod_sqrt() where the attacker can control the parameter values are vulnerable to this DoS issue. In the OpenSSL 1.0.2 version the public key is not parsed during initial parsing of the certificate which makes it slightly harder to trigger the infinite loop. However any operation which requires the public key from the certificate will trigger the infinite loop. In particular the attacker can use a self-signed certificate to trigger the loop during verification of the certificate signature. This issue affects OpenSSL versions 1.0.2, 1.1.1 and 3.0. It was addressed in the releases of 1.1.1n and 3.0.2 on the 15th March 2022. Fixed in OpenSSL 3.0.2 (Affected 3.0.0,3.0.1). Fixed in OpenSSL 1.1.1n (Affected 1.1.1-1.1.1m). Fixed in OpenSSL 1.0.2zd (Affected 1.0.2-1.0.2zc).
The `BN_mod_sqrt()` function, which computes a modular square root, contains
a bug that can cause it to loop forever for non-prime moduli.

Internally this function is used when parsing certificates that contain
elliptic curve public keys in compressed form or explicit elliptic curve
parameters with a base point encoded in compressed form.

It is possible to trigger the infinite loop by crafting a certificate that
has invalid explicit curve parameters.

Since certificate parsing happens prior to verification of the certificate
signature, any process that parses an externally supplied certificate may thus
be subject to a denial of service attack. The infinite loop can also be
reached when parsing crafted private keys as they can contain explicit
elliptic curve parameters.

Thus vulnerable situations include:

 - TLS clients consuming server certificates
 - TLS servers consuming client certificates
 - Hosting providers taking certificates or private keys from customers
 - Certificate authorities parsing certification requests from subscribers
 - Anything else which parses ASN.1 elliptic curve parameters

Also any other applications that use the `BN_mod_sqrt()` where the attacker
can control the parameter values are vulnerable to this DoS issue.
",High,"['https://psirt.global.sonicwall.com/vuln-detail/SNWLID-2022-0002', 'https://www.debian.org/security/2022/dsa-5103', 'https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/GDB3GQVJPXJE7X5C5JN6JAA4XUDWD6E6/', 'https://www.tenable.com/security/tns-2022-08', 'https://www.oracle.com/security-alerts/cpuapr2022.html', 'https://www.tenable.com/security/tns-2022-09', 'https://security.netapp.com/advisory/ntap-20220429-0005/', 'https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=a466912611aa6cbdf550cd10601390e587451246', 'https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/323SNN6ZX7PRJJWP2BUAFLPUAE42XWLZ/', 'https://www.tenable.com/security/tns-2022-07', 'https://rustsec.org/advisories/RUSTSEC-2022-0014.html', 'https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=3118eb64934499d93db3230748a452351d1d9a65', 'https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/W6K3PR542DXWLEFFMFIDMME4CWMHJRMG/', 'https://www.openssl.org/news/secadv/20220315.txt', 'https://security.netapp.com/advisory/ntap-20220321-0002/', 'https://nvd.nist.gov/vuln/detail/CVE-2022-0778', 'https://lists.debian.org/debian-lts-announce/2022/03/msg00024.html', 'https://crates.io/crates/openssl-src', 'https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=380085481c64de749a6dd25cdf0bcf4360b30f83', 'https://www.tenable.com/security/tns-2022-06', 'https://lists.debian.org/debian-lts-announce/2022/03/msg00023.html']"
RUSTSEC-2022-0025,openssl-src,https://github.com/alexcrichton/openssl-src-rs,['Resource Management'],2022-05-19 20:32:59+00:00,2022-05-03T12:00:00Z,"[('300.0.0', '300.0.6')]","Resource leakage when decoding certificates and keys
","The `OPENSSL_LH_flush()` function, which empties a hash table, contains
a bug that breaks reuse of the memory occupied by the removed hash
table entries.

This function is used when decoding certificates or keys. If a long lived
process periodically decodes certificates or keys its memory usage will
expand without bounds and the process might be terminated by the operating
system causing a denial of service. Also traversing the empty hash table
entries will take increasingly more time.

Typically such long lived processes might be TLS clients or TLS servers
configured to accept client certificate authentication.
",High,"['https://crates.io/crates/openssl-src', 'https://www.openssl.org/news/secadv/20220503.txt', 'https://rustsec.org/advisories/RUSTSEC-2022-0025.html']"
GHSA-566x-hhrf-qf8m,ordered-float,https://github.com/reem/rust-ordered-float,['Memory Access'],2021-08-19 18:54:34+00:00,2021-08-25T20:50:30Z,"[('0.2.2', '1.1.1'), ('0', '2.0.1')]","ordered_float:NotNan may contain NaN after panic in assignment operators
Use after free in ordered-float
","After using an assignment operators such as `NotNan::add_assign`, `NotNan::mul_assign`, etc., it was possible for the resulting `NotNan` value to contain a `NaN`.  This could cause undefined behavior in safe code, because the safe `NotNan::cmp` method contains internal unsafe code that assumes the value is never `NaN`.  (It could also cause undefined behavior in third-party unsafe code that makes the same assumption, as well as logic errors in safe code.)

This was mitigated starting in version 0.4.0, by panicking if the assigned value is NaN.  However, in affected versions from 0.4.0 onward, code that uses the `NotNan` value during unwinding, or that continues after catching the panic, could still observe the invalid value and trigger undefined behavior.

The flaw is fully corrected in versions 1.1.1 and 2.0.1, by ensuring that the assignment operators panic without modifying the operand, if the result would be `NaN`.
An issue was discovered in the ordered-float crate before 1.1.1 and 2.x before 2.0.1 for Rust. A NotNan value can contain a NaN.
",Medium,"['https://rustsec.org/advisories/RUSTSEC-2020-0082.html', 'https://crates.io/crates/ordered-float', 'https://github.com/reem/rust-ordered-float', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35923', 'https://github.com/reem/rust-ordered-float/pull/71']"
RUSTSEC-2020-0038,ordnung,https://github.com/maciejhirsz/ordnung,"['Memory Access', 'Memory Management']",2021-10-19 22:14:35+00:00,2020-09-03T12:00:00Z,"[('0.0.0-0', None), ('0', None)]","Out of bounds read in ordnung
Double free in ordnung
Memory safety issues in `compact::Vec`
","An issue was discovered in the ordnung crate through 2020-09-03 for Rust. compact::Vec violates memory safety via out-of-bounds access for large capacity.
An issue was discovered in the ordnung crate through 2020-09-03 for Rust. compact::Vec violates memory safety via a remove() double free.
`compact::Vec` contains multiple memory safety issues.

1. It mishandles large capacity and causes out-of-bound access in 32-bit / allocator layout mismatch in 64-bit.
2. `remove()` is not panic-safe and causes double-free when an index larger than the length is provided.
",High,"['https://rustsec.org/advisories/RUSTSEC-2020-0038.html', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35890', 'https://github.com/maciejhirsz/ordnung/issues/8', 'https://github.com/maciejhirsz/ordnung', 'https://crates.io/crates/ordnung', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35891']"
GHSA-gffv-5hr2-f9gj,orion,https://github.com/orion-rs/orion,['Other'],2021-08-19 21:24:37+00:00,2021-08-25T20:43:18Z,"[('0.0.0-0', '0.11.2'), ('0', '0.11.2')]","Flaw in streaming state reset() functions can create incorrect results.
Incorrect results in orion
","Affected versions of this crate did not properly reset a streaming state.

Resetting a streaming state, without finalising it first, creates incorrect results.
 
The flaw was corrected by not first checking if the state had already been reset, when calling reset().
An issue was discovered in the orion crate before 0.11.2 for Rust. reset() calls cause incorrect results.
",High,"['https://crates.io/crates/orion', 'https://github.com/brycx/orion/issues/46', 'https://github.com/brycx/orion', 'https://rustsec.org/advisories/RUSTSEC-2018-0012.html', 'https://nvd.nist.gov/vuln/detail/CVE-2018-20999']"
RUSTSEC-2020-0012,os_str_bytes,https://github.com/dylni/os_str_bytes,['Risky Values'],2021-10-19 22:14:35+00:00,2020-04-24T12:00:00Z,"[('0', '2.0.0'), ('0.0.0-0', '2.0.0')]","os_str_bytes relies on undefined behavior of `char::from_u32_unchecked`
Relies on undefined behavior of `char::from_u32_unchecked`
","An issue was discovered in the os_str_bytes crate before 2.0.0 for Rust. It has false expectations about char::from_u32_unchecked behavior.
The Windows implementation of this crate relied on the behavior of
`std::char::from_u32_unchecked` when its safety clause is violated.
Even though this worked with Rust versions up to 1.42 (at least),
that behavior could change with any new Rust version, possibly leading
a security issue.

The flaw was corrected in version 2.0.0.
",High,"['https://nvd.nist.gov/vuln/detail/CVE-2020-35865', 'https://github.com/dylni/os_str_bytes', 'https://rustsec.org/advisories/RUSTSEC-2020-0012.html', 'https://github.com/dylni/os_str_bytes/pull/1', 'https://crates.io/crates/os_str_bytes']"
GHSA-6vmq-jh76-hq43,outer_cgi,https://github.com/SolraBizna/outer_cgi,['Memory Access'],2021-08-19 17:03:35+00:00,2021-08-25T20:55:25Z,"[('0', '0.2.1'), ('0.0.0-0', '0.2.1')]","KeyValueReader passes uninitialized memory to Read instance
Uninitialized memory access in outer_cgi
","The `KeyValueReader` type in affected versions of this crate set up an
uninitialized memory buffer and passed them to be read in to a user-provided
`Read` instance.

The `Read` instance could read uninitialized memory and cause undefined
behavior and miscompilations.

This issue was fixed in commit [dd59b30](https://github.com/SolraBizna/outer_cgi/commit/dd59b3066e616a08e756f72de8dc3ab11b7036c4)
by zero-initializing the buffers before passing them.
An issue was discovered in the outer_cgi crate before 0.2.1 for Rust. A user-provided Read instance receives an uninitialized memory buffer from KeyValueReader.
",Critical,"['https://nvd.nist.gov/vuln/detail/CVE-2021-30454', 'https://crates.io/crates/outer_cgi', 'https://github.com/SolraBizna/outer_cgi/issues/1', 'https://rustsec.org/advisories/RUSTSEC-2021-0051.html', 'https://github.com/SolraBizna/outer_cgi/commit/dd59b3066e616a08e756f72de8dc3ab11b7036c4', 'https://github.com/SolraBizna/outer_cgi']"
RUSTSEC-2020-0022,ozone,https://github.com/bqv/ozone,"['Memory Access', 'Exception Management']",2021-10-19 22:14:35+00:00,2020-07-04T12:00:00Z,"[('0.0.0-0', None), ('0', None)]","Out of bounds read in Ozone
Drop of uninitialized memory in Ozone
Ozone contains several memory safety issues
","An issue was discovered in the ozone crate through 2020-07-04 for Rust. Memory safety is violated because of out-of-bounds access.
An issue was discovered in the ozone crate through 2020-07-04 for Rust. Memory safety is violated because of the dropping of uninitialized memory.
Ozone contains several memory safety issues including [out-of-bound access](https://github.com/bqv/ozone/blob/e21f948b0178ab305f644118f18d87a838c618e0/src/buffer.rs#L38-L48)
and dropping of [uninitialized memory](https://github.com/bqv/ozone/blob/e21f948b0178ab305f644118f18d87a838c618e0/src/map.rs#L94-L101).
",Critical,"['https://rustsec.org/advisories/RUSTSEC-2020-0022.html', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35877', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35878', 'https://crates.io/crates/ozone', 'https://github.com/bqv/ozone']"
RUSTSEC-2019-0005,pancurses,https://github.com/ihalila/pancurses,['Tainted Input'],2021-10-19 22:14:35+00:00,2019-06-15T12:00:00Z,"[('0.0.0-0', None), ('0', None)]","Format string vulnerabilities in pancurses
Format string vulnerabilities in `pancurses`
","An issue was discovered in the pancurses crate through 0.16.1 for Rust. printw and mvprintw have format string vulnerabilities.
`pancurses::mvprintw` and `pancurses::printw` passes a pointer from a rust `&str` to C,
allowing hostile input to execute a format string attack, which trivially allows writing
arbitrary data to stack memory.
",High,"['https://github.com/ihalila/pancurses', 'https://nvd.nist.gov/vuln/detail/CVE-2019-15546', 'https://github.com/ihalila/pancurses/issues/66', 'https://rustsec.org/advisories/RUSTSEC-2019-0005.html', 'https://github.com/RustSec/advisory-db/issues/106', 'https://crates.io/crates/pancurses']"
GHSA-xwxc-j97j-84gf,parc,https://github.com/hyyking/rustracts/tree/master/parc,"['Memory Access', 'Synchronization', 'Memory Management']",2021-08-09 17:05:10+00:00,2021-08-25T21:00:03Z,"[('0.0.0-0', None), ('0', None)]","`LockWeak<T>` allows to create data race to `T`.
Data races in parc
Race condition in Parc
","In the affected versions of this crate, `LockWeak<T>` unconditionally implemented `Send` with no trait bounds on `T`. `LockWeak<T>` doesn't own `T` and only provides `&T`.

This allows concurrent access to a non-Sync `T`, which can cause undefined behavior like data races.
An issue was discovered in the parc crate through 2020-11-14 for Rust. LockWeak<T> has an unconditional implementation of Send without trait bounds on T.
In the affected versions of this crate, `LockWeak<T>` unconditionally implemented `Send` with no trait bounds on `T`. `LockWeak<T>` doesn't own `T` and only provides `&T`.

This allows concurrent access to a non-Sync `T`, which can cause undefined behavior like data races.

",High,"['https://nvd.nist.gov/vuln/detail/CVE-2020-36454', 'https://crates.io/crates/parc', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/parc/RUSTSEC-2020-0134.md', 'https://github.com/hyyking/rustracts/pull/6', 'https://github.com/hyyking/rustracts/tree/master/parc', 'https://rustsec.org/advisories/RUSTSEC-2020-0134.html']"
GHSA-qpgv-g792-wh6x,parse_duration,https://github.com/zeta12ti/parse_duration/,['Resource Management'],2021-08-19 17:21:25+00:00,2021-08-25T20:54:04Z,"[('0.0.0-0', None), ('0', None)]","Denial of service through parsing payloads with too big exponent
Uncontrolled Resource Consumption in parse_duration
","The `parse_duration::parse` function allows for parsing duration strings with exponents like `5e5s` where under the hood, the [`BigInt` type along with the `pow` function are used for such payloads](https://github.com/zeta12ti/parse_duration/blob/26940ab5cd4e3a9d6bd97aa101f8d4bbfd18ee8c/src/parse.rs#L335). Passing an arbitrarily big exponent makes the `parse_duration::parse` function to process the payload for a very long time taking up CPU and memory.

This allows an attacker to cause a DoS if the `parse_duration::parse` function is used to process untrusted input.
An issue was discovered in the parse_duration crate through 2021-03-18 for Rust. It allows attackers to cause a denial of service (CPU and memory consumption) via a duration string with a large exponent.
",High,"['https://crates.io/crates/parse_duration', 'https://nvd.nist.gov/vuln/detail/CVE-2021-29932', 'https://github.com/zeta12ti/parse_duration', 'https://github.com/zeta12ti/parse_duration/issues/21', 'https://rustsec.org/advisories/RUSTSEC-2021-0041.html']"
GHSA-45w3-v3g4-54pm,parsec-service,https://github.com/parallaxsecond/parsec,['Memory Access'],2022-02-11 19:11:36+00:00,2022-02-11T19:11:36Z,"[('0.8.0', None)]","Potential segfault in SPIFFE authenticator
","### Impact
Several vulnerabilities have been reported in the `time` and `chrono` crates related to handling of calls to `localtime_r`. You can follow some of the discussions [here](https://github.com/chronotope/chrono/issues/602) and [here](https://github.com/time-rs/time/issues/293), and the associated CVE [here](https://nvd.nist.gov/vuln/detail/CVE-2020-26235). In our case, the issue with the dependency was flagged by our nightly CI build running [`cargo-audit`](https://github.com/parallaxsecond/parsec/issues/544). 

The vulnerability leads to a segfault in specific circumstances - namely, when one of a number of functions in the `time` crate is called while any other thread is setting an environment variable. Given that in the case of the Parsec service this affects the SPIFFE authenticator, Parsec service users can encounter the issue only when the JWT SVID authenticator is enabled and being used. We have not undergone any manual tracing to understand if the vulnerable methods are called anywhere in our stack, however it seems reasonable to expect that if that were to be the case, the issue would lie in JWT validation (i.e. when handling the dates found within a Json Web Token). JWT validation could thus fail, bringing down the thread in which the request happens. The rest of the threads continue to work. Since the threadpool implementation that we use [continues replenishing the pool](https://docs.rs/threadpool/latest/threadpool/) when one thread panics, the impact on the service should be minimal.

### Patches
No current patches exist as the problems lie in a number of dependencies that are not under our control (see more details [here](https://github.com/parallaxsecond/parsec/issues/544#issuecomment-1024185688)).

The issue tracking the required change in the `rust-spiffe` crate (through which the vulnerable dependencies are imported in Parsec) can be seen [here](https://github.com/maxlambrecht/rust-spiffe/issues/17). Once updates happen in our dependency chain that allow us to update beyond the vulnerable versions of `time` and `chrono`, a new version of the Parsec service will be tagged and released with the appropriate notifications.

### Workarounds
The only complete workaround is to use a different type of authenticator with the Parsec service. 

### References
As quoted in the initial paragraph, you can find out more information:
* in the `chrono` repo issue [here](https://github.com/chronotope/chrono/issues/602)
* in the `time` repo issue [here](https://github.com/time-rs/time/issues/293)
* in the official CVE report [here](https://nvd.nist.gov/vuln/detail/CVE-2020-26235)
* in our tracking issue [here](https://github.com/parallaxsecond/parsec/issues/544)

### For more information
If you have any questions or comments about this advisory:
* Open an issue in [the Parsec service repo](https://github.com/parallaxsecond/parsec)
* Email us at [cncf-parsec-maintainers@lists.cncf.io](mailto:cncf-parsec-maintainers@lists.cncf.io)

",nan,"['https://github.com/parallaxsecond/parsec/issues/544#issuecomment-1024185688', 'https://nvd.nist.gov/vuln/detail/CVE-2020-26235', 'https://github.com/chronotope/chrono/issues/602', 'https://github.com/parallaxsecond/parsec', 'https://github.com/parallaxsecond/parsec/security/advisories/GHSA-45w3-v3g4-54pm', 'https://github.com/time-rs/time/issues/293', 'https://github.com/parallaxsecond/parsec/issues/544']"
GHSA-gjrj-9rj4-pgwx,perseus-actix-web,https://github.com/arctic-hen7/perseus,[],2021-12-17 19:33:49+00:00,2021-12-15T22:51:07Z,"[('0', '0.3.0-beta.22')]","DoS Vulnerability from Upstream Actix Web Issues
","### Impact
This vulnerability affects all users of the `perseus deploy` functionality who have not exported their sites to static files. If you are using the inbuilt Perseus server in production, there is a memory leak in Actix Web stemming from [this upstream issue](https://github.com/actix/actix-web/issues/1780) which can allow even a single user to cause the process to exhaust its memory on low-memory servers by continuously reloading the page. Note that this issue does not affect all Actix Web applications, but rather results from certain usage patterns which appear to be present in Perseus' server mechanics.

### Patches
This vulnerability is addressed in all versions after Perseus `v0.3.0-beta.21`, which temporarily discontinues the use of `perseus-actix-web` (until the upstream bug is fixed) and switches to `perseus-warp` instead, which utilizes [Warp](https://github.com/seanmonstar/warp).

Additionally, as of Perseus `v0.3.0-beta.22`, the Actix Web integration has been upgraded to use the latest unstable beta version of Actix Web, which appears to partially resolve this issue (the severity of the memory leak is reduced). However, due to the instability of this version, the default integration will remain Warp for now, and a warning will appear if you attempt to use the Actix Web integration.

<details>
<summary>Using the Actix Web integration</summary>

If the instability of the latest beta version of Actix Web is not a concern for you, you can use this integration by adding `-i actix-web` to `perseus serve` and the like. This will print a warning about instability, and will then operate with the beta version. Please report any failures in functionality that are not security-related to the Perseus team by [opening an issue on the repository](https://github.com/arctic-hen7/perseus/issues/new/choose).

Note however that switching to the Warp integration requires no code changes whatsoever unless you've ejected, so there are very few disadvantages to this change.

</details>

### Workarounds
Due to significant infrastructural changes within other Perseus packages that were needed to support Warp, this integration is not backward-compatible with any previous version of Perseus, meaning there are no easily feasible workarounds. If you're only in development though, this vulnerability is irrelevant until you push to production.

### CVE Status

Due to GitHub's requirements, a CVE can't be issued for this security advisory because the issue is technically one with Actix Web (though it's only in combination with certain mechanics in the Perseus server that this problem arises).

### References
See [this upstream issue](https://github.com/actix/actix-web/issues/1780) in Actix Web.

### For more information
If you have any questions or comments about this advisory:
* Open an issue on this repository
* Email me at [arctic_hen7@pm.me](mailto:arctic_hen7@pm.me)

",nan,"['https://github.com/arctic-hen7/perseus/security/advisories/GHSA-gjrj-9rj4-pgwx', 'https://github.com/actix/actix-web/issues/1780', 'https://github.com/arctic-hen7/perseus']"
RUSTSEC-2021-0101,pleaser,https://gitlab.com/edneville/please,"['Privilege', 'Access Control']",2021-09-10 15:58:27+00:00,2021-05-27T12:00:00Z,"[('0', '0.4'), ('0.0.0-0', '0.4.0')]","Permissions bypass in pleaser
Permissions bypass in pleaser
","Failure to normalize the umask in pleaser before 0.4 allows a local attacker to gain full root privileges if they are allowed to execute at least one command.
Failure to normalize the umask in pleaser before 0.4 allows a local attacker to gain full root privileges if they are allowed to execute at least one command.
",High,"['https://gitlab.com/edneville/please/-/tree/master/src/bin', 'https://gitlab.com/edneville/please', 'https://nvd.nist.gov/vuln/detail/CVE-2021-31155', 'https://rustsec.org/advisories/RUSTSEC-2021-0101.html', 'https://www.openwall.com/lists/oss-security/2021/05/18/1', 'https://crates.io/crates/pleaser']"
RUSTSEC-2021-0104,pleaser,https://gitlab.com/edneville/please,"['Path Resolution', 'Information Leak']",2021-09-10 16:01:55+00:00,2021-05-27T12:00:00Z,"[('0', '0.4'), ('0.0.0-0', '0.4.0')]","File exposure in pleaser
File exposure in pleaser
","pleaser before 0.4 allows a local unprivileged attacker to gain knowledge about the existence of files or directories in privileged locations via the search_path function, the --check option, or the -d option.
pleaser before 0.4 allows a local unprivileged attacker to gain knowledge about the existence of files or directories in privileged locations via the search_path function, the --check option, or the -d option.
",nan,"['https://gitlab.com/edneville/please/-/tree/master/src/bin', 'https://nvd.nist.gov/vuln/detail/CVE-2021-31153', 'https://crates.io/crates/pleaser', 'https://rustsec.org/advisories/RUSTSEC-2021-0104.html', 'http://www.openwall.com/lists/oss-security/2021/05/18/1']"
RUSTSEC-2021-0102,pleaser,https://gitlab.com/edneville/please,"['Path Resolution', 'Privilege', 'Predictability']",2021-09-10 15:58:05+00:00,2021-05-27T12:00:00Z,"[('0', '0.4'), ('0.0.0-0', '0.4.0')]","Permissions bypass in pleaser
Permissions bypass in pleaser
","pleaseedit in pleaser before 0.4 uses predictable temporary filenames in /tmp and the target directory. This allows a local attacker to gain full root privileges by staging a symlink attack.
pleaseedit in pleaser before 0.4 uses predictable temporary filenames in /tmp and the target directory. This allows a local attacker to gain full root privileges by staging a symlink attack.
",High,"['https://gitlab.com/edneville/please/-/tree/master/src/bin', 'https://gitlab.com/edneville/please', 'https://rustsec.org/advisories/RUSTSEC-2021-0102.html', 'https://www.openwall.com/lists/oss-security/2021/05/18/1', 'https://crates.io/crates/pleaser', 'https://nvd.nist.gov/vuln/detail/CVE-2021-31154']"
RUSTSEC-2020-0011,plutonium,https://github.com/mxxo/plutonium,[],2020-10-25 19:51:46+00:00,2020-04-23T12:00:00Z,"[('0.0.0-0', None)]","Library exclusively intended to obfuscate code.
","This crate allows you to write safe functions with unsafe bodies without the `unsafe` keyword.

The value this adds is questionable, and hides `unsafe` usages from naive analysis.
",nan,"['https://docs.rs/plutonium', 'https://crates.io/crates/plutonium', 'https://rustsec.org/advisories/RUSTSEC-2020-0011.html']"
GHSA-24g6-5rx7-58wj,pnet,https://github.com/libpnet/libpnet,"['Exception Management', 'Memory Management']",2022-01-07 16:13:36+00:00,2022-01-06T22:18:07Z,"[('0', '0.27.2'), ('0.0.0-0', '0.27.2')]","Compiler optimisation leads to SEGFAULT
Compiler optimisation for next_with_timeout in pnet::transport::IcmpTransportChannelIterator flaws to SEGFAULT
Missing Initialization of Resource in pnet
","Affected versions of the `pnet` crate were optimized out by compiler, which caused dereference of uninitialized file descriptor which caused segfault.
Affected versions of this crate were optimized out by compiler,
which caused dereference of uninitialized file descriptor which caused segfault.
An issue was discovered in the pnet crate before 0.27.2 for Rust. There is a segmentation fault (upon attempted dereference of an uninitialized descriptor) because of an erroneous IcmpTransportChannelIterator compiler optimization.
",Medium,"['https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/pnet/RUSTSEC-2019-0037.md', 'https://nvd.nist.gov/vuln/detail/CVE-2019-25054', 'https://github.com/libpnet/libpnet/', 'https://crates.io/crates/pnet', 'https://github.com/libpnet/libpnet', 'https://github.com/libpnet/libpnet/pull/455', 'https://github.com/libpnet/libpnet/issues/449', 'https://rustsec.org/advisories/RUSTSEC-2019-0037.html']"
GHSA-pq6v-x7gp-7776,portaudio,https://github.com/RustAudio/rust-portaudio.git,['Information Leak'],2021-08-19 21:25:09+00:00,2021-08-25T20:43:09Z,"[('0.0.0-0', None), ('0', None)]","HTTP download and execution allows MitM RCE
Source code is downloaded over cleartext HTTP in portaudio
","The build script in the portaudio crate will attempt to download via HTTP
the portaudio source and build it.

A Mallory in the middle can intercept the download with their own archive
and get RCE.
An issue was discovered in the portaudio crate through 0.7.0 for Rust. There is a man-in-the-middle issue because the source code is downloaded over cleartext HTTP.
",Medium,"['https://crates.io/crates/portaudio', 'https://nvd.nist.gov/vuln/detail/CVE-2016-10933', 'https://rustsec.org/advisories/RUSTSEC-2016-0003.html', 'https://github.com/RustAudio/rust-portaudio/issues/144', 'https://github.com/RustAudio/rust-portaudio']"
GHSA-qpjr-ch72-2qq4,portaudio-rs,https://github.com/mvdnes/portaudio-rs,"['Memory Access', 'Other', 'Memory Management']",2021-08-19 21:21:17+00:00,2021-08-25T20:45:17Z,"[('0', '0.3.2'), ('0.0.0-0', '0.3.2-0')]","Stream callback function is not unwind safe
Use after free in portaudio-rs
","Affected versions of this crate is not panic safe within callback functions `stream_callback` and `stream_finished_callback`.

The call to user-provided closure might panic before a `mem::forget` call, which then causes a use after free that grants attacker to control the callback function pointer.

This allows an attacker to construct an arbitrary code execution .
 
The flaw was reported by Phosphorus15.
An issue was discovered in the portaudio-rs crate through 0.3.1 for Rust. There is a use-after-free with resultant arbitrary code execution because of a lack of unwind safety in stream_callback and stream_finished_callback.
",Critical,"['https://nvd.nist.gov/vuln/detail/CVE-2019-16881', 'https://crates.io/crates/portaudio-rs', 'https://github.com/mvdnes/portaudio-rs/issues/20', 'https://rustsec.org/advisories/RUSTSEC-2019-0022.html', 'https://github.com/mvdnes/portaudio-rs']"
GHSA-fhvc-gp6c-h2wx,postscript,https://github.com/bodoni/postscript,"['Memory Access', 'Exception Management']",2021-08-19 17:35:31+00:00,2021-08-25T20:52:23Z,"[('0.0.0-0', '0.14.0'), ('0', '0.14.0')]","`Read` on uninitialized buffer may cause UB (`impl Walue for Vec<u8>`)
Read on uninitialized buffer in postscript
","Affected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation.

Arbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.
Reading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.

This flaw was fixed in commit 8026286 by zero-initializing the buffer before handing to a user-provided `Read`.
An issue was discovered in the postscript crate before 0.14.0 for Rust. It might allow attackers to obtain sensitive information from uninitialized memory locations via a user-provided Read implementation.
",High,"['https://rustsec.org/advisories/RUSTSEC-2021-0017.html', 'https://crates.io/crates/postscript', 'https://github.com/bodoni/postscript', 'https://nvd.nist.gov/vuln/detail/CVE-2021-26953', 'https://github.com/bodoni/postscript/issues/1']"
RUSTSEC-2020-0002,prost,https://github.com/tokio-rs/prost,"['Memory Access', 'Resource Management', 'Memory Management']",2021-10-19 22:14:35+00:00,2020-01-16T12:00:00Z,"[('0.0.0-0', '0.6.1'), ('0', '0.6.1')]","Out of bounds write in prost
Parsing a specially crafted message can result in a stack overflow
","An issue was discovered in the prost crate before 0.6.1 for Rust. There is stack consumption via a crafted message, causing a denial of service (e.g., x86) or possibly remote code execution (e.g., ARM).
Affected versions of this crate contained a bug in which decoding untrusted
input could overflow the stack.

On architectures with stack probes (like x86), this can be used for denial of
service attacks, while on architectures without stack probes (like ARM)
overflowing the stack is unsound and can result in potential memory corruption
(or even RCE).
 
The flaw was quickly corrected by @danburkert and released in version 0.6.1.
",Critical,"['https://github.com/danburkert/prost', 'https://github.com/danburkert/prost/issues/267', 'https://rustsec.org/advisories/RUSTSEC-2020-0002.html', 'https://crates.io/crates/prost', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35858']"
RUSTSEC-2021-0073,prost-types,https://github.com/tokio-rs/prost,"['Memory Access', 'Resource Management', 'Risky Values']",2021-11-06 20:37:35+00:00,2021-07-08T12:00:00Z,"[('0.0.0-0', '0.8.0'), ('0', '0.8.0')]","Overflow in prost-types
Conversion from `prost_types::Timestamp` to `SystemTime` can cause an overflow and panic
","An issue was discovered in the prost-types crate before 0.8.0 for Rust. An overflow can occur during conversion from Timestamp to SystemTime.
Affected versions of this crate contained a bug in which untrusted input could cause an overflow and panic when converting a `Timestamp` to `SystemTime`.

It is recommended to upgrade to `prost-types` v0.8 and switch the usage of `From<Timestamp> for SystemTime` to `TryFrom<Timestamp> for SystemTime`.

See [#438] for more information.

[#438]: https://github.com/tokio-rs/prost/issues/438
",High,"['https://nvd.nist.gov/vuln/detail/CVE-2021-38192', 'https://github.com/tokio-rs/prost/tree/master/prost-types', 'https://rustsec.org/advisories/RUSTSEC-2021-0073.html', 'https://github.com/tokio-rs/prost/issues/438', 'https://crates.io/crates/prost-types']"
RUSTSEC-2019-0003,protobuf,https://github.com/stepancheg/rust-protobuf/,['Resource Management'],2021-10-19 22:14:35+00:00,2019-06-08T12:00:00Z,"[('0.0.0-0', '1.7.5'), ('0', '2.6.0')]","Uncontrolled memory consumption in protobuf
Out of Memory in stream::read_raw_bytes_into()
","An issue was discovered in the protobuf crate before 2.6.0 for Rust. Attackers can exhaust all memory via Vec::reserve calls.
Affected versions of this crate called Vec::reserve() on user-supplied input.

This allows an attacker to cause an Out of Memory condition while calling the
vulnerable method on untrusted data.
",High,"['https://github.com/stepancheg/rust-protobuf/issues/411', 'https://lists.apache.org/thread.html/r7fed8dd9bee494094e7011cf3c2ab75bd8754ea314c6734688c42932@%3Ccommon-issues.hadoop.apache.org%3E', 'https://lists.apache.org/thread.html/rd64381fb8f92d640c1975dc50dcdf1b8512e02a2a7b20292d3565cae@%3Cissues.hbase.apache.org%3E', 'https://lists.apache.org/thread.html/r4ef574a5621b0e670a3ce641e9922543e34f22bf4c9ee9584aa67fcf@%3Cissues.hbase.apache.org%3E', 'https://nvd.nist.gov/vuln/detail/CVE-2019-15544', 'https://crates.io/crates/protobuf', 'https://rustsec.org/advisories/RUSTSEC-2019-0003.html', 'https://github.com/stepancheg/rust-protobuf', 'https://lists.apache.org/thread.html/r00097d0b5b6164ea428554007121d5dc1f88ba2af7b9e977a10572cd@%3Cdev.hbase.apache.org%3E']"
RUSTSEC-2022-0015,pty,https://github.com/hibariya/pty-rs,[],2022-03-22 14:52:42+00:00,2022-03-22T12:00:00Z,"[('0.0.0-0', None)]","pty is unmaintained
","The repository hasn't received any updates since Jun 25, 2017 and the author is unresponsive.

Maintained alternatives include:

* [`tokio-pty-process`](https://crates.io/crates/tokio-pty-process)
* [`pty-process`](https://crates.io/crates/pty-process)
",nan,"['https://crates.io/crates/pty', 'https://github.com/hibariya/pty-rs/issues/19', 'https://rustsec.org/advisories/RUSTSEC-2022-0015.html']"
RUSTSEC-2020-0074,pyo3,https://github.com/pyo3/pyo3,['Memory Access'],2021-10-19 22:14:35+00:00,2020-11-28T12:00:00Z,"[('0.12.0', '0.12.4')]","Reference counting error in pyo3
Reference counting error in `From<Py<T>>`
","An issue was discovered in the pyo3 crate before 0.12.4 for Rust. There is a reference-counting error and use-after-free in From<Py<T>>.
A bug in `From<Py<T>>` would lead to an extra reference count decrement, often
leading to use-after-free issues.
",Medium,"['https://nvd.nist.gov/vuln/detail/CVE-2020-35917', 'https://rustsec.org/advisories/RUSTSEC-2020-0074.html', 'https://github.com/PyO3/pyo3', 'https://crates.io/crates/pyo3', 'https://github.com/PyO3/pyo3/pull/1297']"
RUSTSEC-2022-0007,qcell,https://github.com/uazu/qcell,[],2022-01-24 17:41:17+00:00,2022-01-24T12:00:00Z,"[('0.0.0-0', '0.4.3')]","A malicious coder can get unsound access to TCell or TLCell memory
","This is impossible to do by accident, but by carefully constructing
marker types to be covariant, a malicious coder can cheat the
singleton check in `TCellOwner` and `TLCellOwner`, giving unsound
access to cell memory.  This could take the form of getting two
mutable references to the same memory, or a mutable reference and an
immutable reference.

The fix is for the crate to internally force the marker type to be
invariant.  This blocks the conversion between covariant types which
Rust normally allows.
",nan,"['https://github.com/uazu/qcell/issues/20', 'https://crates.io/crates/qcell', 'https://rustsec.org/advisories/RUSTSEC-2022-0007.html']"
RUSTSEC-2020-0067,quic-p2p,https://github.com/maidsafe/qp2p,[],2020-11-02 14:50:19+00:00,2020-11-02T12:00:00Z,"[('0.0.0-0', None)]","crate has been renamed to `qp2p`
","This crate has been renamed from `quic-p2p` to `qp2p`.

The new repository location is:

<https://github.com/maidsafe/qp2p>
",nan,"['https://github.com/maidsafe/qp2p/pull/141', 'https://crates.io/crates/quic-p2p', 'https://rustsec.org/advisories/RUSTSEC-2020-0067.html']"
RUSTSEC-2018-0016,quickersort,https://github.com/notriddle/quickersort,[],2020-10-02 01:29:11+00:00,2018-06-30T12:00:00Z,"[('0.0.0-0', '3.0.2-0')]","quickersort is deprecated and unmaintained
","The author of the `quickersort` crate has deprecated it and does not recommend using it anymore.

Everything in it has been incorporated into [std::sort_unstable] in the standard library as of Rust 1.20.

[std::sort_unstable]: https://doc.rust-lang.org/stable/std/primitive.slice.html#method.sort_unstable
",nan,"['https://rustsec.org/advisories/RUSTSEC-2018-0016.html', 'https://crates.io/crates/quickersort', 'https://github.com/notriddle/quickersort/commit/0bc164366315801f0c6b31f4081b7df9fc894076']"
RUSTSEC-2021-0035,quinn,https://github.com/quinn-rs/quinn,['Memory Access'],2021-10-19 22:14:35+00:00,2021-03-04T12:00:00Z,"[('0.0.0-0', '0.5.4'), ('0', '0.5.4'), ('0.6.0', '0.6.2')]","quinn invalidly assumes the memory layout of std::net::SocketAddr
`quinn` invalidly assumes the memory layout of std::net::SocketAddr
","An issue was discovered in the quinn crate for Rust. It may have invalid memory access for certain versions of the standard library because it relies on a direct cast of std::net::SocketAddrV4 and std::net::SocketAddrV6 data structures.
The [`quinn`](https://crates.io/crates/quinn) crate has assumed `std::net::SocketAddrV4`
and `std::net::SocketAddrV6` have the same memory layout as the system C representation
`sockaddr`. It has simply casted the pointers to convert the socket addresses to the
system representation. The standard library does not say anything about the memory
layout, and this will cause invalid memory access if the standard library
changes the implementation. No warnings or errors will be emitted once the
change happens.
",High,"['https://crates.io/crates/quinn', 'https://rustsec.org/advisories/RUSTSEC-2021-0035.html', 'https://github.com/quinn-rs/quinn/issues/968', 'https://github.com/quinn-rs/quinn', 'https://nvd.nist.gov/vuln/detail/CVE-2021-28036']"
RUSTSEC-2021-0018,qwutils,https://github.com/qwertz19281/rust_utils,['Memory Management'],2021-10-19 22:14:35+00:00,2021-02-03T12:00:00Z,"[('0.0.0-0', '0.3.1')]","insert_slice_clone can double drop if Clone panics.
","Affected versions of this crate used `ptr::copy` when inserting into the middle
of a `Vec`. When ownership was temporarily duplicated during this copy, it calls
the clone method of a user provided element.

This issue can result in an element being double-freed if the clone call panics.

Commit `20cb73d` fixed this issue by adding a `set_len(0)` call before
operating on the vector to avoid dropping the elements during a panic.
",Medium,"['https://crates.io/crates/qwutils', 'https://rustsec.org/advisories/RUSTSEC-2021-0018.html', 'https://github.com/qwertz19281/rust_utils/issues/3']"
RUSTSEC-2019-0035,rand_core,https://github.com/rust-random/rand,['Risky Values'],2021-10-19 22:14:35+00:00,2019-04-19T12:00:00Z,"[('0', '0.3.1'), ('0.4.0', '0.4.2'), ('0.0.0-0', '0.3.1')]","Unaligned memory access in rand_core
Unaligned memory access
","### Impact
Affected versions of this crate violated alignment when casting byte slices to integer slices, resulting in undefined behavior. `rand_core::BlockRng::next_u64` and `rand_core::BlockRng::fill_bytes` are affected.

### Patches
The flaw was corrected by Ralf Jung and Diggory Hardy for `rand_core >= 0.4.2`.

### Workarounds
None.

### References
See [Rand's changelog](https://github.com/rust-random/rand/blob/master/rand_core/CHANGELOG.md#050---2019-06-06).

### For more information
If you have any questions or comments about this advisory, [open an issue in the Rand repository](https://github.com/rust-random/rand/issues/new/choose).


Affected versions of this crate violated alignment when casting byte slices to
integer slices, resulting in undefined behavior.

The flaw was corrected by Ralf Jung and Diggory Hardy.
",Critical,"['https://github.com/rust-random/rand/blob/master/rand_core/CHANGELOG.md#050---2019-06-06', 'https://rustsec.org/advisories/RUSTSEC-2019-0035.html', 'https://crates.io/crates/rand_core', 'https://github.com/rust-random/rand/security/advisories/GHSA-mmc9-pwm7-qj5w', 'https://github.com/rust-random/rand']"
RUSTSEC-2021-0023,rand_core,https://github.com/rust-random/rand,"['Cryptography', 'Predictability']",2021-10-19 22:14:35+00:00,2021-02-12T12:00:00Z,"[('0.6.0', '0.6.2')]","Incorrect check on buffer length in rand_core
Incorrect check on buffer length when seeding RNGs
","An issue was discovered in the rand_core crate before 0.6.2 for Rust. Because `read_u32_into` and `read_u64_into` mishandle certain buffer-length checks, a random number generator may be seeded with too little data. The vulnerability was introduced in v0.6.0. The advisory doesn't apply to earlier minor version numbers.
Summary: rand_core::le::read_u32_into and read_u64_into have incorrect checks on the source buffer length, allowing the destination buffer to be under-filled.

Implications: some downstream RNGs, including Hc128Rng (but not the more widely used ChaCha*Rng), allow seeding using the SeedableRng::from_seed trait-function with too short keys.
",Critical,"['https://github.com/rust-random/rand', 'https://github.com/rust-random/rand/pull/1096', 'https://crates.io/crates/rand_core', 'https://rustsec.org/advisories/RUSTSEC-2021-0023.html', 'https://github.com/rust-random/rand/compare/0.6.0...rand_core-0.6.2#diff-f41b3dfa5ce28f3bee390d327c50621e141cf3569921f8e9ca15ccfcf25263a9R19', 'https://github.com/rust-random/rand/compare/0.6.0...rand_core-0.6.2#diff-f41b3dfa5ce28f3bee390d327c50621e141cf3569921f8e9ca15ccfcf25263a9R28', 'https://nvd.nist.gov/vuln/detail/CVE-2021-27378']"
RUSTSEC-2021-0013,raw-cpuid,https://github.com/gz/rust-cpuid,"['Other', 'Resource Management', 'Memory Management', 'Tainted Input']",2021-08-22 01:18:11+00:00,2021-01-20T12:00:00Z,"[('0', '9.0.0'), ('0.0.0-0', '9.0.0')]","Error on unsupported architectures in raw-cpuid
Soundness issue in raw-cpuid
Soundness issues in `raw-cpuid`
","An issue was discovered in the raw-cpuid crate before 9.0.0 for Rust. It allows __cpuid_count() calls even if the processor does not support the CPUID instruction, which is unsound and causes a deterministic crash.
An issue was discovered in the raw-cpuid crate before 9.0.0 for Rust. It has unsound transmute calls within as_string() methods.
## Undefined behavior in `as_string()` methods

`VendorInfo::as_string()`, `SoCVendorBrand::as_string()`,
and `ExtendedFunctionInfo::processor_brand_string()` construct byte slices
using `std::slice::from_raw_parts()`, with data coming from
`#[repr(Rust)]` structs. This is always undefined behavior.

See https://github.com/gz/rust-cpuid/issues/40.

This flaw has been fixed in v9.0.0, by making the relevant structs
`#[repr(C)]`.

## `native_cpuid::cpuid_count()` is unsound

`native_cpuid::cpuid_count()` exposes the unsafe `__cpuid_count()` intrinsic
from `core::arch::x86` or `core::arch::x86_64` as a safe function, and uses
it internally, without checking the
[safety requirement](https://doc.rust-lang.org/core/arch/index.html#overview):

> The CPU the program is currently running on supports the function being
> called.

CPUID is available in most, but not all, x86/x86_64 environments. The crate
compiles only on these architectures, so others are unaffected.

This issue is mitigated by the fact that affected programs are expected
to crash deterministically every time.

See https://github.com/gz/rust-cpuid/issues/41.

The flaw has been fixed in v9.0.0, by intentionally breaking compilation
when targeting SGX or 32-bit x86 without SSE. This covers all affected CPUs.
",Medium,"['https://nvd.nist.gov/vuln/detail/CVE-2021-26307', 'https://crates.io/crates/raw-cpuid', 'https://rustsec.org/advisories/RUSTSEC-2021-0013.html', 'https://nvd.nist.gov/vuln/detail/CVE-2021-26306', 'https://github.com/gz/rust-cpuid/issues/40', 'https://github.com/RustSec/advisory-db/pull/614', 'https://github.com/gz/rust-cpuid']"
GHSA-w428-f65r-h4q2,raw-cpuid,https://github.com/gz/rust-cpuid,"['Resource Management', 'Memory Management', 'Tainted Input']",2022-01-07 17:23:21+00:00,2022-01-06T22:13:12Z,"[('3.1.1-0', '9.1.1'), ('0', '9.1.1')]","Optional `Deserialize` implementations lacking validation
Deserialization of Untrusted Data in rust-cpuid
","When activating the non-default feature `serialize`, most structs implement
`serde::Deserialize` without sufficient validation. This allows breaking
invariants in safe code, leading to:

* Undefined behavior in `as_string()` methods (which use
  `std::str::from_utf8_unchecked()` internally).
* Panics due to failed assertions.

See https://github.com/gz/rust-cpuid/issues/43.
An issue was discovered in the raw-cpuid crate before 9.1.1 for Rust. If the serialize feature is used (which is not the the default), a Deserialize operation may lack sufficient validation, leading to memory corruption or a panic.
",nan,"['https://rustsec.org/advisories/RUSTSEC-2021-0089.html', 'https://github.com/gz/rust-cpuid/issues/43', 'https://nvd.nist.gov/vuln/detail/CVE-2021-45687', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/raw-cpuid/RUSTSEC-2021-0089.md', 'https://crates.io/crates/raw-cpuid', 'https://github.com/gz/rust-cpuid']"
RUSTSEC-2020-0131,rcu_cell,https://github.com/Xudong-Huang/rcu_cell,"['Synchronization', 'Memory Management', 'Tainted Input']",2021-10-19 22:14:35+00:00,2020-11-14T12:00:00Z,"[('0', '0.1.9'), ('0.0.0-0', None)]","Data races in rcu_cell
Send/Sync bound needed on T  for Send/Sync impl of RcuCell<T>
","Affected versions of this crate unconditionally implement Send/Sync for `RcuCell<T>`.
This allows users to send `T: !Send` to other threads (while `T` enclosed within `RcuCell<T>`), and allows users to concurrently access `T: !Sync` by using the APIs of `RcuCell<T>` that provide access to `&T`.

This can result in memory corruption caused by data races.
Affected versions of this crate unconditionally implement Send/Sync for `RcuCell<T>`.
This allows users to send `T: !Send` to other threads (while `T` enclosed within `RcuCell<T>`), and allows users to concurrently access `T: !Sync` by using the APIs of `RcuCell<T>` that provide access to `&T`.

This can result in memory corruption caused by data races.
",High,"['https://github.com/Xudong-Huang/rcu_cell', 'https://rustsec.org/advisories/RUSTSEC-2020-0131.html', 'https://github.com/Xudong-Huang/rcu_cell/issues/3', 'https://github.com/Xudong-Huang/rcu_cell/pull/4', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36451', 'https://crates.io/crates/rcu_cell', 'https://github.com/Xudong-Huang/rcu_cell/pull/4/commits/1faf18eee11f14969b77ae0f76dcd9ebd437d0c2']"
GHSA-2rxc-8f9w-fjq8,rdiff,https://github.com/dyule/rdiff,"['Memory Access', 'Exception Management']",2022-01-07 18:25:00+00:00,2022-01-06T22:14:13Z,"[('0.0.0-0', None), ('0', None)]","Window can read out of bounds if Read instance returns more bytes than buffer size
Window may read from uninitialized memory locations in rdiff
","`rdiff` performs a diff of two provided strings or files. As part of its reading
code it uses the return value of a `Read` instance to set the length of
its internal character vector.

If the `Read` implementation claims that it has read more bytes than the length
of the provided buffer, the length of the vector will be set to longer than its
capacity. This causes `rdiff` APIs to return uninitialized memory in its API
methods.
An issue was discovered in the rdiff crate through 2021-02-03 for Rust. Window may read from uninitialized memory locations.
",nan,"['https://github.com/dyule/rdiff/issues/3', 'https://nvd.nist.gov/vuln/detail/CVE-2021-45694', 'https://github.com/dyule/rdiff', 'https://rustsec.org/advisories/RUSTSEC-2021-0094.html', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/rdiff/RUSTSEC-2021-0094.md', 'https://crates.io/crates/rdiff']"
GHSA-39xg-8p43-h76x,reffers,https://github.com/diwic/reffers-rs,"['Memory Access', 'Synchronization', 'Memory Management']",2021-08-19 18:49:46+00:00,2021-08-25T20:51:40Z,"[('0.0.0-0', '0.6.1'), ('0', None)]","Unsound: can make `ARefss` contain a !Send, !Sync object.
Data races in reffers
","`ARefss<'a, V>` is a type that is assumed to contain objects that are `Send + Sync`.

In the affected versions of this crate,
`Send`/`Sync` traits are unconditionally implemented for `ARefss<'a, V>`.

By using the `ARefss::map()` API, we can insert a `!Send` or `!Sync` object into `ARefss<'a, V>`. After that, it is possible to create a data race to the inner object of `ARefss<'a, V>`, which can lead to undefined behavior & memory corruption.

The flaw was corrected in commit 6dd7ca0 (https://github.com/diwic/reffers-rs/commit/6dd7ca0d50f2464df708975cdafcfaeeb6d41c66) by adding trait bound `V: Send + Sync` to `ARefss::map()` API.
An issue was discovered in the reffers crate through 2020-12-01 for Rust. ARefss can contain a !Send,!Sync object, leading to a data race and memory corruption.
",Medium,"['https://nvd.nist.gov/vuln/detail/CVE-2020-36203', 'https://github.com/diwic/reffers-rs/issues/7', 'https://github.com/diwic/reffers-rs', 'https://rustsec.org/advisories/RUSTSEC-2020-0094.html', 'https://crates.io/crates/reffers']"
GHSA-m5pq-gvj9-9vr8,regex,https://github.com/rust-lang/regex,['Resource Management'],2022-03-11 19:58:44+00:00,2022-03-08T20:00:36Z,"[('0', '1.5.5')]","Regular expression denial of service in Rust's regex crate
","> This is a cross-post of [the official security advisory][advisory]. The official advisory contains a signed version with our PGP key, as well.

[advisory]: https://groups.google.com/g/rustlang-security-announcements/c/NcNNL1Jq7Yw

The Rust Security Response WG was notified that the `regex` crate did not properly limit the complexity of the regular expressions (regex) it parses. An attacker could use this security issue to perform a denial of service, by sending a specially crafted regex to a service accepting untrusted regexes. No known vulnerability is present when parsing untrusted input with trusted regexes.

This issue has been assigned CVE-2022-24713. The severity of this vulnerability is ""high"" when the `regex` crate is used to parse untrusted regexes. Other uses of the `regex` crate are not affected by this vulnerability.

## Overview

The `regex` crate features built-in mitigations to prevent denial of service attacks caused by untrusted regexes, or untrusted input matched by trusted regexes. Those (tunable) mitigations already provide sane defaults to prevent attacks. This guarantee is documented and it's considered part of the crate's API.

Unfortunately a bug was discovered in the mitigations designed to prevent untrusted regexes to take an arbitrary amount of time during parsing, and it's possible to craft regexes that bypass such mitigations. This makes it possible to perform denial of service attacks by sending specially crafted regexes to services accepting user-controlled, untrusted regexes.

## Affected versions

All versions of the `regex` crate before or equal to 1.5.4 are affected by this issue. The fix is include starting from  `regex` 1.5.5.

## Mitigations

We recommend everyone accepting user-controlled regexes to upgrade immediately to the latest version of the `regex` crate.

Unfortunately there is no fixed set of problematic regexes, as there are practically infinite regexes that could be crafted to exploit this vulnerability. Because of this, we do not recommend denying known problematic regexes.

## Acknowledgements

We want to thank Addison Crump for responsibly disclosing this to us according to the [Rust security policy](https://www.rust-lang.org/policies/security), and for helping review the fix.

We also want to thank Andrew Gallant for developing the fix, and Pietro Albini for coordinating the disclosure and writing this advisory.
",High,"['https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/JANLZ3JXWJR7FSHE57K66UIZUIJZI67T/', 'https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PDOWTHNVGBOP2HN27PUFIGRYNSNDTYRJ/', 'https://www.debian.org/security/2022/dsa-5118', 'https://github.com/rust-lang/regex/commit/ae70b41d4f46641dbc45c7a4f87954aea356283e', 'https://groups.google.com/g/rustlang-security-announcements/c/NcNNL1Jq7Yw', 'https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/O3YB7CURSG64CIPCDPNMGPE4UU24AB6H/', 'https://github.com/rust-lang/regex/security/advisories/GHSA-m5pq-gvj9-9vr8', 'https://lists.debian.org/debian-lts-announce/2022/04/msg00009.html', 'https://lists.debian.org/debian-lts-announce/2022/04/msg00003.html', 'https://nvd.nist.gov/vuln/detail/CVE-2022-24713', 'https://www.debian.org/security/2022/dsa-5113', 'https://github.com/rust-lang/regex/']"
RUSTSEC-2022-0013,regex,https://github.com/rust-lang/regex,['Resource Management'],2022-03-08 15:14:30+00:00,2022-03-08T12:00:00Z,"[('0.0.0-0', '1.5.5')]","Regexes with large repetitions on empty sub-expressions take a very long time to parse
","The Rust Security Response WG was notified that the `regex` crate did not
properly limit the complexity of the regular expressions (regex) it parses. An
attacker could use this security issue to perform a denial of service, by
sending a specially crafted regex to a service accepting untrusted regexes. No
known vulnerability is present when parsing untrusted input with trusted
regexes.

This issue has been assigned CVE-2022-24713. The severity of this vulnerability
is ""high"" when the `regex` crate is used to parse untrusted regexes. Other uses
of the `regex` crate are not affected by this vulnerability.

## Overview

The `regex` crate features built-in mitigations to prevent denial of service
attacks caused by untrusted regexes, or untrusted input matched by trusted
regexes. Those (tunable) mitigations already provide sane defaults to prevent
attacks. This guarantee is documented and it's considered part of the crate's
API.

Unfortunately a bug was discovered in the mitigations designed to prevent
untrusted regexes to take an arbitrary amount of time during parsing, and it's
possible to craft regexes that bypass such mitigations. This makes it possible
to perform denial of service attacks by sending specially crafted regexes to
services accepting user-controlled, untrusted regexes.

## Affected versions

All versions of the `regex` crate before or equal to 1.5.4 are affected by this
issue. The fix is include starting from  `regex` 1.5.5.

## Mitigations

We recommend everyone accepting user-controlled regexes to upgrade immediately
to the latest version of the `regex` crate.

Unfortunately there is no fixed set of problematic regexes, as there are
practically infinite regexes that could be crafted to exploit this
vulnerability. Because of this, we do not recommend denying known problematic
regexes.

## Acknowledgements

We want to thank Addison Crump for responsibly disclosing this to us according
to the [Rust security policy][1], and for helping review the fix.

We also want to thank Andrew Gallant for developing the fix, and Pietro Albini
for coordinating the disclosure and writing this advisory.

[1]: https://www.rust-lang.org/policies/security
",High,"['https://rustsec.org/advisories/RUSTSEC-2022-0013.html', 'https://groups.google.com/g/rustlang-security-announcements/c/NcNNL1Jq7Yw', 'https://crates.io/crates/regex']"
GHSA-vhfr-v4w9-45v8,renderdoc,https://github.com/ebkalderon/renderdoc-rs,['Tainted Input'],2021-08-19 21:22:34+00:00,2021-08-25T20:44:51Z,"[('0.0.0-0', '0.5.0'), ('0', '0.5.0')]","Internally mutating methods take immutable ref self
Improper Input Validation in renderdoc
","Affected versions of this crate exposed several methods which took `self` by
immutable reference, despite the requesting the RenderDoc API to set a mutable
value internally.

This is technically unsound and calling these methods from multiple threads
without synchronization could lead to unexpected and unpredictable behavior.

The flaw was corrected in release 0.5.0.
An issue was discovered in the renderdoc crate before 0.5.0 for Rust. Multiple exposed methods take self by immutable reference, which is incompatible with a multi-threaded application.
",Critical,"['https://rustsec.org/advisories/RUSTSEC-2019-0018.html', 'https://github.com/ebkalderon/renderdoc-rs/pull/32', 'https://github.com/ebkalderon/renderdoc-rs', 'https://nvd.nist.gov/vuln/detail/CVE-2019-16142', 'https://crates.io/crates/renderdoc']"
RUSTSEC-2021-0134,rental,https://github.com/jpernst/rental,[],2022-03-06 11:02:04+00:00,2021-12-27T12:00:00Z,"[('0.0.0-0', None)]","rental is unmaintained, author has moved on
","The author encourages users to explore other solutions, or maintain a fork.

Maintained alternatives include:

* [`ouroboros`](https://crates.io/crates/ouroboros)
* [`fortify`](https://crates.io/crates/fortify)
* [`escher`](https://crates.io/crates/escher)
",nan,"['https://crates.io/crates/rental', 'https://github.com/jpernst/rental/commit/213671ab3aab3452efd7e2290c6bb714ee327014', 'https://rustsec.org/advisories/RUSTSEC-2021-0134.html']"
GHSA-3h87-v52r-p9rg,reorder,https://github.com/tiby312/reorder,['Memory Access'],2021-08-19 17:17:20+00:00,2021-08-25T20:54:08Z,"[('0.0.0-0', '1.1.0'), ('0', '1.1.0')]","swap_index can write out of bounds and return uninitialized memory
Out of bounds write in reorder
Out of bounds write in reorder
","`swap_index` takes an iterator and swaps the items with their corresponding
indexes. It reserves capacity and sets the length of the vector based on the
`.len()` method of the iterator.

If the `len()` returned by the iterator is larger than the actual number of
elements yielded, then `swap_index` creates a vector containing uninitialized
members. If the `len()` returned by the iterator is smaller than the actual
number of members yielded, then `swap_index` can write out of bounds past
its allocated vector.

As noted by the Rust documentation, [`len()`](https://doc.rust-lang.org/std/iter/trait.ExactSizeIterator.html#method.len)
and `size_hint()` are primarily meant for optimization and incorrect values
from their implementations should not lead to memory safety violations.


# Patch

A new version crate was pushed that marks this function as unsafe.

reorder = ""1.1.0""

Previous versions have also been yanked from crates.io.
An issue was discovered in the reorder crate through 1.1.0 for Rust. swap_index can return uninitialized values if an iterator returns a len() that is too large.
An issue was discovered in the reorder crate through 2021-02-24 for Rust. swap_index has an out-of-bounds write if an iterator returns a len() that is too small.
",High,"['https://github.com/tiby312/reorder/issues/1', 'https://crates.io/crates/reorder', 'https://nvd.nist.gov/vuln/detail/CVE-2021-29942', 'https://rustsec.org/advisories/RUSTSEC-2021-0050.html', 'https://github.com/tiby312/reorder', 'https://nvd.nist.gov/vuln/detail/CVE-2021-29941']"
RUSTSEC-2020-0029,rgb,https://github.com/kornelski/rust-rgb,"['Memory Access', 'Risky Values']",2021-10-19 22:14:35+00:00,2020-06-14T12:00:00Z,"[('0', '0.8.20'), ('0.5.4', '0.8.20')]","Out of bounds access in rgb
Allows viewing and modifying arbitrary structs as bytes
","A safety violation was discovered in the rgb crate before 0.8.20 for Rust, leading to (for example) dereferencing of arbitrary pointers or disclosure of uninitialized memory. This occurs because structs can be treated as bytes for read and write operations.
Affected versions of rgb crate allow viewing and modifying data of any type `T` wrapped in `RGB<T>` as bytes,
and do not correctly constrain `RGB<T>` and other wrapper structures to the types for which it is safe to do so.

Safety violation possible for a type wrapped in `RGB<T>` and similar wrapper structures:

 * If `T` contains padding, viewing it as bytes may lead to exposure of contents of uninitialized memory.
 * If `T` contains a pointer, modifying it as bytes may lead to dereferencing of arbitrary pointers.
 * Any safety and/or validity invariants for `T` may be violated.
 
The issue was resolved by requiring all types wrapped in structures provided by RGB crate to implement an unsafe marker trait.
",Critical,"['https://rustsec.org/advisories/RUSTSEC-2020-0029.html', 'https://github.com/kornelski/rust-rgb/issues/35', 'https://crates.io/crates/rgb', 'https://nvd.nist.gov/vuln/detail/CVE-2020-25016', 'https://github.com/kornelski/rust-rgb']"
GHSA-8rc5-mr4f-m243,rio,https://github.com/spacejam/rio,"['Memory Access', 'Resource Management', 'Memory Management']",2021-08-19 21:18:55+00:00,2021-08-25T20:46:57Z,"[('0.0.0-0', None), ('0', None)]","rio allows a use-after-free buffer access when a future is leaked
Use after free in rio
","When a `rio::Completion` is leaked, its drop code will not run. The drop code
is responsible for waiting until the kernel completes the I/O operation into, or
out of, the buffer borrowed by `rio::Completion`. Leaking the struct will allow
one to access and/or drop the buffer, which can lead to a use-after-free,
data races or leaking secrets.

Upstream is not interested in fixing the issue.
An issue was discovered in the rio crate through 2020-05-11 for Rust. A struct can be leaked, allowing attackers to obtain sensitive information, cause a use-after-free, or cause a data race.
",Critical,"['https://rustsec.org/advisories/RUSTSEC-2020-0021.html', 'https://github.com/spacejam/rio/pull/31', 'https://crates.io/crates/rio', 'https://github.com/spacejam/rio/issues/11', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35876', 'https://github.com/spacejam/rio']"
GHSA-g4xg-fxmg-vcg5,ripgrep,https://github.com/BurntSushi/ripgrep,['Tainted Input'],2021-09-07 21:16:08+00:00,2021-08-05T19:31:55Z,"[('0', '13.0.0'), ('0', '0.1.6')]","OS command injection in ripgrep
","ripgrep before 13 on Windows allows attackers to trigger execution of arbitrary programs from the current working directory via the -z/--search-zip or --pre flag.
",Critical,"['https://github.com/BurntSushi/ripgrep/blob/e48a17e1891e1ea9dd06ba0e48d5fb140ca7c0c4/CHANGELOG.md', 'https://nvd.nist.gov/vuln/detail/CVE-2021-3013', 'https://github.com/BurntSushi/ripgrep/blob/master/CHANGELOG.md#1300-2021-06-12', 'https://github.com/BurntSushi/ripgrep', 'https://github.com/BurntSushi/ripgrep/blob/master/CHANGELOG.md', 'https://rustsec.org/advisories/RUSTSEC-2021-0071.html']"
RUSTSEC-2021-0054,rkyv,https://github.com/rkyv/rkyv,"['Memory Access', 'Exception Management']",2021-10-19 22:14:35+00:00,2021-04-28T12:00:00Z,"[('0.0.0-0', '0.6.0'), ('0', '0.6.0')]","Use of uninitialized buffer in rkyv
Archives may contain uninitialized memory
","An issue was discovered in the rkyv crate before 0.6.0 for Rust. When an archive is created via serialization, the archive content may contain uninitialized values of certain parts of a struct.
`rkyv` is a serialization framework that writes struct-compatible memory to be stored or
transmitted. During serialization, struct padding bytes and unused enum bytes may not be
initialized. These bytes may be written to disk or sent over unsecured channels.
",High,"['https://github.com/djkoloski/rkyv/commit/9c65ae9c2c67dd949b5c3aba9b8eba6da802ab7e', 'https://rustsec.org/advisories/RUSTSEC-2021-0054.html', 'https://crates.io/crates/rkyv', 'https://github.com/djkoloski/rkyv/issues/113', 'https://nvd.nist.gov/vuln/detail/CVE-2021-31919', 'https://github.com/djkoloski/rkyv/commit/f141b560523a20557db6540576d153010bd18712']"
GHSA-mcrf-7hf9-f6q5,rmpv,https://github.com/3Hren/msgpack-rust,['Resource Management'],2021-08-06 19:28:40+00:00,2021-08-25T21:00:09Z,"[('0.0.0-0', '0.4.2'), ('0', '0.4.2')]","Unchecked vector pre-allocation
Unchecked vector pre-allocation
","Affected versions of this crate pre-allocate memory on deserializing raw
buffers without checking whether there is sufficient data available.

This allows an attacker to do denial-of-service attacks by sending small
msgpack messages that allocate gigabytes of memory.
Affected versions of this crate pre-allocate memory on deserializing raw
buffers without checking whether there is sufficient data available.

This allows an attacker to do denial-of-service attacks by sending small
msgpack messages that allocate gigabytes of memory.

",nan,"['https://github.com/3Hren/msgpack-rust', 'https://rustsec.org/advisories/RUSTSEC-2017-0006.html', 'https://crates.io/crates/rmpv', 'https://github.com/3Hren/msgpack-rust/issues/151']"
GHSA-8q2v-67v7-6vc6,rocket,https://github.com/SergioBenitez/Rocket,['Synchronization'],2021-08-19 21:07:49+00:00,2021-08-25T20:48:07Z,"[('0.4.0', '0.4.5'), ('0', '0.4.5')]","`LocalRequest::clone` creates multiple mutable references to the same object
Data races in rocket
","The affected version of `rocket` contains a `Clone` trait implementation of
`LocalRequest` that reuses the pointer to inner `Request` object.
This causes data race in rare combinations of APIs if the original and the
cloned objects are modified at the same time.
An issue was discovered in the rocket crate before 0.4.5 for Rust. LocalRequest::clone creates more than one mutable references to the same object, possibly causing a data race.
",High,"['https://nvd.nist.gov/vuln/detail/CVE-2020-35882', 'https://github.com/SergioBenitez/Rocket/issues/1312', 'https://rustsec.org/advisories/RUSTSEC-2020-0028.html', 'https://github.com/SergioBenitez/Rocket', 'https://crates.io/crates/rocket']"
RUSTSEC-2021-0044,rocket,https://github.com/SergioBenitez/Rocket,"['Memory Access', 'Memory Management']",2021-10-19 22:14:35+00:00,2021-02-09T12:00:00Z,"[('0.0.0-0', '0.4.7'), ('0', '0.4.7')]","Use after free in Rocket
Use after free possible in `uri::Formatter` on panic
","An issue was discovered in the rocket crate before 0.4.7 for Rust. uri::Formatter can have a use-after-free if a user-provided function panics.
Affected versions of this crate transmuted a `&str` to a `&'static str` before
pushing it into a `StackVec`, this value was then popped later in the same
function.

This was assumed to be safe because the reference would be valid while the
method's stack was active. In between the push and the pop, however, a function
`f` was called that could invoke a user provided function.

If the user provided panicked, then the assumption used by the function was no
longer true and the transmute to `&'static` would create an illegal static
reference to the string. This could result in a freed string being used during
(such as in a `Drop` implementation) or after (e.g through `catch_unwind`) the
panic unwinding.

This flaw was corrected in commit [e325e2f](https://github.com/SergioBenitez/Rocket/commit/e325e2fce4d9f9f392761e9fb58b418a48cef8bb)
by using a guard object to ensure that the `&'static str` was dropped inside
the function.
",High,"['https://nvd.nist.gov/vuln/detail/CVE-2021-29935', 'https://rustsec.org/advisories/RUSTSEC-2021-0044.html', 'https://github.com/SergioBenitez/Rocket', 'https://github.com/SergioBenitez/Rocket/issues/1534', 'https://crates.io/crates/rocket']"
GHSA-6mv9-qcx2-3hh3,routinator,https://github.com/NLnetLabs/routinator,['Memory Access'],2021-11-15 14:48:03+00:00,2021-11-11T00:55:08Z,"[('0.9.0', '0.10.2')]","Memory exhaustion in routinator
","NLnet Labs Routinator versions 0.9.0 up to and including 0.10.1, support the gzip transfer encoding when querying RRDP repositories. This encoding can be used by an RRDP repository to cause an out-of-memory crash in these versions of Routinator. RRDP uses XML which allows arbitrary amounts of white space in the encoded data. The gzip scheme compresses such white space extremely well, leading to very small compressed files that become huge when being decompressed for further processing, big enough that Routinator runs out of memory when parsing input data waiting for the next XML element.
",High,"['https://github.com/NLnetLabs/routinator', 'https://www.nlnetlabs.nl/downloads/routinator/CVE-2021-43172_CVE-2021-43173_CVE-2021-43174.txt', 'https://www.debian.org/security/2022/dsa-5041', 'https://nvd.nist.gov/vuln/detail/CVE-2021-43174']"
RUSTSEC-2020-0076,routing,https://github.com/maidsafe/sn_routing,[],2020-12-02 17:59:27+00:00,2020-11-02T12:00:00Z,"[('0.0.0-0', None)]","crate has been renamed to `sn_routing`
","This crate has been renamed from `routing` to `sn_routing`.

The new repository location is:

<https://github.com/maidsafe/sn_routing>
",nan,"['https://rustsec.org/advisories/RUSTSEC-2020-0076.html', 'https://github.com/maidsafe/sn_routing/pull/2190', 'https://crates.io/crates/routing']"
RUSTSEC-2020-0023,rulinalg,https://github.com/AtheMathmo/rulinalg,['Synchronization'],2021-10-19 22:14:35+00:00,2020-02-11T12:00:00Z,"[('0.4.0', None)]","Data races in rulinalg
Lifetime boundary for `raw_slice` and `raw_slice_mut` are incorrect
","An issue was discovered in the rulinalg crate through 2020-02-11 for Rust. There are incorrect lifetime-boundary definitions for RowMut::raw_slice and RowMut::raw_slice_mut.
The affected version of `rulinalg` has incorrect lifetime boundary definitions
for `RowMut::raw_slice` and `RowMut::raw_slice_mut`. They do not conform with
Rust's borrowing rule and allows the user to create multiple mutable references
to the same location. This may result in unexpected calculation result and data
race if both references are used at the same time.
",Critical,"['https://github.com/AtheMathmo/rulinalg', 'https://rustsec.org/advisories/RUSTSEC-2020-0023.html', 'https://github.com/AtheMathmo/rulinalg/issues/201', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35879', 'https://crates.io/crates/rulinalg']"
RUSTSEC-2020-0147,rulinalg,https://github.com/AtheMathmo/rulinalg,[],2021-03-04 13:58:02+00:00,2020-02-11T12:00:00Z,"[('0.0.0-0', None)]","rulinalg is unmaintained, use nalgebra instead
","The `rulinalg` crate is no longer maintained, use [nalgebra](https://crates.io/crates/nalgebra)
instead.
",nan,"['https://rustsec.org/advisories/RUSTSEC-2020-0147.html', 'https://crates.io/crates/rulinalg', 'https://github.com/AtheMathmo/rulinalg/issues/201#issuecomment-584749313']"
GHSA-9mxw-4856-9cm5,rusb,https://github.com/a1ien/rusb.git,"['Memory Access', 'Synchronization', 'Memory Management']",2021-08-19 18:51:05+00:00,2021-08-25T20:50:51Z,"[('0.0.0-0', '0.7.0'), ('0', '0.7.0')]","UsbContext trait did not require implementers to be Send and Sync.
Data races in rusb
","Affected versions of `rusb` did not require `UsbContext` to implement `Send`
and `Sync`. However, through `Device` and `DeviceHandle` it is possible to use
`UsbContext`s across threads.

This issue allows non-thread safe `UsbContext` types to be used concurrently
leading to data races and memory corruption.

The issue was fixed by adding `Send` and `Sync` bounds to `UsbContext`.
An issue was discovered in the rusb crate before 0.7.0 for Rust. Because of a lack of Send and Sync bounds, a data race and memory corruption can occur.
",High,"['https://github.com/a1ien/rusb/issues/44', 'https://rustsec.org/advisories/RUSTSEC-2020-0098.html', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36206', 'https://github.com/a1ien/rusb', 'https://crates.io/crates/rusb']"
GHSA-fqq2-xp7m-xvm8,ruspiro-singleton,https://github.com/RusPiRo/ruspiro-singleton/tree/v0.4.3,"['Memory Access', 'Synchronization', 'Memory Management']",2021-08-24 17:45:32+00:00,2021-08-25T20:58:19Z,"[('0.0.0-0', '0.4.1'), ('0', '0.4.1')]","Singleton lacks bounds on Send and Sync.
Data race in ruspiro-singleton
","`Singleton<T>` is meant to be a static object that can be initialized lazily. In
order to satisfy the requirement that `static` items must implement `Sync`,
`Singleton` implemented both `Sync` and `Send` unconditionally.

This allows for a bug where non-`Sync` types such as `Cell` can be used in
singletons and cause data races in concurrent programs.

The flaw was corrected in commit `b0d2bd20e` by adding trait bounds, requiring
the contaiend type to implement `Sync`.
`Singleton<T>` is meant to be a static object that can be initialized lazily. In
order to satisfy the requirement that `static` items must implement `Sync`,
`Singleton` implemented both `Sync` and `Send` unconditionally.

This allows for a bug where non-`Sync` types such as `Cell` can be used in
singletons and cause data races in concurrent programs.

The flaw was corrected in commit `b0d2bd20e` by adding trait bounds, requiring
the contaiend type to implement `Sync`.

",High,"['https://rustsec.org/advisories/RUSTSEC-2020-0115.html', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36435', 'https://github.com/RusPiRo/ruspiro-singleton', 'https://crates.io/crates/ruspiro-singleton', 'https://github.com/RusPiRo/ruspiro-singleton/commit/b0d2bd20eb40b9cbc2958b981ba2dcd9e6f9396e', 'https://github.com/RusPiRo/ruspiro-singleton/issues/10', 'https://github.com/RusPiRo/ruspiro-singleton/pull/11']"
GHSA-g4g4-3pqw-8m7f,rusqlite,https://github.com/rusqlite/rusqlite,"['Memory Access', 'Memory Management']",2022-01-06 20:20:29+00:00,2022-01-06T22:02:01Z,"[('0.26.0', '0.26.2'), ('0.25.0', '0.25.4')]","Incorrect Lifetime Bounds on Closures in `rusqlite`
Use After Free in rusqlite
Use After Free in rusqlite
Use After Free in rusqlite
Use After Free in rusqlite
Use After Free in rusqlite
Use After Free in rusqlite
Use After Free in rusqlite
","The lifetime bound on several closure-accepting `rusqlite` functions (specifically, functions which register a callback to be later invoked by SQLite) was too relaxed. If a closure referencing borrowed values on the stack is was passed to one of these functions, it could allow Rust code to access objects on the stack after they have been dropped.

The impacted functions are:

- Under `cfg(feature = ""functions"")`: `Connection::create_scalar_function`, `Connection::create_aggregate_function` and `Connection::create_window_function`.
- Under `cfg(feature = ""hooks"")`: `Connection::commit_hook`, `Connection::rollback_hook` and `Connection::update_hook`.
- Under `cfg(feature = ""collation"")`: `Connection::create_collation`.

The issue exists in all `0.25.*` versions prior to `0.25.4`, and all `0.26.*` versions prior to 0.26.2 (specifically: `0.25.0`, `0.25.1`, `0.25.2`, `0.25.3`, `0.26.0`, and `0.26.1`).

The fix is available in versions `0.26.2` and newer, and also has been back-ported to `0.25.4`. As it does not exist in `0.24.*`, all affected versions should have an upgrade path to a semver-compatible release.
An issue was discovered in the rusqlite crate 0.25.x before 0.25.4 and 0.26.x before 0.26.2 for Rust. create_aggregate_function has a use-after-free.
An issue was discovered in the rusqlite crate 0.25.x before 0.25.4 and 0.26.x before 0.26.2 for Rust. create_window_function has a use-after-free.
An issue was discovered in the rusqlite crate 0.25.x before 0.25.4 and 0.26.x before 0.26.2 for Rust. create_scalar_function has a use-after-free.
An issue was discovered in the rusqlite crate 0.25.x before 0.25.4 and 0.26.x before 0.26.2 for Rust. commit_hook has a use-after-free.
An issue was discovered in the rusqlite crate 0.25.x before 0.25.4 and 0.26.x before 0.26.2 for Rust. create_collation has a use-after-free.
An issue was discovered in the rusqlite crate 0.25.x before 0.25.4 and 0.26.x before 0.26.2 for Rust. update_hook has a use-after-free.
An issue was discovered in the rusqlite crate 0.25.x before 0.25.4 and 0.26.x before 0.26.2 for Rust. rollback_hook has a use-after-free.
",nan,"['https://nvd.nist.gov/vuln/detail/CVE-2021-45714', 'https://crates.io/crates/rusqlite', 'https://nvd.nist.gov/vuln/detail/CVE-2021-45718', 'https://github.com/rusqlite/rusqlite', 'https://nvd.nist.gov/vuln/detail/CVE-2021-45719', 'https://nvd.nist.gov/vuln/detail/CVE-2021-45717', 'https://nvd.nist.gov/vuln/detail/CVE-2021-45716', 'https://rustsec.org/advisories/RUSTSEC-2021-0128.html', 'https://github.com/rusqlite/rusqlite/issues/1048', 'https://github.com/rusqlite/rusqlite/', 'https://nvd.nist.gov/vuln/detail/CVE-2021-45713', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/rusqlite/RUSTSEC-2021-0128.md', 'https://nvd.nist.gov/vuln/detail/CVE-2021-45715']"
GHSA-q3cc-7p7g-392c,rusqlite,https://github.com/rusqlite/rusqlite,"['Memory Access', 'Synchronization', 'Tainted Input']",2021-08-19 21:08:56+00:00,2021-08-25T20:47:43Z,"[('0', '0.23.0'), ('0.0.0-0', '0.23.0')]","Data races in rusqlite
Data races in rusqlite
Mishandling of format strings in rusqlite
Data races in rusqlite
Data races in rusqlite
Improper type usage in rusqlite
Various memory safety issues
Use after free in rusqlite
Use after free in rusqlite
","An issue was discovered in the rusqlite crate before 0.23.0 for Rust. Memory safety can be violated via VTab / VTabCursor.
An issue was discovered in the rusqlite crate before 0.23.0 for Rust. Memory safety can be violated via UnlockNotification.
An issue was discovered in the rusqlite crate before 0.23.0 for Rust. Memory safety can be violated because rusqlite::trace::log mishandles format strings.
An issue was discovered in the rusqlite crate before 0.23.0 for Rust. Memory safety can be violated via an Auxdata API data race.
An issue was discovered in the rusqlite crate before 0.23.0 for Rust. Memory safety can be violated via create_module.
An issue was discovered in the rusqlite crate before 0.23.0 for Rust. Memory safety can be violated via the repr(Rust) type.
Several memory safety issues have been uncovered in an audit of
rusqlite.

See https://github.com/rusqlite/rusqlite/releases/tag/0.23.0 for a complete list.
An issue was discovered in the rusqlite crate before 0.23.0 for Rust. Memory safety can be violated via an Auxdata API use-after-free.
An issue was discovered in the rusqlite crate before 0.23.0 for Rust. Memory safety can be violated because sessions.rs has a use-after-free.
",Critical,"['https://github.com/rusqlite/rusqlite', 'https://github.com/rusqlite/rusqlite/releases/tag/0.23.0', 'https://github.com/rusqlite/rusqlite/commit/2327d3b774927fdf48903c0bdc1ca7ec93c7c8d0', 'https://github.com/rusqlite/rusqlite/commit/45fd77ee43c38eea4d6f4e2e56c1667a55ec654f', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35870', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35868', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35873', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35872', 'https://crates.io/crates/rusqlite', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35871', 'https://github.com/rusqlite/rusqlite/commit/71b2f5187b0cbace3f8b6ff53432ff2ca0defcf0', 'https://github.com/rusqlite/rusqlite/commit/ac30e169ae51b262bc8cf7026469851ce39b23c6', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35867', 'https://github.com/rusqlite/rusqlite/commit/c9ef5bd63cad5c0c123344c072b490a1a9bcbe1f', 'https://github.com/rusqlite/rusqlite/commit/3c6b57fe1b2cc87e7ebecde43dd836ffb1c4ea5c', 'https://rustsec.org/advisories/RUSTSEC-2020-0014.html', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35869', 'https://github.com/rusqlite/rusqlite/commit/2ef3628dac35aeba0a97d5fb3a57746b4e1d62b3', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35866']"
RUSTSEC-2022-0011,rust-crypto,https://github.com/DaGenix/rust-crypto/,['Cryptography'],2022-03-01 16:17:42+00:00,2022-02-28T12:00:00Z,"[('0.0.0-0', None)]","Miscomputation when performing AES encryption in rust-crypto
","The following Rust program demonstrates some strangeness in AES encryption - if you have an immutable key slice and then operate on that slice, you get different encryption output than if you operate on a copy of that key.

For these functions, we expect that extending a 16 byte key to a 32 byte key by repeating it gives the same encrypted data, because the underlying rust-crypto functions repeat key data up to the necessary key size for the cipher.

```rust
use crypto::{
    aes, blockmodes, buffer,
    buffer::{BufferResult, ReadBuffer, WriteBuffer},
    symmetriccipher,
};

fn encrypt(
    key: &[u8],
    iv: &[u8],
    data: &str,
) -> Result<String, symmetriccipher::SymmetricCipherError> {
    let mut encryptor =
        aes::cbc_encryptor(aes::KeySize::KeySize256, key, iv, blockmodes::PkcsPadding);

    let mut encrypted_data = Vec::<u8>::new();
    let mut read_buffer = buffer::RefReadBuffer::new(data.as_bytes());
    let mut buffer = [0; 4096];
    let mut write_buffer = buffer::RefWriteBuffer::new(&mut buffer);

    loop {
        let result = encryptor.encrypt(&mut read_buffer, &mut write_buffer, true)?;

        encrypted_data.extend(
            write_buffer
                .take_read_buffer()
                .take_remaining()
                .iter()
                .copied(),
        );

        match result {
            BufferResult::BufferUnderflow => break,
            BufferResult::BufferOverflow => {}
        }
    }

    Ok(hex::encode(encrypted_data))
}

fn working() {
    let data = ""data"";
    let iv = [
        0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE,
        0xFF,
    ];
    let key = [
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,
        0x0F,
    ];
    // The copy here makes the code work.
    let key_copy = key;
    let key2: Vec<u8> = key_copy.iter().cycle().take(32).copied().collect();
    println!(""key1:{} key2: {}"", hex::encode(&key), hex::encode(&key2));

    let x1 = encrypt(&key, &iv, data).unwrap();
    println!(""X1: {}"", x1);

    let x2 = encrypt(&key2, &iv, data).unwrap();
    println!(""X2: {}"", x2);

    assert_eq!(x1, x2);
}

fn broken() {
    let data = ""data"";
    let iv = [
        0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE,
        0xFF,
    ];
    let key = [
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,
        0x0F,
    ];
    // This operation shouldn't affect the contents of key at all.
    let key2: Vec<u8> = key.iter().cycle().take(32).copied().collect();
    println!(""key1:{} key2: {}"", hex::encode(&key), hex::encode(&key2));

    let x1 = encrypt(&key, &iv, data).unwrap();
    println!(""X1: {}"", x1);

    let x2 = encrypt(&key2, &iv, data).unwrap();
    println!(""X2: {}"", x2);

    assert_eq!(x1, x2);
}

fn main() {
    working();
    broken();
}
```

The output from this program:

```shell
     Running `target/host/debug/rust-crypto-test`
key1:000102030405060708090a0b0c0d0e0f key2: 000102030405060708090a0b0c0d0e0f000102030405060708090a0b0c0d0e0f
X1: 90462bbe32965c8e7ea0addbbed4cddb
X2: 90462bbe32965c8e7ea0addbbed4cddb
key1:000102030405060708090a0b0c0d0e0f key2: 000102030405060708090a0b0c0d0e0f000102030405060708090a0b0c0d0e0f
X1: 26e847e5e7df1947bf82a650548a7d5b
X2: 90462bbe32965c8e7ea0addbbed4cddb
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `""26e847e5e7df1947bf82a650548a7d5b""`,
 right: `""90462bbe32965c8e7ea0addbbed4cddb""`', src/main.rs:83:5
```

Notably, the X1 key in the `broken()` test changes every time after rerunning the program.
",nan,"['https://crates.io/crates/rust-crypto', 'https://rustsec.org/advisories/RUSTSEC-2022-0011.html']"
RUSTSEC-2016-0005,rust-crypto,https://github.com/DaGenix/rust-crypto/,[],2022-01-09 20:07:15+00:00,2016-09-06T12:00:00Z,"[('0.0.0-0', '0.2.37-0')]","rust-crypto is unmaintained; switch to a modern alternative
","The `rust-crypto` crate has not seen a release or GitHub commit since 2016,
and its author is unresponsive.

*NOTE: The (old) `rust-crypto` crate (with hyphen) should not be confused with
similarly named (new) [RustCrypto GitHub Org] (without hyphen). The GitHub Org
is actively maintained.*

We recommend you switch to one of the following crates instead, depending on
which algorithms you need:

- [dalek-cryptography GitHub Org]:
  - Key agreement: [`x25519-dalek`]
  - Signature algorithms: [`ed25519-dalek`]
- [`ring`]:
  - AEAD algorithms: AES-GCM, ChaCha20Poly1305
  - Digest algorithms: SHA-256, SHA-384, SHA-512, SHA-512/256 (legacy: SHA-1)
  - HMAC
  - Key agreement: ECDH (P-256, P-384), X25519
  - Key derivation: HKDF
  - Password hashing: PBKDF2
  - Signature algorithms: ECDSA (P-256, P-384), Ed25519, RSA (PKCS#1v1.5, PSS)
- [RustCrypto GitHub Org]:
  - AEAD algorithms: [`aes-gcm`], [`aes-gcm-siv`], [`aes-siv`], [`chacha20poly1305`], [`xsalsa20poly1305`]
  - Block ciphers: [`aes`], [`cast5`], [`des`]
  - Digest algorithms: [`sha2`], [`sha3`], [`blake2`], [`ripemd160`]
    (legacy: [`sha-1`], [`md-5`])
  - Key derivation: [`hkdf`]
  - MACs: [`cmac`], [`hmac`], [`pmac`], [`poly1305`]
  - Password hashing: [`pbkdf2`]
  - Stream ciphers: [`aes-ctr`], [`chacha20`], [`hc-256`], [`salsa20`]
- [`secp256k1`]:
  - Key agreement: ECDH (secp256k1 only)
  - Signature algorithms: ECDSA (secp256k1 only)
- [`orion`]:
  - AEAD algorithms: ChaCha20Poly1305 (IETF version), XChaCha20Poly1305
  - Digest algorithms: SHA-512, BLAKE2b
  - Key derivation: HKDF
  - MACs: HMAC, Poly1305
  - Password hashing: PBKDF2
  - Stream ciphers: ChaCha20 (IETF version), XChaCha20

[dalek-cryptography GitHub Org]: https://github.com/dalek-cryptography
[RustCrypto GitHub Org]: https://github.com/RustCrypto
[`aes`]: https://crates.io/crates/aes
[`aes-ctr`]: https://crates.io/crates/aes-ctr
[`aes-gcm`]: https://crates.io/crates/aes-gcm
[`aes-gcm-siv`]: https://crates.io/crates/aes-gcm-siv
[`aes-siv`]: https://crates.io/crates/aes-siv
[`blake2`]: https://crates.io/crates/blake2
[`cast5`]: https://crates.io/crates/cast5
[`chacha20`]: https://crates.io/crates/chacha20
[`chacha20poly1305`]: https://crates.io/crates/chacha20poly1305
[`cmac`]: https://crates.io/crates/cmac
[`des`]: https://crates.io/crates/des
[`ed25519-dalek`]: https://crates.io/crates/ed25519-dalek
[`hc-256`]: https://crates.io/crates/hc-256
[`hkdf`]: https://crates.io/crates/hkdf
[`hmac`]: https://crates.io/crates/hmac
[`pbkdf2`]: https://crates.io/crates/pbkdf2
[`pmac`]: https://crates.io/crates/pmac
[`poly1305`]: https://crates.io/crates/poly1305
[`ring`]: https://crates.io/crates/ring
[`ripemd160`]: https://crates.io/crates/ripemd160
[`salsa20`]: https://crates.io/crates/salsa20
[`secp256k1`]: https://crates.io/crates/secp256k1
[`sha-1`]: https://crates.io/crates/sha-1
[`sha2`]: https://crates.io/crates/sha2
[`sha3`]: https://crates.io/crates/sha3
[`x25519-dalek`]: https://crates.io/crates/x25519-dalek
[`xsalsa20poly1305`]: https://crates.io/crates/xsalsa20poly1305
[`orion`]: https://crates.io/crates/orion
",nan,"['https://crates.io/crates/rust-crypto', 'https://rustsec.org/advisories/RUSTSEC-2016-0005.html', 'https://github.com/DaGenix/rust-crypto/issues/440']"
GHSA-xrg3-hmf3-rvgw,rust-embed,https://github.com/pyros2097/rust-embed,['Path Resolution'],2022-01-07 16:10:23+00:00,2022-01-06T22:03:56Z,"[('0', '6.3.0'), ('0.0.0-0', '6.3.0')]","RustEmbed generated `get` method allows for directory traversal when reading files from disk
Path Traversal in rust-embed
","When running in debug mode and the `debug-embed` (off by default) feature is
not enabled, the generated `get` method does not check that the input path is
a child of the folder given. 

This allows attackers to read arbitrary files in the file system if they have
control over the filename given. The following code will print the contents of
your `/etc/passwd` if adjusted with a correct number of `../`s depending on
where it is run from.

```rust
#[derive(rust_embed::RustEmbed)]
#[folder = ""src/""]
pub struct Asset;

fn main() {
    let d = Asset::get(""../../../etc/passwd"").unwrap().data;
    println!(""{}"", String::from_utf8_lossy(&d));
}
```

The flaw was corrected by canonicalizing the input filename and ensuring that
it starts with the canonicalized folder path.
An issue was discovered in the rust-embed crate before 6.3.0 for Rust. A ../ directory traversal can sometimes occur in debug mode.
",nan,"['https://nvd.nist.gov/vuln/detail/CVE-2021-45712', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/rust-embed/RUSTSEC-2021-0126.md', 'https://github.com/pyros2097/rust-embed', 'https://crates.io/crates/rust-embed', 'https://rustsec.org/advisories/RUSTSEC-2021-0126.html', 'https://github.com/pyros2097/rust-embed/issues/159']"
RUSTSEC-2020-0003,rust_sodium,https://github.com/maidsafe/rust_sodium,[],2020-10-02 01:29:11+00:00,2020-01-20T12:00:00Z,"[('0.0.0-0', '0.10.3-0')]","rust_sodium is unmaintained; switch to a modern alternative
","The `rust_sodium` crate is no longer maintained by its current owner, who
advise in the repository readme that they are looking for
someone else to take ownership of it.

We recommend you switch to an alternative crate such as:
- [`sodiumoxide`](https://crates.io/crates/sodiumoxide)
",nan,"['https://crates.io/crates/rust_sodium', 'https://github.com/maidsafe/rust_sodium/pull/117', 'https://rustsec.org/advisories/RUSTSEC-2020-0003.html']"
RUSTSEC-2022-0004,rustc-serialize,https://github.com/rust-lang/rustc-serialize,['Resource Management'],2022-01-21 18:16:26+00:00,2022-01-01T12:00:00Z,"[('0.0.0-0', None)]","Stack overflow in rustc_serialize when parsing deeply nested JSON
","When parsing JSON using `json::Json::from_str`, there is no limit to the depth of the stack, therefore deeply nested objects can cause a stack overflow, which aborts the process.

Example code that triggers the vulnerability is

```rust
fn main() {
    let _ = rustc_serialize::json::Json::from_str(&""[0,["".repeat(10000));
}
```

[serde](https://crates.io/crates/serde) is recommended as a replacement to rustc_serialize.
",nan,"['https://crates.io/crates/rustc-serialize', 'https://rustsec.org/advisories/RUSTSEC-2022-0004.html']"
RUSTSEC-2020-0051,rustsec,https://github.com/RustSec/rustsec/tree/main/rustsec,[],2020-10-02 01:29:11+00:00,2020-10-01T12:00:00Z,"[('0.0.0-0', '0.19.0')]","Obsolete versions of the `rustsec` crate do not support the new V3 advisory format
","If you are seeing this message, you are running an obsolete version of
`cargo-audit` which does not support the new V3 advisory format.
These versions are end-of-life.

This advisory is a notice that that it will soon be unable to parse the
advisory database.

Please upgrade `cargo-audit` to a newer release.
",nan,"['https://github.com/RustSec/advisory-db/issues/414', 'https://rustsec.org/advisories/RUSTSEC-2020-0051.html', 'https://crates.io/crates/rustsec']"
RUSTSEC-2021-0024,safe-api,https://github.com/maidsafe/safe-api,[],2021-02-15 16:43:30+00:00,2021-02-15T12:00:00Z,"[('0.0.0-0', None)]","crate has been renamed to `sn_api`
","This crate has been renamed from `safe-api` to `sn_api`.

The new repository location is:

<https://github.com/maidsafe/sn_api>
",nan,"['https://github.com/maidsafe/sn_api/pull/619', 'https://crates.io/crates/safe-api', 'https://rustsec.org/advisories/RUSTSEC-2021-0024.html']"
RUSTSEC-2020-0063,safe-nd,https://github.com/maidsafe/sn_data_types,[],2020-11-02 14:43:36+00:00,2020-11-02T12:00:00Z,"[('0.0.0-0', None)]","crate has been renamed to `safe-nd`
","This crate has been renamed from `safe-nd` to `sn_data_types`.

The new repository location is:

<https://github.com/maidsafe/sn_data_types>
",nan,"['https://crates.io/crates/safe-nd', 'https://github.com/maidsafe/sn_data_types/pull/218', 'https://rustsec.org/advisories/RUSTSEC-2020-0063.html']"
RUSTSEC-2018-0013,safe-transmute,https://github.com/nabijaczleweli/safe-transmute-rs,['Memory Access'],2021-10-19 22:14:35+00:00,2018-11-27T12:00:00Z,"[('0.4.0', '0.10.1'), ('0', '0.10.1')]","Heap overflow or corruption in safe-transmute
Vec-to-vec transmutations could lead to heap overflow/corruption
","An issue was discovered in the safe-transmute crate before 0.10.1 for Rust. A constructor's arguments are in the wrong order, causing heap memory corruption.
Affected versions of this crate switched the length and capacity arguments in the Vec::from_raw_parts() constructor,
which could lead to memory corruption or data leakage.

The flaw was corrected by using the constructor correctly.
",Critical,"['https://nvd.nist.gov/vuln/detail/CVE-2018-21000', 'https://crates.io/crates/safe-transmute', 'https://github.com/nabijaczleweli/safe-transmute-rs', 'https://github.com/nabijaczleweli/safe-transmute-rs/pull/36', 'https://rustsec.org/advisories/RUSTSEC-2018-0013.html']"
RUSTSEC-2020-0083,safe_app,https://github.com/maidsafe/safe_client_libs,[],2020-12-07 17:22:02+00:00,2020-12-07T12:00:00Z,"[('0.0.0-0', None)]","crate has been superseded by `sn_client`
","This crate has been superseded by `sn_client`.

The new repository location is:

<https://github.com/maidsafe/sn_client>
",nan,"['https://github.com/maidsafe/sn_client/pull/1267', 'https://rustsec.org/advisories/RUSTSEC-2020-0083.html', 'https://crates.io/crates/safe_app']"
RUSTSEC-2020-0084,safe_authenticator,https://github.com/maidsafe/safe_client_libs,[],2020-12-07 17:22:02+00:00,2020-12-07T12:00:00Z,"[('0.0.0-0', None)]","crate has been superseded by `sn_client`
","This crate has been superseded by `sn_client`.

The new repository location is:

<https://github.com/maidsafe/sn_client>
",nan,"['https://github.com/maidsafe/sn_client/pull/1267', 'https://rustsec.org/advisories/RUSTSEC-2020-0084.html', 'https://crates.io/crates/safe_authenticator']"
RUSTSEC-2020-0066,safe_bindgen,https://github.com/maidsafe/sn_bindgen,[],2020-11-02 14:48:54+00:00,2020-11-02T12:00:00Z,"[('0.0.0-0', None)]","crate has been renamed to `sn_bindgen`
","This crate has been renamed from `safe_bindgen` to `sn_bindgen`.

The new repository location is:

<https://github.com/maidsafe/sn_bindgen>
",nan,"['https://rustsec.org/advisories/RUSTSEC-2020-0066.html', 'https://github.com/maidsafe/sn_bindgen/pull/67', 'https://crates.io/crates/safe_bindgen']"
RUSTSEC-2020-0086,safe_core,https://github.com/maidsafe/safe_client_libs,[],2020-12-07 17:22:02+00:00,2020-12-07T12:00:00Z,"[('0.0.0-0', None)]","crate has been renamed to `sn_client`
","This crate has been renamed from `safe_core` to `sn_client`.

The new repository location is:

<https://github.com/maidsafe/sn_client>
",nan,"['https://crates.io/crates/safe_core', 'https://github.com/maidsafe/sn_client/pull/1267', 'https://rustsec.org/advisories/RUSTSEC-2020-0086.html']"
RUSTSEC-2020-0085,safe_vault,https://github.com/maidsafe/safe_vault,[],2020-12-07 17:22:02+00:00,2020-12-07T12:00:00Z,"[('0.0.0-0', None)]","crate has been renamed to `sn_node`
","This crate has been renamed from `safe_vault` to `sn_node`.

The new repository location is:

<https://github.com/maidsafe/sn_node>
",nan,"['https://github.com/maidsafe/sn_node/pull/1116', 'https://rustsec.org/advisories/RUSTSEC-2020-0085.html', 'https://crates.io/crates/safe_vault']"
GHSA-gvvv-w559-2hg6,scottqueue,https://github.com/rossdylan/rust-scottqueue,"['Synchronization', 'Memory Management']",2021-08-24 17:59:17+00:00,2021-08-25T20:57:17Z,"[('0.0.0-0', None), ('0', None)]","Queue<T> should have a Send bound on its Send/Sync traits
Data races in scottqueue
","Affected versions of this crate unconditionally implements `Send`/`Sync` for `Queue<T>`.

This allows (1) creating data races to a `T: !Sync` and (2) sending `T: !Send` to other threads, resulting in memory corruption or other undefined behavior.
An issue was discovered in the scottqueue crate through 2020-11-15 for Rust. There are unconditional implementations of Send and Sync for Queue<T>. This allows (1) creating data races to a `T: !Sync` and (2) sending `T: !Send` to other threads, resulting in memory corruption or other undefined behavior.

",High,"['https://github.com/rossdylan/rust-scottqueue/issues/1', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36453', 'https://rustsec.org/advisories/RUSTSEC-2020-0133.html', 'https://crates.io/crates/scottqueue', 'https://github.com/rossdylan/rust-scottqueue']"
RUSTSEC-2021-0030,scratchpad,https://github.com/okready/scratchpad,['Memory Management'],2021-10-19 22:14:35+00:00,2021-02-18T12:00:00Z,"[('0.0.0-0', '1.3.1')]","move_elements can double-free objects on panic
","Affected versions of `scratchpad` used `ptr::read` to read elements while
calling a user provided function `f` on them.

Since the pointer read duplicates ownership, a panic inside the user provided
`f` function could cause a double free when unwinding.

The flaw was fixed in commit `891561bea` by removing the unsafe block and using
a plain iterator.
",Critical,"['https://github.com/okready/scratchpad/issues/1', 'https://crates.io/crates/scratchpad', 'https://rustsec.org/advisories/RUSTSEC-2021-0030.html']"
GHSA-jqqr-c2r2-9cvr,security-framework,https://github.com/kornelski/rust-security-framework,['Authentication'],2021-08-19 21:25:26+00:00,2021-08-25T20:42:59Z,"[('0', '0.1.12'), ('0.0.0-0', '0.1.12')]","Hostname verification skipped when custom root certs used
Improper Certificate Validation in security-framework
","If custom root certificates were registered with a `ClientBuilder`, the
hostname of the target server would not be validated against its presented leaf
certificate.

This issue was fixed by properly configuring the trust evaluation logic to
perform that check.
An issue was discovered in the security-framework crate before 0.1.12 for Rust. Hostname verification for certificates does not occur if ClientBuilder uses custom root certificates.
",Medium,"['https://github.com/sfackler/rust-security-framework', 'https://rustsec.org/advisories/RUSTSEC-2017-0003.html', 'https://crates.io/crates/security-framework', 'https://nvd.nist.gov/vuln/detail/CVE-2017-18588', 'https://github.com/sfackler/rust-security-framework/pull/27']"
RUSTSEC-2019-0025,serde_cbor,https://github.com/pyfisch/cbor,"['Memory Access', 'Cryptography']",2021-10-19 22:14:35+00:00,2019-10-03T12:00:00Z,"[('0', '0.10.2'), ('0.0.0-0', '0.10.2')]","Out of bounds write in serde_cbor
Flaw in CBOR deserializer allows stack overflow
","An issue was discovered in the serde_cbor crate before 0.10.2 for Rust. The CBOR deserializer can cause stack consumption via nested semantic tags.
Affected versions of this crate did not properly check if semantic tags were nested excessively during deserialization.

This allows an attacker to craft small (< 1 kB) CBOR documents that cause a stack overflow.
 
The flaw was corrected by limiting the allowed number of nested tags.
",High,"['https://github.com/pyfisch/cbor/releases/tag/v0.10.2', 'https://nvd.nist.gov/vuln/detail/CVE-2019-25001', 'https://crates.io/crates/serde_cbor', 'https://github.com/pyfisch/cbor', 'https://rustsec.org/advisories/RUSTSEC-2019-0025.html']"
RUSTSEC-2021-0127,serde_cbor,https://github.com/pyfisch/cbor,[],2021-12-01 14:04:55+00:00,2021-08-15T12:00:00Z,"[('0.0.0-0', None)]","serde_cbor is unmaintained
","The `serde_cbor` crate is unmaintained. The author has archived the github repository.

Alternatives proposed by the author:

 * [`ciborium`](https://crates.io/crates/ciborium)
 * [`minicbor`](https://crates.io/crates/minicbor)
",nan,"['https://rustsec.org/advisories/RUSTSEC-2021-0127.html', 'https://crates.io/crates/serde_cbor', 'https://github.com/pyfisch/cbor']"
GHSA-39vw-qp34-rmwf,serde_yaml,https://github.com/dtolnay/serde-yaml,['Resource Management'],2021-08-06 17:45:03+00:00,2021-08-25T21:00:18Z,"[('0.5.1', '0.8.4'), ('0.6.0-rc1', '0.8.4')]","Uncontrolled recursion leads to abort in deserialization
Uncontrolled recursion leads to abort in deserialization
","Affected versions of this crate did not properly check for recursion
while deserializing aliases.

This allows an attacker to make a YAML file with an alias referring
to itself causing an abort.

The flaw was corrected by checking the recursion depth.
Affected versions of this crate did not properly check for recursion
while deserializing aliases.

This allows an attacker to make a YAML file with an alias referring
to itself causing an abort.

The flaw was corrected by checking the recursion depth.

",nan,"['https://crates.io/crates/serde_yaml', 'https://github.com/dtolnay/serde-yaml/pull/105', 'https://rustsec.org/advisories/RUSTSEC-2018-0005.html', 'https://github.com/dtolnay/serde-yaml']"
RUSTSEC-2021-0100,sha2,https://github.com/RustCrypto/hashes,['Cryptography'],2021-09-09 16:22:48+00:00,2021-09-08T12:00:00Z,"[('0.9.7', '0.9.8')]","Incorrect hash in sha2
Miscomputed results when using AVX2 backend
","An issue was discovered in the sha2 crate 0.9.7 before 0.9.8 for Rust. Hashes of long messages may be incorrect when the AVX2-accelerated backend is used.
The v0.9.7 release of the `sha2` crate introduced a new AVX2-accelerated
backend which was automatically enabled for all x86/x86_64 CPUs where AVX2
support was autodetected at runtime.

This backend was buggy and would miscompute results for long messages
(i.e. messages spanning multiple SHA blocks).

The crate has since been yanked, but any users who upgraded to v0.9.7 should
immediately upgrade to v0.9.8 and recompute any hashes which were previously
computed by v0.9.7.
",Critical,"['https://github.com/RustCrypto/hashes', 'https://nvd.nist.gov/vuln/detail/CVE-2021-45696', 'https://crates.io/crates/sha2', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/sha2/RUSTSEC-2021-0100.md', 'https://rustsec.org/advisories/RUSTSEC-2021-0100.html', 'https://github.com/RustCrypto/hashes/pull/314']"
RUSTSEC-2020-0160,shamir,https://github.com/Nebulosus/shamir.git,['Cryptography'],2021-12-27 19:42:26+00:00,2020-01-21T12:00:00Z,"[('0.0.0-0', '2.0.0')]","Threshold value is ignored (all shares are n=3)
","Affected versions of this crate did not properly calculate secret shares requirements.

This reduces the security of the algorithm by restricting the crate to always
using a threshold value of three, rather than a configurable limit.

The flaw was corrected by correctly configuring the threshold.
",nan,"['https://crates.io/crates/shamir', 'https://rustsec.org/advisories/RUSTSEC-2020-0160.html', 'https://github.com/Nebulosus/shamir/issues/3']"
RUSTSEC-2020-0126,signal-simple,http://github.com/kitsuneninetails/signal-rust,"['Memory Access', 'Synchronization', 'Memory Management']",2021-10-19 22:14:35+00:00,2020-11-15T12:00:00Z,"[('0.0.0-0', None), ('0', None)]","SyncChannel<T> can move 'T: !Send' to other threads
Data races in signal-simple
SyncChannel<T> can move 'T: !Send' to other threads
","Affected versions of this crate unconditionally implement Send/Sync for `SyncChannel<T>`.
`SyncChannel<T>` doesn't provide access to `&T` but merely serves as a channel that consumes and returns owned `T`.

Users can create UB in safe Rust by sending `T: !Send` to other threads with `SyncChannel::send/recv` APIs. Using `T = Arc<Cell<_>` allows to create data races (which can lead to memory corruption), and using `T = MutexGuard<T>` allows to unlock a mutex from a thread that didn't lock the mutex.

An issue was discovered in the signal-simple crate through 2020-11-15 for Rust. There are unconditional implementations of Send and Sync for SyncChannel<T>.
Affected versions of this crate unconditionally implement Send/Sync for `SyncChannel<T>`.
`SyncChannel<T>` doesn't provide access to `&T` but merely serves as a channel that consumes and returns owned `T`.

Users can create UB in safe Rust by sending `T: !Send` to other threads with `SyncChannel::send/recv` APIs. Using `T = Arc<Cell<_>` allows to create data races (which can lead to memory corruption), and using `T = MutexGuard<T>` allows to unlock a mutex from a thread that didn't lock the mutex.
",nan,"['https://nvd.nist.gov/vuln/detail/CVE-2020-36446', 'http://github.com/kitsuneninetails/signal-rust', 'https://rustsec.org/advisories/RUSTSEC-2020-0126.html', 'https://github.com/kitsuneninetails/signal-rust/issues/2', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/signal-simple/RUSTSEC-2020-0126.md', 'https://crates.io/crates/signal-simple', 'https://github.com/kitsuneninetails/signal-rust/']"
RUSTSEC-2019-0008,simd-json,https://github.com/simd-lite/simd-json,['Memory Access'],2021-10-19 22:14:35+00:00,2019-06-24T12:00:00Z,"[('0.1.14-0', '0.1.15'), ('0', '0.1.15')]","Out of bounds read in simd-json
Flaw in string parsing can lead to crashes due to invalid memory access.
","An issue was discovered in the simd-json crate before 0.1.15 for Rust. There is an out-of-bounds read and an incorrect crossing of a page boundary.
The affected version of this crate did not guard against accessing memory
beyond the range of its input data. A pointer cast to read the data into
a 256-bit register could lead to a segmentation fault when the end plus
the 32 bytes (256 bit) read would overlap into the next page during string
parsing.

```
page   |  ...  page 1  ...  | ... page 2  ... |
data   | x[n * 32 byte]xx__ |                 |
access | ..][ 32 byte ]     |                 |
segflt |               [ 32 | byte ]          |
```

This allows an attacker to eventually crash a service.

The flaw was corrected by using a padding buffer for the last read from the
input. So that we are we never read over the boundary of the input data.
",High,"['https://crates.io/crates/simd-json', 'https://rustsec.org/advisories/RUSTSEC-2019-0008.html', 'https://nvd.nist.gov/vuln/detail/CVE-2019-15550', 'https://github.com/Licenser/simdjson-rs/pull/27', 'https://github.com/Licenser/simdjson-rs']"
GHSA-hqc8-j86x-2764,simple-slab,https://github.com/nathansizemore/simple-slab,"['Memory Access', 'Other']",2021-08-19 21:06:47+00:00,2021-08-25T20:48:33Z,"[('0', '0.3.3'), ('0.0.0-0', '0.3.3')]","Out of bounds read in simple-slab
`index()` allows out-of-bound read and `remove()` has off-by-one error
Off-by-one error in simple-slab
","An issue was discovered in the simple-slab crate before 0.3.3 for Rust. index() allows an out-of-bounds read.
`Slab::index()` does not perform the boundary checking, which leads to out-of-bound read access. `Slab::remove()` copies an element from an invalid address due to off-by-one error, resulting in memory leakage and uninitialized memory drop.
An issue was discovered in the simple-slab crate before 0.3.3 for Rust. remove() has an off-by-one error, causing memory leakage and a drop of uninitialized memory.
",Critical,"['https://rustsec.org/advisories/RUSTSEC-2020-0039.html', 'https://crates.io/crates/simple-slab', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35892', 'https://github.com/nathansizemore/simple-slab', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35893', 'https://github.com/nathansizemore/simple-slab/issues/2']"
RUSTSEC-2021-0125,simple_asn1,https://github.com/acw/simple_asn1,['Resource Management'],2021-11-18 00:32:59+00:00,2021-11-14T12:00:00Z,"[('0.6.0', '0.6.1')]","Uncontrolled Resource Consumption in simple_asn1
Panic on incorrect date input to `simple_asn1`
","An issue was discovered in the simple_asn1 crate 0.6.0 before 0.6.1 for Rust. There is a panic if UTCTime data, supplied by a remote attacker, has a second character greater than 0x7f.
Version 0.6.0 of the `simple_asn1` crate panics on certain malformed
inputs to its parsing functions, including `from_der` and `der_decode`.
Because this crate is frequently used with inputs from the network, this
should be considered a security vulnerability.

The issue occurs when parsing the old ASN.1 ""UTCTime"" time format.  If an
attacker provides a UTCTime where the first character is ASCII but the
second character is above 0x7f, a string slice operation in the
`from_der_` function will try to slice into the middle of a UTF-8
character, and cause a panic.

This error was introduced in commit
[`d7d39d709577710e9dc8`](https://github.com/acw/simple_asn1/commit/d7d39d709577710e9dc8833ee57d200eef366db8),
which updated `simple_asn1` to use `time` instead of `chrono` because of
[`RUSTSEC-2020-159`](https://rustsec.org/advisories/RUSTSEC-2020-0159).
Versions of `simple_asn1` before 0.6.0 are not affected by this issue.

The [patch](https://github.com/acw/simple_asn1/pull/28) was applied in
`simple_asn1` version 0.6.1.
",High,"['https://github.com/acw/simple_asn1/issues/27', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/simple_asn1/RUSTSEC-2021-0125.md', 'https://nvd.nist.gov/vuln/detail/CVE-2021-45711', 'https://github.com/acw/simple_asn1', 'https://crates.io/crates/simple_asn1', 'https://rustsec.org/advisories/RUSTSEC-2021-0125.html']"
GHSA-rfgg-vccr-m46m,sized-chunks,https://github.com/bodil/sized-chunks,"['Failure to Release Memory', 'Tainted Input']",2021-08-19 21:20:37+00:00,2021-08-25T20:45:58Z,"[('0.0.0-0', '0.6.3'), ('0', '0.6.3')]","Multiple soundness issues in Chunk and InlineArray
Array size is not checked in sized-chunks
Unaligned references in sized-chunks
Array size is not checked in sized-chunks
Missing release of memory in sized-chunks
Array size is not checked in sized-chunks
Missing release of memory in sized-chunks
","Chunk:

* Array size is not checked when constructed with `unit()` and `pair()`.
* Array size is not checked when constructed with `From<InlineArray<A, T>>`.
* `Clone` and `insert_from` are not panic-safe; A panicking iterator causes memory safety issues with them.

InlineArray:

* Generates unaligned references for types with a large alignment requirement.
An issue was discovered in the sized-chunks crate through 0.6.2 for Rust. In the Chunk implementation, the array size is not checked when constructed with pair().
An issue was discovered in the sized-chunks crate through 0.6.2 for Rust. In the InlineArray implementation, an unaligned reference may be generated for a type that has a large alignment requirement.
An issue was discovered in the sized-chunks crate through 0.6.2 for Rust. In the Chunk implementation, the array size is not checked when constructed with From<InlineArray<A, T>>.
An issue was discovered in the sized-chunks crate through 0.6.2 for Rust. In the Chunk implementation, insert_from can have a memory-safety issue upon a panic.
An issue was discovered in the sized-chunks crate through 0.6.2 for Rust. In the Chunk implementation, the array size is not checked when constructed with unit().
An issue was discovered in the sized-chunks crate through 0.6.2 for Rust. In the Chunk implementation, clone can have a memory-safety issue upon a panic.
",High,"['https://rustsec.org/advisories/RUSTSEC-2020-0041.html', 'https://nvd.nist.gov/vuln/detail/CVE-2020-25796', 'https://nvd.nist.gov/vuln/detail/CVE-2020-25795', 'https://nvd.nist.gov/vuln/detail/CVE-2020-25793', 'https://nvd.nist.gov/vuln/detail/CVE-2020-25794', 'https://nvd.nist.gov/vuln/detail/CVE-2020-25791', 'https://crates.io/crates/sized-chunks', 'https://nvd.nist.gov/vuln/detail/CVE-2020-25792', 'https://github.com/bodil/sized-chunks/issues/11', 'https://github.com/bodil/sized-chunks']"
GHSA-c3m3-c39q-pv23,slice-deque,https://github.com/gnzlbg/slice_deque,['Memory Access'],2021-08-19 21:23:28+00:00,2021-08-25T20:44:10Z,"[('0', '0.2.0'), ('0.0.0-0', '0.2.0')]","Bug in SliceDeque::move_head_unchecked corrupts its memory
Out of bounds write in slice-deque
","Affected versions of this crate entered a corrupted state if
`mem::size_of::<T>() % allocation_granularity() != 0` and a specific allocation
pattern was used: sufficiently shifting the deque elements over the mirrored
page boundary.

This allows an attacker that controls controls both element insertion and
removal to corrupt the deque, such that reading elements from it would read
bytes corresponding to other elements in the deque. (e.g. a read of T could read
some bytes from one value and some bytes from an adjacent one, resulting in a T
whose value representation is not meaningful). This is undefined behavior.
 
The flaw was corrected by using a pair of pointers to track the head and tail of
the deque instead of a pair of indices. This pair of pointers are represented
using a Rust slice.
An issue was discovered in the slice-deque crate before 0.2.0 for Rust. There is memory corruption in certain allocation cases.
",Critical,"['https://github.com/gnzlbg/slice_deque', 'https://github.com/gnzlbg/slice_deque/issues/57', 'https://crates.io/crates/slice-deque', 'https://rustsec.org/advisories/RUSTSEC-2019-0002.html', 'https://nvd.nist.gov/vuln/detail/CVE-2019-15543']"
RUSTSEC-2018-0008,slice-deque,https://github.com/gnzlbg/slice_deque,['Memory Access'],2021-10-19 22:14:35+00:00,2018-12-05T12:00:00Z,"[('0.0.0-0', '0.1.16'), ('0', '0.1.16')]","Memory corruption slice-deque
Bug in SliceDeque::move_head_unchecked allows read of corrupted memory
","An issue was discovered in the slice-deque crate before 0.1.16 for Rust. move_head_unchecked allows memory corruption because deque updates are mishandled.
Affected versions of this crate did not properly update the
head and tail of the deque when inserting and removing elements from the front
if, before insertion or removal, the tail of the deque was in the mirrored
memory region, and if, after insertion or removal, the head of the deque is
exactly at the beginning of the mirrored memory region.

An attacker that controls both element insertion and removal into the deque
could put it in a corrupted state. Once the deque enters such an state, its head
and tail are corrupted, but in bounds of the allocated memory. This can result
in partial reads and writes, reads of uninitialized memory, reads of memory
containing previously dropped objects, etc. An attacker could exploit this to
alter program execution.

The flaw was corrected by properly updating the head and tail of the deque in
this case.
",Critical,"['https://github.com/gnzlbg/slice_deque', 'https://github.com/gnzlbg/slice_deque/issues/57', 'https://rustsec.org/advisories/RUSTSEC-2018-0008.html', 'https://nvd.nist.gov/vuln/detail/CVE-2018-20995', 'https://crates.io/crates/slice-deque']"
RUSTSEC-2020-0158,slice-deque,https://github.com/gnzlbg/slice_deque,[],2021-11-18 14:04:01+00:00,2020-02-10T12:00:00Z,"[('0.0.0-0', None)]","slice-deque is unmaintained
","The author of the `slice-deque` crate is unresponsive and is not receiving security patches.

Maintained alternatives:

- [`slice-ring-buffer`](https://crates.io/crates/slice-ring-buffer)
",nan,"['https://github.com/gnzlbg/slice_deque/issues/94', 'https://rustsec.org/advisories/RUSTSEC-2020-0158.html', 'https://crates.io/crates/slice-deque']"
RUSTSEC-2021-0047,slice-deque,https://github.com/gnzlbg/slice_deque,['Memory Management'],2021-10-19 22:14:35+00:00,2021-02-19T12:00:00Z,"[('0.0.0-0', None)]","SliceDeque::drain_filter can double drop an element if the predicate panics
","Affected versions of the crate incremented the current index of the drain filter
iterator *before* calling the predicate function `self.pred`.

If the predicate function panics, it is possible for the last element in the
iterator to be dropped twice.
",High,"['https://rustsec.org/advisories/RUSTSEC-2021-0047.html', 'https://crates.io/crates/slice-deque', 'https://github.com/gnzlbg/slice_deque/issues/90']"
GHSA-p9gf-gmfv-398m,slice_deque,https://github.com/gnzlbg/slice_deque,['Memory Management'],2021-08-19 17:14:58+00:00,2021-08-25T20:54:16Z,"[('0', None)]","Double free in slice_deque
","An issue was discovered in the slice-deque crate through 2021-02-19 for Rust. A double drop can occur in SliceDeque::drain_filter upon a panic in a predicate function.
",High,"['https://rustsec.org/advisories/RUSTSEC-2021-0047.html', 'https://github.com/gnzlbg/slice_deque', 'https://nvd.nist.gov/vuln/detail/CVE-2021-29938', 'https://github.com/gnzlbg/slice_deque/issues/90']"
GHSA-83r8-p8v6-6gfm,slock,https://github.com/BrokenLamp/slock-rs,"['Synchronization', 'Memory Management', 'Tainted Input']",2021-08-06 17:28:42+00:00,2021-08-25T21:00:20Z,"[('0.0.0-0', None), ('0', None)]","Data races in slock
Slock<T> allows sending non-Send types across thread boundaries
Slock<T> allows sending non-Send types across thread boundaries
","An issue was discovered in the slock crate through 2020-11-17 for Rust. Slock<T> unconditionally implements Send and Sync.
`Slock<T>` unconditionally implements `Send`/`Sync`.

Affected versions of this crate allows sending non-Send types to other threads,
which can lead to data races and memory corruption due to the data race.
`Slock<T>` unconditionally implements `Send`/`Sync`.

Affected versions of this crate allows sending non-Send types to other threads,
which can lead to data races and memory corruption due to the data race.

",High,"['https://nvd.nist.gov/vuln/detail/CVE-2020-36455', 'https://github.com/BrokenLamp/slock-rs/issues/2', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/slock/RUSTSEC-2020-0135.md', 'https://rustsec.org/advisories/RUSTSEC-2020-0135.html', 'https://crates.io/crates/slock', 'https://github.com/BrokenLamp/slock-rs']"
RUSTSEC-2019-0009,smallvec,https://github.com/servo/rust-smallvec,['Memory Management'],2021-10-19 22:14:35+00:00,2019-06-06T12:00:00Z,"[('0', '0.6.10'), ('0.6.5', '0.6.10')]","Double free in smallvec
Double-free and use-after-free in SmallVec::grow()
","An issue was discovered in the smallvec crate before 0.6.10 for Rust. There is a double free for certain grow attempts with the current capacity.
Attempting to call `grow` on a spilled SmallVec with a value equal to the current capacity causes it to free the existing data. This performs a double free immediately and may lead to use-after-free on subsequent accesses to the SmallVec contents.

An attacker that controls the value passed to `grow` may exploit this flaw to obtain memory contents or gain remote code execution.

Credits to @ehuss for discovering, reporting and fixing the bug.
",Critical,"['https://rustsec.org/advisories/RUSTSEC-2019-0009.html', 'https://github.com/servo/rust-smallvec', 'https://nvd.nist.gov/vuln/detail/CVE-2019-15551', 'https://github.com/servo/rust-smallvec/issues/148', 'https://crates.io/crates/smallvec']"
GHSA-rxr4-x558-x7hw,smallvec,https://github.com/servo/rust-smallvec,['Memory Management'],2021-08-19 21:25:34+00:00,2021-08-25T20:42:54Z,"[('0', '0.6.3'), ('0.3.2', '0.3.4')]","Possible double free during unwinding in SmallVec::insert_many
Double free in smallvec
","If an iterator passed to `SmallVec::insert_many` panicked in `Iterator::next`,
destructors were run during unwinding while the vector was in an inconsistent
state, possibly causing a double free (a destructor running on two copies of
the same value).

This is fixed in smallvec 0.6.3 by ensuring that the vector's length is not
updated to include moved items until they have been removed from their
original positions.  Items may now be leaked if `Iterator::next` panics, but
they will not be dropped more than once.

Thank you to @Vurich for reporting this bug.
An issue was discovered in the smallvec crate before 0.6.3 for Rust. The Iterator implementation mishandles destructors, leading to a double free.
",Critical,"['https://github.com/servo/rust-smallvec', 'https://rustsec.org/advisories/RUSTSEC-2018-0003.html', 'https://nvd.nist.gov/vuln/detail/CVE-2018-20991', 'https://crates.io/crates/smallvec', 'https://github.com/servo/rust-smallvec/issues/96']"
GHSA-69gw-hgj3-45m7,smallvec,https://github.com/servo/rust-smallvec,"['Memory Access', 'Other', 'Memory Management']",2021-08-19 21:23:44+00:00,2021-08-25T20:43:58Z,"[('0', '0.6.10'), ('0.6.3', '0.6.10')]","Memory corruption in SmallVec::grow()
Memory corruption in smallvec
","Attempting to call `grow` on a spilled SmallVec with a value less than the current capacity causes corruption of memory allocator data structures.

An attacker that controls the value passed to `grow` may exploit this flaw to obtain memory contents or gain remote code execution.

Credits to @ehuss for discovering, reporting and fixing the bug.
An issue was discovered in the smallvec crate before 0.6.10 for Rust. There is memory corruption for certain grow attempts with less than the current capacity.
",Critical,"['https://nvd.nist.gov/vuln/detail/CVE-2019-15554', 'https://github.com/servo/rust-smallvec/issues/149', 'https://rustsec.org/advisories/RUSTSEC-2019-0012.html', 'https://github.com/servo/rust-smallvec', 'https://crates.io/crates/smallvec']"
RUSTSEC-2018-0018,smallvec,https://github.com/servo/rust-smallvec,"['Risky Values', 'Exception Management']",2020-10-02 01:29:11+00:00,2018-09-25T12:00:00Z,"[('0.0.0-0', '0.6.13'), ('0', '0.6.13')]","Use of Uninitialized Resource in smallvec
smallvec creates uninitialized value of any type
smallvec creates uninitialized value of any type
","An issue was discovered in the smallvec crate before 0.6.13 for Rust. It can create an uninitialized value of any type, including a reference type.
Affected versions of this crate called `mem::uninitialized()` to create values of a user-supplied type `T`.
This is unsound e.g. if `T` is a reference type (which must be non-null and thus may not remain uninitialized).
 
The flaw was corrected by avoiding the use of `mem::uninitialized()`, using `MaybeUninit` instead.

Affected versions of this crate called `mem::uninitialized()` to create values of a user-supplied type `T`.
This is unsound e.g. if `T` is a reference type (which must be non-null and thus may not remain uninitialized).
 
The flaw was corrected by avoiding the use of `mem::uninitialized()`, using `MaybeUninit` instead.
",High,"['https://github.com/servo/rust-smallvec/pull/162', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/smallvec/RUSTSEC-2018-0018.md', 'https://github.com/servo/rust-smallvec', 'https://nvd.nist.gov/vuln/detail/CVE-2018-25023', 'https://rustsec.org/advisories/RUSTSEC-2018-0018.html', 'https://crates.io/crates/smallvec', 'https://github.com/servo/rust-smallvec/issues/126']"
RUSTSEC-2021-0003,smallvec,https://github.com/servo/rust-smallvec,['Memory Management'],2021-10-19 22:14:35+00:00,2021-01-08T12:00:00Z,"[('0.6.3', '0.6.14')]","Buffer overflow in SmallVec::insert_many
","A bug in the `SmallVec::insert_many` method caused it to allocate a buffer that was smaller than needed.  It then wrote past the end of the buffer, causing a buffer overflow and memory corruption on the heap.

This bug was only triggered if the iterator passed to `insert_many` yielded more items than the lower bound returned from its `size_hint` method.
 
The flaw was corrected in smallvec 0.6.14 and 1.6.1, by ensuring that additional space is always reserved for each item inserted.  The fix also simplified the implementation of `insert_many` to use less unsafe code, so it is easier to verify its correctness.

Thank you to Yechan Bae (@Qwaz) and the Rust group at Georgia Techs SSLab for finding and reporting this bug.
",Critical,"['https://github.com/servo/rust-smallvec/issues/252', 'https://crates.io/crates/smallvec', 'https://rustsec.org/advisories/RUSTSEC-2021-0003.html']"
RUSTSEC-2020-0079,socket2,https://github.com/rust-lang/socket2,['Other'],2021-10-19 22:14:35+00:00,2020-11-06T12:00:00Z,"[('0.0.0-0', '0.3.16'), ('0', '0.3.16')]","socket2 invalidly assumes the memory layout of std::net::SocketAddr
`socket2` invalidly assumes the memory layout of std::net::SocketAddr
","The socket2 crate has assumed `std::net::SocketAddrV4` and `std::net::SocketAddrV6` have the same memory layout as the system C representation `sockaddr`. It has simply casted the pointers to convert the socket addresses to the system representation. The standard library does not say anything about the memory layout, and this will cause invalid memory access if the standard library changes the implementation. No warnings or errors will be emitted once the change happens.

The [`socket2`](https://crates.io/crates/socket2) crate has assumed `std::net::SocketAddrV4`
and `std::net::SocketAddrV6` have the same memory layout as the system C representation
`sockaddr`. It has simply casted the pointers to convert the socket addresses to the
system representation. The standard library does not say anything about the memory
layout, and this will cause invalid memory access if the standard library
changes the implementation. No warnings or errors will be emitted once the
change happens.
",Medium,"['https://rustsec.org/advisories/RUSTSEC-2020-0079.html', 'https://crates.io/crates/socket2', 'https://github.com/rust-lang/socket2-rs', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35920', 'https://github.com/rust-lang/socket2-rs/issues/119']"
GHSA-2wc6-2rcj-8v76,sodiumoxide,https://github.com/sodiumoxide/sodiumoxide,['Cryptography'],2021-08-05 21:10:47+00:00,2021-08-25T21:00:41Z,"[('0.0.0-0', '0.0.14'), ('0', '0.0.14')]","scalarmult() vulnerable to degenerate public keys
scalarmult() vulnerable to degenerate public keys
","The `scalarmult()` function included in previous versions of this crate
accepted all-zero public keys, for which the resulting Diffie-Hellman shared
secret will always be zero regardless of the private key used.

This issue was fixed by checking for this class of keys and rejecting them
if they are used.
The `scalarmult()` function included in previous versions of this crate
accepted all-zero public keys, for which the resulting Diffie-Hellman shared
secret will always be zero regardless of the private key used.

This issue was fixed by checking for this class of keys and rejecting them
if they are used.

",Medium,"['https://github.com/sodiumoxide/sodiumoxide/commit/24c7a5550807ac8a09648b5878f19d14c3a69135', 'https://rustsec.org/advisories/RUSTSEC-2017-0001.html', 'https://nvd.nist.gov/vuln/detail/CVE-2017-1000168', 'https://crates.io/crates/sodiumoxide', 'https://github.com/dnaq/sodiumoxide/issues/154', 'https://github.com/sodiumoxide/sodiumoxide']"
GHSA-wrvc-72w7-xpmj,sodiumoxide,https://github.com/sodiumoxide/sodiumoxide,['Other'],2021-08-19 21:20:40+00:00,2021-08-25T20:45:54Z,"[('0', '0.2.5'), ('0.0.0-0', '0.2.5')]","generichash::Digest::eq always return true
Incorrect Comparison in sodiumoxide
","PartialEq implementation for generichash::Digest has compared itself to itself.

Digest::eq always returns true and Digest::ne always returns false.
An issue was discovered in the sodiumoxide crate before 0.2.5 for Rust. generichash::Digest::eq compares itself to itself and thus has degenerate security properties.
",Critical,"['https://github.com/sodiumoxide/sodiumoxide/pull/381', 'https://github.com/sodiumoxide/sodiumoxide/pull/381/commits/fae052b834b097ced9a89a8fff8466e18f383070', 'https://rustsec.org/advisories/RUSTSEC-2019-0026.html', 'https://crates.io/crates/sodiumoxide', 'https://nvd.nist.gov/vuln/detail/CVE-2019-25002', 'https://github.com/sodiumoxide/sodiumoxide']"
GHSA-xwqr-xmgg-j69q,solana_rbpf,https://github.com/solana-labs/rbpf,['Risky Values'],2022-02-08 19:45:10+00:00,2022-01-28T22:59:28Z,"[('0.2.14', '0.2.17')]","Integer overflow in solana_rbpf
","From version 0.2.14 to 0.2.16 for Solana rBPF, function ""relocate"" in the file src/elf.rs has an integer overflow bug because the sym.st_value is read directly from ELF file without checking. If the sym.st_value is rather large, an integer overflow is triggered while calculating the variable ""addr"" via ""addr = (sym.st_value + refd_pa) as u64"";
",High,"['https://nvd.nist.gov/vuln/detail/CVE-2021-46102', 'https://blocksecteam.medium.com/new-integer-overflow-bug-discovered-in-solana-rbpf-7729717159ee', 'https://github.com/solana-labs/rbpf/pull/236', 'https://github.com/solana-labs/rbpf/releases/tag/v0.2.17', 'https://github.com/solana-labs/rbpf/pull/200', 'https://github.com/solana-labs/rbpf', 'https://github.com/solana-labs/rbpf/blob/c14764850f0b83b58aa013248eaf6d65836c1218/src/elf.rs#L609-L630']"
RUSTSEC-2019-0013,spin,https://github.com/mvdnes/spin-rs.git,['Synchronization'],2021-10-19 22:14:35+00:00,2019-08-27T12:00:00Z,"[('0.0.0-0', '0.5.2'), ('0', '0.5.2')]","Wrong memory orderings violates mutual exclusion in spin
Wrong memory orderings in RwLock potentially violates mutual exclusion
","An issue was discovered in the spin crate before 0.5.2 for Rust, when RwLock is used. Because memory ordering is mishandled, two writers can acquire the lock at the same time, violating mutual exclusion.
Wrong memory orderings inside the RwLock implementation allow for two writers to acquire the lock at the same time. The drop implementation used Ordering::Relaxed, which allows the compiler or CPU to reorder a mutable access on the locked data after the lock has been yielded.

Only users of the RwLock implementation are affected. Users of Once (including users of lazy_static with the `spin_no_std` feature enabled) are NOT affected.

On strongly ordered CPU architectures like x86, the only real way that this would lead to a memory corruption is if the compiler reorders an access after the lock is yielded, which is possible but in practice unlikely. It is a more serious issue on weakly ordered architectures such as ARM which, except in the presence of certain instructions, allow the hardware to decide which accesses are seen at what times. Therefore on an ARM system it is likely that using the wrong memory ordering would result in a memory corruption, even if the compiler itself doesn't reorder the memory accesses in a buggy way.

The flaw was corrected by https://github.com/mvdnes/spin-rs/pull/66.
",High,"['https://nvd.nist.gov/vuln/detail/CVE-2019-16137', 'https://github.com/mvdnes/spin-rs', 'https://github.com/mvdnes/spin-rs/issues/65', 'https://crates.io/crates/spin', 'https://rustsec.org/advisories/RUSTSEC-2019-0013.html']"
RUSTSEC-2021-0096,spirv_headers,https://github.com/gfx-rs/rspirv,[],2021-08-23 14:34:15+00:00,2021-08-16T12:00:00Z,"[('0.0.0-0', None)]","spirv_headers is unmaintained, use spirv instead
","Because of versioning issues; the `spirv_headers` crate is unmaintained. Use [spirv](https://crates.io/crates/spirv)
for parsing spirv files.
",nan,"['https://github.com/gfx-rs/rspirv/issues/197', 'https://crates.io/crates/spirv_headers', 'https://rustsec.org/advisories/RUSTSEC-2021-0096.html']"
RUSTSEC-2020-0042,stack,https://github.com/arcnmx/stack-rs,['Memory Access'],2021-10-19 22:14:35+00:00,2020-09-24T12:00:00Z,"[('0', '0.3.1'), ('0.0.0-0', '0.3.1')]","Out-of-bounds write in stack
Missing check in ArrayVec leads to out-of-bounds write.
","An issue was discovered in the stack crate before 0.3.1 for Rust. ArrayVec has an out-of-bounds write via element insertion.
ArrayVec::insert allows insertion of an element into the array object into the
specified index. Due to a missing check on the upperbound of this index, it is
possible to write out of bounds.
",Critical,"['https://nvd.nist.gov/vuln/detail/CVE-2020-35895', 'https://rustsec.org/advisories/RUSTSEC-2020-0042.html', 'https://github.com/arcnmx/stack-rs', 'https://github.com/arcnmx/stack-rs/issues/4', 'https://crates.io/crates/stack']"
RUSTSEC-2021-0033,stack_dst,https://github.com/thepowersgang/stack_dst-rs,"['Exception Management', 'Memory Management']",2021-10-19 22:14:35+00:00,2021-02-22T12:00:00Z,"[('0.0.0-0', '0.6.1'), ('0', '0.6.1')]","Drop of uninitialized memory in stack_dst
Double free in stack_dst
push_cloned can drop uninitialized memory or double free on panic
","Affected versions of stack_dst used a push_inner function that increased the internal length of the array and then called val.clone(). If the val.clone() call panics, the stack could drop an already dropped element or drop uninitialized memory. This issue was fixed in 2a4d538 by increasing the length of the array after elements are cloned.

An issue was discovered in the stack_dst crate before 0.6.1 for Rust. Because of the push_inner behavior, a double free can occur upon a val.clone() panic.
Affected versions of `stack_dst` used a `push_inner` function that increased
the internal length of the array and then called `val.clone()`.

If the `val.clone()` call panics, the stack could drop an already dropped
element or drop uninitialized memory.

This issue was fixed in `2a4d538` by increasing the length of the array after
elements are cloned.
",Critical,"['https://github.com/thepowersgang/stack_dst-rs/commit/2a4d538', 'https://crates.io/crates/stack_dst', 'https://github.com/thepowersgang/stack_dst-rs/commit/2a4d53809e3000f40085f2b229b6b1a33759881d', 'https://github.com/thepowersgang/stack_dst-rs/issues/5', 'https://github.com/thepowersgang/stack_dst-rs', 'https://nvd.nist.gov/vuln/detail/CVE-2021-28035', 'https://rustsec.org/advisories/RUSTSEC-2021-0033.html', 'https://nvd.nist.gov/vuln/detail/CVE-2021-28034']"
RUSTSEC-2021-0048,stackvector,https://github.com/Alexhuszagh/rust-stackvector,"['Memory Access', 'Memory Management']",2021-10-19 22:14:35+00:00,2021-02-19T12:00:00Z,"[('0.0.0-0', '1.0.9'), ('0', '1.0.9')]","Out of bounds write in stackvector
StackVec::extend can write out of bounds when size_hint is incorrect
","An issue was discovered in the stackvector crate before 1.0.9 for Rust. There is an out-of-bounds write in StackVec::extend if size_hint provides certain anomalous data.
`StackVec::extend` used the lower and upper bounds from an Iterator's
`size_hint` to determine how many items to push into the stack based vector.

If the `size_hint` implementation returned a lower bound that was larger than
the upper bound, `StackVec` would write out of bounds and overwrite memory
on the stack. As mentioned by the [size_hint](https://doc.rust-lang.org/std/iter/trait.Iterator.html#provided-methods)
documentation, `size_hint` is mainly for optimization and incorrect
implementations should not lead to memory safety issues.
",High,"['https://github.com/Alexhuszagh/rust-stackvector/issues/2', 'https://github.com/Alexhuszagh/rust-stackvector', 'https://crates.io/crates/stackvector', 'https://nvd.nist.gov/vuln/detail/CVE-2021-29939', 'https://rustsec.org/advisories/RUSTSEC-2021-0048.html']"
RUSTSEC-2022-0023,static_type_map,https://github.com/malobre/static_type_map,[],2022-05-11 19:44:11+00:00,2022-05-11T12:00:00Z,"[('0.0.0-0', None)]","`static_type_map` has been renamed to `erased_set`
","Please use the `erased_set` crate going forward:

<https://github.com/malobre/erased_set>

There will be no further releases of `static_type_map`.
",nan,"['https://github.com/malobre/erased_set/issues/6', 'https://crates.io/crates/static_type_map', 'https://rustsec.org/advisories/RUSTSEC-2022-0023.html']"
RUSTSEC-2020-0020,stb_truetype,https://gitlab.redox-os.org/redox-os/stb_truetype-rs,[],2020-10-02 01:29:11+00:00,2020-04-18T12:00:00Z,"[('0.0.0-0', None)]","`stb_truetype` crate has been deprecated; use `ttf-parser` instead
","This crate was maintained for use in rusttype which has switched to use [ttf-parser](https://crates.io/crates/ttf-parser)
",nan,"['https://gitlab.redox-os.org/redox-os/stb_truetype-rs/-/commit/f1f5be4794e87bfc80a4255bc3f23ed75dd77645', 'https://crates.io/crates/stb_truetype', 'https://rustsec.org/advisories/RUSTSEC-2020-0020.html']"
RUSTSEC-2020-0109,stderr,https://github.com/biluohc/stderr,[],2021-01-20 19:29:04+00:00,2020-12-22T12:00:00Z,"[('0.0.0-0', None)]","stderr is unmaintained; use eprintln instead
","The `stderr` crate is no longer maintained by its current owner. 

The author recommends using the `eprintln` macro from the standard library as a
replacement.
",nan,"['https://crates.io/crates/stderr', 'https://rustsec.org/advisories/RUSTSEC-2020-0109.html', 'https://github.com/biluohc/stderr/issues/5']"
RUSTSEC-2020-0056,stdweb,https://github.com/koute/stdweb,[],2020-10-25 18:57:46+00:00,2020-05-04T12:00:00Z,"[('0.0.0-0', '0.4.21-0')]","stdweb is unmaintained
","The author of the `stdweb` crate is unresponsive.

Maintained alternatives:

- [`wasm-bindgen`](https://github.com/rustwasm/wasm-bindgen)
- [`js-sys`](https://github.com/rustwasm/wasm-bindgen/tree/master/crates/js-sys)
- [`web-sys`](https://github.com/rustwasm/wasm-bindgen/tree/master/crates/web-sys)
",nan,"['https://crates.io/crates/stdweb', 'https://github.com/koute/stdweb/issues/403', 'https://rustsec.org/advisories/RUSTSEC-2020-0056.html']"
RUSTSEC-2020-0058,stream-cipher,https://github.com/RustCrypto/traits/tree/master/cipher,[],2020-10-25 19:14:03+00:00,2020-10-15T12:00:00Z,"[('0.0.0-0', None)]","crate has been renamed to `cipher`
","This crate has been renamed from `stream-cipher` to `cipher`.

The new repository location is at:

<https://github.com/RustCrypto/traits/tree/master/cipher>
",nan,"['https://github.com/RustCrypto/traits/pull/337', 'https://rustsec.org/advisories/RUSTSEC-2020-0058.html', 'https://crates.io/crates/stream-cipher']"
GHSA-39wr-f4ff-xm6p,streebog,https://github.com/RustCrypto/hashes,"['Cryptography', 'API']",2021-08-19 21:19:50+00:00,2021-08-25T20:46:41Z,"[('0.0.0-0', '0.8.0'), ('0', '0.8.0')]","Incorrect implementation of the Streebog hash functions
Incorrect implementation of the Streebog hash functions in streebog
Incorrect implementation in streebog
","Internal `update-sigma` function was implemented incorrectly and depending on
`debug-assertions` it could've caused an incorrect result or panic for certain
inputs.
An issue was discovered in the streebog crate before 0.8.0 for Rust. The Streebog hash function can produce the wrong answer.
An issue was discovered in the streebog crate before 0.8.0 for Rust. The Streebog hash function can cause a panic.
",nan,"['https://nvd.nist.gov/vuln/detail/CVE-2019-25006', 'https://crates.io/crates/streebog', 'https://rustsec.org/advisories/RUSTSEC-2019-0030.html', 'https://nvd.nist.gov/vuln/detail/CVE-2019-25007', 'https://github.com/RustCrypto/hashes/pull/91', 'https://github.com/RustCrypto/hashes/tree/master/streebog']"
RUSTSEC-2019-0023,string-interner,https://github.com/robbepop/string-interner,['Memory Access'],2021-10-19 22:14:35+00:00,2019-08-24T12:00:00Z,"[('0.0.0-0', '0.6.4'), ('0', '0.7.1')]","Use after free in string-interner
Cloned interners may read already dropped strings
","An issue was discovered in the string-interner crate before 0.7.1 for Rust. It allows attackers to read from memory locations associated with dangling pointers, because of a cloning flaw.
Affected versions of this crate did not clone contained strings when an interner is cloned.
Interners have raw pointers to the contained strings, and they keep pointing the strings which the old interner owns, after the interner is cloned.
If a new cloned interner is alive and the old original interner is dead, the new interner has dangling pointers to the old interner's storage, which is already dropped.

This allows an attacker to read the already freed memory.
The dangling pointers are used by the interners to check a string is already interned.
An attacker can do brute force attack to get the data pointed by the dangling pointer.

The flaw was corrected by <https://github.com/Robbepop/string-interner/pull/10>.
This patch implements `Clone` manually to the interner type, so that the internal raw pointers always point the strings owned by the same interner.

PR #10 was also backported to the 0.6 release line in
<https://github.com/Robbepop/string-interner/pull/14> and was released in 0.6.4.
",High,"['https://nvd.nist.gov/vuln/detail/CVE-2019-16882', 'https://rustsec.org/advisories/RUSTSEC-2019-0023.html', 'https://github.com/Robbepop/string-interner', 'https://crates.io/crates/string-interner', 'https://github.com/Robbepop/string-interner/issues/9']"
GHSA-r88h-6987-g79f,syncpool,https://github.com/Chopinsky/byte_buffer.git,"['Synchronization', 'Memory Management', 'Tainted Input']",2021-08-18 23:32:42+00:00,2021-08-25T21:00:28Z,"[('0.0.0-0', '0.1.6'), ('0', '0.1.6')]","Data race in syncpool
Send bound needed on T (for Send impl of `Bucket2`)
Data races on syncpool
","An issue was discovered in the syncpool crate before 0.1.6 for Rust. There is an unconditional implementation of Send for Bucket2.
Affected versions of this crate unconditionally implements `Send` for `Bucket2`. This allows sending non-Send types to other threads.

This can lead to data races when non Send types like `Cell<T>` or `Rc<T>` are contained inside `Bucket2` and sent across thread boundaries. The data races can potentially lead to memory corruption (as demonstrated in the PoC from the original report issue).

The flaw was corrected in commit 15b2828 by adding a `T: Send` bound to the `Send` impl of `Bucket2<T>`.
Affected versions of this crate unconditionally implements `Send` for `Bucket2`. This allows sending non-Send types to other threads.

This can lead to data races when non Send types like `Cell<T>` or `Rc<T>` are contained inside `Bucket2` and sent across thread boundaries. The data races can potentially lead to memory corruption (as demonstrated in the PoC from the original report issue).

The flaw was corrected in commit 15b2828 by adding a `T: Send` bound to the `Send` impl of `Bucket2<T>`.

",High,"['https://rustsec.org/advisories/RUSTSEC-2020-0142.html', 'https://github.com/Chopinsky/byte_buffer/issues/2', 'https://github.com/Chopinsky/byte_buffer/tree/master/syncpool', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/syncpool/RUSTSEC-2020-0142.md', 'https://github.com/RustSec/advisory-db/blob/main/crates/syncpool/RUSTSEC-2020-0142.md', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36462', 'https://crates.io/crates/syncpool']"
GHSA-2f5j-3mhq-xv58,sys-info,https://github.com/FillZpp/sys-info-rs,['Memory Management'],2021-08-18 20:16:40+00:00,2021-08-25T20:58:15Z,"[('0.0.0-0', '0.8.0'), ('0', '0.8.0')]","Double free when calling `sys_info::disk_info` from multiple threads
Double free in sys-info 
","Affected versions of `sys-info` use a static, global, list to store temporary disk information while running. The function that cleans up this list,
`DFCleanup`, assumes a single threaded environment and will try to free the same memory twice in a multithreaded environment.

This results in consistent double-frees and segfaults when calling `sys_info::disk_info` from multiple threads at once.

The issue was fixed by moving the global variable into a local scope.

## Safer Alternatives:
 - [`sysinfo`](https://crates.io/crates/sysinfo)
An issue was discovered in the sys-info crate before 0.8.0 for Rust. sys_info::disk_info calls can trigger a double free.
",Critical,"['https://rustsec.org/advisories/RUSTSEC-2020-0100.html', 'https://crates.io/crates/sys-info', 'https://github.com/FillZpp/sys-info-rs', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/sys-info/RUSTSEC-2020-0100.md', 'https://github.com/FillZpp/sys-info-rs/issues/63', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36434']"
GHSA-62jx-8vmh-4mcw,tar,https://github.com/alexcrichton/tar-rs,['Path Resolution'],2021-08-18 20:08:23+00:00,2021-08-25T20:58:23Z,"[('0.0.0-0', '0.4.36'), ('0', '0.4.36')]","Links in archive can create arbitrary directories
Path trav in tar
","When unpacking a tarball that contains a symlink the `tar` crate may create
directories outside of the directory it's supposed to unpack into.

The function errors when it's trying to create a file, but the folders are
already created at this point.

```rust
use std::{io, io::Result};
use tar::{Archive, Builder, EntryType, Header};

fn main() -> Result<()> {
    let mut buf = Vec::new();

    {
        let mut builder = Builder::new(&mut buf);

        // symlink: parent -> ..
        let mut header = Header::new_gnu();
        header.set_path(""symlink"")?;
        header.set_link_name("".."")?;
        header.set_entry_type(EntryType::Symlink);
        header.set_size(0);
        header.set_cksum();
        builder.append(&header, io::empty())?;

        // file: symlink/exploit/foo/bar
        let mut header = Header::new_gnu();
        header.set_path(""symlink/exploit/foo/bar"")?;
        header.set_size(0);
        header.set_cksum();
        builder.append(&header, io::empty())?;

        builder.finish()?;
    };

    Archive::new(&*buf).unpack(""demo"")
}
```

This has been fixed in https://github.com/alexcrichton/tar-rs/pull/259 and is
published as `tar` 0.4.36. Thanks to Martin Michaelis (@mgjm) for discovering
and reporting this, and Nikhil Benesch (@benesch) for the fix!
An issue was discovered in the tar crate before 0.4.36 for Rust. When symlinks are present in a TAR archive, extraction can create arbitrary directories via .. traversal.
",High,"['https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/tar/RUSTSEC-2021-0080.md', 'https://github.com/alexcrichton/tar-rs', 'https://nvd.nist.gov/vuln/detail/CVE-2021-38511', 'https://crates.io/crates/tar', 'https://github.com/alexcrichton/tar-rs/issues/238', 'https://rustsec.org/advisories/RUSTSEC-2021-0080.html']"
RUSTSEC-2018-0002,tar,https://github.com/alexcrichton/tar-rs,['Path Resolution'],2021-10-19 22:14:35+00:00,2018-06-29T12:00:00Z,"[('0.0.0-0', '0.4.16'), ('0', '0.4.16')]","Link following in tar
Links in archives can overwrite any existing file
","An issue was discovered in the tar crate before 0.4.16 for Rust. Arbitrary file overwrite can occur via a symlink or hardlink in a TAR archive.
When unpacking a tarball with the `unpack_in`-family of functions it's intended
that only files within the specified directory are able to be written. Tarballs
with hard links or symlinks, however, can be used to overwrite any file on the
filesystem.

Tarballs can contain multiple entries for the same file. A tarball which first
contains an entry for a hard link or symlink pointing to any file on the
filesystem will have the link created, and then afterwards if the same file is
listed in the tarball the hard link will be rewritten and any file can be
rewritten on the filesystem.

This has been fixed in https://github.com/alexcrichton/tar-rs/pull/156 and is
published as `tar` 0.4.16. Thanks to Max Justicz for discovering this and
emailing about the issue!
",High,"['https://nvd.nist.gov/vuln/detail/CVE-2018-20990', 'https://github.com/alexcrichton/tar-rs', 'https://crates.io/crates/tar', 'https://github.com/alexcrichton/tar-rs/pull/156', 'https://rustsec.org/advisories/RUSTSEC-2018-0002.html']"
RUSTSEC-2021-0112,tectonic_xdv,https://github.com/tectonic-typesetting/tectonic/,"['Memory Access', 'Exception Management']",2021-09-18 21:35:48+00:00,2021-02-17T12:00:00Z,"[('0', '0.1.12'), ('0.0.0-0', '0.1.12')]","Use of Uninitialized Resource in tectonic_xdv
`Read` on uninitialized buffer may cause UB ('tectonic_xdv' crate)
","An issue was discovered in the tectonic_xdv crate before 0.1.12 for Rust. XdvParser::<T>::process may read from uninitialized memory locations.
Affected versions of this crate passes an uninitialized buffer to a user-provided `Read` implementation.

Arbitrary `Read` implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer. Reading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.

The problem was fixed in commit `cdff034` by zero-initializing the buffer before passing it to a user-provided `Read` implementation.
",Critical,"['https://github.com/tectonic-typesetting/tectonic/issues/752', 'https://github.com/tectonic-typesetting/tectonic/', 'https://crates.io/crates/tectonic_xdv', 'https://rustsec.org/advisories/RUSTSEC-2021-0112.html', 'https://nvd.nist.gov/vuln/detail/CVE-2021-45703', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/tectonic_xdv/RUSTSEC-2021-0112.md']"
GHSA-hpcx-3pw8-g3j2,telemetry,https://github.com/Yoric/telemetry.rs,"['Memory Management', 'Exception Management']",2021-08-19 17:09:26+00:00,2021-08-25T20:54:22Z,"[('0.0.0-0', None), ('0', '0.1.3')]","misc::vec_with_size() can drop uninitialized memory if clone panics
Free of uninitialized memory in telemetry
","`misc::vec_with_size` creates a vector of the provided `size` and immediately
calls `vec.set_len(size)` on it, initially filling it with uninitialized memory.
It then inserts elements using `vec[i] = value.clone()`.

If the `value.clone()` call panics, uninitialized items in the vector will be
dropped leading to undefined behavior.
An issue was discovered in the telemetry crate through 0.1.2 for Rust. There is a drop of uninitialized memory if a value.clone() call panics within misc::vec_with_size().
",Critical,"['https://github.com/Yoric/telemetry.rs/issues/45', 'https://github.com/Yoric/telemetry.rs', 'https://rustsec.org/advisories/RUSTSEC-2021-0046.html', 'https://nvd.nist.gov/vuln/detail/CVE-2021-29937', 'https://github.com/Yoric/telemetry.rs/commit/2820cf12f2e08645fd6d1f15b4a90a54d6082a81', 'https://crates.io/crates/telemetry']"
RUSTSEC-2018-0015,term,https://github.com/Stebalien/term,[],2020-10-02 01:29:11+00:00,2018-11-19T12:00:00Z,"[('0.0.0-0', '0.6.2-0')]","term is looking for a new maintainer
","The author of the `term` crate does not have time to maintain it and is looking
for a new maintainer.

Some maintained alternatives you can potentially switch to instead, depending
on your needs:

- [`crossterm`](https://github.com/crossterm-rs/crossterm)
- [`termcolor`](https://crates.io/crates/termcolor)
- [`yansi`](https://crates.io/crates/yansi)
",nan,"['https://crates.io/crates/term', 'https://github.com/Stebalien/term/issues/93', 'https://rustsec.org/advisories/RUSTSEC-2018-0015.html']"
RUSTSEC-2020-0090,thex,https://github.com/krl/thex,"['Synchronization', 'Memory Management']",2021-10-19 22:14:35+00:00,2020-12-08T12:00:00Z,"[('0.0.0-0', None), ('0', None)]","Data races in thex
Thex<T> allows data races of non-Send types across threads
","An issue was discovered in the thex crate through 2020-12-08 for Rust. Thex<T> allows cross-thread data races of non-Send types.
`thex::Thex<T>` implements `Sync` for all types `T`. However, it is missing a
bound for `T: Send`.

This allows non-Send types such as `Rc` to be sent across thread boundaries
which can trigger undefined behavior and memory corruption.
",Medium,"['https://crates.io/crates/thex', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35927', 'https://rustsec.org/advisories/RUSTSEC-2020-0090.html']"
RUSTSEC-2022-0006,thread_local,https://github.com/Amanieu/thread_local-rs,['Memory Management'],2022-01-24 14:39:43+00:00,2022-01-23T12:00:00Z,"[('0.0.0-0', '1.1.4')]","Data race in `Iter` and `IterMut`
","In the affected version of this crate, `{Iter, IterMut}::next` used a weaker memory ordering when loading values than what was required, exposing a potential data race
when iterating over a `ThreadLocal`'s values.

Crates using `Iter::next`, or `IterMut::next` are affected by this issue.
",nan,"['https://crates.io/crates/thread_local', 'https://rustsec.org/advisories/RUSTSEC-2022-0006.html', 'https://github.com/Amanieu/thread_local-rs/issues/33']"
RUSTSEC-2021-0049,through,https://github.com/gretchenfrage/through,['Memory Management'],2021-10-19 22:14:35+00:00,2021-02-18T12:00:00Z,"[('0.0.0-0', None), ('0', None)]","Double free in through
`through` and `through_and` causes a double free if the map function panics
","An issue was discovered in the through crate through 2021-02-18 for Rust. There is a double free (in through and through_and) upon a panic of the map function.
`through` and `through_and` take a mutable reference as well as a mapping
function to change the provided reference. They do this by calling `ptr::read`
on the reference which duplicates ownership and then calling the mapping
function.

If the mapping function panics, both the original object and the one
duplicated by `ptr::read` get dropped, causing a double free.
",Critical,"['https://github.com/gretchenfrage/through/issues/1', 'https://nvd.nist.gov/vuln/detail/CVE-2021-29940', 'https://crates.io/crates/through', 'https://github.com/gretchenfrage/through', 'https://rustsec.org/advisories/RUSTSEC-2021-0049.html']"
RUSTSEC-2020-0010,tiberius,https://github.com/prisma/tiberius,[],2020-10-02 01:29:11+00:00,2020-02-28T12:00:00Z,"[('0.0.0-0', '0.3.3-0')]","tiberius is unmaintained
","The author of `tiberius` has archived the GitHub repository and left the
following note:

> I do not have the time to overhaul the library and do not intend to further
> maintain the 0.3 version relying on the old futures ecosystem.

Suggested alternatives are:

- [`odbc`](https://crates.io/crates/odbc)
- [`sqlx`](https://github.com/launchbadge/sqlx/issues/116) (forthcoming)
",nan,"['https://github.com/RustSec/advisory-db/issues/261', 'https://crates.io/crates/tiberius', 'https://rustsec.org/advisories/RUSTSEC-2020-0010.html']"
GHSA-gq4h-f254-7cw9,ticketed_lock,https://github.com/kvark/ticketed_lock/,"['Memory Access', 'Synchronization', 'Memory Management']",2021-08-18 23:35:09+00:00,2021-08-25T21:00:34Z,"[('0', '0.3.0'), ('0.0.0-0', '0.3.0')]","Data races in ticketed_lock
ReadTicket and WriteTicket should only be sendable when T is Send
Data races in ticketed_lock
","An issue was discovered in the ticketed_lock crate before 0.3.0 for Rust. There are unconditional implementations of Send for ReadTicket<T> and WriteTicket<T>.
Affected versions of this crate unconditionally implemented `Send` for `ReadTicket<T>` & `WriteTicket<T>`.
This allows to send non-Send `T` to other threads.

This can allows creating data races by cloning types with internal mutability and sending them to other threads (as `T` of `ReadTicket<T>`/`WriteTicket<T>`). Such data races can cause memory corruption or other undefined behavior.

The flaw was corrected in commit a986a93 by adding `T: Send` bounds to `Send` impls of `ReadTicket<T>`/`WriteTicket<T>`.
Affected versions of this crate unconditionally implemented `Send` for `ReadTicket<T>` & `WriteTicket<T>`.
This allows to send non-Send `T` to other threads.

This can allows creating data races by cloning types with internal mutability and sending them to other threads (as `T` of `ReadTicket<T>`/`WriteTicket<T>`). Such data races can cause memory corruption or other undefined behavior.

The flaw was corrected in commit a986a93 by adding `T: Send` bounds to `Send` impls of `ReadTicket<T>`/`WriteTicket<T>`.

",High,"['https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/ticketed_lock/RUSTSEC-2020-0119.md', 'https://rustsec.org/advisories/RUSTSEC-2020-0119.html', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36439', 'https://crates.io/crates/ticketed_lock', 'https://github.com/kvark/ticketed_lock/issues/7', 'https://github.com/kvark/ticketed_lock/', 'https://github.com/kvark/ticketed_lock/pull/8/commits/a986a9335d591fa5c826157d1674d47aa525357f']"
GHSA-wcg3-cvx6-7396,time,https://github.com/time-rs/time,['Memory Access'],2021-10-18 20:47:30+00:00,2021-08-25T20:56:46Z,"[('0.2.7', '0.2.23')]","Segmentation fault in time
","### Impact

Unix-like operating systems may segfault due to dereferencing a dangling pointer in specific circumstances. This requires an environment variable to be set in a different thread than the affected functions. This may occur without the user's knowledge, notably in a third-party library.

The affected functions from time 0.2.7 through 0.2.22 are:

- `time::UtcOffset::local_offset_at`
- `time::UtcOffset::try_local_offset_at`
- `time::UtcOffset::current_local_offset`
- `time::UtcOffset::try_current_local_offset`
- `time::OffsetDateTime::now_local`
- `time::OffsetDateTime::try_now_local`

The affected functions in time 0.1 (all versions) are:

- `at`
- `at_utc`
- `now`

Non-Unix targets (including Windows and wasm) are unaffected.

### Patches

Pending a proper fix, the internal method that determines the local offset has been modified to always return `None` on the affected operating systems. This has the effect of returning an `Err` on the `try_*` methods and `UTC` on the non-`try_*` methods.

Users and library authors with time in their dependency tree should perform `cargo update`, which will pull in the updated, unaffected code.

Users of time 0.1 do not have a patch and should upgrade to an unaffected version: time 0.2.23 or greater or the 0.3. series.

### Workarounds

No workarounds are known.

### References

time-rs/time#293
",Medium,"['https://rustsec.org/advisories/RUSTSEC-2020-0071.html', 'https://nvd.nist.gov/vuln/detail/CVE-2020-26235', 'https://github.com/time-rs/time/security/advisories/GHSA-wcg3-cvx6-7396', 'https://github.com/time-rs/time/issues/293', 'https://github.com/time-rs/time']"
GHSA-m296-j53x-xv95,tiny_future,https://github.com/KizzyCode/tiny_future,"['Memory Access', 'Synchronization', 'Memory Management']",2021-08-18 23:36:06+00:00,2021-08-25T21:00:32Z,"[('0.0.0-0', '0.4.0'), ('0', '0.4.0')]","Future<T> lacks bounds on Send and Sync.
Data race in tiny_future
Data races in tiny_future
","`tiny_future` contains a light-weight implementation of `Future`s. The `Future`
type it has lacked bound on its `Send` and `Sync` traits.

This allows for a bug where non-thread safe types such as `Cell` can be used in
`Future`s and cause data races in concurrent programs.

The flaw was corrected in commit `c791919` by adding trait bounds to `Future`'s
`Send` and `Sync`.
An issue was discovered in the tiny_future crate before 0.4.0 for Rust. Future<T> does not have bounds on its Send and Sync traits.
`tiny_future` contains a light-weight implementation of `Future`s. The `Future`
type it has lacked bound on its `Send` and `Sync` traits.

This allows for a bug where non-thread safe types such as `Cell` can be used in
`Future`s and cause data races in concurrent programs.

The flaw was corrected in commit `c791919` by adding trait bounds to `Future`'s
`Send` and `Sync`.

",High,"['https://crates.io/crates/tiny_future', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36438', 'https://github.com/KizzyCode/tiny_future', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/tiny_future/RUSTSEC-2020-0118.md', 'https://github.com/KizzyCode/tiny_future/issues/1', 'https://rustsec.org/advisories/RUSTSEC-2020-0118.html', 'https://github.com/KizzyCode/tiny_future/commit/c7919199a0f6d1ce0e3c33499d1b37f862c990e4', 'https://github.com/KizzyCode/tiny_future/commit/7ab8a264980d23c2ed64e72f4636f38b7381eb39']"
RUSTSEC-2020-0031,tiny_http,https://github.com/tiny-http/tiny-http,['Tainted Input'],2021-10-19 22:14:35+00:00,2020-06-16T12:00:00Z,"[('0.0.0-0', '0.6.3'), ('0', '0.8.0')]","HTTP Request smuggling in tiny_http
HTTP Request smuggling through malformed Transfer Encoding headers
","An issue was discovered in the tiny_http crate through 2020-06-16 for Rust. HTTP Request smuggling can occur via a malformed Transfer-Encoding header.
HTTP pipelining issues and request smuggling attacks are possible due to incorrect 
Transfer encoding header parsing.

It is possible conduct HTTP request smuggling attacks (CL:TE/TE:TE) by sending invalid Transfer Encoding headers. 

By manipulating the HTTP response the attacker could poison a web-cache, perform an XSS attack, or obtain sensitive information 
from requests other than their own.
",Medium,"['https://github.com/tiny-http/tiny-http', 'https://github.com/tiny-http/tiny-http/issues/173', 'https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/VO6SRTCEPEYO2OX647I3H5XUWLFDRDWL/', 'https://rustsec.org/advisories/RUSTSEC-2020-0031.html', 'https://crates.io/crates/tiny_http', 'https://github.com/tiny-http/tiny-http/pull/190', 'https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/M3JDNRE5RXJOWZZZF5QSCG4GUCSLTHF2/', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35884']"
RUSTSEC-2021-0072,tokio,https://github.com/tokio-rs/tokio,"['Synchronization', 'Memory Management']",2021-11-06 20:37:35+00:00,2021-07-07T12:00:00Z,"[('1.8.0', '1.8.1'), ('0.3.0', '1.5.1'), ('1.7.0', '1.7.2'), ('1.6.0', '1.6.3')]","Race condition in tokio
Task dropped in wrong thread when aborting `LocalSet` task
","An issue was discovered in the tokio crate before 1.8.1 for Rust. Upon a JoinHandle::abort, a Task may be dropped in the wrong thread.
When aborting a task with `JoinHandle::abort`, the future is dropped in the
thread calling abort if the task is not currently being executed. This is
incorrect for tasks spawned on a `LocalSet`.

This can easily result in race conditions as many projects use `Rc` or `RefCell`
in their Tokio tasks for better performance.

See [tokio#3929][issue] for more details.

[issue]: https://github.com/tokio-rs/tokio/issues/3929
",Medium,"['https://crates.io/crates/tokio', 'https://nvd.nist.gov/vuln/detail/CVE-2021-38191', 'https://github.com/tokio-rs/tokio/issues/3929', 'https://rustsec.org/advisories/RUSTSEC-2021-0072.html', 'https://github.com/tokio-rs/tokio', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/tokio/RUSTSEC-2021-0072.md']"
GHSA-fg7r-2g4j-5cgr,tokio,https://github.com/tokio-rs/tokio,"['Synchronization', 'Memory Management']",2022-01-07 18:26:27+00:00,2022-01-06T22:04:37Z,"[('0', '1.8.4'), ('0.1.14', '1.8.4'), ('1.9.0', '1.13.1')]","Data race when sending and receiving after closing a `oneshot` channel
Race Condition in tokio
","If a `tokio::sync::oneshot` channel is closed (via the
[`oneshot::Receiver::close`] method), a data race may occur if the
`oneshot::Sender::send` method is called while the corresponding
`oneshot::Receiver` is `await`ed or calling `try_recv`.

When these methods are called concurrently on a closed channel, the two halves
of the channel can concurrently access a shared memory location, resulting in a
data race. This has been observed to [cause memory corruption][corruption].

Note that the race only occurs when **both** halves of the channel are used
after the `Receiver` half has called `close`. Code where `close` is not used, or where the
`Receiver` is not `await`ed and `try_recv` is not called after calling `close`,
is not affected.

See [tokio#4225][issue] for more details.

[corruption]: https://github.com/tokio-rs/tokio/issues/4225#issuecomment-967434847
[issue]: https://github.com/tokio-rs/tokio/issues/4225
[`oneshot::Receiver::close`]: https://docs.rs/tokio/1.14.0/tokio/sync/oneshot/struct.Receiver.html#method.close
An issue was discovered in the tokio crate before 1.8.4, and 1.9.x through 1.13.x before 1.13.1, for Rust. In certain circumstances involving a closed oneshot channel, there is a data race and memory corruption.
",nan,"['https://crates.io/crates/tokio', 'https://nvd.nist.gov/vuln/detail/CVE-2021-45710', 'https://github.com/tokio-rs/tokio', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/tokio/RUSTSEC-2021-0124.md', 'https://github.com/tokio-rs/tokio/issues/4225', 'https://rustsec.org/advisories/RUSTSEC-2021-0124.html']"
RUSTSEC-2020-0162,tokio-proto,https://github.com/tokio-rs/tokio-proto,[],2022-02-07 02:25:36+00:00,2020-02-06T12:00:00Z,"[('0.0.0-0', None)]","`tokio-proto` is deprecated/unmaintained
","The [`tokio-proto`](https://crates.io/crates/tokio-proto) crate has been deprecated, and [its GitHub repository](https://github.com/tokio-rs/tokio-proto) has been archived.
Users may be interested in [`tokio-tower`](https://crates.io/crates/tokio-tower) instead, per https://github.com/tokio-rs/tokio/issues/118#issuecomment-452969665
",nan,"['https://crates.io/crates/tokio-proto', 'https://rustsec.org/advisories/RUSTSEC-2020-0162.html', 'https://github.com/tokio-rs/tokio-proto/commit/56c720ea3c74efa8f39e36c24e609628222b16a1']"
RUSTSEC-2020-0019,tokio-rustls,https://github.com/tokio-rs/tls,['Resource Management'],2021-10-19 22:14:35+00:00,2020-05-19T12:00:00Z,"[('0.13.0', '0.13.1'), ('0.12.0', '0.12.3')]","Excessive memory usage in tokio-rustls
tokio-rustls reads may cause excessive memory usage
","An issue was discovered in the tokio-rustls crate before 0.13.1 for Rust. Excessive memory usage may occur when data arrives quickly.
`tokio-rustls` does not call `process_new_packets` immediately after `read`,
so the expected termination condition `wants_read` always returns true.
As long as new incoming data arrives faster than it is processed
and the reader does not return pending, data will be buffered.

This may cause DoS.
",High,"['https://github.com/tokio-rs/tls', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35875', 'https://crates.io/crates/tokio-rustls', 'https://rustsec.org/advisories/RUSTSEC-2020-0019.html', 'https://github.com/tokio-rs/tls/pull/14']"
GHSA-xm9m-2vj8-fmfr,toodee,https://github.com/antonmarsden/toodee,"['Exception Management', 'Memory Management']",2021-08-30 21:56:39+00:00,2021-09-01T18:30:40Z,"[('0', '0.3.0'), ('0.0.0-0', '0.3.0')]","Double free in toodee
Multiple memory safety issues in insert_row
Uninitialized memory access in toodee
","An issue was discovered in the toodee crate before 0.3.0 for Rust. Row insertion can cause a double free upon an iterator panic.
When inserting rows from an iterator at a particular index, `toodee` would shift
items over, duplicating their ownership. The space reserved for the new elements
was based on the `len()` returned by the `ExactSizeIterator`.

This could result in elements in the array being freed twice if the iterator
panics. Uninitialized or previously freed elements could also be exposed if the
`len()` didn't match the number of elements.

These issues were fixed in commit `ced70c17` by temporarily setting the length
of the array smaller while processing it and adding assertions on the number
of elements returned by the iterator.
An issue was discovered in the toodee crate before 0.3.0 for Rust. The row-insertion feature allows attackers to read the contents of uninitialized memory locations.
",Critical,"['https://nvd.nist.gov/vuln/detail/CVE-2021-28028', 'https://rustsec.org/advisories/RUSTSEC-2021-0028.html', 'https://nvd.nist.gov/vuln/detail/CVE-2021-28029', 'https://crates.io/crates/toodee', 'https://github.com/antonmarsden/toodee/issues/13', 'https://github.com/antonmarsden/toodee']"
GHSA-2r6q-6c8c-g762,toolshed,https://github.com/ratel-rust/toolshed,"['Synchronization', 'Memory Management', 'Tainted Input']",2021-08-18 20:21:02+00:00,2021-08-25T20:58:03Z,"[('0.0.0-0', None), ('0', None)]","CopyCell lacks bounds on its Send trait allowing for data races
Data races in toolshed
","`CopyCell<T>` is a `Cell`-like type that is implemented for any type `T` that
is `Copy`able. It's `Send` trait has no bounds on the contained type.

As not all `Copy`able types are thread safe, for example non-mutable references
implement the `Copy` trait, it is possible to send references to types with
interior mutability such as `Cell` across threads and cause data races.
An issue was discovered in the toolshed crate through 2020-11-15 for Rust. In CopyCell<T>, the Send trait lacks bounds on the contained type.
",High,"['https://github.com/ratel-rust/toolshed/issues/12', 'https://rustsec.org/advisories/RUSTSEC-2020-0136.html', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36456', 'https://crates.io/crates/toolshed', 'https://github.com/ratel-rust/toolshed']"
RUSTSEC-2022-0018,totp-rs,https://github.com/constantoine/totp-rs,['Cryptography'],2022-05-09 18:08:13+00:00,2022-05-09T12:00:00Z,"[('0.0.0-0', '1.1.0')]","Timing attack
","Affecting versions did not compare tokens in constant time, which could make it possible for an attacker to guess the 2fa token of a user.

This has been fixed by using using the crate constant_time_eq for comparison.
",Medium,"['https://rustsec.org/advisories/RUSTSEC-2022-0018.html', 'https://github.com/constantoine/totp-rs/security/advisories/GHSA-8vxv-2g8p-2249', 'https://crates.io/crates/totp-rs']"
RUSTSEC-2020-0024,tough,https://github.com/awslabs/tough,['Cryptography'],2021-10-19 22:14:35+00:00,2020-07-09T12:00:00Z,"[('0.0.0-0', '0.7.1'), ('0', '0.7.1')]","Improper verification of signature threshold in tough
Improper uniqueness verification of signature threshold
","## Impact

The tough library, prior to 0.7.1, does not properly verify the uniqueness of keys in the signatures provided to meet the threshold of cryptographic signatures. It allows someone with access to a valid signing key to create multiple valid signatures in order to circumvent TUF requiring a minimum threshold of unique keys before the metadata is considered valid.

AWS would like to thank Erick Tryzelaar of the Google Fuchsia Team for reporting this issue. 

## Patches

A fix is available in version 0.7.1.

## Workarounds

No workarounds to this issue are known.

## References

CVE-2020-6174 is assigned to the same issue in the TUF reference implementation.

https://github.com/theupdateframework/tuf/pull/974
https://nvd.nist.gov/vuln/detail/CVE-2020-6174

## For more information

If you have any questions or comments about this advisory, [contact AWS Security](https://aws.amazon.com/security/vulnerability-reporting/) at [aws-security@amazon.com](mailto:aws-security@amazon.com).
The tough library, prior to 0.7.1, does not properly verify the uniqueness of
keys in the signatures provided to meet the threshold of cryptographic
signatures. It allows someone with access to a valid signing key to create
multiple valid signatures in order to circumvent TUF requiring a minimum
threshold of unique keys before the metadata is considered valid.

AWS would like to thank Erick Tryzelaar of the Google Fuchsia Team for
reporting this issue.

A fix is available in version 0.7.1.

CVE-2020-6174 is assigned to the same issue in the TUF reference
implementation.

If you have any questions or comments about this advisory, contact AWS Security
at aws-security@amazon.com.
",High,"['https://github.com/awslabs/tough/security/advisories/GHSA-5q2r-92f9-4m49', 'https://github.com/theupdateframework/tuf/commit/2977188139d065ff3356c3cb4aec60c582b57e0e', 'https://github.com/awslabs/tough', 'https://crates.io/crates/tough', 'https://github.com/theupdateframework/tuf/pull/974', 'https://nvd.nist.gov/vuln/detail/CVE-2020-15093', 'https://rustsec.org/advisories/RUSTSEC-2020-0024.html']"
GHSA-r56q-vv3c-6g9c,tough,https://github.com/awslabs/tough,['Path Resolution'],2021-10-19 18:06:09+00:00,2021-10-19T20:16:26Z,"[('0', '0.12.0')]","Improper sanitization of delegated role names
","### Impact
The tough library, prior to 0.12.0, does not properly sanitize delegated role names when caching a repository, or when loading a repository from the filesystem. When the repository is cached or loaded, files ending with the .json extension could be overwritten with role metadata anywhere on the system.

AWS would like to thank https://github.com/jku for reporting this issue.

### Patches
A fix is available in version 0.12.0.

### Workarounds
No workarounds to this issue are known.

### References
https://github.com/theupdateframework/python-tuf/security/advisories/GHSA-wjw6-2cqr-j4qr 

",High,"['https://github.com/awslabs/tough', 'https://github.com/awslabs/tough/security/advisories/GHSA-r56q-vv3c-6g9c', 'https://github.com/awslabs/tough/commit/1809b9bd1106d78a51fbea3071aa97a3530bac9a', 'https://nvd.nist.gov/vuln/detail/CVE-2021-41150', 'https://github.com/theupdateframework/python-tuf/security/advisories/GHSA-wjw6-2cqr-j4qr ']"
GHSA-x3r5-q6mj-m485,tough,https://github.com/awslabs/tough,['Path Resolution'],2021-10-19 18:04:34+00:00,2021-10-19T20:16:15Z,"[('0', '0.12.0')]","Improper sanitization of target names
","### Impact
The tough library, prior to 0.12.0, does not properly sanitize target names when caching a repository, or when saving specific targets to an output directory. When targets are cached or saved, files could be overwritten with arbitrary content anywhere on the system.

AWS would like to thank https://github.com/jku for reporting this issue.

### Patches
A fix is available in version 0.12.0.

### Workarounds
No workarounds to this issue are known.

",High,"['https://nvd.nist.gov/vuln/detail/CVE-2021-41149', 'https://github.com/awslabs/tough/commit/1809b9bd1106d78a51fbea3071aa97a3530bac9a', 'https://github.com/awslabs/tough', 'https://github.com/awslabs/tough/security/advisories/GHSA-x3r5-q6mj-m485']"
RUSTSEC-2021-0135,tower-http,https://github.com/tower-rs/tower-http,['Path Resolution'],2022-01-22 15:22:46+00:00,2021-01-21T12:00:00Z,"[('0.0.0-0', '0.1.3')]","Improper validation of Windows paths could lead to directory traversal attack
","`tower_http::services::fs::ServeDir` didn't correctly validate Windows paths
meaning paths like `/foo/bar/c:/windows/web/screen/img101.png` would be allowed
and respond with the contents of `c:/windows/web/screen/img101.png`. Thus users
could potentially read files anywhere on the filesystem.

This only impacts Windows. Linux and other unix likes are not impacted by this.

See [tower-http#204] for more details.

[tower-http#204]: https://github.com/tower-rs/tower-http/pull/204
",nan,"['https://rustsec.org/advisories/RUSTSEC-2021-0135.html', 'https://github.com/tower-rs/tower-http/pull/204', 'https://crates.io/crates/tower-http']"
GHSA-j79j-cx3h-g27h,traitobject,https://github.com/reem/rust-traitobject.git,"['Memory Access', 'Memory Management']",2021-08-19 21:07:57+00:00,2021-08-25T20:48:02Z,"[('0.0.0-0', None), ('0', None)]","traitobject assumes the layout of fat pointers
Out of bounds write in traitobject
","This crate gets the data pointer from fat pointers assuming that the first
element in a fat pointer is the data pointer. This is currently true, but
it may change in a future Rust version, leading to memory corruption.

This has been fixed in the master branch of the crate, but is has not
been released into crates.io.
An issue was discovered in the traitobject crate through 2020-06-01 for Rust. It has false expectations about fat pointers, possibly causing memory corruption in, for example, Rust 2.x.
",Critical,"['https://crates.io/crates/traitobject', 'https://rustsec.org/advisories/RUSTSEC-2020-0027.html', 'https://github.com/reem/rust-traitobject/issues/7', 'https://github.com/reem/rust-traitobject', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35881']"
RUSTSEC-2021-0111,tremor-script,https://github.com/tremor-rs/tremor-runtime,"['Memory Access', 'Memory Management']",2021-09-18 18:10:57+00:00,2021-09-16T12:00:00Z,"[('0', '0.11.6'), ('0.7.3-0', '0.11.6')]","Use After Free in tremor-script
Use After Free in tremor-script
Memory Safety Issue when using `patch` or `merge` on `state` and assign the result back to `state`
","An issue was discovered in the tremor-script crate before 0.11.6 for Rust. A merge operation may result in a use-after-free.
An issue was discovered in the tremor-script crate before 0.11.6 for Rust. A patch operation may result in a use-after-free.
Affected versions of this crate maintains references to memory that might have been freed already.
If affects the following two `tremor-script` language constructs:

* A [Merge](https://www.tremor.rs/docs/tremor-script/index#merge) where we assign the result back to the target expression
  and the expression to be merged needs to reference the `event`:

```
let state = merge state of event end;
```

* A [Patch](https://www.tremor.rs/docs/tremor-script/index#patch) where we assign the result back to the target expression
  and the patch operations used need to reference the `event`:

```
let state = patch state of insert event.key => event.value end;
```

For constructs like this (it doesnt matter what is references in the expression to be merged or the patch operations) an optimization
was applied to manipulate the target value in-place, instead of cloning it.

Our `Value` struct which underpins all event data in `tremor-script`, is representing as borrowed strings `beef::Cow<'lifetime, str>` 
that reference the actual `Vec<u8>` the event is based upon. We keep the raw byte-array next to the event structure inside our `Event` struct as a self-referential struct,
so we make sure that the structured `Value` and its references are valid across its whole lifetime.

The optimization was considered safe as long as it was only possible to merge or patche `event` data or static data.
When `state` was introduced to `tremor-script` a new possibility existed, to keep `Value` data around for longer than the lifetime of an event.
If `event` data is merged or patched into `state` without cloning `state` first, it can still reference keys or values from
the previous event, which will now be invalid. This allows access to those already freed regions of memory and to get their content out over the wire.


## Workaround

If an upgrade is not possible, a possible workaround is to avoid the optimization
by introducing a temporary variable and not immediately reassigning to `state`:

```
let tmp = merge state of event end;
let state = tmp
```

## Fix

The flaw was corrected in `tremor-script` version 0.11.6 via commit [1a2efcd](https://github.com/tremor-rs/tremor-runtime/commit/1a2efcdbe68e5e7fd0a05836ac32d2cde78a0b2e) by removing the optimization
and always clone the target expression of a [Merge](https://www.tremor.rs/docs/tremor-script/index#merge) or [Patch](https://www.tremor.rs/docs/tremor-script/index#patch.
",High,"['https://nvd.nist.gov/vuln/detail/CVE-2021-45701', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/tremor-script/RUSTSEC-2021-0111.md', 'https://rustsec.org/advisories/RUSTSEC-2021-0111.html', 'https://crates.io/crates/tremor-script', 'https://github.com/tremor-rs/tremor-runtime/pull/1217', 'https://nvd.nist.gov/vuln/detail/CVE-2021-45702']"
RUSTSEC-2021-0029,truetype,https://github.com/bodoni/truetype,"['Memory Access', 'Exception Management']",2021-10-19 22:14:35+00:00,2021-02-17T12:00:00Z,"[('0.0.0-0', '0.30.1'), ('0', '0.30.1')]"," Use of Uninitialized Resource in truetype
Tape::take_bytes exposes uninitialized memory to a user-provided Read
","An issue was discovered in the truetype crate before 0.30.1 for Rust. Attackers can read the contents of uninitialized memory locations via a user-provided Read operation within Tape::take_bytes.
Affected versions of this crate passed an unininitialized buffer to a
user-provided `Read` instance in `Tape::take_bytes`.

This can result in safe `Read` implementations reading from the uninitialized
buffer leading to undefined behavior.

The flaw was corrected in commit `1f2dc7f37dd` by removing the unsafe block
and zero-initializing the buffer.
",High,"['https://github.com/bodoni/truetype', 'https://crates.io/crates/truetype', 'https://nvd.nist.gov/vuln/detail/CVE-2021-28030', 'https://rustsec.org/advisories/RUSTSEC-2021-0029.html', 'https://github.com/bodoni/truetype/issues/11']"
RUSTSEC-2018-0007,trust-dns-proto,https://github.com/bluejekyll/trust-dns,['Resource Management'],2021-10-19 22:14:35+00:00,2018-10-09T12:00:00Z,"[('0.0.0-0', '0.4.3'), ('0', '0.4.3')]","Uncontrolled recursion in trust-dns-proto
Stack overflow when parsing malicious DNS packet
","An issue was discovered in the trust-dns-proto crate before 0.5.0-alpha.3 for Rust. There is infinite recursion because DNS message compression is mishandled.
There's a stack overflow leading to a crash when Trust-DNS's parses a
malicious DNS packet.

Affected versions of this crate did not properly handle parsing of DNS message
compression (RFC1035 section 4.1.4). The parser could be tricked into infinite
loop when a compression offset pointed back to the same domain name to be
parsed.

This allows an attacker to craft a malicious DNS packet which when consumed
with Trust-DNS could cause stack overflow and crash the affected software.

The flaw was corrected by trust-dns-proto 0.4.3 and upcoming 0.5.0 release.
",High,"['https://github.com/bluejekyll/trust-dns', 'https://nvd.nist.gov/vuln/detail/CVE-2018-20994', 'https://crates.io/crates/trust-dns-proto', 'https://rustsec.org/advisories/RUSTSEC-2018-0007.html']"
GHSA-4cww-f7w5-x525,trust-dns-server,https://github.com/bluejekyll/trust-dns,['Resource Management'],2021-08-19 21:20:03+00:00,2021-08-25T20:46:13Z,"[('0', '0.18.1'), ('0.16.0', '0.18.1')]","Stack overflow when resolving additional records from MX or SRV null targets
Stack consumption in trust-dns-server
","There's a stack overflow leading to a crash and potential DOS when processing
additional records for return of MX or SRV record types from the server.

This is only possible when a zone is configured with a null target for MX or SRV records, i.e. '.'.

Example effected zone record:
```text
no-service 86400 IN MX 0 .
```

Prior to 0.16.0 the additional record processing was not supported by trust-dns-server. There
Are no known issues with upgrading from 0.16 or 0.17 to 0.18.1. The remidy should be to upgrade to
0.18.1. If unable to do so, MX, SRV or other record types with a target to the null type, should be avoided.
An issue was discovered in the trust-dns-server crate before 0.18.1 for Rust. DNS MX and SRV null targets are mishandled, causing stack consumption.
",High,"['https://nvd.nist.gov/vuln/detail/CVE-2020-35857', 'https://rustsec.org/advisories/RUSTSEC-2020-0001.html', 'https://github.com/bluejekyll/trust-dns/issues/980', 'https://github.com/bluejekyll/trust-dns', 'https://crates.io/crates/trust-dns-server']"
RUSTSEC-2020-0087,try-mutex,https://github.com/mpdn/try-mutex,"['Memory Access', 'Synchronization']",2021-10-19 22:14:35+00:00,2020-11-17T12:00:00Z,"[('0', '0.3.0'), ('0.0.0-0', '0.3.0')]","Data races in try-mutex
TryMutex<T> allows sending non-Send type across threads
","An issue was discovered in the try-mutex crate before 0.3.0 for Rust. TryMutex<T> allows cross-thread sending of a non-Send type.
Affected versions of this crate unconditionally implemented Sync trait for `TryMutex<T>` type.

This allows users to put non-Send `T` type in `TryMutex` and send it to another thread, which can cause a data race.

The flaw was corrected in the 0.3.0 release by adding `T: Send` bound for the Sync trait implementation.
",Medium,"['https://rustsec.org/advisories/RUSTSEC-2020-0087.html', 'https://github.com/mpdn/try-mutex/issues/2', 'https://nvd.nist.gov/vuln/detail/CVE-2020-35924', 'https://github.com/mpdn/try-mutex', 'https://crates.io/crates/try-mutex']"
GHSA-686f-ch3r-xwmh,unicycle,https://github.com/udoprog/unicycle,"['Memory Access', 'Synchronization', 'Memory Management']",2021-08-24 17:47:59+00:00,2021-08-25T20:58:17Z,"[('0.0.0-0', '0.7.1'), ('0', '0.7.1')]","PinSlab<T> and Unordered<T, S> need bounds on their Send/Sync traits
Data races in unicycle
","Affected versions of this crate unconditionally implemented `Send` & `Sync` for types `PinSlab<T>` & `Unordered<T, S>`. This allows sending non-Send types to other threads and concurrently accessing non-Sync types from multiple threads.

This can result in a data race & memory corruption when types that provide internal mutability without synchronization are contained within `PinSlab<T>` or `Unordered<T, S>` and accessed concurrently from multiple threads.

The flaw was corrected in commits 92f40b4 & 6a6c367 by adding trait bound `T: Send` to `Send` impls for `PinSlab<T>` & `Unordered<T, S>` and adding `T: Sync` to `Sync` impls for `PinSlab<T>` & `Unordered<T, S>`.
Affected versions of this crate unconditionally implemented `Send` & `Sync` for types `PinSlab<T>` & `Unordered<T, S>`. This allows sending non-Send types to other threads and concurrently accessing non-Sync types from multiple threads.

This can result in a data race & memory corruption when types that provide internal mutability without synchronization are contained within `PinSlab<T>` or `Unordered<T, S>` and accessed concurrently from multiple threads.

The flaw was corrected in commits 92f40b4 & 6a6c367 by adding trait bound `T: Send` to `Send` impls for `PinSlab<T>` & `Unordered<T, S>` and adding `T: Sync` to `Sync` impls for `PinSlab<T>` & `Unordered<T, S>`.
",High,"['https://github.com/udoprog/unicycle/commit/92f40b4a2c671553dfa96feacff0265206c44ce5', 'https://github.com/udoprog/unicycle/commit/6a6c367a0c25f86f998fa315ea90c328f685b194', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36436', 'https://crates.io/crates/unicycle', 'https://rustsec.org/advisories/RUSTSEC-2020-0116.html', 'https://github.com/udoprog/unicycle/issues/8', 'https://github.com/udoprog/unicycle']"
GHSA-wq8f-46ww-6c2h,untrusted,https://github.com/briansmith/untrusted,['Risky Values'],2021-08-19 21:24:20+00:00,2021-08-25T20:43:49Z,"[('0', '0.6.2'), ('0.0.0-0', '0.6.2')]","An integer underflow could lead to panic
Integer underflow in untrusted
","A mistake in error handling in untrusted before 0.6.2 could lead to an integer
underflow and panic if a user of the crate didn't properly check for errors
returned by untrusted.

Combination of these two programming errors (one in untrusted and another by
user of this crate) could lead to a panic and maybe a denial of service of
affected software.

The error in untrusted is fixed in release 0.6.2 released 2018-06-21. It's also
advisable that users of untrusted check for their sources for cases where errors
returned by untrusted are not handled correctly.
An issue was discovered in the untrusted crate before 0.6.2 for Rust. Error handling can trigger an integer underflow and panic.
",High,"['https://github.com/briansmith/untrusted/pull/20', 'https://nvd.nist.gov/vuln/detail/CVE-2018-20989', 'https://rustsec.org/advisories/RUSTSEC-2018-0001.html', 'https://crates.io/crates/untrusted', 'https://github.com/briansmith/untrusted']"
RUSTSEC-2021-0043,uu_od,https://github.com/uutils/coreutils/tree/main/src/uu/od,['Memory Access'],2021-10-19 22:14:35+00:00,2021-02-17T12:00:00Z,"[('0', '0.0.4'), ('0.0.0-0', '0.0.4')]","Out of bounds read in uu_od
PartialReader passes uninitialized memory to user-provided Read
","An issue was discovered in PartialReader in the uu_od crate before 0.0.4 for Rust. Attackers can read the contents of uninitialized memory locations via a user-provided Read operation.
Affected versions of this crate passed an uniniitalized buffer to a
user-provided `Read` instance in `PartialReader::read`.

This can result in safe `Read` implementations reading from the uninitialized
buffer leading to undefined behavior.

The flaw was fixed in commit [`39d62c6`](https://github.com/uutils/coreutils/commit/39d62c6c1f809022c903180471c10fde6ecd12d1)
by zero-initializing the passed buffer.
",High,"['https://nvd.nist.gov/vuln/detail/CVE-2021-29934', 'https://crates.io/crates/uu_od', 'https://github.com/uutils/coreutils', 'https://rustsec.org/advisories/RUSTSEC-2021-0043.html', 'https://github.com/uutils/coreutils/issues/1729']"
GHSA-pfjq-935c-4895,v9,https://github.com/purpleposeidon/v9,"['Synchronization', 'Memory Management', 'Tainted Input']",2021-08-18 23:41:25+00:00,2021-08-25T21:00:37Z,"[('0.0.0-0', None), ('0', None)]","Data race in v9
SyncRef's clone() and debug() allow data races
Data races in v9
","v9 is a slim data engine for Data Oriented Design. An issue was discovered in the v9 crate through 2020-12-18 for Rust. There is an unconditional implementation of Sync for SyncRef<T>.
Affected versions of this crate unconditionally implement `Sync` for `SyncRef<T>`.
This definition allows data races if `&T` is accessible through `&SyncRef`.

`SyncRef<T>` derives `Clone` and `Debug`, and the default implementations of those traits access `&T` by invoking `T::clone()` & `T::fmt()`. It is possible to create data races & undefined behavior by concurrently invoking `SyncRef<T>::clone()` or `SyncRef<T>::fmt()` from multiple threads with `T: !Sync`.
Affected versions of this crate unconditionally implement `Sync` for `SyncRef<T>`.
This definition allows data races if `&T` is accessible through `&SyncRef`.

`SyncRef<T>` derives `Clone` and `Debug`, and the default implementations of those traits access `&T` by invoking `T::clone()` & `T::fmt()`. It is possible to create data races & undefined behavior by concurrently invoking `SyncRef<T>::clone()` or `SyncRef<T>::fmt()` from multiple threads with `T: !Sync`.

",High,"['https://github.com/purpleposeidon/v9', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/v9/RUSTSEC-2020-0127.md', 'https://rustsec.org/advisories/RUSTSEC-2020-0127.html', 'https://github.com/purpleposeidon/v9/issues/1', 'https://crates.io/crates/v9', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36447']"
RUSTSEC-2020-0114,va-ts,https://github.com/video-audio/va-ts,"['Memory Access', 'Synchronization', 'Memory Management']",2021-10-19 22:14:35+00:00,2020-12-22T12:00:00Z,"[('0', '0.0.4'), ('0.0.0-0', '0.0.4')]","Data race in va-ts
`Demuxer` can carry non-Send types across thread boundaries
","An issue was discovered in the va-ts crate before 0.0.4 for Rust. Because Demuxer<T> omits a required T: Send bound, a data race and memory corruption can occur.
In the affected versions of this crate, `Demuxer<T>` unconditionally implemented `Send` with no trait bounds on `T`.

This allows sending a non-Send type `T` across thread boundaries, which can cause undefined behavior like unlocking a mutex from a thread that didn't lock the mutex, or memory corruption from data race.

The flaw was corrected in commit 0562cbf by adding a `T: Send` bound to the `Send` impl for `Demuxer<T>`.
",Medium,"['https://github.com/video-audio/va-ts', 'https://github.com/video-audio/va-ts/issues/4', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36220', 'https://rustsec.org/advisories/RUSTSEC-2020-0114.html', 'https://crates.io/crates/va-ts']"
RUSTSEC-2021-0082,vec-const,https://github.com/Eolu/vec-const,"['Memory Access', 'Memory Management']",2021-10-17 22:19:40+00:00,2021-08-14T12:00:00Z,"[('0', '2.0.0'), ('0.0.0-0', '2.0.0')]","Out-of-bounds Write in vec-const
vec-const attempts to construct a Vec from a pointer to a const slice
","An issue was discovered in the vec-const crate before 2.0.0 for Rust. It tries to construct a Vec from a pointer to a const slice, leading to memory corruption.
Affected versions of this crate claimed to construct a const `Vec` with nonzero length and capacity, but that cannot be done because such a `Vec` requires a pointer from an allocator.

The implementation was later changed to just construct a `std::borrow::Cow`.
",High,"['https://github.com/Eolu/vec-const/', 'https://crates.io/crates/vec-const', 'https://nvd.nist.gov/vuln/detail/CVE-2021-45680', 'https://github.com/Eolu/vec-const/issues/1#issuecomment-898908241', 'https://rustsec.org/advisories/RUSTSEC-2021-0082.html', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/vec-const/RUSTSEC-2021-0082.md']"
RUSTSEC-2020-0157,vm-memory,https://github.com/rust-vmm/vm-memory,"['Synchronization', 'Memory Management']",2021-09-10 15:50:27+00:00,2020-06-02T12:00:00Z,"[('0.0.0-0', '0.1.1'), ('0.2.0', '0.2.1'), ('0', '0.1.1')]","Improper Synchronization and Race Condition in vm-memory
Improper Synchronization and Race Condition in vm-memory
","rust-vmm vm-memory before 0.1.1 and 0.2.x before 0.2.1 allows attackers to cause a denial of service (loss of IP networking) because read_obj and write_obj do not properly access memory. This affects aarch64 (with musl or glibc) and x86_64 (with musl).
rust-vmm vm-memory before 0.1.1 and 0.2.x before 0.2.1 allows attackers to cause a denial of service (loss of IP networking) because read_obj and write_obj do not properly access memory. This affects aarch64 (with musl or glibc) and x86_64 (with musl).
",High,"['https://github.com/rust-vmm/vm-memory/issues/93', 'https://github.com/rust-vmm/vm-memory/releases/tag/v0.1.1', 'https://nvd.nist.gov/vuln/detail/CVE-2020-13759', 'https://crates.io/crates/vm-memory', 'https://github.com/rust-vmm/vm-memory/releases/tag/v0.2.1', 'https://rustsec.org/advisories/RUSTSEC-2020-0157.html']"
GHSA-4873-36h9-wv49,wasmtime,https://github.com/bytecodealliance/wasmtime,"['Memory Access', 'Memory Management']",2021-09-17 20:05:58+00:00,2021-09-20T19:54:16Z,"[('0.26.0', '0.30.0')]","Out-of-bounds read/write and invalid free with `externref`s and GC safepoints in Wasmtime 
","### Impact

There was an invalid free and out-of-bounds read and write bug when running Wasm that uses `externref`s in Wasmtime.

To trigger this bug, Wasmtime needs to be running Wasm that uses `externref`s, the host creates non-null `externrefs`, Wasmtime performs a garbage collection (GC), and there has to be a Wasm frame on the stack that is at a GC safepoint where

* there are no live references at this safepoint, and
* there is a safepoint with live references earlier in this frame's function.

Under this scenario, Wasmtime would incorrectly use the GC stack map for the safepoint from earlier in the function instead of the empty safepoint. This would result in Wasmtime treating arbitrary stack slots as `externref`s that needed to be rooted for GC. At the *next* GC, it would be determined that nothing was referencing these bogus `externref`s (because nothing could ever reference them, because they are not really `externref`s) and then Wasmtime would deallocate them and run `<ExternRef as Drop>::drop` on them. This results in a free of memory that is not necessarily on the heap (and shouldn't be freed at this moment even if it was), as well as potential out-of-bounds reads and writes.

Even though support for `externref`s (via the reference types proposal) is enabled by default, unless you are creating non-null `externref`s in your host code or explicitly triggering GCs, you cannot be affected by this bug.

We have reason to believe that the effective impact of this bug is relatively small because usage of `externref` is currently quite rare.

### Patches

This bug has been patched and users should upgrade to Wasmtime version 0.30.0.

Additionally, we have updated [our primary `externref` fuzz target](https://github.com/bytecodealliance/wasmtime/blob/37c094faf53f1b356aab3c79d451395e4f7edb34/fuzz/fuzz_targets/table_ops.rs) such that it better exercises these code paths and we can have greater confidence in their correctness going forward.

### Workarounds

If you cannot upgrade Wasmtime at this time, you can avoid this bug by disabling the reference types proposal by passing `false` to [`wasmtime::Config::wasm_reference_types`](https://docs.rs/wasmtime/0.29.0/wasmtime/struct.Config.html#method.wasm_reference_types)

### References

* [The Wasm reference types proposal, which introduces `externref`](https://github.com/WebAssembly/reference-types/)

### For more information

If you have any questions or comments about this advisory:

* Reach out to us on [the Bytecode Alliance Zulip chat](https://bytecodealliance.zulipchat.com/#narrow/stream/217126-wasmtime)
* Open an issue in [the `bytecodealliance/wasmtime` repository](https://github.com/bytecodealliance/wasmtime/)
",Medium,"['https://github.com/bytecodealliance/wasmtime/commit/398a73f0dd862dbe703212ebae8e34036a18c11c', 'https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/Z2Z33FTXFQ6EOINVEQIP4DFBG53G5XIY/', 'https://github.com/bytecodealliance/wasmtime', 'https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-4873-36h9-wv49', 'https://crates.io/crates/wasmtime', 'https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WAVBRYDDUIY2ZR3K3FO4BVYJKIMJ5TP7/', 'https://nvd.nist.gov/vuln/detail/CVE-2021-39218']"
GHSA-88xq-w8cq-xfg7,wasmtime,https://github.com/bytecodealliance/wasmtime,['Memory Access'],2022-02-16 22:35:03+00:00,2022-02-16T22:35:03Z,"[('0', '0.33.1'), ('0.34.0', '0.34.1')]","Invalid drop of partially-initialized instances in the pooling instance allocator for modules with defined `externref` globals 
","### Impact

There exists a bug in the pooling instance allocator in Wasmtime's runtime where a failure to instantiate an instance for a module that defines an `externref` global will result in an invalid drop of a `VMExternRef` via an uninitialized pointer.

As instance slots may be reused between consecutive instantiations, the value of the uninitialized pointer may be from a previous instantiation and therefore under the control of an attacker via a module's initial values for its globals. If the attacker can somehow determine an address under their control inside the mapped memory representing the instance pool, it is possible to trick the runtime to call `drop_in_place` on a trait object under the attacker's control and therefore cause remote code execution.

Exploiting the bug to cause remote code execution would be very difficult as attackers cannot determine the addresses of globals from code executing within the WebAssembly VM and the memory space for the instance pool cannot be statically determined. Operating system mitigations, such as [address space layout randomization](https://en.wikipedia.org/wiki/Address_space_layout_randomization), would additionally increase the difficulty for attackers to determine useful executable code to target with an exploit. It is also very unlikely that attackers will be able to directly influence the conditions that trigger the bug as described below.

When the conditions to trigger the bug are met, however, it is much easier to exploit this bug to cause a denial of service by crashing the host with an invalid memory read.

The following engine configuration (via [Config](https://docs.rs/wasmtime/0.34.0/wasmtime/struct.Config.html)) is required to be impacted by this bug:

* support for the reference types proposal must be enabled (this is the default for `Config`).
* a pooling allocation strategy must be configured via [Config::allocation_strategy](https://docs.rs/wasmtime/0.34.0/wasmtime/struct.Config.html#method.allocation_strategy), which is **not the default allocation strategy**.

A module must be instantiated with **all the following characteristics**:

* The module defines at least one table or memory.
* The module defines at least one `externref` global.

During instantiation, **one of the following** must occur to cause the instantiation to fail:

* a call to `mprotect` or `VirtualAlloc` fails (e.g. out-of-memory conditions).
* a resource limiter was configured in the associated `Store` (via [Store::limiter](https://docs.rs/wasmtime/0.34.0/wasmtime/struct.Store.html#method.limiter) or [Store::limiter_async](https://docs.rs/wasmtime/0.34.0/wasmtime/struct.Store.html#method.limiter_async)) and the limiter returns `false` from the initial call to `memory_growing` or `table_growing`. **Stores do not have a resource limiter set by default**.

This results in a partially-initialized instance being dropped and that attempts to drop the uninitialized `VMExternRef` representing the defined `externref` global.

We have reason to believe that the effective impact of this bug is relatively small because the usage of `externref` is still uncommon and without a resource limiter configured on the `Store`, which is not the default configuration, it is only possible to trigger the bug from an error returned by `mprotect` or `VirtualAlloc`.

Note that on Linux with the `uffd` feature enabled, it is only possible to trigger the bug from a resource limiter as the call to `mprotect` is skipped; if no resource limiter is used, then this configuration is not vulnerable.

### Patches

The bug has been fixed in 0.34.1 and 0.33.1; users are encouraged to upgrade as soon as possible.

### Workarounds

If it is not possible to upgrade to 0.34.1 or 0.33.1 of the `wasmtime` crate, it is recommend that support for the reference types proposal be disabled by passing `false` to [Config::wasm_reference_types](https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_reference_types).

Doing so will prevent modules that use `externref` from being loaded entirely.

### For more information

If you have any questions or comments about this advisory:

* Reach out to us on [the Bytecode Alliance Zulip chat](https://bytecodealliance.zulipchat.com/#narrow/stream/217126-wasmtime)
* Open an issue in [the bytecodealliance/wasmtime repository](https://github.com/bytecodealliance/wasmtime/)
",Medium,"['https://nvd.nist.gov/vuln/detail/CVE-2022-23636', 'https://github.com/bytecodealliance/wasmtime/commit/886ecc562040bef61faf19438c22285c2d62403a', 'https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-88xq-w8cq-xfg7', 'https://github.com/bytecodealliance/wasmtime']"
GHSA-v4cp-h94r-m7xf,wasmtime,https://github.com/bytecodealliance/wasmtime,['Memory Access'],2021-09-17 20:05:21+00:00,2021-09-20T19:54:05Z,"[('0.19.0', '0.30.0')]","Use after free passing `externref`s to Wasm in Wasmtime
","### Impact

There was a use-after-free bug when passing `externref`s from the host to guest Wasm content.

To trigger the bug, you have to explicitly pass multiple `externref`s from the host to a Wasm instance at the same time, either by

* passing multiple `externref`s as arguments from host code to a Wasm function,
* or returning multiple `externref`s to Wasm from a multi-value return function defined in the host.
 
If you do not have host code that matches one of these shapes, then you are not impacted.

If Wasmtime's [`VMExternRefActivationsTable`](https://github.com/bytecodealliance/wasmtime/blob/37c094faf53f1b356aab3c79d451395e4f7edb34/crates/runtime/src/externref.rs#L493) became filled to capacity after passing the first `externref` in, then passing in the second `externref` could trigger a garbage collection. However the first `externref` is not rooted until we pass control to Wasm, and therefore could be reclaimed by the collector if nothing else was holding a reference to it or otherwise keeping it alive. Then, when control was passed to Wasm after the garbage collection, Wasm could use the first `externref`, which at this point has already been freed.

We have reason to believe that the effective impact of this bug is relatively small because usage of `externref` is currently quite rare.

### Patches

The bug has been fixed, and users should upgrade to Wasmtime 0.30.0.

Additionally, we have updated [our primary `externref` fuzz target](https://github.com/bytecodealliance/wasmtime/blob/37c094faf53f1b356aab3c79d451395e4f7edb34/fuzz/fuzz_targets/table_ops.rs) such that it better exercises these code paths and we can have greater confidence in their correctness going forward.

### Workarounds

If you cannot upgrade Wasmtime yet, you can avoid the bug by disabling reference types support in Wasmtime by passing `false` to [`wasmtime::Config::wasm_reference_types`](https://docs.rs/wasmtime/0.29.0/wasmtime/struct.Config.html#method.wasm_reference_types).

### References

* [The reference types Wasm proposal, which introduces `externref`](https://github.com/WebAssembly/reference-types/)

### For more information

If you have any questions or comments about this advisory:

* Reach out to us on [the Bytecode Alliance Zulip chat](https://bytecodealliance.zulipchat.com/#narrow/stream/217126-wasmtime)
* Open an issue in [the `bytecodealliance/wasmtime` repository](https://github.com/bytecodealliance/wasmtime/)
",Medium,"['https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/Z2Z33FTXFQ6EOINVEQIP4DFBG53G5XIY/', 'https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-v4cp-h94r-m7xf', 'https://github.com/bytecodealliance/wasmtime', 'https://crates.io/crates/wasmtime', 'https://github.com/bytecodealliance/wasmtime/commit/101998733b74624cbd348a2366d05760b40181f3', 'https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WAVBRYDDUIY2ZR3K3FO4BVYJKIMJ5TP7/', 'https://nvd.nist.gov/vuln/detail/CVE-2021-39216']"
GHSA-q879-9g95-56mx,wasmtime,https://github.com/bytecodealliance/wasmtime,['Risky Values'],2021-09-17 20:07:13+00:00,2021-09-20T19:54:26Z,"[('0', '0.30.0')]","Wrong type for `Linker`-define functions when used across two `Engine`s
","### Impact

As a Rust library the `wasmtime` crate clearly marks which functions are safe and which are `unsafe`, guaranteeing that if consumers never use `unsafe` then it should not be possible to have memory unsafety issues in their embeddings of Wasmtime. An issue was discovered in the safe API of `Linker::func_*` APIs. These APIs were previously not sound when one `Engine` was used to create the `Linker` and then a different `Engine` was used to create a `Store` and then the `Linker` was used to instantiate a module into that `Store`. Cross-`Engine` usage of functions is not supported in Wasmtime and this can result in type confusion of function pointers, resulting in being able to safely call a function with the wrong type.

Triggering this bug requires using at least two `Engine` values in an embedding and then additionally using two different values with a `Linker` (one at the creation time of the `Linker` and another when instantiating a module with the `Linker`).

It's expected that usage of more-than-one `Engine` in an embedding is relatively rare since an `Engine` is intended to be a globally shared resource, so the expectation is that the impact of this issue is relatively small.

The fix implemented is to change this behavior to `panic!()` in Rust instead of silently allowing it. Using different `Engine` instances with a `Linker` is a programmer bug that `wasmtime` catches at runtime.

### Patches

This bug has been patched and users should upgrade to Wasmtime version 0.30.0.

### Workarounds

If you cannot upgrade Wasmtime and are using more than one `Engine` in your embedding it's recommended to instead use only one `Engine` for the entire program if possible. An `Engine` is designed to be a globally shared resource that is suitable to have only one for the lifetime of an entire process. If using multiple `Engine`s is required then code should be audited to ensure that `Linker` is only used with one `Engine`.

### For more information

If you have any questions or comments about this advisory:

* Reach out to us on [the Bytecode Alliance Zulip chat](https://bytecodealliance.zulipchat.com/#narrow/stream/217126-wasmtime)
* Open an issue in [the `bytecodealliance/wasmtime` repository](https://github.com/bytecodealliance/wasmtime/)
",Medium,"['https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-q879-9g95-56mx', 'https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WAVBRYDDUIY2ZR3K3FO4BVYJKIMJ5TP7/', 'https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/Z2Z33FTXFQ6EOINVEQIP4DFBG53G5XIY/', 'https://github.com/bytecodealliance/wasmtime', 'https://crates.io/crates/wasmtime', 'https://github.com/bytecodealliance/wasmtime/commit/b39f087414f27ae40c44449ed5d1154e03449bff', 'https://nvd.nist.gov/vuln/detail/CVE-2021-39219']"
RUSTSEC-2022-0016,wasmtime,https://github.com/bytecodealliance/wasmtime,"['Memory Access', 'Memory Management']",2022-03-31 22:54:54+00:00,2022-03-31T12:00:00Z,"[('0.34.0', '0.34.2')]","Use after free with `externref`s and epoch interruption in Wasmtime
","[Use after free with `externref`s and epoch interruption in Wasmtime](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-gwc9-348x-qwv2)
",nan,"['https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-gwc9-348x-qwv2', 'https://crates.io/crates/wasmtime', 'https://rustsec.org/advisories/RUSTSEC-2022-0016.html']"
RUSTSEC-2021-0110,wasmtime,https://github.com/bytecodealliance/wasmtime,"['Memory Access', 'Memory Management']",2021-10-19 22:14:35+00:00,2021-09-17T12:00:00Z,"[('0.0.0-0', '0.30.0')]","Multiple Vulnerabilities in Wasmtime
","* [Use after free passing `externref`s to Wasm in
  Wasmtime](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-v4cp-h94r-m7xf)

* [Out-of-bounds read/write and invalid free with `externref`s and GC safepoints
  in
  Wasmtime](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-4873-36h9-wv49)

* [Wrong type for `Linker`-define functions when used across two
  `Engine`s](https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-q879-9g95-56mx)
",Medium,"['https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-q879-9g95-56mx', 'https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-v4cp-h94r-m7xf', 'https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-4873-36h9-wv49', 'https://crates.io/crates/wasmtime', 'https://rustsec.org/advisories/RUSTSEC-2021-0110.html']"
GHSA-gwc9-348x-qwv2,wasmtime,https://github.com/bytecodealliance/wasmtime,['Memory Access'],2022-04-12 23:16:15+00:00,2022-04-01T13:36:12Z,"[('0.35.0', '0.35.2'), ('0', '0.34.2')]","Use after free in Wasmtime
","There is a use after free vulnerability in Wasmtime when both running Wasm that uses `externref`s and enabling [epoch interruption](https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.epoch_interruption) in Wasmtime. If you are not explicitly enabling epoch interruption (it is disabled by default) then you are not affected. If you are explicitly disabling the Wasm reference types proposal (it is enabled by default) then you are also not affected.

The use after free is caused by Cranelift failing to emit stack maps when there are safepoints inside cold blocks. Cold blocks occur when epoch interruption is enabled. Cold blocks are emitted at the end of compiled functions, and change the order blocks are emitted versus defined. This reordering accidentally caused Cranelift to skip emitting some stack maps because it expected to emit the stack maps in block definition order, rather than block emission order. When Wasmtime would eventually collect garbage, it would fail to find live references on the stack because of the missing stack maps, think that they were unreferenced garbage, and therefore reclaim them. Then after the collection ended, the Wasm code could use the reclaimed-too-early references, which is a use after free.

This bug was discovered while extending our fuzz targets for `externref`s and GC in Wasmtime. The updated fuzz target thoroughly exercises these code paths and feature combinations now. We have also added a regression test for this bug. Released versions 0.34.2 and 0.35.2, which fix the vulnerability. We recommend all Wasmtime users upgrade to these patched versions. If upgrading is not an option for you at this time, you can avoid the vulnerability by either disabling the Wasm reference types proposal or by disabling epoch interruption if you were previously enabling it.
",High,"['https://github.com/bytecodealliance/wasmtime', 'https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-gwc9-348x-qwv2', 'https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.epoch_interruption', 'https://github.com/bytecodealliance/wasmtime/commit/666c2554ea0e1728c35aa41178cf235920db888a', 'https://github.com/WebAssembly/reference-types', 'https://nvd.nist.gov/vuln/detail/CVE-2022-24791']"
RUSTSEC-2022-0008,windows,https://github.com/microsoft/windows-rs,"['Synchronization', 'Memory Management']",2022-02-04 15:22:53+00:00,2022-01-02T12:00:00Z,"[('0.1.2', '0.32.0')]","Delegate functions are missing `Send` bound
","Affected versions of this crate did not require event handlers to have `Send` bound despite there being no guarantee of them being called on any particular thread, which can potentially lead to data races and undefined behavior.

The flaw was corrected in commit [afe3252](https://github.com/microsoft/windows-rs/commit/afe32525c22209aa8f632a0f4ad607863b51796a) by adding `Send` bounds.
",nan,"['https://rustsec.org/advisories/RUSTSEC-2022-0008.html', 'https://crates.io/crates/windows', 'https://github.com/microsoft/windows-rs/issues/1409']"
RUSTSEC-2020-0043,ws,https://github.com/housleyjk/ws-rs,['Resource Management'],2021-10-19 22:14:35+00:00,2020-09-25T12:00:00Z,"[('0.0.0-0', None), ('0', None)]","Insufficient size checks in ws
Insufficient size checks in outgoing buffer in ws allows remote attacker to run the process out of memory
","An issue was discovered in the ws crate through 2020-09-25 for Rust. The outgoing buffer is not properly limited, leading to a remote memory-consumption attack.
Affected versions of this crate did not properly check and cap the growth of the outgoing buffer.

This allows a remote attacker to take down the process by growing the buffer of their (single) connection until the process runs out of memory it can allocate and is killed.

The flaw was corrected in the [`parity-ws` fork](https://crates.io/crates/parity-ws) (>=0.10.0) by [disconnecting a client when the buffer runs full](https://github.com/housleyjk/ws-rs/pull/328).
",High,"['https://nvd.nist.gov/vuln/detail/CVE-2020-35896', 'https://crates.io/crates/ws', 'https://rustsec.org/advisories/RUSTSEC-2020-0043.html', 'https://github.com/housleyjk/ws-rs/issues/291', 'https://github.com/housleyjk/ws-rs']"
RUSTSEC-2020-0097,xcb,https://github.com/rust-x-bindings/rust-xcb,"['Memory Access', 'Synchronization', 'Memory Management']",2021-10-19 22:14:35+00:00,2020-12-10T12:00:00Z,"[('0.0.0-0', None), ('0', None)]","Memory handling issues in xcb
Soundness issue with base::Error
","An issue was discovered in the xcb crate through 2020-12-10 for Rust. base::Error does not have soundness. Because of the public ptr field, a use-after-free or double-free can occur.
`base::Error` type contains public field named `ptr`.
With this definition, it is possible to create a `base::Error` with an invalid pointer and trigger memory safety errors
such as use-after-free or double-free with safe Rust.

The users of `xcb` crate are advised not to manipulate the field.
",Medium,"['https://github.com/rtbo/rust-xcb/issues/93', 'https://github.com/rtbo/rust-xcb', 'https://crates.io/crates/xcb', 'https://rustsec.org/advisories/RUSTSEC-2020-0097.html', 'https://nvd.nist.gov/vuln/detail/CVE-2020-36205']"
GHSA-3288-cwgw-ch86,xcb,https://github.com/rust-x-bindings/rust-xcb,"['Memory Access', 'Exception Management', 'Other', 'Memory Management']",2021-08-19 17:44:05+00:00,2021-08-25T20:53:22Z,"[('0.0.0-0', '1.0.0'), ('0', None)]","Out of bounds read in xcb
Multiple soundness issues
Unchecked Return Value in xcb
Multiple soundness issues
Unchecked Return Value in xcb
","An issue was discovered in the xcb crate through 2021-02-04 for Rust. It has a soundness violation because there is an out-of-bounds read in xcb::xproto::change_property(), as demonstrated by a format=32 T=u8 situation where out-of-bounds bytes are sent to an X server.
An issue was discovered in the xcb crate through 2021-02-04 for Rust. It has a soundness violation because bytes from an X server can be interpreted as any data type returned by xcb::xproto::GetPropertyReply::value.
An issue was discovered in the xcb crate through 2021-02-04 for Rust. It has a soundness violation because transmutation to the wrong type can happen after xcb::base::cast_event uses std::mem::transmute to return a reference to an arbitrary type.
## Calls `std::str::from_utf8_unchecked()` without any checks

The function `xcb::xproto::GetAtomNameReply::name()` calls
`std::str::from_utf8_unchecked()` on the raw bytes that were received from the
X11 server without any validity checks. The X11 server only prevents interior
null bytes, but otherwise allows any X11 client to create an atom for arbitrary
bytes.

This issue is tracked here: https://github.com/rust-x-bindings/rust-xcb/issues/96

## `xcb::xproto::GetPropertyReply::value()` allows arbitrary return types

The function `xcb::xproto::GetPropertyReply::value()` returns a slice of type
`T` where `T` is an unconstrained type parameter. The raw bytes received from
the X11 server are interpreted as the requested type.

The users of the `xcb` crate are advised to only call this function with the
intended types. These are `u8`, `u16`, and `u32`.

This issue is tracked here: https://github.com/rust-x-bindings/rust-xcb/issues/95

## Out of bounds read in `xcb::xproto::change_property()`

`xcb::xproto::change_property` has (among others) the arguments `format: u8` and
`data: &[T]`. The intended use is one of the following cases:
- `format = 8` and `T = u8`
- `format = 16` and `T = u16`
- `format = 32` and `T = u32`
However, this constraint is not enforced. For example, it is possible to call
the function with `format = 32` and `T = u8`. In this case, a read beyond the
end of the `data` slice is performed and the bytes are sent to the X11 server.

The users of the `xcb` crate are advised to only call this function with one of
the intended argument combinations.

This issue is tracked here: https://github.com/rust-x-bindings/rust-xcb/issues/94

## 'Safe' wrapper around `std::mem::transmute()`

The function `xcb::base::cast_event()` takes a reference to a
`xcb::base::GenericEvent` and returns a reference to an arbitrary type, as
requested by the caller (or found via type interference). The function is
implemented as a direct call to `std::mem::transmute()`. Since the return type
is not constrained, this allows transmution to an incorrect type or a type that
is larger than the X11 event that was passed in.

X11 events are mostly always 32 bytes large and this function works as intended.

Users are advised to only cast to the event structs provided by the `xcb` crate
(and hope for the best).

This issue is tracked here: https://github.com/rust-x-bindings/rust-xcb/issues/78
An issue was discovered in the xcb crate through 2021-02-04 for Rust. It has a soundness violation because xcb::xproto::GetAtomNameReply::name() calls std::str::from_utf8_unchecked() on unvalidated bytes from an X server.
",Critical,"['https://nvd.nist.gov/vuln/detail/CVE-2021-26957', 'https://github.com/rust-x-bindings/rust-xcb/issues/96', 'https://nvd.nist.gov/vuln/detail/CVE-2021-26958', 'https://rustsec.org/advisories/RUSTSEC-2021-0019.html', 'https://github.com/rtbo/rust-xcb', 'https://crates.io/crates/xcb', 'https://nvd.nist.gov/vuln/detail/CVE-2021-26955', 'https://github.com/rust-x-bindings/rust-xcb/issues/94', 'https://github.com/rust-x-bindings/rust-xcb/issues/95', 'https://github.com/rust-x-bindings/rust-xcb/issues/78', 'https://nvd.nist.gov/vuln/detail/CVE-2021-26956', 'https://github.com/RustSec/advisory-db/issues/653']"
RUSTSEC-2018-0006,yaml-rust,https://github.com/chyh1990/yaml-rust,['Resource Management'],2021-10-19 22:14:35+00:00,2018-09-17T12:00:00Z,"[('0.0.0-0', '0.4.1'), ('0', '0.4.1')]","Uncontrolled recursion in rust-yaml
Uncontrolled recursion leads to abort in deserialization
","An issue was discovered in the yaml-rust crate before 0.4.1 for Rust. There is uncontrolled recursion during deserialization.
Affected versions of this crate did not prevent deep recursion while
deserializing data structures.

This allows an attacker to make a YAML file with deeply nested structures
that causes an abort while deserializing it.

The flaw was corrected by checking the recursion depth.

Note: `clap 2.33` is not affected by this because it uses `yaml-rust`
in a way that doesn't trigger the vulnerability. More specifically:

1. The input to the YAML parser is always trusted - is included at compile
time via `include_str!`.

2. The nesting level is never deep enough to trigger the overflow in practice
(at most 5).
",High,"['https://github.com/chyh1990/yaml-rust', 'https://crates.io/crates/yaml-rust', 'https://nvd.nist.gov/vuln/detail/CVE-2018-20993', 'https://rustsec.org/advisories/RUSTSEC-2018-0006.html', 'https://github.com/chyh1990/yaml-rust/pull/109']"
RUSTSEC-2021-0022,yottadb,https://gitlab.com/YottaDB/Lang/YDBRust,"['Memory Access', 'Memory Management']",2021-10-19 22:14:35+00:00,2021-02-09T12:00:00Z,"[('0', '1.2.0'), ('0.0.0-0', '1.2.0')]","Use-after-free in yottadb
Use-after-free in `subscript_next` and `subscript_prev` wrappers
","An issue was discovered in the yottadb crate before 1.2.0 for Rust. For some memory-allocation patterns, ydb_subscript_next_st and ydb_subscript_prev_st have a use-after-free.
Affected versions of this crate had an unsound implementation which could pass
a pointer to freed memory to `ydb_subscript_next_st` and
`ydb_subscript_prev_st` if the variable and subscripts did not have enough
memory allocated on the first call to hold the next variable in the database.

For example, the following code had undefined behavior:

```rust
let mut key = Key::variable(String::from(""a""));
Key::variable(""averylongkeywithlotsofletters"")
    .set_st(YDB_NOTTP, Vec::new(), b""some val"")
    .unwrap();
key.sub_next_self_st(YDB_NOTTP, Vec::new()).unwrap();
```

`yottadb` has no reverse-dependencies on crates.io and there are no known
instances of this API being used incorrectly in practice. The fix is backwards
compatible.

The flaw was corrected by recalculating the pointer each time it was reallocated.
",Critical,"['https://gitlab.com/YottaDB/Lang/YDBRust', 'https://rustsec.org/advisories/RUSTSEC-2021-0022.html', 'https://crates.io/crates/yottadb', 'https://nvd.nist.gov/vuln/detail/CVE-2021-27377', 'https://gitlab.com/YottaDB/Lang/YDBRust/-/issues/40']"
RUSTSEC-2021-0115,zeroize_derive,https://github.com/RustCrypto/utils/tree/master/zeroize/derive,[],2021-10-12 15:24:09+00:00,2021-09-24T12:00:00Z,"[('0.0.0-0', '1.1.1'), ('0', '1.1.1')]","Memory flaw in zeroize_derive
`#[zeroize(drop)]` doesn't implement `Drop` for `enum`s
","An issue was discovered in the zeroize_derive crate before 1.1.1 for Rust. Dropped memory is not zeroed out for an enum.
Affected versions of this crate did not implement `Drop` when `#[zeroize(drop)]` was used on an `enum`.

This can result in memory not being zeroed out after dropping it, which is exactly what is intended when adding this attribute.

The flaw was corrected in version 1.2 and `#[zeroize(drop)]` on `enum`s now properly implements `Drop`.
",Critical,"['https://github.com/RustCrypto/utils/tree/master/zeroize/derive', 'https://github.com/iqlusioninc/crates/issues/876', 'https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/zeroize_derive/RUSTSEC-2021-0115.md', 'https://crates.io/crates/zeroize_derive', 'https://nvd.nist.gov/vuln/detail/CVE-2021-45706', 'https://rustsec.org/advisories/RUSTSEC-2021-0115.html']"
